:NewParser
:ParseOnly

:lhGenOCaml
fun zip(xs, ys) = if xs is
  C(x, xt) then if ys is
    C(y, yt) then C(Pair(x, y), zip(xt, yt))
    N then N
  N then N
fun unzip(ls) = if ls is
  C(h, t) then if h is
    Pair(a, b) then if unzip(t) is
      Pair(atail, btail) then Pair(C(a, atail), C(b, btail))
  N then Pair(N, N)
fun enumFromTo(a, b) = if a < b then C(a, enumFromTo(a + 1, b)) else N
fun testUnzipZip(n) = unzip(zip(primId(enumFromTo(1, n)), primId(enumFromTo(2, n + 3))))
testUnzipZip(primId(50000))
//│ |#fun| |zip|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|x|,| |xt|)| |#then| |#if| |ys| |is|→|C|(|y|,| |yt|)| |#then| |C|(|Pair|(|x|,| |y|)|,| |zip|(|xt|,| |yt|)|)|↵|N| |#then| |N|←|↵|N| |#then| |N|←|↵|#fun| |unzip|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |is|→|Pair|(|a|,| |b|)| |#then| |#if| |unzip|(|t|)| |is|→|Pair|(|atail|,| |btail|)| |#then| |Pair|(|C|(|a|,| |atail|)|,| |C|(|b|,| |btail|)|)|←|←|↵|N| |#then| |Pair|(|N|,| |N|)|←|↵|#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |testUnzipZip|(|n|)| |#=| |unzip|(|zip|(|primId|(|enumFromTo|(|1|,| |n|)|)|,| |primId|(|enumFromTo|(|2|,| |n| |+| |3|)|)|)|)|↵|testUnzipZip|(|primId|(|50000|)|)|
//│ Parsed: {fun zip = xs, ys, => if xs is ‹(C (x, xt,)) then if ys is ‹(C (y, yt,)) then C (Pair (x, y,), zip (xt, yt,),); (N) then N›; (N) then N›; fun unzip = ls, => if ls is ‹(C (h, t,)) then if h is ‹(Pair (a, b,)) then if unzip (t,) is ‹(Pair (atail, btail,)) then Pair (C (a, atail,), C (b, btail,),)››; (N) then Pair (N, N,)›; fun enumFromTo = a, b, => if (< (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun testUnzipZip = n, => unzip (zip (primId (enumFromTo (1, n,),), primId (enumFromTo (2, + (n,) (3,),),),),); testUnzipZip (primId (50000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testUnzipZip^81(primId⁰(50000))
//│ def enumFromTo(a¹, b¹) = if (a¹ < b¹) then [C a¹ enumFromTo^43((a¹ + 1), b¹)] else [N]
//│ def testUnzipZip(n⁰) = unzip^57(zip^58(primId⁰(enumFromTo^60(1, n⁰)), primId⁰(enumFromTo^68(2, (n⁰ + 3)))))
//│ def unzip(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case h⁰ of {
//│ 		Pair a⁰ b⁰ => case unzip^20(t⁰) of {
//│ 			Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}}
//│ 	| N  => [Pair [N] [N]]}
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C x⁰ xt⁰ => case ys⁰ of {
//│ 		C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip^6(xt⁰, yt⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_1 b_1 =
//│ 		  (if (a_1 < b_1) then
//│ 		    (`C(a_1, ((enumFromTo (a_1 + 1)) b_1)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec unzip ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (match h_0 with
//│ 		        | `Pair(a_0, b_0) -> 
//│ 		          (match (unzip t_0) with
//│ 		            | `Pair(atail_0, btail_0) -> 
//│ 		              (`Pair((`C(a_0, atail_0)), (`C(b_0, btail_0))))))
//│ 		    | `N -> 
//│ 		      (`Pair((`N), (`N))));;
//│ 		let rec zip xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `C(x_0, xt_0) -> 
//│ 		      (match ys_0 with
//│ 		        | `C(y_0, yt_0) -> 
//│ 		          (`C((`Pair(x_0, y_0)), ((zip xt_0) yt_0)))
//│ 		        | `N -> 
//│ 		          (`N))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec testUnzipZip n_0 =
//│ 		  (unzip ((zip ((enumFromTo 1) n_0)) ((enumFromTo 2) (n_0 + 3))));;
//│ 		(testUnzipZip 50000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Pair x⁰ y⁰]: 5 --->
//│ 	case h⁰ of {Pair a⁰ b⁰ => case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}}: 31
//│ [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)]: 11 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case h⁰ of {Pair a⁰ b⁰ => case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}} | N  => [Pair [N] [N]]}: 35
//│ [N]: 12 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case h⁰ of {Pair a⁰ b⁰ => case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}} | N  => [Pair [N] [N]]}: 35
//│ [N]: 14 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case h⁰ of {Pair a⁰ b⁰ => case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}} | N  => [Pair [N] [N]]}: 35
//│ [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]: 29 --->
//│ 	NoCons
//│ 	case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}: 30
//│ [Pair [N] [N]]: 34 --->
//│ 	NoCons
//│ 	case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}: 30
//│ ------------------
//│ case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}: 30 --->
//│ 	[Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]: 29
//│ 	[Pair [N] [N]]: 34
//│ case h⁰ of {Pair a⁰ b⁰ => case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}}: 31 --->
//│ 	[Pair x⁰ y⁰]: 5
//│ case ls⁰ of {C h⁰ t⁰ => case h⁰ of {Pair a⁰ b⁰ => case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}} | N  => [Pair [N] [N]]}: 35 --->
//│ 	[C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)]: 11
//│ 	[N]: 12
//│ 	[N]: 14
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Pair x⁰ y⁰]: 5 --->
//│ 	case h⁰ of {Pair a⁰ b⁰ => case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}}: 31
//│ [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)]: 11 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case h⁰ of {Pair a⁰ b⁰ => case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}} | N  => [Pair [N] [N]]}: 35
//│ [N]: 12 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case h⁰ of {Pair a⁰ b⁰ => case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}} | N  => [Pair [N] [N]]}: 35
//│ [N]: 14 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case h⁰ of {Pair a⁰ b⁰ => case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}} | N  => [Pair [N] [N]]}: 35
//│ ------------------
//│ case h⁰ of {Pair a⁰ b⁰ => case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}}: 31 --->
//│ 	[Pair x⁰ y⁰]: 5
//│ case ls⁰ of {C h⁰ t⁰ => case h⁰ of {Pair a⁰ b⁰ => case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}} | N  => [Pair [N] [N]]}: 35 --->
//│ 	[C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)]: 11
//│ 	[N]: 12
//│ 	[N]: 14
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testUnzipZip(primId⁰(50000))
//│ def enumFromTo(a³, b³) = if (a³ < b³) then [C a³ enumFromTo((a³ + 1), b³)] else [N]
//│ def testUnzipZip(n¹) = unzip(zip(primId⁰(enumFromTo(1, n¹)), primId⁰(enumFromTo(2, (n¹ + 3)))))
//│ def unzip(ls¹) = ls¹(99)
//│ def zip(xs¹, ys¹) = case xs¹ of {
//│ 	C x⁰ xt⁰ => case ys¹ of {
//│ 		C y⁰ yt⁰ => 
//│ 			let t¹ = zip(xt⁰, yt⁰)
//│ 			in let h¹ = 	
//│ 				let b² = y⁰
//│ 				in let a² = x⁰
//│ 				in (fun t² -> case unzip(t²) of {
//│ 					Pair atail⁰ btail⁰ => [Pair [C a² atail⁰] [C b² btail⁰]]})
//│ 			in (fun _lh_dummy⁰ -> h¹(t¹))
//│ 		| N  => (fun _lh_dummy¹ -> [Pair [N] [N]])}
//│ 	| N  => (fun _lh_dummy² -> [Pair [N] [N]])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ unzip
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ zip -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testUnzipZip(primId⁰(50000))
//│ def enumFromTo(a¹, b¹) = if (a¹ < b¹) then [C a¹ enumFromTo((a¹ + 1), b¹)] else [N]
//│ def testUnzipZip(n⁰) = zip(primId⁰(enumFromTo(1, n⁰)), primId⁰(enumFromTo(2, (n⁰ + 3))), 99)
//│ def unzip(ls⁰) = ls⁰(99)
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C x⁰ xt⁰ => case ys⁰ of {
//│ 		C y⁰ yt⁰ => 
//│ 			let t⁰ = zip(xt⁰, yt⁰)
//│ 			in let h⁰ = 	
//│ 				let b⁰ = y⁰
//│ 				in let a⁰ = x⁰
//│ 				in (fun t¹ -> case t¹(99) of {
//│ 					Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]})
//│ 			in (fun _lh_dummy⁰ -> h⁰(t⁰))
//│ 		| N  => (fun _lh_dummy¹ -> [Pair [N] [N]])}
//│ 	| N  => (fun _lh_dummy² -> [Pair [N] [N]])}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testUnzipZip(primId⁰(50000))
//│ def enumFromTo(a¹, b¹) = if (a¹ < b¹) then [C a¹ enumFromTo((a¹ + 1), b¹)] else [N]
//│ def testUnzipZip(n⁰) = zip(primId⁰(enumFromTo(1, n⁰)), primId⁰(enumFromTo(2, (n⁰ + 3))), 99)
//│ def unzip(ls⁰) = ls⁰(99)
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C x⁰ xt⁰ => case ys⁰ of {
//│ 		C y⁰ yt⁰ => 
//│ 			let t⁰ = zip(xt⁰, yt⁰)
//│ 			in let h⁰ = 	
//│ 				let b⁰ = y⁰
//│ 				in let a⁰ = x⁰
//│ 				in (fun t¹ -> case t¹(99) of {
//│ 					Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]})
//│ 			in (fun _lh_dummy⁰ -> h⁰(t⁰))
//│ 		| N  => (fun _lh_dummy¹ -> [Pair [N] [N]])}
//│ 	| N  => (fun _lh_dummy² -> [Pair [N] [N]])}
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<



:lhGenOCaml
fun zip(xs, ys) = if xs is
  C(x, xt) then if ys is
    C(y, yt) then C(Pair(x, y), zip(xt, yt))
    N then N
  N then N
fun unzip(ls) = if ls is
  C(h, t) then if h is
    Pair(a, b) then if unzip(t) is
      Pair(atail, btail) then Pair(C(a, atail), C(b, btail))
  N then Pair(N, N)
fun makeZippedList(n) = if n > 0 then C(Pair(n, n + 1), makeZippedList(n - 1)) else N
fun testZipUnzip(n) = if unzip(primId(makeZippedList(n))) is
  Pair(xs, ys) then zip(xs, ys)
testZipUnzip(primId(50000))
//│ |#fun| |zip|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|x|,| |xt|)| |#then| |#if| |ys| |is|→|C|(|y|,| |yt|)| |#then| |C|(|Pair|(|x|,| |y|)|,| |zip|(|xt|,| |yt|)|)|↵|N| |#then| |N|←|↵|N| |#then| |N|←|↵|#fun| |unzip|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |is|→|Pair|(|a|,| |b|)| |#then| |#if| |unzip|(|t|)| |is|→|Pair|(|atail|,| |btail|)| |#then| |Pair|(|C|(|a|,| |atail|)|,| |C|(|b|,| |btail|)|)|←|←|↵|N| |#then| |Pair|(|N|,| |N|)|←|↵|#fun| |makeZippedList|(|n|)| |#=| |#if| |n| |>| |0| |#then| |C|(|Pair|(|n|,| |n| |+| |1|)|,| |makeZippedList|(|n| |-| |1|)|)| |#else| |N|↵|#fun| |testZipUnzip|(|n|)| |#=| |#if| |unzip|(|primId|(|makeZippedList|(|n|)|)|)| |is|→|Pair|(|xs|,| |ys|)| |#then| |zip|(|xs|,| |ys|)|←|↵|testZipUnzip|(|primId|(|50000|)|)|
//│ Parsed: {fun zip = xs, ys, => if xs is ‹(C (x, xt,)) then if ys is ‹(C (y, yt,)) then C (Pair (x, y,), zip (xt, yt,),); (N) then N›; (N) then N›; fun unzip = ls, => if ls is ‹(C (h, t,)) then if h is ‹(Pair (a, b,)) then if unzip (t,) is ‹(Pair (atail, btail,)) then Pair (C (a, atail,), C (b, btail,),)››; (N) then Pair (N, N,)›; fun makeZippedList = n, => if (> (n,) (0,)) then C (Pair (n, + (n,) (1,),), makeZippedList (- (n,) (1,),),) else N; fun testZipUnzip = n, => if unzip (primId (makeZippedList (n,),),) is ‹(Pair (xs, ys,)) then zip (xs, ys,)›; testZipUnzip (primId (50000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testZipUnzip^74(primId⁰(50000))
//│ def makeZippedList(n⁰) = if (n⁰ > 0) then [C [Pair n⁰ (n⁰ + 1)] makeZippedList^49((n⁰ - 1))] else [N]
//│ def testZipUnzip(n¹) = case unzip^60(primId⁰(makeZippedList^62(n¹))) of {
//│ 	Pair xs¹ ys¹ => zip^67(xs¹, ys¹)}
//│ def unzip(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case h⁰ of {
//│ 		Pair a⁰ b⁰ => case unzip^20(t⁰) of {
//│ 			Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}}
//│ 	| N  => [Pair [N] [N]]}
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C x⁰ xt⁰ => case ys⁰ of {
//│ 		C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip^6(xt⁰, yt⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec unzip ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (match h_0 with
//│ 		        | `Pair(a_0, b_0) -> 
//│ 		          (match (unzip t_0) with
//│ 		            | `Pair(atail_0, btail_0) -> 
//│ 		              (`Pair((`C(a_0, atail_0)), (`C(b_0, btail_0))))))
//│ 		    | `N -> 
//│ 		      (`Pair((`N), (`N))));;
//│ 		let rec zip xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `C(x_0, xt_0) -> 
//│ 		      (match ys_0 with
//│ 		        | `C(y_0, yt_0) -> 
//│ 		          (`C((`Pair(x_0, y_0)), ((zip xt_0) yt_0)))
//│ 		        | `N -> 
//│ 		          (`N))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec makeZippedList n_0 =
//│ 		  (if (n_0 > 0) then
//│ 		    (`C((`Pair(n_0, (n_0 + 1))), (makeZippedList (n_0 - 1))))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec testZipUnzip n_1 =
//│ 		  (match (unzip (makeZippedList n_1)) with
//│ 		    | `Pair(xs_1, ys_1) -> 
//│ 		      ((zip xs_1) ys_1));;
//│ 		(testZipUnzip 50000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a⁰ atail⁰]: 25 --->
//│ 	case xs⁰ of {C x⁰ xt⁰ => case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]} | N  => [N]}: 15
//│ [C b⁰ btail⁰]: 28 --->
//│ 	case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]}: 13
//│ [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]: 29 --->
//│ 	case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}: 30
//│ 	case unzip(primId⁰(makeZippedList(n¹))) of {Pair xs¹ ys¹ => zip(xs¹, ys¹)}: 72
//│ [N]: 32 --->
//│ 	case xs⁰ of {C x⁰ xt⁰ => case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]} | N  => [N]}: 15
//│ [N]: 33 --->
//│ 	case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]}: 13
//│ [Pair [N] [N]]: 34 --->
//│ 	case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}: 30
//│ 	case unzip(primId⁰(makeZippedList(n¹))) of {Pair xs¹ ys¹ => zip(xs¹, ys¹)}: 72
//│ ------------------
//│ case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]}: 13 --->
//│ 	[C b⁰ btail⁰]: 28
//│ 	[N]: 33
//│ case xs⁰ of {C x⁰ xt⁰ => case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]} | N  => [N]}: 15 --->
//│ 	[C a⁰ atail⁰]: 25
//│ 	[N]: 32
//│ case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}: 30 --->
//│ 	[Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]: 29
//│ 	[Pair [N] [N]]: 34
//│ case unzip(primId⁰(makeZippedList(n¹))) of {Pair xs¹ ys¹ => zip(xs¹, ys¹)}: 72 --->
//│ 	[Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]: 29
//│ 	[Pair [N] [N]]: 34
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C a⁰ atail⁰]: 25 --->
//│ 	case xs⁰ of {C x⁰ xt⁰ => case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]} | N  => [N]}: 15
//│ [C b⁰ btail⁰]: 28 --->
//│ 	case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]}: 13
//│ [N]: 32 --->
//│ 	case xs⁰ of {C x⁰ xt⁰ => case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]} | N  => [N]}: 15
//│ [N]: 33 --->
//│ 	case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]}: 13
//│ ------------------
//│ case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]}: 13 --->
//│ 	[C b⁰ btail⁰]: 28
//│ 	[N]: 33
//│ case xs⁰ of {C x⁰ xt⁰ => case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]} | N  => [N]}: 15 --->
//│ 	[C a⁰ atail⁰]: 25
//│ 	[N]: 32
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testZipUnzip(primId⁰(50000))
//│ def makeZippedList(n²) = if (n² > 0) then [C [Pair n² (n² + 1)] makeZippedList((n² - 1))] else [N]
//│ def testZipUnzip(n³) = case unzip(primId⁰(makeZippedList(n³))) of {
//│ 	Pair xs¹ ys¹ => zip(xs¹, ys¹)}
//│ def unzip(ls¹) = case ls¹ of {
//│ 	C h⁰ t⁰ => case h⁰ of {
//│ 		Pair a⁰ b⁰ => case unzip(t⁰) of {
//│ 			Pair atail⁰ btail⁰ => [Pair 
//│ 				let xt¹ = atail⁰
//│ 				in let x¹ = a⁰
//│ 				in (fun ys³ -> ys³(xt¹, x¹)) 
//│ 				let yt¹ = btail⁰
//│ 				in let y¹ = b⁰
//│ 				in (fun xt² -> (fun x² -> [C [Pair x² y¹] zip(xt², yt¹)]))]}}
//│ 	| N  => [Pair (fun ys⁴ -> [N]) (fun xt³ -> (fun x³ -> [N]))]}
//│ def zip(xs², ys²) = xs²(ys²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ zip
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ unzip -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testZipUnzip(primId⁰(50000))
//│ def makeZippedList(n⁰) = if (n⁰ > 0) then [C [Pair n⁰ (n⁰ + 1)] makeZippedList((n⁰ - 1))] else [N]
//│ def testZipUnzip(n¹) = case unzip(primId⁰(makeZippedList(n¹))) of {
//│ 	Pair xs¹ ys³ => xs¹(ys³)}
//│ def unzip(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case h⁰ of {
//│ 		Pair a⁰ b⁰ => case unzip(t⁰) of {
//│ 			Pair atail⁰ btail⁰ => [Pair 
//│ 				let xt⁰ = atail⁰
//│ 				in let x⁰ = a⁰
//│ 				in (fun ys¹ -> ys¹(xt⁰, x⁰)) 
//│ 				let yt⁰ = btail⁰
//│ 				in let y⁰ = b⁰
//│ 				in (fun xt¹ -> (fun x¹ -> [C [Pair x¹ y⁰] xt¹(yt⁰)]))]}}
//│ 	| N  => [Pair (fun ys² -> [N]) (fun xt² -> (fun x² -> [N]))]}
//│ def zip(xs⁰, ys⁰) = xs⁰(ys⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testZipUnzip(primId⁰(50000))
//│ def makeZippedList(n⁰) = if (n⁰ > 0) then [C [Pair n⁰ (n⁰ + 1)] makeZippedList((n⁰ - 1))] else [N]
//│ def testZipUnzip(n¹) = case unzip(primId⁰(makeZippedList(n¹))) of {
//│ 	Pair xs¹ ys³ => xs¹(ys³)}
//│ def unzip(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case h⁰ of {
//│ 		Pair a⁰ b⁰ => case unzip(t⁰) of {
//│ 			Pair atail⁰ btail⁰ => [Pair 
//│ 				let xt⁰ = atail⁰
//│ 				in let x⁰ = a⁰
//│ 				in (fun ys¹ -> ys¹(xt⁰, x⁰)) 
//│ 				let yt⁰ = btail⁰
//│ 				in let y⁰ = b⁰
//│ 				in (fun xt¹ -> (fun x¹ -> [C [Pair x¹ y⁰] xt¹(yt⁰)]))]}}
//│ 	| N  => [Pair (fun ys² -> [N]) (fun xt² -> (fun x² -> [N]))]}
//│ def zip(xs⁰, ys⁰) = xs⁰(ys⁰)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
fun zip(xs, ys) = if xs is
  C(x, xt) then if ys is
    C(y, yt) then C(Pair(x, y), zip(xt, yt))
    N then N
  N then N
fun unzip(ls) = if ls is
  C(h, t) then if h is
    Pair(a, b) then if unzip(t) is
      Pair(atail, btail) then Pair(C(a, atail), C(b, btail))
  N then Pair(N, N)
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun makeZippedList(n) = if n > 0 then C(Pair(n, n + 1), makeZippedList(n - 1)) else N
fun testZipMapBothUnzip(n) = if unzip(primId(makeZippedList(n))) is
  Pair(xs, ys) then zip(
    map(x => x + 1, xs),
    map(x => x * x, ys)
  )
testZipMapBothUnzip(primId(50000))
//│ |#fun| |zip|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|x|,| |xt|)| |#then| |#if| |ys| |is|→|C|(|y|,| |yt|)| |#then| |C|(|Pair|(|x|,| |y|)|,| |zip|(|xt|,| |yt|)|)|↵|N| |#then| |N|←|↵|N| |#then| |N|←|↵|#fun| |unzip|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |is|→|Pair|(|a|,| |b|)| |#then| |#if| |unzip|(|t|)| |is|→|Pair|(|atail|,| |btail|)| |#then| |Pair|(|C|(|a|,| |atail|)|,| |C|(|b|,| |btail|)|)|←|←|↵|N| |#then| |Pair|(|N|,| |N|)|←|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |makeZippedList|(|n|)| |#=| |#if| |n| |>| |0| |#then| |C|(|Pair|(|n|,| |n| |+| |1|)|,| |makeZippedList|(|n| |-| |1|)|)| |#else| |N|↵|#fun| |testZipMapBothUnzip|(|n|)| |#=| |#if| |unzip|(|primId|(|makeZippedList|(|n|)|)|)| |is|→|Pair|(|xs|,| |ys|)| |#then| |zip|(|→|map|(|x| |=>| |x| |+| |1|,| |xs|)|,|↵|map|(|x| |=>| |x| |*| |x|,| |ys|)|←|↵|)|←|↵|testZipMapBothUnzip|(|primId|(|50000|)|)|
//│ Parsed: {fun zip = xs, ys, => if xs is ‹(C (x, xt,)) then if ys is ‹(C (y, yt,)) then C (Pair (x, y,), zip (xt, yt,),); (N) then N›; (N) then N›; fun unzip = ls, => if ls is ‹(C (h, t,)) then if h is ‹(Pair (a, b,)) then if unzip (t,) is ‹(Pair (atail, btail,)) then Pair (C (a, atail,), C (b, btail,),)››; (N) then Pair (N, N,)›; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun makeZippedList = n, => if (> (n,) (0,)) then C (Pair (n, + (n,) (1,),), makeZippedList (- (n,) (1,),),) else N; fun testZipMapBothUnzip = n, => if unzip (primId (makeZippedList (n,),),) is ‹(Pair (xs, ys,)) then zip (map (x, => + (x,) (1,), xs,), map (x, => * (x,) (x,), ys,),)›; testZipMapBothUnzip (primId (50000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testZipMapBothUnzip^106(primId⁰(50000))
//│ def makeZippedList(n⁰) = if (n⁰ > 0) then [C [Pair n⁰ (n⁰ + 1)] makeZippedList^63((n⁰ - 1))] else [N]
//│ def map(f⁰, ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => [C f⁰(h¹) map^41(f⁰, t¹)]
//│ 	| N  => [N]}
//│ def testZipMapBothUnzip(n¹) = case unzip^74(primId⁰(makeZippedList^76(n¹))) of {
//│ 	Pair xs¹ ys¹ => zip^81(map^82((fun x¹ -> (x¹ + 1)), xs¹), map^93((fun x² -> (x² * x²)), ys¹))}
//│ def unzip(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case h⁰ of {
//│ 		Pair a⁰ b⁰ => case unzip^20(t⁰) of {
//│ 			Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}}
//│ 	| N  => [Pair [N] [N]]}
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C x⁰ xt⁰ => case ys⁰ of {
//│ 		C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip^6(xt⁰, yt⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec map f_0 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (`C((f_0 h_1), ((map f_0) t_1)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec makeZippedList n_0 =
//│ 		  (if (n_0 > 0) then
//│ 		    (`C((`Pair(n_0, (n_0 + 1))), (makeZippedList (n_0 - 1))))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec zip xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `C(x_0, xt_0) -> 
//│ 		      (match ys_0 with
//│ 		        | `C(y_0, yt_0) -> 
//│ 		          (`C((`Pair(x_0, y_0)), ((zip xt_0) yt_0)))
//│ 		        | `N -> 
//│ 		          (`N))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec unzip ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (match h_0 with
//│ 		        | `Pair(a_0, b_0) -> 
//│ 		          (match (unzip t_0) with
//│ 		            | `Pair(atail_0, btail_0) -> 
//│ 		              (`Pair((`C(a_0, atail_0)), (`C(b_0, btail_0))))))
//│ 		    | `N -> 
//│ 		      (`Pair((`N), (`N))));;
//│ 		let rec testZipMapBothUnzip n_1 =
//│ 		  (match (unzip (makeZippedList n_1)) with
//│ 		    | `Pair(xs_1, ys_1) -> 
//│ 		      ((zip ((map (fun x_1 -> 
//│ 		        (x_1 + 1))) xs_1)) ((map (fun x_2 -> 
//│ 		        (x_2 * x_2))) ys_1)));;
//│ 		(testZipMapBothUnzip 50000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a⁰ atail⁰]: 25 --->
//│ 	case ls¹ of {C h¹ t¹ => [C f⁰(h¹) map(f⁰, t¹)] | N  => [N]}: 48
//│ [C b⁰ btail⁰]: 28 --->
//│ 	case ls¹ of {C h¹ t¹ => [C f⁰(h¹) map(f⁰, t¹)] | N  => [N]}: 48
//│ [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]: 29 --->
//│ 	case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}: 30
//│ 	case unzip(primId⁰(makeZippedList(n¹))) of {Pair xs¹ ys¹ => zip(map((fun x¹ -> (x¹ + 1)), xs¹), map((fun x² -> (x² * x²)), ys¹))}: 104
//│ [N]: 32 --->
//│ 	case ls¹ of {C h¹ t¹ => [C f⁰(h¹) map(f⁰, t¹)] | N  => [N]}: 48
//│ [N]: 33 --->
//│ 	case ls¹ of {C h¹ t¹ => [C f⁰(h¹) map(f⁰, t¹)] | N  => [N]}: 48
//│ [Pair [N] [N]]: 34 --->
//│ 	case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}: 30
//│ 	case unzip(primId⁰(makeZippedList(n¹))) of {Pair xs¹ ys¹ => zip(map((fun x¹ -> (x¹ + 1)), xs¹), map((fun x² -> (x² * x²)), ys¹))}: 104
//│ [C f⁰(h¹) map(f⁰, t¹)]: 46 --->
//│ 	case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]}: 13
//│ 	case xs⁰ of {C x⁰ xt⁰ => case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]} | N  => [N]}: 15
//│ [N]: 47 --->
//│ 	case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]}: 13
//│ 	case xs⁰ of {C x⁰ xt⁰ => case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]} | N  => [N]}: 15
//│ ------------------
//│ case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]}: 13 --->
//│ 	[C f⁰(h¹) map(f⁰, t¹)]: 46
//│ 	[N]: 47
//│ case xs⁰ of {C x⁰ xt⁰ => case ys⁰ of {C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)] | N  => [N]} | N  => [N]}: 15 --->
//│ 	[C f⁰(h¹) map(f⁰, t¹)]: 46
//│ 	[N]: 47
//│ case unzip(t⁰) of {Pair atail⁰ btail⁰ => [Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]}: 30 --->
//│ 	[Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]: 29
//│ 	[Pair [N] [N]]: 34
//│ case ls¹ of {C h¹ t¹ => [C f⁰(h¹) map(f⁰, t¹)] | N  => [N]}: 48 --->
//│ 	[C a⁰ atail⁰]: 25
//│ 	[C b⁰ btail⁰]: 28
//│ 	[N]: 32
//│ 	[N]: 33
//│ case unzip(primId⁰(makeZippedList(n¹))) of {Pair xs¹ ys¹ => zip(map((fun x¹ -> (x¹ + 1)), xs¹), map((fun x² -> (x² * x²)), ys¹))}: 104 --->
//│ 	[Pair [C a⁰ atail⁰] [C b⁰ btail⁰]]: 29
//│ 	[Pair [N] [N]]: 34
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C a⁰ atail⁰]: 25 --->
//│ 	case ls¹ of {C h¹ t¹ => [C f⁰(h¹) map(f⁰, t¹)] | N  => [N]}: 48
//│ [C b⁰ btail⁰]: 28 --->
//│ 	case ls¹ of {C h¹ t¹ => [C f⁰(h¹) map(f⁰, t¹)] | N  => [N]}: 48
//│ [N]: 32 --->
//│ 	case ls¹ of {C h¹ t¹ => [C f⁰(h¹) map(f⁰, t¹)] | N  => [N]}: 48
//│ [N]: 33 --->
//│ 	case ls¹ of {C h¹ t¹ => [C f⁰(h¹) map(f⁰, t¹)] | N  => [N]}: 48
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C f⁰(h¹) map(f⁰, t¹)] | N  => [N]}: 48 --->
//│ 	[C a⁰ atail⁰]: 25
//│ 	[C b⁰ btail⁰]: 28
//│ 	[N]: 32
//│ 	[N]: 33
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testZipMapBothUnzip(primId⁰(50000))
//│ def makeZippedList(n³) = if (n³ > 0) then [C [Pair n³ (n³ + 1)] makeZippedList((n³ - 1))] else [N]
//│ def map(f¹, ls²) = ls²(f¹)
//│ def testZipMapBothUnzip(n²) = case unzip(primId⁰(makeZippedList(n²))) of {
//│ 	Pair xs¹ ys¹ => zip(map((fun x³ -> (x³ + 1)), xs¹), map((fun x⁴ -> (x⁴ * x⁴)), ys¹))}
//│ def unzip(ls³) = case ls³ of {
//│ 	C h⁰ t⁰ => case h⁰ of {
//│ 		Pair a⁰ b⁰ => case unzip(t⁰) of {
//│ 			Pair atail⁰ btail⁰ => [Pair 
//│ 				let t² = atail⁰
//│ 				in let h² = a⁰
//│ 				in (fun f² -> [C f²(h²) map(f², t²)]) 
//│ 				let t³ = btail⁰
//│ 				in let h³ = b⁰
//│ 				in (fun f³ -> [C f³(h³) map(f³, t³)])]}}
//│ 	| N  => [Pair (fun f⁴ -> [N]) (fun f⁵ -> [N])]}
//│ def zip(xs², ys²) = case xs² of {
//│ 	C x⁰ xt⁰ => case ys² of {
//│ 		C y⁰ yt⁰ => [C [Pair x⁰ y⁰] zip(xt⁰, yt⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ unzip -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testZipMapBothUnzip(primId⁰(50000))
//│ def makeZippedList(n¹) = if (n¹ > 0) then [C [Pair n¹ (n¹ + 1)] makeZippedList((n¹ - 1))] else [N]
//│ def map(f⁰, ls⁰) = ls⁰(f⁰)
//│ def testZipMapBothUnzip(n⁰) = case unzip(primId⁰(makeZippedList(n⁰))) of {
//│ 	Pair xs⁰ ys⁰ => zip(xs⁰((fun x⁰ -> (x⁰ + 1))), ys⁰((fun x¹ -> (x¹ * x¹))))}
//│ def unzip(ls¹) = case ls¹ of {
//│ 	C h⁰ t⁰ => case h⁰ of {
//│ 		Pair a⁰ b⁰ => case unzip(t⁰) of {
//│ 			Pair atail⁰ btail⁰ => [Pair 
//│ 				let t¹ = atail⁰
//│ 				in let h¹ = a⁰
//│ 				in (fun f¹ -> [C f¹(h¹) t¹(f¹)]) 
//│ 				let t² = btail⁰
//│ 				in let h² = b⁰
//│ 				in (fun f² -> [C f²(h²) t²(f²)])]}}
//│ 	| N  => [Pair (fun f³ -> [N]) (fun f⁴ -> [N])]}
//│ def zip(xs¹, ys¹) = case xs¹ of {
//│ 	C x² xt⁰ => case ys¹ of {
//│ 		C y⁰ yt⁰ => [C [Pair x² y⁰] zip(xt⁰, yt⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testZipMapBothUnzip(primId⁰(50000))
//│ def makeZippedList(n¹) = if (n¹ > 0) then [C [Pair n¹ (n¹ + 1)] makeZippedList((n¹ - 1))] else [N]
//│ def map(f⁰, ls⁰) = ls⁰(f⁰)
//│ def testZipMapBothUnzip(n⁰) = case unzip(primId⁰(makeZippedList(n⁰))) of {
//│ 	Pair xs⁰ ys⁰ => zip(xs⁰((fun x⁰ -> (x⁰ + 1))), ys⁰((fun x¹ -> (x¹ * x¹))))}
//│ def unzip(ls¹) = case ls¹ of {
//│ 	C h⁰ t⁰ => case h⁰ of {
//│ 		Pair a⁰ b⁰ => case unzip(t⁰) of {
//│ 			Pair atail⁰ btail⁰ => [Pair 
//│ 				let t¹ = atail⁰
//│ 				in let h¹ = a⁰
//│ 				in (fun f¹ -> [C f¹(h¹) t¹(f¹)]) 
//│ 				let t² = btail⁰
//│ 				in let h² = b⁰
//│ 				in (fun f² -> [C f²(h²) t²(f²)])]}}
//│ 	| N  => [Pair (fun f³ -> [N]) (fun f⁴ -> [N])]}
//│ def zip(xs¹, ys¹) = case xs¹ of {
//│ 	C x² xt⁰ => case ys¹ of {
//│ 		C y⁰ yt⁰ => [C [Pair x² y⁰] zip(xt⁰, yt⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
