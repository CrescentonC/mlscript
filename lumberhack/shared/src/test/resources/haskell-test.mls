:NewParser
:ParseOnly

:lhhaskell
test len = map (\x -> x + 1) $ map (\x -> x + x) [1..len]
test $ primId 10
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ test₀^256(primId⁰(10))
//│ def enumFromTo₀(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo₀^218((a² + 1), b²)] else [LH_N]
//│ def map₀(f⁴, ls⁷) = case ls⁷ of {
//│ 	LH_C h⁷ t⁸ => [LH_C f⁴(h⁷) map₀^188(f⁴, t⁸)]
//│ 	| LH_N  => [LH_N]}
//│ def map₁(f⁵, ls⁸) = case ls⁸ of {
//│ 	LH_C h⁸ t⁹ => [LH_C f⁵(h⁸) map₁^202(f⁵, t⁹)]
//│ 	| LH_N  => [LH_N]}
//│ def test₀(_lh_test_arg1¹) = map₀^232((fun x² -> (x² + 1)), map₁^240((fun x³ -> (x³ + x³)), enumFromTo₀^248(1, _lh_test_arg1¹)))
//│ 		---------- unoptimized haskell gen ----------
//│ 		(test₀ 10)
//│ 		map₀ f⁴ ls⁷ = (case ls⁷ of {(h⁷ : t⁸) -> ((f⁴ h⁷):((map₀ f⁴) t⁸)); [] -> []})
//│ 		map₁ f⁵ ls⁸ = (case ls⁸ of {(h⁸ : t⁹) -> ((f⁵ h⁸):((map₁ f⁵) t⁹)); [] -> []})
//│ 		enumFromTo₀ a² b² = (if (a² <= b²) then (a²:((enumFromTo₀ (a² + 1)) b²)) else [])
//│ 		test₀ _lh_test_arg1¹ = ((map₀ (\x² -> (x² + 1))) ((map₁ (\x³ -> (x³ + x³))) ((enumFromTo₀ 1) _lh_test_arg1¹)))
//│ 		---------- unoptimized haskell gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [test₀^256]
//│ 	[test₀^256 · enumFromTo₀^248] (hopeless to continue)
//│ 		[test₀^256 · enumFromTo₀^248 · enumFromTo₀^218] ---> [test₀^256 · enumFromTo₀^248] (using original def)
//│ 	[test₀^256 · map₀^232]
//│ 		[test₀^256 · map₀^232 · map₀^188] ---> [test₀^256 · map₀^232] (only one)
//│ 	[test₀^256 · map₁^240] (hopeless to continue)
//│ 		[test₀^256 · map₁^240 · map₁^202] ---> [test₀^256 · map₁^240] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ test₀₀(primId⁰(10))
//│ def test₀₀(_lh_test_arg1¹) = 
//│ 	map₀₀((fun x² -> (x² + 1)), map₁₀((fun x³ -> (x³ + x³)), enumFromTo₀₀(1, _lh_test_arg1¹)))
//│ 	where
//│ 	def enumFromTo₀₀(a¹, b¹) = 
//│ 		if (a¹ <= b¹) then [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)] else [LH_N]
//│ 	def map₀₀(f³, ls³) = 
//│ 		case ls³ of {
//│ 			LH_C h³ t³ => [LH_C f³(h³) map₀₀(f³, t³)]
//│ 			| LH_N  => [LH_N]}
//│ 	def map₁₀(f², ls²) = 
//│ 		case ls² of {
//│ 			LH_C h² t² => [LH_C f²(h²) map₁₀(f², t²)]
//│ 			| LH_N  => [LH_N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f²(h²) map₁₀(f², t²)]: 87 --->
//│ 	case ls³ of {LH_C h³ t³ => [LH_C f³(h³) map₀₀(f³, t³)] | LH_N  => [LH_N]}: 103
//│ [LH_N]: 88 --->
//│ 	case ls³ of {LH_C h³ t³ => [LH_C f³(h³) map₀₀(f³, t³)] | LH_N  => [LH_N]}: 103
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 145 --->
//│ 	case ls² of {LH_C h² t² => [LH_C f²(h²) map₁₀(f², t²)] | LH_N  => [LH_N]}: 89
//│ [LH_N]: 146 --->
//│ 	case ls² of {LH_C h² t² => [LH_C f²(h²) map₁₀(f², t²)] | LH_N  => [LH_N]}: 89
//│ ------------------
//│ case ls² of {LH_C h² t² => [LH_C f²(h²) map₁₀(f², t²)] | LH_N  => [LH_N]}: 89 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 145
//│ 	[LH_N]: 146
//│ case ls³ of {LH_C h³ t³ => [LH_C f³(h³) map₀₀(f³, t³)] | LH_N  => [LH_N]}: 103 --->
//│ 	[LH_C f²(h²) map₁₀(f², t²)]: 87
//│ 	[LH_N]: 88
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f²(h²) map₁₀(f², t²)]: 87 --->
//│ 	case ls³ of {LH_C h³ t³ => [LH_C f³(h³) map₀₀(f³, t³)] | LH_N  => [LH_N]}: 103
//│ [LH_N]: 88 --->
//│ 	case ls³ of {LH_C h³ t³ => [LH_C f³(h³) map₀₀(f³, t³)] | LH_N  => [LH_N]}: 103
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 145 --->
//│ 	case ls² of {LH_C h² t² => [LH_C f²(h²) map₁₀(f², t²)] | LH_N  => [LH_N]}: 89
//│ [LH_N]: 146 --->
//│ 	case ls² of {LH_C h² t² => [LH_C f²(h²) map₁₀(f², t²)] | LH_N  => [LH_N]}: 89
//│ ------------------
//│ case ls² of {LH_C h² t² => [LH_C f²(h²) map₁₀(f², t²)] | LH_N  => [LH_N]}: 89 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 145
//│ 	[LH_N]: 146
//│ case ls³ of {LH_C h³ t³ => [LH_C f³(h³) map₀₀(f³, t³)] | LH_N  => [LH_N]}: 103 --->
//│ 	[LH_C f²(h²) map₁₀(f², t²)]: 87
//│ 	[LH_N]: 88
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ test₀₀(primId⁰(10))
//│ def test₀₀(_lh_test_arg1²) = 
//│ 	map₀₀((fun x⁴ -> (x⁴ + 1)), map₁₀((fun x⁵ -> (x⁵ + x⁵)), enumFromTo₀₀(1, _lh_test_arg1²)))
//│ 	where
//│ 	def enumFromTo₀₀(a², b²) = 
//│ 		if (a² <= b²) then 
//│ 			let h⁴ = a²
//│ 			in let t⁴ = enumFromTo₀₀((a² + 1), b²)
//│ 			in (fun f⁶ -> 
//│ 				let h⁵ = f⁶(h⁴)
//│ 				in let t⁵ = map₁₀(f⁶, t⁴)
//│ 				in (fun f⁷ -> [LH_C f⁷(h⁵) map₀₀(f⁷, t⁵)])) else (fun f⁸ -> (fun f⁹ -> [LH_N]))
//│ 	def map₀₀(f⁵, ls⁵) = 
//│ 		ls⁵(f⁵)
//│ 	def map₁₀(f⁴, ls⁴) = 
//│ 		ls⁴(f⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated Haskell Code >>>>>>>>>>
//│ (test₀₀ 10)
//│ map₁₀ f⁰ ls⁰ = (ls⁰ f⁰)
//│ map₀₀ f¹ ls¹ = (ls¹ f¹)
//│ test₀₀ _lh_test_arg1⁰ = ((map₀₀ (\x⁰ -> (x⁰ + 1))) ((map₁₀ (\x¹ -> (x¹ + x¹))) ((enumFromTo₀₀ 1) _lh_test_arg1⁰)))
//│ enumFromTo₀₀ a⁰ b⁰ = (if (a⁰ <= b⁰) then (let h⁰ = a⁰ in (let t⁰ = ((enumFromTo₀₀ (a⁰ + 1)) b⁰) in (\f² -> (let h¹ = (f² h⁰) in (let t¹ = ((map₁₀ f²) t⁰) in (\f³ -> ((f³ h¹):((map₀₀ f³) t¹)))))))) else (\f⁴ f⁵ -> []))
//│ <<<<<<<<<< Generated Haskell Code <<<<<<<<<<


:lhhaskell
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = [ (q:b) | b <- gen (n-1) nq, q <- (primId [1..nq]), safe q 1 b ]
nsoln nq = length (gen nq nq)
test n = nsoln n
test $ primId 4
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ test₀^433(primId⁰(4))
//│ def enumFromTo₀(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo₀^408((a² + 1), b²)] else [LH_N]
//│ def gen₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 			LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 				let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 					LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀^295(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 					| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 				in _lh_listcomp_fun³(primId⁰(enumFromTo₀^320(1, _lh_gen_arg2¹)))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun²(gen₀^332((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length₀(ls⁷) = case ls⁷ of {
//│ 	LH_C h⁷ t⁸ => (1 + length₀^426(t⁸))
//│ 	| LH_N  => 0}
//│ def nsoln₀(_lh_nsoln_arg1¹) = length₀^281(gen₀^282(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀^383(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))
//│ 	| _  => error⁰("match error")}
//│ def test₀(_lh_test_arg1¹) = nsoln₀^346(_lh_test_arg1¹)
//│ 		---------- unoptimized haskell gen ----------
//│ 		(test₀ 4)
//│ 		nsoln₀ _lh_nsoln_arg1¹ = (length₀ ((gen₀ _lh_nsoln_arg1¹) _lh_nsoln_arg1¹))
//│ 		gen₀ _lh_gen_arg1¹ _lh_gen_arg2¹ = (case _lh_gen_arg1¹ of {0 -> ([]:[]); _ -> (let _lh_listcomp_fun² = (\_lh_listcomp_fun_para² -> (case _lh_listcomp_fun_para² of {(_lh_listcomp_fun_ls_h² : _lh_listcomp_fun_ls_t²) -> (let _lh_listcomp_fun³ = (\_lh_listcomp_fun_para³ -> (case _lh_listcomp_fun_para³ of {(_lh_listcomp_fun_ls_h³ : _lh_listcomp_fun_ls_t³) -> (if (((safe₀ _lh_listcomp_fun_ls_h³) 1) _lh_listcomp_fun_ls_h²) then ((_lh_listcomp_fun_ls_h³:_lh_listcomp_fun_ls_h²):(_lh_listcomp_fun³ _lh_listcomp_fun_ls_t³)) else (_lh_listcomp_fun³ _lh_listcomp_fun_ls_t³)); [] -> (_lh_listcomp_fun² _lh_listcomp_fun_ls_t²)})) in (_lh_listcomp_fun³ ((enumFromTo₀ 1) _lh_gen_arg2¹))); [] -> []})) in (_lh_listcomp_fun² ((gen₀ (_lh_gen_arg1¹ - 1)) _lh_gen_arg2¹)))})
//│ 		test₀ _lh_test_arg1¹ = (nsoln₀ _lh_test_arg1¹)
//│ 		safe₀ _lh_safe_arg1¹ _lh_safe_arg2¹ _lh_safe_arg3¹ = (case _lh_safe_arg3¹ of {[] -> (True ); (_lh_safe_LH_C_0¹ : _lh_safe_LH_C_1¹) -> ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && (((safe₀ _lh_safe_arg1¹) (_lh_safe_arg2¹ + 1)) _lh_safe_LH_C_1¹)); _ -> (error "match error")})
//│ 		enumFromTo₀ a² b² = (if (a² <= b²) then (a²:((enumFromTo₀ (a² + 1)) b²)) else [])
//│ 		length₀ ls⁷ = (case ls⁷ of {(h⁷ : t⁸) -> (1 + (length₀ t⁸)); [] -> 0})
//│ 		---------- unoptimized haskell gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [test₀^433] (hopeless to continue)
//│ 	[test₀^433 · nsoln₀^346] (using original def)
//│ 		[test₀^433 · nsoln₀^346 · gen₀^282] (using original def)
//│ 			[test₀^433 · nsoln₀^346 · gen₀^282 · enumFromTo₀^320] (using original def)
//│ 				[test₀^433 · nsoln₀^346 · gen₀^282 · enumFromTo₀^320 · enumFromTo₀^408] ---> [test₀^433 · nsoln₀^346 · gen₀^282 · enumFromTo₀^320] (using original def)
//│ 			[test₀^433 · nsoln₀^346 · gen₀^282 · gen₀^332] ---> [test₀^433 · nsoln₀^346 · gen₀^282] (using original def)
//│ 			[test₀^433 · nsoln₀^346 · gen₀^282 · safe₀^295] (using original def)
//│ 				[test₀^433 · nsoln₀^346 · gen₀^282 · safe₀^295 · safe₀^383] ---> [test₀^433 · nsoln₀^346 · gen₀^282 · safe₀^295] (using original def)
//│ 		[test₀^433 · nsoln₀^346 · length₀^281] (using original def)
//│ 			[test₀^433 · nsoln₀^346 · length₀^281 · length₀^426] ---> [test₀^433 · nsoln₀^346 · length₀^281] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ test₀₀(primId⁰(4))
//│ def test₀₀(_lh_test_arg1¹) = 
//│ 	nsoln₀₀(_lh_test_arg1¹)
//│ 	where
//│ 	def nsoln₀₀(_lh_nsoln_arg1¹) = 
//│ 		length₀₀(gen₀₀(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ 		where
//│ 		def gen₀₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = 
//│ 			case _lh_gen_arg1¹ of {
//│ 				0  => [LH_C [LH_N] [LH_N]]
//│ 				| _  => 
//│ 					let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 						LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 							let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 								LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 								| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 							in _lh_listcomp_fun³(primId⁰(enumFromTo₀₀(1, _lh_gen_arg2¹)))
//│ 						| LH_N  => [LH_N]})
//│ 					in _lh_listcomp_fun²(gen₀₀((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ 			where
//│ 			def enumFromTo₀₀(a¹, b¹) = 
//│ 				if (a¹ <= b¹) then [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)] else [LH_N]
//│ 			def safe₀₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = 
//│ 				case _lh_safe_arg3¹ of {
//│ 					LH_N  => [True]
//│ 					| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))
//│ 					| _  => error⁰("match error")}
//│ 		def length₀₀(ls¹) = 
//│ 			case ls¹ of {
//│ 				LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 				| LH_N  => 0}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 191 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 306
//│ [LH_N]: 192 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(primId⁰(enumFromTo₀₀(1, _lh_gen_arg2¹))) | LH_N  => [LH_N]}: 230
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 256
//│ [LH_C [LH_N] [LH_N]]: 193 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(primId⁰(enumFromTo₀₀(1, _lh_gen_arg2¹))) | LH_N  => [LH_N]}: 230
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 256
//│ [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 205 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 306
//│ [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 209 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(primId⁰(enumFromTo₀₀(1, _lh_gen_arg2¹))) | LH_N  => [LH_N]}: 230
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 256
//│ [LH_N]: 229 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(primId⁰(enumFromTo₀₀(1, _lh_gen_arg2¹))) | LH_N  => [LH_N]}: 230
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 256
//│ ------------------
//│ case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(primId⁰(enumFromTo₀₀(1, _lh_gen_arg2¹))) | LH_N  => [LH_N]}: 230 --->
//│ 	[LH_N]: 192
//│ 	[LH_C [LH_N] [LH_N]]: 193
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 209
//│ 	[LH_N]: 229
//│ case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 256 --->
//│ 	[LH_N]: 192
//│ 	[LH_C [LH_N] [LH_N]]: 193
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 209
//│ 	[LH_N]: 229
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 306 --->
//│ 	[LH_N]: 191
//│ 	[LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 205
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_N]: 191 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 306
//│ [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 205 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 306
//│ ------------------
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 306 --->
//│ 	[LH_N]: 191
//│ 	[LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 205
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ test₀₀(primId⁰(4))
//│ def test₀₀(_lh_test_arg1²) = 
//│ 	nsoln₀₀(_lh_test_arg1²)
//│ 	where
//│ 	def nsoln₀₀(_lh_nsoln_arg1²) = 
//│ 		length₀₀(gen₀₀(_lh_nsoln_arg1², _lh_nsoln_arg1²))
//│ 		where
//│ 		def gen₀₀(_lh_gen_arg1², _lh_gen_arg2²) = 
//│ 			case _lh_gen_arg1² of {
//│ 				0  => [LH_C (fun _lh_safe_arg1³ -> (fun _lh_safe_arg2³ -> [True])) [LH_N]]
//│ 				| _  => 
//│ 					let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {
//│ 						LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 							let _lh_listcomp_fun⁵ = (fun _lh_listcomp_fun_para⁵ -> case _lh_listcomp_fun_para⁵ of {
//│ 								LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C 
//│ 									let _lh_safe_LH_C_0² = _lh_listcomp_fun_ls_h³
//│ 									in let _lh_safe_LH_C_1² = _lh_listcomp_fun_ls_h²
//│ 									in (fun _lh_safe_arg1⁴ -> (fun _lh_safe_arg2⁴ -> ((((_lh_safe_arg1⁴ /= _lh_safe_LH_C_0²) && (_lh_safe_arg1⁴ /= (_lh_safe_LH_C_0² + _lh_safe_arg2⁴))) && (_lh_safe_arg1⁴ /= (_lh_safe_LH_C_0² - _lh_safe_arg2⁴))) && safe₀₀(_lh_safe_arg1⁴, (_lh_safe_arg2⁴ + 1), _lh_safe_LH_C_1²)))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t³)
//│ 								| LH_N  => _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t²)})
//│ 							in _lh_listcomp_fun⁵(primId⁰(enumFromTo₀₀(1, _lh_gen_arg2²)))
//│ 						| LH_N  => [LH_N]})
//│ 					in _lh_listcomp_fun⁴(gen₀₀((_lh_gen_arg1² - 1), _lh_gen_arg2²))}
//│ 			where
//│ 			def enumFromTo₀₀(a², b²) = 
//│ 				if (a² <= b²) then [LH_C a² enumFromTo₀₀((a² + 1), b²)] else [LH_N]
//│ 			def safe₀₀(_lh_safe_arg1², _lh_safe_arg2², _lh_safe_arg3²) = 
//│ 				_lh_safe_arg3²(_lh_safe_arg1², _lh_safe_arg2²)
//│ 		def length₀₀(ls²) = 
//│ 			case ls² of {
//│ 				LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 				| LH_N  => 0}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated Haskell Code >>>>>>>>>>
//│ (test₀₀ 4)
//│ enumFromTo₀₀ a⁰ b⁰ = (if (a⁰ <= b⁰) then (a⁰:((enumFromTo₀₀ (a⁰ + 1)) b⁰)) else [])
//│ nsoln₀₀ _lh_nsoln_arg1⁰ = (length₀₀ ((gen₀₀ _lh_nsoln_arg1⁰) _lh_nsoln_arg1⁰))
//│ safe₀₀ _lh_safe_arg1⁰ _lh_safe_arg2⁰ _lh_safe_arg3⁰ = ((_lh_safe_arg3⁰ _lh_safe_arg1⁰) _lh_safe_arg2⁰)
//│ gen₀₀ _lh_gen_arg1⁰ _lh_gen_arg2⁰ = (case _lh_gen_arg1⁰ of {0 -> ((\_lh_safe_arg1¹ _lh_safe_arg2¹ -> (True )):[]); _ -> (let _lh_listcomp_fun⁰ = (\_lh_listcomp_fun_para⁰ -> (case _lh_listcomp_fun_para⁰ of {(_lh_listcomp_fun_ls_h⁰ : _lh_listcomp_fun_ls_t⁰) -> (let _lh_listcomp_fun¹ = (\_lh_listcomp_fun_para¹ -> (case _lh_listcomp_fun_para¹ of {(_lh_listcomp_fun_ls_h¹ : _lh_listcomp_fun_ls_t¹) -> (if (((safe₀₀ _lh_listcomp_fun_ls_h¹) 1) _lh_listcomp_fun_ls_h⁰) then ((let _lh_safe_LH_C_0⁰ = _lh_listcomp_fun_ls_h¹ in (let _lh_safe_LH_C_1⁰ = _lh_listcomp_fun_ls_h⁰ in (\_lh_safe_arg1² _lh_safe_arg2² -> ((((_lh_safe_arg1² /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2²))) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2²))) && (((safe₀₀ _lh_safe_arg1²) (_lh_safe_arg2² + 1)) _lh_safe_LH_C_1⁰))))):(_lh_listcomp_fun¹ _lh_listcomp_fun_ls_t¹)) else (_lh_listcomp_fun¹ _lh_listcomp_fun_ls_t¹)); [] -> (_lh_listcomp_fun⁰ _lh_listcomp_fun_ls_t⁰)})) in (_lh_listcomp_fun¹ ((enumFromTo₀₀ 1) _lh_gen_arg2⁰))); [] -> []})) in (_lh_listcomp_fun⁰ ((gen₀₀ (_lh_gen_arg1⁰ - 1)) _lh_gen_arg2⁰)))})
//│ length₀₀ ls⁰ = (case ls⁰ of {(h⁰ : t⁰) -> (1 + (length₀₀ t⁰)); [] -> 0})
//│ test₀₀ _lh_test_arg1⁰ = (nsoln₀₀ _lh_test_arg1⁰)
//│ <<<<<<<<<< Generated Haskell Code <<<<<<<<<<


// WRONG: haskell also cannot handle `[1..nq]` in list comprehension, type error
:lhhaskell
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = [ (q:b) | b <- gen (n-1) nq, q <- [1..nq], safe q 1 b ]
nsoln nq = length (gen nq nq)
test n = nsoln n
test $ primId 4
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ test₀^429(primId⁰(4))
//│ def enumFromTo₀(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo₀^415((a² + 1), b²)] else [LH_N]
//│ def gen₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 			LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 				let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 					LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀^296(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 					| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 				in _lh_listcomp_fun³(enumFromTo₀^320(1, _lh_gen_arg2¹))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun²(gen₀^331((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length₀(ls⁷) = case ls⁷ of {
//│ 	LH_C h⁷ t⁸ => (1 + length₀^283(t⁸))
//│ 	| LH_N  => 0}
//│ def nsoln₀(_lh_nsoln_arg1¹) = length₀^397(gen₀^398(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀^378(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))
//│ 	| _  => error⁰("match error")}
//│ def test₀(_lh_test_arg1¹) = nsoln₀^405(_lh_test_arg1¹)
//│ 		---------- unoptimized haskell gen ----------
//│ 		(test₀ 4)
//│ 		length₀ ls⁷ = (case ls⁷ of {(h⁷ : t⁸) -> (1 + (length₀ t⁸)); [] -> 0})
//│ 		gen₀ _lh_gen_arg1¹ _lh_gen_arg2¹ = (case _lh_gen_arg1¹ of {0 -> ([]:[]); _ -> (let _lh_listcomp_fun² = (\_lh_listcomp_fun_para² -> (case _lh_listcomp_fun_para² of {(_lh_listcomp_fun_ls_h² : _lh_listcomp_fun_ls_t²) -> (let _lh_listcomp_fun³ = (\_lh_listcomp_fun_para³ -> (case _lh_listcomp_fun_para³ of {(_lh_listcomp_fun_ls_h³ : _lh_listcomp_fun_ls_t³) -> (if (((safe₀ _lh_listcomp_fun_ls_h³) 1) _lh_listcomp_fun_ls_h²) then ((_lh_listcomp_fun_ls_h³:_lh_listcomp_fun_ls_h²):(_lh_listcomp_fun³ _lh_listcomp_fun_ls_t³)) else (_lh_listcomp_fun³ _lh_listcomp_fun_ls_t³)); [] -> (_lh_listcomp_fun² _lh_listcomp_fun_ls_t²)})) in (_lh_listcomp_fun³ ((enumFromTo₀ 1) _lh_gen_arg2¹))); [] -> []})) in (_lh_listcomp_fun² ((gen₀ (_lh_gen_arg1¹ - 1)) _lh_gen_arg2¹)))})
//│ 		safe₀ _lh_safe_arg1¹ _lh_safe_arg2¹ _lh_safe_arg3¹ = (case _lh_safe_arg3¹ of {[] -> (True ); (_lh_safe_LH_C_0¹ : _lh_safe_LH_C_1¹) -> ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && (((safe₀ _lh_safe_arg1¹) (_lh_safe_arg2¹ + 1)) _lh_safe_LH_C_1¹)); _ -> (error "match error")})
//│ 		nsoln₀ _lh_nsoln_arg1¹ = (length₀ ((gen₀ _lh_nsoln_arg1¹) _lh_nsoln_arg1¹))
//│ 		test₀ _lh_test_arg1¹ = (nsoln₀ _lh_test_arg1¹)
//│ 		enumFromTo₀ a² b² = (if (a² <= b²) then (a²:((enumFromTo₀ (a² + 1)) b²)) else [])
//│ 		---------- unoptimized haskell gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [test₀^429] (hopeless to continue)
//│ 	[test₀^429 · nsoln₀^405] (using original def)
//│ 		[test₀^429 · nsoln₀^405 · gen₀^398] (using original def)
//│ 			[test₀^429 · nsoln₀^405 · gen₀^398 · enumFromTo₀^320] (using original def)
//│ 				[test₀^429 · nsoln₀^405 · gen₀^398 · enumFromTo₀^320 · enumFromTo₀^415] ---> [test₀^429 · nsoln₀^405 · gen₀^398 · enumFromTo₀^320] (using original def)
//│ 			[test₀^429 · nsoln₀^405 · gen₀^398 · gen₀^331] ---> [test₀^429 · nsoln₀^405 · gen₀^398] (using original def)
//│ 			[test₀^429 · nsoln₀^405 · gen₀^398 · safe₀^296] (using original def)
//│ 				[test₀^429 · nsoln₀^405 · gen₀^398 · safe₀^296 · safe₀^378] ---> [test₀^429 · nsoln₀^405 · gen₀^398 · safe₀^296] (using original def)
//│ 		[test₀^429 · nsoln₀^405 · length₀^397] (using original def)
//│ 			[test₀^429 · nsoln₀^405 · length₀^397 · length₀^283] ---> [test₀^429 · nsoln₀^405 · length₀^397] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ test₀₀(primId⁰(4))
//│ def test₀₀(_lh_test_arg1¹) = 
//│ 	nsoln₀₀(_lh_test_arg1¹)
//│ 	where
//│ 	def nsoln₀₀(_lh_nsoln_arg1¹) = 
//│ 		length₀₀(gen₀₀(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ 		where
//│ 		def gen₀₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = 
//│ 			case _lh_gen_arg1¹ of {
//│ 				0  => [LH_C [LH_N] [LH_N]]
//│ 				| _  => 
//│ 					let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 						LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 							let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 								LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 								| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 							in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹))
//│ 						| LH_N  => [LH_N]})
//│ 					in _lh_listcomp_fun²(gen₀₀((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ 			where
//│ 			def enumFromTo₀₀(a¹, b¹) = 
//│ 				if (a¹ <= b¹) then [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)] else [LH_N]
//│ 			def safe₀₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = 
//│ 				case _lh_safe_arg3¹ of {
//│ 					LH_N  => [True]
//│ 					| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))
//│ 					| _  => error⁰("match error")}
//│ 		def length₀₀(ls¹) = 
//│ 			case ls¹ of {
//│ 				LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 				| LH_N  => 0}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 157 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 291
//│ [LH_N]: 158 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 194
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 304
//│ [LH_C [LH_N] [LH_N]]: 159 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 194
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 304
//│ [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 171 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 291
//│ [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 175 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 194
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 304
//│ [LH_N]: 193 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 194
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 304
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 234 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 183
//│ [LH_N]: 235 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 183
//│ ------------------
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 183 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 234
//│ 	[LH_N]: 235
//│ case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 194 --->
//│ 	[LH_N]: 158
//│ 	[LH_C [LH_N] [LH_N]]: 159
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 175
//│ 	[LH_N]: 193
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 291 --->
//│ 	[LH_N]: 157
//│ 	[LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 171
//│ case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 304 --->
//│ 	[LH_N]: 158
//│ 	[LH_C [LH_N] [LH_N]]: 159
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 175
//│ 	[LH_N]: 193
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_N]: 157 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 291
//│ [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 171 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 291
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 234 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 183
//│ [LH_N]: 235 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 183
//│ ------------------
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 183 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 234
//│ 	[LH_N]: 235
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 291 --->
//│ 	[LH_N]: 157
//│ 	[LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 171
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ test₀₀(primId⁰(4))
//│ def test₀₀(_lh_test_arg1²) = 
//│ 	nsoln₀₀(_lh_test_arg1²)
//│ 	where
//│ 	def nsoln₀₀(_lh_nsoln_arg1²) = 
//│ 		length₀₀(gen₀₀(_lh_nsoln_arg1², _lh_nsoln_arg1²))
//│ 		where
//│ 		def gen₀₀(_lh_gen_arg1², _lh_gen_arg2²) = 
//│ 			case _lh_gen_arg1² of {
//│ 				0  => [LH_C (fun _lh_safe_arg1⁴ -> (fun _lh_safe_arg2⁴ -> [True])) [LH_N]]
//│ 				| _  => 
//│ 					let _lh_listcomp_fun⁸ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {
//│ 						LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 							let _lh_listcomp_fun⁹ = (fun _lh_listcomp_fun_para⁵ -> _lh_listcomp_fun_para⁵(_lh_listcomp_fun_ls_h², _lh_listcomp_fun⁹, _lh_listcomp_fun⁸, _lh_listcomp_fun_ls_t²))
//│ 							in _lh_listcomp_fun⁹(enumFromTo₀₀(1, _lh_gen_arg2²))
//│ 						| LH_N  => [LH_N]})
//│ 					in _lh_listcomp_fun⁸(gen₀₀((_lh_gen_arg1² - 1), _lh_gen_arg2²))}
//│ 			where
//│ 			def enumFromTo₀₀(a², b²) = 
//│ 				if (a² <= b²) then 
//│ 					let _lh_listcomp_fun_ls_h⁴ = a²
//│ 					in let _lh_listcomp_fun_ls_t⁴ = enumFromTo₀₀((a² + 1), b²)
//│ 					in (fun _lh_listcomp_fun_ls_h⁵ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_listcomp_fun⁵ -> (fun _lh_listcomp_fun_ls_t⁵ -> if safe₀₀(_lh_listcomp_fun_ls_h⁴, 1, _lh_listcomp_fun_ls_h⁵) then [LH_C 
//│ 						let _lh_safe_LH_C_0² = _lh_listcomp_fun_ls_h⁴
//│ 						in let _lh_safe_LH_C_1² = _lh_listcomp_fun_ls_h⁵
//│ 						in (fun _lh_safe_arg1² -> (fun _lh_safe_arg2² -> ((((_lh_safe_arg1² /= _lh_safe_LH_C_0²) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0² + _lh_safe_arg2²))) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0² - _lh_safe_arg2²))) && safe₀₀(_lh_safe_arg1², (_lh_safe_arg2² + 1), _lh_safe_LH_C_1²)))) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴))))) else (fun _lh_listcomp_fun_ls_h⁶ -> (fun _lh_listcomp_fun⁶ -> (fun _lh_listcomp_fun⁷ -> (fun _lh_listcomp_fun_ls_t⁶ -> _lh_listcomp_fun⁷(_lh_listcomp_fun_ls_t⁶)))))
//│ 			def safe₀₀(_lh_safe_arg1³, _lh_safe_arg2³, _lh_safe_arg3²) = 
//│ 				_lh_safe_arg3²(_lh_safe_arg1³, _lh_safe_arg2³)
//│ 		def length₀₀(ls²) = 
//│ 			case ls² of {
//│ 				LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 				| LH_N  => 0}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated Haskell Code >>>>>>>>>>
//│ (test₀₀ 4)
//│ enumFromTo₀₀ a⁰ b⁰ = (if (a⁰ <= b⁰) then (let _lh_listcomp_fun_ls_h⁰ = a⁰ in (let _lh_listcomp_fun_ls_t⁰ = ((enumFromTo₀₀ (a⁰ + 1)) b⁰) in (\_lh_listcomp_fun_ls_h¹ _lh_listcomp_fun⁰ _lh_listcomp_fun¹ _lh_listcomp_fun_ls_t¹ -> (if (((safe₀₀ _lh_listcomp_fun_ls_h⁰) 1) _lh_listcomp_fun_ls_h¹) then ((let _lh_safe_LH_C_0⁰ = _lh_listcomp_fun_ls_h⁰ in (let _lh_safe_LH_C_1⁰ = _lh_listcomp_fun_ls_h¹ in (\_lh_safe_arg1⁰ _lh_safe_arg2⁰ -> ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && (((safe₀₀ _lh_safe_arg1⁰) (_lh_safe_arg2⁰ + 1)) _lh_safe_LH_C_1⁰))))):(_lh_listcomp_fun⁰ _lh_listcomp_fun_ls_t⁰)) else (_lh_listcomp_fun⁰ _lh_listcomp_fun_ls_t⁰))))) else (\_lh_listcomp_fun_ls_h² _lh_listcomp_fun² _lh_listcomp_fun³ _lh_listcomp_fun_ls_t² -> (_lh_listcomp_fun³ _lh_listcomp_fun_ls_t²)))
//│ nsoln₀₀ _lh_nsoln_arg1⁰ = (length₀₀ ((gen₀₀ _lh_nsoln_arg1⁰) _lh_nsoln_arg1⁰))
//│ safe₀₀ _lh_safe_arg1¹ _lh_safe_arg2¹ _lh_safe_arg3⁰ = ((_lh_safe_arg3⁰ _lh_safe_arg1¹) _lh_safe_arg2¹)
//│ gen₀₀ _lh_gen_arg1⁰ _lh_gen_arg2⁰ = (case _lh_gen_arg1⁰ of {0 -> ((\_lh_safe_arg1² _lh_safe_arg2² -> (True )):[]); _ -> (let _lh_listcomp_fun⁴ = (\_lh_listcomp_fun_para⁰ -> (case _lh_listcomp_fun_para⁰ of {(_lh_listcomp_fun_ls_h³ : _lh_listcomp_fun_ls_t³) -> (let _lh_listcomp_fun⁵ = (\_lh_listcomp_fun_para¹ -> ((((_lh_listcomp_fun_para¹ _lh_listcomp_fun_ls_h³) _lh_listcomp_fun⁵) _lh_listcomp_fun⁴) _lh_listcomp_fun_ls_t³)) in (_lh_listcomp_fun⁵ ((enumFromTo₀₀ 1) _lh_gen_arg2⁰))); [] -> []})) in (_lh_listcomp_fun⁴ ((gen₀₀ (_lh_gen_arg1⁰ - 1)) _lh_gen_arg2⁰)))})
//│ length₀₀ ls⁰ = (case ls⁰ of {(h⁰ : t⁰) -> (1 + (length₀₀ t⁰)); [] -> 0})
//│ test₀₀ _lh_test_arg1⁰ = (nsoln₀₀ _lh_test_arg1⁰)
//│ <<<<<<<<<< Generated Haskell Code <<<<<<<<<<


// WRONG: not well-typed in haskell
:lhhaskell
// [ (a, b) | b <- [1, 4, 10], a <- [2, 3, 5], a < b ]

// TODO: support where, but cannot be local mutual recursive let bindings
// :haskell
// nsoln nq = length (gen nq)
//  where
//     safe :: Int -> Int -> [Int] -> Bool
//     safe x d []    = True
//     safe x d (q:l) = x /= q && x /= q+d && x /= q-d && safe x (d+1) l
//     gen :: Int -> [[Int]]
//     gen 0 = [[]]
//     gen n = [ (q:b) | b <- gen (n-1), q <- [1..nq], safe q 1 b]

:lhhaskell
// gen 0 nq = [[]]
// gen n nq = [ (q:b) | b <- gen (n-1) nq, q <- (primId [1..nq])]
// nsoln nq = length (gen nq nq)
// nsoln 3

:lhhaskell
// f 0 = error("no")
// f n = n + error("yes")
// f 9

:lhhaskell
// f [] ys = []
// f xs [] = []
// f (x:xs) (y:ys) = (x,y):(f xs ys)
// f [1,2] [2,3]

// WRONG: type error after fusion in haskell: f x = x f
:lhhaskell
// [a | (Just a) <- [Nothing, Just 3]]

// WRONG: not well-typed in haskell after fusion
:lhhaskell
// [a | a <- [3]]

// WRONG: not well-typed in haskell
:lhhaskell
// [a | a <- [1..2]]
