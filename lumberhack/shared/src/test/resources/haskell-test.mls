:NewParser
:ParseOnly

:lhGenHaskell
:lhInHaskell
testMapmap len = map (\x -> x + 1) $ map (\x -> x + x) [1..len]
testMapmap $ primId 5000000
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapmap_lh_₁^73(primId⁰(5000000))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^35((a⁰ + 1), b⁰)] else [LH_N]
//│ def map_lh_₁(f¹, ls¹) = case ls¹ of {
//│ 	LH_C h¹ t¹ => [LH_C f¹(h¹) map_lh_₁^19(f¹, t¹)]
//│ 	| LH_N  => [LH_N]}
//│ def map_lh_₂(f⁰, ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₂^5(f⁰, t⁰)]
//│ 	| LH_N  => [LH_N]}
//│ def testMapmap_lh_₁(_lh_testMapmap_arg1⁰) = map_lh_₂^49((fun x⁰ -> (x⁰ + 1)), map_lh_₁^57((fun x¹ -> (x¹ + x¹)), enumFromTo_lh_₁^65(1, _lh_testMapmap_arg1⁰)))
//│ 		---------- unoptimized haskell gen ----------
//│ 		(testMapmap_lh_₁ 5000000)
//│ 		enumFromTo_lh_₁ a⁰ b⁰ = (if (a⁰ <= b⁰) then (a⁰:((enumFromTo_lh_₁ (a⁰ + 1)) b⁰)) else [])
//│ 		map_lh_₁ f¹ ls¹ = (case ls¹ of {(h¹ : t¹) -> ((f¹ h¹):((map_lh_₁ f¹) t¹)); [] -> []})
//│ 		map_lh_₂ f⁰ ls⁰ = (case ls⁰ of {(h⁰ : t⁰) -> ((f⁰ h⁰):((map_lh_₂ f⁰) t⁰)); [] -> []})
//│ 		testMapmap_lh_₁ _lh_testMapmap_arg1⁰ = ((map_lh_₂ (\x⁰ -> (x⁰ + 1))) ((map_lh_₁ (\x¹ -> (x¹ + x¹))) ((enumFromTo_lh_₁ 1) _lh_testMapmap_arg1⁰)))
//│ 		---------- unoptimized haskell gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f¹(h¹) map_lh_₁(f¹, t¹)]: 24 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₂(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ [LH_N]: 25 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₂(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 44 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => [LH_C f¹(h¹) map_lh_₁(f¹, t¹)] | LH_N  => [LH_N]}: 26
//│ [LH_N]: 45 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => [LH_C f¹(h¹) map_lh_₁(f¹, t¹)] | LH_N  => [LH_N]}: 26
//│ ------------------
//│ case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₂(f⁰, t⁰)] | LH_N  => [LH_N]}: 12 --->
//│ 	[LH_C f¹(h¹) map_lh_₁(f¹, t¹)]: 24
//│ 	[LH_N]: 25
//│ case ls¹ of {LH_C h¹ t¹ => [LH_C f¹(h¹) map_lh_₁(f¹, t¹)] | LH_N  => [LH_N]}: 26 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 44
//│ 	[LH_N]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f¹(h¹) map_lh_₁(f¹, t¹)]: 24 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₂(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ [LH_N]: 25 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₂(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 44 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => [LH_C f¹(h¹) map_lh_₁(f¹, t¹)] | LH_N  => [LH_N]}: 26
//│ [LH_N]: 45 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => [LH_C f¹(h¹) map_lh_₁(f¹, t¹)] | LH_N  => [LH_N]}: 26
//│ ------------------
//│ case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₂(f⁰, t⁰)] | LH_N  => [LH_N]}: 12 --->
//│ 	[LH_C f¹(h¹) map_lh_₁(f¹, t¹)]: 24
//│ 	[LH_N]: 25
//│ case ls¹ of {LH_C h¹ t¹ => [LH_C f¹(h¹) map_lh_₁(f¹, t¹)] | LH_N  => [LH_N]}: 26 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 44
//│ 	[LH_N]: 45
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapmap_lh_₁(primId⁰(5000000))
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let t² = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let h² = a¹
//│ 	in (fun f⁴ -> 
//│ 		let t³ = map_lh_₁(f⁴, t²)
//│ 		in let h³ = f⁴(h²)
//│ 		in (fun f⁵ -> [LH_C f⁵(h³) map_lh_₂(f⁵, t³)])) else (fun f⁶ -> (fun f⁷ -> [LH_N]))
//│ def map_lh_₁(f³, ls³) = ls³(f³)
//│ def map_lh_₂(f², ls²) = ls²(f²)
//│ def testMapmap_lh_₁(_lh_testMapmap_arg1¹) = map_lh_₂((fun x² -> (x² + 1)), map_lh_₁((fun x³ -> (x³ + x³)), enumFromTo_lh_₁(1, _lh_testMapmap_arg1¹)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map_lh_₂, map_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₁ -> 4
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testMapmap_lh_₁(primId⁰(5000000))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let t⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let h⁰ = a⁰
//│ 	in (fun f² -> 
//│ 		let t¹ = t⁰(f²)
//│ 		in let h¹ = f²(h⁰)
//│ 		in (fun f³ -> [LH_C f³(h¹) t¹(f³)])) else (fun f⁴ -> (fun f⁵ -> [LH_N]))
//│ def map_lh_₁(f¹, ls¹) = ls¹(f¹)
//│ def map_lh_₂(f⁰, ls⁰) = ls⁰(f⁰)
//│ def testMapmap_lh_₁(_lh_testMapmap_arg1⁰) = enumFromTo_lh_₁(1, _lh_testMapmap_arg1⁰, (fun x⁰ -> (x⁰ + x⁰)), (fun x¹ -> (x¹ + 1)))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testMapmap_lh_₁(primId⁰(5000000))
//│ def enumFromTo_lh_₁(a⁰, b⁰, _lh_popOutId_0⁰, _lh_popOutId_1⁰) = if (a⁰ <= b⁰) then 
//│ 	let t⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let h⁰ = a⁰
//│ 	in let t¹ = t⁰(_lh_popOutId_0⁰)
//│ 	in let h¹ = _lh_popOutId_0⁰(h⁰)
//│ 	in [LH_C _lh_popOutId_1⁰(h¹) t¹(_lh_popOutId_1⁰)] else [LH_N]
//│ def map_lh_₁(f¹, ls¹) = ls¹(f¹)
//│ def map_lh_₂(f⁰, ls⁰) = ls⁰(f⁰)
//│ def testMapmap_lh_₁(_lh_testMapmap_arg1⁰) = enumFromTo_lh_₁(1, _lh_testMapmap_arg1⁰, (fun x⁰ -> (x⁰ + x⁰)), (fun x¹ -> (x¹ + 1)))
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated Haskell >>>>>>>>>>
//│ import Criterion.Main
//│ 
//│ 
//│ --- original ---
//│ (testMapmap_lh_₁ 5000000)
//│ enumFromTo_lh_₁ a⁰ b⁰ = (if (a⁰ <= b⁰) then (a⁰:((enumFromTo_lh_₁ (a⁰ + 1)) b⁰)) else [])
//│ map_lh_₁ f¹ ls¹ = (case ls¹ of {(h¹ : t¹) -> ((f¹ h¹):((map_lh_₁ f¹) t¹)); [] -> []})
//│ testMapmap_lh_₁ _lh_testMapmap_arg1⁰ = ((map_lh_₂ (\x⁰ -> (x⁰ + 1))) ((map_lh_₁ (\x¹ -> (x¹ + x¹))) ((enumFromTo_lh_₁ 1) _lh_testMapmap_arg1⁰)))
//│ 
//│ --- lumberhack ---
//│ enumFromTo_lh_₁ a⁰ b⁰ = (if (a⁰ <= b⁰) then (let t⁰ = ((enumFromTo_lh_₁ (a⁰ + 1)) b⁰) in (let h⁰ = a⁰ in (\f² -> (let t¹ = ((map_lh_₁ f²) t⁰) in (let h¹ = (f² h⁰) in (\f³ -> ((f³ h¹):((map_lh_₂ f³) t¹)))))))) else (\f⁴ f⁵ -> []))
//│ map_lh_₁ f¹ ls¹ = (ls¹ f¹)
//│ map_lh_₂ f⁰ ls⁰ = (ls⁰ f⁰)
//│ testMapmap_lh_₁ _lh_testMapmap_arg1⁰ = ((map_lh_₂ (\x⁰ -> (x⁰ + 1))) ((map_lh_₁ (\x¹ -> (x¹ + x¹))) ((enumFromTo_lh_₁ 1) _lh_testMapmap_arg1⁰)))
//│ 
//│ main :: IO ()
//│ main = defaultMain [ bgroup "Mapmap_lh" [
//│     bench "lumberhack_Mapmap_lh" $ nf testMapmap_lh_₁ 5000000
//│   , bench "original_Mapmap_lh" $ nf testMapmap_lh_₁ 5000000 ] ]
//│ <<<<<<<<<< Generated Haskell <<<<<<<<<<


// fusion clash due to: the thing returned by `gen` will be consumed
// by both `gen` itself (`b <- gen (n-1) nq`) and `length`
// NOTE: being slower (than the desugared version, faster than the most original version) may be because
// originally the type of `gen` is `Int -> Int -> [[Int]]`
// after the fusion the type of `gen` is `Int -> Int -> [Int -> Int -> Bool]`
:lhGenHaskell
:lhInHaskell
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = [ (q:b) | b <- gen (n-1) nq, q <- (primId [1..nq]), safe q 1 b ]
nsoln nq = length (gen nq nq)
testQueen n = nsoln n
testQueen $ primId 12
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testQueen_lh_₁^151(primId⁰(12))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^57((a⁰ + 1), b⁰)] else [LH_N]
//│ def gen_lh_₁(_lh_gen_arg1⁰, _lh_gen_arg2⁰) = case _lh_gen_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 				let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 					LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁^77(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)
//│ 					| LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ 				in _lh_listcomp_fun¹(primId⁰(enumFromTo_lh_₁^102(1, _lh_gen_arg2⁰)))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁰(gen_lh_₁^114((_lh_gen_arg1⁰ - 1), _lh_gen_arg2⁰))}
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁^132(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1⁰) = length_lh_₁^139(gen_lh_₁^140(_lh_nsoln_arg1⁰, _lh_nsoln_arg1⁰))
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁰, _lh_safe_arg3⁰) = case _lh_safe_arg3⁰ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁^34(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def testQueen_lh_₁(_lh_testQueen_arg1⁰) = nsoln_lh_₁^147(_lh_testQueen_arg1⁰)
//│ 		---------- unoptimized haskell gen ----------
//│ 		(testQueen_lh_₁ 12)
//│ 		enumFromTo_lh_₁ a⁰ b⁰ = (if (a⁰ <= b⁰) then (a⁰:((enumFromTo_lh_₁ (a⁰ + 1)) b⁰)) else [])
//│ 		gen_lh_₁ _lh_gen_arg1⁰ _lh_gen_arg2⁰ = (case _lh_gen_arg1⁰ of {0 -> ([]:[]); _ -> (let _lh_listcomp_fun⁰ = (\_lh_listcomp_fun_para⁰ -> (case _lh_listcomp_fun_para⁰ of {(_lh_listcomp_fun_ls_h⁰ : _lh_listcomp_fun_ls_t⁰) -> (let _lh_listcomp_fun¹ = (\_lh_listcomp_fun_para¹ -> (case _lh_listcomp_fun_para¹ of {(_lh_listcomp_fun_ls_h¹ : _lh_listcomp_fun_ls_t¹) -> (if (((safe_lh_₁ _lh_listcomp_fun_ls_h¹) 1) _lh_listcomp_fun_ls_h⁰) then ((_lh_listcomp_fun_ls_h¹:_lh_listcomp_fun_ls_h⁰):(_lh_listcomp_fun¹ _lh_listcomp_fun_ls_t¹)) else (_lh_listcomp_fun¹ _lh_listcomp_fun_ls_t¹)); [] -> (_lh_listcomp_fun⁰ _lh_listcomp_fun_ls_t⁰)})) in (_lh_listcomp_fun¹ ((enumFromTo_lh_₁ 1) _lh_gen_arg2⁰))); [] -> []})) in (_lh_listcomp_fun⁰ ((gen_lh_₁ (_lh_gen_arg1⁰ - 1)) _lh_gen_arg2⁰)))})
//│ 		length_lh_₁ ls⁰ = (case ls⁰ of {(h⁰ : t⁰) -> (1 + (length_lh_₁ t⁰)); [] -> 0})
//│ 		nsoln_lh_₁ _lh_nsoln_arg1⁰ = (length_lh_₁ ((gen_lh_₁ _lh_nsoln_arg1⁰) _lh_nsoln_arg1⁰))
//│ 		safe_lh_₁ _lh_safe_arg1⁰ _lh_safe_arg2⁰ _lh_safe_arg3⁰ = (case _lh_safe_arg3⁰ of {[] -> True; (_lh_safe_LH_C_0⁰ : _lh_safe_LH_C_1⁰) -> ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && (((safe_lh_₁ _lh_safe_arg1⁰) (_lh_safe_arg2⁰ + 1)) _lh_safe_LH_C_1⁰)); _ -> error})
//│ 		testQueen_lh_₁ _lh_testQueen_arg1⁰ = (nsoln_lh_₁ _lh_testQueen_arg1⁰)
//│ 		---------- unoptimized haskell gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 72 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 47
//│ [LH_N]: 73 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(primId⁰(enumFromTo_lh_₁(1, _lh_gen_arg2⁰))) | LH_N  => [LH_N]}: 111
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 137
//│ [LH_C [LH_N] [LH_N]]: 74 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(primId⁰(enumFromTo_lh_₁(1, _lh_gen_arg2⁰))) | LH_N  => [LH_N]}: 111
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 137
//│ [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰]: 86 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 47
//│ [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 90 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(primId⁰(enumFromTo_lh_₁(1, _lh_gen_arg2⁰))) | LH_N  => [LH_N]}: 111
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 137
//│ [LH_N]: 110 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(primId⁰(enumFromTo_lh_₁(1, _lh_gen_arg2⁰))) | LH_N  => [LH_N]}: 111
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 137
//│ ------------------
//│ case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 47 --->
//│ 	[LH_N]: 72
//│ 	[LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰]: 86
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(primId⁰(enumFromTo_lh_₁(1, _lh_gen_arg2⁰))) | LH_N  => [LH_N]}: 111 --->
//│ 	[LH_N]: 73
//│ 	[LH_C [LH_N] [LH_N]]: 74
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 90
//│ 	[LH_N]: 110
//│ case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 137 --->
//│ 	[LH_N]: 73
//│ 	[LH_C [LH_N] [LH_N]]: 74
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 90
//│ 	[LH_N]: 110
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testQueen_lh_₁(primId⁰(12))
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then [LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b¹)] else [LH_N]
//│ def gen_lh_₁(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 				let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 					LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t¹)
//│ 					| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t⁰)})
//│ 				in _lh_listcomp_fun³(primId⁰(enumFromTo_lh_₁(1, _lh_gen_arg2¹)))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun²(gen_lh_₁((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length_lh_₁(ls¹) = case ls¹ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1¹) = length_lh_₁(gen_lh_₁(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe_lh_₁(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2¹))) && safe_lh_₁(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def testQueen_lh_₁(_lh_testQueen_arg1¹) = nsoln_lh_₁(_lh_testQueen_arg1¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testQueen_lh_₁(primId⁰(12))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)] else [LH_N]
//│ def gen_lh_₁(_lh_gen_arg1⁰, _lh_gen_arg2⁰) = case _lh_gen_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 				let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 					LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)
//│ 					| LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ 				in _lh_listcomp_fun¹(primId⁰(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁰(gen_lh_₁((_lh_gen_arg1⁰ - 1), _lh_gen_arg2⁰))}
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1⁰) = length_lh_₁(gen_lh_₁(_lh_nsoln_arg1⁰, _lh_nsoln_arg1⁰))
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁰, _lh_safe_arg3⁰) = case _lh_safe_arg3⁰ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def testQueen_lh_₁(_lh_testQueen_arg1⁰) = nsoln_lh_₁(_lh_testQueen_arg1⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testQueen_lh_₁(primId⁰(12))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)] else [LH_N]
//│ def gen_lh_₁(_lh_gen_arg1⁰, _lh_gen_arg2⁰) = case _lh_gen_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 				let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 					LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)
//│ 					| LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ 				in _lh_listcomp_fun¹(primId⁰(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁰(gen_lh_₁((_lh_gen_arg1⁰ - 1), _lh_gen_arg2⁰))}
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1⁰) = length_lh_₁(gen_lh_₁(_lh_nsoln_arg1⁰, _lh_nsoln_arg1⁰))
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁰, _lh_safe_arg3⁰) = case _lh_safe_arg3⁰ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def testQueen_lh_₁(_lh_testQueen_arg1⁰) = nsoln_lh_₁(_lh_testQueen_arg1⁰)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated Haskell >>>>>>>>>>
//│ import Criterion.Main
//│ 
//│ 
//│ --- original ---
//│ (testQueen_lh_₁ 12)
//│ enumFromTo_lh_₁ a⁰ b⁰ = (if (a⁰ <= b⁰) then (a⁰:((enumFromTo_lh_₁ (a⁰ + 1)) b⁰)) else [])
//│ gen_lh_₁ _lh_gen_arg1⁰ _lh_gen_arg2⁰ = (case _lh_gen_arg1⁰ of {0 -> ([]:[]); _ -> (let _lh_listcomp_fun⁰ = (\_lh_listcomp_fun_para⁰ -> (case _lh_listcomp_fun_para⁰ of {(_lh_listcomp_fun_ls_h⁰ : _lh_listcomp_fun_ls_t⁰) -> (let _lh_listcomp_fun¹ = (\_lh_listcomp_fun_para¹ -> (case _lh_listcomp_fun_para¹ of {(_lh_listcomp_fun_ls_h¹ : _lh_listcomp_fun_ls_t¹) -> (if (((safe_lh_₁ _lh_listcomp_fun_ls_h¹) 1) _lh_listcomp_fun_ls_h⁰) then ((_lh_listcomp_fun_ls_h¹:_lh_listcomp_fun_ls_h⁰):(_lh_listcomp_fun¹ _lh_listcomp_fun_ls_t¹)) else (_lh_listcomp_fun¹ _lh_listcomp_fun_ls_t¹)); [] -> (_lh_listcomp_fun⁰ _lh_listcomp_fun_ls_t⁰)})) in (_lh_listcomp_fun¹ ((enumFromTo_lh_₁ 1) _lh_gen_arg2⁰))); [] -> []})) in (_lh_listcomp_fun⁰ ((gen_lh_₁ (_lh_gen_arg1⁰ - 1)) _lh_gen_arg2⁰)))})
//│ length_lh_₁ ls⁰ = (case ls⁰ of {(h⁰ : t⁰) -> (1 + (length_lh_₁ t⁰)); [] -> 0})
//│ nsoln_lh_₁ _lh_nsoln_arg1⁰ = (length_lh_₁ ((gen_lh_₁ _lh_nsoln_arg1⁰) _lh_nsoln_arg1⁰))
//│ testQueen_lh_₁ _lh_testQueen_arg1⁰ = (nsoln_lh_₁ _lh_testQueen_arg1⁰)
//│ 
//│ --- lumberhack ---
//│ enumFromTo_lh_₁ a⁰ b⁰ = (if (a⁰ <= b⁰) then (a⁰:((enumFromTo_lh_₁ (a⁰ + 1)) b⁰)) else [])
//│ gen_lh_₁ _lh_gen_arg1⁰ _lh_gen_arg2⁰ = (case _lh_gen_arg1⁰ of {0 -> ([]:[]); _ -> (let _lh_listcomp_fun⁰ = (\_lh_listcomp_fun_para⁰ -> (case _lh_listcomp_fun_para⁰ of {(_lh_listcomp_fun_ls_h⁰ : _lh_listcomp_fun_ls_t⁰) -> (let _lh_listcomp_fun¹ = (\_lh_listcomp_fun_para¹ -> (case _lh_listcomp_fun_para¹ of {(_lh_listcomp_fun_ls_h¹ : _lh_listcomp_fun_ls_t¹) -> (if (((safe_lh_₁ _lh_listcomp_fun_ls_h¹) 1) _lh_listcomp_fun_ls_h⁰) then ((_lh_listcomp_fun_ls_h¹:_lh_listcomp_fun_ls_h⁰):(_lh_listcomp_fun¹ _lh_listcomp_fun_ls_t¹)) else (_lh_listcomp_fun¹ _lh_listcomp_fun_ls_t¹)); [] -> (_lh_listcomp_fun⁰ _lh_listcomp_fun_ls_t⁰)})) in (_lh_listcomp_fun¹ ((enumFromTo_lh_₁ 1) _lh_gen_arg2⁰))); [] -> []})) in (_lh_listcomp_fun⁰ ((gen_lh_₁ (_lh_gen_arg1⁰ - 1)) _lh_gen_arg2⁰)))})
//│ length_lh_₁ ls⁰ = (case ls⁰ of {(h⁰ : t⁰) -> (1 + (length_lh_₁ t⁰)); [] -> 0})
//│ nsoln_lh_₁ _lh_nsoln_arg1⁰ = (length_lh_₁ ((gen_lh_₁ _lh_nsoln_arg1⁰) _lh_nsoln_arg1⁰))
//│ safe_lh_₁ _lh_safe_arg1⁰ _lh_safe_arg2⁰ _lh_safe_arg3⁰ = (case _lh_safe_arg3⁰ of {[] -> True; (_lh_safe_LH_C_0⁰ : _lh_safe_LH_C_1⁰) -> ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && (((safe_lh_₁ _lh_safe_arg1⁰) (_lh_safe_arg2⁰ + 1)) _lh_safe_LH_C_1⁰)); _ -> error})
//│ testQueen_lh_₁ _lh_testQueen_arg1⁰ = (nsoln_lh_₁ _lh_testQueen_arg1⁰)
//│ 
//│ main :: IO ()
//│ main = defaultMain [ bgroup "Queen_lh" [
//│     bench "lumberhack_Queen_lh" $ nf testQueen_lh_₁ 12
//│   , bench "original_Queen_lh" $ nf testQueen_lh_₁ 12 ] ]
//│ <<<<<<<<<< Generated Haskell <<<<<<<<<<


// WRONG: haskell also cannot handle `[1..nq]` in list comprehension, type error
:lhInHaskell
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = [ (q:b) | b <- gen (n-1) nq, q <- [1..nq], safe q 1 b ]
nsoln nq = length (gen nq nq)
test n = nsoln n
test $ primId 4
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ test_lh_₁^149(primId⁰(4))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^57((a⁰ + 1), b⁰)] else [LH_N]
//│ def gen_lh_₁(_lh_gen_arg1⁰, _lh_gen_arg2⁰) = case _lh_gen_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 				let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 					LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁^77(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)
//│ 					| LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ 				in _lh_listcomp_fun¹(enumFromTo_lh_₁^101(1, _lh_gen_arg2⁰))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁰(gen_lh_₁^112((_lh_gen_arg1⁰ - 1), _lh_gen_arg2⁰))}
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁^130(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1⁰) = length_lh_₁^137(gen_lh_₁^138(_lh_nsoln_arg1⁰, _lh_nsoln_arg1⁰))
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁰, _lh_safe_arg3⁰) = case _lh_safe_arg3⁰ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁^34(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def test_lh_₁(_lh_test_arg1⁰) = nsoln_lh_₁^145(_lh_test_arg1⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 66 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98
//│ [LH_N]: 67 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98
//│ [LH_N]: 72 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 47
//│ [LH_N]: 73 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135
//│ [LH_C [LH_N] [LH_N]]: 74 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135
//│ [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰]: 86 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 47
//│ [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 90 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135
//│ [LH_N]: 108 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135
//│ ------------------
//│ case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 47 --->
//│ 	[LH_N]: 72
//│ 	[LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰]: 86
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 66
//│ 	[LH_N]: 67
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109 --->
//│ 	[LH_N]: 73
//│ 	[LH_C [LH_N] [LH_N]]: 74
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 90
//│ 	[LH_N]: 108
//│ case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135 --->
//│ 	[LH_N]: 73
//│ 	[LH_C [LH_N] [LH_N]]: 74
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 90
//│ 	[LH_N]: 108
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 66 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98
//│ [LH_N]: 67 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98
//│ ------------------
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 66
//│ 	[LH_N]: 67
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ test_lh_₁(primId⁰(4))
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let _lh_listcomp_fun_ls_t² = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let _lh_listcomp_fun_ls_h² = a¹
//│ 	in (fun _lh_listcomp_fun_ls_h³ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_listcomp_fun_ls_t³ -> (fun _lh_listcomp_fun⁵ -> if safe_lh_₁(_lh_listcomp_fun_ls_h², 1, _lh_listcomp_fun_ls_h³) then [LH_C [LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_h³] _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t²))))) else (fun _lh_listcomp_fun_ls_h⁴ -> (fun _lh_listcomp_fun⁶ -> (fun _lh_listcomp_fun_ls_t⁴ -> (fun _lh_listcomp_fun⁷ -> _lh_listcomp_fun⁷(_lh_listcomp_fun_ls_t⁴)))))
//│ def gen_lh_₁(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 				let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> _lh_listcomp_fun_para³(_lh_listcomp_fun_ls_h⁰, _lh_listcomp_fun³, _lh_listcomp_fun_ls_t⁰, _lh_listcomp_fun²))
//│ 				in _lh_listcomp_fun³(enumFromTo_lh_₁(1, _lh_gen_arg2¹))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun²(gen_lh_₁((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length_lh_₁(ls¹) = case ls¹ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1¹) = length_lh_₁(gen_lh_₁(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe_lh_₁(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2¹))) && safe_lh_₁(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def test_lh_₁(_lh_test_arg1¹) = nsoln_lh_₁(_lh_test_arg1¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ recursive consumer: gen_lh_₁
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₁ -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ test_lh_₁(primId⁰(4))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_listcomp_fun_ls_t¹ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_listcomp_fun_ls_h¹ = a⁰
//│ 	in (fun _lh_listcomp_fun_ls_h² -> (fun _lh_listcomp_fun² -> (fun _lh_listcomp_fun_ls_t² -> (fun _lh_listcomp_fun³ -> if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun²(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t¹))))) else (fun _lh_listcomp_fun_ls_h³ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_listcomp_fun_ls_t³ -> (fun _lh_listcomp_fun⁵ -> _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t³)))))
//│ def gen_lh_₁(_lh_gen_arg1⁰, _lh_gen_arg2⁰) = case _lh_gen_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 				let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun_ls_h⁰, _lh_listcomp_fun¹, _lh_listcomp_fun_ls_t⁰, _lh_listcomp_fun⁰))
//│ 				in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁰(gen_lh_₁((_lh_gen_arg1⁰ - 1), _lh_gen_arg2⁰))}
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1⁰) = length_lh_₁(gen_lh_₁(_lh_nsoln_arg1⁰, _lh_nsoln_arg1⁰))
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁰, _lh_safe_arg3⁰) = case _lh_safe_arg3⁰ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def test_lh_₁(_lh_test_arg1⁰) = nsoln_lh_₁(_lh_test_arg1⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ test_lh_₁(primId⁰(4))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_listcomp_fun_ls_t¹ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_listcomp_fun_ls_h¹ = a⁰
//│ 	in (fun _lh_listcomp_fun_ls_h² -> (fun _lh_listcomp_fun² -> (fun _lh_listcomp_fun_ls_t² -> (fun _lh_listcomp_fun³ -> if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun²(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t¹))))) else (fun _lh_listcomp_fun_ls_h³ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_listcomp_fun_ls_t³ -> (fun _lh_listcomp_fun⁵ -> _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t³)))))
//│ def gen_lh_₁(_lh_gen_arg1⁰, _lh_gen_arg2⁰) = case _lh_gen_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 				let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun_ls_h⁰, _lh_listcomp_fun¹, _lh_listcomp_fun_ls_t⁰, _lh_listcomp_fun⁰))
//│ 				in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁰(gen_lh_₁((_lh_gen_arg1⁰ - 1), _lh_gen_arg2⁰))}
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1⁰) = length_lh_₁(gen_lh_₁(_lh_nsoln_arg1⁰, _lh_nsoln_arg1⁰))
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁰, _lh_safe_arg3⁰) = case _lh_safe_arg3⁰ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def test_lh_₁(_lh_test_arg1⁰) = nsoln_lh_₁(_lh_test_arg1⁰)
//│ <<<<<<< after floating out <<<<<<<


// WRONG: not well-typed in haskell
:lhInHaskell
// [ (a, b) | b <- [1, 4, 10], a <- [2, 3, 5], a < b ]

// TODO: support where, but cannot be local mutual recursive let bindings
// :haskell
// nsoln nq = length (gen nq)
//  where
//     safe :: Int -> Int -> [Int] -> Bool
//     safe x d []    = True
//     safe x d (q:l) = x /= q && x /= q+d && x /= q-d && safe x (d+1) l
//     gen :: Int -> [[Int]]
//     gen 0 = [[]]
//     gen n = [ (q:b) | b <- gen (n-1), q <- [1..nq], safe q 1 b]

:lhInHaskell
// gen 0 nq = [[]]
// gen n nq = [ (q:b) | b <- gen (n-1) nq, q <- (primId [1..nq])]
// nsoln nq = length (gen nq nq)
// nsoln 3

:lhInHaskell
// f 0 = error("no")
// f n = n + error("yes")
// f 9

:lhInHaskell
// f [] ys = []
// f xs [] = []
// f (x:xs) (y:ys) = (x,y):(f xs ys)
// f [1,2] [2,3]

// WRONG: type error after fusion in haskell: f x = x f
:lhInHaskell
// [a | (Just a) <- [Nothing, Just 3]]

// WRONG: not well-typed in haskell after fusion
:lhInHaskell
:lhGenHaskell
testSimpleRecursiveTypeExample x = [a | a <- [x]]
testSimpleRecursiveTypeExample $ primId 3
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSimpleRecursiveTypeExample_lh_₁^17(primId⁰(3))
//│ def testSimpleRecursiveTypeExample_lh_₁(_lh_testSimpleRecursiveTypeExample_arg1⁰) = 
//│ 	let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 		LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun⁰([LH_C _lh_testSimpleRecursiveTypeExample_arg1⁰ [LH_N]])
//│ 		---------- unoptimized haskell gen ----------
//│ 		(testSimpleRecursiveTypeExample_lh_₁ 3)
//│ 		testSimpleRecursiveTypeExample_lh_₁ _lh_testSimpleRecursiveTypeExample_arg1⁰ = (let _lh_listcomp_fun⁰ = (\_lh_listcomp_fun_para⁰ -> (case _lh_listcomp_fun_para⁰ of {(_lh_listcomp_fun_ls_h⁰ : _lh_listcomp_fun_ls_t⁰) -> (_lh_listcomp_fun_ls_h⁰:(_lh_listcomp_fun⁰ _lh_listcomp_fun_ls_t⁰)); [] -> []})) in (_lh_listcomp_fun⁰ (_lh_testSimpleRecursiveTypeExample_arg1⁰:[])))
//│ 		---------- unoptimized haskell gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 12 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 8
//│ [LH_C _lh_testSimpleRecursiveTypeExample_arg1⁰ [LH_N]]: 13 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 8
//│ ------------------
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 8 --->
//│ 	[LH_N]: 12
//│ 	[LH_C _lh_testSimpleRecursiveTypeExample_arg1⁰ [LH_N]]: 13
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_N]: 12 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 8
//│ [LH_C _lh_testSimpleRecursiveTypeExample_arg1⁰ [LH_N]]: 13 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 8
//│ ------------------
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 8 --->
//│ 	[LH_N]: 12
//│ 	[LH_C _lh_testSimpleRecursiveTypeExample_arg1⁰ [LH_N]]: 13
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSimpleRecursiveTypeExample_lh_₁(primId⁰(3))
//│ def testSimpleRecursiveTypeExample_lh_₁(_lh_testSimpleRecursiveTypeExample_arg1¹) = 
//│ 	let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun¹))
//│ 	in _lh_listcomp_fun¹(
//│ 		let _lh_listcomp_fun_ls_t¹ = (fun _lh_listcomp_fun³ -> [LH_N])
//│ 		in let _lh_listcomp_fun_ls_h¹ = _lh_testSimpleRecursiveTypeExample_arg1¹
//│ 		in (fun _lh_listcomp_fun² -> [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun²(_lh_listcomp_fun_ls_t¹)]))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ testSimpleRecursiveTypeExample_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> _lh_listcomp_fun_para⁰(_lh_listcomp_fun⁰))
//│ in _lh_listcomp_fun⁰(
//│ 	let _lh_listcomp_fun_ls_t⁰ = (fun _lh_listcomp_fun¹ -> [LH_N])
//│ 	in let _lh_listcomp_fun_ls_h⁰ = primId⁰(3)
//│ 	in (fun _lh_listcomp_fun² -> [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun²(_lh_listcomp_fun_ls_t⁰)]))
//│ def testSimpleRecursiveTypeExample_lh_₁(_lh_testSimpleRecursiveTypeExample_arg1⁰) = 
//│ 	let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun³))
//│ 	in _lh_listcomp_fun³(
//│ 		let _lh_listcomp_fun_ls_t¹ = (fun _lh_listcomp_fun⁴ -> [LH_N])
//│ 		in let _lh_listcomp_fun_ls_h¹ = _lh_testSimpleRecursiveTypeExample_arg1⁰
//│ 		in (fun _lh_listcomp_fun⁵ -> [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t¹)]))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> _lh_listcomp_fun_para⁰(_lh_listcomp_fun⁰))
//│ in _lh_listcomp_fun⁰(
//│ 	let _lh_listcomp_fun_ls_t⁰ = (fun _lh_listcomp_fun¹ -> [LH_N])
//│ 	in let _lh_listcomp_fun_ls_h⁰ = primId⁰(3)
//│ 	in (fun _lh_listcomp_fun² -> [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun²(_lh_listcomp_fun_ls_t⁰)]))
//│ def testSimpleRecursiveTypeExample_lh_₁(_lh_testSimpleRecursiveTypeExample_arg1⁰) = 
//│ 	let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun³))
//│ 	in _lh_listcomp_fun³(
//│ 		let _lh_listcomp_fun_ls_t¹ = (fun _lh_listcomp_fun⁴ -> [LH_N])
//│ 		in let _lh_listcomp_fun_ls_h¹ = _lh_testSimpleRecursiveTypeExample_arg1⁰
//│ 		in (fun _lh_listcomp_fun⁵ -> [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t¹)]))
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated Haskell >>>>>>>>>>
//│ import Criterion.Main
//│ 
//│ 
//│ --- original ---
//│ (testSimpleRecursiveTypeExample_lh_₁ 3)
//│ 
//│ --- lumberhack ---
//│ testSimpleRecursiveTypeExample_lh_₁ _lh_testSimpleRecursiveTypeExample_arg1⁰ = (let _lh_listcomp_fun⁰ = (\_lh_listcomp_fun_para⁰ -> (_lh_listcomp_fun_para⁰ _lh_listcomp_fun⁰)) in (_lh_listcomp_fun⁰ (let _lh_listcomp_fun_ls_t⁰ = (\_lh_listcomp_fun¹ -> []) in (let _lh_listcomp_fun_ls_h⁰ = _lh_testSimpleRecursiveTypeExample_arg1⁰ in (\_lh_listcomp_fun² -> (_lh_listcomp_fun_ls_h⁰:(_lh_listcomp_fun² _lh_listcomp_fun_ls_t⁰)))))))
//│ 
//│ main :: IO ()
//│ main = defaultMain [ bgroup "SimpleRecursiveTypeExample_lh" [
//│     bench "lumberhack_SimpleRecursiveTypeExample_lh" $ nf testSimpleRecursiveTypeExample_lh_₁ 3
//│   , bench "original_SimpleRecursiveTypeExample_lh" $ nf testSimpleRecursiveTypeExample_lh_₁ 3 ] ]
//│ <<<<<<<<<< Generated Haskell <<<<<<<<<<

// WRONG: not well-typed in haskell
:lhInHaskell
// [a | a <- [1..2]]
