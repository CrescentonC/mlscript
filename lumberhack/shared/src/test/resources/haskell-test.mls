:NewParser
:ParseOnly


:haskell
map (\x -> x + 1) $ map (\x -> x + x) [1,3..11]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^144((fun x⁰ -> (x⁰ + 1)), map^152((fun x¹ -> (x¹ + x¹)), enumFromThenTo^163(1, 3, 11)))
//│ def enumFromThenTo(a¹, t⁶, b¹) = if (a¹ <= b¹) then [LH_C a¹ enumFromThenTo^123(t⁶, ((2 * t⁶) - a¹), b¹)] else [LH_N]
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo^103((a⁰ + 1), b⁰)] else [LH_N]
//│ def filter(f¹, ls¹) = case ls¹ of {
//│ 	LH_C h¹ t¹ => if f¹(h¹) then [LH_C h¹ filter^20(f¹, t¹)] else filter^26(f¹, t¹)
//│ 	| LH_N  => [LH_N]}
//│ def foldl(f², i⁰, ls²) = case ls² of {
//│ 	LH_C h² t² => foldl^37(f², f²(i⁰, h²), t²)
//│ 	| LH_N  => i⁰}
//│ def foldr(f³, i¹, ls³) = case ls³ of {
//│ 	LH_C h³ t³ => f³(h³, foldr^57(f³, i¹, t³))
//│ 	| LH_N  => i¹}
//│ def head(ls⁴) = case ls⁴ of {
//│ 	LH_C h⁴ t⁴ => h⁴
//│ 	| LH_N  => primitive⁰}
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map^5(f⁰, t⁰)]
//│ 	| LH_N  => [LH_N]}
//│ def tail(ls⁵) = case ls⁵ of {
//│ 	LH_C h⁵ t⁵ => t⁵
//│ 	| LH_N  => primitive⁰}
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip^75(tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromThenTo^163]
//│ 	[enumFromThenTo^163 · enumFromThenTo^123] ---> [enumFromThenTo^163] (only one)
//│ [map^144]
//│ 	[map^144 · map^5] ---> [map^144] (only one)
//│ [map^152]
//│ 	[map^152 · map^5] ---> [map^152] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map₀((fun x² -> (x² + 1)), map₁((fun x³ -> (x³ + x³)), enumFromThenTo₀(1, 3, 11)))
//│ def enumFromThenTo₀(a², t⁸, b²) = 
//│ 	if (a² <= b²) then [LH_C a² enumFromThenTo₀(t⁸, ((2 * t⁸) - a²), b²)] else [LH_N]
//│ def map₀(f⁴, ls⁶) = 
//│ 	case ls⁶ of {
//│ 		LH_C h⁶ t⁷ => [LH_C f⁴(h⁶) map₀(f⁴, t⁷)]
//│ 		| LH_N  => [LH_N]}
//│ def map₁(f⁵, ls⁷) = 
//│ 	case ls⁷ of {
//│ 		LH_C h⁷ t⁹ => [LH_C f⁵(h⁷) map₁(f⁵, t⁹)]
//│ 		| LH_N  => [LH_N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a² enumFromThenTo₀(t⁸, ((2 * t⁸) - a²), b²)]: 204 --->
//│ 	case ls⁷ of {LH_C h⁷ t⁹ => [LH_C f⁵(h⁷) map₁(f⁵, t⁹)] | LH_N  => [LH_N]}: 221
//│ [LH_N]: 205 --->
//│ 	case ls⁷ of {LH_C h⁷ t⁹ => [LH_C f⁵(h⁷) map₁(f⁵, t⁹)] | LH_N  => [LH_N]}: 221
//│ [LH_C f⁵(h⁷) map₁(f⁵, t⁹)]: 219 --->
//│ 	case ls⁶ of {LH_C h⁶ t⁷ => [LH_C f⁴(h⁶) map₀(f⁴, t⁷)] | LH_N  => [LH_N]}: 180
//│ [LH_N]: 220 --->
//│ 	case ls⁶ of {LH_C h⁶ t⁷ => [LH_C f⁴(h⁶) map₀(f⁴, t⁷)] | LH_N  => [LH_N]}: 180
//│ ------------------
//│ case ls⁶ of {LH_C h⁶ t⁷ => [LH_C f⁴(h⁶) map₀(f⁴, t⁷)] | LH_N  => [LH_N]}: 180 --->
//│ 	[LH_C f⁵(h⁷) map₁(f⁵, t⁹)]: 219
//│ 	[LH_N]: 220
//│ case ls⁷ of {LH_C h⁷ t⁹ => [LH_C f⁵(h⁷) map₁(f⁵, t⁹)] | LH_N  => [LH_N]}: 221 --->
//│ 	[LH_C a² enumFromThenTo₀(t⁸, ((2 * t⁸) - a²), b²)]: 204
//│ 	[LH_N]: 205
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a² enumFromThenTo₀(t⁸, ((2 * t⁸) - a²), b²)]: 204 --->
//│ 	case ls⁷ of {LH_C h⁷ t⁹ => [LH_C f⁵(h⁷) map₁(f⁵, t⁹)] | LH_N  => [LH_N]}: 221
//│ [LH_N]: 205 --->
//│ 	case ls⁷ of {LH_C h⁷ t⁹ => [LH_C f⁵(h⁷) map₁(f⁵, t⁹)] | LH_N  => [LH_N]}: 221
//│ [LH_C f⁵(h⁷) map₁(f⁵, t⁹)]: 219 --->
//│ 	case ls⁶ of {LH_C h⁶ t⁷ => [LH_C f⁴(h⁶) map₀(f⁴, t⁷)] | LH_N  => [LH_N]}: 180
//│ [LH_N]: 220 --->
//│ 	case ls⁶ of {LH_C h⁶ t⁷ => [LH_C f⁴(h⁶) map₀(f⁴, t⁷)] | LH_N  => [LH_N]}: 180
//│ ------------------
//│ case ls⁶ of {LH_C h⁶ t⁷ => [LH_C f⁴(h⁶) map₀(f⁴, t⁷)] | LH_N  => [LH_N]}: 180 --->
//│ 	[LH_C f⁵(h⁷) map₁(f⁵, t⁹)]: 219
//│ 	[LH_N]: 220
//│ case ls⁷ of {LH_C h⁷ t⁹ => [LH_C f⁵(h⁷) map₁(f⁵, t⁹)] | LH_N  => [LH_N]}: 221 --->
//│ 	[LH_C a² enumFromThenTo₀(t⁸, ((2 * t⁸) - a²), b²)]: 204
//│ 	[LH_N]: 205
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map₀((fun x⁴ -> (x⁴ + 1)), map₁((fun x⁵ -> (x⁵ + x⁵)), enumFromThenTo₀(1, 3, 11)))
//│ def enumFromThenTo₀(a³, t¹⁰, b³) = 
//│ 	if (a³ <= b³) then 
//│ 		let h⁸ = a³
//│ 		in let t¹¹ = enumFromThenTo₀(t¹⁰, ((2 * t¹⁰) - a³), b³)
//│ 		in (fun f⁷ -> 
//│ 			let h⁹ = f⁷(h⁸)
//│ 			in let t¹² = map₁(f⁷, t¹¹)
//│ 			in (fun f⁸ -> [LH_C f⁸(h⁹) map₀(f⁸, t¹²)])) else (fun f⁹ -> (fun f¹⁰ -> [LH_N]))
//│ def map₀(f⁶, ls⁸) = 
//│ 	ls⁸(f⁶)
//│ def map₁(f¹¹, ls⁹) = 
//│ 	ls⁹(f¹¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated Haskell Code >>>>>>>>>>
//│ 
//│ map₀ f⁰ ls⁰ = (ls⁰ f⁰)
//│ enumFromThenTo₀ a⁰ t⁰ b⁰ = (if (a⁰ <= b⁰) then (let h⁰ = a⁰ in (let t¹ = (((enumFromThenTo₀ t⁰) ((2 * t⁰) - a⁰)) b⁰) in (\f¹ -> (let h¹ = (f¹ h⁰) in (let t² = ((map₁ f¹) t¹) in (\f² -> ((f² h¹):((map₀ f²) t²)))))))) else (\f³ f⁴ -> []))
//│ map₁ f⁵ ls¹ = (ls¹ f⁵)
//│ ((map₀ (\x⁰ -> (x⁰ + 1))) ((map₁ (\x¹ -> (x¹ + x¹))) (((enumFromThenTo₀ 1) 3) 11)))
//│ <<<<<<<<<< Generated Haskell Code <<<<<<<<<<




// :haskell
// main = (print . sum . concat . queens) 10
//   where
//     queens :: Int -> [[Int]]
//     queens 0 = [[]]
//     queens m = [ p ++ [n] | p <- queens (m-1) , n <- [1..10], safe p n]
//    
//     safe : : [Int] -> Int -> Bool
//     safe p n = and [ (j /= n) && (i+j /= m + n) && (i - j /= m - n) | (i, j) <- zip [1 ..] p]
//       where
//         m = length p + 1


