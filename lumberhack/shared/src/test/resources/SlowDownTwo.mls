:NewParser
:ParseOnly

:lhInHaskell
:lhGenOCaml
testSlowManualListCompTwo n =
  if n < 0 then
    [1]
  else
    concat (
      let lscompf =
            \x -> case x of { [] -> []; (h:t) -> (testSlowManualListCompTwo (n - 1)):(lscompf t) }
      in
      lscompf [0..n]
    )
testSlowManualListCompTwo $ primId 8
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSlowManualListCompTwo_lh_₁^82(primId⁰(8))
//│ def concat_lh_₁(lss⁰) = case lss⁰ of {
//│ 	LH_C h¹ t¹ => mappend_lh_₁^34(h¹, concat_lh_₁^37(t¹))
//│ 	| LH_N  => [LH_N]}
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^19((a⁰ + 1), b⁰)] else [LH_N]
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁^3(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testSlowManualListCompTwo_lh_₁(_lh_testSlowManualListCompTwo_arg1⁰) = if (_lh_testSlowManualListCompTwo_arg1⁰ < 0) then [LH_C 1 [LH_N]] else concat_lh_₁^52(
//│ 	let lscompf⁰ = (fun x⁰ -> 
//│ 		let _lh_matchIdent⁰ = x⁰
//│ 		in case _lh_matchIdent⁰ of {
//│ 			LH_N  => [LH_N]
//│ 			| LH_C _lh_testSlowManualListCompTwo_LH_C_0⁰ _lh_testSlowManualListCompTwo_LH_C_1⁰ => [LH_C testSlowManualListCompTwo_lh_₁^56((_lh_testSlowManualListCompTwo_arg1⁰ - 1)) lscompf⁰(_lh_testSlowManualListCompTwo_LH_C_1⁰)]
//│ 			| _  => error⁰})
//│ 	in lscompf⁰(enumFromTo_lh_₁^72(0, _lh_testSlowManualListCompTwo_arg1⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_lh__d1 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d1 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec mappend_lh__d1 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (`LH_C(h_0, ((mappend_lh__d1 t_0) ys_0)))
//│ 		    | `LH_N -> 
//│ 		      ys_0);;
//│ 		let rec concat_lh__d1 lss_0 =
//│ 		  (match lss_0 with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      ((mappend_lh__d1 h_1) (concat_lh__d1 t_1))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec testSlowManualListCompTwo_lh__d1 _lh_testSlowManualListCompTwo_arg1_0 =
//│ 		  (if (_lh_testSlowManualListCompTwo_arg1_0 < 0) then
//│ 		    (`LH_C(1, (`LH_N)))
//│ 		  else
//│ 		    (concat_lh__d1 (let rec lscompf_0 = (fun x_0 -> 
//│ 		      (let rec _lh_matchIdent_0 = x_0 in
//│ 		        (match _lh_matchIdent_0 with
//│ 		          | `LH_N -> 
//│ 		            (`LH_N)
//│ 		          | `LH_C(_lh_testSlowManualListCompTwo_LH_C_0_0, _lh_testSlowManualListCompTwo_LH_C_1_0) -> 
//│ 		            (`LH_C((testSlowManualListCompTwo_lh__d1 (_lh_testSlowManualListCompTwo_arg1_0 - 1)), (lscompf_0 _lh_testSlowManualListCompTwo_LH_C_1_0)))
//│ 		          | _ -> 
//│ 		            (failwith "error")))) in
//│ 		      (lscompf_0 ((enumFromTo_lh__d1 0) _lh_testSlowManualListCompTwo_arg1_0)))));;
//│ 		(testSlowManualListCompTwo_lh__d1 8)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28 --->
//│ 	case _lh_matchIdent⁰ of {LH_N  => [LH_N] | LH_C _lh_testSlowManualListCompTwo_LH_C_0⁰ _lh_testSlowManualListCompTwo_LH_C_1⁰ => [LH_C testSlowManualListCompTwo_lh_₁((_lh_testSlowManualListCompTwo_arg1⁰ - 1)) lscompf⁰(_lh_testSlowManualListCompTwo_LH_C_1⁰)] | _  => error⁰}: 68
//│ [LH_N]: 29 --->
//│ 	case _lh_matchIdent⁰ of {LH_N  => [LH_N] | LH_C _lh_testSlowManualListCompTwo_LH_C_0⁰ _lh_testSlowManualListCompTwo_LH_C_1⁰ => [LH_C testSlowManualListCompTwo_lh_₁((_lh_testSlowManualListCompTwo_arg1⁰ - 1)) lscompf⁰(_lh_testSlowManualListCompTwo_LH_C_1⁰)] | _  => error⁰}: 68
//│ [LH_N]: 41 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_N]: 50 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C 1 [LH_N]]: 51 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_N]: 55 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ [LH_C testSlowManualListCompTwo_lh_₁((_lh_testSlowManualListCompTwo_arg1⁰ - 1)) lscompf⁰(_lh_testSlowManualListCompTwo_LH_C_1⁰)]: 66 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ ------------------
//│ case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10 --->
//│ 	[LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8
//│ 	[LH_N]: 41
//│ 	[LH_N]: 50
//│ 	[LH_C 1 [LH_N]]: 51
//│ case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42 --->
//│ 	[LH_N]: 55
//│ 	[LH_C testSlowManualListCompTwo_lh_₁((_lh_testSlowManualListCompTwo_arg1⁰ - 1)) lscompf⁰(_lh_testSlowManualListCompTwo_LH_C_1⁰)]: 66
//│ case _lh_matchIdent⁰ of {LH_N  => [LH_N] | LH_C _lh_testSlowManualListCompTwo_LH_C_0⁰ _lh_testSlowManualListCompTwo_LH_C_1⁰ => [LH_C testSlowManualListCompTwo_lh_₁((_lh_testSlowManualListCompTwo_arg1⁰ - 1)) lscompf⁰(_lh_testSlowManualListCompTwo_LH_C_1⁰)] | _  => error⁰}: 68 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28
//│ 	[LH_N]: 29
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28 --->
//│ 	case _lh_matchIdent⁰ of {LH_N  => [LH_N] | LH_C _lh_testSlowManualListCompTwo_LH_C_0⁰ _lh_testSlowManualListCompTwo_LH_C_1⁰ => [LH_C testSlowManualListCompTwo_lh_₁((_lh_testSlowManualListCompTwo_arg1⁰ - 1)) lscompf⁰(_lh_testSlowManualListCompTwo_LH_C_1⁰)] | _  => error⁰}: 68
//│ [LH_N]: 29 --->
//│ 	case _lh_matchIdent⁰ of {LH_N  => [LH_N] | LH_C _lh_testSlowManualListCompTwo_LH_C_0⁰ _lh_testSlowManualListCompTwo_LH_C_1⁰ => [LH_C testSlowManualListCompTwo_lh_₁((_lh_testSlowManualListCompTwo_arg1⁰ - 1)) lscompf⁰(_lh_testSlowManualListCompTwo_LH_C_1⁰)] | _  => error⁰}: 68
//│ [LH_N]: 55 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ [LH_C testSlowManualListCompTwo_lh_₁((_lh_testSlowManualListCompTwo_arg1⁰ - 1)) lscompf⁰(_lh_testSlowManualListCompTwo_LH_C_1⁰)]: 66 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ ------------------
//│ case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42 --->
//│ 	[LH_N]: 55
//│ 	[LH_C testSlowManualListCompTwo_lh_₁((_lh_testSlowManualListCompTwo_arg1⁰ - 1)) lscompf⁰(_lh_testSlowManualListCompTwo_LH_C_1⁰)]: 66
//│ case _lh_matchIdent⁰ of {LH_N  => [LH_N] | LH_C _lh_testSlowManualListCompTwo_LH_C_0⁰ _lh_testSlowManualListCompTwo_LH_C_1⁰ => [LH_C testSlowManualListCompTwo_lh_₁((_lh_testSlowManualListCompTwo_arg1⁰ - 1)) lscompf⁰(_lh_testSlowManualListCompTwo_LH_C_1⁰)] | _  => error⁰}: 68 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28
//│ 	[LH_N]: 29
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSlowManualListCompTwo_lh_₁(primId⁰(8))
//│ def concat_lh_₁(lss¹) = lss¹(99)
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let _lh_testSlowManualListCompTwo_LH_C_1¹ = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let _lh_testSlowManualListCompTwo_LH_C_0¹ = a¹
//│ 	in (fun _lh_testSlowManualListCompTwo_arg1¹ -> (fun lscompf¹ -> 
//│ 		let t² = lscompf¹(_lh_testSlowManualListCompTwo_LH_C_1¹)
//│ 		in let h² = testSlowManualListCompTwo_lh_₁((_lh_testSlowManualListCompTwo_arg1¹ - 1))
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h², concat_lh_₁(t²))))) else (fun _lh_testSlowManualListCompTwo_arg1² -> (fun lscompf² -> (fun _lh_dummy¹ -> [LH_N])))
//│ def mappend_lh_₁(xs¹, ys¹) = case xs¹ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys¹)]
//│ 	| LH_N  => ys¹}
//│ def testSlowManualListCompTwo_lh_₁(_lh_testSlowManualListCompTwo_arg1³) = if (_lh_testSlowManualListCompTwo_arg1³ < 0) then [LH_C 1 [LH_N]] else concat_lh_₁(
//│ 	let lscompf³ = (fun x¹ -> 
//│ 		let _lh_matchIdent¹ = x¹
//│ 		in _lh_matchIdent¹(_lh_testSlowManualListCompTwo_arg1³, lscompf³))
//│ 	in lscompf³(enumFromTo_lh_₁(0, _lh_testSlowManualListCompTwo_arg1³)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ testSlowManualListCompTwo_lh_₁, concat_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₁ -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ if (primId⁰(8) < 0) then [LH_C 1 [LH_N]] else 
//│ 	let lscompf⁰ = (fun x⁰ -> 
//│ 		let _lh_matchIdent⁰ = x⁰
//│ 		in _lh_matchIdent⁰(primId⁰(8), lscompf⁰))
//│ 	in lscompf⁰(enumFromTo_lh_₁(0, primId⁰(8)))(99)
//│ def concat_lh_₁(lss⁰) = lss⁰(99)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_testSlowManualListCompTwo_LH_C_1⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_testSlowManualListCompTwo_LH_C_0⁰ = a⁰
//│ 	in (fun _lh_testSlowManualListCompTwo_arg1⁰ -> (fun lscompf¹ -> 
//│ 		let t¹ = lscompf¹(_lh_testSlowManualListCompTwo_LH_C_1⁰)
//│ 		in let h¹ = if ((_lh_testSlowManualListCompTwo_arg1⁰ - 1) < 0) then [LH_C 1 [LH_N]] else 
//│ 			let lscompf² = (fun x¹ -> 
//│ 				let _lh_matchIdent¹ = x¹
//│ 				in _lh_matchIdent¹((_lh_testSlowManualListCompTwo_arg1⁰ - 1), lscompf²))
//│ 			in lscompf²(enumFromTo_lh_₁(0, (_lh_testSlowManualListCompTwo_arg1⁰ - 1)))(99)
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h¹, t¹(99))))) else (fun _lh_testSlowManualListCompTwo_arg1¹ -> (fun lscompf³ -> (fun _lh_dummy¹ -> [LH_N])))
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testSlowManualListCompTwo_lh_₁(_lh_testSlowManualListCompTwo_arg1²) = if (_lh_testSlowManualListCompTwo_arg1² < 0) then [LH_C 1 [LH_N]] else 
//│ 	let lscompf⁴ = (fun x² -> 
//│ 		let _lh_matchIdent² = x²
//│ 		in _lh_matchIdent²(_lh_testSlowManualListCompTwo_arg1², lscompf⁴))
//│ 	in lscompf⁴(enumFromTo_lh_₁(0, _lh_testSlowManualListCompTwo_arg1²))(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ if (primId⁰(8) < 0) then [LH_C 1 [LH_N]] else 
//│ 	let lscompf⁰ = (fun x⁰ -> 
//│ 		let _lh_matchIdent⁰ = x⁰
//│ 		in _lh_matchIdent⁰(primId⁰(8), lscompf⁰))
//│ 	in lscompf⁰(enumFromTo_lh_₁(0, primId⁰(8)))(99)
//│ def concat_lh_₁(lss⁰) = lss⁰(99)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_testSlowManualListCompTwo_LH_C_1⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_testSlowManualListCompTwo_LH_C_0⁰ = a⁰
//│ 	in (fun _lh_testSlowManualListCompTwo_arg1⁰ -> (fun lscompf¹ -> 
//│ 		let t¹ = lscompf¹(_lh_testSlowManualListCompTwo_LH_C_1⁰)
//│ 		in let h¹ = if ((_lh_testSlowManualListCompTwo_arg1⁰ - 1) < 0) then [LH_C 1 [LH_N]] else 
//│ 			let lscompf² = (fun x¹ -> 
//│ 				let _lh_matchIdent¹ = x¹
//│ 				in _lh_matchIdent¹((_lh_testSlowManualListCompTwo_arg1⁰ - 1), lscompf²))
//│ 			in lscompf²(enumFromTo_lh_₁(0, (_lh_testSlowManualListCompTwo_arg1⁰ - 1)))(99)
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h¹, t¹(99))))) else (fun _lh_testSlowManualListCompTwo_arg1¹ -> (fun lscompf³ -> (fun _lh_dummy¹ -> [LH_N])))
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testSlowManualListCompTwo_lh_₁(_lh_testSlowManualListCompTwo_arg1²) = if (_lh_testSlowManualListCompTwo_arg1² < 0) then [LH_C 1 [LH_N]] else 
//│ 	let lscompf⁴ = (fun x² -> 
//│ 		let _lh_matchIdent² = x²
//│ 		in _lh_matchIdent²(_lh_testSlowManualListCompTwo_arg1², lscompf⁴))
//│ 	in lscompf⁴(enumFromTo_lh_₁(0, _lh_testSlowManualListCompTwo_arg1²))(99)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhInHaskell
:lhGenOCaml
lscompf x n = case x of { [] -> []; (h:t) -> (testSlowManualListCompLiftedTwo (n - 1)):(lscompf t n) }
testSlowManualListCompLiftedTwo n =
  if n < 0 then
    [1]
  else
    concat ( lscompf [0..n] n )
testSlowManualListCompLiftedTwo $ primId 8
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSlowManualListCompLiftedTwo_lh_₁^86(primId⁰(8))
//│ def concat_lh_₁(lss⁰) = case lss⁰ of {
//│ 	LH_C h¹ t¹ => mappend_lh_₁^34(h¹, concat_lh_₁^37(t¹))
//│ 	| LH_N  => [LH_N]}
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^19((a⁰ + 1), b⁰)] else [LH_N]
//│ def lscompf_lh_₁(_lh_lscompf_arg1⁰, _lh_lscompf_arg2⁰) = 
//│ 	let _lh_matchIdent⁰ = _lh_lscompf_arg1⁰
//│ 	in case _lh_matchIdent⁰ of {
//│ 		LH_N  => [LH_N]
//│ 		| LH_C _lh_lscompf_LH_C_0⁰ _lh_lscompf_LH_C_1⁰ => [LH_C testSlowManualListCompLiftedTwo_lh_₁^47((_lh_lscompf_arg2⁰ - 1)) lscompf_lh_₁^54(_lh_lscompf_LH_C_1⁰, _lh_lscompf_arg2⁰)]
//│ 		| _  => error⁰}
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁^3(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testSlowManualListCompLiftedTwo_lh_₁(_lh_testSlowManualListCompLiftedTwo_arg1⁰) = if (_lh_testSlowManualListCompLiftedTwo_arg1⁰ < 0) then [LH_C 1 [LH_N]] else concat_lh_₁^73(lscompf_lh_₁^74(enumFromTo_lh_₁^75(0, _lh_testSlowManualListCompLiftedTwo_arg1⁰), _lh_testSlowManualListCompLiftedTwo_arg1⁰))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_lh__d1 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d1 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec mappend_lh__d1 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (`LH_C(h_0, ((mappend_lh__d1 t_0) ys_0)))
//│ 		    | `LH_N -> 
//│ 		      ys_0);;
//│ 		let rec concat_lh__d1 lss_0 =
//│ 		  (match lss_0 with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      ((mappend_lh__d1 h_1) (concat_lh__d1 t_1))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec lscompf_lh__d1 _lh_lscompf_arg1_0 _lh_lscompf_arg2_0 =
//│ 		  (let rec _lh_matchIdent_0 = _lh_lscompf_arg1_0 in
//│ 		    (match _lh_matchIdent_0 with
//│ 		      | `LH_N -> 
//│ 		        (`LH_N)
//│ 		      | `LH_C(_lh_lscompf_LH_C_0_0, _lh_lscompf_LH_C_1_0) -> 
//│ 		        (`LH_C((testSlowManualListCompLiftedTwo_lh__d1 (_lh_lscompf_arg2_0 - 1)), ((lscompf_lh__d1 _lh_lscompf_LH_C_1_0) _lh_lscompf_arg2_0)))
//│ 		      | _ -> 
//│ 		        (failwith "error")))
//│ 		and
//│ 		testSlowManualListCompLiftedTwo_lh__d1 _lh_testSlowManualListCompLiftedTwo_arg1_0 =
//│ 		  (if (_lh_testSlowManualListCompLiftedTwo_arg1_0 < 0) then
//│ 		    (`LH_C(1, (`LH_N)))
//│ 		  else
//│ 		    (concat_lh__d1 ((lscompf_lh__d1 ((enumFromTo_lh__d1 0) _lh_testSlowManualListCompLiftedTwo_arg1_0)) _lh_testSlowManualListCompLiftedTwo_arg1_0)));;
//│ 		(testSlowManualListCompLiftedTwo_lh__d1 8)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28 --->
//│ 	case _lh_matchIdent⁰ of {LH_N  => [LH_N] | LH_C _lh_lscompf_LH_C_0⁰ _lh_lscompf_LH_C_1⁰ => [LH_C testSlowManualListCompLiftedTwo_lh_₁((_lh_lscompf_arg2⁰ - 1)) lscompf_lh_₁(_lh_lscompf_LH_C_1⁰, _lh_lscompf_arg2⁰)] | _  => error⁰}: 61
//│ [LH_N]: 29 --->
//│ 	case _lh_matchIdent⁰ of {LH_N  => [LH_N] | LH_C _lh_lscompf_LH_C_0⁰ _lh_lscompf_LH_C_1⁰ => [LH_C testSlowManualListCompLiftedTwo_lh_₁((_lh_lscompf_arg2⁰ - 1)) lscompf_lh_₁(_lh_lscompf_LH_C_1⁰, _lh_lscompf_arg2⁰)] | _  => error⁰}: 61
//│ [LH_N]: 41 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_N]: 46 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ [LH_C testSlowManualListCompLiftedTwo_lh_₁((_lh_lscompf_arg2⁰ - 1)) lscompf_lh_₁(_lh_lscompf_LH_C_1⁰, _lh_lscompf_arg2⁰)]: 59 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ [LH_N]: 71 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C 1 [LH_N]]: 72 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10 --->
//│ 	[LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8
//│ 	[LH_N]: 41
//│ 	[LH_N]: 71
//│ 	[LH_C 1 [LH_N]]: 72
//│ case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42 --->
//│ 	[LH_N]: 46
//│ 	[LH_C testSlowManualListCompLiftedTwo_lh_₁((_lh_lscompf_arg2⁰ - 1)) lscompf_lh_₁(_lh_lscompf_LH_C_1⁰, _lh_lscompf_arg2⁰)]: 59
//│ case _lh_matchIdent⁰ of {LH_N  => [LH_N] | LH_C _lh_lscompf_LH_C_0⁰ _lh_lscompf_LH_C_1⁰ => [LH_C testSlowManualListCompLiftedTwo_lh_₁((_lh_lscompf_arg2⁰ - 1)) lscompf_lh_₁(_lh_lscompf_LH_C_1⁰, _lh_lscompf_arg2⁰)] | _  => error⁰}: 61 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28
//│ 	[LH_N]: 29
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28 --->
//│ 	case _lh_matchIdent⁰ of {LH_N  => [LH_N] | LH_C _lh_lscompf_LH_C_0⁰ _lh_lscompf_LH_C_1⁰ => [LH_C testSlowManualListCompLiftedTwo_lh_₁((_lh_lscompf_arg2⁰ - 1)) lscompf_lh_₁(_lh_lscompf_LH_C_1⁰, _lh_lscompf_arg2⁰)] | _  => error⁰}: 61
//│ [LH_N]: 29 --->
//│ 	case _lh_matchIdent⁰ of {LH_N  => [LH_N] | LH_C _lh_lscompf_LH_C_0⁰ _lh_lscompf_LH_C_1⁰ => [LH_C testSlowManualListCompLiftedTwo_lh_₁((_lh_lscompf_arg2⁰ - 1)) lscompf_lh_₁(_lh_lscompf_LH_C_1⁰, _lh_lscompf_arg2⁰)] | _  => error⁰}: 61
//│ [LH_N]: 46 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ [LH_C testSlowManualListCompLiftedTwo_lh_₁((_lh_lscompf_arg2⁰ - 1)) lscompf_lh_₁(_lh_lscompf_LH_C_1⁰, _lh_lscompf_arg2⁰)]: 59 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ ------------------
//│ case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42 --->
//│ 	[LH_N]: 46
//│ 	[LH_C testSlowManualListCompLiftedTwo_lh_₁((_lh_lscompf_arg2⁰ - 1)) lscompf_lh_₁(_lh_lscompf_LH_C_1⁰, _lh_lscompf_arg2⁰)]: 59
//│ case _lh_matchIdent⁰ of {LH_N  => [LH_N] | LH_C _lh_lscompf_LH_C_0⁰ _lh_lscompf_LH_C_1⁰ => [LH_C testSlowManualListCompLiftedTwo_lh_₁((_lh_lscompf_arg2⁰ - 1)) lscompf_lh_₁(_lh_lscompf_LH_C_1⁰, _lh_lscompf_arg2⁰)] | _  => error⁰}: 61 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28
//│ 	[LH_N]: 29
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSlowManualListCompLiftedTwo_lh_₁(primId⁰(8))
//│ def concat_lh_₁(lss¹) = lss¹(99)
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let _lh_lscompf_LH_C_1¹ = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let _lh_lscompf_LH_C_0¹ = a¹
//│ 	in (fun _lh_lscompf_arg2¹ -> 
//│ 		let t² = lscompf_lh_₁(_lh_lscompf_LH_C_1¹, _lh_lscompf_arg2¹)
//│ 		in let h² = testSlowManualListCompLiftedTwo_lh_₁((_lh_lscompf_arg2¹ - 1))
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h², concat_lh_₁(t²)))) else (fun _lh_lscompf_arg2² -> (fun _lh_dummy¹ -> [LH_N]))
//│ def lscompf_lh_₁(_lh_lscompf_arg1¹, _lh_lscompf_arg2³) = 
//│ 	let _lh_matchIdent¹ = _lh_lscompf_arg1¹
//│ 	in _lh_matchIdent¹(_lh_lscompf_arg2³)
//│ def mappend_lh_₁(xs¹, ys¹) = case xs¹ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys¹)]
//│ 	| LH_N  => ys¹}
//│ def testSlowManualListCompLiftedTwo_lh_₁(_lh_testSlowManualListCompLiftedTwo_arg1¹) = if (_lh_testSlowManualListCompLiftedTwo_arg1¹ < 0) then [LH_C 1 [LH_N]] else concat_lh_₁(lscompf_lh_₁(enumFromTo_lh_₁(0, _lh_testSlowManualListCompLiftedTwo_arg1¹), _lh_testSlowManualListCompLiftedTwo_arg1¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ concat_lh_₁, lscompf_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₁ -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testSlowManualListCompLiftedTwo_lh_₁(primId⁰(8))
//│ def concat_lh_₁(lss⁰) = lss⁰(99)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_lscompf_LH_C_1⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_lscompf_LH_C_0⁰ = a⁰
//│ 	in (fun _lh_lscompf_arg2⁰ -> 
//│ 		let t¹ = 	
//│ 			let _lh_matchIdent⁰ = _lh_lscompf_LH_C_1⁰
//│ 			in _lh_matchIdent⁰(_lh_lscompf_arg2⁰)
//│ 		in let h¹ = testSlowManualListCompLiftedTwo_lh_₁((_lh_lscompf_arg2⁰ - 1))
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h¹, t¹(99)))) else (fun _lh_lscompf_arg2¹ -> (fun _lh_dummy¹ -> [LH_N]))
//│ def lscompf_lh_₁(_lh_lscompf_arg1⁰, _lh_lscompf_arg2²) = 
//│ 	let _lh_matchIdent¹ = _lh_lscompf_arg1⁰
//│ 	in _lh_matchIdent¹(_lh_lscompf_arg2²)
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testSlowManualListCompLiftedTwo_lh_₁(_lh_testSlowManualListCompLiftedTwo_arg1⁰) = if (_lh_testSlowManualListCompLiftedTwo_arg1⁰ < 0) then [LH_C 1 [LH_N]] else 
//│ 	let _lh_matchIdent² = enumFromTo_lh_₁(0, _lh_testSlowManualListCompLiftedTwo_arg1⁰)
//│ 	in _lh_matchIdent²(_lh_testSlowManualListCompLiftedTwo_arg1⁰)(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testSlowManualListCompLiftedTwo_lh_₁(primId⁰(8))
//│ def concat_lh_₁(lss⁰) = lss⁰(99)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_lscompf_LH_C_1⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_lscompf_LH_C_0⁰ = a⁰
//│ 	in (fun _lh_lscompf_arg2⁰ -> 
//│ 		let t¹ = 	
//│ 			let _lh_matchIdent⁰ = _lh_lscompf_LH_C_1⁰
//│ 			in _lh_matchIdent⁰(_lh_lscompf_arg2⁰)
//│ 		in let h¹ = testSlowManualListCompLiftedTwo_lh_₁((_lh_lscompf_arg2⁰ - 1))
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h¹, t¹(99)))) else (fun _lh_lscompf_arg2¹ -> (fun _lh_dummy¹ -> [LH_N]))
//│ def lscompf_lh_₁(_lh_lscompf_arg1⁰, _lh_lscompf_arg2²) = 
//│ 	let _lh_matchIdent¹ = _lh_lscompf_arg1⁰
//│ 	in _lh_matchIdent¹(_lh_lscompf_arg2²)
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testSlowManualListCompLiftedTwo_lh_₁(_lh_testSlowManualListCompLiftedTwo_arg1⁰) = if (_lh_testSlowManualListCompLiftedTwo_arg1⁰ < 0) then [LH_C 1 [LH_N]] else 
//│ 	let _lh_matchIdent² = enumFromTo_lh_₁(0, _lh_testSlowManualListCompLiftedTwo_arg1⁰)
//│ 	in _lh_matchIdent²(_lh_testSlowManualListCompLiftedTwo_arg1⁰)(99)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhInHaskell
:lhGenOCaml
testSlowTwo n = if n < 0 then [1] else concat [ testSlowTwo (n - 1) | x <- [0..n] ]
testSlowTwo $ primId 8
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSlowTwo_lh_₁^79(primId⁰(8))
//│ def concat_lh_₁(lss⁰) = case lss⁰ of {
//│ 	LH_C h¹ t¹ => mappend_lh_₁^34(h¹, concat_lh_₁^37(t¹))
//│ 	| LH_N  => [LH_N]}
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^19((a⁰ + 1), b⁰)] else [LH_N]
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁^3(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testSlowTwo_lh_₁(_lh_testSlowTwo_arg1⁰) = if (_lh_testSlowTwo_arg1⁰ < 0) then [LH_C 1 [LH_N]] else concat_lh_₁^52(
//│ 	let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 		LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C testSlowTwo_lh_₁^54((_lh_testSlowTwo_arg1⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun⁰(enumFromTo_lh_₁^69(0, _lh_testSlowTwo_arg1⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec mappend_lh__d1 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (`LH_C(h_0, ((mappend_lh__d1 t_0) ys_0)))
//│ 		    | `LH_N -> 
//│ 		      ys_0);;
//│ 		let rec concat_lh__d1 lss_0 =
//│ 		  (match lss_0 with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      ((mappend_lh__d1 h_1) (concat_lh__d1 t_1))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec enumFromTo_lh__d1 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d1 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec testSlowTwo_lh__d1 _lh_testSlowTwo_arg1_0 =
//│ 		  (if (_lh_testSlowTwo_arg1_0 < 0) then
//│ 		    (`LH_C(1, (`LH_N)))
//│ 		  else
//│ 		    (concat_lh__d1 (let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│ 		      (match _lh_listcomp_fun_para_0 with
//│ 		        | `LH_C(_lh_listcomp_fun_ls_h_0, _lh_listcomp_fun_ls_t_0) -> 
//│ 		          (`LH_C((testSlowTwo_lh__d1 (_lh_testSlowTwo_arg1_0 - 1)), (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))) in
//│ 		      (_lh_listcomp_fun_0 ((enumFromTo_lh__d1 0) _lh_testSlowTwo_arg1_0)))));;
//│ 		(testSlowTwo_lh__d1 8)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C testSlowTwo_lh_₁((_lh_testSlowTwo_arg1⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 66
//│ [LH_N]: 29 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C testSlowTwo_lh_₁((_lh_testSlowTwo_arg1⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 66
//│ [LH_N]: 41 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_N]: 50 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C 1 [LH_N]]: 51 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C testSlowTwo_lh_₁((_lh_testSlowTwo_arg1⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 64 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ [LH_N]: 65 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ ------------------
//│ case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10 --->
//│ 	[LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8
//│ 	[LH_N]: 41
//│ 	[LH_N]: 50
//│ 	[LH_C 1 [LH_N]]: 51
//│ case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42 --->
//│ 	[LH_C testSlowTwo_lh_₁((_lh_testSlowTwo_arg1⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 64
//│ 	[LH_N]: 65
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C testSlowTwo_lh_₁((_lh_testSlowTwo_arg1⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 66 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28
//│ 	[LH_N]: 29
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C testSlowTwo_lh_₁((_lh_testSlowTwo_arg1⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 66
//│ [LH_N]: 29 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C testSlowTwo_lh_₁((_lh_testSlowTwo_arg1⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 66
//│ [LH_C testSlowTwo_lh_₁((_lh_testSlowTwo_arg1⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 64 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ [LH_N]: 65 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ ------------------
//│ case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42 --->
//│ 	[LH_C testSlowTwo_lh_₁((_lh_testSlowTwo_arg1⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 64
//│ 	[LH_N]: 65
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C testSlowTwo_lh_₁((_lh_testSlowTwo_arg1⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 66 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28
//│ 	[LH_N]: 29
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSlowTwo_lh_₁(primId⁰(8))
//│ def concat_lh_₁(lss¹) = lss¹(99)
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let _lh_listcomp_fun_ls_t¹ = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let _lh_listcomp_fun_ls_h¹ = a¹
//│ 	in (fun _lh_listcomp_fun¹ -> (fun _lh_testSlowTwo_arg1¹ -> 
//│ 		let t² = _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)
//│ 		in let h² = testSlowTwo_lh_₁((_lh_testSlowTwo_arg1¹ - 1))
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h², concat_lh_₁(t²))))) else (fun _lh_listcomp_fun² -> (fun _lh_testSlowTwo_arg1² -> (fun _lh_dummy¹ -> [LH_N])))
//│ def mappend_lh_₁(xs¹, ys¹) = case xs¹ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys¹)]
//│ 	| LH_N  => ys¹}
//│ def testSlowTwo_lh_₁(_lh_testSlowTwo_arg1³) = if (_lh_testSlowTwo_arg1³ < 0) then [LH_C 1 [LH_N]] else concat_lh_₁(
//│ 	let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun³, _lh_testSlowTwo_arg1³))
//│ 	in _lh_listcomp_fun³(enumFromTo_lh_₁(0, _lh_testSlowTwo_arg1³)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ testSlowTwo_lh_₁, concat_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₁ -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ if (primId⁰(8) < 0) then [LH_C 1 [LH_N]] else 
//│ 	let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> _lh_listcomp_fun_para⁰(_lh_listcomp_fun⁰, primId⁰(8)))
//│ 	in _lh_listcomp_fun⁰(enumFromTo_lh_₁(0, primId⁰(8)))(99)
//│ def concat_lh_₁(lss⁰) = lss⁰(99)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_listcomp_fun_ls_t⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_listcomp_fun_ls_h⁰ = a⁰
//│ 	in (fun _lh_listcomp_fun¹ -> (fun _lh_testSlowTwo_arg1⁰ -> 
//│ 		let t¹ = _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t⁰)
//│ 		in let h¹ = if ((_lh_testSlowTwo_arg1⁰ - 1) < 0) then [LH_C 1 [LH_N]] else 
//│ 			let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun², (_lh_testSlowTwo_arg1⁰ - 1)))
//│ 			in _lh_listcomp_fun²(enumFromTo_lh_₁(0, (_lh_testSlowTwo_arg1⁰ - 1)))(99)
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h¹, t¹(99))))) else (fun _lh_listcomp_fun³ -> (fun _lh_testSlowTwo_arg1¹ -> (fun _lh_dummy¹ -> [LH_N])))
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testSlowTwo_lh_₁(_lh_testSlowTwo_arg1²) = if (_lh_testSlowTwo_arg1² < 0) then [LH_C 1 [LH_N]] else 
//│ 	let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para² -> _lh_listcomp_fun_para²(_lh_listcomp_fun⁴, _lh_testSlowTwo_arg1²))
//│ 	in _lh_listcomp_fun⁴(enumFromTo_lh_₁(0, _lh_testSlowTwo_arg1²))(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ if (primId⁰(8) < 0) then [LH_C 1 [LH_N]] else 
//│ 	let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> _lh_listcomp_fun_para⁰(_lh_listcomp_fun⁰, primId⁰(8)))
//│ 	in _lh_listcomp_fun⁰(enumFromTo_lh_₁(0, primId⁰(8)))(99)
//│ def concat_lh_₁(lss⁰) = lss⁰(99)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_listcomp_fun_ls_t⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_listcomp_fun_ls_h⁰ = a⁰
//│ 	in (fun _lh_listcomp_fun¹ -> (fun _lh_testSlowTwo_arg1⁰ -> 
//│ 		let t¹ = _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t⁰)
//│ 		in let h¹ = if ((_lh_testSlowTwo_arg1⁰ - 1) < 0) then [LH_C 1 [LH_N]] else 
//│ 			let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun², (_lh_testSlowTwo_arg1⁰ - 1)))
//│ 			in _lh_listcomp_fun²(enumFromTo_lh_₁(0, (_lh_testSlowTwo_arg1⁰ - 1)))(99)
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h¹, t¹(99))))) else (fun _lh_listcomp_fun³ -> (fun _lh_testSlowTwo_arg1¹ -> (fun _lh_dummy¹ -> [LH_N])))
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testSlowTwo_lh_₁(_lh_testSlowTwo_arg1²) = if (_lh_testSlowTwo_arg1² < 0) then [LH_C 1 [LH_N]] else 
//│ 	let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para² -> _lh_listcomp_fun_para²(_lh_listcomp_fun⁴, _lh_testSlowTwo_arg1²))
//│ 	in _lh_listcomp_fun⁴(enumFromTo_lh_₁(0, _lh_testSlowTwo_arg1²))(99)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
testNotSlow2Two n = if n < 0 then [1] else concat [ testNotSlow2Two (x - 1) | x <- [0..n] ]
testNotSlow2Two $ primId 15
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testNotSlow2Two_lh_₁^79(primId⁰(15))
//│ def concat_lh_₁(lss⁰) = case lss⁰ of {
//│ 	LH_C h¹ t¹ => mappend_lh_₁^34(h¹, concat_lh_₁^37(t¹))
//│ 	| LH_N  => [LH_N]}
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^19((a⁰ + 1), b⁰)] else [LH_N]
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁^3(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testNotSlow2Two_lh_₁(_lh_testNotSlow2Two_arg1⁰) = if (_lh_testNotSlow2Two_arg1⁰ < 0) then [LH_C 1 [LH_N]] else concat_lh_₁^52(
//│ 	let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 		LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C testNotSlow2Two_lh_₁^54((_lh_listcomp_fun_ls_h⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun⁰(enumFromTo_lh_₁^69(0, _lh_testNotSlow2Two_arg1⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec mappend_lh__d1 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (`LH_C(h_0, ((mappend_lh__d1 t_0) ys_0)))
//│ 		    | `LH_N -> 
//│ 		      ys_0);;
//│ 		let rec concat_lh__d1 lss_0 =
//│ 		  (match lss_0 with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      ((mappend_lh__d1 h_1) (concat_lh__d1 t_1))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec enumFromTo_lh__d1 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d1 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec testNotSlow2Two_lh__d1 _lh_testNotSlow2Two_arg1_0 =
//│ 		  (if (_lh_testNotSlow2Two_arg1_0 < 0) then
//│ 		    (`LH_C(1, (`LH_N)))
//│ 		  else
//│ 		    (concat_lh__d1 (let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│ 		      (match _lh_listcomp_fun_para_0 with
//│ 		        | `LH_C(_lh_listcomp_fun_ls_h_0, _lh_listcomp_fun_ls_t_0) -> 
//│ 		          (`LH_C((testNotSlow2Two_lh__d1 (_lh_listcomp_fun_ls_h_0 - 1)), (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))) in
//│ 		      (_lh_listcomp_fun_0 ((enumFromTo_lh__d1 0) _lh_testNotSlow2Two_arg1_0)))));;
//│ 		(testNotSlow2Two_lh__d1 15)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C testNotSlow2Two_lh_₁((_lh_listcomp_fun_ls_h⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 66
//│ [LH_N]: 29 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C testNotSlow2Two_lh_₁((_lh_listcomp_fun_ls_h⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 66
//│ [LH_N]: 41 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_N]: 50 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C 1 [LH_N]]: 51 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C testNotSlow2Two_lh_₁((_lh_listcomp_fun_ls_h⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 64 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ [LH_N]: 65 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ ------------------
//│ case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10 --->
//│ 	[LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8
//│ 	[LH_N]: 41
//│ 	[LH_N]: 50
//│ 	[LH_C 1 [LH_N]]: 51
//│ case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42 --->
//│ 	[LH_C testNotSlow2Two_lh_₁((_lh_listcomp_fun_ls_h⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 64
//│ 	[LH_N]: 65
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C testNotSlow2Two_lh_₁((_lh_listcomp_fun_ls_h⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 66 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28
//│ 	[LH_N]: 29
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C testNotSlow2Two_lh_₁((_lh_listcomp_fun_ls_h⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 66
//│ [LH_N]: 29 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C testNotSlow2Two_lh_₁((_lh_listcomp_fun_ls_h⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 66
//│ [LH_C testNotSlow2Two_lh_₁((_lh_listcomp_fun_ls_h⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 64 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ [LH_N]: 65 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42
//│ ------------------
//│ case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 42 --->
//│ 	[LH_C testNotSlow2Two_lh_₁((_lh_listcomp_fun_ls_h⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 64
//│ 	[LH_N]: 65
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C testNotSlow2Two_lh_₁((_lh_listcomp_fun_ls_h⁰ - 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 66 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 28
//│ 	[LH_N]: 29
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testNotSlow2Two_lh_₁(primId⁰(15))
//│ def concat_lh_₁(lss¹) = lss¹(99)
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let _lh_listcomp_fun_ls_t¹ = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let _lh_listcomp_fun_ls_h¹ = a¹
//│ 	in (fun _lh_listcomp_fun¹ -> 
//│ 		let t² = _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)
//│ 		in let h² = testNotSlow2Two_lh_₁((_lh_listcomp_fun_ls_h¹ - 1))
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h², concat_lh_₁(t²)))) else (fun _lh_listcomp_fun² -> (fun _lh_dummy¹ -> [LH_N]))
//│ def mappend_lh_₁(xs¹, ys¹) = case xs¹ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys¹)]
//│ 	| LH_N  => ys¹}
//│ def testNotSlow2Two_lh_₁(_lh_testNotSlow2Two_arg1¹) = if (_lh_testNotSlow2Two_arg1¹ < 0) then [LH_C 1 [LH_N]] else concat_lh_₁(
//│ 	let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun³))
//│ 	in _lh_listcomp_fun³(enumFromTo_lh_₁(0, _lh_testNotSlow2Two_arg1¹)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ testNotSlow2Two_lh_₁, concat_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₁ -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ if (primId⁰(15) < 0) then [LH_C 1 [LH_N]] else 
//│ 	let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> _lh_listcomp_fun_para⁰(_lh_listcomp_fun⁰))
//│ 	in _lh_listcomp_fun⁰(enumFromTo_lh_₁(0, primId⁰(15)))(99)
//│ def concat_lh_₁(lss⁰) = lss⁰(99)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_listcomp_fun_ls_t⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_listcomp_fun_ls_h⁰ = a⁰
//│ 	in (fun _lh_listcomp_fun¹ -> 
//│ 		let t¹ = _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t⁰)
//│ 		in let h¹ = if ((_lh_listcomp_fun_ls_h⁰ - 1) < 0) then [LH_C 1 [LH_N]] else 
//│ 			let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun²))
//│ 			in _lh_listcomp_fun²(enumFromTo_lh_₁(0, (_lh_listcomp_fun_ls_h⁰ - 1)))(99)
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h¹, t¹(99)))) else (fun _lh_listcomp_fun³ -> (fun _lh_dummy¹ -> [LH_N]))
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testNotSlow2Two_lh_₁(_lh_testNotSlow2Two_arg1⁰) = if (_lh_testNotSlow2Two_arg1⁰ < 0) then [LH_C 1 [LH_N]] else 
//│ 	let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para² -> _lh_listcomp_fun_para²(_lh_listcomp_fun⁴))
//│ 	in _lh_listcomp_fun⁴(enumFromTo_lh_₁(0, _lh_testNotSlow2Two_arg1⁰))(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ if (primId⁰(15) < 0) then [LH_C 1 [LH_N]] else 
//│ 	let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> _lh_listcomp_fun_para⁰(_lh_listcomp_fun⁰))
//│ 	in _lh_listcomp_fun⁰(enumFromTo_lh_₁(0, primId⁰(15)))(99)
//│ def concat_lh_₁(lss⁰) = lss⁰(99)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_listcomp_fun_ls_t⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_listcomp_fun_ls_h⁰ = a⁰
//│ 	in (fun _lh_listcomp_fun¹ -> 
//│ 		let t¹ = _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t⁰)
//│ 		in let h¹ = if ((_lh_listcomp_fun_ls_h⁰ - 1) < 0) then [LH_C 1 [LH_N]] else 
//│ 			let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun²))
//│ 			in _lh_listcomp_fun²(enumFromTo_lh_₁(0, (_lh_listcomp_fun_ls_h⁰ - 1)))(99)
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h¹, t¹(99)))) else (fun _lh_listcomp_fun³ -> (fun _lh_dummy¹ -> [LH_N]))
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testNotSlow2Two_lh_₁(_lh_testNotSlow2Two_arg1⁰) = if (_lh_testNotSlow2Two_arg1⁰ < 0) then [LH_C 1 [LH_N]] else 
//│ 	let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para² -> _lh_listcomp_fun_para²(_lh_listcomp_fun⁴))
//│ 	in _lh_listcomp_fun⁴(enumFromTo_lh_₁(0, _lh_testNotSlow2Two_arg1⁰))(99)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
testNotSlow3Two n = if n < 0 then [1] else let tmp = testNotSlow3Two (n - 1) in concat [ tmp | x <- [0..n] ]
testNotSlow3Two $ primId 8
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testNotSlow3Two_lh_₁^81(primId⁰(8))
//│ def concat_lh_₁(lss⁰) = case lss⁰ of {
//│ 	LH_C h¹ t¹ => mappend_lh_₁^14(h¹, concat_lh_₁^17(t¹))
//│ 	| LH_N  => [LH_N]}
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^30((a⁰ + 1), b⁰)] else [LH_N]
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁^3(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testNotSlow3Two_lh_₁(_lh_testNotSlow3Two_arg1⁰) = if (_lh_testNotSlow3Two_arg1⁰ < 0) then [LH_C 1 [LH_N]] else 
//│ 	let tmp⁰ = testNotSlow3Two_lh_₁^52((_lh_testNotSlow3Two_arg1⁰ - 1))
//│ 	in concat_lh_₁^59(
//│ 		let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C tmp⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁰(enumFromTo_lh_₁^70(0, _lh_testNotSlow3Two_arg1⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_lh__d1 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d1 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec mappend_lh__d1 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (`LH_C(h_0, ((mappend_lh__d1 t_0) ys_0)))
//│ 		    | `LH_N -> 
//│ 		      ys_0);;
//│ 		let rec concat_lh__d1 lss_0 =
//│ 		  (match lss_0 with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      ((mappend_lh__d1 h_1) (concat_lh__d1 t_1))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec testNotSlow3Two_lh__d1 _lh_testNotSlow3Two_arg1_0 =
//│ 		  (if (_lh_testNotSlow3Two_arg1_0 < 0) then
//│ 		    (`LH_C(1, (`LH_N)))
//│ 		  else
//│ 		    (let rec tmp_0 = (testNotSlow3Two_lh__d1 (_lh_testNotSlow3Two_arg1_0 - 1)) in
//│ 		      (concat_lh__d1 (let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│ 		        (match _lh_listcomp_fun_para_0 with
//│ 		          | `LH_C(_lh_listcomp_fun_ls_h_0, _lh_listcomp_fun_ls_t_0) -> 
//│ 		            (`LH_C(tmp_0, (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0)))
//│ 		          | `LH_N -> 
//│ 		            (`LH_N))) in
//│ 		        (_lh_listcomp_fun_0 ((enumFromTo_lh__d1 0) _lh_testNotSlow3Two_arg1_0))))));;
//│ 		(testNotSlow3Two_lh__d1 8)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_N]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 39 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C tmp⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 67
//│ [LH_N]: 40 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C tmp⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 67
//│ [LH_N]: 50 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C 1 [LH_N]]: 51 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C tmp⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 65 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 22
//│ [LH_N]: 66 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 22
//│ ------------------
//│ case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10 --->
//│ 	[LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8
//│ 	[LH_N]: 21
//│ 	[LH_N]: 50
//│ 	[LH_C 1 [LH_N]]: 51
//│ case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 22 --->
//│ 	[LH_C tmp⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 65
//│ 	[LH_N]: 66
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C tmp⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 67 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 39
//│ 	[LH_N]: 40
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 39 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C tmp⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 67
//│ [LH_N]: 40 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C tmp⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 67
//│ [LH_C tmp⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 65 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 22
//│ [LH_N]: 66 --->
//│ 	case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 22
//│ ------------------
//│ case lss⁰ of {LH_C h¹ t¹ => mappend_lh_₁(h¹, concat_lh_₁(t¹)) | LH_N  => [LH_N]}: 22 --->
//│ 	[LH_C tmp⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 65
//│ 	[LH_N]: 66
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C tmp⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 67 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 39
//│ 	[LH_N]: 40
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testNotSlow3Two_lh_₁(primId⁰(8))
//│ def concat_lh_₁(lss¹) = lss¹(99)
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let _lh_listcomp_fun_ls_t¹ = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let _lh_listcomp_fun_ls_h¹ = a¹
//│ 	in (fun _lh_listcomp_fun¹ -> (fun tmp¹ -> 
//│ 		let t² = _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)
//│ 		in let h² = tmp¹
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h², concat_lh_₁(t²))))) else (fun _lh_listcomp_fun² -> (fun tmp² -> (fun _lh_dummy¹ -> [LH_N])))
//│ def mappend_lh_₁(xs¹, ys¹) = case xs¹ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys¹)]
//│ 	| LH_N  => ys¹}
//│ def testNotSlow3Two_lh_₁(_lh_testNotSlow3Two_arg1¹) = if (_lh_testNotSlow3Two_arg1¹ < 0) then [LH_C 1 [LH_N]] else 
//│ 	let tmp³ = testNotSlow3Two_lh_₁((_lh_testNotSlow3Two_arg1¹ - 1))
//│ 	in concat_lh_₁(
//│ 		let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun³, tmp³))
//│ 		in _lh_listcomp_fun³(enumFromTo_lh_₁(0, _lh_testNotSlow3Two_arg1¹)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ recursive consumer: testNotSlow3Two_lh_₁
//│ concat_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₁ -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testNotSlow3Two_lh_₁(primId⁰(8))
//│ def concat_lh_₁(lss⁰) = lss⁰(99)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_listcomp_fun_ls_t⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_listcomp_fun_ls_h⁰ = a⁰
//│ 	in (fun _lh_listcomp_fun⁰ -> (fun tmp⁰ -> 
//│ 		let t¹ = _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)
//│ 		in let h¹ = tmp⁰
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h¹, t¹(99))))) else (fun _lh_listcomp_fun¹ -> (fun tmp¹ -> (fun _lh_dummy¹ -> [LH_N])))
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testNotSlow3Two_lh_₁(_lh_testNotSlow3Two_arg1⁰) = if (_lh_testNotSlow3Two_arg1⁰ < 0) then [LH_C 1 [LH_N]] else 
//│ 	let tmp² = testNotSlow3Two_lh_₁((_lh_testNotSlow3Two_arg1⁰ - 1))
//│ 	in let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para⁰ -> _lh_listcomp_fun_para⁰(_lh_listcomp_fun², tmp²))
//│ 		in _lh_listcomp_fun²(enumFromTo_lh_₁(0, _lh_testNotSlow3Two_arg1⁰))(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testNotSlow3Two_lh_₁(primId⁰(8))
//│ def concat_lh_₁(lss⁰) = lss⁰(99)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_listcomp_fun_ls_t⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_listcomp_fun_ls_h⁰ = a⁰
//│ 	in (fun _lh_listcomp_fun⁰ -> (fun tmp⁰ -> 
//│ 		let t¹ = _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)
//│ 		in let h¹ = tmp⁰
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h¹, t¹(99))))) else (fun _lh_listcomp_fun¹ -> (fun tmp¹ -> (fun _lh_dummy¹ -> [LH_N])))
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testNotSlow3Two_lh_₁(_lh_testNotSlow3Two_arg1⁰) = if (_lh_testNotSlow3Two_arg1⁰ < 0) then [LH_C 1 [LH_N]] else 
//│ 	let tmp² = testNotSlow3Two_lh_₁((_lh_testNotSlow3Two_arg1⁰ - 1))
//│ 	in let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para⁰ -> _lh_listcomp_fun_para⁰(_lh_listcomp_fun², tmp²))
//│ 		in _lh_listcomp_fun²(enumFromTo_lh_₁(0, _lh_testNotSlow3Two_arg1⁰))(99)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
f n ls = map (\x -> testNotSlowTwo (n - 1)) ls
testNotSlowTwo n = if n < 0 then [1] else concat (f n [0..n])
testNotSlowTwo $ primId 10
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testNotSlowTwo_lh_₁^93(primId⁰(10))
//│ def concat_lh_₁(lss⁰) = case lss⁰ of {
//│ 	LH_C h² t² => mappend_lh_₁^62(h², concat_lh_₁^65(t²))
//│ 	| LH_N  => [LH_N]}
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^47((a⁰ + 1), b⁰)] else [LH_N]
//│ def f_lh_₁(_lh_f_arg1⁰, _lh_f_arg2⁰) = map_lh_₁^27((fun x⁰ -> testNotSlowTwo_lh_₁^28((_lh_f_arg1⁰ - 1))), _lh_f_arg2⁰)
//│ def map_lh_₁(f⁰, ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₁^5(f⁰, t⁰)]
//│ 	| LH_N  => [LH_N]}
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h¹ t¹ => [LH_C h¹ mappend_lh_₁^17(t¹, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testNotSlowTwo_lh_₁(_lh_testNotSlowTwo_arg1⁰) = if (_lh_testNotSlowTwo_arg1⁰ < 0) then [LH_C 1 [LH_N]] else concat_lh_₁^80(f_lh_₁^81(_lh_testNotSlowTwo_arg1⁰, enumFromTo_lh_₁^84(0, _lh_testNotSlowTwo_arg1⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec map_lh__d1 f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (`LH_C((f_0 h_0), ((map_lh__d1 f_0) t_0)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec enumFromTo_lh__d1 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d1 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec mappend_lh__d1 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      (`LH_C(h_1, ((mappend_lh__d1 t_1) ys_0)))
//│ 		    | `LH_N -> 
//│ 		      ys_0);;
//│ 		let rec concat_lh__d1 lss_0 =
//│ 		  (match lss_0 with
//│ 		    | `LH_C(h_2, t_2) -> 
//│ 		      ((mappend_lh__d1 h_2) (concat_lh__d1 t_2))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec f_lh__d1 _lh_f_arg1_0 _lh_f_arg2_0 =
//│ 		  ((map_lh__d1 (fun x_0 -> 
//│ 		    (testNotSlowTwo_lh__d1 (_lh_f_arg1_0 - 1)))) _lh_f_arg2_0)
//│ 		and
//│ 		testNotSlowTwo_lh__d1 _lh_testNotSlowTwo_arg1_0 =
//│ 		  (if (_lh_testNotSlowTwo_arg1_0 < 0) then
//│ 		    (`LH_C(1, (`LH_N)))
//│ 		  else
//│ 		    (concat_lh__d1 ((f_lh__d1 _lh_testNotSlowTwo_arg1_0) ((enumFromTo_lh__d1 0) _lh_testNotSlowTwo_arg1_0))));;
//│ 		(testNotSlowTwo_lh__d1 10)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f⁰(h⁰) map_lh_₁(f⁰, t⁰)]: 10 --->
//│ 	case lss⁰ of {LH_C h² t² => mappend_lh_₁(h², concat_lh_₁(t²)) | LH_N  => [LH_N]}: 70
//│ [LH_N]: 11 --->
//│ 	case lss⁰ of {LH_C h² t² => mappend_lh_₁(h², concat_lh_₁(t²)) | LH_N  => [LH_N]}: 70
//│ [LH_C h¹ mappend_lh_₁(t¹, ys⁰)]: 22 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h¹ t¹ => [LH_C h¹ mappend_lh_₁(t¹, ys⁰)] | LH_N  => ys⁰}: 24
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 56 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₁(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ [LH_N]: 57 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₁(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ [LH_N]: 69 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h¹ t¹ => [LH_C h¹ mappend_lh_₁(t¹, ys⁰)] | LH_N  => ys⁰}: 24
//│ [LH_N]: 78 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h¹ t¹ => [LH_C h¹ mappend_lh_₁(t¹, ys⁰)] | LH_N  => ys⁰}: 24
//│ [LH_C 1 [LH_N]]: 79 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h¹ t¹ => [LH_C h¹ mappend_lh_₁(t¹, ys⁰)] | LH_N  => ys⁰}: 24
//│ ------------------
//│ case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₁(f⁰, t⁰)] | LH_N  => [LH_N]}: 12 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 56
//│ 	[LH_N]: 57
//│ case xs⁰ of {LH_C h¹ t¹ => [LH_C h¹ mappend_lh_₁(t¹, ys⁰)] | LH_N  => ys⁰}: 24 --->
//│ 	[LH_C h¹ mappend_lh_₁(t¹, ys⁰)]: 22
//│ 	[LH_N]: 69
//│ 	[LH_N]: 78
//│ 	[LH_C 1 [LH_N]]: 79
//│ case lss⁰ of {LH_C h² t² => mappend_lh_₁(h², concat_lh_₁(t²)) | LH_N  => [LH_N]}: 70 --->
//│ 	[LH_C f⁰(h⁰) map_lh_₁(f⁰, t⁰)]: 10
//│ 	[LH_N]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f⁰(h⁰) map_lh_₁(f⁰, t⁰)]: 10 --->
//│ 	case lss⁰ of {LH_C h² t² => mappend_lh_₁(h², concat_lh_₁(t²)) | LH_N  => [LH_N]}: 70
//│ [LH_N]: 11 --->
//│ 	case lss⁰ of {LH_C h² t² => mappend_lh_₁(h², concat_lh_₁(t²)) | LH_N  => [LH_N]}: 70
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 56 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₁(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ [LH_N]: 57 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₁(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ ------------------
//│ case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₁(f⁰, t⁰)] | LH_N  => [LH_N]}: 12 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 56
//│ 	[LH_N]: 57
//│ case lss⁰ of {LH_C h² t² => mappend_lh_₁(h², concat_lh_₁(t²)) | LH_N  => [LH_N]}: 70 --->
//│ 	[LH_C f⁰(h⁰) map_lh_₁(f⁰, t⁰)]: 10
//│ 	[LH_N]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testNotSlowTwo_lh_₁(primId⁰(10))
//│ def concat_lh_₁(lss¹) = lss¹(99)
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let t³ = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let h³ = a¹
//│ 	in (fun f² -> 
//│ 		let t⁴ = map_lh_₁(f², t³)
//│ 		in let h⁴ = f²(h³)
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h⁴, concat_lh_₁(t⁴)))) else (fun f³ -> (fun _lh_dummy¹ -> [LH_N]))
//│ def f_lh_₁(_lh_f_arg1¹, _lh_f_arg2¹) = map_lh_₁((fun x¹ -> testNotSlowTwo_lh_₁((_lh_f_arg1¹ - 1))), _lh_f_arg2¹)
//│ def map_lh_₁(f¹, ls¹) = ls¹(f¹)
//│ def mappend_lh_₁(xs¹, ys¹) = case xs¹ of {
//│ 	LH_C h¹ t¹ => [LH_C h¹ mappend_lh_₁(t¹, ys¹)]
//│ 	| LH_N  => ys¹}
//│ def testNotSlowTwo_lh_₁(_lh_testNotSlowTwo_arg1¹) = if (_lh_testNotSlowTwo_arg1¹ < 0) then [LH_C 1 [LH_N]] else concat_lh_₁(f_lh_₁(_lh_testNotSlowTwo_arg1¹, enumFromTo_lh_₁(0, _lh_testNotSlowTwo_arg1¹)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map_lh_₁, concat_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₁ -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testNotSlowTwo_lh_₁(primId⁰(10))
//│ def concat_lh_₁(lss⁰) = lss⁰(99)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let t¹ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let h¹ = a⁰
//│ 	in (fun f¹ -> 
//│ 		let t² = t¹(f¹)
//│ 		in let h² = f¹(h¹)
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h², t²(99)))) else (fun f² -> (fun _lh_dummy¹ -> [LH_N]))
//│ def f_lh_₁(_lh_f_arg1⁰, _lh_f_arg2⁰) = _lh_f_arg2⁰((fun x⁰ -> testNotSlowTwo_lh_₁((_lh_f_arg1⁰ - 1))))
//│ def map_lh_₁(f⁰, ls⁰) = ls⁰(f⁰)
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testNotSlowTwo_lh_₁(_lh_testNotSlowTwo_arg1⁰) = if (_lh_testNotSlowTwo_arg1⁰ < 0) then [LH_C 1 [LH_N]] else f_lh_₁(_lh_testNotSlowTwo_arg1⁰, enumFromTo_lh_₁(0, _lh_testNotSlowTwo_arg1⁰), 99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testNotSlowTwo_lh_₁(primId⁰(10))
//│ def concat_lh_₁(lss⁰) = lss⁰(99)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let t¹ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let h¹ = a⁰
//│ 	in (fun f¹ -> 
//│ 		let t² = t¹(f¹)
//│ 		in let h² = f¹(h¹)
//│ 		in (fun _lh_dummy⁰ -> mappend_lh_₁(h², t²(99)))) else (fun f² -> (fun _lh_dummy¹ -> [LH_N]))
//│ def f_lh_₁(_lh_f_arg1⁰, _lh_f_arg2⁰) = _lh_f_arg2⁰((fun x⁰ -> testNotSlowTwo_lh_₁((_lh_f_arg1⁰ - 1))))
//│ def map_lh_₁(f⁰, ls⁰) = ls⁰(f⁰)
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def testNotSlowTwo_lh_₁(_lh_testNotSlowTwo_arg1⁰) = if (_lh_testNotSlowTwo_arg1⁰ < 0) then [LH_C 1 [LH_N]] else f_lh_₁(_lh_testNotSlowTwo_arg1⁰, enumFromTo_lh_₁(0, _lh_testNotSlowTwo_arg1⁰), 99)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

