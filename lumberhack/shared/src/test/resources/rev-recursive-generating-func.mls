:NewParser
:ParseOnly

// NOTE: will only fuse the `rev` for the first iteration, the second iteration will not fuse due to things flowing into toplevelConstraits
_LUMBERHACK_EVAL
fun concat(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
fun genCountDown(n) = if n > 0 then C(n, genCountDown(n - 1)) else N
rev(genCountDown(4))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|#fun| |genCountDown|(|n|)| |#=| |#if| |n| |>| |0| |#then| |C|(|n|,| |genCountDown|(|n| |-| |1|)|)| |#else| |N|↵|rev|(|genCountDown|(|4|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; fun genCountDown = n, => if (> (n,) (0,)) then C (n, genCountDown (- (n,) (1,),),) else N; rev (genCountDown (4,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^43(genCountDown^44(4))
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat^4(t⁰, ys⁰)]}
//│ def genCountDown(n⁰) = if (n⁰ > 0) then [C n⁰ genCountDown^32((n⁰ - 1))] else [N]
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^14(rev^15(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [N]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [genCountDown^44]
//│ 	[genCountDown^44 · genCountDown^32] ---> [genCountDown^44] (only one)
//│ [rev^43]
//│ 	[rev^43 · concat^14]
//│ 		[rev^43 · concat^14 · concat^4] ---> [rev^43 · concat^14] (only one)
//│ 	[rev^43 · rev^15] ---> [rev^43] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀(genCountDown_₀(4))
//│ def genCountDown_₀(n¹) = 
//│ 	if (n¹ > 0) then [C n¹ genCountDown_₀((n¹ - 1))] else [N]
//│ def rev_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h² t² => concat_₀(rev_₀(t²), [C h² [N]])
//│ 		| N  => [N]}
//│ 	where
//│ 	def concat_₀(xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			N  => ys¹
//│ 			| C h³ t³ => [C h³ concat_₀(t³, ys¹)]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 55 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 87
//│ [C h² [N]]: 56 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 87
//│ [N]: 58 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 87
//│ [C n¹ genCountDown_₀((n¹ - 1))]: 74 --->
//│ 	case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 59
//│ [N]: 75 --->
//│ 	case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 59
//│ [C h³ concat_₀(t³, ys¹)]: 86 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 87
//│ ------------------
//│ case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 59 --->
//│ 	[C n¹ genCountDown_₀((n¹ - 1))]: 74
//│ 	[N]: 75
//│ case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 87 --->
//│ 	[N]: 55
//│ 	[C h² [N]]: 56
//│ 	[N]: 58
//│ 	[C h³ concat_₀(t³, ys¹)]: 86
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C n¹ genCountDown_₀((n¹ - 1))]: 74 --->
//│ 	case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 59
//│ [N]: 75 --->
//│ 	case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 59
//│ ------------------
//│ case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 59 --->
//│ 	[C n¹ genCountDown_₀((n¹ - 1))]: 74
//│ 	[N]: 75
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(genCountDown_₀(4))
//│ def genCountDown_₀(n²) = 
//│ 	if (n² > 0) then 
//│ 		let t⁴ = genCountDown_₀((n² - 1))
//│ 		in let h⁴ = n²
//│ 		in (fun _lh_dummy⁰ -> concat_₀(rev_₀(t⁴), [C h⁴ [N]])) else (fun _lh_dummy¹ -> [N])
//│ def rev_₀(ls²) = 
//│ 	ls²(99)
//│ 	where
//│ 	def concat_₀(xs², ys²) = 
//│ 		case xs² of {
//│ 			N  => ys²
//│ 			| C h³ t³ => [C h³ concat_₀(t³, ys²)]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [N]]]]]
//│ <<<<<<< evaluate <<<<<<<


// NOTE: will only fuse the `rev` for the first iteration, the second iteration will not fuse do to things flowing into toplevelConstraits
fun concat(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
fun genCountDown(n) = if n > 0 then C(n, genCountDown(n - 1)) else N
rev(genCountDown(primitive))
//│ |#fun| |concat|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|#fun| |genCountDown|(|n|)| |#=| |#if| |n| |>| |0| |#then| |C|(|n|,| |genCountDown|(|n| |-| |1|)|)| |#else| |N|↵|rev|(|genCountDown|(|primitive|)|)|
//│ Parsed: {fun concat = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; fun genCountDown = n, => if (> (n,) (0,)) then C (n, genCountDown (- (n,) (1,),),) else N; rev (genCountDown (primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^43(genCountDown^44(primitive⁰))
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat^4(t⁰, ys⁰)]}
//│ def genCountDown(n⁰) = if (n⁰ > 0) then [C n⁰ genCountDown^32((n⁰ - 1))] else [N]
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^14(rev^15(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [genCountDown^44]
//│ 	[genCountDown^44 · genCountDown^32] ---> [genCountDown^44] (only one)
//│ [rev^43]
//│ 	[rev^43 · concat^14]
//│ 		[rev^43 · concat^14 · concat^4] ---> [rev^43 · concat^14] (only one)
//│ 	[rev^43 · rev^15] ---> [rev^43] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀(genCountDown_₀(primitive⁰))
//│ def genCountDown_₀(n¹) = 
//│ 	if (n¹ > 0) then [C n¹ genCountDown_₀((n¹ - 1))] else [N]
//│ def rev_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h² t² => concat_₀(rev_₀(t²), [C h² [N]])
//│ 		| N  => [N]}
//│ 	where
//│ 	def concat_₀(xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			N  => ys¹
//│ 			| C h³ t³ => [C h³ concat_₀(t³, ys¹)]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 55 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 87
//│ [C h² [N]]: 56 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 87
//│ [N]: 58 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 87
//│ [C n¹ genCountDown_₀((n¹ - 1))]: 74 --->
//│ 	case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 59
//│ [N]: 75 --->
//│ 	case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 59
//│ [C h³ concat_₀(t³, ys¹)]: 86 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 87
//│ ------------------
//│ case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 59 --->
//│ 	[C n¹ genCountDown_₀((n¹ - 1))]: 74
//│ 	[N]: 75
//│ case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 87 --->
//│ 	[N]: 55
//│ 	[C h² [N]]: 56
//│ 	[N]: 58
//│ 	[C h³ concat_₀(t³, ys¹)]: 86
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C n¹ genCountDown_₀((n¹ - 1))]: 74 --->
//│ 	case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 59
//│ [N]: 75 --->
//│ 	case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 59
//│ ------------------
//│ case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 59 --->
//│ 	[C n¹ genCountDown_₀((n¹ - 1))]: 74
//│ 	[N]: 75
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(genCountDown_₀(primitive⁰))
//│ def genCountDown_₀(n²) = 
//│ 	if (n² > 0) then 
//│ 		let t⁴ = genCountDown_₀((n² - 1))
//│ 		in let h⁴ = n²
//│ 		in (fun _lh_dummy⁰ -> concat_₀(rev_₀(t⁴), [C h⁴ [N]])) else (fun _lh_dummy¹ -> [N])
//│ def rev_₀(ls²) = 
//│ 	ls²(99)
//│ 	where
//│ 	def concat_₀(xs², ys²) = 
//│ 		case xs² of {
//│ 			N  => ys²
//│ 			| C h³ t³ => [C h³ concat_₀(t³, ys²)]}
//│ <<<<<<< after fusion <<<<<<<


// above is the rev using concat, below is the rev using accumulating parameters

fun rev(ls, a) = if ls is
  C(h, t) then rev(t, C(h, a))
  N then a
fun genCountDown(n) = if n > 0 then C(n, genCountDown(n - 1)) else N
rev(genCountDown(10), N)
//│ |#fun| |rev|(|ls|,| |a|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a|←|↵|#fun| |genCountDown|(|n|)| |#=| |#if| |n| |>| |0| |#then| |C|(|n|,| |genCountDown|(|n| |-| |1|)|)| |#else| |N|↵|rev|(|genCountDown|(|10|)|,| |N|)|
//│ Parsed: {fun rev = ls, a, => if ls is ‹(C (h, t,)) then rev (t, C (h, a,),); (N) then a›; fun genCountDown = n, => if (> (n,) (0,)) then C (n, genCountDown (- (n,) (1,),),) else N; rev (genCountDown (10,), N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^30(genCountDown^31(10), [N])
//│ def genCountDown(n⁰) = if (n⁰ > 0) then [C n⁰ genCountDown^19((n⁰ - 1))] else [N]
//│ def rev(ls⁰, a⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => rev^2(t⁰, [C h⁰ a⁰])
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [genCountDown^31]
//│ 	[genCountDown^31 · genCountDown^19] ---> [genCountDown^31] (only one)
//│ [rev^30]
//│ 	[rev^30 · rev^2] ---> [rev^30] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀(genCountDown_₀(10), [N])
//│ def genCountDown_₀(n¹) = 
//│ 	if (n¹ > 0) then [C n¹ genCountDown_₀((n¹ - 1))] else [N]
//│ def rev_₀(ls¹, a¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => rev_₀(t¹, [C h¹ a¹])
//│ 		| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C n¹ genCountDown_₀((n¹ - 1))]: 62 --->
//│ 	case ls¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 46
//│ [N]: 63 --->
//│ 	case ls¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 46
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 46 --->
//│ 	[C n¹ genCountDown_₀((n¹ - 1))]: 62
//│ 	[N]: 63
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C n¹ genCountDown_₀((n¹ - 1))]: 62 --->
//│ 	case ls¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 46
//│ [N]: 63 --->
//│ 	case ls¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 46
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 46 --->
//│ 	[C n¹ genCountDown_₀((n¹ - 1))]: 62
//│ 	[N]: 63
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(genCountDown_₀(10), [N])
//│ def genCountDown_₀(n²) = 
//│ 	if (n² > 0) then 
//│ 		let t² = genCountDown_₀((n² - 1))
//│ 		in let h² = n²
//│ 		in (fun a³ -> rev_₀(t², [C h² a³])) else (fun a⁴ -> a⁴)
//│ def rev_₀(ls², a²) = 
//│ 	ls²(a²)
//│ <<<<<<< after fusion <<<<<<<
