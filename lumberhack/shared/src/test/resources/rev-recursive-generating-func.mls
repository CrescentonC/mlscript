:NewParser
:ParseOnly

// NOTE: will only fuse the `rev` for the first iteration, the second iteration will not fuse due to things flowing into toplevelConstraits
_LUMBERHACK_EVAL
fun concat(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
fun genCountDown(n) = if n > 0 then C(n, genCountDown(n - 1)) else N
rev(genCountDown(4))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|#fun| |genCountDown|(|n|)| |#=| |#if| |n| |>| |0| |#then| |C|(|n|,| |genCountDown|(|n| |-| |1|)|)| |#else| |N|↵|rev|(|genCountDown|(|4|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; fun genCountDown = n, => if (> (n,) (0,)) then C (n, genCountDown (- (n,) (1,),),) else N; rev (genCountDown (4,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^43(genCountDown^44(4))
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat^4(t⁰, ys⁰)]}
//│ def genCountDown(n⁰) = if (n⁰ > 0) then [C n⁰ genCountDown^32((n⁰ - 1))] else [N]
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^14(rev^15(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [N]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ concat(t⁰, ys⁰)]: 9 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 20 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [C h¹ [N]]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 23 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [C n⁰ genCountDown((n⁰ - 1))]: 39 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ [N]: 40 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ ------------------
//│ case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10 --->
//│ 	[C h⁰ concat(t⁰, ys⁰)]: 9
//│ 	[N]: 20
//│ 	[C h¹ [N]]: 21
//│ 	[N]: 23
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24 --->
//│ 	[C n⁰ genCountDown((n⁰ - 1))]: 39
//│ 	[N]: 40
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C n⁰ genCountDown((n⁰ - 1))]: 39 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ [N]: 40 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ ------------------
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24 --->
//│ 	[C n⁰ genCountDown((n⁰ - 1))]: 39
//│ 	[N]: 40
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(genCountDown(4))
//│ def concat(xs¹, ys¹) = case xs¹ of {
//│ 	N  => ys¹
//│ 	| C h⁰ t⁰ => [C h⁰ concat(t⁰, ys¹)]}
//│ def genCountDown(n¹) = if (n¹ > 0) then 
//│ 	let t² = genCountDown((n¹ - 1))
//│ 	in let h² = n¹
//│ 	in (fun _lh_dummy⁰ -> concat(rev(t²), [C h² [N]])) else (fun _lh_dummy¹ -> [N])
//│ def rev(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [N]]]]]
//│ <<<<<<< evaluate <<<<<<<


// NOTE: will only fuse the `rev` for the first iteration, the second iteration will not fuse do to things flowing into toplevelConstraits
fun concat(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
fun genCountDown(n) = if n > 0 then C(n, genCountDown(n - 1)) else N
rev(genCountDown(primitive))
//│ |#fun| |concat|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|#fun| |genCountDown|(|n|)| |#=| |#if| |n| |>| |0| |#then| |C|(|n|,| |genCountDown|(|n| |-| |1|)|)| |#else| |N|↵|rev|(|genCountDown|(|primitive|)|)|
//│ Parsed: {fun concat = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; fun genCountDown = n, => if (> (n,) (0,)) then C (n, genCountDown (- (n,) (1,),),) else N; rev (genCountDown (primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^43(genCountDown^44(primitive⁰))
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat^4(t⁰, ys⁰)]}
//│ def genCountDown(n⁰) = if (n⁰ > 0) then [C n⁰ genCountDown^32((n⁰ - 1))] else [N]
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^14(rev^15(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ concat(t⁰, ys⁰)]: 9 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 20 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [C h¹ [N]]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 23 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [C n⁰ genCountDown((n⁰ - 1))]: 39 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ [N]: 40 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ ------------------
//│ case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10 --->
//│ 	[C h⁰ concat(t⁰, ys⁰)]: 9
//│ 	[N]: 20
//│ 	[C h¹ [N]]: 21
//│ 	[N]: 23
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24 --->
//│ 	[C n⁰ genCountDown((n⁰ - 1))]: 39
//│ 	[N]: 40
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C n⁰ genCountDown((n⁰ - 1))]: 39 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ [N]: 40 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ ------------------
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24 --->
//│ 	[C n⁰ genCountDown((n⁰ - 1))]: 39
//│ 	[N]: 40
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(genCountDown(primitive⁰))
//│ def concat(xs¹, ys¹) = case xs¹ of {
//│ 	N  => ys¹
//│ 	| C h⁰ t⁰ => [C h⁰ concat(t⁰, ys¹)]}
//│ def genCountDown(n¹) = if (n¹ > 0) then 
//│ 	let t² = genCountDown((n¹ - 1))
//│ 	in let h² = n¹
//│ 	in (fun _lh_dummy⁰ -> concat(rev(t²), [C h² [N]])) else (fun _lh_dummy¹ -> [N])
//│ def rev(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<


// above is the rev using concat, below is the rev using accumulating parameters

fun rev(ls, a) = if ls is
  C(h, t) then rev(t, C(h, a))
  N then a
fun genCountDown(n) = if n > 0 then C(n, genCountDown(n - 1)) else N
rev(genCountDown(10), N)
//│ |#fun| |rev|(|ls|,| |a|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a|←|↵|#fun| |genCountDown|(|n|)| |#=| |#if| |n| |>| |0| |#then| |C|(|n|,| |genCountDown|(|n| |-| |1|)|)| |#else| |N|↵|rev|(|genCountDown|(|10|)|,| |N|)|
//│ Parsed: {fun rev = ls, a, => if ls is ‹(C (h, t,)) then rev (t, C (h, a,),); (N) then a›; fun genCountDown = n, => if (> (n,) (0,)) then C (n, genCountDown (- (n,) (1,),),) else N; rev (genCountDown (10,), N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^30(genCountDown^31(10), [N])
//│ def genCountDown(n⁰) = if (n⁰ > 0) then [C n⁰ genCountDown^19((n⁰ - 1))] else [N]
//│ def rev(ls⁰, a⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => rev^2(t⁰, [C h⁰ a⁰])
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C n⁰ genCountDown((n⁰ - 1))]: 26 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ [N]: 27 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10 --->
//│ 	[C n⁰ genCountDown((n⁰ - 1))]: 26
//│ 	[N]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C n⁰ genCountDown((n⁰ - 1))]: 26 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ [N]: 27 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10 --->
//│ 	[C n⁰ genCountDown((n⁰ - 1))]: 26
//│ 	[N]: 27
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(genCountDown(10), [N])
//│ def genCountDown(n¹) = if (n¹ > 0) then 
//│ 	let t¹ = genCountDown((n¹ - 1))
//│ 	in let h¹ = n¹
//│ 	in (fun a² -> rev(t¹, [C h¹ a²])) else (fun a³ -> a³)
//│ def rev(ls¹, a¹) = ls¹(a¹)
//│ <<<<<<< after fusion <<<<<<<
