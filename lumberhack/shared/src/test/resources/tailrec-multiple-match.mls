:NewParser
:ParseOnly


// NOTE: more to fuse if there is no strategy clash of '79_callres
// :stdout
_LUMBERHACK_EVAL
fun count(c, xs) = (if xs is
  C(h, t) then c => count(c + 1, t)
  N then c => c
)(c)
fun rev(a, ys) = (if ys is
  C(h1, t1) then a => rev(C(h1, a), t1)
  N then a => a
)(a)
count(0, rev(N, C(1, C(2, N))))
//│ |_LUMBERHACK_EVAL|↵|#fun| |count|(|c|,| |xs|)| |#=| |(|#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |c| |=>| |count|(|c| |+| |1|,| |t|)|↵|N| |#then| |c| |=>| |c|←|↵|)|(|c|)|↵|#fun| |rev|(|a|,| |ys|)| |#=| |(|#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |a| |=>| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a| |=>| |a|←|↵|)|(|a|)|↵|count|(|0|,| |rev|(|N|,| |C|(|1|,| |C|(|2|,| |N|)|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun count = c, xs, => '(' if xs is ‹(C (h, t,)) then c, => count (+ (c,) (1,), t,); (N) then c, => c›, ')' (c,); fun rev = a, ys, => '(' if ys is ‹(C (h1, t1,)) then a, => rev (C (h1, a,), t1,); (N) then a, => a›, ')' (a,); count (0, rev (N, C (1, C (2, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((count^35 0) ((rev^38 [N]) [C 1 [C 2 [N]]]))
//│ def count = (fun c⁰ -> (fun xs⁰ -> (case xs⁰ of {
//│ 	C h⁰ t⁰ => (fun c¹ -> ((count^2 (c¹ + 1)) t⁰))
//│ 	| N => (fun c² -> c²)} c⁰)))
//│ def rev = (fun a⁰ -> (fun ys⁰ -> (case ys⁰ of {
//│ 	C h1⁰ t1⁰ => (fun a¹ -> ((rev^20 [C h1⁰ a¹]) t1⁰))
//│ 	| N => (fun a² -> a²)} a⁰)))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [count^35] (hopeless to continue)
//│ 	[count^35 · count^2] ---> [count^35] (using original def)
//│ [rev^38]
//│ 	[rev^38 · rev^20] ---> [rev^38] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((count₀ 0) ((rev₀ [N]) [C 1 [C 2 [N]]]))
//│ def count₀ = 
//│ 	(fun c³ -> (fun xs¹ -> (case xs¹ of {
//│ 		C h¹ t¹ => (fun c⁴ -> ((count₀ (c⁴ + 1)) t¹))
//│ 		| N => (fun c⁵ -> c⁵)} c³)))
//│ def rev₀ = 
//│ 	(fun a³ -> (fun ys¹ -> (case ys¹ of {
//│ 		C h1¹ t1¹ => (fun a⁴ -> ((rev₀ [C h1¹ a⁴]) t1¹))
//│ 		| N => (fun a⁵ -> a⁵)} a³)))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1¹ a⁴]: 70 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c⁴ -> ((count₀ (c⁴ + 1)) t¹)) | N => (fun c⁵ -> c⁵)}: 61
//│ [N]: 86 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c⁴ -> ((count₀ (c⁴ + 1)) t¹)) | N => (fun c⁵ -> c⁵)}: 61
//│ [N]: 90 --->
//│ 	case ys¹ of {C h1¹ t1¹ => (fun a⁴ -> ((rev₀ [C h1¹ a⁴]) t1¹)) | N => (fun a⁵ -> a⁵)}: 77
//│ [C 2 [N]]: 91 --->
//│ 	case ys¹ of {C h1¹ t1¹ => (fun a⁴ -> ((rev₀ [C h1¹ a⁴]) t1¹)) | N => (fun a⁵ -> a⁵)}: 77
//│ [C 1 [C 2 [N]]]: 92 --->
//│ 	case ys¹ of {C h1¹ t1¹ => (fun a⁴ -> ((rev₀ [C h1¹ a⁴]) t1¹)) | N => (fun a⁵ -> a⁵)}: 77
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => (fun c⁴ -> ((count₀ (c⁴ + 1)) t¹)) | N => (fun c⁵ -> c⁵)}: 61 --->
//│ 	[C h1¹ a⁴]: 70
//│ 	[N]: 86
//│ case ys¹ of {C h1¹ t1¹ => (fun a⁴ -> ((rev₀ [C h1¹ a⁴]) t1¹)) | N => (fun a⁵ -> a⁵)}: 77 --->
//│ 	[N]: 90
//│ 	[C 2 [N]]: 91
//│ 	[C 1 [C 2 [N]]]: 92
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h1¹ a⁴]: 70 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c⁴ -> ((count₀ (c⁴ + 1)) t¹)) | N => (fun c⁵ -> c⁵)}: 61
//│ [N]: 86 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c⁴ -> ((count₀ (c⁴ + 1)) t¹)) | N => (fun c⁵ -> c⁵)}: 61
//│ [N]: 90 --->
//│ 	case ys¹ of {C h1¹ t1¹ => (fun a⁴ -> ((rev₀ [C h1¹ a⁴]) t1¹)) | N => (fun a⁵ -> a⁵)}: 77
//│ [C 2 [N]]: 91 --->
//│ 	case ys¹ of {C h1¹ t1¹ => (fun a⁴ -> ((rev₀ [C h1¹ a⁴]) t1¹)) | N => (fun a⁵ -> a⁵)}: 77
//│ [C 1 [C 2 [N]]]: 92 --->
//│ 	case ys¹ of {C h1¹ t1¹ => (fun a⁴ -> ((rev₀ [C h1¹ a⁴]) t1¹)) | N => (fun a⁵ -> a⁵)}: 77
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => (fun c⁴ -> ((count₀ (c⁴ + 1)) t¹)) | N => (fun c⁵ -> c⁵)}: 61 --->
//│ 	[C h1¹ a⁴]: 70
//│ 	[N]: 86
//│ case ys¹ of {C h1¹ t1¹ => (fun a⁴ -> ((rev₀ [C h1¹ a⁴]) t1¹)) | N => (fun a⁵ -> a⁵)}: 77 --->
//│ 	[N]: 90
//│ 	[C 2 [N]]: 91
//│ 	[C 1 [C 2 [N]]]: 92
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((count₀ 0) ((rev₀ (fun c⁶ -> c⁶)) 
//│ 	let h1² = 1
//│ 	in let t1² = 	
//│ 		let h1³ = 2
//│ 		in let t1³ = (fun a⁸ -> a⁸)
//│ 		in (fun a⁷ -> ((rev₀ 
//│ 			let h³ = h1³
//│ 			in let t³ = a⁷
//│ 			in (fun c⁸ -> ((count₀ (c⁸ + 1)) t³))) t1³))
//│ 	in (fun a⁶ -> ((rev₀ 
//│ 		let h² = h1²
//│ 		in let t² = a⁶
//│ 		in (fun c⁷ -> ((count₀ (c⁷ + 1)) t²))) t1²))))
//│ def count₀ = 
//│ 	(fun c⁹ -> (fun xs² -> (xs² c⁹)))
//│ def rev₀ = 
//│ 	(fun a⁹ -> (fun ys² -> (ys² a⁹)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 2
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [count₀^15] (hopeless to continue)
//│ [count₀^1] (hopeless to continue)
//│ [count₀^36] (hopeless to continue)
//│ [rev₀^12] (hopeless to continue)
//│ [rev₀^33] (hopeless to continue)
//│ [rev₀^4] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((count₀₁ 0) ((rev₀₂ (fun c⁷ -> c⁷)) 
//│ 	let h1² = 1
//│ 	in let t1² = 	
//│ 		let h1³ = 2
//│ 		in let t1³ = (fun a⁷ -> a⁷)
//│ 		in (fun a⁸ -> ((rev₀₀ 
//│ 			let h² = h1³
//│ 			in let t² = a⁸
//│ 			in (fun c⁸ -> ((count₀₀ (c⁸ + 1)) t²))) t1³))
//│ 	in (fun a⁹ -> ((rev₀₁ 
//│ 		let h³ = h1²
//│ 		in let t³ = a⁹
//│ 		in (fun c⁹ -> ((count₀₂ (c⁹ + 1)) t³))) t1²))))
//│ def count₀₀ = 
//│ 	(fun c⁴ -> (fun xs¹ -> (xs¹ c⁴)))
//│ def count₀₁ = 
//│ 	(fun c⁵ -> (fun xs² -> (xs² c⁵)))
//│ def count₀₂ = 
//│ 	(fun c⁶ -> (fun xs³ -> (xs³ c⁶)))
//│ def rev₀₀ = 
//│ 	(fun a⁴ -> (fun ys¹ -> (ys¹ a⁴)))
//│ def rev₀₁ = 
//│ 	(fun a⁶ -> (fun ys³ -> (ys³ a⁶)))
//│ def rev₀₂ = 
//│ 	(fun a⁵ -> (fun ys² -> (ys² a⁵)))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((count₀₁ 0) ((rev₀₂ (fun c¹⁰ -> c¹⁰)) 
//│ 	let h1² = 1
//│ 	in let t1² = 	
//│ 		let h1³ = 2
//│ 		in let t1³ = (fun a¹⁰ -> a¹⁰)
//│ 		in (fun a¹¹ -> ((rev₀₀ 
//│ 			let h² = h1³
//│ 			in let t² = a¹¹
//│ 			in (fun c¹¹ -> ((count₀₀ (c¹¹ + 1)) t²))) t1³))
//│ 	in (fun a¹² -> ((rev₀₁ 
//│ 		let h³ = h1²
//│ 		in let t³ = a¹²
//│ 		in (fun c¹² -> ((count₀₂ (c¹² + 1)) t³))) t1²))))
//│ def count₀₀ = 
//│ 	(fun c¹⁴ -> (fun xs⁵ -> (xs⁵ c¹⁴)))
//│ def count₀₁ = 
//│ 	(fun c¹⁵ -> (fun xs⁶ -> (xs⁶ c¹⁵)))
//│ def count₀₂ = 
//│ 	(fun c¹³ -> (fun xs⁴ -> (xs⁴ c¹³)))
//│ def rev₀₀ = 
//│ 	(fun a¹⁴ -> (fun ys⁵ -> (ys⁵ a¹⁴)))
//│ def rev₀₁ = 
//│ 	(fun a¹⁵ -> (fun ys⁶ -> (ys⁶ a¹⁵)))
//│ def rev₀₂ = 
//│ 	(fun a¹³ -> (fun ys⁴ -> (ys⁴ a¹³)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 2
//│ <<<<<<< evaluate <<<<<<<
