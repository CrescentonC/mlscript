:NewParser
:ParseOnly


// NOTE: more to fuse if there is no strategy clash of '79_callres
// :stdout
_LUMBERHACK_EVAL
fun count(c, xs) = (if xs is
  C(h, t) then c => count(c + 1, t)
  N then c => c
)(c)
fun rev(a, ys) = (if ys is
  C(h1, t1) then a => rev(C(h1, a), t1)
  N then a => a
)(a)
count(0, rev(N, C(1, C(2, N))))
//│ |_LUMBERHACK_EVAL|↵|#fun| |count|(|c|,| |xs|)| |#=| |(|#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |c| |=>| |count|(|c| |+| |1|,| |t|)|↵|N| |#then| |c| |=>| |c|←|↵|)|(|c|)|↵|#fun| |rev|(|a|,| |ys|)| |#=| |(|#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |a| |=>| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a| |=>| |a|←|↵|)|(|a|)|↵|count|(|0|,| |rev|(|N|,| |C|(|1|,| |C|(|2|,| |N|)|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun count = c, xs, => '(' if xs is ‹(C (h, t,)) then c, => count (+ (c,) (1,), t,); (N) then c, => c›, ')' (c,); fun rev = a, ys, => '(' if ys is ‹(C (h1, t1,)) then a, => rev (C (h1, a,), t1,); (N) then a, => a›, ')' (a,); count (0, rev (N, C (1, C (2, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ count^35(0, rev^38([N], [C 1 [C 2 [N]]]))
//│ def count(c⁰, xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => (fun c¹ -> count^2((c¹ + 1), t⁰))
//│ 	| N  => (fun c² -> c²)}(c⁰)
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => (fun a¹ -> rev^20([C h1⁰ a¹], t1⁰))
//│ 	| N  => (fun a² -> a²)}(a⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 2
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1⁰ a¹]: 23 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14
//│ [N]: 39 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14
//│ [N]: 43 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => (fun a¹ -> rev([C h1⁰ a¹], t1⁰)) | N  => (fun a² -> a²)}: 30
//│ [C 2 [N]]: 44 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => (fun a¹ -> rev([C h1⁰ a¹], t1⁰)) | N  => (fun a² -> a²)}: 30
//│ [C 1 [C 2 [N]]]: 45 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => (fun a¹ -> rev([C h1⁰ a¹], t1⁰)) | N  => (fun a² -> a²)}: 30
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14 --->
//│ 	[C h1⁰ a¹]: 23
//│ 	[N]: 39
//│ case ys⁰ of {C h1⁰ t1⁰ => (fun a¹ -> rev([C h1⁰ a¹], t1⁰)) | N  => (fun a² -> a²)}: 30 --->
//│ 	[N]: 43
//│ 	[C 2 [N]]: 44
//│ 	[C 1 [C 2 [N]]]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h1⁰ a¹]: 23 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14
//│ [N]: 39 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14
//│ [N]: 43 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => (fun a¹ -> rev([C h1⁰ a¹], t1⁰)) | N  => (fun a² -> a²)}: 30
//│ [C 2 [N]]: 44 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => (fun a¹ -> rev([C h1⁰ a¹], t1⁰)) | N  => (fun a² -> a²)}: 30
//│ [C 1 [C 2 [N]]]: 45 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => (fun a¹ -> rev([C h1⁰ a¹], t1⁰)) | N  => (fun a² -> a²)}: 30
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14 --->
//│ 	[C h1⁰ a¹]: 23
//│ 	[N]: 39
//│ case ys⁰ of {C h1⁰ t1⁰ => (fun a¹ -> rev([C h1⁰ a¹], t1⁰)) | N  => (fun a² -> a²)}: 30 --->
//│ 	[N]: 43
//│ 	[C 2 [N]]: 44
//│ 	[C 1 [C 2 [N]]]: 45
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ count(0, rev((fun c³ -> c³), 
//│ 	let t1¹ = 	
//│ 		let t1² = (fun a⁵ -> a⁵)
//│ 		in let h1² = 2
//│ 		in (fun a⁴ -> rev(
//│ 			let t² = a⁴
//│ 			in let h² = h1²
//│ 			in (fun c⁵ -> count((c⁵ + 1), t²)), t1²))
//│ 	in let h1¹ = 1
//│ 	in (fun a³ -> rev(
//│ 		let t¹ = a³
//│ 		in let h¹ = h1¹
//│ 		in (fun c⁴ -> count((c⁴ + 1), t¹)), t1¹))))
//│ def count(c⁶, xs¹) = xs¹(c⁶)
//│ def rev(a⁶, ys¹) = ys¹(a⁶)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 2
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev, count
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t1⁰ = 	
//│ 		let t1¹ = (fun a⁰ -> a⁰)
//│ 		in let h1⁰ = 2
//│ 		in (fun a¹ -> t1¹(
//│ 			let t⁰ = a¹
//│ 			in let h⁰ = h1⁰
//│ 			in (fun c⁰ -> t⁰((c⁰ + 1)))))
//│ 	in let h1¹ = 1
//│ 	in (fun a² -> t1⁰(
//│ 		let t¹ = a²
//│ 		in let h¹ = h1¹
//│ 		in (fun c¹ -> t¹((c¹ + 1)))))((fun c² -> c²), 0)
//│ def count(c³, xs⁰) = xs⁰(c³)
//│ def rev(a³, ys⁰) = ys⁰(a³)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t1⁰ = 	
//│ 		let t1¹ = (fun a⁰ -> a⁰)
//│ 		in let h1⁰ = 2
//│ 		in (fun a¹ -> t1¹(
//│ 			let t⁰ = a¹
//│ 			in let h⁰ = h1⁰
//│ 			in (fun c⁰ -> t⁰((c⁰ + 1)))))
//│ 	in let h1¹ = 1
//│ 	in (fun a² -> t1⁰(
//│ 		let t¹ = a²
//│ 		in let h¹ = h1¹
//│ 		in (fun c¹ -> t¹((c¹ + 1)))))((fun c² -> c²), 0)
//│ def count(c³, xs⁰) = xs⁰(c³)
//│ def rev(a³, ys⁰) = ys⁰(a³)
//│ <<<<<<< after floating out <<<<<<<
