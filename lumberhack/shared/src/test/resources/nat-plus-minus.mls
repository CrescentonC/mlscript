:NewParser
:ParseOnly

// WRONG: no fusion done
:lhEval
fun intToNat(x) = if x <= 0 then Z else S(intToNat(x - 1))
fun natAdd(x, y) = if x is
  Z then y
  S(x) then S(natAdd(x, y))
fun natMinus(x, y) = if y is
  Z then x
  S(y) then if x is
    Z then Z
    S(x) then natMinus(x, y)
fun testMinusAdd(x) = natMinus(
  natAdd(
    primId(intToNat(x)),
    primId(intToNat(3 * x))
  ),
  primId(intToNat(3 * x))
)
testMinusAdd(4)
//│ |#fun| |intToNat|(|x|)| |#=| |#if| |x| |<=| |0| |#then| |Z| |#else| |S|(|intToNat|(|x| |-| |1|)|)|↵|#fun| |natAdd|(|x|,| |y|)| |#=| |#if| |x| |is|→|Z| |#then| |y|↵|S|(|x|)| |#then| |S|(|natAdd|(|x|,| |y|)|)|←|↵|#fun| |natMinus|(|x|,| |y|)| |#=| |#if| |y| |is|→|Z| |#then| |x|↵|S|(|y|)| |#then| |#if| |x| |is|→|Z| |#then| |Z|↵|S|(|x|)| |#then| |natMinus|(|x|,| |y|)|←|←|↵|#fun| |testMinusAdd|(|x|)| |#=| |natMinus|(|→|natAdd|(|→|primId|(|intToNat|(|x|)|)|,|↵|primId|(|intToNat|(|3| |*| |x|)|)|←|↵|)|,|↵|primId|(|intToNat|(|3| |*| |x|)|)|←|↵|)|↵|testMinusAdd|(|4|)|
//│ Parsed: {fun intToNat = x, => if (<= (x,) (0,)) then Z else S (intToNat (- (x,) (1,),),); fun natAdd = x, y, => if x is ‹(Z) then y; (S (x,)) then S (natAdd (x, y,),)›; fun natMinus = x, y, => if y is ‹(Z) then x; (S (y,)) then if x is ‹(Z) then Z; (S (x,)) then natMinus (x, y,)››; fun testMinusAdd = x, => natMinus (natAdd (primId (intToNat (x,),), primId (intToNat (* (3,) (x,),),),), primId (intToNat (* (3,) (x,),),),); testMinusAdd (4,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMinusAdd^71(4)
//│ def intToNat(x⁰) = if (x⁰ <= 0) then [Z] else [S intToNat^7((x⁰ - 1))]
//│ def natAdd(x¹, y⁰) = case x¹ of {
//│ 	Z  => y⁰
//│ 	| S x² => [S natAdd^19(x², y⁰)]}
//│ def natMinus(x³, y¹) = case y¹ of {
//│ 	Z  => x³
//│ 	| S y² => case x³ of {
//│ 		Z  => [Z]
//│ 		| S x⁴ => natMinus^32(x⁴, y²)}}
//│ def testMinusAdd(x⁵) = natMinus^41(natAdd^42(primId⁰(intToNat^44(x⁵)), primId⁰(intToNat^50((3 * x⁵)))), primId⁰(intToNat^61((3 * x⁵))))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [S [S [S [S [Z]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S natAdd(x², y⁰)]: 24 --->
//│ 	NoCons
//│ 	case x³ of {Z  => [Z] | S x⁴ => natMinus(x⁴, y²)}: 37
//│ ------------------
//│ case x³ of {Z  => [Z] | S x⁴ => natMinus(x⁴, y²)}: 37 --->
//│ 	NoProd
//│ 	[S natAdd(x², y⁰)]: 24
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMinusAdd(4)
//│ def intToNat(x⁶) = if (x⁶ <= 0) then [Z] else [S intToNat((x⁶ - 1))]
//│ def natAdd(x⁷, y³) = case x⁷ of {
//│ 	Z  => y³
//│ 	| S x² => [S natAdd(x², y³)]}
//│ def natMinus(x⁸, y⁴) = case y⁴ of {
//│ 	Z  => x⁸
//│ 	| S y² => case x⁸ of {
//│ 		Z  => [Z]
//│ 		| S x⁴ => natMinus(x⁴, y²)}}
//│ def testMinusAdd(x⁹) = natMinus(natAdd(primId⁰(intToNat(x⁹)), primId⁰(intToNat((3 * x⁹)))), primId⁰(intToNat((3 * x⁹))))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [S [S [S [S [Z]]]]]
//│ <<<<<<< evaluate <<<<<<<
