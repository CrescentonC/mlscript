:NewParser
:ParseOnly


:lhInHaskell
:lhGenOCaml
a = b
b = c
c = c d
e = d
d = f d e a
f = g
g = g f
a
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ a_lh^18
//│ def a_lh = b_lh^3
//│ def b_lh = c_lh^4
//│ def c_lh = c_lh^8(d_lh^9)
//│ def d_lh = f_lh^11(d_lh^12, e_lh^14, a_lh^16)
//│ def e_lh = d_lh^1
//│ def f_lh = g_lh^2
//│ def g_lh = g_lh^5(f_lh^6)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f_lh =
//│ 		  g_lh
//│ 		and
//│ 		g_lh =
//│ 		  (g_lh f_lh);;
//│ 		let rec a_lh =
//│ 		  b_lh
//│ 		and
//│ 		b_lh =
//│ 		  c_lh
//│ 		and
//│ 		c_lh =
//│ 		  (c_lh d_lh)
//│ 		and
//│ 		d_lh =
//│ 		  (((f_lh d_lh) e_lh) a_lh)
//│ 		and
//│ 		e_lh =
//│ 		  d_lh;;
//│ 		a_lh
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ a_lh
//│ def a_lh = b_lh
//│ def b_lh = c_lh
//│ def c_lh = c_lh(d_lh)
//│ def d_lh = f_lh(d_lh, e_lh, a_lh)
//│ def e_lh = d_lh
//│ def f_lh = g_lh
//│ def g_lh = g_lh(f_lh)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec f_lh =
//│   g_lh
//│ and
//│ g_lh =
//│   (g_lh f_lh);;
//│ let rec a_lh =
//│   b_lh
//│ and
//│ b_lh =
//│   c_lh
//│ and
//│ c_lh =
//│   (c_lh d_lh)
//│ and
//│ d_lh =
//│   (((f_lh d_lh) e_lh) a_lh)
//│ and
//│ e_lh =
//│   d_lh;;
//│ a_lh
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
main = b a
a = f
b = a
f = f
main
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main_lh^7
//│ def a_lh = f_lh^2
//│ def b_lh = a_lh^6
//│ def f_lh = f_lh^1
//│ def main_lh = b_lh^3(a_lh^4)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f_lh =
//│ 		  f_lh;;
//│ 		let rec a_lh =
//│ 		  f_lh;;
//│ 		let rec b_lh =
//│ 		  a_lh;;
//│ 		let rec main_lh =
//│ 		  (b_lh a_lh);;
//│ 		main_lh
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main_lh
//│ def a_lh = f_lh
//│ def b_lh = a_lh
//│ def f_lh = f_lh
//│ def main_lh = b_lh(a_lh)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec f_lh =
//│   f_lh;;
//│ let rec a_lh =
//│   f_lh;;
//│ let rec b_lh =
//│   a_lh;;
//│ let rec main_lh =
//│   (b_lh a_lh);;
//│ main_lh
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
a = b
b = e f c
c = g d
d = c h
e = a f
f = g
g = f
h = d g
a
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ a_lh^21
//│ def a_lh = b_lh^5
//│ def b_lh = e_lh^6(f_lh^7, c_lh^9)
//│ def c_lh = g_lh^15(d_lh^16)
//│ def d_lh = c_lh^12(h_lh^13)
//│ def e_lh = a_lh^1(f_lh^2)
//│ def f_lh = g_lh^4
//│ def g_lh = f_lh^11
//│ def h_lh = d_lh^18(g_lh^19)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f_lh =
//│ 		  g_lh
//│ 		and
//│ 		g_lh =
//│ 		  f_lh;;
//│ 		let rec c_lh =
//│ 		  (g_lh d_lh)
//│ 		and
//│ 		d_lh =
//│ 		  (c_lh h_lh)
//│ 		and
//│ 		h_lh =
//│ 		  (d_lh g_lh);;
//│ 		let rec a_lh =
//│ 		  b_lh
//│ 		and
//│ 		b_lh =
//│ 		  ((e_lh f_lh) c_lh)
//│ 		and
//│ 		e_lh =
//│ 		  (a_lh f_lh);;
//│ 		a_lh
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ a_lh
//│ def a_lh = b_lh
//│ def b_lh = e_lh(f_lh, c_lh)
//│ def c_lh = g_lh(d_lh)
//│ def d_lh = c_lh(h_lh)
//│ def e_lh = a_lh(f_lh)
//│ def f_lh = g_lh
//│ def g_lh = f_lh
//│ def h_lh = d_lh(g_lh)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec f_lh =
//│   g_lh
//│ and
//│ g_lh =
//│   f_lh;;
//│ let rec c_lh =
//│   (g_lh d_lh)
//│ and
//│ d_lh =
//│   (c_lh h_lh)
//│ and
//│ h_lh =
//│   (d_lh g_lh);;
//│ let rec a_lh =
//│   b_lh
//│ and
//│ b_lh =
//│   ((e_lh f_lh) c_lh)
//│ and
//│ e_lh =
//│   (a_lh f_lh);;
//│ a_lh
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhInHaskell
:lhGenOCaml
a = b
b = c
c = a d
d = b
a
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ a_lh^7
//│ def a_lh = b_lh^1
//│ def b_lh = c_lh^2
//│ def c_lh = a_lh^3(d_lh^4)
//│ def d_lh = b_lh^6
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec a_lh =
//│ 		  b_lh
//│ 		and
//│ 		b_lh =
//│ 		  c_lh
//│ 		and
//│ 		c_lh =
//│ 		  (a_lh d_lh)
//│ 		and
//│ 		d_lh =
//│ 		  b_lh;;
//│ 		a_lh
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ a_lh
//│ def a_lh = b_lh
//│ def b_lh = c_lh
//│ def c_lh = a_lh(d_lh)
//│ def d_lh = b_lh
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec a_lh =
//│   b_lh
//│ and
//│ b_lh =
//│   c_lh
//│ and
//│ c_lh =
//│   (a_lh d_lh)
//│ and
//│ d_lh =
//│   b_lh;;
//│ a_lh
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
a = b
b = c
c = b d
d = a
a
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ a_lh^7
//│ def a_lh = b_lh^1
//│ def b_lh = c_lh^2
//│ def c_lh = b_lh^3(d_lh^4)
//│ def d_lh = a_lh^6
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec a_lh =
//│ 		  b_lh
//│ 		and
//│ 		b_lh =
//│ 		  c_lh
//│ 		and
//│ 		c_lh =
//│ 		  (b_lh d_lh)
//│ 		and
//│ 		d_lh =
//│ 		  a_lh;;
//│ 		a_lh
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ a_lh
//│ def a_lh = b_lh
//│ def b_lh = c_lh
//│ def c_lh = b_lh(d_lh)
//│ def d_lh = a_lh
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec a_lh =
//│   b_lh
//│ and
//│ b_lh =
//│   c_lh
//│ and
//│ c_lh =
//│   (b_lh d_lh)
//│ and
//│ d_lh =
//│   a_lh;;
//│ a_lh
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
a = a
a
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ a_lh^2
//│ def a_lh = a_lh^1
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec a_lh =
//│ 		  a_lh;;
//│ 		a_lh
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ a_lh
//│ def a_lh = a_lh
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec a_lh =
//│   a_lh;;
//│ a_lh
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhInHaskell
:lhGenOCaml
main = a b
a = f main
f = f
b = a
main
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main_lh^9
//│ def a_lh = f_lh^2(main_lh^3)
//│ def b_lh = a_lh^8
//│ def f_lh = f_lh^1
//│ def main_lh = a_lh^5(b_lh^6)
//│ 		---------- unoptimized ocaml gen ----------
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: 
//│ TreeMap(0 -> Set(2), 2 -> Set(0))
//│ Map(0 -> Set(Ident(true,main_lh,0), Ident(true,a_lh,0)), 1 -> Set(Ident(true,f_lh,0)), 2 -> Set(Ident(true,b_lh,0)))
//│ 
//│ 	at: mlscript.utils.package$.lastWords(package.scala:187)
//│ 	at: mlscript.lumberhack.Program.liftedTree1$1(Expr.scala:145)
//│ 	at: mlscript.lumberhack.Program.topLevelDefsOrder$lzyINIT1(Expr.scala:147)
//│ 	at: mlscript.lumberhack.Program.topLevelDefsOrder(Expr.scala:83)
//│ 	at: mlscript.lumberhack.OCamlGen.apply(CodeGen.scala:1327)
//│ 	at: mlscript.lumberhack.DiffTestLumberhack.postProcess(DiffTestLumberhack.scala:94)
//│ 	at: mlscript.DiffTests.rec$1(DiffTests.scala:391)
//│ 	at: mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:798)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
