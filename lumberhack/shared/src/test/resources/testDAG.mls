:NewParser
:ParseOnly

:lhInHaskell
:lhGenOCaml
a = b
b = c
c = c d
e = d
d = f d e a
f = g
g = g f
a
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ a_lh_₁^18
//│ def a_lh_₁ = b_lh_₁^17
//│ def b_lh_₁ = c_lh_₁^16
//│ def c_lh_₁ = c_lh_₁^13(d_lh_₁^14)
//│ def d_lh_₁ = f_lh_₁^6(d_lh_₁^7, e_lh_₁^9, a_lh_₁^11)
//│ def e_lh_₁ = d_lh_₁^4
//│ def f_lh_₁ = g_lh_₁^5
//│ def g_lh_₁ = g_lh_₁^1(f_lh_₁^2)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f_lh__d1 =
//│ 		  g_lh__d1
//│ 		and
//│ 		g_lh__d1 =
//│ 		  (g_lh__d1 f_lh__d1);;
//│ 		let rec a_lh__d1 =
//│ 		  b_lh__d1
//│ 		and
//│ 		b_lh__d1 =
//│ 		  c_lh__d1
//│ 		and
//│ 		c_lh__d1 =
//│ 		  (c_lh__d1 d_lh__d1)
//│ 		and
//│ 		d_lh__d1 =
//│ 		  (((f_lh__d1 d_lh__d1) e_lh__d1) a_lh__d1)
//│ 		and
//│ 		e_lh__d1 =
//│ 		  d_lh__d1;;
//│ 		a_lh__d1
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ a_lh_₁
//│ def a_lh_₁ = b_lh_₁
//│ def b_lh_₁ = c_lh_₁
//│ def c_lh_₁ = c_lh_₁(d_lh_₁)
//│ def d_lh_₁ = f_lh_₁(d_lh_₁, e_lh_₁, a_lh_₁)
//│ def e_lh_₁ = d_lh_₁
//│ def f_lh_₁ = g_lh_₁
//│ def g_lh_₁ = g_lh_₁(f_lh_₁)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec f_lh__d1 =
//│   g_lh__d1
//│ and
//│ g_lh__d1 =
//│   (g_lh__d1 f_lh__d1);;
//│ let rec a_lh__d1 =
//│   b_lh__d1
//│ and
//│ b_lh__d1 =
//│   c_lh__d1
//│ and
//│ c_lh__d1 =
//│   (c_lh__d1 d_lh__d1)
//│ and
//│ d_lh__d1 =
//│   (((f_lh__d1 d_lh__d1) e_lh__d1) a_lh__d1)
//│ and
//│ e_lh__d1 =
//│   d_lh__d1;;
//│ a_lh__d1
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
main = b a
a = f
b = a
f = f
main
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main_lh_₁^9
//│ def a_lh_₁ = f_lh_₁^5
//│ def a_lh_₂ = f_lh_₂^2
//│ def b_lh_₁ = a_lh_₂^4
//│ def f_lh_₁ = f_lh_₁^3
//│ def f_lh_₂ = f_lh_₂^1
//│ def main_lh_₁ = b_lh_₁^6(a_lh_₁^7)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f_lh__d2 =
//│ 		  f_lh__d2;;
//│ 		let rec a_lh__d2 =
//│ 		  f_lh__d2;;
//│ 		let rec b_lh__d1 =
//│ 		  a_lh__d2;;
//│ 		let rec f_lh__d1 =
//│ 		  f_lh__d1;;
//│ 		let rec a_lh__d1 =
//│ 		  f_lh__d1;;
//│ 		let rec main_lh__d1 =
//│ 		  (b_lh__d1 a_lh__d1);;
//│ 		main_lh__d1
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main_lh_₁
//│ def a_lh_₁ = f_lh_₁
//│ def a_lh_₂ = f_lh_₂
//│ def b_lh_₁ = a_lh_₂
//│ def f_lh_₁ = f_lh_₁
//│ def f_lh_₂ = f_lh_₂
//│ def main_lh_₁ = b_lh_₁(a_lh_₁)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec f_lh__d2 =
//│   f_lh__d2;;
//│ let rec a_lh__d2 =
//│   f_lh__d2;;
//│ let rec b_lh__d1 =
//│   a_lh__d2;;
//│ let rec f_lh__d1 =
//│   f_lh__d1;;
//│ let rec a_lh__d1 =
//│   f_lh__d1;;
//│ let rec main_lh__d1 =
//│   (b_lh__d1 a_lh__d1);;
//│ main_lh__d1
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
a = b
b = e f c
c = g d
d = c h
e = a f
f = g
g = f
h = d g
a
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ a_lh_₁^27
//│ def a_lh_₁ = b_lh_₁^26
//│ def b_lh_₁ = e_lh_₁^21(f_lh_₁^22, c_lh_₁^24)
//│ def c_lh_₁ = g_lh_₁^15(d_lh_₁^16)
//│ def d_lh_₁ = c_lh_₁^9(h_lh_₁^10)
//│ def e_lh_₁ = a_lh_₁^18(f_lh_₂^19)
//│ def f_lh_₁ = g_lh_₂^14
//│ def f_lh_₂ = g_lh_₃^13
//│ def f_lh_₃ = g_lh_₁^6
//│ def f_lh_₄ = g_lh_₄^1
//│ def g_lh_₁ = f_lh_₃^12
//│ def g_lh_₂ = f_lh_₁^8
//│ def g_lh_₃ = f_lh_₂^7
//│ def g_lh_₄ = f_lh_₄^2
//│ def h_lh_₁ = d_lh_₁^3(g_lh_₄^4)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f_lh__d4 =
//│ 		  g_lh__d4
//│ 		and
//│ 		g_lh__d4 =
//│ 		  f_lh__d4;;
//│ 		let rec f_lh__d3 =
//│ 		  g_lh__d1
//│ 		and
//│ 		g_lh__d1 =
//│ 		  f_lh__d3;;
//│ 		let rec c_lh__d1 =
//│ 		  (g_lh__d1 d_lh__d1)
//│ 		and
//│ 		d_lh__d1 =
//│ 		  (c_lh__d1 h_lh__d1)
//│ 		and
//│ 		h_lh__d1 =
//│ 		  (d_lh__d1 g_lh__d4);;
//│ 		let rec f_lh__d2 =
//│ 		  g_lh__d3
//│ 		and
//│ 		g_lh__d3 =
//│ 		  f_lh__d2;;
//│ 		let rec f_lh__d1 =
//│ 		  g_lh__d2
//│ 		and
//│ 		g_lh__d2 =
//│ 		  f_lh__d1;;
//│ 		let rec a_lh__d1 =
//│ 		  b_lh__d1
//│ 		and
//│ 		b_lh__d1 =
//│ 		  ((e_lh__d1 f_lh__d1) c_lh__d1)
//│ 		and
//│ 		e_lh__d1 =
//│ 		  (a_lh__d1 f_lh__d2);;
//│ 		a_lh__d1
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ a_lh_₁
//│ def a_lh_₁ = b_lh_₁
//│ def b_lh_₁ = e_lh_₁(f_lh_₁, c_lh_₁)
//│ def c_lh_₁ = g_lh_₁(d_lh_₁)
//│ def d_lh_₁ = c_lh_₁(h_lh_₁)
//│ def e_lh_₁ = a_lh_₁(f_lh_₂)
//│ def f_lh_₁ = g_lh_₂
//│ def f_lh_₂ = g_lh_₃
//│ def f_lh_₃ = g_lh_₁
//│ def f_lh_₄ = g_lh_₄
//│ def g_lh_₁ = f_lh_₃
//│ def g_lh_₂ = f_lh_₁
//│ def g_lh_₃ = f_lh_₂
//│ def g_lh_₄ = f_lh_₄
//│ def h_lh_₁ = d_lh_₁(g_lh_₄)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec f_lh__d2 =
//│   g_lh__d3
//│ and
//│ g_lh__d3 =
//│   f_lh__d2;;
//│ let rec f_lh__d1 =
//│   g_lh__d2
//│ and
//│ g_lh__d2 =
//│   f_lh__d1;;
//│ let rec f_lh__d4 =
//│   g_lh__d4
//│ and
//│ g_lh__d4 =
//│   f_lh__d4;;
//│ let rec f_lh__d3 =
//│   g_lh__d1
//│ and
//│ g_lh__d1 =
//│   f_lh__d3;;
//│ let rec c_lh__d1 =
//│   (g_lh__d1 d_lh__d1)
//│ and
//│ d_lh__d1 =
//│   (c_lh__d1 h_lh__d1)
//│ and
//│ h_lh__d1 =
//│   (d_lh__d1 g_lh__d4);;
//│ let rec a_lh__d1 =
//│   b_lh__d1
//│ and
//│ b_lh__d1 =
//│   ((e_lh__d1 f_lh__d1) c_lh__d1)
//│ and
//│ e_lh__d1 =
//│   (a_lh__d1 f_lh__d2);;
//│ a_lh__d1
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhInHaskell
:lhGenOCaml
a = b
b = c
c = a d
d = b
a
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ a_lh_₁^7
//│ def a_lh_₁ = b_lh_₁^6
//│ def b_lh_₁ = c_lh_₁^5
//│ def c_lh_₁ = a_lh_₁^2(d_lh_₁^3)
//│ def d_lh_₁ = b_lh_₁^1
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec a_lh__d1 =
//│ 		  b_lh__d1
//│ 		and
//│ 		b_lh__d1 =
//│ 		  c_lh__d1
//│ 		and
//│ 		c_lh__d1 =
//│ 		  (a_lh__d1 d_lh__d1)
//│ 		and
//│ 		d_lh__d1 =
//│ 		  b_lh__d1;;
//│ 		a_lh__d1
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ a_lh_₁
//│ def a_lh_₁ = b_lh_₁
//│ def b_lh_₁ = c_lh_₁
//│ def c_lh_₁ = a_lh_₁(d_lh_₁)
//│ def d_lh_₁ = b_lh_₁
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec a_lh__d1 =
//│   b_lh__d1
//│ and
//│ b_lh__d1 =
//│   c_lh__d1
//│ and
//│ c_lh__d1 =
//│   (a_lh__d1 d_lh__d1)
//│ and
//│ d_lh__d1 =
//│   b_lh__d1;;
//│ a_lh__d1
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
a = b
b = c
c = b d
d = a
a
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ a_lh_₁^7
//│ def a_lh_₁ = b_lh_₁^6
//│ def b_lh_₁ = c_lh_₁^5
//│ def c_lh_₁ = b_lh_₁^2(d_lh_₁^3)
//│ def d_lh_₁ = a_lh_₁^1
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec a_lh__d1 =
//│ 		  b_lh__d1
//│ 		and
//│ 		b_lh__d1 =
//│ 		  c_lh__d1
//│ 		and
//│ 		c_lh__d1 =
//│ 		  (b_lh__d1 d_lh__d1)
//│ 		and
//│ 		d_lh__d1 =
//│ 		  a_lh__d1;;
//│ 		a_lh__d1
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ a_lh_₁
//│ def a_lh_₁ = b_lh_₁
//│ def b_lh_₁ = c_lh_₁
//│ def c_lh_₁ = b_lh_₁(d_lh_₁)
//│ def d_lh_₁ = a_lh_₁
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec a_lh__d1 =
//│   b_lh__d1
//│ and
//│ b_lh__d1 =
//│   c_lh__d1
//│ and
//│ c_lh__d1 =
//│   (b_lh__d1 d_lh__d1)
//│ and
//│ d_lh__d1 =
//│   a_lh__d1;;
//│ a_lh__d1
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
a = a
a
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ a_lh_₁^2
//│ def a_lh_₁ = a_lh_₁^1
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec a_lh__d1 =
//│ 		  a_lh__d1;;
//│ 		a_lh__d1
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ a_lh_₁
//│ def a_lh_₁ = a_lh_₁
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec a_lh__d1 =
//│   a_lh__d1;;
//│ a_lh__d1
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhInHaskell
:lhGenOCaml
main = a b
a = f main
f = f
b = a
main
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main_lh_₁^13
//│ def a_lh_₁ = f_lh_₁^7(main_lh_₁^8)
//│ def a_lh_₂ = f_lh_₂^2(main_lh_₁^3)
//│ def b_lh_₁ = a_lh_₂^6
//│ def f_lh_₁ = f_lh_₁^5
//│ def f_lh_₂ = f_lh_₂^1
//│ def main_lh_₁ = a_lh_₁^10(b_lh_₁^11)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f_lh__d2 =
//│ 		  f_lh__d2;;
//│ 		let rec f_lh__d1 =
//│ 		  f_lh__d1;;
//│ 		let rec a_lh__d1 =
//│ 		  (f_lh__d1 main_lh__d1)
//│ 		and
//│ 		a_lh__d2 =
//│ 		  (f_lh__d2 main_lh__d1)
//│ 		and
//│ 		b_lh__d1 =
//│ 		  a_lh__d2
//│ 		and
//│ 		main_lh__d1 =
//│ 		  (a_lh__d1 b_lh__d1);;
//│ 		main_lh__d1
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main_lh_₁
//│ def a_lh_₁ = f_lh_₁(main_lh_₁)
//│ def a_lh_₂ = f_lh_₂(main_lh_₁)
//│ def b_lh_₁ = a_lh_₂
//│ def f_lh_₁ = f_lh_₁
//│ def f_lh_₂ = f_lh_₂
//│ def main_lh_₁ = a_lh_₁(b_lh_₁)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec f_lh__d1 =
//│   f_lh__d1;;
//│ let rec f_lh__d2 =
//│   f_lh__d2;;
//│ let rec a_lh__d1 =
//│   (f_lh__d1 main_lh__d1)
//│ and
//│ a_lh__d2 =
//│   (f_lh__d2 main_lh__d1)
//│ and
//│ b_lh__d1 =
//│   a_lh__d2
//│ and
//│ main_lh__d1 =
//│   (a_lh__d1 b_lh__d1);;
//│ main_lh__d1
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
a = b
b = c
c = 1
a
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ a_lh_₁^4
//│ def a_lh_₁ = b_lh_₁^3
//│ def b_lh_₁ = c_lh_₁^2
//│ def c_lh_₁ = 1
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec c_lh__d1 =
//│ 		  1;;
//│ 		let rec b_lh__d1 =
//│ 		  c_lh__d1;;
//│ 		let rec a_lh__d1 =
//│ 		  b_lh__d1;;
//│ 		a_lh__d1
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ a_lh_₁
//│ def a_lh_₁ = b_lh_₁
//│ def b_lh_₁ = c_lh_₁
//│ def c_lh_₁ = 1
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec c_lh__d1 =
//│   1;;
//│ let rec b_lh__d1 =
//│   c_lh__d1;;
//│ let rec a_lh__d1 =
//│   b_lh__d1;;
//│ a_lh__d1
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
