:NewParser
:ParseOnly

// WRONG: result is not correct
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
inter(N)(N)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|inter|(|N|)|(|N|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; inter (N,) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter^14 [N]) [N])
//│ def inter = (fun xs⁰ -> case xs⁰ of {
//│ 	N => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ ((inter^5 ys¹) t⁰)])})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^14] (hopeless to continue)
//│ 	[inter^14 · inter^5] ---> [inter^14] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((inter₀ [N]) [N])
//│ def inter₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		N => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 33 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 30
//│ [N]: 35 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 30
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((inter₀ [N]) [N])
//│ def inter₀ = 
//│ 	(fun xs² -> case xs² of {
//│ 		N => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ ((inter₀ ys⁵) t¹)])})
//│ <<<<<<< after fusion <<<<<<<


// WRONG: it returns something like: C(1, C(9, C(2, C(10, ys => ys))))
// despite the fact that there is no clash at all
_LUMBERHACK_EVAL
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, N))
let l2 = C(9, C(10, N))
inter(l1)(l2)
//│ |_LUMBERHACK_EVAL|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#let| |l2| |#=| |C|(|9|,| |C|(|10|,| |N|)|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, N,),); let l2 = C (9, C (10, N,),); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter^24 l1^25) l2^27)
//│ def inter = (fun xs⁰ -> case xs⁰ of {
//│ 	N => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ ((inter^5 ys¹) t⁰)])})
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [C 9 [C 10 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^24]
//│ 	[inter^24 · inter^5] ---> [inter^24] (only one)
//│ [l1^25] (hopeless to continue)
//│ [l2^27] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((inter₀ l1₀) l2₀)
//│ def inter₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		N => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])})
//│ def l1₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ def l2₀ = 
//│ 	[C 9 [C 10 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]]: 33 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 45
//│ [C 10 [N]]: 50 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 45
//│ [C 2 [N]]: 32 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 45
//│ [C 9 [C 10 [N]]]: 51 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 45
//│ [N]: 49 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 45
//│ [N]: 31 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((inter₀ l1₀) l2₀)
//│ def inter₀ = 
//│ 	(fun xs² -> case xs² of {
//│ 		N => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ ((inter₀ ys⁵) t¹)])})
//│ def l1₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ def l2₀ = 
//│ 	[C 9 [C 10 [N]]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 9 [C 2 [C 10 [N]]]]]
//│ <<<<<<< evaluate <<<<<<<

// WRONG: the return type is not correct
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, l1))
let l2 = C(9, l2)
inter(l1)(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |l1|)|)|↵|#let| |l2| |#=| |C|(|9|,| |l2|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, l1,),); let l2 = C (9, l2,); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter^22 l1^23) l2^25)
//│ def inter = (fun xs⁰ -> case xs⁰ of {
//│ 	N => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ ((inter^5 ys¹) t⁰)])})
//│ def l1 = [C 1 [C 2 l1^16]]
//│ def l2 = [C 9 l2^20]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^22]
//│ 	[inter^22 · inter^5] ---> [inter^22] (only one)
//│ [l1^23]
//│ 	[l1^23 · l1^16] ---> [l1^23] (only one)
//│ [l2^25]
//│ 	[l2^25 · l2^20] ---> [l2^25] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((inter₀ l1₀) l2₀)
//│ def inter₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		N => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])})
//│ def l1₀ = 
//│ 	[C 1 [C 2 l1₀]]
//│ def l2₀ = 
//│ 	[C 9 l2₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 l1₀]]: 31 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 46
//│ [C 2 l1₀]: 30 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 46
//│ [C 9 l2₀]: 34 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 46
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((inter₀ l1₀) l2₀)
//│ def inter₀ = 
//│ 	(fun xs² -> case xs² of {
//│ 		N => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ ((inter₀ ys⁵) t¹)])})
//│ def l1₀ = 
//│ 	[C 1 [C 2 l1₀]]
//│ def l2₀ = 
//│ 	[C 9 l2₀]
//│ <<<<<<< after fusion <<<<<<<


// WRONG: a wrong choice when resolving collision
_LUMBERHACK_ERROR
fun f(x) = if x is
  C(a) then
    if a is
      A then N
      B then g(D(a))
fun g(y) = if y is
  D(b) then
    if b is
      A then N
      B then f(C(b))
f(C(A))
//│ |_LUMBERHACK_ERROR|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then|→|#if| |a| |is|→|A| |#then| |N|↵|B| |#then| |g|(|D|(|a|)|)|←|←|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|D|(|b|)| |#then|→|#if| |b| |is|→|A| |#then| |N|↵|B| |#then| |f|(|C|(|b|)|)|←|←|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun f = x, => if x is ‹(C (a,)) then {if a is ‹(A) then N; (B) then g (D (a,),)›}›; fun g = y, => if y is ‹(D (b,)) then {if b is ‹(A) then N; (B) then f (C (b,),)›}›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^21 [C [A]])
//│ def f = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		A => [N]
//│ 		| B => (g^4 [D a⁰])}})
//│ def g = (fun y⁰ -> case y⁰ of {
//│ 	D b⁰ => case b⁰ of {
//│ 		A => [N]
//│ 		| B => (f^14 [C b⁰])}})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^21]
//│ 	[f^21 · g^4]
//│ 		[f^21 · g^4 · f^14] ---> [f^21] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ [C [A]])
//│ def f₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C a¹ => case a¹ of {
//│ 			A => [N]
//│ 			| B => (g₀ [D a¹])}})
//│ 	where
//│ 	def g₀ = 
//│ 		(fun y¹ -> case y¹ of {
//│ 			D b¹ => case b¹ of {
//│ 				A => [N]
//│ 				| B => (f₀ [C b¹])}})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 46 --->
//│ 	case a¹ of {A => [N] | B => (g₀ [D a¹])}: 42
//│ 	case b¹ of {A => [N] | B => (f₀ [C b¹])}: 32
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C [A]]: 47 --->
//│ 	case x¹ of {C a¹ => case a¹ of {A => [N] | B => (g₀ [D a¹])}}: 43
//│ [C b¹]: 30 --->
//│ 	case x¹ of {C a¹ => case a¹ of {A => [N] | B => (g₀ [D a¹])}}: 43
//│ [D a¹]: 40 --->
//│ 	case y¹ of {D b¹ => case b¹ of {A => [N] | B => (f₀ [C b¹])}}: 33
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C b¹]: 30 --->
//│ 	case x¹ of {C a¹ => case a¹ of {A => [N] | B => (g₀ [D a¹])}}: 43
//│ [D a¹]: 40 --->
//│ 	case y¹ of {D b¹ => case b¹ of {A => [N] | B => (f₀ [C b¹])}}: 33
//│ [C [A]]: 47 --->
//│ 	case x¹ of {C a¹ => case a¹ of {A => [N] | B => (g₀ [D a¹])}}: 43
//│ ------------------
//│ case y¹ of {D b¹ => case b¹ of {A => [N] | B => (f₀ [C b¹])}}: 33 --->
//│ 	[D a¹]: 40
//│ case x¹ of {C a¹ => case a¹ of {A => [N] | B => (g₀ [D a¹])}}: 43 --->
//│ 	[C b¹]: 30
//│ 	[C [A]]: 47
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!


// WRONG: lazy eval?
fun c(x) = if x is
  C(a) then primitive(a) // print(a)
fun f(a) = if False then c(a) else Unit
f(C(A))
//│ |#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |primitive|(|a|)| |/* print(a)*/|←|↵|#fun| |f|(|a|)| |#=| |#if| |False| |#then| |c|(|a|)| |#else| |Unit|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun c = x, => if x is ‹(C (a,)) then primitive (a,)›; fun f = a, => if (False) then c (a,) else Unit; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^14 [C [A]])
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => (primitive⁰ a⁰)})
//│ def f = (fun a¹ -> if [False] then (c^8 a¹) else [Unit])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^14] (hopeless to continue)
//│ 	[f^14 · c^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ [C [A]])
//│ def f₀ = 
//│ 	(fun a³ -> if [False] then (c₀ a³) else [Unit])
//│ 	where
//│ 	def c₀ = 
//│ 		(fun x¹ -> case x¹ of {
//│ 			C a² => (primitive⁰ a²)})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 33 --->
//│ 	case x¹ of {C a² => (primitive⁰ a²)}: 22
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [A]]: 33 --->
//│ 	case x¹ of {C a² => (primitive⁰ a²)}: 22
//│ ------------------
//│ case x¹ of {C a² => (primitive⁰ a²)}: 22 --->
//│ 	[C [A]]: 33
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ 
//│ 	let a⁴ = [A]
//│ 	in (primitive⁰ a⁴))
//│ def f₀ = 
//│ 	(fun a⁵ -> if [False] then (c₀ a⁵) else [Unit])
//│ 	where
//│ 	def c₀ = 
//│ 		(fun x² -> x²)
//│ <<<<<<< after fusion <<<<<<<
