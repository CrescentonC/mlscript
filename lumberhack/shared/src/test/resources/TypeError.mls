:NewParser
:ParseOnly

// WRONG: result is not correct
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
inter(N)(N)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|inter|(|N|)|(|N|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; inter (N,) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^14([N], [N])
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^14]
//│ 	[inter^14 · inter^5] ---> [inter^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ inter₀([N], [N])
//│ def inter₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 33 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 30
//│ [N]: 35 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 30
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 30 --->
//│ 	[N]: 33
//│ 	[N]: 35
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter₀([N], [N])
//│ def inter₀(xs²) = 
//│ 	case xs² of {
//│ 		N  => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ inter₀(ys⁵, t¹)])}
//│ <<<<<<< after fusion <<<<<<<


// WRONG: it returns something like: C(1, C(9, C(2, C(10, ys => ys))))
// despite the fact that there is no clash at all
_LUMBERHACK_EVAL
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, N))
let l2 = C(9, C(10, N))
inter(l1)(l2)
//│ |_LUMBERHACK_EVAL|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#let| |l2| |#=| |C|(|9|,| |C|(|10|,| |N|)|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, N,),); let l2 = C (9, C (10, N,),); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^24(l1^25, l2^27)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [C 9 [C 10 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 9 [C 2 [C 10 [N]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^24]
//│ 	[inter^24 · inter^5] ---> [inter^24] (only one)
//│ [l1^25] (hopeless to continue)
//│ [l2^27] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ inter₀(l1₀, l2₀)
//│ def inter₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}
//│ def l1₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ def l2₀ = 
//│ 	[C 9 [C 10 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 31 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [C 2 [N]]: 32 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [C 1 [C 2 [N]]]: 33 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [N]: 49 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [C 10 [N]]: 50 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [C 9 [C 10 [N]]]: 51 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45 --->
//│ 	[N]: 31
//│ 	[C 2 [N]]: 32
//│ 	[C 1 [C 2 [N]]]: 33
//│ 	[N]: 49
//│ 	[C 10 [N]]: 50
//│ 	[C 9 [C 10 [N]]]: 51
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter₀(l1₀, l2₀)
//│ def inter₀(xs²) = 
//│ 	case xs² of {
//│ 		N  => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ inter₀(ys⁵, t¹)])}
//│ def l1₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ def l2₀ = 
//│ 	[C 9 [C 10 [N]]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 9 [C 2 [C 10 [N]]]]]
//│ <<<<<<< evaluate <<<<<<<

// WRONG: the return type is not correct
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, l1))
let l2 = C(9, l2)
inter(l1)(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |l1|)|)|↵|#let| |l2| |#=| |C|(|9|,| |l2|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, l1,),); let l2 = C (9, l2,); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^22(l1^23, l2^25)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 l1^16]]
//│ def l2 = [C 9 l2^20]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^22]
//│ 	[inter^22 · inter^5] ---> [inter^22] (only one)
//│ [l1^23]
//│ 	[l1^23 · l1^16] ---> [l1^23] (only one)
//│ [l2^25]
//│ 	[l2^25 · l2^20] ---> [l2^25] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ inter₀(l1₀, l2₀)
//│ def inter₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}
//│ def l1₀ = 
//│ 	[C 1 [C 2 l1₀]]
//│ def l2₀ = 
//│ 	[C 9 l2₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 2 l1₀]: 30 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 46
//│ [C 1 [C 2 l1₀]]: 31 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 46
//│ [C 9 l2₀]: 34 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 46
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 46 --->
//│ 	[C 2 l1₀]: 30
//│ 	[C 1 [C 2 l1₀]]: 31
//│ 	[C 9 l2₀]: 34
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter₀(l1₀, l2₀)
//│ def inter₀(xs²) = 
//│ 	case xs² of {
//│ 		N  => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ inter₀(ys⁵, t¹)])}
//│ def l1₀ = 
//│ 	[C 1 [C 2 l1₀]]
//│ def l2₀ = 
//│ 	[C 9 l2₀]
//│ <<<<<<< after fusion <<<<<<<


// NOTE: maybe more fusion can be done
fun f(x) = if x is
  C(a) then
    if a is
      A then N
      B then g(D(a))
fun g(y) = if y is
  D(b) then
    if b is
      A then N
      B then f(C(b))
f(C(A))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then|→|#if| |a| |is|→|A| |#then| |N|↵|B| |#then| |g|(|D|(|a|)|)|←|←|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|D|(|b|)| |#then|→|#if| |b| |is|→|A| |#then| |N|↵|B| |#then| |f|(|C|(|b|)|)|←|←|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then {if a is ‹(A) then N; (B) then g (D (a,),)›}›; fun g = y, => if y is ‹(D (b,)) then {if b is ‹(A) then N; (B) then f (C (b,),)›}›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^21([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		A  => [N]
//│ 		| B  => g^4([D a⁰])}}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => case b⁰ of {
//│ 		A  => [N]
//│ 		| B  => f^14([C b⁰])}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^21]
//│ 	[f^21 · g^4]
//│ 		[f^21 · g^4 · f^14] ---> [f^21] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C [A]])
//│ def f₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => case a¹ of {
//│ 			A  => [N]
//│ 			| B  => g₀([D a¹])}}
//│ 	where
//│ 	def g₀(y¹) = 
//│ 		case y¹ of {
//│ 			D b¹ => case b¹ of {
//│ 				A  => [N]
//│ 				| B  => f₀([C b¹])}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C b¹]: 30 --->
//│ 	case x¹ of {C a¹ => case a¹ of {A  => [N] | B  => g₀([D a¹])}}: 43
//│ [D a¹]: 40 --->
//│ 	case y¹ of {D b¹ => case b¹ of {A  => [N] | B  => f₀([C b¹])}}: 33
//│ [A]: 46 --->
//│ 	case b¹ of {A  => [N] | B  => f₀([C b¹])}: 32
//│ 	case a¹ of {A  => [N] | B  => g₀([D a¹])}: 42
//│ [C [A]]: 47 --->
//│ 	case x¹ of {C a¹ => case a¹ of {A  => [N] | B  => g₀([D a¹])}}: 43
//│ ------------------
//│ case b¹ of {A  => [N] | B  => f₀([C b¹])}: 32 --->
//│ 	[A]: 46
//│ case y¹ of {D b¹ => case b¹ of {A  => [N] | B  => f₀([C b¹])}}: 33 --->
//│ 	[D a¹]: 40
//│ case a¹ of {A  => [N] | B  => g₀([D a¹])}: 42 --->
//│ 	[A]: 46
//│ case x¹ of {C a¹ => case a¹ of {A  => [N] | B  => g₀([D a¹])}}: 43 --->
//│ 	[C b¹]: 30
//│ 	[C [A]]: 47
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀([C [A]])
//│ def f₀(x²) = 
//│ 	case x² of {
//│ 		C a¹ => case a¹ of {
//│ 			A  => [N]
//│ 			| B  => g₀([D a¹])}}
//│ 	where
//│ 	def g₀(y²) = 
//│ 		case y² of {
//│ 			D b¹ => case b¹ of {
//│ 				A  => [N]
//│ 				| B  => f₀([C b¹])}}
//│ <<<<<<< after fusion <<<<<<<


// WRONG: lazy eval?
fun c(x) = if x is
  C(a) then primitive(a) // print(a)
fun f(a) = if False then c(a) else Unit
f(C(A))
//│ |#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |primitive|(|a|)| |/* print(a)*/|←|↵|#fun| |f|(|a|)| |#=| |#if| |False| |#then| |c|(|a|)| |#else| |Unit|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun c = x, => if x is ‹(C (a,)) then primitive (a,)›; fun f = a, => if (False) then c (a,) else Unit; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^14([C [A]])
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => primitive⁰(a⁰)}
//│ def f(a¹) = if [False] then c^8(a¹) else [Unit]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^14] (hopeless to continue)
//│ 	[f^14 · c^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C [A]])
//│ def f₀(a³) = 
//│ 	if [False] then c₀(a³) else [Unit]
//│ 	where
//│ 	def c₀(x¹) = 
//│ 		case x¹ of {
//│ 			C a² => primitive⁰(a²)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 33 --->
//│ 	case x¹ of {C a² => primitive⁰(a²)}: 22
//│ ------------------
//│ case x¹ of {C a² => primitive⁰(a²)}: 22 --->
//│ 	[C [A]]: 33
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [A]]: 33 --->
//│ 	case x¹ of {C a² => primitive⁰(a²)}: 22
//│ ------------------
//│ case x¹ of {C a² => primitive⁰(a²)}: 22 --->
//│ 	[C [A]]: 33
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀(
//│ 	let a⁴ = [A]
//│ 	in primitive⁰(a⁴))
//│ def f₀(a⁵) = 
//│ 	if [False] then c₀(a⁵) else [Unit]
//│ 	where
//│ 	def c₀(x²) = 
//│ 		x²
//│ <<<<<<< after fusion <<<<<<<






// FIXME: still have type error
_LUMBERHACK_ERROR_LUMBERHACK_EVAL
fun f(xs, ys) = if xs is
  N then 0
  _ then if xs is
    C(h, t) then if ys is
      C(hh, yt) then h + hh
      _ then h
    _ then error("match error")
f(C(1, N), C(2, N))
//│ |_LUMBERHACK_ERROR_LUMBERHACK_EVAL|↵|#fun| |f|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |0|↵|_| |#then| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |ys| |is|→|C|(|hh|,| |yt|)| |#then| |h| |+| |hh|↵|_| |#then| |h|←|↵|_| |#then| |error|(|"match error"|)|←|←|↵|f|(|C|(|1|,| |N|)|,| |C|(|2|,| |N|)|)|
//│ Parsed: {_LUMBERHACK_ERROR_LUMBERHACK_EVAL; fun f = xs, ys, => if xs is ‹(N) then 0; (_) then if xs is ‹(C (h, t,)) then if ys is ‹(C (hh, yt,)) then + (h,) (hh,); (_) then h›; (_) then error ("match error",)››; f (C (1, N,), C (2, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^19([C 1 [N]], [C 2 [N]])
//│ def f(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h⁰ t⁰ => case ys⁰ of {
//│ 			C hh⁰ yt⁰ => (h⁰ + hh⁰)
//│ 			| _  => h⁰}
//│ 		| _  => error⁰("match error")}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 3
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^19] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C 1 [N]], [C 2 [N]])
//│ def f₀(xs¹, ys¹) = 
//│ 	case xs¹ of {
//│ 		N  => 0
//│ 		| _  => case xs¹ of {
//│ 			C h¹ t¹ => case ys¹ of {
//│ 				C hh¹ yt¹ => (h¹ + hh¹)
//│ 				| _  => h¹}
//│ 			| _  => error⁰("match error")}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 49 --->
//│ 	case xs¹ of {C h¹ t¹ => case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹} | _  => error⁰("match error")}: 42
//│ [C 2 [N]]: 53 --->
//│ 	case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹}: 38
//│ ------------------
//│ case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹}: 38 --->
//│ 	[C 2 [N]]: 53
//│ case xs¹ of {C h¹ t¹ => case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹} | _  => error⁰("match error")}: 42 --->
//│ 	[C 1 [N]]: 49
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 [N]]: 49 --->
//│ 	case xs¹ of {C h¹ t¹ => case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹} | _  => error⁰("match error")}: 42
//│ [C 2 [N]]: 53 --->
//│ 	case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹}: 38
//│ ------------------
//│ case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹}: 38 --->
//│ 	[C 2 [N]]: 53
//│ case xs¹ of {C h¹ t¹ => case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹} | _  => error⁰("match error")}: 42 --->
//│ 	[C 1 [N]]: 49
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀(
//│ 	let h² = 1
//│ 	in let t² = [N]
//│ 	in (fun ys² -> ys²(h²)), 
//│ 	let hh² = 2
//│ 	in let yt² = [N]
//│ 	in (fun h³ -> (h³ + hh²)))
//│ def f₀(xs², ys³) = 
//│ 	case xs² of {
//│ 		N  => 0
//│ 		| _  => xs²(ys³)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 3
//│ <<<<<<< evaluate <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: type error 'ys⁰ => '6_callres <: Destruct(N, _)
//│ !!!!!!ERROR!!!!!!


// FIXME: still have type error
_LUMBERHACK_ERROR
fun f(xs) = if xs is
  N then 0
  _ then if xs is
    C(h, t) then h
    _ then error("match error")
f(C(1, N))
//│ |_LUMBERHACK_ERROR|↵|#fun| |f|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |0|↵|_| |#then| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |h|↵|_| |#then| |error|(|"match error"|)|←|←|↵|f|(|C|(|1|,| |N|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun f = xs, => if xs is ‹(N) then 0; (_) then if xs is ‹(C (h, t,)) then h; (_) then error ("match error",)››; f (C (1, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^11([C 1 [N]])
//│ def f(xs⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h⁰ t⁰ => h⁰
//│ 		| _  => error⁰("match error")}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^11] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C 1 [N]])
//│ def f₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => 0
//│ 		| _  => case xs¹ of {
//│ 			C h¹ t¹ => h¹
//│ 			| _  => error⁰("match error")}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 29 --->
//│ 	case xs¹ of {C h¹ t¹ => h¹ | _  => error⁰("match error")}: 23
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => h¹ | _  => error⁰("match error")}: 23 --->
//│ 	[C 1 [N]]: 29
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 [N]]: 29 --->
//│ 	case xs¹ of {C h¹ t¹ => h¹ | _  => error⁰("match error")}: 23
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => h¹ | _  => error⁰("match error")}: 23 --->
//│ 	[C 1 [N]]: 29
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀(
//│ 	let h² = 1
//│ 	in let t² = [N]
//│ 	in h²)
//│ def f₀(xs²) = 
//│ 	case xs² of {
//│ 		N  => 0
//│ 		| _  => xs²}
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!
