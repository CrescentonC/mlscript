:NewParser
:ParseOnly

_LUMBERHACK_EVAL
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
inter(N)(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|inter|(|N|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; inter (N,) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^14([N], [N])
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [N]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^14]
//│ 	[inter^14 · inter^5] ---> [inter^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ inter₀([N], [N])
//│ def inter₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 33 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 30
//│ [N]: 35 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 30
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 30 --->
//│ 	DeadCodeProd
//│ 	[N]: 33
//│ 	[N]: 35
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter₀([N], [N])
//│ def inter₀(xs²) = 
//│ 	case xs² of {
//│ 		N  => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ inter₀(ys⁵, t¹)])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [N]
//│ <<<<<<< evaluate <<<<<<<


_LUMBERHACK_EVAL
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, N))
let l2 = C(9, C(10, N))
inter(l1)(l2)
//│ |_LUMBERHACK_EVAL|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#let| |l2| |#=| |C|(|9|,| |C|(|10|,| |N|)|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, N,),); let l2 = C (9, C (10, N,),); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^24(l1^25, l2^27)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [C 9 [C 10 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 9 [C 2 [C 10 [N]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^24]
//│ 	[inter^24 · inter^5] ---> [inter^24] (only one)
//│ [l1^25] (hopeless to continue)
//│ [l2^27] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ inter₀(l1₀, l2₀)
//│ def inter₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}
//│ def l1₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ def l2₀ = 
//│ 	[C 9 [C 10 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 31 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [C 2 [N]]: 32 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [C 1 [C 2 [N]]]: 33 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [N]: 49 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [C 10 [N]]: 50 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [C 9 [C 10 [N]]]: 51 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45 --->
//│ 	[N]: 31
//│ 	[C 2 [N]]: 32
//│ 	[C 1 [C 2 [N]]]: 33
//│ 	[N]: 49
//│ 	[C 10 [N]]: 50
//│ 	[C 9 [C 10 [N]]]: 51
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter₀(l1₀, l2₀)
//│ def inter₀(xs²) = 
//│ 	case xs² of {
//│ 		N  => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ inter₀(ys⁵, t¹)])}
//│ def l1₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ def l2₀ = 
//│ 	[C 9 [C 10 [N]]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 9 [C 2 [C 10 [N]]]]]
//│ <<<<<<< evaluate <<<<<<<

fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, l1))
let l2 = C(9, l2)
inter(l1)(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |l1|)|)|↵|#let| |l2| |#=| |C|(|9|,| |l2|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, l1,),); let l2 = C (9, l2,); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^22(l1^23, l2^25)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 l1^16]]
//│ def l2 = [C 9 l2^20]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^22]
//│ 	[inter^22 · inter^5] ---> [inter^22] (only one)
//│ [l1^23]
//│ 	[l1^23 · l1^16] ---> [l1^23] (only one)
//│ [l2^25]
//│ 	[l2^25 · l2^20] ---> [l2^25] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ inter₀(l1₀, l2₀)
//│ def inter₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}
//│ def l1₀ = 
//│ 	[C 1 [C 2 l1₀]]
//│ def l2₀ = 
//│ 	[C 9 l2₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 2 l1₀]: 30 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 46
//│ [C 1 [C 2 l1₀]]: 31 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 46
//│ [C 9 l2₀]: 34 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 46
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 46 --->
//│ 	[C 2 l1₀]: 30
//│ 	[C 1 [C 2 l1₀]]: 31
//│ 	[C 9 l2₀]: 34
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter₀(l1₀, l2₀)
//│ def inter₀(xs²) = 
//│ 	case xs² of {
//│ 		N  => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ inter₀(ys⁵, t¹)])}
//│ def l1₀ = 
//│ 	[C 1 [C 2 l1₀]]
//│ def l2₀ = 
//│ 	[C 9 l2₀]
//│ <<<<<<< after fusion <<<<<<<


// NOTE: maybe more fusion can be done
fun f(x) = if x is
  C(a) then
    if a is
      A then N
      B then g(D(a))
fun g(y) = if y is
  D(b) then
    if b is
      A then N
      B then f(C(b))
f(C(A))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then|→|#if| |a| |is|→|A| |#then| |N|↵|B| |#then| |g|(|D|(|a|)|)|←|←|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|D|(|b|)| |#then|→|#if| |b| |is|→|A| |#then| |N|↵|B| |#then| |f|(|C|(|b|)|)|←|←|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then {if a is ‹(A) then N; (B) then g (D (a,),)›}›; fun g = y, => if y is ‹(D (b,)) then {if b is ‹(A) then N; (B) then f (C (b,),)›}›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^21([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		A  => [N]
//│ 		| B  => g^4([D a⁰])}}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => case b⁰ of {
//│ 		A  => [N]
//│ 		| B  => f^14([C b⁰])}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^21]
//│ 	[f^21 · g^4]
//│ 		[f^21 · g^4 · f^14] ---> [f^21] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C [A]])
//│ def f₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => case a¹ of {
//│ 			A  => [N]
//│ 			| B  => g₀([D a¹])}}
//│ 	where
//│ 	def g₀(y¹) = 
//│ 		case y¹ of {
//│ 			D b¹ => case b¹ of {
//│ 				A  => [N]
//│ 				| B  => f₀([C b¹])}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C b¹]: 30 --->
//│ 	case x¹ of {C a¹ => case a¹ of {A  => [N] | B  => g₀([D a¹])}}: 43
//│ [D a¹]: 40 --->
//│ 	case y¹ of {D b¹ => case b¹ of {A  => [N] | B  => f₀([C b¹])}}: 33
//│ [A]: 46 --->
//│ 	case b¹ of {A  => [N] | B  => f₀([C b¹])}: 32
//│ 	case a¹ of {A  => [N] | B  => g₀([D a¹])}: 42
//│ [C [A]]: 47 --->
//│ 	case x¹ of {C a¹ => case a¹ of {A  => [N] | B  => g₀([D a¹])}}: 43
//│ ------------------
//│ case b¹ of {A  => [N] | B  => f₀([C b¹])}: 32 --->
//│ 	[A]: 46
//│ case y¹ of {D b¹ => case b¹ of {A  => [N] | B  => f₀([C b¹])}}: 33 --->
//│ 	[D a¹]: 40
//│ case a¹ of {A  => [N] | B  => g₀([D a¹])}: 42 --->
//│ 	[A]: 46
//│ case x¹ of {C a¹ => case a¹ of {A  => [N] | B  => g₀([D a¹])}}: 43 --->
//│ 	[C b¹]: 30
//│ 	[C [A]]: 47
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀([C [A]])
//│ def f₀(x²) = 
//│ 	case x² of {
//│ 		C a¹ => case a¹ of {
//│ 			A  => [N]
//│ 			| B  => g₀([D a¹])}}
//│ 	where
//│ 	def g₀(y²) = 
//│ 		case y² of {
//│ 			D b¹ => case b¹ of {
//│ 				A  => [N]
//│ 				| B  => f₀([C b¹])}}
//│ <<<<<<< after fusion <<<<<<<


// NOTE: problem resolved by thunking the computation inside the branch
fun c(x) = if x is
  C(a) then primitive(a) // print(a)
fun f(a) = if False then c(a) else Unit
f(C(A))
//│ |#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |primitive|(|a|)| |/* print(a)*/|←|↵|#fun| |f|(|a|)| |#=| |#if| |False| |#then| |c|(|a|)| |#else| |Unit|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun c = x, => if x is ‹(C (a,)) then primitive (a,)›; fun f = a, => if (False) then c (a,) else Unit; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^14([C [A]])
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => primitive⁰(a⁰)}
//│ def f(a¹) = if [False] then c^8(a¹) else [Unit]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^14] (hopeless to continue)
//│ 	[f^14 · c^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C [A]])
//│ def f₀(a³) = 
//│ 	if [False] then c₀(a³) else [Unit]
//│ 	where
//│ 	def c₀(x¹) = 
//│ 		case x¹ of {
//│ 			C a² => primitive⁰(a²)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 33 --->
//│ 	case x¹ of {C a² => primitive⁰(a²)}: 22
//│ ------------------
//│ case x¹ of {C a² => primitive⁰(a²)}: 22 --->
//│ 	[C [A]]: 33
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [A]]: 33 --->
//│ 	case x¹ of {C a² => primitive⁰(a²)}: 22
//│ ------------------
//│ case x¹ of {C a² => primitive⁰(a²)}: 22 --->
//│ 	[C [A]]: 33
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀(
//│ 	let a⁴ = [A]
//│ 	in (fun _lh_dummy⁰ -> primitive⁰(a⁴)))
//│ def f₀(a⁵) = 
//│ 	if [False] then c₀(a⁵) else [Unit]
//│ 	where
//│ 	def c₀(x²) = 
//│ 		x²(99)
//│ <<<<<<< after fusion <<<<<<<


fun f(xs, ys) = if xs is
  N then 0
  _ then if xs is
    C(h, t) then if ys is
      C(hh, yt) then h + hh
      _ then h
    _ then error
f(C(1, N), C(2, N))
//│ |#fun| |f|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |0|↵|_| |#then| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |ys| |is|→|C|(|hh|,| |yt|)| |#then| |h| |+| |hh|↵|_| |#then| |h|←|↵|_| |#then| |error|←|←|↵|f|(|C|(|1|,| |N|)|,| |C|(|2|,| |N|)|)|
//│ Parsed: {fun f = xs, ys, => if xs is ‹(N) then 0; (_) then if xs is ‹(C (h, t,)) then if ys is ‹(C (hh, yt,)) then + (h,) (hh,); (_) then h›; (_) then error››; f (C (1, N,), C (2, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^17([C 1 [N]], [C 2 [N]])
//│ def f(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h⁰ t⁰ => case ys⁰ of {
//│ 			C hh⁰ yt⁰ => (h⁰ + hh⁰)
//│ 			| _  => h⁰}
//│ 		| _  => error⁰}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^17] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C 1 [N]], [C 2 [N]])
//│ def f₀(xs¹, ys¹) = 
//│ 	case xs¹ of {
//│ 		N  => 0
//│ 		| _  => case xs¹ of {
//│ 			C h¹ t¹ => case ys¹ of {
//│ 				C hh¹ yt¹ => (h¹ + hh¹)
//│ 				| _  => h¹}
//│ 			| _  => error⁰}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 45 --->
//│ 	case xs¹ of {C h¹ t¹ => case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹} | _  => error⁰}: 38
//│ 	case xs¹ of {N  => 0 | _  => case xs¹ of {C h¹ t¹ => case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹} | _  => error⁰}}: 39
//│ [C 2 [N]]: 49 --->
//│ 	case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹}: 36
//│ ------------------
//│ case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹}: 36 --->
//│ 	[C 2 [N]]: 49
//│ case xs¹ of {C h¹ t¹ => case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹} | _  => error⁰}: 38 --->
//│ 	[C 1 [N]]: 45
//│ case xs¹ of {N  => 0 | _  => case xs¹ of {C h¹ t¹ => case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹} | _  => error⁰}}: 39 --->
//│ 	[C 1 [N]]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 2 [N]]: 49 --->
//│ 	case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹}: 36
//│ ------------------
//│ case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹}: 36 --->
//│ 	[C 2 [N]]: 49
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀([C 1 [N]], 
//│ 	let hh² = 2
//│ 	in (fun h² -> (h² + hh²)))
//│ def f₀(xs², ys²) = 
//│ 	case xs² of {
//│ 		N  => 0
//│ 		| _  => case xs² of {
//│ 			C h¹ t¹ => ys²(h¹)
//│ 			| _  => error⁰}}
//│ <<<<<<< after fusion <<<<<<<


fun f(xs) = if xs is
  N then 0
  _ then if xs is
    C(h, t) then h
    _ then error("match error")
f(C(1, N))
//│ |#fun| |f|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |0|↵|_| |#then| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |h|↵|_| |#then| |error|(|"match error"|)|←|←|↵|f|(|C|(|1|,| |N|)|)|
//│ Parsed: {fun f = xs, => if xs is ‹(N) then 0; (_) then if xs is ‹(C (h, t,)) then h; (_) then error ("match error",)››; f (C (1, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^33([C 1 [N]])
//│ def f(xs⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h⁰ t⁰ => h⁰
//│ 		| _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^33] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C 1 [N]])
//│ def f₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => 0
//│ 		| _  => case xs¹ of {
//│ 			C h¹ t¹ => h¹
//│ 			| _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 73 --->
//│ 	case xs¹ of {C h¹ t¹ => h¹ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}: 67
//│ 	case xs¹ of {N  => 0 | _  => case xs¹ of {C h¹ t¹ => h¹ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}: 68
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => h¹ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}: 67 --->
//│ 	[C 1 [N]]: 73
//│ case xs¹ of {N  => 0 | _  => case xs¹ of {C h¹ t¹ => h¹ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}: 68 --->
//│ 	[C 1 [N]]: 73
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀([C 1 [N]])
//│ def f₀(xs²) = 
//│ 	case xs² of {
//│ 		N  => 0
//│ 		| _  => case xs² of {
//│ 			C h¹ t¹ => h¹
//│ 			| _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}
//│ <<<<<<< after fusion <<<<<<<


fun f(x, y) = if x is
  N then y
  _ then y + 1
f(C(1, N), 0)
//│ |#fun| |f|(|x|,| |y|)| |#=| |#if| |x| |is|→|N| |#then| |y|↵|_| |#then| |y| |+| |1|←|↵|f|(|C|(|1|,| |N|)|,| |0|)|
//│ Parsed: {fun f = x, y, => if x is ‹(N) then y; (_) then + (y,) (1,)›; f (C (1, N,), 0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^11([C 1 [N]], 0)
//│ def f(x⁰, y⁰) = case x⁰ of {
//│ 	N  => y⁰
//│ 	| _  => (y⁰ + 1)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^11] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C 1 [N]], 0)
//│ def f₀(x¹, y¹) = 
//│ 	case x¹ of {
//│ 		N  => y¹
//│ 		| _  => (y¹ + 1)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 31 --->
//│ 	case x¹ of {N  => y¹ | _  => (y¹ + 1)}: 25
//│ ------------------
//│ case x¹ of {N  => y¹ | _  => (y¹ + 1)}: 25 --->
//│ 	[C 1 [N]]: 31
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 [N]]: 31 --->
//│ 	case x¹ of {N  => y¹ | _  => (y¹ + 1)}: 25
//│ ------------------
//│ case x¹ of {N  => y¹ | _  => (y¹ + 1)}: 25 --->
//│ 	[C 1 [N]]: 31
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀((fun y² -> (y² + 1)), 0)
//│ def f₀(x², y³) = 
//│ 	x²(y³)
//│ <<<<<<< after fusion <<<<<<<


// NOTE: after registering wildcard and id match, no type error
fun zip(xs, ys) = if xs is
  N then N
  _ then if ys is
    N then N
    _ then if xs is
      C(xs, xt) then if ys is
        C(ys, yt) then C(P2(xs, ys), zip(xt, yt))
        _ then N
      _ then N
zip(C(1,N), C(2,N))
//│ |#fun| |zip|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |N|↵|_| |#then| |#if| |ys| |is|→|N| |#then| |N|↵|_| |#then| |#if| |xs| |is|→|C|(|xs|,| |xt|)| |#then| |#if| |ys| |is|→|C|(|ys|,| |yt|)| |#then| |C|(|P2|(|xs|,| |ys|)|,| |zip|(|xt|,| |yt|)|)|↵|_| |#then| |N|←|↵|_| |#then| |N|←|←|←|↵|zip|(|C|(|1|,|N|)|,| |C|(|2|,|N|)|)|
//│ Parsed: {fun zip = xs, ys, => if xs is ‹(N) then N; (_) then if ys is ‹(N) then N; (_) then if xs is ‹(C (xs, xt,)) then if ys is ‹(C (ys, yt,)) then C (P2 (xs, ys,), zip (xt, yt,),); (_) then N›; (_) then N›››; zip (C (1, N,), C (2, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ zip^24([C 1 [N]], [C 2 [N]])
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => [N]
//│ 	| _  => case ys⁰ of {
//│ 		N  => [N]
//│ 		| _  => case xs⁰ of {
//│ 			C xs¹ xt⁰ => case ys⁰ of {
//│ 				C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip^10(xt⁰, yt⁰)]
//│ 				| _  => [N]}
//│ 			| _  => [N]}}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [zip^24]
//│ 	[zip^24 · zip^10] ---> [zip^24] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ zip₀([C 1 [N]], [C 2 [N]])
//│ def zip₀(xs², ys²) = 
//│ 	case xs² of {
//│ 		N  => [N]
//│ 		| _  => case ys² of {
//│ 			N  => [N]
//│ 			| _  => case xs² of {
//│ 				C xs³ xt¹ => case ys² of {
//│ 					C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)]
//│ 					| _  => [N]}
//│ 				| _  => [N]}}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 58 --->
//│ 	case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}: 51
//│ 	case xs² of {N  => [N] | _  => case ys² of {N  => [N] | _  => case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}}}: 53
//│ [C 1 [N]]: 59 --->
//│ 	case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}: 51
//│ 	case xs² of {N  => [N] | _  => case ys² of {N  => [N] | _  => case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}}}: 53
//│ [N]: 62 --->
//│ 	case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]}: 49
//│ 	case ys² of {N  => [N] | _  => case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}}: 52
//│ [C 2 [N]]: 63 --->
//│ 	case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]}: 49
//│ 	case ys² of {N  => [N] | _  => case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}}: 52
//│ ------------------
//│ case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]}: 49 --->
//│ 	[N]: 62
//│ 	[C 2 [N]]: 63
//│ case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}: 51 --->
//│ 	[N]: 58
//│ 	[C 1 [N]]: 59
//│ case ys² of {N  => [N] | _  => case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}}: 52 --->
//│ 	[N]: 62
//│ 	[C 2 [N]]: 63
//│ case xs² of {N  => [N] | _  => case ys² of {N  => [N] | _  => case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}}}: 53 --->
//│ 	[N]: 58
//│ 	[C 1 [N]]: 59
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ zip₀([C 1 [N]], [C 2 [N]])
//│ def zip₀(xs⁴, ys⁴) = 
//│ 	case xs⁴ of {
//│ 		N  => [N]
//│ 		| _  => case ys⁴ of {
//│ 			N  => [N]
//│ 			| _  => case xs⁴ of {
//│ 				C xs³ xt¹ => case ys⁴ of {
//│ 					C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)]
//│ 					| _  => [N]}
//│ 				| _  => [N]}}}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: type error: f x = x f cannot be well typed in haskell
fun f(x) =
  (
    if x is
      C(h, t) then ff => C(h, ff(t))
      N then ff => N
  )(f)
f(C(3, N))
//│ |#fun| |f|(|x|)| |#=|→|(|→|#if| |x| |is|→|C|(|h|,| |t|)| |#then| |ff| |=>| |C|(|h|,| |ff|(|t|)|)|↵|N| |#then| |ff| |=>| |N|←|←|↵|)|(|f|)|←|↵|f|(|C|(|3|,| |N|)|)|
//│ Parsed: {fun f = x, => {'(' if x is ‹(C (h, t,)) then ff, => C (h, ff (t,),); (N) then ff, => N›, ')' (f,)}; f (C (3, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^14([C 3 [N]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C h⁰ t⁰ => (fun ff⁰ -> [C h⁰ ff⁰(t⁰)])
//│ 	| N  => (fun ff¹ -> [N])}(f^11)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^14]
//│ 	[f^14 · f^11] ---> [f^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C 3 [N]])
//│ def f₀(x¹) = 
//│ 	case x¹ of {
//│ 		C h¹ t¹ => (fun ff² -> [C h¹ ff²(t¹)])
//│ 		| N  => (fun ff³ -> [N])}(f₀)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 34 --->
//│ 	case x¹ of {C h¹ t¹ => (fun ff² -> [C h¹ ff²(t¹)]) | N  => (fun ff³ -> [N])}: 28
//│ [C 3 [N]]: 35 --->
//│ 	case x¹ of {C h¹ t¹ => (fun ff² -> [C h¹ ff²(t¹)]) | N  => (fun ff³ -> [N])}: 28
//│ ------------------
//│ case x¹ of {C h¹ t¹ => (fun ff² -> [C h¹ ff²(t¹)]) | N  => (fun ff³ -> [N])}: 28 --->
//│ 	DeadCodeProd
//│ 	[N]: 34
//│ 	[C 3 [N]]: 35
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀([C 3 [N]])
//│ def f₀(x²) = 
//│ 	case x² of {
//│ 		C h¹ t¹ => (fun ff⁴ -> [C h¹ ff⁴(t¹)])
//│ 		| N  => (fun ff⁵ -> [N])}(f₀)
//│ <<<<<<< after fusion <<<<<<<

// a more minimal example requiring recursive type after fusion
fun f(x) =
  (
    if x is
      N then ff => 1
  )(f)
f(N)
//│ |#fun| |f|(|x|)| |#=|→|(|→|#if| |x| |is|→|N| |#then| |ff| |=>| |1|←|←|↵|)|(|f|)|←|↵|f|(|N|)|
//│ Parsed: {fun f = x, => {'(' if x is ‹(N) then ff, => 1›, ')' (f,)}; f (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^8([N])
//│ def f(x⁰) = case x⁰ of {
//│ 	N  => (fun ff⁰ -> 1)}(f^5)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^8] (hopeless to continue)
//│ 	[f^8 · f^5] ---> [f^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([N])
//│ def f₀(x¹) = 
//│ 	case x¹ of {
//│ 		N  => (fun ff¹ -> 1)}(f₀)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 19 --->
//│ 	case x¹ of {N  => (fun ff¹ -> 1)}: 14
//│ ------------------
//│ case x¹ of {N  => (fun ff¹ -> 1)}: 14 --->
//│ 	DeadCodeProd
//│ 	[N]: 19
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀([N])
//│ def f₀(x²) = 
//│ 	case x² of {
//│ 		N  => (fun ff² -> 1)}(f₀)
//│ <<<<<<< after fusion <<<<<<<


// FIXME: still have error even after eliminating dead branches and unused definitions, need more
// flow sensitive dead code elmination?
:lhInHaskell
:lhGenOCaml
:d
break p [] = ([], [])
break p (x:xs) = if p x then ([], (x:xs)) else case (break1 p xs) of { (ys, zs) -> ((x:ys), zs) }
break1 p [] = ([], [])
break1 p (x:xs) = if p x then ([], (x:xs)) else case (break1 p xs) of { (ys, zs) -> ((x:ys), zs) }
words s =  case (dropWhile (\x -> polyEq x ' ') s) of
          [] -> []
          s' -> case (break (\x -> polyEq x ' ') s') of (w, s'') -> (w : (words s''))
dropWhile f [] = []
dropWhile f (h:t) = if (f h) then dropWhile f t else (h:t)
words "1 2 4"
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ words₀^843([LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]])
//│ def break1₀(_lh_break1_arg1¹, _lh_break1_arg2¹) = case _lh_break1_arg2¹ of {
//│ 	LH_N  => [LH_P2 [LH_N] [LH_N]]
//│ 	| LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹ => if _lh_break1_arg1¹(_lh_break1_LH_C_0¹) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹]] else 
//│ 		let _lh_matchIdent⁷ = break1₀^806(_lh_break1_arg1¹, _lh_break1_LH_C_1¹)
//│ 		in case _lh_matchIdent⁷ of {
//│ 			LH_P2 _lh_break1_LH_P2_0¹ _lh_break1_LH_P2_1¹ => [LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹]
//│ 			| _  => error⁰}
//│ 	| _  => error⁰}
//│ def break₀(_lh_break_arg1¹, _lh_break_arg2¹) = case _lh_break_arg2¹ of {
//│ 	LH_N  => [LH_P2 [LH_N] [LH_N]]
//│ 	| LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹ => if _lh_break_arg1¹(_lh_break_LH_C_0¹) then [LH_P2 [LH_N] [LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹]] else 
//│ 		let _lh_matchIdent⁶ = break1₀^775(_lh_break_arg1¹, _lh_break_LH_C_1¹)
//│ 		in case _lh_matchIdent⁶ of {
//│ 			LH_P2 _lh_break_LH_P2_0¹ _lh_break_LH_P2_1¹ => [LH_P2 [LH_C _lh_break_LH_C_0¹ _lh_break_LH_P2_0¹] _lh_break_LH_P2_1¹]
//│ 			| _  => error⁰}
//│ 	| _  => error⁰}
//│ def dropWhile₀(_lh_dropWhile_arg1¹, _lh_dropWhile_arg2¹) = case _lh_dropWhile_arg2¹ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹ => if _lh_dropWhile_arg1¹(_lh_dropWhile_LH_C_0¹) then dropWhile₀^830(_lh_dropWhile_arg1¹, _lh_dropWhile_LH_C_1¹) else [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹]
//│ 	| _  => error⁰}
//│ def words₀(_lh_words_arg1¹) = 
//│ 	let _lh_matchIdent⁴ = dropWhile₀^729((fun x⁴ -> polyEq⁰(x⁴, ' ')), _lh_words_arg1¹)
//│ 	in case _lh_matchIdent⁴ of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => 
//│ 			let _lh_matchIdent⁵ = break₀^741((fun x⁵ -> polyEq⁰(x⁵, ' ')), _lh_matchIdent⁴)
//│ 			in case _lh_matchIdent⁵ of {
//│ 				LH_P2 _lh_words_LH_P2_0¹ _lh_words_LH_P2_1¹ => [LH_C _lh_words_LH_P2_0¹ words₀^753(_lh_words_LH_P2_1¹)]
//│ 				| _  => error⁰}}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec break1_d0 _lh_break1_arg1_1 _lh_break1_arg2_1 =
//│ 		  (match _lh_break1_arg2_1 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_P2((`LH_N), (`LH_N)))
//│ 		    | `LH_C(_lh_break1_LH_C_0_1, _lh_break1_LH_C_1_1) -> 
//│ 		      (if (_lh_break1_arg1_1 _lh_break1_LH_C_0_1) then
//│ 		        (`LH_P2((`LH_N), (`LH_C(_lh_break1_LH_C_0_1, _lh_break1_LH_C_1_1))))
//│ 		      else
//│ 		        (let rec _lh_matchIdent_7 = ((break1_d0 _lh_break1_arg1_1) _lh_break1_LH_C_1_1) in
//│ 		          (match _lh_matchIdent_7 with
//│ 		            | `LH_P2(_lh_break1_LH_P2_0_1, _lh_break1_LH_P2_1_1) -> 
//│ 		              (`LH_P2((`LH_C(_lh_break1_LH_C_0_1, _lh_break1_LH_P2_0_1)), _lh_break1_LH_P2_1_1))
//│ 		            | _ -> 
//│ 		              (failwith "error"))))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and break_d0 _lh_break_arg1_1 _lh_break_arg2_1 =
//│ 		  (match _lh_break_arg2_1 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_P2((`LH_N), (`LH_N)))
//│ 		    | `LH_C(_lh_break_LH_C_0_1, _lh_break_LH_C_1_1) -> 
//│ 		      (if (_lh_break_arg1_1 _lh_break_LH_C_0_1) then
//│ 		        (`LH_P2((`LH_N), (`LH_C(_lh_break_LH_C_0_1, _lh_break_LH_C_1_1))))
//│ 		      else
//│ 		        (let rec _lh_matchIdent_6 = ((break1_d0 _lh_break_arg1_1) _lh_break_LH_C_1_1) in
//│ 		          (match _lh_matchIdent_6 with
//│ 		            | `LH_P2(_lh_break_LH_P2_0_1, _lh_break_LH_P2_1_1) -> 
//│ 		              (`LH_P2((`LH_C(_lh_break_LH_C_0_1, _lh_break_LH_P2_0_1)), _lh_break_LH_P2_1_1))
//│ 		            | _ -> 
//│ 		              (failwith "error"))))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and dropWhile_d0 _lh_dropWhile_arg1_1 _lh_dropWhile_arg2_1 =
//│ 		  (match _lh_dropWhile_arg2_1 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_dropWhile_LH_C_0_1, _lh_dropWhile_LH_C_1_1) -> 
//│ 		      (if (_lh_dropWhile_arg1_1 _lh_dropWhile_LH_C_0_1) then
//│ 		        ((dropWhile_d0 _lh_dropWhile_arg1_1) _lh_dropWhile_LH_C_1_1)
//│ 		      else
//│ 		        (`LH_C(_lh_dropWhile_LH_C_0_1, _lh_dropWhile_LH_C_1_1)))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and words_d0 _lh_words_arg1_1 =
//│ 		  (let rec _lh_matchIdent_4 = ((dropWhile_d0 (fun x_4 -> 
//│ 		    (x_4 = ' '))) _lh_words_arg1_1) in
//│ 		    (match _lh_matchIdent_4 with
//│ 		      | `LH_N -> 
//│ 		        (`LH_N)
//│ 		      | _ -> 
//│ 		        (let rec _lh_matchIdent_5 = ((break_d0 (fun x_5 -> 
//│ 		          (x_5 = ' '))) _lh_matchIdent_4) in
//│ 		          (match _lh_matchIdent_5 with
//│ 		            | `LH_P2(_lh_words_LH_P2_0_1, _lh_words_LH_P2_1_1) -> 
//│ 		              (`LH_C(_lh_words_LH_P2_0_1, (words_d0 _lh_words_LH_P2_1_1)))
//│ 		            | _ -> 
//│ 		              (failwith "error")))));;
//│ 		(words_d0 (`LH_C('1', (`LH_C(' ', (`LH_C('2', (`LH_C(' ', (`LH_C('4', (`LH_N))))))))))))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		                                                                                                                val break1_d0 :
//│ 		  (char -> bool) ->
//│ 		  ([> `LH_C of char * 'a | `LH_N ] as 'a) ->
//│ 		  [> `LH_P2 of ([> `LH_C of char * 'b | `LH_N ] as 'b) * 'a ] = <fun>
//│ 		val break_d0 :
//│ 		  (char -> bool) ->
//│ 		  [> `LH_C of char * ([> `LH_C of char * 'a | `LH_N ] as 'a) | `LH_N ] ->
//│ 		  [> `LH_P2 of
//│ 		       [> `LH_C of char * ([> `LH_C of char * 'b | `LH_N ] as 'b) | `LH_N ] *
//│ 		       'a ] =
//│ 		  <fun>
//│ 		val dropWhile_d0 :
//│ 		  (char -> bool) ->
//│ 		  ([> `LH_C of char * 'a | `LH_N ] as 'a) -> [> `LH_C of char * 'a | `LH_N ] =
//│ 		  <fun>
//│ 		val words_d0 :
//│ 		  ([> `LH_C of char * 'a | `LH_N ] as 'a) ->
//│ 		  ([> `LH_C of
//│ 		        [> `LH_C of char * ([> `LH_C of char * 'c | `LH_N ] as 'c) | `LH_N ] *
//│ 		        'b
//│ 		    | `LH_N ]
//│ 		   as 'b) =
//│ 		  <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [words₀^843]
//│ 	[words₀^843 · break₀^741]
//│ 		[words₀^843 · break₀^741 · break1₀^775]
//│ 			[words₀^843 · break₀^741 · break1₀^775 · break1₀^806] ---> [words₀^843 · break₀^741 · break1₀^775] (only one)
//│ 	[words₀^843 · dropWhile₀^729]
//│ 		[words₀^843 · dropWhile₀^729 · dropWhile₀^830] ---> [words₀^843 · dropWhile₀^729] (only one)
//│ 	[words₀^843 · words₀^753] ---> [words₀^843] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ words₀₀([LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]])
//│ def words₀₀(_lh_words_arg1¹) = 
//│ 	let _lh_matchIdent⁴ = dropWhile₀₀((fun x² -> polyEq⁰(x², ' ')), _lh_words_arg1¹)
//│ 	in case _lh_matchIdent⁴ of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => 
//│ 			let _lh_matchIdent⁵ = break₀₀((fun x³ -> polyEq⁰(x³, ' ')), _lh_matchIdent⁴)
//│ 			in case _lh_matchIdent⁵ of {
//│ 				LH_P2 _lh_words_LH_P2_0¹ _lh_words_LH_P2_1¹ => [LH_C _lh_words_LH_P2_0¹ words₀₀(_lh_words_LH_P2_1¹)]
//│ 				| _  => error⁰}}
//│ 	where
//│ 	def break₀₀(_lh_break_arg1¹, _lh_break_arg2¹) = 
//│ 		case _lh_break_arg2¹ of {
//│ 			LH_N  => [LH_P2 [LH_N] [LH_N]]
//│ 			| LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹ => if _lh_break_arg1¹(_lh_break_LH_C_0¹) then [LH_P2 [LH_N] [LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹]] else 
//│ 				let _lh_matchIdent⁶ = break1₀₀(_lh_break_arg1¹, _lh_break_LH_C_1¹)
//│ 				in case _lh_matchIdent⁶ of {
//│ 					LH_P2 _lh_break_LH_P2_0¹ _lh_break_LH_P2_1¹ => [LH_P2 [LH_C _lh_break_LH_C_0¹ _lh_break_LH_P2_0¹] _lh_break_LH_P2_1¹]
//│ 					| _  => error⁰}
//│ 			| _  => error⁰}
//│ 		where
//│ 		def break1₀₀(_lh_break1_arg1¹, _lh_break1_arg2¹) = 
//│ 			case _lh_break1_arg2¹ of {
//│ 				LH_N  => [LH_P2 [LH_N] [LH_N]]
//│ 				| LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹ => if _lh_break1_arg1¹(_lh_break1_LH_C_0¹) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹]] else 
//│ 					let _lh_matchIdent⁷ = break1₀₀(_lh_break1_arg1¹, _lh_break1_LH_C_1¹)
//│ 					in case _lh_matchIdent⁷ of {
//│ 						LH_P2 _lh_break1_LH_P2_0¹ _lh_break1_LH_P2_1¹ => [LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹]
//│ 						| _  => error⁰}
//│ 				| _  => error⁰}
//│ 	def dropWhile₀₀(_lh_dropWhile_arg1¹, _lh_dropWhile_arg2¹) = 
//│ 		case _lh_dropWhile_arg2¹ of {
//│ 			LH_N  => [LH_N]
//│ 			| LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹ => if _lh_dropWhile_arg1¹(_lh_dropWhile_LH_C_0¹) then dropWhile₀₀(_lh_dropWhile_arg1¹, _lh_dropWhile_LH_C_1¹) else [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹]
//│ 			| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 164 --->
//│ 	case _lh_dropWhile_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹ => if _lh_dropWhile_arg1¹(_lh_dropWhile_LH_C_0¹) then dropWhile₀₀(_lh_dropWhile_arg1¹, _lh_dropWhile_LH_C_1¹) else [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹] | _  => error⁰}: 208
//│ [LH_P2 [LH_N] [LH_N]]: 165 --->
//│ 	case _lh_matchIdent⁵ of {LH_P2 _lh_words_LH_P2_0¹ _lh_words_LH_P2_1¹ => [LH_C _lh_words_LH_P2_0¹ words₀₀(_lh_words_LH_P2_1¹)] | _  => error⁰}: 157
//│ [LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹]: 172 --->
//│ 	case _lh_dropWhile_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹ => if _lh_dropWhile_arg1¹(_lh_dropWhile_LH_C_0¹) then dropWhile₀₀(_lh_dropWhile_arg1¹, _lh_dropWhile_LH_C_1¹) else [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹] | _  => error⁰}: 208
//│ [LH_P2 [LH_N] [LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹]]: 173 --->
//│ 	case _lh_matchIdent⁵ of {LH_P2 _lh_words_LH_P2_0¹ _lh_words_LH_P2_1¹ => [LH_C _lh_words_LH_P2_0¹ words₀₀(_lh_words_LH_P2_1¹)] | _  => error⁰}: 157
//│ [LH_P2 [LH_C _lh_break_LH_C_0¹ _lh_break_LH_P2_0¹] _lh_break_LH_P2_1¹]: 184 --->
//│ 	case _lh_matchIdent⁵ of {LH_P2 _lh_words_LH_P2_0¹ _lh_words_LH_P2_1¹ => [LH_C _lh_words_LH_P2_0¹ words₀₀(_lh_words_LH_P2_1¹)] | _  => error⁰}: 157
//│ [LH_N]: 194 --->
//│ 	case _lh_matchIdent⁴ of {LH_N  => [LH_N] | _  => let _lh_matchIdent⁵ = break₀₀((fun x³ -> polyEq⁰(x³, ' ')), _lh_matchIdent⁴)
//│ in case _lh_matchIdent⁵ of {LH_P2 _lh_words_LH_P2_0¹ _lh_words_LH_P2_1¹ => [LH_C _lh_words_LH_P2_0¹ words₀₀(_lh_words_LH_P2_1¹)] | _  => error⁰}}: 159
//│ 	case _lh_break_arg2¹ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹ => if _lh_break_arg1¹(_lh_break_LH_C_0¹) then [LH_P2 [LH_N] [LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹]] else let _lh_matchIdent⁶ = break1₀₀(_lh_break_arg1¹, _lh_break_LH_C_1¹)
//│ in case _lh_matchIdent⁶ of {LH_P2 _lh_break_LH_P2_0¹ _lh_break_LH_P2_1¹ => [LH_P2 [LH_C _lh_break_LH_C_0¹ _lh_break_LH_P2_0¹] _lh_break_LH_P2_1¹] | _  => error⁰} | _  => error⁰}: 190
//│ [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹]: 205 --->
//│ 	case _lh_matchIdent⁴ of {LH_N  => [LH_N] | _  => let _lh_matchIdent⁵ = break₀₀((fun x³ -> polyEq⁰(x³, ' ')), _lh_matchIdent⁴)
//│ in case _lh_matchIdent⁵ of {LH_P2 _lh_words_LH_P2_0¹ _lh_words_LH_P2_1¹ => [LH_C _lh_words_LH_P2_0¹ words₀₀(_lh_words_LH_P2_1¹)] | _  => error⁰}}: 159
//│ 	case _lh_break_arg2¹ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹ => if _lh_break_arg1¹(_lh_break_LH_C_0¹) then [LH_P2 [LH_N] [LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹]] else let _lh_matchIdent⁶ = break1₀₀(_lh_break_arg1¹, _lh_break_LH_C_1¹)
//│ in case _lh_matchIdent⁶ of {LH_P2 _lh_break_LH_P2_0¹ _lh_break_LH_P2_1¹ => [LH_P2 [LH_C _lh_break_LH_C_0¹ _lh_break_LH_P2_0¹] _lh_break_LH_P2_1¹] | _  => error⁰} | _  => error⁰}: 190
//│ [LH_N]: 213 --->
//│ 	case _lh_dropWhile_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹ => if _lh_dropWhile_arg1¹(_lh_dropWhile_LH_C_0¹) then dropWhile₀₀(_lh_dropWhile_arg1¹, _lh_dropWhile_LH_C_1¹) else [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹] | _  => error⁰}: 208
//│ [LH_P2 [LH_N] [LH_N]]: 214 --->
//│ 	case _lh_matchIdent⁶ of {LH_P2 _lh_break_LH_P2_0¹ _lh_break_LH_P2_1¹ => [LH_P2 [LH_C _lh_break_LH_C_0¹ _lh_break_LH_P2_0¹] _lh_break_LH_P2_1¹] | _  => error⁰}: 186
//│ 	case _lh_matchIdent⁷ of {LH_P2 _lh_break1_LH_P2_0¹ _lh_break1_LH_P2_1¹ => [LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹] | _  => error⁰}: 235
//│ [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹]: 221 --->
//│ 	case _lh_dropWhile_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹ => if _lh_dropWhile_arg1¹(_lh_dropWhile_LH_C_0¹) then dropWhile₀₀(_lh_dropWhile_arg1¹, _lh_dropWhile_LH_C_1¹) else [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹] | _  => error⁰}: 208
//│ [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹]]: 222 --->
//│ 	case _lh_matchIdent⁶ of {LH_P2 _lh_break_LH_P2_0¹ _lh_break_LH_P2_1¹ => [LH_P2 [LH_C _lh_break_LH_C_0¹ _lh_break_LH_P2_0¹] _lh_break_LH_P2_1¹] | _  => error⁰}: 186
//│ 	case _lh_matchIdent⁷ of {LH_P2 _lh_break1_LH_P2_0¹ _lh_break1_LH_P2_1¹ => [LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹] | _  => error⁰}: 235
//│ [LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹]: 233 --->
//│ 	case _lh_matchIdent⁶ of {LH_P2 _lh_break_LH_P2_0¹ _lh_break_LH_P2_1¹ => [LH_P2 [LH_C _lh_break_LH_C_0¹ _lh_break_LH_P2_0¹] _lh_break_LH_P2_1¹] | _  => error⁰}: 186
//│ 	case _lh_matchIdent⁷ of {LH_P2 _lh_break1_LH_P2_0¹ _lh_break1_LH_P2_1¹ => [LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹] | _  => error⁰}: 235
//│ [LH_N]: 248 --->
//│ 	case _lh_dropWhile_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹ => if _lh_dropWhile_arg1¹(_lh_dropWhile_LH_C_0¹) then dropWhile₀₀(_lh_dropWhile_arg1¹, _lh_dropWhile_LH_C_1¹) else [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹] | _  => error⁰}: 208
//│ 	case _lh_break1_arg2¹ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹ => if _lh_break1_arg1¹(_lh_break1_LH_C_0¹) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹]] else let _lh_matchIdent⁷ = break1₀₀(_lh_break1_arg1¹, _lh_break1_LH_C_1¹)
//│ in case _lh_matchIdent⁷ of {LH_P2 _lh_break1_LH_P2_0¹ _lh_break1_LH_P2_1¹ => [LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹] | _  => error⁰} | _  => error⁰}: 239
//│ [LH_C '4' [LH_N]]: 249 --->
//│ 	case _lh_dropWhile_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹ => if _lh_dropWhile_arg1¹(_lh_dropWhile_LH_C_0¹) then dropWhile₀₀(_lh_dropWhile_arg1¹, _lh_dropWhile_LH_C_1¹) else [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹] | _  => error⁰}: 208
//│ 	case _lh_break1_arg2¹ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹ => if _lh_break1_arg1¹(_lh_break1_LH_C_0¹) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹]] else let _lh_matchIdent⁷ = break1₀₀(_lh_break1_arg1¹, _lh_break1_LH_C_1¹)
//│ in case _lh_matchIdent⁷ of {LH_P2 _lh_break1_LH_P2_0¹ _lh_break1_LH_P2_1¹ => [LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹] | _  => error⁰} | _  => error⁰}: 239
//│ [LH_C ' ' [LH_C '4' [LH_N]]]: 250 --->
//│ 	case _lh_dropWhile_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹ => if _lh_dropWhile_arg1¹(_lh_dropWhile_LH_C_0¹) then dropWhile₀₀(_lh_dropWhile_arg1¹, _lh_dropWhile_LH_C_1¹) else [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹] | _  => error⁰}: 208
//│ 	case _lh_break1_arg2¹ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹ => if _lh_break1_arg1¹(_lh_break1_LH_C_0¹) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹]] else let _lh_matchIdent⁷ = break1₀₀(_lh_break1_arg1¹, _lh_break1_LH_C_1¹)
//│ in case _lh_matchIdent⁷ of {LH_P2 _lh_break1_LH_P2_0¹ _lh_break1_LH_P2_1¹ => [LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹] | _  => error⁰} | _  => error⁰}: 239
//│ [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]: 251 --->
//│ 	case _lh_dropWhile_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹ => if _lh_dropWhile_arg1¹(_lh_dropWhile_LH_C_0¹) then dropWhile₀₀(_lh_dropWhile_arg1¹, _lh_dropWhile_LH_C_1¹) else [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹] | _  => error⁰}: 208
//│ 	case _lh_break1_arg2¹ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹ => if _lh_break1_arg1¹(_lh_break1_LH_C_0¹) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹]] else let _lh_matchIdent⁷ = break1₀₀(_lh_break1_arg1¹, _lh_break1_LH_C_1¹)
//│ in case _lh_matchIdent⁷ of {LH_P2 _lh_break1_LH_P2_0¹ _lh_break1_LH_P2_1¹ => [LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹] | _  => error⁰} | _  => error⁰}: 239
//│ [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]: 252 --->
//│ 	case _lh_dropWhile_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹ => if _lh_dropWhile_arg1¹(_lh_dropWhile_LH_C_0¹) then dropWhile₀₀(_lh_dropWhile_arg1¹, _lh_dropWhile_LH_C_1¹) else [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹] | _  => error⁰}: 208
//│ 	case _lh_break1_arg2¹ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹ => if _lh_break1_arg1¹(_lh_break1_LH_C_0¹) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹]] else let _lh_matchIdent⁷ = break1₀₀(_lh_break1_arg1¹, _lh_break1_LH_C_1¹)
//│ in case _lh_matchIdent⁷ of {LH_P2 _lh_break1_LH_P2_0¹ _lh_break1_LH_P2_1¹ => [LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹] | _  => error⁰} | _  => error⁰}: 239
//│ [LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]]: 253 --->
//│ 	case _lh_dropWhile_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹ => if _lh_dropWhile_arg1¹(_lh_dropWhile_LH_C_0¹) then dropWhile₀₀(_lh_dropWhile_arg1¹, _lh_dropWhile_LH_C_1¹) else [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹] | _  => error⁰}: 208
//│ ------------------
//│ case _lh_matchIdent⁵ of {LH_P2 _lh_words_LH_P2_0¹ _lh_words_LH_P2_1¹ => [LH_C _lh_words_LH_P2_0¹ words₀₀(_lh_words_LH_P2_1¹)] | _  => error⁰}: 157 --->
//│ 	[LH_P2 [LH_N] [LH_N]]: 165
//│ 	[LH_P2 [LH_N] [LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹]]: 173
//│ 	[LH_P2 [LH_C _lh_break_LH_C_0¹ _lh_break_LH_P2_0¹] _lh_break_LH_P2_1¹]: 184
//│ case _lh_matchIdent⁴ of {LH_N  => [LH_N] | _  => let _lh_matchIdent⁵ = break₀₀((fun x³ -> polyEq⁰(x³, ' ')), _lh_matchIdent⁴)
//│ in case _lh_matchIdent⁵ of {LH_P2 _lh_words_LH_P2_0¹ _lh_words_LH_P2_1¹ => [LH_C _lh_words_LH_P2_0¹ words₀₀(_lh_words_LH_P2_1¹)] | _  => error⁰}}: 159 --->
//│ 	[LH_N]: 194
//│ 	[LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹]: 205
//│ case _lh_matchIdent⁶ of {LH_P2 _lh_break_LH_P2_0¹ _lh_break_LH_P2_1¹ => [LH_P2 [LH_C _lh_break_LH_C_0¹ _lh_break_LH_P2_0¹] _lh_break_LH_P2_1¹] | _  => error⁰}: 186 --->
//│ 	[LH_P2 [LH_N] [LH_N]]: 214
//│ 	[LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹]]: 222
//│ 	[LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹]: 233
//│ case _lh_break_arg2¹ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹ => if _lh_break_arg1¹(_lh_break_LH_C_0¹) then [LH_P2 [LH_N] [LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹]] else let _lh_matchIdent⁶ = break1₀₀(_lh_break_arg1¹, _lh_break_LH_C_1¹)
//│ in case _lh_matchIdent⁶ of {LH_P2 _lh_break_LH_P2_0¹ _lh_break_LH_P2_1¹ => [LH_P2 [LH_C _lh_break_LH_C_0¹ _lh_break_LH_P2_0¹] _lh_break_LH_P2_1¹] | _  => error⁰} | _  => error⁰}: 190 --->
//│ 	[LH_N]: 194
//│ 	[LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹]: 205
//│ case _lh_dropWhile_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹ => if _lh_dropWhile_arg1¹(_lh_dropWhile_LH_C_0¹) then dropWhile₀₀(_lh_dropWhile_arg1¹, _lh_dropWhile_LH_C_1¹) else [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹] | _  => error⁰}: 208 --->
//│ 	[LH_N]: 164
//│ 	[LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹]: 172
//│ 	[LH_N]: 213
//│ 	[LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹]: 221
//│ 	[LH_N]: 248
//│ 	[LH_C '4' [LH_N]]: 249
//│ 	[LH_C ' ' [LH_C '4' [LH_N]]]: 250
//│ 	[LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]: 251
//│ 	[LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]: 252
//│ 	[LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]]: 253
//│ case _lh_matchIdent⁷ of {LH_P2 _lh_break1_LH_P2_0¹ _lh_break1_LH_P2_1¹ => [LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹] | _  => error⁰}: 235 --->
//│ 	[LH_P2 [LH_N] [LH_N]]: 214
//│ 	[LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹]]: 222
//│ 	[LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹]: 233
//│ case _lh_break1_arg2¹ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹ => if _lh_break1_arg1¹(_lh_break1_LH_C_0¹) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹]] else let _lh_matchIdent⁷ = break1₀₀(_lh_break1_arg1¹, _lh_break1_LH_C_1¹)
//│ in case _lh_matchIdent⁷ of {LH_P2 _lh_break1_LH_P2_0¹ _lh_break1_LH_P2_1¹ => [LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹] | _  => error⁰} | _  => error⁰}: 239 --->
//│ 	[LH_N]: 248
//│ 	[LH_C '4' [LH_N]]: 249
//│ 	[LH_C ' ' [LH_C '4' [LH_N]]]: 250
//│ 	[LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]: 251
//│ 	[LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]: 252
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_P2 [LH_N] [LH_N]]: 165 --->
//│ 	case _lh_matchIdent⁵ of {LH_P2 _lh_words_LH_P2_0¹ _lh_words_LH_P2_1¹ => [LH_C _lh_words_LH_P2_0¹ words₀₀(_lh_words_LH_P2_1¹)] | _  => error⁰}: 157
//│ [LH_P2 [LH_N] [LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹]]: 173 --->
//│ 	case _lh_matchIdent⁵ of {LH_P2 _lh_words_LH_P2_0¹ _lh_words_LH_P2_1¹ => [LH_C _lh_words_LH_P2_0¹ words₀₀(_lh_words_LH_P2_1¹)] | _  => error⁰}: 157
//│ [LH_P2 [LH_C _lh_break_LH_C_0¹ _lh_break_LH_P2_0¹] _lh_break_LH_P2_1¹]: 184 --->
//│ 	case _lh_matchIdent⁵ of {LH_P2 _lh_words_LH_P2_0¹ _lh_words_LH_P2_1¹ => [LH_C _lh_words_LH_P2_0¹ words₀₀(_lh_words_LH_P2_1¹)] | _  => error⁰}: 157
//│ ------------------
//│ case _lh_matchIdent⁵ of {LH_P2 _lh_words_LH_P2_0¹ _lh_words_LH_P2_1¹ => [LH_C _lh_words_LH_P2_0¹ words₀₀(_lh_words_LH_P2_1¹)] | _  => error⁰}: 157 --->
//│ 	[LH_P2 [LH_N] [LH_N]]: 165
//│ 	[LH_P2 [LH_N] [LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹]]: 173
//│ 	[LH_P2 [LH_C _lh_break_LH_C_0¹ _lh_break_LH_P2_0¹] _lh_break_LH_P2_1¹]: 184
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ words₀₀([LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]])
//│ def words₀₀(_lh_words_arg1²) = 
//│ 	let _lh_matchIdent⁸ = dropWhile₀₀((fun x⁴ -> polyEq⁰(x⁴, ' ')), _lh_words_arg1²)
//│ 	in case _lh_matchIdent⁸ of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => 
//│ 			let _lh_matchIdent⁹ = break₀₀((fun x⁵ -> polyEq⁰(x⁵, ' ')), _lh_matchIdent⁸)
//│ 			in _lh_matchIdent⁹(99)}
//│ 	where
//│ 	def break₀₀(_lh_break_arg1², _lh_break_arg2²) = 
//│ 		case _lh_break_arg2² of {
//│ 			LH_N  => 
//│ 				let _lh_words_LH_P2_1² = [LH_N]
//│ 				in let _lh_words_LH_P2_0² = [LH_N]
//│ 				in (fun _lh_dummy⁰ -> [LH_C _lh_words_LH_P2_0² words₀₀(_lh_words_LH_P2_1²)])
//│ 			| LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹ => if _lh_break_arg1²(_lh_break_LH_C_0¹) then 
//│ 				let _lh_words_LH_P2_1³ = [LH_C _lh_break_LH_C_0¹ _lh_break_LH_C_1¹]
//│ 				in let _lh_words_LH_P2_0³ = [LH_N]
//│ 				in (fun _lh_dummy¹ -> [LH_C _lh_words_LH_P2_0³ words₀₀(_lh_words_LH_P2_1³)]) else 
//│ 				let _lh_matchIdent¹⁰ = break1₀₀(_lh_break_arg1², _lh_break_LH_C_1¹)
//│ 				in case _lh_matchIdent¹⁰ of {
//│ 					LH_P2 _lh_break_LH_P2_0¹ _lh_break_LH_P2_1¹ => 
//│ 						let _lh_words_LH_P2_1⁴ = _lh_break_LH_P2_1¹
//│ 						in let _lh_words_LH_P2_0⁴ = [LH_C _lh_break_LH_C_0¹ _lh_break_LH_P2_0¹]
//│ 						in (fun _lh_dummy² -> [LH_C _lh_words_LH_P2_0⁴ words₀₀(_lh_words_LH_P2_1⁴)])
//│ 					| _  => error⁰}
//│ 			| _  => error⁰}
//│ 		where
//│ 		def break1₀₀(_lh_break1_arg1², _lh_break1_arg2²) = 
//│ 			case _lh_break1_arg2² of {
//│ 				LH_N  => [LH_P2 [LH_N] [LH_N]]
//│ 				| LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹ => if _lh_break1_arg1²(_lh_break1_LH_C_0¹) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_C_1¹]] else 
//│ 					let _lh_matchIdent¹¹ = break1₀₀(_lh_break1_arg1², _lh_break1_LH_C_1¹)
//│ 					in case _lh_matchIdent¹¹ of {
//│ 						LH_P2 _lh_break1_LH_P2_0¹ _lh_break1_LH_P2_1¹ => [LH_P2 [LH_C _lh_break1_LH_C_0¹ _lh_break1_LH_P2_0¹] _lh_break1_LH_P2_1¹]
//│ 						| _  => error⁰}
//│ 				| _  => error⁰}
//│ 	def dropWhile₀₀(_lh_dropWhile_arg1², _lh_dropWhile_arg2²) = 
//│ 		case _lh_dropWhile_arg2² of {
//│ 			LH_N  => [LH_N]
//│ 			| LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹ => if _lh_dropWhile_arg1²(_lh_dropWhile_LH_C_0¹) then dropWhile₀₀(_lh_dropWhile_arg1², _lh_dropWhile_LH_C_1¹) else [LH_C _lh_dropWhile_LH_C_0¹ _lh_dropWhile_LH_C_1¹]
//│ 			| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ words₀₀ :: 'words₀₀ <: [LH_C(Char, LH_C(Char, LH_C(Char, LH_C(Char, LH_C(Char, LH_N))))) => '13_callres | '_lh_words_LH_P2_1⁰ => '49_callres | '_lh_words_LH_P2_1¹ => '64_callres | '_lh_words_LH_P2_1² => '82_callres] ::: false
//│ '1' :: Char ::: false
//│ ' ' :: Char ::: false
//│ '2' :: Char ::: false
//│ ' ' :: Char ::: false
//│ '4' :: Char ::: false
//│ [LH_N] :: LH_N ::: true
//│ [LH_C '4' [LH_N]] :: LH_C(Char, LH_N) ::: true
//│ [LH_C ' ' [LH_C '4' [LH_N]]] :: LH_C(Char, LH_C(Char, LH_N)) ::: true
//│ [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]] :: LH_C(Char, LH_C(Char, LH_C(Char, LH_N))) ::: true
//│ [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]] :: LH_C(Char, LH_C(Char, LH_C(Char, LH_C(Char, LH_N)))) ::: true
//│ [LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]] :: LH_C(Char, LH_C(Char, LH_C(Char, LH_C(Char, LH_C(Char, LH_N))))) ::: true
//│ words₀₀([LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]]) :: '13_callres <: [NoCons] ::: false
//│ dropWhile₀₀ :: 'dropWhile₀₀ <: ['x⁰ => '19_callres => '21_callres | '_lh_dropWhile_arg1⁰ => '102_callres] ::: false
//│ polyEq :: NoProd ::: true
//│ x :: 'x⁰ <: [NoCons] ::: false
//│ polyEq(x) :: '17_callres <: [Char => '19_callres] ::: false
//│ ' ' :: Char ::: false
//│ polyEq(x, ' ') :: '19_callres <: ['99_callres] ::: false
//│ (fun x -> polyEq(x, ' ')) :: 'x⁰ => '19_callres ::: true
//│ dropWhile₀₀((fun x -> polyEq(x, ' '))) :: '21_callres <: ['_lh_words_arg1⁰ => '23_callres] ::: false
//│ _lh_words_arg1 :: '_lh_words_arg1⁰ <: ['_lh_dropWhile_arg2⁰] ::: false
//│ dropWhile₀₀((fun x -> polyEq(x, ' ')), _lh_words_arg1) :: '23_callres <: ['_lh_matchIdent⁰] ::: false
//│ _lh_matchIdent :: '_lh_matchIdent⁰ <: ['_lh_break_arg2⁰ | Destruct(LH_N, _)] ::: false
//│ [LH_N] :: LH_N ::: true
//│ break₀₀ :: 'break₀₀ <: ['x¹ => '31_callres => '33_callres] ::: false
//│ polyEq :: NoProd ::: true
//│ x :: 'x¹ <: [NoCons] ::: false
//│ polyEq(x) :: '29_callres <: [Char => '31_callres] ::: false
//│ ' ' :: Char ::: false
//│ polyEq(x, ' ') :: '31_callres <: ['119_callres | '56_callres] ::: false
//│ (fun x -> polyEq(x, ' ')) :: 'x¹ => '31_callres ::: true
//│ break₀₀((fun x -> polyEq(x, ' '))) :: '33_callres <: ['_lh_matchIdent⁰ => '35_callres] ::: false
//│ _lh_matchIdent :: '_lh_matchIdent⁰ <: ['_lh_break_arg2⁰ | Destruct(LH_N, _)] ::: false
//│ break₀₀((fun x -> polyEq(x, ' ')), _lh_matchIdent) :: '35_callres <: ['_lh_matchIdent¹] ::: false
//│ _lh_matchIdent :: '_lh_matchIdent¹ <: [Int => '38_callres] ::: false
//│ 99 :: Int ::: false
//│ _lh_matchIdent(99) :: '38_callres <: ['40_matchres] ::: false
//│ let _lh_matchIdent = break₀₀((fun x -> polyEq(x, ' ')), _lh_matchIdent)
//│ in _lh_matchIdent(99) :: '38_callres <: ['40_matchres] ::: false
//│ case _lh_matchIdent of {LH_N  => [LH_N] | _  => let _lh_matchIdent = break₀₀((fun x -> polyEq(x, ' ')), _lh_matchIdent)
//│ in _lh_matchIdent(99)} :: '40_matchres <: ['13_callres | '82_callres | '64_callres | '49_callres] ::: false
//│ let _lh_matchIdent = dropWhile₀₀((fun x -> polyEq(x, ' ')), _lh_words_arg1)
//│ in case _lh_matchIdent of {LH_N  => [LH_N] | _  => let _lh_matchIdent = break₀₀((fun x -> polyEq(x, ' ')), _lh_matchIdent)
//│ in _lh_matchIdent(99)} :: '40_matchres <: ['13_callres | '82_callres | '64_callres | '49_callres] ::: false
//│ (fun _lh_words_arg1 -> let _lh_matchIdent = dropWhile₀₀((fun x -> polyEq(x, ' ')), _lh_words_arg1)
//│ in case _lh_matchIdent of {LH_N  => [LH_N] | _  => let _lh_matchIdent = break₀₀((fun x -> polyEq(x, ' ')), _lh_matchIdent)
//│ in _lh_matchIdent(99)}) :: '_lh_words_arg1⁰ => '40_matchres ::: true
//│ _lh_break_arg2 :: '_lh_break_arg2⁰ <: [Destruct(LH_N, LH_C('_lh_break_LH_C_0⁰, '_lh_break_LH_C_1⁰), _)] ::: false
//│ [LH_N] :: LH_N ::: true
//│ [LH_N] :: LH_N ::: true
//│ _lh_words_LH_P2_0 :: '_lh_words_LH_P2_0⁰ <: [NoCons] ::: false
//│ words₀₀ :: 'words₀₀ <: [LH_C(Char, LH_C(Char, LH_C(Char, LH_C(Char, LH_C(Char, LH_N))))) => '13_callres | '_lh_words_LH_P2_1⁰ => '49_callres | '_lh_words_LH_P2_1¹ => '64_callres | '_lh_words_LH_P2_1² => '82_callres] ::: false
//│ _lh_words_LH_P2_1 :: '_lh_words_LH_P2_1⁰ <: ['_lh_words_arg1⁰] ::: false
//│ words₀₀(_lh_words_LH_P2_1) :: '49_callres <: [NoCons] ::: false
//│ [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)] :: LH_C('_lh_words_LH_P2_0⁰, '49_callres) ::: true
//│ (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) :: '_lh_dummy⁰ => LH_C('_lh_words_LH_P2_0⁰, '49_callres) ::: true
//│ let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) :: '_lh_dummy⁰ => LH_C('_lh_words_LH_P2_0⁰, '49_callres) ::: true
//│ let _lh_words_LH_P2_1 = [LH_N]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) :: '_lh_dummy⁰ => LH_C('_lh_words_LH_P2_0⁰, '49_callres) ::: true
//│ _lh_break_arg1 :: '_lh_break_arg1⁰ <: ['_lh_break_LH_C_0⁰ => '56_callres | '_lh_break1_arg1⁰] ::: false
//│ _lh_break_LH_C_0 :: '_lh_break_LH_C_0⁰ <: [NoCons | '_lh_dropWhile_LH_C_0⁰ | 'x¹] ::: false
//│ _lh_break_arg1(_lh_break_LH_C_0) :: '56_callres <: [Destruct(True, False)] ::: false
//│ _lh_break_LH_C_0 :: '_lh_break_LH_C_0⁰ <: [NoCons | '_lh_dropWhile_LH_C_0⁰ | 'x¹] ::: false
//│ _lh_break_LH_C_1 :: '_lh_break_LH_C_1⁰ <: ['_lh_dropWhile_LH_C_1⁰ | '_lh_break1_arg2⁰] ::: false
//│ [LH_C _lh_break_LH_C_0 _lh_break_LH_C_1] :: LH_C('_lh_break_LH_C_0⁰, '_lh_break_LH_C_1⁰) ::: true
//│ [LH_N] :: LH_N ::: true
//│ _lh_words_LH_P2_0 :: '_lh_words_LH_P2_0¹ <: [NoCons] ::: false
//│ words₀₀ :: 'words₀₀ <: [LH_C(Char, LH_C(Char, LH_C(Char, LH_C(Char, LH_C(Char, LH_N))))) => '13_callres | '_lh_words_LH_P2_1⁰ => '49_callres | '_lh_words_LH_P2_1¹ => '64_callres | '_lh_words_LH_P2_1² => '82_callres] ::: false
//│ _lh_words_LH_P2_1 :: '_lh_words_LH_P2_1¹ <: ['_lh_words_arg1⁰] ::: false
//│ words₀₀(_lh_words_LH_P2_1) :: '64_callres <: [NoCons] ::: false
//│ [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)] :: LH_C('_lh_words_LH_P2_0¹, '64_callres) ::: true
//│ (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) :: '_lh_dummy¹ => LH_C('_lh_words_LH_P2_0¹, '64_callres) ::: true
//│ let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) :: '_lh_dummy¹ => LH_C('_lh_words_LH_P2_0¹, '64_callres) ::: true
//│ let _lh_words_LH_P2_1 = [LH_C _lh_break_LH_C_0 _lh_break_LH_C_1]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) :: '_lh_dummy¹ => LH_C('_lh_words_LH_P2_0¹, '64_callres) ::: true
//│ break1₀₀ :: 'break1₀₀ <: ['_lh_break_arg1⁰ => '71_callres | '_lh_break1_arg1⁰ => '127_callres] ::: false
//│ _lh_break_arg1 :: '_lh_break_arg1⁰ <: ['_lh_break_LH_C_0⁰ => '56_callres | '_lh_break1_arg1⁰] ::: false
//│ break1₀₀(_lh_break_arg1) :: '71_callres <: ['_lh_break_LH_C_1⁰ => '73_callres] ::: false
//│ _lh_break_LH_C_1 :: '_lh_break_LH_C_1⁰ <: ['_lh_dropWhile_LH_C_1⁰ | '_lh_break1_arg2⁰] ::: false
//│ break1₀₀(_lh_break_arg1, _lh_break_LH_C_1) :: '73_callres <: ['_lh_matchIdent²] ::: false
//│ _lh_matchIdent :: '_lh_matchIdent² <: [Destruct(LH_P2('_lh_break_LH_P2_0⁰, '_lh_break_LH_P2_1⁰), _)] ::: false
//│ _lh_break_LH_P2_1 :: '_lh_break_LH_P2_1⁰ <: ['_lh_words_LH_P2_1²] ::: false
//│ _lh_break_LH_C_0 :: '_lh_break_LH_C_0⁰ <: [NoCons | '_lh_dropWhile_LH_C_0⁰ | 'x¹] ::: false
//│ _lh_break_LH_P2_0 :: '_lh_break_LH_P2_0⁰ <: [NoCons] ::: false
//│ [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0] :: LH_C('_lh_break_LH_C_0⁰, '_lh_break_LH_P2_0⁰) ::: true
//│ _lh_words_LH_P2_0 :: '_lh_words_LH_P2_0² <: [NoCons] ::: false
//│ words₀₀ :: 'words₀₀ <: [LH_C(Char, LH_C(Char, LH_C(Char, LH_C(Char, LH_C(Char, LH_N))))) => '13_callres | '_lh_words_LH_P2_1⁰ => '49_callres | '_lh_words_LH_P2_1¹ => '64_callres | '_lh_words_LH_P2_1² => '82_callres] ::: false
//│ _lh_words_LH_P2_1 :: '_lh_words_LH_P2_1² <: ['_lh_words_arg1⁰] ::: false
//│ words₀₀(_lh_words_LH_P2_1) :: '82_callres <: [NoCons] ::: false
//│ [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)] :: LH_C('_lh_words_LH_P2_0², '82_callres) ::: true
//│ (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) :: '_lh_dummy² => LH_C('_lh_words_LH_P2_0², '82_callres) ::: true
//│ let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) :: '_lh_dummy² => LH_C('_lh_words_LH_P2_0², '82_callres) ::: true
//│ let _lh_words_LH_P2_1 = _lh_break_LH_P2_1
//│ in let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) :: '_lh_dummy² => LH_C('_lh_words_LH_P2_0², '82_callres) ::: true
//│ error :: '_lh_rigid_error_var <: [DeadCodeCons] ::: true
//│ case _lh_matchIdent of {LH_P2 _lh_break_LH_P2_0 _lh_break_LH_P2_1 => let _lh_words_LH_P2_1 = _lh_break_LH_P2_1
//│ in let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) | _  => error} :: '88_matchres <: ['90_ifres] ::: false
//│ let _lh_matchIdent = break1₀₀(_lh_break_arg1, _lh_break_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break_LH_P2_0 _lh_break_LH_P2_1 => let _lh_words_LH_P2_1 = _lh_break_LH_P2_1
//│ in let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) | _  => error} :: '88_matchres <: ['90_ifres] ::: false
//│ if _lh_break_arg1(_lh_break_LH_C_0) then let _lh_words_LH_P2_1 = [LH_C _lh_break_LH_C_0 _lh_break_LH_C_1]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) else let _lh_matchIdent = break1₀₀(_lh_break_arg1, _lh_break_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break_LH_P2_0 _lh_break_LH_P2_1 => let _lh_words_LH_P2_1 = _lh_break_LH_P2_1
//│ in let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) | _  => error} :: '90_ifres <: ['92_matchres] ::: false
//│ error :: '_lh_rigid_error_var <: [DeadCodeCons] ::: true
//│ case _lh_break_arg2 of {LH_N  => let _lh_words_LH_P2_1 = [LH_N]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) | LH_C _lh_break_LH_C_0 _lh_break_LH_C_1 => if _lh_break_arg1(_lh_break_LH_C_0) then let _lh_words_LH_P2_1 = [LH_C _lh_break_LH_C_0 _lh_break_LH_C_1]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) else let _lh_matchIdent = break1₀₀(_lh_break_arg1, _lh_break_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break_LH_P2_0 _lh_break_LH_P2_1 => let _lh_words_LH_P2_1 = _lh_break_LH_P2_1
//│ in let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) | _  => error} | _  => error} :: '92_matchres <: ['35_callres] ::: false
//│ (fun _lh_break_arg2 -> case _lh_break_arg2 of {LH_N  => let _lh_words_LH_P2_1 = [LH_N]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) | LH_C _lh_break_LH_C_0 _lh_break_LH_C_1 => if _lh_break_arg1(_lh_break_LH_C_0) then let _lh_words_LH_P2_1 = [LH_C _lh_break_LH_C_0 _lh_break_LH_C_1]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) else let _lh_matchIdent = break1₀₀(_lh_break_arg1, _lh_break_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break_LH_P2_0 _lh_break_LH_P2_1 => let _lh_words_LH_P2_1 = _lh_break_LH_P2_1
//│ in let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) | _  => error} | _  => error}) :: '_lh_break_arg2⁰ => '92_matchres ::: true
//│ (fun _lh_break_arg1 -> (fun _lh_break_arg2 -> case _lh_break_arg2 of {LH_N  => let _lh_words_LH_P2_1 = [LH_N]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) | LH_C _lh_break_LH_C_0 _lh_break_LH_C_1 => if _lh_break_arg1(_lh_break_LH_C_0) then let _lh_words_LH_P2_1 = [LH_C _lh_break_LH_C_0 _lh_break_LH_C_1]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) else let _lh_matchIdent = break1₀₀(_lh_break_arg1, _lh_break_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break_LH_P2_0 _lh_break_LH_P2_1 => let _lh_words_LH_P2_1 = _lh_break_LH_P2_1
//│ in let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words₀₀(_lh_words_LH_P2_1)]) | _  => error} | _  => error})) :: '_lh_break_arg1⁰ => '_lh_break_arg2⁰ => '92_matchres ::: true
//│ _lh_dropWhile_arg2 :: '_lh_dropWhile_arg2⁰ <: [Destruct(LH_N, LH_C('_lh_dropWhile_LH_C_0⁰, '_lh_dropWhile_LH_C_1⁰), _)] ::: false
//│ [LH_N] :: LH_N ::: true
//│ _lh_dropWhile_arg1 :: '_lh_dropWhile_arg1⁰ <: ['_lh_dropWhile_LH_C_0⁰ => '99_callres] ::: false
//│ _lh_dropWhile_LH_C_0 :: '_lh_dropWhile_LH_C_0⁰ <: ['_lh_break_LH_C_0⁰ | 'x⁰] ::: false
//│ _lh_dropWhile_arg1(_lh_dropWhile_LH_C_0) :: '99_callres <: [Destruct(True, False)] ::: false
//│ dropWhile₀₀ :: 'dropWhile₀₀ <: ['x⁰ => '19_callres => '21_callres | '_lh_dropWhile_arg1⁰ => '102_callres] ::: false
//│ _lh_dropWhile_arg1 :: '_lh_dropWhile_arg1⁰ <: ['_lh_dropWhile_LH_C_0⁰ => '99_callres] ::: false
//│ dropWhile₀₀(_lh_dropWhile_arg1) :: '102_callres <: ['_lh_dropWhile_LH_C_1⁰ => '104_callres] ::: false
//│ _lh_dropWhile_LH_C_1 :: '_lh_dropWhile_LH_C_1⁰ <: ['_lh_break_LH_C_1⁰ | '_lh_dropWhile_arg2⁰] ::: false
//│ dropWhile₀₀(_lh_dropWhile_arg1, _lh_dropWhile_LH_C_1) :: '104_callres <: ['108_ifres] ::: false
//│ _lh_dropWhile_LH_C_0 :: '_lh_dropWhile_LH_C_0⁰ <: ['_lh_break_LH_C_0⁰ | 'x⁰] ::: false
//│ _lh_dropWhile_LH_C_1 :: '_lh_dropWhile_LH_C_1⁰ <: ['_lh_break_LH_C_1⁰ | '_lh_dropWhile_arg2⁰] ::: false
//│ [LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1] :: LH_C('_lh_dropWhile_LH_C_0⁰, '_lh_dropWhile_LH_C_1⁰) ::: true
//│ if _lh_dropWhile_arg1(_lh_dropWhile_LH_C_0) then dropWhile₀₀(_lh_dropWhile_arg1, _lh_dropWhile_LH_C_1) else [LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1] :: '108_ifres <: ['110_matchres] ::: false
//│ error :: '_lh_rigid_error_var <: [DeadCodeCons] ::: true
//│ case _lh_dropWhile_arg2 of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1 => if _lh_dropWhile_arg1(_lh_dropWhile_LH_C_0) then dropWhile₀₀(_lh_dropWhile_arg1, _lh_dropWhile_LH_C_1) else [LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1] | _  => error} :: '110_matchres <: ['23_callres | '104_callres] ::: false
//│ (fun _lh_dropWhile_arg2 -> case _lh_dropWhile_arg2 of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1 => if _lh_dropWhile_arg1(_lh_dropWhile_LH_C_0) then dropWhile₀₀(_lh_dropWhile_arg1, _lh_dropWhile_LH_C_1) else [LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1] | _  => error}) :: '_lh_dropWhile_arg2⁰ => '110_matchres ::: true
//│ (fun _lh_dropWhile_arg1 -> (fun _lh_dropWhile_arg2 -> case _lh_dropWhile_arg2 of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1 => if _lh_dropWhile_arg1(_lh_dropWhile_LH_C_0) then dropWhile₀₀(_lh_dropWhile_arg1, _lh_dropWhile_LH_C_1) else [LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1] | _  => error})) :: '_lh_dropWhile_arg1⁰ => '_lh_dropWhile_arg2⁰ => '110_matchres ::: true
//│ _lh_break1_arg2 :: '_lh_break1_arg2⁰ <: [Destruct(LH_N, LH_C('_lh_break1_LH_C_0⁰, '_lh_break1_LH_C_1⁰), _)] ::: false
//│ [LH_N] :: LH_N ::: true
//│ [LH_N] :: LH_N ::: true
//│ [LH_P2 [LH_N] [LH_N]] :: LH_P2(LH_N, LH_N) ::: true
//│ _lh_break1_arg1 :: '_lh_break1_arg1⁰ <: ['_lh_break1_LH_C_0⁰ => '119_callres] ::: false
//│ _lh_break1_LH_C_0 :: '_lh_break1_LH_C_0⁰ <: [NoCons | '_lh_dropWhile_LH_C_0⁰ | 'x¹] ::: false
//│ _lh_break1_arg1(_lh_break1_LH_C_0) :: '119_callres <: [Destruct(True, False)] ::: false
//│ [LH_N] :: LH_N ::: true
//│ _lh_break1_LH_C_0 :: '_lh_break1_LH_C_0⁰ <: [NoCons | '_lh_dropWhile_LH_C_0⁰ | 'x¹] ::: false
//│ _lh_break1_LH_C_1 :: '_lh_break1_LH_C_1⁰ <: ['_lh_dropWhile_LH_C_1⁰ | '_lh_break1_arg2⁰] ::: false
//│ [LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1] :: LH_C('_lh_break1_LH_C_0⁰, '_lh_break1_LH_C_1⁰) ::: true
//│ [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1]] :: LH_P2(LH_N, LH_C('_lh_break1_LH_C_0⁰, '_lh_break1_LH_C_1⁰)) ::: true
//│ break1₀₀ :: 'break1₀₀ <: ['_lh_break_arg1⁰ => '71_callres | '_lh_break1_arg1⁰ => '127_callres] ::: false
//│ _lh_break1_arg1 :: '_lh_break1_arg1⁰ <: ['_lh_break1_LH_C_0⁰ => '119_callres] ::: false
//│ break1₀₀(_lh_break1_arg1) :: '127_callres <: ['_lh_break1_LH_C_1⁰ => '129_callres] ::: false
//│ _lh_break1_LH_C_1 :: '_lh_break1_LH_C_1⁰ <: ['_lh_dropWhile_LH_C_1⁰ | '_lh_break1_arg2⁰] ::: false
//│ break1₀₀(_lh_break1_arg1, _lh_break1_LH_C_1) :: '129_callres <: ['_lh_matchIdent³] ::: false
//│ _lh_matchIdent :: '_lh_matchIdent³ <: [Destruct(LH_P2('_lh_break1_LH_P2_0⁰, '_lh_break1_LH_P2_1⁰), _)] ::: false
//│ _lh_break1_LH_C_0 :: '_lh_break1_LH_C_0⁰ <: [NoCons | '_lh_dropWhile_LH_C_0⁰ | 'x¹] ::: false
//│ _lh_break1_LH_P2_0 :: '_lh_break1_LH_P2_0⁰ <: [NoCons] ::: false
//│ [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] :: LH_C('_lh_break1_LH_C_0⁰, '_lh_break1_LH_P2_0⁰) ::: true
//│ _lh_break1_LH_P2_1 :: '_lh_break1_LH_P2_1⁰ <: ['_lh_break_LH_P2_1⁰] ::: false
//│ [LH_P2 [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] _lh_break1_LH_P2_1] :: LH_P2(LH_C('_lh_break1_LH_C_0⁰, '_lh_break1_LH_P2_0⁰), '_lh_break1_LH_P2_1⁰) ::: true
//│ error :: '_lh_rigid_error_var <: [DeadCodeCons] ::: true
//│ case _lh_matchIdent of {LH_P2 _lh_break1_LH_P2_0 _lh_break1_LH_P2_1 => [LH_P2 [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] _lh_break1_LH_P2_1] | _  => error} :: '137_matchres <: ['139_ifres] ::: false
//│ let _lh_matchIdent = break1₀₀(_lh_break1_arg1, _lh_break1_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break1_LH_P2_0 _lh_break1_LH_P2_1 => [LH_P2 [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] _lh_break1_LH_P2_1] | _  => error} :: '137_matchres <: ['139_ifres] ::: false
//│ if _lh_break1_arg1(_lh_break1_LH_C_0) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1]] else let _lh_matchIdent = break1₀₀(_lh_break1_arg1, _lh_break1_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break1_LH_P2_0 _lh_break1_LH_P2_1 => [LH_P2 [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] _lh_break1_LH_P2_1] | _  => error} :: '139_ifres <: ['141_matchres] ::: false
//│ error :: '_lh_rigid_error_var <: [DeadCodeCons] ::: true
//│ case _lh_break1_arg2 of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1 => if _lh_break1_arg1(_lh_break1_LH_C_0) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1]] else let _lh_matchIdent = break1₀₀(_lh_break1_arg1, _lh_break1_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break1_LH_P2_0 _lh_break1_LH_P2_1 => [LH_P2 [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] _lh_break1_LH_P2_1] | _  => error} | _  => error} :: '141_matchres <: ['73_callres | '129_callres] ::: false
//│ (fun _lh_break1_arg2 -> case _lh_break1_arg2 of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1 => if _lh_break1_arg1(_lh_break1_LH_C_0) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1]] else let _lh_matchIdent = break1₀₀(_lh_break1_arg1, _lh_break1_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break1_LH_P2_0 _lh_break1_LH_P2_1 => [LH_P2 [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] _lh_break1_LH_P2_1] | _  => error} | _  => error}) :: '_lh_break1_arg2⁰ => '141_matchres ::: true
//│ (fun _lh_break1_arg1 -> (fun _lh_break1_arg2 -> case _lh_break1_arg2 of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1 => if _lh_break1_arg1(_lh_break1_LH_C_0) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1]] else let _lh_matchIdent = break1₀₀(_lh_break1_arg1, _lh_break1_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break1_LH_P2_0 _lh_break1_LH_P2_1 => [LH_P2 [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] _lh_break1_LH_P2_1] | _  => error} | _  => error})) :: '_lh_break1_arg1⁰ => '_lh_break1_arg2⁰ => '141_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec break1_d0_d0 _lh_break1_arg1_0 _lh_break1_arg2_0 =
//│   (match _lh_break1_arg2_0 with
//│     | `LH_N -> 
//│       (`LH_P2((`LH_N), (`LH_N)))
//│     | `LH_C(_lh_break1_LH_C_0_0, _lh_break1_LH_C_1_0) -> 
//│       (if (_lh_break1_arg1_0 _lh_break1_LH_C_0_0) then
//│         (`LH_P2((`LH_N), (`LH_C(_lh_break1_LH_C_0_0, _lh_break1_LH_C_1_0))))
//│       else
//│         (let rec _lh_matchIdent_3 = ((break1_d0_d0 _lh_break1_arg1_0) _lh_break1_LH_C_1_0) in
//│           (match _lh_matchIdent_3 with
//│             | `LH_P2(_lh_break1_LH_P2_0_0, _lh_break1_LH_P2_1_0) -> 
//│               (`LH_P2((`LH_C(_lh_break1_LH_C_0_0, _lh_break1_LH_P2_0_0)), _lh_break1_LH_P2_1_0))
//│             | _ -> 
//│               (failwith "error"))))
//│     | _ -> 
//│       (failwith "error"))
//│ and break_d0_d0 _lh_break_arg1_0 _lh_break_arg2_0 =
//│   (match _lh_break_arg2_0 with
//│     | `LH_N -> 
//│       (let rec _lh_words_LH_P2_1_0 = (`LH_N) in
//│         (let rec _lh_words_LH_P2_0_0 = (`LH_N) in
//│           (fun _lh_dummy_0 -> 
//│             (`LH_C(_lh_words_LH_P2_0_0, (words_d0_d0 _lh_words_LH_P2_1_0))))))
//│     | `LH_C(_lh_break_LH_C_0_0, _lh_break_LH_C_1_0) -> 
//│       (if (_lh_break_arg1_0 _lh_break_LH_C_0_0) then
//│         (let rec _lh_words_LH_P2_1_1 = (`LH_C(_lh_break_LH_C_0_0, _lh_break_LH_C_1_0)) in
//│           (let rec _lh_words_LH_P2_0_1 = (`LH_N) in
//│             (fun _lh_dummy_1 -> 
//│               (`LH_C(_lh_words_LH_P2_0_1, (words_d0_d0 _lh_words_LH_P2_1_1))))))
//│       else
//│         (let rec _lh_matchIdent_2 = ((break1_d0_d0 _lh_break_arg1_0) _lh_break_LH_C_1_0) in
//│           (match _lh_matchIdent_2 with
//│             | `LH_P2(_lh_break_LH_P2_0_0, _lh_break_LH_P2_1_0) -> 
//│               (let rec _lh_words_LH_P2_1_2 = _lh_break_LH_P2_1_0 in
//│                 (let rec _lh_words_LH_P2_0_2 = (`LH_C(_lh_break_LH_C_0_0, _lh_break_LH_P2_0_0)) in
//│                   (fun _lh_dummy_2 -> 
//│                     (`LH_C(_lh_words_LH_P2_0_2, (words_d0_d0 _lh_words_LH_P2_1_2))))))
//│             | _ -> 
//│               (failwith "error"))))
//│     | _ -> 
//│       (failwith "error"))
//│ and dropWhile_d0_d0 _lh_dropWhile_arg1_0 _lh_dropWhile_arg2_0 =
//│   (match _lh_dropWhile_arg2_0 with
//│     | `LH_N -> 
//│       (`LH_N)
//│     | `LH_C(_lh_dropWhile_LH_C_0_0, _lh_dropWhile_LH_C_1_0) -> 
//│       (if (_lh_dropWhile_arg1_0 _lh_dropWhile_LH_C_0_0) then
//│         ((dropWhile_d0_d0 _lh_dropWhile_arg1_0) _lh_dropWhile_LH_C_1_0)
//│       else
//│         (`LH_C(_lh_dropWhile_LH_C_0_0, _lh_dropWhile_LH_C_1_0)))
//│     | _ -> 
//│       (failwith "error"))
//│ and words_d0_d0 _lh_words_arg1_0 =
//│   (let rec _lh_matchIdent_0 = ((dropWhile_d0_d0 (fun x_0 -> 
//│     (x_0 = ' '))) _lh_words_arg1_0) in
//│     (match _lh_matchIdent_0 with
//│       | `LH_N -> 
//│         (`LH_N)
//│       | _ -> 
//│         (let rec _lh_matchIdent_1 = ((break_d0_d0 (fun x_1 -> 
//│           (x_1 = ' '))) _lh_matchIdent_0) in
//│           (_lh_matchIdent_1 99))));;
//│ (words_d0_d0 (`LH_C('1', (`LH_C(' ', (`LH_C('2', (`LH_C(' ', (`LH_C('4', (`LH_N))))))))))))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│   - : [> `LH_C of
//│          [> `LH_C of char * ([> `LH_C of char * 'b | `LH_N ] as 'b) | `LH_N ] *
//│          'a
//│      | `LH_N ]
//│     as 'a
//│ =
//│ `LH_C
//│   (`LH_C ('1', `LH_N),
//│    `LH_C (`LH_C ('2', `LH_N), `LH_C (`LH_C ('4', `LH_N), `LH_N)))
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


// FIXME: the type error can be eliminated by expanding again to
// eliminate dead codes (totally unreachable definitions) that appear
// after removing dead branches
:lhGenOCaml
:d
fun break(p, ls) = if ls is
  N then P(N, N)
  C(x, xs) then if p(x) then P(N, C(x, xs)) else if break1(p, xs) is
    P(ys, zs) then P(C(x, ys), zs)
fun break1(p, ls) = if ls is
  N then P(N, N)
  C(x, xs) then if p(x) then P(N, C(x, xs)) else if break1(p, xs) is
    P(ys, zs) then P(C(x, ys), zs)
fun words(s) = if dropWhile(x => x == 1, s) is
  N then N
  s' then if break(x => x == 1, s') is
    P(w, s'') then C(w, words(s''))
fun dropWhile(f, ls) = if ls is
  N then N
  C(h, t) then if f(h) then dropWhile(f, t) else C(h, t)
words(C(2, C(1, C(2, C(1, C(2, N))))))
//│ |#fun| |break|(|p|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |P|(|N|,| |N|)|↵|C|(|x|,| |xs|)| |#then| |#if| |p|(|x|)| |#then| |P|(|N|,| |C|(|x|,| |xs|)|)| |#else| |#if| |break1|(|p|,| |xs|)| |is|→|P|(|ys|,| |zs|)| |#then| |P|(|C|(|x|,| |ys|)|,| |zs|)|←|←|↵|#fun| |break1|(|p|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |P|(|N|,| |N|)|↵|C|(|x|,| |xs|)| |#then| |#if| |p|(|x|)| |#then| |P|(|N|,| |C|(|x|,| |xs|)|)| |#else| |#if| |break1|(|p|,| |xs|)| |is|→|P|(|ys|,| |zs|)| |#then| |P|(|C|(|x|,| |ys|)|,| |zs|)|←|←|↵|#fun| |words|(|s|)| |#=| |#if| |dropWhile|(|x| |=>| |x| |==| |1|,| |s|)| |is|→|N| |#then| |N|↵|s'| |#then| |#if| |break|(|x| |=>| |x| |==| |1|,| |s'|)| |is|→|P|(|w|,| |s''|)| |#then| |C|(|w|,| |words|(|s''|)|)|←|←|↵|#fun| |dropWhile|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |dropWhile|(|f|,| |t|)| |#else| |C|(|h|,| |t|)|←|↵|words|(|C|(|2|,| |C|(|1|,| |C|(|2|,| |C|(|1|,| |C|(|2|,| |N|)|)|)|)|)|)|
//│ Parsed: {fun break = p, ls, => if ls is ‹(N) then P (N, N,); (C (x, xs,)) then if (p (x,)) then P (N, C (x, xs,),) else if break1 (p, xs,) is ‹(P (ys, zs,)) then P (C (x, ys,), zs,)››; fun break1 = p, ls, => if ls is ‹(N) then P (N, N,); (C (x, xs,)) then if (p (x,)) then P (N, C (x, xs,),) else if break1 (p, xs,) is ‹(P (ys, zs,)) then P (C (x, ys,), zs,)››; fun words = s, => if dropWhile (x, => == (x,) (1,), s,) is ‹(N) then N; (s') then if break (x, => == (x,) (1,), s',) is ‹(P (w, s'',)) then C (w, words (s'',),)››; fun dropWhile = f, ls, => if ls is ‹(N) then N; (C (h, t,)) then if (f (h,)) then dropWhile (f, t,) else C (h, t,)›; words (C (2, C (1, C (2, C (1, C (2, N,),),),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ words^101([C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]])
//│ def break(p⁰, ls⁰) = case ls⁰ of {
//│ 	N  => [P [N] [N]]
//│ 	| C x⁰ xs⁰ => if p⁰(x⁰) then [P [N] [C x⁰ xs⁰]] else case break1^13(p⁰, xs⁰) of {
//│ 		P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}}
//│ def break1(p¹, ls¹) = case ls¹ of {
//│ 	N  => [P [N] [N]]
//│ 	| C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1^40(p¹, xs¹) of {
//│ 		P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}
//│ def dropWhile(f⁰, ls²) = case ls² of {
//│ 	N  => [N]
//│ 	| C h⁰ t⁰ => if f⁰(h⁰) then dropWhile^89(f⁰, t⁰) else [C h⁰ t⁰]}
//│ def words(s⁰) = case dropWhile^55((fun x² -> (x² == 1)), s⁰) of {
//│ 	N  => [N]
//│ 	| s'⁰ => case break^66((fun x³ -> (x³ == 1)), s'⁰) of {
//│ 		P w⁰ s''⁰ => [C w⁰ words^77(s''⁰)]}}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec break p_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`P((`N), (`N)))
//│ 		    | `C(x_0, xs_0) -> 
//│ 		      (if (p_0 x_0) then
//│ 		        (`P((`N), (`C(x_0, xs_0))))
//│ 		      else
//│ 		        (match ((break1 p_0) xs_0) with
//│ 		          | `P(ys_0, zs_0) -> 
//│ 		            (`P((`C(x_0, ys_0)), zs_0)))))
//│ 		and break1 p_1 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `N -> 
//│ 		      (`P((`N), (`N)))
//│ 		    | `C(x_1, xs_1) -> 
//│ 		      (if (p_1 x_1) then
//│ 		        (`P((`N), (`C(x_1, xs_1))))
//│ 		      else
//│ 		        (match ((break1 p_1) xs_1) with
//│ 		          | `P(ys_1, zs_1) -> 
//│ 		            (`P((`C(x_1, ys_1)), zs_1)))))
//│ 		and dropWhile f_0 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (f_0 h_0) then
//│ 		        ((dropWhile f_0) t_0)
//│ 		      else
//│ 		        (`C(h_0, t_0))))
//│ 		and words s_0 =
//│ 		  (match ((dropWhile (fun x_2 -> 
//│ 		    (x_2 = 1))) s_0) with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | s'_0 -> 
//│ 		      (match ((break (fun x_3 -> 
//│ 		        (x_3 = 1))) s'_0) with
//│ 		        | `P(w_0, s''_0) -> 
//│ 		          (`C(w_0, (words s''_0)))));;
//│ 		(words (`C(2, (`C(1, (`C(2, (`C(1, (`C(2, (`N))))))))))))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		                                                                                val break :
//│ 		  (int -> bool) ->
//│ 		  [ `C of int * ([ `C of int * 'a | `N ] as 'a) | `N ] ->
//│ 		  [ `P of
//│ 		      [> `C of int * ([> `C of int * 'b | `N ] as 'b) | `N ] *
//│ 		      [ `C of int * 'a | `N ] ] =
//│ 		  <fun>
//│ 		val break1 :
//│ 		  (int -> bool) ->
//│ 		  ([ `C of int * 'a | `N ] as 'a) ->
//│ 		  [ `P of ([> `C of int * 'b | `N ] as 'b) * [ `C of int * 'a | `N ] ] =
//│ 		  <fun>
//│ 		val dropWhile :
//│ 		  (int -> bool) -> ([ `C of int * 'a | `N ] as 'a) -> [ `C of int * 'a | `N ] =
//│ 		  <fun>
//│ 		val words :
//│ 		  ([ `C of int * 'a | `N ] as 'a) ->
//│ 		  ([> `C of [> `C of int * ([> `C of int * 'c | `N ] as 'c) | `N ] * 'b | `N
//│ 		   ] as 'b) =
//│ 		  <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [words^101]
//│ 	[words^101 · break^66]
//│ 		[words^101 · break^66 · break1^13]
//│ 			[words^101 · break^66 · break1^13 · break1^40] ---> [words^101 · break^66 · break1^13] (only one)
//│ 	[words^101 · dropWhile^55]
//│ 		[words^101 · dropWhile^55 · dropWhile^89] ---> [words^101 · dropWhile^55] (only one)
//│ 	[words^101 · words^77] ---> [words^101] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ words₀([C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]])
//│ def words₀(s¹) = 
//│ 	case dropWhile₀((fun x⁵ -> (x⁵ == 1)), s¹) of {
//│ 		N  => [N]
//│ 		| s'¹ => case break₀((fun x⁶ -> (x⁶ == 1)), s'¹) of {
//│ 			P w¹ s''¹ => [C w¹ words₀(s''¹)]}}
//│ 	where
//│ 	def break₀(p², ls⁴) = 
//│ 		case ls⁴ of {
//│ 			N  => [P [N] [N]]
//│ 			| C x⁴ xs² => if p²(x⁴) then [P [N] [C x⁴ xs²]] else case break1₀(p², xs²) of {
//│ 				P ys² zs² => [P [C x⁴ ys²] zs²]}}
//│ 		where
//│ 		def break1₀(p³, ls⁵) = 
//│ 			case ls⁵ of {
//│ 				N  => [P [N] [N]]
//│ 				| C x⁷ xs³ => if p³(x⁷) then [P [N] [C x⁷ xs³]] else case break1₀(p³, xs³) of {
//│ 					P ys³ zs³ => [P [C x⁷ ys³] zs³]}}
//│ 	def dropWhile₀(f¹, ls³) = 
//│ 		case ls³ of {
//│ 			N  => [N]
//│ 			| C h¹ t¹ => if f¹(h¹) then dropWhile₀(f¹, t¹) else [C h¹ t¹]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 115 --->
//│ 	case dropWhile₀((fun x⁵ -> (x⁵ == 1)), s¹) of {N  => [N] | s'¹ => case break₀((fun x⁶ -> (x⁶ == 1)), s'¹) of {P w¹ s''¹ => [C w¹ words₀(s''¹)]}}: 185
//│ [C h¹ t¹]: 126 --->
//│ 	case ls⁴ of {N  => [P [N] [N]] | C x⁴ xs² => if p²(x⁴) then [P [N] [C x⁴ xs²]] else case break1₀(p², xs²) of {P ys² zs² => [P [C x⁴ ys²] zs²]}}: 155
//│ 	case dropWhile₀((fun x⁵ -> (x⁵ == 1)), s¹) of {N  => [N] | s'¹ => case break₀((fun x⁶ -> (x⁶ == 1)), s'¹) of {P w¹ s''¹ => [C w¹ words₀(s''¹)]}}: 185
//│ [N]: 133 --->
//│ 	case ls³ of {N  => [N] | C h¹ t¹ => if f¹(h¹) then dropWhile₀(f¹, t¹) else [C h¹ t¹]}: 128
//│ [P [N] [N]]: 134 --->
//│ 	case break₀((fun x⁶ -> (x⁶ == 1)), s'¹) of {P w¹ s''¹ => [C w¹ words₀(s''¹)]}: 184
//│ [C x⁴ xs²]: 141 --->
//│ 	case ls³ of {N  => [N] | C h¹ t¹ => if f¹(h¹) then dropWhile₀(f¹, t¹) else [C h¹ t¹]}: 128
//│ [P [N] [C x⁴ xs²]]: 142 --->
//│ 	case break₀((fun x⁶ -> (x⁶ == 1)), s'¹) of {P w¹ s''¹ => [C w¹ words₀(s''¹)]}: 184
//│ [P [C x⁴ ys²] zs²]: 152 --->
//│ 	case break₀((fun x⁶ -> (x⁶ == 1)), s'¹) of {P w¹ s''¹ => [C w¹ words₀(s''¹)]}: 184
//│ [N]: 189 --->
//│ 	case ls³ of {N  => [N] | C h¹ t¹ => if f¹(h¹) then dropWhile₀(f¹, t¹) else [C h¹ t¹]}: 128
//│ [P [N] [N]]: 190 --->
//│ 	case break1₀(p², xs²) of {P ys² zs² => [P [C x⁴ ys²] zs²]}: 153
//│ 	case break1₀(p³, xs³) of {P ys³ zs³ => [P [C x⁷ ys³] zs³]}: 209
//│ [C x⁷ xs³]: 197 --->
//│ 	case ls³ of {N  => [N] | C h¹ t¹ => if f¹(h¹) then dropWhile₀(f¹, t¹) else [C h¹ t¹]}: 128
//│ [P [N] [C x⁷ xs³]]: 198 --->
//│ 	case break1₀(p², xs²) of {P ys² zs² => [P [C x⁴ ys²] zs²]}: 153
//│ 	case break1₀(p³, xs³) of {P ys³ zs³ => [P [C x⁷ ys³] zs³]}: 209
//│ [P [C x⁷ ys³] zs³]: 208 --->
//│ 	case break1₀(p², xs²) of {P ys² zs² => [P [C x⁴ ys²] zs²]}: 153
//│ 	case break1₀(p³, xs³) of {P ys³ zs³ => [P [C x⁷ ys³] zs³]}: 209
//│ [N]: 220 --->
//│ 	case ls³ of {N  => [N] | C h¹ t¹ => if f¹(h¹) then dropWhile₀(f¹, t¹) else [C h¹ t¹]}: 128
//│ 	case ls⁵ of {N  => [P [N] [N]] | C x⁷ xs³ => if p³(x⁷) then [P [N] [C x⁷ xs³]] else case break1₀(p³, xs³) of {P ys³ zs³ => [P [C x⁷ ys³] zs³]}}: 211
//│ [C 2 [N]]: 221 --->
//│ 	case ls³ of {N  => [N] | C h¹ t¹ => if f¹(h¹) then dropWhile₀(f¹, t¹) else [C h¹ t¹]}: 128
//│ 	case ls⁵ of {N  => [P [N] [N]] | C x⁷ xs³ => if p³(x⁷) then [P [N] [C x⁷ xs³]] else case break1₀(p³, xs³) of {P ys³ zs³ => [P [C x⁷ ys³] zs³]}}: 211
//│ [C 1 [C 2 [N]]]: 222 --->
//│ 	case ls³ of {N  => [N] | C h¹ t¹ => if f¹(h¹) then dropWhile₀(f¹, t¹) else [C h¹ t¹]}: 128
//│ 	case ls⁵ of {N  => [P [N] [N]] | C x⁷ xs³ => if p³(x⁷) then [P [N] [C x⁷ xs³]] else case break1₀(p³, xs³) of {P ys³ zs³ => [P [C x⁷ ys³] zs³]}}: 211
//│ [C 2 [C 1 [C 2 [N]]]]: 223 --->
//│ 	case ls³ of {N  => [N] | C h¹ t¹ => if f¹(h¹) then dropWhile₀(f¹, t¹) else [C h¹ t¹]}: 128
//│ 	case ls⁵ of {N  => [P [N] [N]] | C x⁷ xs³ => if p³(x⁷) then [P [N] [C x⁷ xs³]] else case break1₀(p³, xs³) of {P ys³ zs³ => [P [C x⁷ ys³] zs³]}}: 211
//│ [C 1 [C 2 [C 1 [C 2 [N]]]]]: 224 --->
//│ 	case ls³ of {N  => [N] | C h¹ t¹ => if f¹(h¹) then dropWhile₀(f¹, t¹) else [C h¹ t¹]}: 128
//│ 	case ls⁵ of {N  => [P [N] [N]] | C x⁷ xs³ => if p³(x⁷) then [P [N] [C x⁷ xs³]] else case break1₀(p³, xs³) of {P ys³ zs³ => [P [C x⁷ ys³] zs³]}}: 211
//│ [C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]]: 225 --->
//│ 	case ls³ of {N  => [N] | C h¹ t¹ => if f¹(h¹) then dropWhile₀(f¹, t¹) else [C h¹ t¹]}: 128
//│ ------------------
//│ case ls³ of {N  => [N] | C h¹ t¹ => if f¹(h¹) then dropWhile₀(f¹, t¹) else [C h¹ t¹]}: 128 --->
//│ 	[N]: 133
//│ 	[C x⁴ xs²]: 141
//│ 	[N]: 189
//│ 	[C x⁷ xs³]: 197
//│ 	[N]: 220
//│ 	[C 2 [N]]: 221
//│ 	[C 1 [C 2 [N]]]: 222
//│ 	[C 2 [C 1 [C 2 [N]]]]: 223
//│ 	[C 1 [C 2 [C 1 [C 2 [N]]]]]: 224
//│ 	[C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]]: 225
//│ case break1₀(p², xs²) of {P ys² zs² => [P [C x⁴ ys²] zs²]}: 153 --->
//│ 	[P [N] [N]]: 190
//│ 	[P [N] [C x⁷ xs³]]: 198
//│ 	[P [C x⁷ ys³] zs³]: 208
//│ case ls⁴ of {N  => [P [N] [N]] | C x⁴ xs² => if p²(x⁴) then [P [N] [C x⁴ xs²]] else case break1₀(p², xs²) of {P ys² zs² => [P [C x⁴ ys²] zs²]}}: 155 --->
//│ 	[C h¹ t¹]: 126
//│ case break₀((fun x⁶ -> (x⁶ == 1)), s'¹) of {P w¹ s''¹ => [C w¹ words₀(s''¹)]}: 184 --->
//│ 	[P [N] [N]]: 134
//│ 	[P [N] [C x⁴ xs²]]: 142
//│ 	[P [C x⁴ ys²] zs²]: 152
//│ case dropWhile₀((fun x⁵ -> (x⁵ == 1)), s¹) of {N  => [N] | s'¹ => case break₀((fun x⁶ -> (x⁶ == 1)), s'¹) of {P w¹ s''¹ => [C w¹ words₀(s''¹)]}}: 185 --->
//│ 	[N]: 115
//│ 	[C h¹ t¹]: 126
//│ case break1₀(p³, xs³) of {P ys³ zs³ => [P [C x⁷ ys³] zs³]}: 209 --->
//│ 	[P [N] [N]]: 190
//│ 	[P [N] [C x⁷ xs³]]: 198
//│ 	[P [C x⁷ ys³] zs³]: 208
//│ case ls⁵ of {N  => [P [N] [N]] | C x⁷ xs³ => if p³(x⁷) then [P [N] [C x⁷ xs³]] else case break1₀(p³, xs³) of {P ys³ zs³ => [P [C x⁷ ys³] zs³]}}: 211 --->
//│ 	[N]: 220
//│ 	[C 2 [N]]: 221
//│ 	[C 1 [C 2 [N]]]: 222
//│ 	[C 2 [C 1 [C 2 [N]]]]: 223
//│ 	[C 1 [C 2 [C 1 [C 2 [N]]]]]: 224
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [P [N] [N]]: 134 --->
//│ 	case break₀((fun x⁶ -> (x⁶ == 1)), s'¹) of {P w¹ s''¹ => [C w¹ words₀(s''¹)]}: 184
//│ [P [N] [C x⁴ xs²]]: 142 --->
//│ 	case break₀((fun x⁶ -> (x⁶ == 1)), s'¹) of {P w¹ s''¹ => [C w¹ words₀(s''¹)]}: 184
//│ [P [C x⁴ ys²] zs²]: 152 --->
//│ 	case break₀((fun x⁶ -> (x⁶ == 1)), s'¹) of {P w¹ s''¹ => [C w¹ words₀(s''¹)]}: 184
//│ ------------------
//│ case break₀((fun x⁶ -> (x⁶ == 1)), s'¹) of {P w¹ s''¹ => [C w¹ words₀(s''¹)]}: 184 --->
//│ 	[P [N] [N]]: 134
//│ 	[P [N] [C x⁴ xs²]]: 142
//│ 	[P [C x⁴ ys²] zs²]: 152
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ words₀([C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]])
//│ def words₀(s²) = 
//│ 	case dropWhile₀((fun x⁸ -> (x⁸ == 1)), s²) of {
//│ 		N  => [N]
//│ 		| s'¹ => break₀((fun x⁹ -> (x⁹ == 1)), s'¹, 99)}
//│ 	where
//│ 	def break₀(p⁴, ls⁷) = 
//│ 		case ls⁷ of {
//│ 			N  => 
//│ 				let s''² = [N]
//│ 				in let w² = [N]
//│ 				in (fun _lh_dummy⁰ -> [C w² words₀(s''²)])
//│ 			| C x⁴ xs² => if p⁴(x⁴) then 
//│ 				let s''³ = [C x⁴ xs²]
//│ 				in let w³ = [N]
//│ 				in (fun _lh_dummy¹ -> [C w³ words₀(s''³)]) else case break1₀(p⁴, xs²) of {
//│ 				P ys² zs² => 
//│ 					let s''⁴ = zs²
//│ 					in let w⁴ = [C x⁴ ys²]
//│ 					in (fun _lh_dummy² -> [C w⁴ words₀(s''⁴)])}}
//│ 		where
//│ 		def break1₀(p⁵, ls⁸) = 
//│ 			case ls⁸ of {
//│ 				N  => [P [N] [N]]
//│ 				| C x⁷ xs³ => if p⁵(x⁷) then [P [N] [C x⁷ xs³]] else case break1₀(p⁵, xs³) of {
//│ 					P ys³ zs³ => [P [C x⁷ ys³] zs³]}}
//│ 	def dropWhile₀(f², ls⁶) = 
//│ 		case ls⁶ of {
//│ 			N  => [N]
//│ 			| C h¹ t¹ => if f²(h¹) then dropWhile₀(f², t¹) else [C h¹ t¹]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ words₀ :: 'words₀ <: [C(Int, C(Int, C(Int, C(Int, C(Int, N))))) => '13_callres | 's''⁰ => '37_callres | 's''¹ => '52_callres | 's''² => '69_callres] ::: false
//│ 2 :: Int ::: false
//│ 1 :: Int ::: false
//│ 2 :: Int ::: false
//│ 1 :: Int ::: false
//│ 2 :: Int ::: false
//│ [N] :: N ::: true
//│ [C 2 [N]] :: C(Int, N) ::: true
//│ [C 1 [C 2 [N]]] :: C(Int, C(Int, N)) ::: true
//│ [C 2 [C 1 [C 2 [N]]]] :: C(Int, C(Int, C(Int, N))) ::: true
//│ [C 1 [C 2 [C 1 [C 2 [N]]]]] :: C(Int, C(Int, C(Int, C(Int, N)))) ::: true
//│ [C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]] :: C(Int, C(Int, C(Int, C(Int, C(Int, N))))) ::: true
//│ words₀([C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]]) :: '13_callres <: [NoCons] ::: false
//│ ls :: 'ls⁰ <: [Destruct(N, C('h⁰, 't⁰))] ::: false
//│ [N] :: N ::: true
//│ f :: 'f⁰ <: ['h⁰ => '18_callres] ::: false
//│ h :: 'h⁰ <: ['x¹ | 'x⁰] ::: false
//│ f(h) :: '18_callres <: [Destruct(True, False)] ::: false
//│ dropWhile₀ :: 'dropWhile₀ <: ['f⁰ => '21_callres | 'x¹ => '84_callres => '86_callres] ::: false
//│ f :: 'f⁰ <: ['h⁰ => '18_callres] ::: false
//│ dropWhile₀(f) :: '21_callres <: ['t⁰ => '23_callres] ::: false
//│ t :: 't⁰ <: ['ls⁰ | 'xs⁰] ::: false
//│ dropWhile₀(f, t) :: '23_callres <: ['27_ifres] ::: false
//│ h :: 'h⁰ <: ['x¹ | 'x⁰] ::: false
//│ t :: 't⁰ <: ['ls⁰ | 'xs⁰] ::: false
//│ [C h t] :: C('h⁰, 't⁰) ::: true
//│ if f(h) then dropWhile₀(f, t) else [C h t] :: '27_ifres <: ['28_matchres] ::: false
//│ case ls of {N  => [N] | C h t => if f(h) then dropWhile₀(f, t) else [C h t]} :: '28_matchres <: ['23_callres | '88_callres] ::: false
//│ (fun ls -> case ls of {N  => [N] | C h t => if f(h) then dropWhile₀(f, t) else [C h t]}) :: 'ls⁰ => '28_matchres ::: true
//│ (fun f -> (fun ls -> case ls of {N  => [N] | C h t => if f(h) then dropWhile₀(f, t) else [C h t]})) :: 'f⁰ => 'ls⁰ => '28_matchres ::: true
//│ ls :: 'ls¹ <: [Destruct(N, C('x⁰, 'xs⁰))] ::: false
//│ [N] :: N ::: true
//│ [N] :: N ::: true
//│ w :: 'w⁰ <: [NoCons] ::: false
//│ words₀ :: 'words₀ <: [C(Int, C(Int, C(Int, C(Int, C(Int, N))))) => '13_callres | 's''⁰ => '37_callres | 's''¹ => '52_callres | 's''² => '69_callres] ::: false
//│ s'' :: 's''⁰ <: ['s⁰] ::: false
//│ words₀(s'') :: '37_callres <: [NoCons] ::: false
//│ [C w words₀(s'')] :: C('w⁰, '37_callres) ::: true
//│ (fun _lh_dummy -> [C w words₀(s'')]) :: '_lh_dummy⁰ => C('w⁰, '37_callres) ::: true
//│ let w = [N]
//│ in (fun _lh_dummy -> [C w words₀(s'')]) :: '_lh_dummy⁰ => C('w⁰, '37_callres) ::: true
//│ let s'' = [N]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words₀(s'')]) :: '_lh_dummy⁰ => C('w⁰, '37_callres) ::: true
//│ p :: 'p⁰ <: ['x⁰ => '44_callres | 'p¹] ::: false
//│ x :: 'x⁰ <: [NoCons | 'h⁰ | 'x²] ::: false
//│ p(x) :: '44_callres <: [Destruct(True, False)] ::: false
//│ x :: 'x⁰ <: [NoCons | 'h⁰ | 'x²] ::: false
//│ xs :: 'xs⁰ <: ['t⁰ | 'ls²] ::: false
//│ [C x xs] :: C('x⁰, 'xs⁰) ::: true
//│ [N] :: N ::: true
//│ w :: 'w¹ <: [NoCons] ::: false
//│ words₀ :: 'words₀ <: [C(Int, C(Int, C(Int, C(Int, C(Int, N))))) => '13_callres | 's''⁰ => '37_callres | 's''¹ => '52_callres | 's''² => '69_callres] ::: false
//│ s'' :: 's''¹ <: ['s⁰] ::: false
//│ words₀(s'') :: '52_callres <: [NoCons] ::: false
//│ [C w words₀(s'')] :: C('w¹, '52_callres) ::: true
//│ (fun _lh_dummy -> [C w words₀(s'')]) :: '_lh_dummy¹ => C('w¹, '52_callres) ::: true
//│ let w = [N]
//│ in (fun _lh_dummy -> [C w words₀(s'')]) :: '_lh_dummy¹ => C('w¹, '52_callres) ::: true
//│ let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words₀(s'')]) :: '_lh_dummy¹ => C('w¹, '52_callres) ::: true
//│ break1₀ :: 'break1₀ <: ['p⁰ => '59_callres | 'p¹ => '118_callres] ::: false
//│ p :: 'p⁰ <: ['x⁰ => '44_callres | 'p¹] ::: false
//│ break1₀(p) :: '59_callres <: ['xs⁰ => '61_callres] ::: false
//│ xs :: 'xs⁰ <: ['t⁰ | 'ls²] ::: false
//│ break1₀(p, xs) :: '61_callres <: [Destruct(P('ys⁰, 'zs⁰))] ::: false
//│ zs :: 'zs⁰ <: ['s''²] ::: false
//│ x :: 'x⁰ <: [NoCons | 'h⁰ | 'x²] ::: false
//│ ys :: 'ys⁰ <: [NoCons] ::: false
//│ [C x ys] :: C('x⁰, 'ys⁰) ::: true
//│ w :: 'w² <: [NoCons] ::: false
//│ words₀ :: 'words₀ <: [C(Int, C(Int, C(Int, C(Int, C(Int, N))))) => '13_callres | 's''⁰ => '37_callres | 's''¹ => '52_callres | 's''² => '69_callres] ::: false
//│ s'' :: 's''² <: ['s⁰] ::: false
//│ words₀(s'') :: '69_callres <: [NoCons] ::: false
//│ [C w words₀(s'')] :: C('w², '69_callres) ::: true
//│ (fun _lh_dummy -> [C w words₀(s'')]) :: '_lh_dummy² => C('w², '69_callres) ::: true
//│ let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words₀(s'')]) :: '_lh_dummy² => C('w², '69_callres) ::: true
//│ let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words₀(s'')]) :: '_lh_dummy² => C('w², '69_callres) ::: true
//│ case break1₀(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words₀(s'')])} :: '74_matchres <: ['75_ifres] ::: false
//│ if p(x) then let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words₀(s'')]) else case break1₀(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words₀(s'')])} :: '75_ifres <: ['76_matchres] ::: false
//│ case ls of {N  => let s'' = [N]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words₀(s'')]) | C x xs => if p(x) then let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words₀(s'')]) else case break1₀(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words₀(s'')])}} :: '76_matchres <: ['99_callres] ::: false
//│ (fun ls -> case ls of {N  => let s'' = [N]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words₀(s'')]) | C x xs => if p(x) then let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words₀(s'')]) else case break1₀(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words₀(s'')])}}) :: 'ls¹ => '76_matchres ::: true
//│ (fun p -> (fun ls -> case ls of {N  => let s'' = [N]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words₀(s'')]) | C x xs => if p(x) then let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words₀(s'')]) else case break1₀(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words₀(s'')])}})) :: 'p⁰ => 'ls¹ => '76_matchres ::: true
//│ dropWhile₀ :: 'dropWhile₀ <: ['f⁰ => '21_callres | 'x¹ => '84_callres => '86_callres] ::: false
//│ == :: Destruct(Int) => Destruct(Int) => Sum[True, False] ::: true
//│ x :: 'x¹ <: [Destruct(Int)] ::: false
//│ ==(x) :: '82_callres <: [Int => '84_callres] ::: false
//│ 1 :: Int ::: false
//│ (x == 1) :: '84_callres <: ['18_callres] ::: false
//│ (fun x -> (x == 1)) :: 'x¹ => '84_callres ::: true
//│ dropWhile₀((fun x -> (x == 1))) :: '86_callres <: ['s⁰ => '88_callres] ::: false
//│ s :: 's⁰ <: ['ls⁰] ::: false
//│ dropWhile₀((fun x -> (x == 1)), s) :: '88_callres <: [Destruct(N, _('s'⁰))] ::: false
//│ [N] :: N ::: true
//│ break₀ :: 'break₀ <: ['x² => '95_callres => '97_callres] ::: false
//│ == :: Destruct(Int) => Destruct(Int) => Sum[True, False] ::: true
//│ x :: 'x² <: [Destruct(Int)] ::: false
//│ ==(x) :: '93_callres <: [Int => '95_callres] ::: false
//│ 1 :: Int ::: false
//│ (x == 1) :: '95_callres <: ['44_callres | '110_callres] ::: false
//│ (fun x -> (x == 1)) :: 'x² => '95_callres ::: true
//│ break₀((fun x -> (x == 1))) :: '97_callres <: ['s'⁰ => '99_callres] ::: false
//│ s' :: 's'⁰ <: ['ls¹] ::: false
//│ break₀((fun x -> (x == 1)), s') :: '99_callres <: [Int => '101_callres] ::: false
//│ 99 :: Int ::: false
//│ break₀((fun x -> (x == 1)), s', 99) :: '101_callres <: ['102_matchres] ::: false
//│ case dropWhile₀((fun x -> (x == 1)), s) of {N  => [N] | s' => break₀((fun x -> (x == 1)), s', 99)} :: '102_matchres <: ['13_callres | '37_callres | '52_callres | '69_callres] ::: false
//│ (fun s -> case dropWhile₀((fun x -> (x == 1)), s) of {N  => [N] | s' => break₀((fun x -> (x == 1)), s', 99)}) :: 's⁰ => '102_matchres ::: true
//│ ls :: 'ls² <: [Destruct(N, C('x³, 'xs¹))] ::: false
//│ [N] :: N ::: true
//│ [N] :: N ::: true
//│ [P [N] [N]] :: P(N, N) ::: true
//│ p :: 'p¹ <: ['x³ => '110_callres] ::: false
//│ x :: 'x³ <: [NoCons | 'h⁰ | 'x²] ::: false
//│ p(x) :: '110_callres <: [Destruct(True, False)] ::: false
//│ [N] :: N ::: true
//│ x :: 'x³ <: [NoCons | 'h⁰ | 'x²] ::: false
//│ xs :: 'xs¹ <: ['t⁰ | 'ls²] ::: false
//│ [C x xs] :: C('x³, 'xs¹) ::: true
//│ [P [N] [C x xs]] :: P(N, C('x³, 'xs¹)) ::: true
//│ break1₀ :: 'break1₀ <: ['p⁰ => '59_callres | 'p¹ => '118_callres] ::: false
//│ p :: 'p¹ <: ['x³ => '110_callres] ::: false
//│ break1₀(p) :: '118_callres <: ['xs¹ => '120_callres] ::: false
//│ xs :: 'xs¹ <: ['t⁰ | 'ls²] ::: false
//│ break1₀(p, xs) :: '120_callres <: [Destruct(P('ys¹, 'zs¹))] ::: false
//│ x :: 'x³ <: [NoCons | 'h⁰ | 'x²] ::: false
//│ ys :: 'ys¹ <: [NoCons] ::: false
//│ [C x ys] :: C('x³, 'ys¹) ::: true
//│ zs :: 'zs¹ <: ['zs⁰] ::: false
//│ [P [C x ys] zs] :: P(C('x³, 'ys¹), 'zs¹) ::: true
//│ case break1₀(p, xs) of {P ys zs => [P [C x ys] zs]} :: '126_matchres <: ['127_ifres] ::: false
//│ if p(x) then [P [N] [C x xs]] else case break1₀(p, xs) of {P ys zs => [P [C x ys] zs]} :: '127_ifres <: ['128_matchres] ::: false
//│ case ls of {N  => [P [N] [N]] | C x xs => if p(x) then [P [N] [C x xs]] else case break1₀(p, xs) of {P ys zs => [P [C x ys] zs]}} :: '128_matchres <: ['61_callres | '120_callres] ::: false
//│ (fun ls -> case ls of {N  => [P [N] [N]] | C x xs => if p(x) then [P [N] [C x xs]] else case break1₀(p, xs) of {P ys zs => [P [C x ys] zs]}}) :: 'ls² => '128_matchres ::: true
//│ (fun p -> (fun ls -> case ls of {N  => [P [N] [N]] | C x xs => if p(x) then [P [N] [C x xs]] else case break1₀(p, xs) of {P ys zs => [P [C x ys] zs]}})) :: 'p¹ => 'ls² => '128_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec break1_d0 p_1 ls_2 =
//│   (match ls_2 with
//│     | `N -> 
//│       (`P((`N), (`N)))
//│     | `C(x_3, xs_1) -> 
//│       (if (p_1 x_3) then
//│         (`P((`N), (`C(x_3, xs_1))))
//│       else
//│         (match ((break1_d0 p_1) xs_1) with
//│           | `P(ys_1, zs_1) -> 
//│             (`P((`C(x_3, ys_1)), zs_1)))))
//│ and break_d0 p_0 ls_1 =
//│   (match ls_1 with
//│     | `N -> 
//│       (let rec s''_0 = (`N) in
//│         (let rec w_0 = (`N) in
//│           (fun _lh_dummy_0 -> 
//│             (`C(w_0, (words_d0 s''_0))))))
//│     | `C(x_0, xs_0) -> 
//│       (if (p_0 x_0) then
//│         (let rec s''_1 = (`C(x_0, xs_0)) in
//│           (let rec w_1 = (`N) in
//│             (fun _lh_dummy_1 -> 
//│               (`C(w_1, (words_d0 s''_1))))))
//│       else
//│         (match ((break1_d0 p_0) xs_0) with
//│           | `P(ys_0, zs_0) -> 
//│             (let rec s''_2 = zs_0 in
//│               (let rec w_2 = (`C(x_0, ys_0)) in
//│                 (fun _lh_dummy_2 -> 
//│                   (`C(w_2, (words_d0 s''_2)))))))))
//│ and dropWhile_d0 f_0 ls_0 =
//│   (match ls_0 with
//│     | `N -> 
//│       (`N)
//│     | `C(h_0, t_0) -> 
//│       (if (f_0 h_0) then
//│         ((dropWhile_d0 f_0) t_0)
//│       else
//│         (`C(h_0, t_0))))
//│ and words_d0 s_0 =
//│   (match ((dropWhile_d0 (fun x_1 -> 
//│     (x_1 = 1))) s_0) with
//│     | `N -> 
//│       (`N)
//│     | s'_0 -> 
//│       (((break_d0 (fun x_2 -> 
//│         (x_2 = 1))) s'_0) 99));;
//│ (words_d0 (`C(2, (`C(1, (`C(2, (`C(1, (`C(2, (`N))))))))))))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│   - : [> `C of [> `C of int * ([> `C of int * 'b | `N ] as 'b) | `N ] * 'a | `N
//│     ] as 'a
//│ = `C (`C (2, `N), `C (`C (2, `N), `C (`C (2, `N), `N)))
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

