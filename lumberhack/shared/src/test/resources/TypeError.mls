:NewParser
:ParseOnly

_LUMBERHACK_EVAL
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
inter(N)(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|inter|(|N|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; inter (N,) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^14([N], [N])
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [N]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 15 --->
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [N]: 17 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12 --->
//│ 	DeadCodeProd
//│ 	[N]: 15
//│ 	[N]: 17
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter([N], [N])
//│ def inter(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ inter(ys³, t⁰)])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [N]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ inter([N], [N])
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ inter([N], [N])
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ <<<<<<< after floating out <<<<<<<


_LUMBERHACK_EVAL
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, N))
let l2 = C(9, C(10, N))
inter(l1)(l2)
//│ |_LUMBERHACK_EVAL|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#let| |l2| |#=| |C|(|9|,| |C|(|10|,| |N|)|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, N,),); let l2 = C (9, C (10, N,),); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^24(l1^25, l2^27)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [C 9 [C 10 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 9 [C 2 [C 10 [N]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 16 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 2 [N]]: 17 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 1 [C 2 [N]]]: 18 --->
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [N]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 10 [N]]: 22 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 9 [C 10 [N]]]: 23 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12 --->
//│ 	[N]: 16
//│ 	[C 2 [N]]: 17
//│ 	[C 1 [C 2 [N]]]: 18
//│ 	[N]: 21
//│ 	[C 10 [N]]: 22
//│ 	[C 9 [C 10 [N]]]: 23
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ inter(ys³, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [C 9 [C 10 [N]]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 9 [C 2 [C 10 [N]]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [C 9 [C 10 [N]]]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [C 9 [C 10 [N]]]
//│ <<<<<<< after floating out <<<<<<<

fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, l1))
let l2 = C(9, l2)
inter(l1)(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |l1|)|)|↵|#let| |l2| |#=| |C|(|9|,| |l2|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, l1,),); let l2 = C (9, l2,); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^22(l1^23, l2^25)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 l1^16]]
//│ def l2 = [C 9 l2^20]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 2 l1]: 17 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 1 [C 2 l1]]: 18 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 9 l2]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12 --->
//│ 	[C 2 l1]: 17
//│ 	[C 1 [C 2 l1]]: 18
//│ 	[C 9 l2]: 21
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ inter(ys³, t⁰)])}
//│ def l1 = [C 1 [C 2 l1]]
//│ def l2 = [C 9 l2]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 l1]]
//│ def l2 = [C 9 l2]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 l1]]
//│ def l2 = [C 9 l2]
//│ <<<<<<< after floating out <<<<<<<


// NOTE: maybe more fusion can be done
fun f(x) = if x is
  C(a) then
    if a is
      A then N
      B then g(D(a))
fun g(y) = if y is
  D(b) then
    if b is
      A then N
      B then f(C(b))
f(C(A))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then|→|#if| |a| |is|→|A| |#then| |N|↵|B| |#then| |g|(|D|(|a|)|)|←|←|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|D|(|b|)| |#then|→|#if| |b| |is|→|A| |#then| |N|↵|B| |#then| |f|(|C|(|b|)|)|←|←|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then {if a is ‹(A) then N; (B) then g (D (a,),)›}›; fun g = y, => if y is ‹(D (b,)) then {if b is ‹(A) then N; (B) then f (C (b,),)›}›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^21([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		A  => [N]
//│ 		| B  => g^4([D a⁰])}}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => case b⁰ of {
//│ 		A  => [N]
//│ 		| B  => f^14([C b⁰])}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [D a⁰]: 6 --->
//│ 	case y⁰ of {D b⁰ => case b⁰ of {A  => [N] | B  => f([C b⁰])}}: 19
//│ [C b⁰]: 16 --->
//│ 	case x⁰ of {C a⁰ => case a⁰ of {A  => [N] | B  => g([D a⁰])}}: 9
//│ [A]: 22 --->
//│ 	case a⁰ of {A  => [N] | B  => g([D a⁰])}: 8
//│ 	case b⁰ of {A  => [N] | B  => f([C b⁰])}: 18
//│ [C [A]]: 23 --->
//│ 	case x⁰ of {C a⁰ => case a⁰ of {A  => [N] | B  => g([D a⁰])}}: 9
//│ ------------------
//│ case a⁰ of {A  => [N] | B  => g([D a⁰])}: 8 --->
//│ 	[A]: 22
//│ case x⁰ of {C a⁰ => case a⁰ of {A  => [N] | B  => g([D a⁰])}}: 9 --->
//│ 	[C b⁰]: 16
//│ 	[C [A]]: 23
//│ case b⁰ of {A  => [N] | B  => f([C b⁰])}: 18 --->
//│ 	[A]: 22
//│ case y⁰ of {D b⁰ => case b⁰ of {A  => [N] | B  => f([C b⁰])}}: 19 --->
//│ 	[D a⁰]: 6
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C [A]])
//│ def f(x¹) = case x¹ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		A  => [N]
//│ 		| B  => g([D a⁰])}}
//│ def g(y¹) = case y¹ of {
//│ 	D b⁰ => case b⁰ of {
//│ 		A  => [N]
//│ 		| B  => f([C b⁰])}}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		A  => [N]
//│ 		| B  => g([D a⁰])}}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => case b⁰ of {
//│ 		A  => [N]
//│ 		| B  => f([C b⁰])}}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		A  => [N]
//│ 		| B  => g([D a⁰])}}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => case b⁰ of {
//│ 		A  => [N]
//│ 		| B  => f([C b⁰])}}
//│ <<<<<<< after floating out <<<<<<<


// NOTE: problem resolved by thunking the computation inside the branch
fun c(x) = if x is
  C(a) then primitive(a) // print(a)
fun f(a) = if False then c(a) else Unit
f(C(A))
//│ |#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |primitive|(|a|)| |/* print(a)*/|←|↵|#fun| |f|(|a|)| |#=| |#if| |False| |#then| |c|(|a|)| |#else| |Unit|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun c = x, => if x is ‹(C (a,)) then primitive (a,)›; fun f = a, => if (False) then c (a,) else Unit; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^14([C [A]])
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => primitive⁰(a⁰)}
//│ def f(a¹) = if [False] then c^8(a¹) else [Unit]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 16 --->
//│ 	case x⁰ of {C a⁰ => primitive⁰(a⁰)}: 5
//│ ------------------
//│ case x⁰ of {C a⁰ => primitive⁰(a⁰)}: 5 --->
//│ 	[C [A]]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [A]]: 16 --->
//│ 	case x⁰ of {C a⁰ => primitive⁰(a⁰)}: 5
//│ ------------------
//│ case x⁰ of {C a⁰ => primitive⁰(a⁰)}: 5 --->
//│ 	[C [A]]: 16
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f(
//│ 	let a² = [A]
//│ 	in (fun _lh_dummy⁰ -> primitive⁰(a²)))
//│ def c(x¹) = x¹(99)
//│ def f(a³) = if [False] then c(a³) else [Unit]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ c
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f(
//│ 	let a⁰ = [A]
//│ 	in (fun _lh_dummy⁰ -> primitive⁰(a⁰)))
//│ def c(x⁰) = x⁰(99)
//│ def f(a¹) = if [False] then a¹(99) else [Unit]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f(
//│ 	let a⁰ = [A]
//│ 	in (fun _lh_dummy⁰ -> primitive⁰(a⁰)))
//│ def c(x⁰) = x⁰(99)
//│ def f(a¹) = if [False] then a¹(99) else [Unit]
//│ <<<<<<< after floating out <<<<<<<


fun f(xs, ys) = if xs is
  N then 0
  _ then if xs is
    C(h, t) then if ys is
      C(hh, yt) then h + hh
      _ then h
    _ then error
f(C(1, N), C(2, N))
//│ |#fun| |f|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |0|↵|_| |#then| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |ys| |is|→|C|(|hh|,| |yt|)| |#then| |h| |+| |hh|↵|_| |#then| |h|←|↵|_| |#then| |error|←|←|↵|f|(|C|(|1|,| |N|)|,| |C|(|2|,| |N|)|)|
//│ Parsed: {fun f = xs, ys, => if xs is ‹(N) then 0; (_) then if xs is ‹(C (h, t,)) then if ys is ‹(C (hh, yt,)) then + (h,) (hh,); (_) then h›; (_) then error››; f (C (1, N,), C (2, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^17([C 1 [N]], [C 2 [N]])
//│ def f(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h⁰ t⁰ => case ys⁰ of {
//│ 			C hh⁰ yt⁰ => (h⁰ + hh⁰)
//│ 			| _  => h⁰}
//│ 		| _  => error⁰}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 20 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰} | _  => error⁰}: 13
//│ 	case xs⁰ of {N  => 0 | _  => case xs⁰ of {C h⁰ t⁰ => case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰} | _  => error⁰}}: 14
//│ [C 2 [N]]: 24 --->
//│ 	case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰}: 11
//│ ------------------
//│ case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰}: 11 --->
//│ 	[C 2 [N]]: 24
//│ case xs⁰ of {C h⁰ t⁰ => case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰} | _  => error⁰}: 13 --->
//│ 	[C 1 [N]]: 20
//│ case xs⁰ of {N  => 0 | _  => case xs⁰ of {C h⁰ t⁰ => case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰} | _  => error⁰}}: 14 --->
//│ 	[C 1 [N]]: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 2 [N]]: 24 --->
//│ 	case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰}: 11
//│ ------------------
//│ case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰}: 11 --->
//│ 	[C 2 [N]]: 24
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C 1 [N]], 
//│ 	let hh¹ = 2
//│ 	in (fun h¹ -> (h¹ + hh¹)))
//│ def f(xs¹, ys¹) = case xs¹ of {
//│ 	N  => 0
//│ 	| _  => case xs¹ of {
//│ 		C h⁰ t⁰ => ys¹(h⁰)
//│ 		| _  => error⁰}}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ f
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ case [C 1 [N]] of {
//│ 	N  => 0
//│ 	| _  => case [C 1 [N]] of {
//│ 		C h⁰ t⁰ => 
//│ 			let hh⁰ = 2
//│ 			in (fun h¹ -> (h¹ + hh⁰))(h⁰)
//│ 		| _  => error⁰}}
//│ def f(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h² t¹ => ys⁰(h²)
//│ 		| _  => error⁰}}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ case [C 1 [N]] of {
//│ 	N  => 0
//│ 	| _  => case [C 1 [N]] of {
//│ 		C h⁰ t⁰ => 
//│ 			let hh⁰ = 2
//│ 			in (fun h¹ -> (h¹ + hh⁰))(h⁰)
//│ 		| _  => error⁰}}
//│ def f(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h² t¹ => ys⁰(h²)
//│ 		| _  => error⁰}}
//│ <<<<<<< after floating out <<<<<<<


fun f(xs) = if xs is
  N then 0
  _ then if xs is
    C(h, t) then h
    _ then error("match error")
f(C(1, N))
//│ |#fun| |f|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |0|↵|_| |#then| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |h|↵|_| |#then| |error|(|"match error"|)|←|←|↵|f|(|C|(|1|,| |N|)|)|
//│ Parsed: {fun f = xs, => if xs is ‹(N) then 0; (_) then if xs is ‹(C (h, t,)) then h; (_) then error ("match error",)››; f (C (1, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^33([C 1 [N]])
//│ def f(xs⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h⁰ t⁰ => h⁰
//│ 		| _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 36 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => h⁰ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}: 30
//│ 	case xs⁰ of {N  => 0 | _  => case xs⁰ of {C h⁰ t⁰ => h⁰ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}: 31
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => h⁰ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}: 30 --->
//│ 	[C 1 [N]]: 36
//│ case xs⁰ of {N  => 0 | _  => case xs⁰ of {C h⁰ t⁰ => h⁰ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}: 31 --->
//│ 	[C 1 [N]]: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C 1 [N]])
//│ def f(xs¹) = case xs¹ of {
//│ 	N  => 0
//│ 	| _  => case xs¹ of {
//│ 		C h⁰ t⁰ => h⁰
//│ 		| _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f([C 1 [N]])
//│ def f(xs⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h⁰ t⁰ => h⁰
//│ 		| _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f([C 1 [N]])
//│ def f(xs⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h⁰ t⁰ => h⁰
//│ 		| _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}
//│ <<<<<<< after floating out <<<<<<<


fun f(x, y) = if x is
  N then y
  _ then y + 1
f(C(1, N), 0)
//│ |#fun| |f|(|x|,| |y|)| |#=| |#if| |x| |is|→|N| |#then| |y|↵|_| |#then| |y| |+| |1|←|↵|f|(|C|(|1|,| |N|)|,| |0|)|
//│ Parsed: {fun f = x, y, => if x is ‹(N) then y; (_) then + (y,) (1,)›; f (C (1, N,), 0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^11([C 1 [N]], 0)
//│ def f(x⁰, y⁰) = case x⁰ of {
//│ 	N  => y⁰
//│ 	| _  => (y⁰ + 1)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 14 --->
//│ 	case x⁰ of {N  => y⁰ | _  => (y⁰ + 1)}: 8
//│ ------------------
//│ case x⁰ of {N  => y⁰ | _  => (y⁰ + 1)}: 8 --->
//│ 	[C 1 [N]]: 14
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 [N]]: 14 --->
//│ 	case x⁰ of {N  => y⁰ | _  => (y⁰ + 1)}: 8
//│ ------------------
//│ case x⁰ of {N  => y⁰ | _  => (y⁰ + 1)}: 8 --->
//│ 	[C 1 [N]]: 14
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f((fun y¹ -> (y¹ + 1)), 0)
//│ def f(x¹, y²) = x¹(y²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ f
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ (fun y⁰ -> (y⁰ + 1))(0)
//│ def f(x⁰, y¹) = x⁰(y¹)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ (fun y⁰ -> (y⁰ + 1))(0)
//│ def f(x⁰, y¹) = x⁰(y¹)
//│ <<<<<<< after floating out <<<<<<<


// NOTE: after registering wildcard and id match, no type error
fun zip(xs, ys) = if xs is
  N then N
  _ then if ys is
    N then N
    _ then if xs is
      C(xs, xt) then if ys is
        C(ys, yt) then C(P2(xs, ys), zip(xt, yt))
        _ then N
      _ then N
zip(C(1,N), C(2,N))
//│ |#fun| |zip|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |N|↵|_| |#then| |#if| |ys| |is|→|N| |#then| |N|↵|_| |#then| |#if| |xs| |is|→|C|(|xs|,| |xt|)| |#then| |#if| |ys| |is|→|C|(|ys|,| |yt|)| |#then| |C|(|P2|(|xs|,| |ys|)|,| |zip|(|xt|,| |yt|)|)|↵|_| |#then| |N|←|↵|_| |#then| |N|←|←|←|↵|zip|(|C|(|1|,|N|)|,| |C|(|2|,|N|)|)|
//│ Parsed: {fun zip = xs, ys, => if xs is ‹(N) then N; (_) then if ys is ‹(N) then N; (_) then if xs is ‹(C (xs, xt,)) then if ys is ‹(C (ys, yt,)) then C (P2 (xs, ys,), zip (xt, yt,),); (_) then N›; (_) then N›››; zip (C (1, N,), C (2, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ zip^24([C 1 [N]], [C 2 [N]])
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => [N]
//│ 	| _  => case ys⁰ of {
//│ 		N  => [N]
//│ 		| _  => case xs⁰ of {
//│ 			C xs¹ xt⁰ => case ys⁰ of {
//│ 				C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip^10(xt⁰, yt⁰)]
//│ 				| _  => [N]}
//│ 			| _  => [N]}}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 26 --->
//│ 	case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}: 19
//│ 	case xs⁰ of {N  => [N] | _  => case ys⁰ of {N  => [N] | _  => case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}}}: 21
//│ [C 1 [N]]: 27 --->
//│ 	case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}: 19
//│ 	case xs⁰ of {N  => [N] | _  => case ys⁰ of {N  => [N] | _  => case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}}}: 21
//│ [N]: 30 --->
//│ 	case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]}: 17
//│ 	case ys⁰ of {N  => [N] | _  => case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}}: 20
//│ [C 2 [N]]: 31 --->
//│ 	case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]}: 17
//│ 	case ys⁰ of {N  => [N] | _  => case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}}: 20
//│ ------------------
//│ case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]}: 17 --->
//│ 	[N]: 30
//│ 	[C 2 [N]]: 31
//│ case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}: 19 --->
//│ 	[N]: 26
//│ 	[C 1 [N]]: 27
//│ case ys⁰ of {N  => [N] | _  => case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}}: 20 --->
//│ 	[N]: 30
//│ 	[C 2 [N]]: 31
//│ case xs⁰ of {N  => [N] | _  => case ys⁰ of {N  => [N] | _  => case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}}}: 21 --->
//│ 	[N]: 26
//│ 	[C 1 [N]]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ zip([C 1 [N]], [C 2 [N]])
//│ def zip(xs², ys²) = case xs² of {
//│ 	N  => [N]
//│ 	| _  => case ys² of {
//│ 		N  => [N]
//│ 		| _  => case xs² of {
//│ 			C xs¹ xt⁰ => case ys² of {
//│ 				C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)]
//│ 				| _  => [N]}
//│ 			| _  => [N]}}}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ zip([C 1 [N]], [C 2 [N]])
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => [N]
//│ 	| _  => case ys⁰ of {
//│ 		N  => [N]
//│ 		| _  => case xs⁰ of {
//│ 			C xs¹ xt⁰ => case ys⁰ of {
//│ 				C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)]
//│ 				| _  => [N]}
//│ 			| _  => [N]}}}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ zip([C 1 [N]], [C 2 [N]])
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => [N]
//│ 	| _  => case ys⁰ of {
//│ 		N  => [N]
//│ 		| _  => case xs⁰ of {
//│ 			C xs¹ xt⁰ => case ys⁰ of {
//│ 				C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)]
//│ 				| _  => [N]}
//│ 			| _  => [N]}}}
//│ <<<<<<< after floating out <<<<<<<

// NOTE: type error: f x = x f cannot be well typed in haskell
fun f(x) =
  (
    if x is
      C(h, t) then ff => C(h, ff(t))
      N then ff => N
  )(f)
f(C(3, N))
//│ |#fun| |f|(|x|)| |#=|→|(|→|#if| |x| |is|→|C|(|h|,| |t|)| |#then| |ff| |=>| |C|(|h|,| |ff|(|t|)|)|↵|N| |#then| |ff| |=>| |N|←|←|↵|)|(|f|)|←|↵|f|(|C|(|3|,| |N|)|)|
//│ Parsed: {fun f = x, => {'(' if x is ‹(C (h, t,)) then ff, => C (h, ff (t,),); (N) then ff, => N›, ')' (f,)}; f (C (3, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^14([C 3 [N]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C h⁰ t⁰ => (fun ff⁰ -> [C h⁰ ff⁰(t⁰)])
//│ 	| N  => (fun ff¹ -> [N])}(f^11)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 16 --->
//│ 	case x⁰ of {C h⁰ t⁰ => (fun ff⁰ -> [C h⁰ ff⁰(t⁰)]) | N  => (fun ff¹ -> [N])}: 10
//│ [C 3 [N]]: 17 --->
//│ 	case x⁰ of {C h⁰ t⁰ => (fun ff⁰ -> [C h⁰ ff⁰(t⁰)]) | N  => (fun ff¹ -> [N])}: 10
//│ ------------------
//│ case x⁰ of {C h⁰ t⁰ => (fun ff⁰ -> [C h⁰ ff⁰(t⁰)]) | N  => (fun ff¹ -> [N])}: 10 --->
//│ 	DeadCodeProd
//│ 	[N]: 16
//│ 	[C 3 [N]]: 17
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C 3 [N]])
//│ def f(x¹) = case x¹ of {
//│ 	C h⁰ t⁰ => (fun ff² -> [C h⁰ ff²(t⁰)])
//│ 	| N  => (fun ff³ -> [N])}(f)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f([C 3 [N]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C h⁰ t⁰ => (fun ff⁰ -> [C h⁰ ff⁰(t⁰)])
//│ 	| N  => (fun ff¹ -> [N])}(f)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f([C 3 [N]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C h⁰ t⁰ => (fun ff⁰ -> [C h⁰ ff⁰(t⁰)])
//│ 	| N  => (fun ff¹ -> [N])}(f)
//│ <<<<<<< after floating out <<<<<<<

// a more minimal example requiring recursive type after fusion
fun f(x) =
  (
    if x is
      N then ff => 1
  )(f)
f(N)
//│ |#fun| |f|(|x|)| |#=|→|(|→|#if| |x| |is|→|N| |#then| |ff| |=>| |1|←|←|↵|)|(|f|)|←|↵|f|(|N|)|
//│ Parsed: {fun f = x, => {'(' if x is ‹(N) then ff, => 1›, ')' (f,)}; f (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^8([N])
//│ def f(x⁰) = case x⁰ of {
//│ 	N  => (fun ff⁰ -> 1)}(f^5)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 9 --->
//│ 	case x⁰ of {N  => (fun ff⁰ -> 1)}: 4
//│ ------------------
//│ case x⁰ of {N  => (fun ff⁰ -> 1)}: 4 --->
//│ 	DeadCodeProd
//│ 	[N]: 9
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([N])
//│ def f(x¹) = case x¹ of {
//│ 	N  => (fun ff¹ -> 1)}(f)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f([N])
//│ def f(x⁰) = case x⁰ of {
//│ 	N  => (fun ff⁰ -> 1)}(f)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f([N])
//│ def f(x⁰) = case x⁰ of {
//│ 	N  => (fun ff⁰ -> 1)}(f)
//│ <<<<<<< after floating out <<<<<<<


// FIXME: still have error even after eliminating dead branches and unused definitions, need more
// flow sensitive dead code elmination?
:lhInHaskell
:lhGenOCaml
:d
break p [] = ([], [])
break p (x:xs) = if p x then ([], (x:xs)) else case (break1 p xs) of { (ys, zs) -> ((x:ys), zs) }
break1 p [] = ([], [])
break1 p (x:xs) = if p x then ([], (x:xs)) else case (break1 p xs) of { (ys, zs) -> ((x:ys), zs) }
words s =  case (dropWhile (\x -> polyEq x ' ') s) of
          [] -> []
          s' -> case (break (\x -> polyEq x ' ') s') of (w, s'') -> (w : (words s''))
dropWhile f [] = []
dropWhile f (h:t) = if (f h) then dropWhile f t else (h:t)
words "1 2 4"
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ words_lh_₁^115([LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]])
//│ def break1_lh_₁(_lh_break1_arg1⁰, _lh_break1_arg2⁰) = case _lh_break1_arg2⁰ of {
//│ 	LH_N  => [LH_P2 [LH_N] [LH_N]]
//│ 	| LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰ => if _lh_break1_arg1⁰(_lh_break1_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]] else 
//│ 		let _lh_matchIdent⁰ = break1_lh_₁^13(_lh_break1_arg1⁰, _lh_break1_LH_C_1⁰)
//│ 		in case _lh_matchIdent⁰ of {
//│ 			LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰]
//│ 			| _  => error⁰}
//│ 	| _  => error⁰}
//│ def break_lh_₁(_lh_break_arg1⁰, _lh_break_arg2⁰) = case _lh_break_arg2⁰ of {
//│ 	LH_N  => [LH_P2 [LH_N] [LH_N]]
//│ 	| LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰ => if _lh_break_arg1⁰(_lh_break_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰]] else 
//│ 		let _lh_matchIdent¹ = break1_lh_₁^62(_lh_break_arg1⁰, _lh_break_LH_C_1⁰)
//│ 		in case _lh_matchIdent¹ of {
//│ 			LH_P2 _lh_break_LH_P2_0⁰ _lh_break_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰] _lh_break_LH_P2_1⁰]
//│ 			| _  => error⁰}
//│ 	| _  => error⁰}
//│ def dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_arg2⁰) = case _lh_dropWhile_arg2⁰ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁^37(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰]
//│ 	| _  => error⁰}
//│ def words_lh_₁(_lh_words_arg1⁰) = 
//│ 	let _lh_matchIdent² = dropWhile_lh_₁^81((fun x⁰ -> polyEq⁰(x⁰, ' ')), _lh_words_arg1⁰)
//│ 	in case _lh_matchIdent² of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => 
//│ 			let _lh_matchIdent³ = break_lh_₁^93((fun x¹ -> polyEq⁰(x¹, ' ')), _lh_matchIdent²)
//│ 			in case _lh_matchIdent³ of {
//│ 				LH_P2 _lh_words_LH_P2_0⁰ _lh_words_LH_P2_1⁰ => [LH_C _lh_words_LH_P2_0⁰ words_lh_₁^105(_lh_words_LH_P2_1⁰)]
//│ 				| _  => error⁰}}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec dropWhile_lh__d1 _lh_dropWhile_arg1_0 _lh_dropWhile_arg2_0 =
//│ 		  (match _lh_dropWhile_arg2_0 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_dropWhile_LH_C_0_0, _lh_dropWhile_LH_C_1_0) -> 
//│ 		      (if (_lh_dropWhile_arg1_0 _lh_dropWhile_LH_C_0_0) then
//│ 		        ((dropWhile_lh__d1 _lh_dropWhile_arg1_0) _lh_dropWhile_LH_C_1_0)
//│ 		      else
//│ 		        (`LH_C(_lh_dropWhile_LH_C_0_0, _lh_dropWhile_LH_C_1_0)))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec break1_lh__d1 _lh_break1_arg1_0 _lh_break1_arg2_0 =
//│ 		  (match _lh_break1_arg2_0 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_P2((`LH_N), (`LH_N)))
//│ 		    | `LH_C(_lh_break1_LH_C_0_0, _lh_break1_LH_C_1_0) -> 
//│ 		      (if (_lh_break1_arg1_0 _lh_break1_LH_C_0_0) then
//│ 		        (`LH_P2((`LH_N), (`LH_C(_lh_break1_LH_C_0_0, _lh_break1_LH_C_1_0))))
//│ 		      else
//│ 		        (let rec _lh_matchIdent_0 = ((break1_lh__d1 _lh_break1_arg1_0) _lh_break1_LH_C_1_0) in
//│ 		          (match _lh_matchIdent_0 with
//│ 		            | `LH_P2(_lh_break1_LH_P2_0_0, _lh_break1_LH_P2_1_0) -> 
//│ 		              (`LH_P2((`LH_C(_lh_break1_LH_C_0_0, _lh_break1_LH_P2_0_0)), _lh_break1_LH_P2_1_0))
//│ 		            | _ -> 
//│ 		              (failwith "error"))))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec break_lh__d1 _lh_break_arg1_0 _lh_break_arg2_0 =
//│ 		  (match _lh_break_arg2_0 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_P2((`LH_N), (`LH_N)))
//│ 		    | `LH_C(_lh_break_LH_C_0_0, _lh_break_LH_C_1_0) -> 
//│ 		      (if (_lh_break_arg1_0 _lh_break_LH_C_0_0) then
//│ 		        (`LH_P2((`LH_N), (`LH_C(_lh_break_LH_C_0_0, _lh_break_LH_C_1_0))))
//│ 		      else
//│ 		        (let rec _lh_matchIdent_1 = ((break1_lh__d1 _lh_break_arg1_0) _lh_break_LH_C_1_0) in
//│ 		          (match _lh_matchIdent_1 with
//│ 		            | `LH_P2(_lh_break_LH_P2_0_0, _lh_break_LH_P2_1_0) -> 
//│ 		              (`LH_P2((`LH_C(_lh_break_LH_C_0_0, _lh_break_LH_P2_0_0)), _lh_break_LH_P2_1_0))
//│ 		            | _ -> 
//│ 		              (failwith "error"))))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec words_lh__d1 _lh_words_arg1_0 =
//│ 		  (let rec _lh_matchIdent_2 = ((dropWhile_lh__d1 (fun x_0 -> 
//│ 		    (x_0 = ' '))) _lh_words_arg1_0) in
//│ 		    (match _lh_matchIdent_2 with
//│ 		      | `LH_N -> 
//│ 		        (`LH_N)
//│ 		      | _ -> 
//│ 		        (let rec _lh_matchIdent_3 = ((break_lh__d1 (fun x_1 -> 
//│ 		          (x_1 = ' '))) _lh_matchIdent_2) in
//│ 		          (match _lh_matchIdent_3 with
//│ 		            | `LH_P2(_lh_words_LH_P2_0_0, _lh_words_LH_P2_1_0) -> 
//│ 		              (`LH_C(_lh_words_LH_P2_0_0, (words_lh__d1 _lh_words_LH_P2_1_0)))
//│ 		            | _ -> 
//│ 		              (failwith "error")))));;
//│ 		(words_lh__d1 (`LH_C('1', (`LH_C(' ', (`LH_C('2', (`LH_C(' ', (`LH_C('4', (`LH_N))))))))))))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		                    val dropWhile_lh__d1 :
//│ 		  ('a -> bool) ->
//│ 		  ([> `LH_C of 'a * 'b | `LH_N ] as 'b) -> [> `LH_C of 'a * 'b | `LH_N ] =
//│ 		  <fun>
//│ 		[ok]
//│ 		                                val break1_lh__d1 :
//│ 		  ('a -> bool) ->
//│ 		  ([> `LH_C of 'a * 'b | `LH_N ] as 'b) ->
//│ 		  [> `LH_P2 of
//│ 		       ([> `LH_C of 'a * 'c | `LH_N ] as 'c) * [> `LH_C of 'a * 'b | `LH_N ]
//│ 		  ] = <fun>
//│ 		[ok]
//│ 		                                val break_lh__d1 :
//│ 		  ('a -> bool) ->
//│ 		  [> `LH_C of 'a * ([> `LH_C of 'a * 'b | `LH_N ] as 'b) | `LH_N ] ->
//│ 		  [> `LH_P2 of
//│ 		       [> `LH_C of 'a * ([> `LH_C of 'a * 'c | `LH_N ] as 'c) | `LH_N ] *
//│ 		       [> `LH_C of 'a * 'b | `LH_N ] ] =
//│ 		  <fun>
//│ 		[ok]
//│ 		                            val words_lh__d1 :
//│ 		  ([> `LH_C of char * 'a | `LH_N ] as 'a) ->
//│ 		  ([> `LH_C of
//│ 		        [> `LH_C of char * ([> `LH_C of char * 'c | `LH_N ] as 'c) | `LH_N ] *
//│ 		        'b
//│ 		    | `LH_N ]
//│ 		   as 'b) =
//│ 		  <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 3 --->
//│ 	case _lh_dropWhile_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰] | _  => error⁰}: 47
//│ [LH_P2 [LH_N] [LH_N]]: 4 --->
//│ 	case _lh_matchIdent⁰ of {LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰] | _  => error⁰}: 25
//│ 	case _lh_matchIdent¹ of {LH_P2 _lh_break_LH_P2_0⁰ _lh_break_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰] _lh_break_LH_P2_1⁰] | _  => error⁰}: 74
//│ [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]: 11 --->
//│ 	case _lh_dropWhile_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰] | _  => error⁰}: 47
//│ [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]]: 12 --->
//│ 	case _lh_matchIdent⁰ of {LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰] | _  => error⁰}: 25
//│ 	case _lh_matchIdent¹ of {LH_P2 _lh_break_LH_P2_0⁰ _lh_break_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰] _lh_break_LH_P2_1⁰] | _  => error⁰}: 74
//│ [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰]: 23 --->
//│ 	case _lh_matchIdent⁰ of {LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰] | _  => error⁰}: 25
//│ 	case _lh_matchIdent¹ of {LH_P2 _lh_break_LH_P2_0⁰ _lh_break_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰] _lh_break_LH_P2_1⁰] | _  => error⁰}: 74
//│ [LH_N]: 33 --->
//│ 	case _lh_break_arg2⁰ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰ => if _lh_break_arg1⁰(_lh_break_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰]] else let _lh_matchIdent¹ = break1_lh_₁(_lh_break_arg1⁰, _lh_break_LH_C_1⁰)
//│ in case _lh_matchIdent¹ of {LH_P2 _lh_break_LH_P2_0⁰ _lh_break_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰] _lh_break_LH_P2_1⁰] | _  => error⁰} | _  => error⁰}: 78
//│ 	case _lh_matchIdent² of {LH_N  => [LH_N] | _  => let _lh_matchIdent³ = break_lh_₁((fun x¹ -> polyEq⁰(x¹, ' ')), _lh_matchIdent²)
//│ in case _lh_matchIdent³ of {LH_P2 _lh_words_LH_P2_0⁰ _lh_words_LH_P2_1⁰ => [LH_C _lh_words_LH_P2_0⁰ words_lh_₁(_lh_words_LH_P2_1⁰)] | _  => error⁰}}: 112
//│ [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰]: 44 --->
//│ 	case _lh_break_arg2⁰ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰ => if _lh_break_arg1⁰(_lh_break_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰]] else let _lh_matchIdent¹ = break1_lh_₁(_lh_break_arg1⁰, _lh_break_LH_C_1⁰)
//│ in case _lh_matchIdent¹ of {LH_P2 _lh_break_LH_P2_0⁰ _lh_break_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰] _lh_break_LH_P2_1⁰] | _  => error⁰} | _  => error⁰}: 78
//│ 	case _lh_matchIdent² of {LH_N  => [LH_N] | _  => let _lh_matchIdent³ = break_lh_₁((fun x¹ -> polyEq⁰(x¹, ' ')), _lh_matchIdent²)
//│ in case _lh_matchIdent³ of {LH_P2 _lh_words_LH_P2_0⁰ _lh_words_LH_P2_1⁰ => [LH_C _lh_words_LH_P2_0⁰ words_lh_₁(_lh_words_LH_P2_1⁰)] | _  => error⁰}}: 112
//│ [LH_N]: 52 --->
//│ 	case _lh_dropWhile_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰] | _  => error⁰}: 47
//│ [LH_P2 [LH_N] [LH_N]]: 53 --->
//│ 	case _lh_matchIdent³ of {LH_P2 _lh_words_LH_P2_0⁰ _lh_words_LH_P2_1⁰ => [LH_C _lh_words_LH_P2_0⁰ words_lh_₁(_lh_words_LH_P2_1⁰)] | _  => error⁰}: 110
//│ [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰]: 60 --->
//│ 	case _lh_dropWhile_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰] | _  => error⁰}: 47
//│ [LH_P2 [LH_N] [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰]]: 61 --->
//│ 	case _lh_matchIdent³ of {LH_P2 _lh_words_LH_P2_0⁰ _lh_words_LH_P2_1⁰ => [LH_C _lh_words_LH_P2_0⁰ words_lh_₁(_lh_words_LH_P2_1⁰)] | _  => error⁰}: 110
//│ [LH_P2 [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰] _lh_break_LH_P2_1⁰]: 72 --->
//│ 	case _lh_matchIdent³ of {LH_P2 _lh_words_LH_P2_0⁰ _lh_words_LH_P2_1⁰ => [LH_C _lh_words_LH_P2_0⁰ words_lh_₁(_lh_words_LH_P2_1⁰)] | _  => error⁰}: 110
//│ [LH_N]: 121 --->
//│ 	case _lh_break1_arg2⁰ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰ => if _lh_break1_arg1⁰(_lh_break1_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]] else let _lh_matchIdent⁰ = break1_lh_₁(_lh_break1_arg1⁰, _lh_break1_LH_C_1⁰)
//│ in case _lh_matchIdent⁰ of {LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰] | _  => error⁰} | _  => error⁰}: 29
//│ 	case _lh_dropWhile_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰] | _  => error⁰}: 47
//│ [LH_C '4' [LH_N]]: 122 --->
//│ 	case _lh_break1_arg2⁰ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰ => if _lh_break1_arg1⁰(_lh_break1_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]] else let _lh_matchIdent⁰ = break1_lh_₁(_lh_break1_arg1⁰, _lh_break1_LH_C_1⁰)
//│ in case _lh_matchIdent⁰ of {LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰] | _  => error⁰} | _  => error⁰}: 29
//│ 	case _lh_dropWhile_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰] | _  => error⁰}: 47
//│ [LH_C ' ' [LH_C '4' [LH_N]]]: 123 --->
//│ 	case _lh_break1_arg2⁰ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰ => if _lh_break1_arg1⁰(_lh_break1_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]] else let _lh_matchIdent⁰ = break1_lh_₁(_lh_break1_arg1⁰, _lh_break1_LH_C_1⁰)
//│ in case _lh_matchIdent⁰ of {LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰] | _  => error⁰} | _  => error⁰}: 29
//│ 	case _lh_dropWhile_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰] | _  => error⁰}: 47
//│ [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]: 124 --->
//│ 	case _lh_break1_arg2⁰ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰ => if _lh_break1_arg1⁰(_lh_break1_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]] else let _lh_matchIdent⁰ = break1_lh_₁(_lh_break1_arg1⁰, _lh_break1_LH_C_1⁰)
//│ in case _lh_matchIdent⁰ of {LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰] | _  => error⁰} | _  => error⁰}: 29
//│ 	case _lh_dropWhile_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰] | _  => error⁰}: 47
//│ [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]: 125 --->
//│ 	case _lh_break1_arg2⁰ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰ => if _lh_break1_arg1⁰(_lh_break1_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]] else let _lh_matchIdent⁰ = break1_lh_₁(_lh_break1_arg1⁰, _lh_break1_LH_C_1⁰)
//│ in case _lh_matchIdent⁰ of {LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰] | _  => error⁰} | _  => error⁰}: 29
//│ 	case _lh_dropWhile_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰] | _  => error⁰}: 47
//│ [LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]]: 126 --->
//│ 	case _lh_dropWhile_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰] | _  => error⁰}: 47
//│ ------------------
//│ case _lh_matchIdent⁰ of {LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰] | _  => error⁰}: 25 --->
//│ 	[LH_P2 [LH_N] [LH_N]]: 4
//│ 	[LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]]: 12
//│ 	[LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰]: 23
//│ case _lh_break1_arg2⁰ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰ => if _lh_break1_arg1⁰(_lh_break1_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]] else let _lh_matchIdent⁰ = break1_lh_₁(_lh_break1_arg1⁰, _lh_break1_LH_C_1⁰)
//│ in case _lh_matchIdent⁰ of {LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰] | _  => error⁰} | _  => error⁰}: 29 --->
//│ 	[LH_N]: 121
//│ 	[LH_C '4' [LH_N]]: 122
//│ 	[LH_C ' ' [LH_C '4' [LH_N]]]: 123
//│ 	[LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]: 124
//│ 	[LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]: 125
//│ case _lh_dropWhile_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰] | _  => error⁰}: 47 --->
//│ 	[LH_N]: 3
//│ 	[LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]: 11
//│ 	[LH_N]: 52
//│ 	[LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰]: 60
//│ 	[LH_N]: 121
//│ 	[LH_C '4' [LH_N]]: 122
//│ 	[LH_C ' ' [LH_C '4' [LH_N]]]: 123
//│ 	[LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]: 124
//│ 	[LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]: 125
//│ 	[LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]]: 126
//│ case _lh_matchIdent¹ of {LH_P2 _lh_break_LH_P2_0⁰ _lh_break_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰] _lh_break_LH_P2_1⁰] | _  => error⁰}: 74 --->
//│ 	[LH_P2 [LH_N] [LH_N]]: 4
//│ 	[LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]]: 12
//│ 	[LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰]: 23
//│ case _lh_break_arg2⁰ of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰ => if _lh_break_arg1⁰(_lh_break_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰]] else let _lh_matchIdent¹ = break1_lh_₁(_lh_break_arg1⁰, _lh_break_LH_C_1⁰)
//│ in case _lh_matchIdent¹ of {LH_P2 _lh_break_LH_P2_0⁰ _lh_break_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰] _lh_break_LH_P2_1⁰] | _  => error⁰} | _  => error⁰}: 78 --->
//│ 	[LH_N]: 33
//│ 	[LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰]: 44
//│ case _lh_matchIdent³ of {LH_P2 _lh_words_LH_P2_0⁰ _lh_words_LH_P2_1⁰ => [LH_C _lh_words_LH_P2_0⁰ words_lh_₁(_lh_words_LH_P2_1⁰)] | _  => error⁰}: 110 --->
//│ 	[LH_P2 [LH_N] [LH_N]]: 53
//│ 	[LH_P2 [LH_N] [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰]]: 61
//│ 	[LH_P2 [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰] _lh_break_LH_P2_1⁰]: 72
//│ case _lh_matchIdent² of {LH_N  => [LH_N] | _  => let _lh_matchIdent³ = break_lh_₁((fun x¹ -> polyEq⁰(x¹, ' ')), _lh_matchIdent²)
//│ in case _lh_matchIdent³ of {LH_P2 _lh_words_LH_P2_0⁰ _lh_words_LH_P2_1⁰ => [LH_C _lh_words_LH_P2_0⁰ words_lh_₁(_lh_words_LH_P2_1⁰)] | _  => error⁰}}: 112 --->
//│ 	[LH_N]: 33
//│ 	[LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰]: 44
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_P2 [LH_N] [LH_N]]: 53 --->
//│ 	case _lh_matchIdent³ of {LH_P2 _lh_words_LH_P2_0⁰ _lh_words_LH_P2_1⁰ => [LH_C _lh_words_LH_P2_0⁰ words_lh_₁(_lh_words_LH_P2_1⁰)] | _  => error⁰}: 110
//│ [LH_P2 [LH_N] [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰]]: 61 --->
//│ 	case _lh_matchIdent³ of {LH_P2 _lh_words_LH_P2_0⁰ _lh_words_LH_P2_1⁰ => [LH_C _lh_words_LH_P2_0⁰ words_lh_₁(_lh_words_LH_P2_1⁰)] | _  => error⁰}: 110
//│ [LH_P2 [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰] _lh_break_LH_P2_1⁰]: 72 --->
//│ 	case _lh_matchIdent³ of {LH_P2 _lh_words_LH_P2_0⁰ _lh_words_LH_P2_1⁰ => [LH_C _lh_words_LH_P2_0⁰ words_lh_₁(_lh_words_LH_P2_1⁰)] | _  => error⁰}: 110
//│ ------------------
//│ case _lh_matchIdent³ of {LH_P2 _lh_words_LH_P2_0⁰ _lh_words_LH_P2_1⁰ => [LH_C _lh_words_LH_P2_0⁰ words_lh_₁(_lh_words_LH_P2_1⁰)] | _  => error⁰}: 110 --->
//│ 	[LH_P2 [LH_N] [LH_N]]: 53
//│ 	[LH_P2 [LH_N] [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰]]: 61
//│ 	[LH_P2 [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰] _lh_break_LH_P2_1⁰]: 72
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ words_lh_₁([LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]])
//│ def break1_lh_₁(_lh_break1_arg1¹, _lh_break1_arg2¹) = case _lh_break1_arg2¹ of {
//│ 	LH_N  => [LH_P2 [LH_N] [LH_N]]
//│ 	| LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰ => if _lh_break1_arg1¹(_lh_break1_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]] else 
//│ 		let _lh_matchIdent⁴ = break1_lh_₁(_lh_break1_arg1¹, _lh_break1_LH_C_1⁰)
//│ 		in case _lh_matchIdent⁴ of {
//│ 			LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰]
//│ 			| _  => error⁰}
//│ 	| _  => error⁰}
//│ def break_lh_₁(_lh_break_arg1¹, _lh_break_arg2¹) = case _lh_break_arg2¹ of {
//│ 	LH_N  => 
//│ 		let _lh_words_LH_P2_1¹ = [LH_N]
//│ 		in let _lh_words_LH_P2_0¹ = [LH_N]
//│ 		in (fun _lh_dummy⁰ -> [LH_C _lh_words_LH_P2_0¹ words_lh_₁(_lh_words_LH_P2_1¹)])
//│ 	| LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰ => if _lh_break_arg1¹(_lh_break_LH_C_0⁰) then 
//│ 		let _lh_words_LH_P2_1² = [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰]
//│ 		in let _lh_words_LH_P2_0² = [LH_N]
//│ 		in (fun _lh_dummy¹ -> [LH_C _lh_words_LH_P2_0² words_lh_₁(_lh_words_LH_P2_1²)]) else 
//│ 		let _lh_matchIdent⁵ = break1_lh_₁(_lh_break_arg1¹, _lh_break_LH_C_1⁰)
//│ 		in case _lh_matchIdent⁵ of {
//│ 			LH_P2 _lh_break_LH_P2_0⁰ _lh_break_LH_P2_1⁰ => 
//│ 				let _lh_words_LH_P2_1³ = _lh_break_LH_P2_1⁰
//│ 				in let _lh_words_LH_P2_0³ = [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰]
//│ 				in (fun _lh_dummy² -> [LH_C _lh_words_LH_P2_0³ words_lh_₁(_lh_words_LH_P2_1³)])
//│ 			| _  => error⁰}
//│ 	| _  => error⁰}
//│ def dropWhile_lh_₁(_lh_dropWhile_arg1¹, _lh_dropWhile_arg2¹) = case _lh_dropWhile_arg2¹ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1¹(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁(_lh_dropWhile_arg1¹, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰]
//│ 	| _  => error⁰}
//│ def words_lh_₁(_lh_words_arg1¹) = 
//│ 	let _lh_matchIdent⁶ = dropWhile_lh_₁((fun x² -> polyEq⁰(x², ' ')), _lh_words_arg1¹)
//│ 	in case _lh_matchIdent⁶ of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => 
//│ 			let _lh_matchIdent⁷ = break_lh_₁((fun x³ -> polyEq⁰(x³, ' ')), _lh_matchIdent⁶)
//│ 			in _lh_matchIdent⁷(99)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ words_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ break_lh_₁ -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ let _lh_matchIdent⁰ = dropWhile_lh_₁((fun x⁰ -> polyEq⁰(x⁰, ' ')), [LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]])
//│ in case _lh_matchIdent⁰ of {
//│ 	LH_N  => [LH_N]
//│ 	| _  => 
//│ 		let _lh_matchIdent¹ = break_lh_₁((fun x¹ -> polyEq⁰(x¹, ' ')), _lh_matchIdent⁰)
//│ 		in _lh_matchIdent¹(99)}
//│ def break1_lh_₁(_lh_break1_arg1⁰, _lh_break1_arg2⁰) = case _lh_break1_arg2⁰ of {
//│ 	LH_N  => [LH_P2 [LH_N] [LH_N]]
//│ 	| LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰ => if _lh_break1_arg1⁰(_lh_break1_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]] else 
//│ 		let _lh_matchIdent² = break1_lh_₁(_lh_break1_arg1⁰, _lh_break1_LH_C_1⁰)
//│ 		in case _lh_matchIdent² of {
//│ 			LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰]
//│ 			| _  => error⁰}
//│ 	| _  => error⁰}
//│ def break_lh_₁(_lh_break_arg1⁰, _lh_break_arg2⁰) = case _lh_break_arg2⁰ of {
//│ 	LH_N  => 
//│ 		let _lh_words_LH_P2_1⁰ = [LH_N]
//│ 		in let _lh_words_LH_P2_0⁰ = [LH_N]
//│ 		in (fun _lh_dummy⁰ -> [LH_C _lh_words_LH_P2_0⁰ 
//│ 			let _lh_matchIdent³ = dropWhile_lh_₁((fun x² -> polyEq⁰(x², ' ')), _lh_words_LH_P2_1⁰)
//│ 			in case _lh_matchIdent³ of {
//│ 				LH_N  => [LH_N]
//│ 				| _  => 
//│ 					let _lh_matchIdent⁴ = break_lh_₁((fun x³ -> polyEq⁰(x³, ' ')), _lh_matchIdent³)
//│ 					in _lh_matchIdent⁴(99)}])
//│ 	| LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰ => if _lh_break_arg1⁰(_lh_break_LH_C_0⁰) then 
//│ 		let _lh_words_LH_P2_1¹ = [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰]
//│ 		in let _lh_words_LH_P2_0¹ = [LH_N]
//│ 		in (fun _lh_dummy¹ -> [LH_C _lh_words_LH_P2_0¹ 
//│ 			let _lh_matchIdent⁵ = dropWhile_lh_₁((fun x⁴ -> polyEq⁰(x⁴, ' ')), _lh_words_LH_P2_1¹)
//│ 			in case _lh_matchIdent⁵ of {
//│ 				LH_N  => [LH_N]
//│ 				| _  => 
//│ 					let _lh_matchIdent⁶ = break_lh_₁((fun x⁵ -> polyEq⁰(x⁵, ' ')), _lh_matchIdent⁵)
//│ 					in _lh_matchIdent⁶(99)}]) else 
//│ 		let _lh_matchIdent⁷ = break1_lh_₁(_lh_break_arg1⁰, _lh_break_LH_C_1⁰)
//│ 		in case _lh_matchIdent⁷ of {
//│ 			LH_P2 _lh_break_LH_P2_0⁰ _lh_break_LH_P2_1⁰ => 
//│ 				let _lh_words_LH_P2_1² = _lh_break_LH_P2_1⁰
//│ 				in let _lh_words_LH_P2_0² = [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰]
//│ 				in (fun _lh_dummy² -> [LH_C _lh_words_LH_P2_0² 
//│ 					let _lh_matchIdent⁸ = dropWhile_lh_₁((fun x⁶ -> polyEq⁰(x⁶, ' ')), _lh_words_LH_P2_1²)
//│ 					in case _lh_matchIdent⁸ of {
//│ 						LH_N  => [LH_N]
//│ 						| _  => 
//│ 							let _lh_matchIdent⁹ = break_lh_₁((fun x⁷ -> polyEq⁰(x⁷, ' ')), _lh_matchIdent⁸)
//│ 							in _lh_matchIdent⁹(99)}])
//│ 			| _  => error⁰}
//│ 	| _  => error⁰}
//│ def dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_arg2⁰) = case _lh_dropWhile_arg2⁰ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰]
//│ 	| _  => error⁰}
//│ def words_lh_₁(_lh_words_arg1⁰) = 
//│ 	let _lh_matchIdent¹⁰ = dropWhile_lh_₁((fun x⁸ -> polyEq⁰(x⁸, ' ')), _lh_words_arg1⁰)
//│ 	in case _lh_matchIdent¹⁰ of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => 
//│ 			let _lh_matchIdent¹¹ = break_lh_₁((fun x⁹ -> polyEq⁰(x⁹, ' ')), _lh_matchIdent¹⁰)
//│ 			in _lh_matchIdent¹¹(99)}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ let _lh_matchIdent⁰ = dropWhile_lh_₁((fun x⁰ -> polyEq⁰(x⁰, ' ')), [LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]])
//│ in case _lh_matchIdent⁰ of {
//│ 	LH_N  => [LH_N]
//│ 	| _  => 
//│ 		let _lh_matchIdent¹ = break_lh_₁((fun x¹ -> polyEq⁰(x¹, ' ')), _lh_matchIdent⁰)
//│ 		in _lh_matchIdent¹(99)}
//│ def break1_lh_₁(_lh_break1_arg1⁰, _lh_break1_arg2⁰) = case _lh_break1_arg2⁰ of {
//│ 	LH_N  => [LH_P2 [LH_N] [LH_N]]
//│ 	| LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰ => if _lh_break1_arg1⁰(_lh_break1_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]] else 
//│ 		let _lh_matchIdent² = break1_lh_₁(_lh_break1_arg1⁰, _lh_break1_LH_C_1⁰)
//│ 		in case _lh_matchIdent² of {
//│ 			LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰]
//│ 			| _  => error⁰}
//│ 	| _  => error⁰}
//│ def break_lh_₁(_lh_break_arg1⁰, _lh_break_arg2⁰) = case _lh_break_arg2⁰ of {
//│ 	LH_N  => 
//│ 		let _lh_words_LH_P2_1⁰ = [LH_N]
//│ 		in let _lh_words_LH_P2_0⁰ = [LH_N]
//│ 		in (fun _lh_dummy⁰ -> [LH_C _lh_words_LH_P2_0⁰ 
//│ 			let _lh_matchIdent³ = dropWhile_lh_₁((fun x² -> polyEq⁰(x², ' ')), _lh_words_LH_P2_1⁰)
//│ 			in case _lh_matchIdent³ of {
//│ 				LH_N  => [LH_N]
//│ 				| _  => 
//│ 					let _lh_matchIdent⁴ = break_lh_₁((fun x³ -> polyEq⁰(x³, ' ')), _lh_matchIdent³)
//│ 					in _lh_matchIdent⁴(99)}])
//│ 	| LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰ => if _lh_break_arg1⁰(_lh_break_LH_C_0⁰) then 
//│ 		let _lh_words_LH_P2_1¹ = [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰]
//│ 		in let _lh_words_LH_P2_0¹ = [LH_N]
//│ 		in (fun _lh_dummy¹ -> [LH_C _lh_words_LH_P2_0¹ 
//│ 			let _lh_matchIdent⁵ = dropWhile_lh_₁((fun x⁴ -> polyEq⁰(x⁴, ' ')), _lh_words_LH_P2_1¹)
//│ 			in case _lh_matchIdent⁵ of {
//│ 				LH_N  => [LH_N]
//│ 				| _  => 
//│ 					let _lh_matchIdent⁶ = break_lh_₁((fun x⁵ -> polyEq⁰(x⁵, ' ')), _lh_matchIdent⁵)
//│ 					in _lh_matchIdent⁶(99)}]) else 
//│ 		let _lh_matchIdent⁷ = break1_lh_₁(_lh_break_arg1⁰, _lh_break_LH_C_1⁰)
//│ 		in case _lh_matchIdent⁷ of {
//│ 			LH_P2 _lh_break_LH_P2_0⁰ _lh_break_LH_P2_1⁰ => 
//│ 				let _lh_words_LH_P2_1² = _lh_break_LH_P2_1⁰
//│ 				in let _lh_words_LH_P2_0² = [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰]
//│ 				in (fun _lh_dummy² -> [LH_C _lh_words_LH_P2_0² 
//│ 					let _lh_matchIdent⁸ = dropWhile_lh_₁((fun x⁶ -> polyEq⁰(x⁶, ' ')), _lh_words_LH_P2_1²)
//│ 					in case _lh_matchIdent⁸ of {
//│ 						LH_N  => [LH_N]
//│ 						| _  => 
//│ 							let _lh_matchIdent⁹ = break_lh_₁((fun x⁷ -> polyEq⁰(x⁷, ' ')), _lh_matchIdent⁸)
//│ 							in _lh_matchIdent⁹(99)}])
//│ 			| _  => error⁰}
//│ 	| _  => error⁰}
//│ def dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_arg2⁰) = case _lh_dropWhile_arg2⁰ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰]
//│ 	| _  => error⁰}
//│ def words_lh_₁(_lh_words_arg1⁰) = 
//│ 	let _lh_matchIdent¹⁰ = dropWhile_lh_₁((fun x⁸ -> polyEq⁰(x⁸, ' ')), _lh_words_arg1⁰)
//│ 	in case _lh_matchIdent¹⁰ of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => 
//│ 			let _lh_matchIdent¹¹ = break_lh_₁((fun x⁹ -> polyEq⁰(x⁹, ' ')), _lh_matchIdent¹⁰)
//│ 			in _lh_matchIdent¹¹(99)}
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ words_lh_₁ :: 'words_lh_₁ <: [] ::: true
//│ '1' :: Char ::: false
//│ ' ' :: Char ::: false
//│ '2' :: Char ::: false
//│ ' ' :: Char ::: false
//│ '4' :: Char ::: false
//│ [LH_N] :: LH_N ::: true
//│ [LH_C '4' [LH_N]] :: LH_C(Char, LH_N) ::: true
//│ [LH_C ' ' [LH_C '4' [LH_N]]] :: LH_C(Char, LH_C(Char, LH_N)) ::: true
//│ [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]] :: LH_C(Char, LH_C(Char, LH_C(Char, LH_N))) ::: true
//│ [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]] :: LH_C(Char, LH_C(Char, LH_C(Char, LH_C(Char, LH_N)))) ::: true
//│ [LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]] :: LH_C(Char, LH_C(Char, LH_C(Char, LH_C(Char, LH_C(Char, LH_N))))) ::: true
//│ words_lh_₁([LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]]) :: '13_callres <: [] ::: true
//│ _lh_break1_arg2 :: '_lh_break1_arg2⁰ <: [] ::: true
//│ [LH_N] :: LH_N ::: true
//│ [LH_N] :: LH_N ::: true
//│ [LH_P2 [LH_N] [LH_N]] :: LH_P2(LH_N, LH_N) ::: true
//│ _lh_break1_arg1 :: '_lh_break1_arg1⁰ <: [] ::: true
//│ _lh_break1_LH_C_0 :: '_lh_break1_LH_C_0⁰ <: [] ::: true
//│ _lh_break1_arg1(_lh_break1_LH_C_0) :: '20_callres <: [] ::: true
//│ [LH_N] :: LH_N ::: true
//│ _lh_break1_LH_C_0 :: '_lh_break1_LH_C_0⁰ <: [] ::: true
//│ _lh_break1_LH_C_1 :: '_lh_break1_LH_C_1⁰ <: [] ::: true
//│ [LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1] :: LH_C('_lh_break1_LH_C_0⁰, '_lh_break1_LH_C_1⁰) ::: true
//│ [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1]] :: LH_P2(LH_N, LH_C('_lh_break1_LH_C_0⁰, '_lh_break1_LH_C_1⁰)) ::: true
//│ break1_lh_₁ :: 'break1_lh_₁ <: [] ::: true
//│ _lh_break1_arg1 :: '_lh_break1_arg1⁰ <: [] ::: true
//│ break1_lh_₁(_lh_break1_arg1) :: '28_callres <: [] ::: true
//│ _lh_break1_LH_C_1 :: '_lh_break1_LH_C_1⁰ <: [] ::: true
//│ break1_lh_₁(_lh_break1_arg1, _lh_break1_LH_C_1) :: '30_callres <: [] ::: true
//│ _lh_matchIdent :: '_lh_matchIdent⁰ <: [] ::: true
//│ _lh_break1_LH_C_0 :: '_lh_break1_LH_C_0⁰ <: [] ::: true
//│ _lh_break1_LH_P2_0 :: '_lh_break1_LH_P2_0⁰ <: [] ::: true
//│ [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] :: LH_C('_lh_break1_LH_C_0⁰, '_lh_break1_LH_P2_0⁰) ::: true
//│ _lh_break1_LH_P2_1 :: '_lh_break1_LH_P2_1⁰ <: [] ::: true
//│ [LH_P2 [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] _lh_break1_LH_P2_1] :: LH_P2(LH_C('_lh_break1_LH_C_0⁰, '_lh_break1_LH_P2_0⁰), '_lh_break1_LH_P2_1⁰) ::: true
//│ error :: '_lh_rigid_error_var <: [] ::: true
//│ case _lh_matchIdent of {LH_P2 _lh_break1_LH_P2_0 _lh_break1_LH_P2_1 => [LH_P2 [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] _lh_break1_LH_P2_1] | _  => error} :: '38_matchres <: [] ::: true
//│ let _lh_matchIdent = break1_lh_₁(_lh_break1_arg1, _lh_break1_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break1_LH_P2_0 _lh_break1_LH_P2_1 => [LH_P2 [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] _lh_break1_LH_P2_1] | _  => error} :: '38_matchres <: [] ::: true
//│ if _lh_break1_arg1(_lh_break1_LH_C_0) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1]] else let _lh_matchIdent = break1_lh_₁(_lh_break1_arg1, _lh_break1_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break1_LH_P2_0 _lh_break1_LH_P2_1 => [LH_P2 [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] _lh_break1_LH_P2_1] | _  => error} :: '40_ifres <: [] ::: true
//│ error :: '_lh_rigid_error_var <: [] ::: true
//│ case _lh_break1_arg2 of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1 => if _lh_break1_arg1(_lh_break1_LH_C_0) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1]] else let _lh_matchIdent = break1_lh_₁(_lh_break1_arg1, _lh_break1_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break1_LH_P2_0 _lh_break1_LH_P2_1 => [LH_P2 [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] _lh_break1_LH_P2_1] | _  => error} | _  => error} :: '42_matchres <: [] ::: true
//│ (fun _lh_break1_arg2 -> case _lh_break1_arg2 of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1 => if _lh_break1_arg1(_lh_break1_LH_C_0) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1]] else let _lh_matchIdent = break1_lh_₁(_lh_break1_arg1, _lh_break1_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break1_LH_P2_0 _lh_break1_LH_P2_1 => [LH_P2 [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] _lh_break1_LH_P2_1] | _  => error} | _  => error}) :: '_lh_break1_arg2⁰ => '42_matchres ::: true
//│ (fun _lh_break1_arg1 -> (fun _lh_break1_arg2 -> case _lh_break1_arg2 of {LH_N  => [LH_P2 [LH_N] [LH_N]] | LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1 => if _lh_break1_arg1(_lh_break1_LH_C_0) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0 _lh_break1_LH_C_1]] else let _lh_matchIdent = break1_lh_₁(_lh_break1_arg1, _lh_break1_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break1_LH_P2_0 _lh_break1_LH_P2_1 => [LH_P2 [LH_C _lh_break1_LH_C_0 _lh_break1_LH_P2_0] _lh_break1_LH_P2_1] | _  => error} | _  => error})) :: '_lh_break1_arg1⁰ => '_lh_break1_arg2⁰ => '42_matchres ::: true
//│ _lh_dropWhile_arg2 :: '_lh_dropWhile_arg2⁰ <: [] ::: true
//│ [LH_N] :: LH_N ::: true
//│ _lh_dropWhile_arg1 :: '_lh_dropWhile_arg1⁰ <: [] ::: true
//│ _lh_dropWhile_LH_C_0 :: '_lh_dropWhile_LH_C_0⁰ <: [] ::: true
//│ _lh_dropWhile_arg1(_lh_dropWhile_LH_C_0) :: '49_callres <: [] ::: true
//│ dropWhile_lh_₁ :: 'dropWhile_lh_₁ <: [] ::: true
//│ _lh_dropWhile_arg1 :: '_lh_dropWhile_arg1⁰ <: [] ::: true
//│ dropWhile_lh_₁(_lh_dropWhile_arg1) :: '52_callres <: [] ::: true
//│ _lh_dropWhile_LH_C_1 :: '_lh_dropWhile_LH_C_1⁰ <: [] ::: true
//│ dropWhile_lh_₁(_lh_dropWhile_arg1, _lh_dropWhile_LH_C_1) :: '54_callres <: [] ::: true
//│ _lh_dropWhile_LH_C_0 :: '_lh_dropWhile_LH_C_0⁰ <: [] ::: true
//│ _lh_dropWhile_LH_C_1 :: '_lh_dropWhile_LH_C_1⁰ <: [] ::: true
//│ [LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1] :: LH_C('_lh_dropWhile_LH_C_0⁰, '_lh_dropWhile_LH_C_1⁰) ::: true
//│ if _lh_dropWhile_arg1(_lh_dropWhile_LH_C_0) then dropWhile_lh_₁(_lh_dropWhile_arg1, _lh_dropWhile_LH_C_1) else [LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1] :: '58_ifres <: [] ::: true
//│ error :: '_lh_rigid_error_var <: [] ::: true
//│ case _lh_dropWhile_arg2 of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1 => if _lh_dropWhile_arg1(_lh_dropWhile_LH_C_0) then dropWhile_lh_₁(_lh_dropWhile_arg1, _lh_dropWhile_LH_C_1) else [LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1] | _  => error} :: '60_matchres <: [] ::: true
//│ (fun _lh_dropWhile_arg2 -> case _lh_dropWhile_arg2 of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1 => if _lh_dropWhile_arg1(_lh_dropWhile_LH_C_0) then dropWhile_lh_₁(_lh_dropWhile_arg1, _lh_dropWhile_LH_C_1) else [LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1] | _  => error}) :: '_lh_dropWhile_arg2⁰ => '60_matchres ::: true
//│ (fun _lh_dropWhile_arg1 -> (fun _lh_dropWhile_arg2 -> case _lh_dropWhile_arg2 of {LH_N  => [LH_N] | LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1 => if _lh_dropWhile_arg1(_lh_dropWhile_LH_C_0) then dropWhile_lh_₁(_lh_dropWhile_arg1, _lh_dropWhile_LH_C_1) else [LH_C _lh_dropWhile_LH_C_0 _lh_dropWhile_LH_C_1] | _  => error})) :: '_lh_dropWhile_arg1⁰ => '_lh_dropWhile_arg2⁰ => '60_matchres ::: true
//│ _lh_break_arg2 :: '_lh_break_arg2⁰ <: [] ::: true
//│ [LH_N] :: LH_N ::: true
//│ [LH_N] :: LH_N ::: true
//│ _lh_words_LH_P2_0 :: '_lh_words_LH_P2_0⁰ <: [] ::: true
//│ words_lh_₁ :: 'words_lh_₁ <: [] ::: true
//│ _lh_words_LH_P2_1 :: '_lh_words_LH_P2_1⁰ <: [] ::: true
//│ words_lh_₁(_lh_words_LH_P2_1) :: '69_callres <: [] ::: true
//│ [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)] :: LH_C('_lh_words_LH_P2_0⁰, '69_callres) ::: true
//│ (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) :: '_lh_dummy⁰ => LH_C('_lh_words_LH_P2_0⁰, '69_callres) ::: true
//│ let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) :: '_lh_dummy⁰ => LH_C('_lh_words_LH_P2_0⁰, '69_callres) ::: true
//│ let _lh_words_LH_P2_1 = [LH_N]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) :: '_lh_dummy⁰ => LH_C('_lh_words_LH_P2_0⁰, '69_callres) ::: true
//│ _lh_break_arg1 :: '_lh_break_arg1⁰ <: [] ::: true
//│ _lh_break_LH_C_0 :: '_lh_break_LH_C_0⁰ <: [] ::: true
//│ _lh_break_arg1(_lh_break_LH_C_0) :: '76_callres <: [] ::: true
//│ _lh_break_LH_C_0 :: '_lh_break_LH_C_0⁰ <: [] ::: true
//│ _lh_break_LH_C_1 :: '_lh_break_LH_C_1⁰ <: [] ::: true
//│ [LH_C _lh_break_LH_C_0 _lh_break_LH_C_1] :: LH_C('_lh_break_LH_C_0⁰, '_lh_break_LH_C_1⁰) ::: true
//│ [LH_N] :: LH_N ::: true
//│ _lh_words_LH_P2_0 :: '_lh_words_LH_P2_0¹ <: [] ::: true
//│ words_lh_₁ :: 'words_lh_₁ <: [] ::: true
//│ _lh_words_LH_P2_1 :: '_lh_words_LH_P2_1¹ <: [] ::: true
//│ words_lh_₁(_lh_words_LH_P2_1) :: '84_callres <: [] ::: true
//│ [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)] :: LH_C('_lh_words_LH_P2_0¹, '84_callres) ::: true
//│ (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) :: '_lh_dummy¹ => LH_C('_lh_words_LH_P2_0¹, '84_callres) ::: true
//│ let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) :: '_lh_dummy¹ => LH_C('_lh_words_LH_P2_0¹, '84_callres) ::: true
//│ let _lh_words_LH_P2_1 = [LH_C _lh_break_LH_C_0 _lh_break_LH_C_1]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) :: '_lh_dummy¹ => LH_C('_lh_words_LH_P2_0¹, '84_callres) ::: true
//│ break1_lh_₁ :: 'break1_lh_₁ <: [] ::: true
//│ _lh_break_arg1 :: '_lh_break_arg1⁰ <: [] ::: true
//│ break1_lh_₁(_lh_break_arg1) :: '91_callres <: [] ::: true
//│ _lh_break_LH_C_1 :: '_lh_break_LH_C_1⁰ <: [] ::: true
//│ break1_lh_₁(_lh_break_arg1, _lh_break_LH_C_1) :: '93_callres <: [] ::: true
//│ _lh_matchIdent :: '_lh_matchIdent¹ <: [] ::: true
//│ _lh_break_LH_P2_1 :: '_lh_break_LH_P2_1⁰ <: [] ::: true
//│ _lh_break_LH_C_0 :: '_lh_break_LH_C_0⁰ <: [] ::: true
//│ _lh_break_LH_P2_0 :: '_lh_break_LH_P2_0⁰ <: [] ::: true
//│ [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0] :: LH_C('_lh_break_LH_C_0⁰, '_lh_break_LH_P2_0⁰) ::: true
//│ _lh_words_LH_P2_0 :: '_lh_words_LH_P2_0² <: [] ::: true
//│ words_lh_₁ :: 'words_lh_₁ <: [] ::: true
//│ _lh_words_LH_P2_1 :: '_lh_words_LH_P2_1² <: [] ::: true
//│ words_lh_₁(_lh_words_LH_P2_1) :: '102_callres <: [] ::: true
//│ [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)] :: LH_C('_lh_words_LH_P2_0², '102_callres) ::: true
//│ (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) :: '_lh_dummy² => LH_C('_lh_words_LH_P2_0², '102_callres) ::: true
//│ let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) :: '_lh_dummy² => LH_C('_lh_words_LH_P2_0², '102_callres) ::: true
//│ let _lh_words_LH_P2_1 = _lh_break_LH_P2_1
//│ in let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) :: '_lh_dummy² => LH_C('_lh_words_LH_P2_0², '102_callres) ::: true
//│ error :: '_lh_rigid_error_var <: [] ::: true
//│ case _lh_matchIdent of {LH_P2 _lh_break_LH_P2_0 _lh_break_LH_P2_1 => let _lh_words_LH_P2_1 = _lh_break_LH_P2_1
//│ in let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) | _  => error} :: '108_matchres <: [] ::: true
//│ let _lh_matchIdent = break1_lh_₁(_lh_break_arg1, _lh_break_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break_LH_P2_0 _lh_break_LH_P2_1 => let _lh_words_LH_P2_1 = _lh_break_LH_P2_1
//│ in let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) | _  => error} :: '108_matchres <: [] ::: true
//│ if _lh_break_arg1(_lh_break_LH_C_0) then let _lh_words_LH_P2_1 = [LH_C _lh_break_LH_C_0 _lh_break_LH_C_1]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) else let _lh_matchIdent = break1_lh_₁(_lh_break_arg1, _lh_break_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break_LH_P2_0 _lh_break_LH_P2_1 => let _lh_words_LH_P2_1 = _lh_break_LH_P2_1
//│ in let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) | _  => error} :: '110_ifres <: [] ::: true
//│ error :: '_lh_rigid_error_var <: [] ::: true
//│ case _lh_break_arg2 of {LH_N  => let _lh_words_LH_P2_1 = [LH_N]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) | LH_C _lh_break_LH_C_0 _lh_break_LH_C_1 => if _lh_break_arg1(_lh_break_LH_C_0) then let _lh_words_LH_P2_1 = [LH_C _lh_break_LH_C_0 _lh_break_LH_C_1]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) else let _lh_matchIdent = break1_lh_₁(_lh_break_arg1, _lh_break_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break_LH_P2_0 _lh_break_LH_P2_1 => let _lh_words_LH_P2_1 = _lh_break_LH_P2_1
//│ in let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) | _  => error} | _  => error} :: '112_matchres <: [] ::: true
//│ (fun _lh_break_arg2 -> case _lh_break_arg2 of {LH_N  => let _lh_words_LH_P2_1 = [LH_N]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) | LH_C _lh_break_LH_C_0 _lh_break_LH_C_1 => if _lh_break_arg1(_lh_break_LH_C_0) then let _lh_words_LH_P2_1 = [LH_C _lh_break_LH_C_0 _lh_break_LH_C_1]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) else let _lh_matchIdent = break1_lh_₁(_lh_break_arg1, _lh_break_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break_LH_P2_0 _lh_break_LH_P2_1 => let _lh_words_LH_P2_1 = _lh_break_LH_P2_1
//│ in let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) | _  => error} | _  => error}) :: '_lh_break_arg2⁰ => '112_matchres ::: true
//│ (fun _lh_break_arg1 -> (fun _lh_break_arg2 -> case _lh_break_arg2 of {LH_N  => let _lh_words_LH_P2_1 = [LH_N]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) | LH_C _lh_break_LH_C_0 _lh_break_LH_C_1 => if _lh_break_arg1(_lh_break_LH_C_0) then let _lh_words_LH_P2_1 = [LH_C _lh_break_LH_C_0 _lh_break_LH_C_1]
//│ in let _lh_words_LH_P2_0 = [LH_N]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) else let _lh_matchIdent = break1_lh_₁(_lh_break_arg1, _lh_break_LH_C_1)
//│ in case _lh_matchIdent of {LH_P2 _lh_break_LH_P2_0 _lh_break_LH_P2_1 => let _lh_words_LH_P2_1 = _lh_break_LH_P2_1
//│ in let _lh_words_LH_P2_0 = [LH_C _lh_break_LH_C_0 _lh_break_LH_P2_0]
//│ in (fun _lh_dummy -> [LH_C _lh_words_LH_P2_0 words_lh_₁(_lh_words_LH_P2_1)]) | _  => error} | _  => error})) :: '_lh_break_arg1⁰ => '_lh_break_arg2⁰ => '112_matchres ::: true
//│ dropWhile_lh_₁ :: 'dropWhile_lh_₁ <: [] ::: true
//│ polyEq :: NoProd ::: true
//│ x :: 'x⁰ <: [] ::: true
//│ polyEq(x) :: '118_callres <: [] ::: true
//│ ' ' :: Char ::: false
//│ polyEq(x, ' ') :: '120_callres <: [] ::: true
//│ (fun x -> polyEq(x, ' ')) :: 'x⁰ => '120_callres ::: true
//│ dropWhile_lh_₁((fun x -> polyEq(x, ' '))) :: '122_callres <: [] ::: true
//│ _lh_words_arg1 :: '_lh_words_arg1⁰ <: [] ::: true
//│ dropWhile_lh_₁((fun x -> polyEq(x, ' ')), _lh_words_arg1) :: '124_callres <: [] ::: true
//│ _lh_matchIdent :: '_lh_matchIdent² <: [] ::: true
//│ [LH_N] :: LH_N ::: true
//│ break_lh_₁ :: 'break_lh_₁ <: [] ::: true
//│ polyEq :: NoProd ::: true
//│ x :: 'x¹ <: [] ::: true
//│ polyEq(x) :: '130_callres <: [] ::: true
//│ ' ' :: Char ::: false
//│ polyEq(x, ' ') :: '132_callres <: [] ::: true
//│ (fun x -> polyEq(x, ' ')) :: 'x¹ => '132_callres ::: true
//│ break_lh_₁((fun x -> polyEq(x, ' '))) :: '134_callres <: [] ::: true
//│ _lh_matchIdent :: '_lh_matchIdent² <: [] ::: true
//│ break_lh_₁((fun x -> polyEq(x, ' ')), _lh_matchIdent) :: '136_callres <: [] ::: true
//│ _lh_matchIdent :: '_lh_matchIdent³ <: [] ::: true
//│ 99 :: Int ::: false
//│ _lh_matchIdent(99) :: '139_callres <: [] ::: true
//│ let _lh_matchIdent = break_lh_₁((fun x -> polyEq(x, ' ')), _lh_matchIdent)
//│ in _lh_matchIdent(99) :: '139_callres <: [] ::: true
//│ case _lh_matchIdent of {LH_N  => [LH_N] | _  => let _lh_matchIdent = break_lh_₁((fun x -> polyEq(x, ' ')), _lh_matchIdent)
//│ in _lh_matchIdent(99)} :: '141_matchres <: [] ::: true
//│ let _lh_matchIdent = dropWhile_lh_₁((fun x -> polyEq(x, ' ')), _lh_words_arg1)
//│ in case _lh_matchIdent of {LH_N  => [LH_N] | _  => let _lh_matchIdent = break_lh_₁((fun x -> polyEq(x, ' ')), _lh_matchIdent)
//│ in _lh_matchIdent(99)} :: '141_matchres <: [] ::: true
//│ (fun _lh_words_arg1 -> let _lh_matchIdent = dropWhile_lh_₁((fun x -> polyEq(x, ' ')), _lh_words_arg1)
//│ in case _lh_matchIdent of {LH_N  => [LH_N] | _  => let _lh_matchIdent = break_lh_₁((fun x -> polyEq(x, ' ')), _lh_matchIdent)
//│ in _lh_matchIdent(99)}) :: '_lh_words_arg1⁰ => '141_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec break1_lh__d1 _lh_break1_arg1_0 _lh_break1_arg2_0 =
//│   (match _lh_break1_arg2_0 with
//│     | `LH_N -> 
//│       (`LH_P2((`LH_N), (`LH_N)))
//│     | `LH_C(_lh_break1_LH_C_0_0, _lh_break1_LH_C_1_0) -> 
//│       (if (_lh_break1_arg1_0 _lh_break1_LH_C_0_0) then
//│         (`LH_P2((`LH_N), (`LH_C(_lh_break1_LH_C_0_0, _lh_break1_LH_C_1_0))))
//│       else
//│         (let rec _lh_matchIdent_0 = ((break1_lh__d1 _lh_break1_arg1_0) _lh_break1_LH_C_1_0) in
//│           (match _lh_matchIdent_0 with
//│             | `LH_P2(_lh_break1_LH_P2_0_0, _lh_break1_LH_P2_1_0) -> 
//│               (`LH_P2((`LH_C(_lh_break1_LH_C_0_0, _lh_break1_LH_P2_0_0)), _lh_break1_LH_P2_1_0))
//│             | _ -> 
//│               (failwith "error"))))
//│     | _ -> 
//│       (failwith "error"));;
//│ let rec dropWhile_lh__d1 _lh_dropWhile_arg1_0 _lh_dropWhile_arg2_0 =
//│   (match _lh_dropWhile_arg2_0 with
//│     | `LH_N -> 
//│       (`LH_N)
//│     | `LH_C(_lh_dropWhile_LH_C_0_0, _lh_dropWhile_LH_C_1_0) -> 
//│       (if (_lh_dropWhile_arg1_0 _lh_dropWhile_LH_C_0_0) then
//│         ((dropWhile_lh__d1 _lh_dropWhile_arg1_0) _lh_dropWhile_LH_C_1_0)
//│       else
//│         (`LH_C(_lh_dropWhile_LH_C_0_0, _lh_dropWhile_LH_C_1_0)))
//│     | _ -> 
//│       (failwith "error"));;
//│ let rec break_lh__d1 _lh_break_arg1_0 _lh_break_arg2_0 =
//│   (match _lh_break_arg2_0 with
//│     | `LH_N -> 
//│       (let rec _lh_words_LH_P2_1_0 = (`LH_N) in
//│         (let rec _lh_words_LH_P2_0_0 = (`LH_N) in
//│           (fun _lh_dummy_0 -> 
//│             (`LH_C(_lh_words_LH_P2_0_0, (words_lh__d1 _lh_words_LH_P2_1_0))))))
//│     | `LH_C(_lh_break_LH_C_0_0, _lh_break_LH_C_1_0) -> 
//│       (if (_lh_break_arg1_0 _lh_break_LH_C_0_0) then
//│         (let rec _lh_words_LH_P2_1_1 = (`LH_C(_lh_break_LH_C_0_0, _lh_break_LH_C_1_0)) in
//│           (let rec _lh_words_LH_P2_0_1 = (`LH_N) in
//│             (fun _lh_dummy_1 -> 
//│               (`LH_C(_lh_words_LH_P2_0_1, (words_lh__d1 _lh_words_LH_P2_1_1))))))
//│       else
//│         (let rec _lh_matchIdent_1 = ((break1_lh__d1 _lh_break_arg1_0) _lh_break_LH_C_1_0) in
//│           (match _lh_matchIdent_1 with
//│             | `LH_P2(_lh_break_LH_P2_0_0, _lh_break_LH_P2_1_0) -> 
//│               (let rec _lh_words_LH_P2_1_2 = _lh_break_LH_P2_1_0 in
//│                 (let rec _lh_words_LH_P2_0_2 = (`LH_C(_lh_break_LH_C_0_0, _lh_break_LH_P2_0_0)) in
//│                   (fun _lh_dummy_2 -> 
//│                     (`LH_C(_lh_words_LH_P2_0_2, (words_lh__d1 _lh_words_LH_P2_1_2))))))
//│             | _ -> 
//│               (failwith "error"))))
//│     | _ -> 
//│       (failwith "error"))
//│ and
//│ words_lh__d1 _lh_words_arg1_0 =
//│   (let rec _lh_matchIdent_2 = ((dropWhile_lh__d1 (fun x_0 -> 
//│     (x_0 = ' '))) _lh_words_arg1_0) in
//│     (match _lh_matchIdent_2 with
//│       | `LH_N -> 
//│         (`LH_N)
//│       | _ -> 
//│         (let rec _lh_matchIdent_3 = ((break_lh__d1 (fun x_1 -> 
//│           (x_1 = ' '))) _lh_matchIdent_2) in
//│           (_lh_matchIdent_3 99))));;
//│ (words_lh__d1 (`LH_C('1', (`LH_C(' ', (`LH_C('2', (`LH_C(' ', (`LH_C('4', (`LH_N))))))))))))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│   - : [> `LH_C of
//│          [> `LH_C of char * ([> `LH_C of char * 'b | `LH_N ] as 'b) | `LH_N ] *
//│          'a
//│      | `LH_N ]
//│     as 'a
//│ =
//│ `LH_C
//│   (`LH_C ('1', `LH_N),
//│    `LH_C (`LH_C ('2', `LH_N), `LH_C (`LH_C ('4', `LH_N), `LH_N)))
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


// FIXME: the type error can be eliminated by expanding again to
// eliminate dead codes (totally unreachable definitions) that appear
// after removing dead branches
:lhGenOCaml
:d
fun break(p, ls) = if ls is
  N then P(N, N)
  C(x, xs) then if p(x) then P(N, C(x, xs)) else if break1(p, xs) is
    P(ys, zs) then P(C(x, ys), zs)
fun break1(p, ls) = if ls is
  N then P(N, N)
  C(x, xs) then if p(x) then P(N, C(x, xs)) else if break1(p, xs) is
    P(ys, zs) then P(C(x, ys), zs)
fun words(s) = if dropWhile(x => x == 1, s) is
  N then N
  s' then if break(x => x == 1, s') is
    P(w, s'') then C(w, words(s''))
fun dropWhile(f, ls) = if ls is
  N then N
  C(h, t) then if f(h) then dropWhile(f, t) else C(h, t)
words(C(2, C(1, C(2, C(1, C(2, N))))))
//│ |#fun| |break|(|p|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |P|(|N|,| |N|)|↵|C|(|x|,| |xs|)| |#then| |#if| |p|(|x|)| |#then| |P|(|N|,| |C|(|x|,| |xs|)|)| |#else| |#if| |break1|(|p|,| |xs|)| |is|→|P|(|ys|,| |zs|)| |#then| |P|(|C|(|x|,| |ys|)|,| |zs|)|←|←|↵|#fun| |break1|(|p|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |P|(|N|,| |N|)|↵|C|(|x|,| |xs|)| |#then| |#if| |p|(|x|)| |#then| |P|(|N|,| |C|(|x|,| |xs|)|)| |#else| |#if| |break1|(|p|,| |xs|)| |is|→|P|(|ys|,| |zs|)| |#then| |P|(|C|(|x|,| |ys|)|,| |zs|)|←|←|↵|#fun| |words|(|s|)| |#=| |#if| |dropWhile|(|x| |=>| |x| |==| |1|,| |s|)| |is|→|N| |#then| |N|↵|s'| |#then| |#if| |break|(|x| |=>| |x| |==| |1|,| |s'|)| |is|→|P|(|w|,| |s''|)| |#then| |C|(|w|,| |words|(|s''|)|)|←|←|↵|#fun| |dropWhile|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |dropWhile|(|f|,| |t|)| |#else| |C|(|h|,| |t|)|←|↵|words|(|C|(|2|,| |C|(|1|,| |C|(|2|,| |C|(|1|,| |C|(|2|,| |N|)|)|)|)|)|)|
//│ Parsed: {fun break = p, ls, => if ls is ‹(N) then P (N, N,); (C (x, xs,)) then if (p (x,)) then P (N, C (x, xs,),) else if break1 (p, xs,) is ‹(P (ys, zs,)) then P (C (x, ys,), zs,)››; fun break1 = p, ls, => if ls is ‹(N) then P (N, N,); (C (x, xs,)) then if (p (x,)) then P (N, C (x, xs,),) else if break1 (p, xs,) is ‹(P (ys, zs,)) then P (C (x, ys,), zs,)››; fun words = s, => if dropWhile (x, => == (x,) (1,), s,) is ‹(N) then N; (s') then if break (x, => == (x,) (1,), s',) is ‹(P (w, s'',)) then C (w, words (s'',),)››; fun dropWhile = f, ls, => if ls is ‹(N) then N; (C (h, t,)) then if (f (h,)) then dropWhile (f, t,) else C (h, t,)›; words (C (2, C (1, C (2, C (1, C (2, N,),),),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ words^101([C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]])
//│ def break(p⁰, ls⁰) = case ls⁰ of {
//│ 	N  => [P [N] [N]]
//│ 	| C x⁰ xs⁰ => if p⁰(x⁰) then [P [N] [C x⁰ xs⁰]] else case break1^13(p⁰, xs⁰) of {
//│ 		P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}}
//│ def break1(p¹, ls¹) = case ls¹ of {
//│ 	N  => [P [N] [N]]
//│ 	| C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1^40(p¹, xs¹) of {
//│ 		P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}
//│ def dropWhile(f⁰, ls²) = case ls² of {
//│ 	N  => [N]
//│ 	| C h⁰ t⁰ => if f⁰(h⁰) then dropWhile^89(f⁰, t⁰) else [C h⁰ t⁰]}
//│ def words(s⁰) = case dropWhile^55((fun x² -> (x² == 1)), s⁰) of {
//│ 	N  => [N]
//│ 	| s'⁰ => case break^66((fun x³ -> (x³ == 1)), s'⁰) of {
//│ 		P w⁰ s''⁰ => [C w⁰ words^77(s''⁰)]}}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec dropWhile f_0 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (f_0 h_0) then
//│ 		        ((dropWhile f_0) t_0)
//│ 		      else
//│ 		        (`C(h_0, t_0))));;
//│ 		let rec break1 p_1 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `N -> 
//│ 		      (`P((`N), (`N)))
//│ 		    | `C(x_1, xs_1) -> 
//│ 		      (if (p_1 x_1) then
//│ 		        (`P((`N), (`C(x_1, xs_1))))
//│ 		      else
//│ 		        (match ((break1 p_1) xs_1) with
//│ 		          | `P(ys_1, zs_1) -> 
//│ 		            (`P((`C(x_1, ys_1)), zs_1)))));;
//│ 		let rec break p_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`P((`N), (`N)))
//│ 		    | `C(x_0, xs_0) -> 
//│ 		      (if (p_0 x_0) then
//│ 		        (`P((`N), (`C(x_0, xs_0))))
//│ 		      else
//│ 		        (match ((break1 p_0) xs_0) with
//│ 		          | `P(ys_0, zs_0) -> 
//│ 		            (`P((`C(x_0, ys_0)), zs_0)))));;
//│ 		let rec words s_0 =
//│ 		  (match ((dropWhile (fun x_2 -> 
//│ 		    (x_2 = 1))) s_0) with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | s'_0 -> 
//│ 		      (match ((break (fun x_3 -> 
//│ 		        (x_3 = 1))) s'_0) with
//│ 		        | `P(w_0, s''_0) -> 
//│ 		          (`C(w_0, (words s''_0)))));;
//│ 		(words (`C(2, (`C(1, (`C(2, (`C(1, (`C(2, (`N))))))))))))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		                val dropWhile :
//│ 		  ('a -> bool) -> ([< `C of 'a * 'b | `N ] as 'b) -> [> `C of 'a * 'b | `N ] =
//│ 		  <fun>
//│ 		[ok]
//│ 		                      val break1 :
//│ 		  ('a -> bool) ->
//│ 		  ([< `C of 'a * 'b | `N ] as 'b) ->
//│ 		  [ `P of ([> `C of 'a * 'c | `N ] as 'c) * [> `C of 'a * 'b | `N ] ] = <fun>
//│ 		[ok]
//│ 		                      val break :
//│ 		  ('a -> bool) ->
//│ 		  [< `C of 'a * ([< `C of 'a * 'b | `N ] as 'b) | `N ] ->
//│ 		  [> `P of
//│ 		       [> `C of 'a * ([> `C of 'a * 'c | `N ] as 'c) | `N ] *
//│ 		       [> `C of 'a * 'b | `N ] ] =
//│ 		  <fun>
//│ 		[ok]
//│ 		                    val words :
//│ 		  ([ `C of int * 'a | `N ] as 'a) ->
//│ 		  ([> `C of [> `C of int * ([> `C of int * 'c | `N ] as 'c) | `N ] * 'b | `N
//│ 		   ] as 'b) =
//│ 		  <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 3 --->
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 98
//│ [P [N] [N]]: 4 --->
//│ 	case break((fun x³ -> (x³ == 1)), s'⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 81
//│ [C x⁰ xs⁰]: 11 --->
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 98
//│ [P [N] [C x⁰ xs⁰]]: 12 --->
//│ 	case break((fun x³ -> (x³ == 1)), s'⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 81
//│ [P [C x⁰ ys⁰] zs⁰]: 22 --->
//│ 	case break((fun x³ -> (x³ == 1)), s'⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 81
//│ [N]: 30 --->
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 98
//│ [P [N] [N]]: 31 --->
//│ 	case break1(p⁰, xs⁰) of {P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}: 23
//│ 	case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}: 50
//│ [C x¹ xs¹]: 38 --->
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 98
//│ [P [N] [C x¹ xs¹]]: 39 --->
//│ 	case break1(p⁰, xs⁰) of {P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}: 23
//│ 	case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}: 50
//│ [P [C x¹ ys¹] zs¹]: 49 --->
//│ 	case break1(p⁰, xs⁰) of {P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}: 23
//│ 	case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}: 50
//│ [N]: 85 --->
//│ 	case dropWhile((fun x² -> (x² == 1)), s⁰) of {N  => [N] | s'⁰ => case break((fun x³ -> (x³ == 1)), s'⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}}: 82
//│ [C h⁰ t⁰]: 96 --->
//│ 	case ls⁰ of {N  => [P [N] [N]] | C x⁰ xs⁰ => if p⁰(x⁰) then [P [N] [C x⁰ xs⁰]] else case break1(p⁰, xs⁰) of {P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}}: 25
//│ 	case dropWhile((fun x² -> (x² == 1)), s⁰) of {N  => [N] | s'⁰ => case break((fun x³ -> (x³ == 1)), s'⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}}: 82
//│ [N]: 107 --->
//│ 	case ls¹ of {N  => [P [N] [N]] | C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}: 52
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 98
//│ [C 2 [N]]: 108 --->
//│ 	case ls¹ of {N  => [P [N] [N]] | C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}: 52
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 98
//│ [C 1 [C 2 [N]]]: 109 --->
//│ 	case ls¹ of {N  => [P [N] [N]] | C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}: 52
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 98
//│ [C 2 [C 1 [C 2 [N]]]]: 110 --->
//│ 	case ls¹ of {N  => [P [N] [N]] | C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}: 52
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 98
//│ [C 1 [C 2 [C 1 [C 2 [N]]]]]: 111 --->
//│ 	case ls¹ of {N  => [P [N] [N]] | C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}: 52
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 98
//│ [C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]]: 112 --->
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 98
//│ ------------------
//│ case break1(p⁰, xs⁰) of {P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}: 23 --->
//│ 	[P [N] [N]]: 31
//│ 	[P [N] [C x¹ xs¹]]: 39
//│ 	[P [C x¹ ys¹] zs¹]: 49
//│ case ls⁰ of {N  => [P [N] [N]] | C x⁰ xs⁰ => if p⁰(x⁰) then [P [N] [C x⁰ xs⁰]] else case break1(p⁰, xs⁰) of {P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}}: 25 --->
//│ 	[C h⁰ t⁰]: 96
//│ case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}: 50 --->
//│ 	[P [N] [N]]: 31
//│ 	[P [N] [C x¹ xs¹]]: 39
//│ 	[P [C x¹ ys¹] zs¹]: 49
//│ case ls¹ of {N  => [P [N] [N]] | C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}: 52 --->
//│ 	[N]: 107
//│ 	[C 2 [N]]: 108
//│ 	[C 1 [C 2 [N]]]: 109
//│ 	[C 2 [C 1 [C 2 [N]]]]: 110
//│ 	[C 1 [C 2 [C 1 [C 2 [N]]]]]: 111
//│ case break((fun x³ -> (x³ == 1)), s'⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 81 --->
//│ 	[P [N] [N]]: 4
//│ 	[P [N] [C x⁰ xs⁰]]: 12
//│ 	[P [C x⁰ ys⁰] zs⁰]: 22
//│ case dropWhile((fun x² -> (x² == 1)), s⁰) of {N  => [N] | s'⁰ => case break((fun x³ -> (x³ == 1)), s'⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}}: 82 --->
//│ 	[N]: 85
//│ 	[C h⁰ t⁰]: 96
//│ case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 98 --->
//│ 	[N]: 3
//│ 	[C x⁰ xs⁰]: 11
//│ 	[N]: 30
//│ 	[C x¹ xs¹]: 38
//│ 	[N]: 107
//│ 	[C 2 [N]]: 108
//│ 	[C 1 [C 2 [N]]]: 109
//│ 	[C 2 [C 1 [C 2 [N]]]]: 110
//│ 	[C 1 [C 2 [C 1 [C 2 [N]]]]]: 111
//│ 	[C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]]: 112
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [P [N] [N]]: 4 --->
//│ 	case break((fun x³ -> (x³ == 1)), s'⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 81
//│ [P [N] [C x⁰ xs⁰]]: 12 --->
//│ 	case break((fun x³ -> (x³ == 1)), s'⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 81
//│ [P [C x⁰ ys⁰] zs⁰]: 22 --->
//│ 	case break((fun x³ -> (x³ == 1)), s'⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 81
//│ ------------------
//│ case break((fun x³ -> (x³ == 1)), s'⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 81 --->
//│ 	[P [N] [N]]: 4
//│ 	[P [N] [C x⁰ xs⁰]]: 12
//│ 	[P [C x⁰ ys⁰] zs⁰]: 22
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ words([C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]])
//│ def break(p², ls³) = case ls³ of {
//│ 	N  => 
//│ 		let s''¹ = [N]
//│ 		in let w¹ = [N]
//│ 		in (fun _lh_dummy⁰ -> [C w¹ words(s''¹)])
//│ 	| C x⁰ xs⁰ => if p²(x⁰) then 
//│ 		let s''² = [C x⁰ xs⁰]
//│ 		in let w² = [N]
//│ 		in (fun _lh_dummy¹ -> [C w² words(s''²)]) else case break1(p², xs⁰) of {
//│ 		P ys⁰ zs⁰ => 
//│ 			let s''³ = zs⁰
//│ 			in let w³ = [C x⁰ ys⁰]
//│ 			in (fun _lh_dummy² -> [C w³ words(s''³)])}}
//│ def break1(p³, ls⁴) = case ls⁴ of {
//│ 	N  => [P [N] [N]]
//│ 	| C x¹ xs¹ => if p³(x¹) then [P [N] [C x¹ xs¹]] else case break1(p³, xs¹) of {
//│ 		P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}
//│ def dropWhile(f¹, ls⁵) = case ls⁵ of {
//│ 	N  => [N]
//│ 	| C h⁰ t⁰ => if f¹(h⁰) then dropWhile(f¹, t⁰) else [C h⁰ t⁰]}
//│ def words(s¹) = case dropWhile((fun x⁴ -> (x⁴ == 1)), s¹) of {
//│ 	N  => [N]
//│ 	| s'⁰ => break((fun x⁵ -> (x⁵ == 1)), s'⁰, 99)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ words
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ break -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ case dropWhile((fun x⁰ -> (x⁰ == 1)), [C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]]) of {
//│ 	N  => [N]
//│ 	| s'⁰ => break((fun x¹ -> (x¹ == 1)), s'⁰, 99)}
//│ def break(p⁰, ls⁰) = case ls⁰ of {
//│ 	N  => 
//│ 		let s''⁰ = [N]
//│ 		in let w⁰ = [N]
//│ 		in (fun _lh_dummy⁰ -> [C w⁰ case dropWhile((fun x² -> (x² == 1)), s''⁰) of {
//│ 			N  => [N]
//│ 			| s'¹ => break((fun x³ -> (x³ == 1)), s'¹, 99)}])
//│ 	| C x⁴ xs⁰ => if p⁰(x⁴) then 
//│ 		let s''¹ = [C x⁴ xs⁰]
//│ 		in let w¹ = [N]
//│ 		in (fun _lh_dummy¹ -> [C w¹ case dropWhile((fun x⁵ -> (x⁵ == 1)), s''¹) of {
//│ 			N  => [N]
//│ 			| s'² => break((fun x⁶ -> (x⁶ == 1)), s'², 99)}]) else case break1(p⁰, xs⁰) of {
//│ 		P ys⁰ zs⁰ => 
//│ 			let s''² = zs⁰
//│ 			in let w² = [C x⁴ ys⁰]
//│ 			in (fun _lh_dummy² -> [C w² case dropWhile((fun x⁷ -> (x⁷ == 1)), s''²) of {
//│ 				N  => [N]
//│ 				| s'³ => break((fun x⁸ -> (x⁸ == 1)), s'³, 99)}])}}
//│ def break1(p¹, ls¹) = case ls¹ of {
//│ 	N  => [P [N] [N]]
//│ 	| C x⁹ xs¹ => if p¹(x⁹) then [P [N] [C x⁹ xs¹]] else case break1(p¹, xs¹) of {
//│ 		P ys¹ zs¹ => [P [C x⁹ ys¹] zs¹]}}
//│ def dropWhile(f⁰, ls²) = case ls² of {
//│ 	N  => [N]
//│ 	| C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}
//│ def words(s⁰) = case dropWhile((fun x¹⁰ -> (x¹⁰ == 1)), s⁰) of {
//│ 	N  => [N]
//│ 	| s'⁴ => break((fun x¹¹ -> (x¹¹ == 1)), s'⁴, 99)}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ case dropWhile((fun x⁰ -> (x⁰ == 1)), [C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]]) of {
//│ 	N  => [N]
//│ 	| s'⁰ => break((fun x¹ -> (x¹ == 1)), s'⁰, 99)}
//│ def break(p⁰, ls⁰, _lh_popOutId_0⁰) = case ls⁰ of {
//│ 	N  => 
//│ 		let s''⁰ = [N]
//│ 		in let w⁰ = [N]
//│ 		in [C w⁰ case dropWhile((fun x² -> (x² == 1)), s''⁰) of {
//│ 			N  => [N]
//│ 			| s'¹ => break((fun x³ -> (x³ == 1)), s'¹, 99)}]
//│ 	| C x⁴ xs⁰ => if p⁰(x⁴) then 
//│ 		let s''¹ = [C x⁴ xs⁰]
//│ 		in let w¹ = [N]
//│ 		in [C w¹ case dropWhile((fun x⁵ -> (x⁵ == 1)), s''¹) of {
//│ 			N  => [N]
//│ 			| s'² => break((fun x⁶ -> (x⁶ == 1)), s'², 99)}] else case break1(p⁰, xs⁰) of {
//│ 		P ys⁰ zs⁰ => 
//│ 			let s''² = zs⁰
//│ 			in let w² = [C x⁴ ys⁰]
//│ 			in [C w² case dropWhile((fun x⁷ -> (x⁷ == 1)), s''²) of {
//│ 				N  => [N]
//│ 				| s'³ => break((fun x⁸ -> (x⁸ == 1)), s'³, 99)}]}}
//│ def break1(p¹, ls¹) = case ls¹ of {
//│ 	N  => [P [N] [N]]
//│ 	| C x⁹ xs¹ => if p¹(x⁹) then [P [N] [C x⁹ xs¹]] else case break1(p¹, xs¹) of {
//│ 		P ys¹ zs¹ => [P [C x⁹ ys¹] zs¹]}}
//│ def dropWhile(f⁰, ls²) = case ls² of {
//│ 	N  => [N]
//│ 	| C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}
//│ def words(s⁰) = case dropWhile((fun x¹⁰ -> (x¹⁰ == 1)), s⁰) of {
//│ 	N  => [N]
//│ 	| s'⁴ => break((fun x¹¹ -> (x¹¹ == 1)), s'⁴, 99)}
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ words :: 'words <: [] ::: true
//│ 2 :: Int ::: false
//│ 1 :: Int ::: false
//│ 2 :: Int ::: false
//│ 1 :: Int ::: false
//│ 2 :: Int ::: false
//│ [N] :: N ::: true
//│ [C 2 [N]] :: C(Int, N) ::: true
//│ [C 1 [C 2 [N]]] :: C(Int, C(Int, N)) ::: true
//│ [C 2 [C 1 [C 2 [N]]]] :: C(Int, C(Int, C(Int, N))) ::: true
//│ [C 1 [C 2 [C 1 [C 2 [N]]]]] :: C(Int, C(Int, C(Int, C(Int, N)))) ::: true
//│ [C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]] :: C(Int, C(Int, C(Int, C(Int, C(Int, N))))) ::: true
//│ words([C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]]) :: '13_callres <: [] ::: true
//│ ls :: 'ls⁰ <: [] ::: true
//│ [N] :: N ::: true
//│ [N] :: N ::: true
//│ w :: 'w⁰ <: [] ::: true
//│ words :: 'words <: [] ::: true
//│ s'' :: 's''⁰ <: [] ::: true
//│ words(s'') :: '20_callres <: [] ::: true
//│ [C w words(s'')] :: C('w⁰, '20_callres) ::: true
//│ (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy⁰ => C('w⁰, '20_callres) ::: true
//│ let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy⁰ => C('w⁰, '20_callres) ::: true
//│ let s'' = [N]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy⁰ => C('w⁰, '20_callres) ::: true
//│ p :: 'p⁰ <: [] ::: true
//│ x :: 'x⁰ <: [] ::: true
//│ p(x) :: '27_callres <: [] ::: true
//│ x :: 'x⁰ <: [] ::: true
//│ xs :: 'xs⁰ <: [] ::: true
//│ [C x xs] :: C('x⁰, 'xs⁰) ::: true
//│ [N] :: N ::: true
//│ w :: 'w¹ <: [] ::: true
//│ words :: 'words <: [] ::: true
//│ s'' :: 's''¹ <: [] ::: true
//│ words(s'') :: '35_callres <: [] ::: true
//│ [C w words(s'')] :: C('w¹, '35_callres) ::: true
//│ (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy¹ => C('w¹, '35_callres) ::: true
//│ let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy¹ => C('w¹, '35_callres) ::: true
//│ let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy¹ => C('w¹, '35_callres) ::: true
//│ break1 :: 'break1 <: [] ::: true
//│ p :: 'p⁰ <: [] ::: true
//│ break1(p) :: '42_callres <: [] ::: true
//│ xs :: 'xs⁰ <: [] ::: true
//│ break1(p, xs) :: '44_callres <: [] ::: true
//│ zs :: 'zs⁰ <: [] ::: true
//│ x :: 'x⁰ <: [] ::: true
//│ ys :: 'ys⁰ <: [] ::: true
//│ [C x ys] :: C('x⁰, 'ys⁰) ::: true
//│ w :: 'w² <: [] ::: true
//│ words :: 'words <: [] ::: true
//│ s'' :: 's''² <: [] ::: true
//│ words(s'') :: '52_callres <: [] ::: true
//│ [C w words(s'')] :: C('w², '52_callres) ::: true
//│ (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy² => C('w², '52_callres) ::: true
//│ let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy² => C('w², '52_callres) ::: true
//│ let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy² => C('w², '52_callres) ::: true
//│ case break1(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words(s'')])} :: '57_matchres <: [] ::: true
//│ if p(x) then let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) else case break1(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words(s'')])} :: '58_ifres <: [] ::: true
//│ case ls of {N  => let s'' = [N]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) | C x xs => if p(x) then let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) else case break1(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words(s'')])}} :: '59_matchres <: [] ::: true
//│ (fun ls -> case ls of {N  => let s'' = [N]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) | C x xs => if p(x) then let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) else case break1(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words(s'')])}}) :: 'ls⁰ => '59_matchres ::: true
//│ (fun p -> (fun ls -> case ls of {N  => let s'' = [N]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) | C x xs => if p(x) then let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) else case break1(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words(s'')])}})) :: 'p⁰ => 'ls⁰ => '59_matchres ::: true
//│ ls :: 'ls¹ <: [] ::: true
//│ [N] :: N ::: true
//│ [N] :: N ::: true
//│ [P [N] [N]] :: P(N, N) ::: true
//│ p :: 'p¹ <: [] ::: true
//│ x :: 'x¹ <: [] ::: true
//│ p(x) :: '68_callres <: [] ::: true
//│ [N] :: N ::: true
//│ x :: 'x¹ <: [] ::: true
//│ xs :: 'xs¹ <: [] ::: true
//│ [C x xs] :: C('x¹, 'xs¹) ::: true
//│ [P [N] [C x xs]] :: P(N, C('x¹, 'xs¹)) ::: true
//│ break1 :: 'break1 <: [] ::: true
//│ p :: 'p¹ <: [] ::: true
//│ break1(p) :: '76_callres <: [] ::: true
//│ xs :: 'xs¹ <: [] ::: true
//│ break1(p, xs) :: '78_callres <: [] ::: true
//│ x :: 'x¹ <: [] ::: true
//│ ys :: 'ys¹ <: [] ::: true
//│ [C x ys] :: C('x¹, 'ys¹) ::: true
//│ zs :: 'zs¹ <: [] ::: true
//│ [P [C x ys] zs] :: P(C('x¹, 'ys¹), 'zs¹) ::: true
//│ case break1(p, xs) of {P ys zs => [P [C x ys] zs]} :: '84_matchres <: [] ::: true
//│ if p(x) then [P [N] [C x xs]] else case break1(p, xs) of {P ys zs => [P [C x ys] zs]} :: '85_ifres <: [] ::: true
//│ case ls of {N  => [P [N] [N]] | C x xs => if p(x) then [P [N] [C x xs]] else case break1(p, xs) of {P ys zs => [P [C x ys] zs]}} :: '86_matchres <: [] ::: true
//│ (fun ls -> case ls of {N  => [P [N] [N]] | C x xs => if p(x) then [P [N] [C x xs]] else case break1(p, xs) of {P ys zs => [P [C x ys] zs]}}) :: 'ls¹ => '86_matchres ::: true
//│ (fun p -> (fun ls -> case ls of {N  => [P [N] [N]] | C x xs => if p(x) then [P [N] [C x xs]] else case break1(p, xs) of {P ys zs => [P [C x ys] zs]}})) :: 'p¹ => 'ls¹ => '86_matchres ::: true
//│ dropWhile :: 'dropWhile <: [] ::: true
//│ == :: Destruct(Int) => Destruct(Int) => Sum[True, False] ::: true
//│ x :: 'x² <: [] ::: true
//│ ==(x) :: '92_callres <: [] ::: true
//│ 1 :: Int ::: false
//│ (x == 1) :: '94_callres <: [] ::: true
//│ (fun x -> (x == 1)) :: 'x² => '94_callres ::: true
//│ dropWhile((fun x -> (x == 1))) :: '96_callres <: [] ::: true
//│ s :: 's⁰ <: [] ::: true
//│ dropWhile((fun x -> (x == 1)), s) :: '98_callres <: [] ::: true
//│ [N] :: N ::: true
//│ break :: 'break <: [] ::: true
//│ == :: Destruct(Int) => Destruct(Int) => Sum[True, False] ::: true
//│ x :: 'x³ <: [] ::: true
//│ ==(x) :: '103_callres <: [] ::: true
//│ 1 :: Int ::: false
//│ (x == 1) :: '105_callres <: [] ::: true
//│ (fun x -> (x == 1)) :: 'x³ => '105_callres ::: true
//│ break((fun x -> (x == 1))) :: '107_callres <: [] ::: true
//│ s' :: 's'⁰ <: [] ::: true
//│ break((fun x -> (x == 1)), s') :: '109_callres <: [] ::: true
//│ 99 :: Int ::: false
//│ break((fun x -> (x == 1)), s', 99) :: '111_callres <: [] ::: true
//│ case dropWhile((fun x -> (x == 1)), s) of {N  => [N] | s' => break((fun x -> (x == 1)), s', 99)} :: '112_matchres <: [] ::: true
//│ (fun s -> case dropWhile((fun x -> (x == 1)), s) of {N  => [N] | s' => break((fun x -> (x == 1)), s', 99)}) :: 's⁰ => '112_matchres ::: true
//│ ls :: 'ls² <: [] ::: true
//│ [N] :: N ::: true
//│ f :: 'f⁰ <: [] ::: true
//│ h :: 'h⁰ <: [] ::: true
//│ f(h) :: '118_callres <: [] ::: true
//│ dropWhile :: 'dropWhile <: [] ::: true
//│ f :: 'f⁰ <: [] ::: true
//│ dropWhile(f) :: '121_callres <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ dropWhile(f, t) :: '123_callres <: [] ::: true
//│ h :: 'h⁰ <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ [C h t] :: C('h⁰, 't⁰) ::: true
//│ if f(h) then dropWhile(f, t) else [C h t] :: '127_ifres <: [] ::: true
//│ case ls of {N  => [N] | C h t => if f(h) then dropWhile(f, t) else [C h t]} :: '128_matchres <: [] ::: true
//│ (fun ls -> case ls of {N  => [N] | C h t => if f(h) then dropWhile(f, t) else [C h t]}) :: 'ls² => '128_matchres ::: true
//│ (fun f -> (fun ls -> case ls of {N  => [N] | C h t => if f(h) then dropWhile(f, t) else [C h t]})) :: 'f⁰ => 'ls² => '128_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec break1 p_1 ls_1 =
//│   (match ls_1 with
//│     | `N -> 
//│       (`P((`N), (`N)))
//│     | `C(x_1, xs_1) -> 
//│       (if (p_1 x_1) then
//│         (`P((`N), (`C(x_1, xs_1))))
//│       else
//│         (match ((break1 p_1) xs_1) with
//│           | `P(ys_1, zs_1) -> 
//│             (`P((`C(x_1, ys_1)), zs_1)))));;
//│ let rec dropWhile f_0 ls_2 =
//│   (match ls_2 with
//│     | `N -> 
//│       (`N)
//│     | `C(h_0, t_0) -> 
//│       (if (f_0 h_0) then
//│         ((dropWhile f_0) t_0)
//│       else
//│         (`C(h_0, t_0))));;
//│ let rec break p_0 ls_0 =
//│   (match ls_0 with
//│     | `N -> 
//│       (let rec s''_0 = (`N) in
//│         (let rec w_0 = (`N) in
//│           (fun _lh_dummy_0 -> 
//│             (`C(w_0, (words s''_0))))))
//│     | `C(x_0, xs_0) -> 
//│       (if (p_0 x_0) then
//│         (let rec s''_1 = (`C(x_0, xs_0)) in
//│           (let rec w_1 = (`N) in
//│             (fun _lh_dummy_1 -> 
//│               (`C(w_1, (words s''_1))))))
//│       else
//│         (match ((break1 p_0) xs_0) with
//│           | `P(ys_0, zs_0) -> 
//│             (let rec s''_2 = zs_0 in
//│               (let rec w_2 = (`C(x_0, ys_0)) in
//│                 (fun _lh_dummy_2 -> 
//│                   (`C(w_2, (words s''_2)))))))))
//│ and
//│ words s_0 =
//│   (match ((dropWhile (fun x_2 -> 
//│     (x_2 = 1))) s_0) with
//│     | `N -> 
//│       (`N)
//│     | s'_0 -> 
//│       (((break (fun x_3 -> 
//│         (x_3 = 1))) s'_0) 99));;
//│ (words (`C(2, (`C(1, (`C(2, (`C(1, (`C(2, (`N))))))))))))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│   - : [> `C of [> `C of int * ([> `C of int * 'b | `N ] as 'b) | `N ] * 'a | `N
//│     ] as 'a
//│ = `C (`C (2, `N), `C (`C (2, `N), `C (`C (2, `N), `N)))
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

