:NewParser
:ParseOnly

_LUMBERHACK_EVAL
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
inter(N)(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|inter|(|N|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; inter (N,) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^14([N], [N])
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [N]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^14]
//│ 	[inter^14 · inter^5] ---> [inter^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ inter₀([N], [N])
//│ def inter₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 33 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 30
//│ [N]: 35 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 30
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 30 --->
//│ 	[N]: 33
//│ 	[N]: 35
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter₀([N], [N])
//│ def inter₀(xs²) = 
//│ 	case xs² of {
//│ 		N  => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ inter₀(ys⁵, t¹)])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [N]
//│ <<<<<<< evaluate <<<<<<<


_LUMBERHACK_EVAL
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, N))
let l2 = C(9, C(10, N))
inter(l1)(l2)
//│ |_LUMBERHACK_EVAL|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#let| |l2| |#=| |C|(|9|,| |C|(|10|,| |N|)|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, N,),); let l2 = C (9, C (10, N,),); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^24(l1^25, l2^27)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [C 9 [C 10 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 9 [C 2 [C 10 [N]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^24]
//│ 	[inter^24 · inter^5] ---> [inter^24] (only one)
//│ [l1^25] (hopeless to continue)
//│ [l2^27] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ inter₀(l1₀, l2₀)
//│ def inter₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}
//│ def l1₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ def l2₀ = 
//│ 	[C 9 [C 10 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 31 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [C 2 [N]]: 32 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [C 1 [C 2 [N]]]: 33 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [N]: 49 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [C 10 [N]]: 50 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ [C 9 [C 10 [N]]]: 51 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 45 --->
//│ 	[N]: 31
//│ 	[C 2 [N]]: 32
//│ 	[C 1 [C 2 [N]]]: 33
//│ 	[N]: 49
//│ 	[C 10 [N]]: 50
//│ 	[C 9 [C 10 [N]]]: 51
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter₀(l1₀, l2₀)
//│ def inter₀(xs²) = 
//│ 	case xs² of {
//│ 		N  => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ inter₀(ys⁵, t¹)])}
//│ def l1₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ def l2₀ = 
//│ 	[C 9 [C 10 [N]]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 9 [C 2 [C 10 [N]]]]]
//│ <<<<<<< evaluate <<<<<<<

fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, l1))
let l2 = C(9, l2)
inter(l1)(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |l1|)|)|↵|#let| |l2| |#=| |C|(|9|,| |l2|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, l1,),); let l2 = C (9, l2,); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^22(l1^23, l2^25)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 l1^16]]
//│ def l2 = [C 9 l2^20]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^22]
//│ 	[inter^22 · inter^5] ---> [inter^22] (only one)
//│ [l1^23]
//│ 	[l1^23 · l1^16] ---> [l1^23] (only one)
//│ [l2^25]
//│ 	[l2^25 · l2^20] ---> [l2^25] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ inter₀(l1₀, l2₀)
//│ def inter₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}
//│ def l1₀ = 
//│ 	[C 1 [C 2 l1₀]]
//│ def l2₀ = 
//│ 	[C 9 l2₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 2 l1₀]: 30 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 46
//│ [C 1 [C 2 l1₀]]: 31 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 46
//│ [C 9 l2₀]: 34 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 46
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter₀(ys³, t¹)])}: 46 --->
//│ 	[C 2 l1₀]: 30
//│ 	[C 1 [C 2 l1₀]]: 31
//│ 	[C 9 l2₀]: 34
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter₀(l1₀, l2₀)
//│ def inter₀(xs²) = 
//│ 	case xs² of {
//│ 		N  => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ inter₀(ys⁵, t¹)])}
//│ def l1₀ = 
//│ 	[C 1 [C 2 l1₀]]
//│ def l2₀ = 
//│ 	[C 9 l2₀]
//│ <<<<<<< after fusion <<<<<<<


// NOTE: maybe more fusion can be done
fun f(x) = if x is
  C(a) then
    if a is
      A then N
      B then g(D(a))
fun g(y) = if y is
  D(b) then
    if b is
      A then N
      B then f(C(b))
f(C(A))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then|→|#if| |a| |is|→|A| |#then| |N|↵|B| |#then| |g|(|D|(|a|)|)|←|←|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|D|(|b|)| |#then|→|#if| |b| |is|→|A| |#then| |N|↵|B| |#then| |f|(|C|(|b|)|)|←|←|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then {if a is ‹(A) then N; (B) then g (D (a,),)›}›; fun g = y, => if y is ‹(D (b,)) then {if b is ‹(A) then N; (B) then f (C (b,),)›}›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^21([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		A  => [N]
//│ 		| B  => g^4([D a⁰])}}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => case b⁰ of {
//│ 		A  => [N]
//│ 		| B  => f^14([C b⁰])}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^21]
//│ 	[f^21 · g^4]
//│ 		[f^21 · g^4 · f^14] ---> [f^21] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C [A]])
//│ def f₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => case a¹ of {
//│ 			A  => [N]
//│ 			| B  => g₀([D a¹])}}
//│ 	where
//│ 	def g₀(y¹) = 
//│ 		case y¹ of {
//│ 			D b¹ => case b¹ of {
//│ 				A  => [N]
//│ 				| B  => f₀([C b¹])}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C b¹]: 30 --->
//│ 	case x¹ of {C a¹ => case a¹ of {A  => [N] | B  => g₀([D a¹])}}: 43
//│ [D a¹]: 40 --->
//│ 	case y¹ of {D b¹ => case b¹ of {A  => [N] | B  => f₀([C b¹])}}: 33
//│ [A]: 46 --->
//│ 	case b¹ of {A  => [N] | B  => f₀([C b¹])}: 32
//│ 	case a¹ of {A  => [N] | B  => g₀([D a¹])}: 42
//│ [C [A]]: 47 --->
//│ 	case x¹ of {C a¹ => case a¹ of {A  => [N] | B  => g₀([D a¹])}}: 43
//│ ------------------
//│ case b¹ of {A  => [N] | B  => f₀([C b¹])}: 32 --->
//│ 	[A]: 46
//│ case y¹ of {D b¹ => case b¹ of {A  => [N] | B  => f₀([C b¹])}}: 33 --->
//│ 	[D a¹]: 40
//│ case a¹ of {A  => [N] | B  => g₀([D a¹])}: 42 --->
//│ 	[A]: 46
//│ case x¹ of {C a¹ => case a¹ of {A  => [N] | B  => g₀([D a¹])}}: 43 --->
//│ 	[C b¹]: 30
//│ 	[C [A]]: 47
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀([C [A]])
//│ def f₀(x²) = 
//│ 	case x² of {
//│ 		C a¹ => case a¹ of {
//│ 			A  => [N]
//│ 			| B  => g₀([D a¹])}}
//│ 	where
//│ 	def g₀(y²) = 
//│ 		case y² of {
//│ 			D b¹ => case b¹ of {
//│ 				A  => [N]
//│ 				| B  => f₀([C b¹])}}
//│ <<<<<<< after fusion <<<<<<<


// WRONG: lazy eval?
fun c(x) = if x is
  C(a) then primitive(a) // print(a)
fun f(a) = if False then c(a) else Unit
f(C(A))
//│ |#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |primitive|(|a|)| |/* print(a)*/|←|↵|#fun| |f|(|a|)| |#=| |#if| |False| |#then| |c|(|a|)| |#else| |Unit|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun c = x, => if x is ‹(C (a,)) then primitive (a,)›; fun f = a, => if (False) then c (a,) else Unit; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^14([C [A]])
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => primitive⁰(a⁰)}
//│ def f(a¹) = if [False] then c^8(a¹) else [Unit]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^14] (hopeless to continue)
//│ 	[f^14 · c^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C [A]])
//│ def f₀(a³) = 
//│ 	if [False] then c₀(a³) else [Unit]
//│ 	where
//│ 	def c₀(x¹) = 
//│ 		case x¹ of {
//│ 			C a² => primitive⁰(a²)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 33 --->
//│ 	case x¹ of {C a² => primitive⁰(a²)}: 22
//│ ------------------
//│ case x¹ of {C a² => primitive⁰(a²)}: 22 --->
//│ 	[C [A]]: 33
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [A]]: 33 --->
//│ 	case x¹ of {C a² => primitive⁰(a²)}: 22
//│ ------------------
//│ case x¹ of {C a² => primitive⁰(a²)}: 22 --->
//│ 	[C [A]]: 33
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀(
//│ 	let a⁴ = [A]
//│ 	in (fun _lh_dummy⁰ -> primitive⁰(a⁴)))
//│ def f₀(a⁵) = 
//│ 	if [False] then c₀(a⁵) else [Unit]
//│ 	where
//│ 	def c₀(x²) = 
//│ 		x²(99)
//│ <<<<<<< after fusion <<<<<<<



// FIXME: still have type error
fun f(xs, ys) = if xs is
  N then 0
  _ then if xs is
    C(h, t) then if ys is
      C(hh, yt) then h + hh
      _ then h
    _ then error
f(C(1, N), C(2, N))
//│ |#fun| |f|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |0|↵|_| |#then| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |ys| |is|→|C|(|hh|,| |yt|)| |#then| |h| |+| |hh|↵|_| |#then| |h|←|↵|_| |#then| |error|←|←|↵|f|(|C|(|1|,| |N|)|,| |C|(|2|,| |N|)|)|
//│ Parsed: {fun f = xs, ys, => if xs is ‹(N) then 0; (_) then if xs is ‹(C (h, t,)) then if ys is ‹(C (hh, yt,)) then + (h,) (hh,); (_) then h›; (_) then error››; f (C (1, N,), C (2, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^17([C 1 [N]], [C 2 [N]])
//│ def f(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h⁰ t⁰ => case ys⁰ of {
//│ 			C hh⁰ yt⁰ => (h⁰ + hh⁰)
//│ 			| _  => h⁰}
//│ 		| _  => error⁰}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^17] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C 1 [N]], [C 2 [N]])
//│ def f₀(xs¹, ys¹) = 
//│ 	case xs¹ of {
//│ 		N  => 0
//│ 		| _  => case xs¹ of {
//│ 			C h¹ t¹ => case ys¹ of {
//│ 				C hh¹ yt¹ => (h¹ + hh¹)
//│ 				| _  => h¹}
//│ 			| _  => error⁰}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 45 --->
//│ 	case xs¹ of {C h¹ t¹ => case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹} | _  => error⁰}: 38
//│ 	case xs¹ of {N  => 0 | _  => case xs¹ of {C h¹ t¹ => case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹} | _  => error⁰}}: 39
//│ [C 2 [N]]: 49 --->
//│ 	case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹}: 36
//│ ------------------
//│ case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹}: 36 --->
//│ 	[C 2 [N]]: 49
//│ case xs¹ of {C h¹ t¹ => case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹} | _  => error⁰}: 38 --->
//│ 	[C 1 [N]]: 45
//│ case xs¹ of {N  => 0 | _  => case xs¹ of {C h¹ t¹ => case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹} | _  => error⁰}}: 39 --->
//│ 	[C 1 [N]]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 2 [N]]: 49 --->
//│ 	case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹}: 36
//│ ------------------
//│ case ys¹ of {C hh¹ yt¹ => (h¹ + hh¹) | _  => h¹}: 36 --->
//│ 	[C 2 [N]]: 49
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀([C 1 [N]], 
//│ 	let hh² = 2
//│ 	in (fun h² -> (h² + hh²)))
//│ def f₀(xs², ys²) = 
//│ 	case xs² of {
//│ 		N  => 0
//│ 		| _  => case xs² of {
//│ 			C h¹ t¹ => ys²(h¹)
//│ 			| _  => error⁰}}
//│ <<<<<<< after fusion <<<<<<<


fun f(xs) = if xs is
  N then 0
  _ then if xs is
    C(h, t) then h
    _ then error("match error")
f(C(1, N))
//│ |#fun| |f|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |0|↵|_| |#then| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |h|↵|_| |#then| |error|(|"match error"|)|←|←|↵|f|(|C|(|1|,| |N|)|)|
//│ Parsed: {fun f = xs, => if xs is ‹(N) then 0; (_) then if xs is ‹(C (h, t,)) then h; (_) then error ("match error",)››; f (C (1, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^33([C 1 [N]])
//│ def f(xs⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h⁰ t⁰ => h⁰
//│ 		| _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^33] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C 1 [N]])
//│ def f₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => 0
//│ 		| _  => case xs¹ of {
//│ 			C h¹ t¹ => h¹
//│ 			| _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 73 --->
//│ 	case xs¹ of {C h¹ t¹ => h¹ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}: 67
//│ 	case xs¹ of {N  => 0 | _  => case xs¹ of {C h¹ t¹ => h¹ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}: 68
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => h¹ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}: 67 --->
//│ 	[C 1 [N]]: 73
//│ case xs¹ of {N  => 0 | _  => case xs¹ of {C h¹ t¹ => h¹ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}: 68 --->
//│ 	[C 1 [N]]: 73
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀([C 1 [N]])
//│ def f₀(xs²) = 
//│ 	case xs² of {
//│ 		N  => 0
//│ 		| _  => case xs² of {
//│ 			C h¹ t¹ => h¹
//│ 			| _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}
//│ <<<<<<< after fusion <<<<<<<


fun f(x, y) = if x is
  N then y
  _ then y + 1
f(C(1, N), 0)
//│ |#fun| |f|(|x|,| |y|)| |#=| |#if| |x| |is|→|N| |#then| |y|↵|_| |#then| |y| |+| |1|←|↵|f|(|C|(|1|,| |N|)|,| |0|)|
//│ Parsed: {fun f = x, y, => if x is ‹(N) then y; (_) then + (y,) (1,)›; f (C (1, N,), 0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^11([C 1 [N]], 0)
//│ def f(x⁰, y⁰) = case x⁰ of {
//│ 	N  => y⁰
//│ 	| _  => (y⁰ + 1)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^11] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C 1 [N]], 0)
//│ def f₀(x¹, y¹) = 
//│ 	case x¹ of {
//│ 		N  => y¹
//│ 		| _  => (y¹ + 1)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 31 --->
//│ 	case x¹ of {N  => y¹ | _  => (y¹ + 1)}: 25
//│ ------------------
//│ case x¹ of {N  => y¹ | _  => (y¹ + 1)}: 25 --->
//│ 	[C 1 [N]]: 31
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀([C 1 [N]], 0)
//│ def f₀(x², y²) = 
//│ 	case x² of {
//│ 		N  => y²
//│ 		| _  => (y² + 1)}
//│ <<<<<<< after fusion <<<<<<<


// NOTE: after registering wildcard and id match, no type error
fun zip(xs, ys) = if xs is
  N then N
  _ then if ys is
    N then N
    _ then if xs is
      C(xs, xt) then if ys is
        C(ys, yt) then C(P2(xs, ys), zip(xt, yt))
        _ then N
      _ then N
zip(C(1,N), C(2,N))
//│ |#fun| |zip|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |N|↵|_| |#then| |#if| |ys| |is|→|N| |#then| |N|↵|_| |#then| |#if| |xs| |is|→|C|(|xs|,| |xt|)| |#then| |#if| |ys| |is|→|C|(|ys|,| |yt|)| |#then| |C|(|P2|(|xs|,| |ys|)|,| |zip|(|xt|,| |yt|)|)|↵|_| |#then| |N|←|↵|_| |#then| |N|←|←|←|↵|zip|(|C|(|1|,|N|)|,| |C|(|2|,|N|)|)|
//│ Parsed: {fun zip = xs, ys, => if xs is ‹(N) then N; (_) then if ys is ‹(N) then N; (_) then if xs is ‹(C (xs, xt,)) then if ys is ‹(C (ys, yt,)) then C (P2 (xs, ys,), zip (xt, yt,),); (_) then N›; (_) then N›››; zip (C (1, N,), C (2, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ zip^24([C 1 [N]], [C 2 [N]])
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => [N]
//│ 	| _  => case ys⁰ of {
//│ 		N  => [N]
//│ 		| _  => case xs⁰ of {
//│ 			C xs¹ xt⁰ => case ys⁰ of {
//│ 				C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip^10(xt⁰, yt⁰)]
//│ 				| _  => [N]}
//│ 			| _  => [N]}}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [zip^24]
//│ 	[zip^24 · zip^10] ---> [zip^24] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ zip₀([C 1 [N]], [C 2 [N]])
//│ def zip₀(xs², ys²) = 
//│ 	case xs² of {
//│ 		N  => [N]
//│ 		| _  => case ys² of {
//│ 			N  => [N]
//│ 			| _  => case xs² of {
//│ 				C xs³ xt¹ => case ys² of {
//│ 					C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)]
//│ 					| _  => [N]}
//│ 				| _  => [N]}}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 58 --->
//│ 	case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}: 51
//│ 	case xs² of {N  => [N] | _  => case ys² of {N  => [N] | _  => case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}}}: 53
//│ [C 1 [N]]: 59 --->
//│ 	case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}: 51
//│ 	case xs² of {N  => [N] | _  => case ys² of {N  => [N] | _  => case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}}}: 53
//│ [N]: 62 --->
//│ 	case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]}: 49
//│ 	case ys² of {N  => [N] | _  => case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}}: 52
//│ [C 2 [N]]: 63 --->
//│ 	case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]}: 49
//│ 	case ys² of {N  => [N] | _  => case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}}: 52
//│ ------------------
//│ case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]}: 49 --->
//│ 	[N]: 62
//│ 	[C 2 [N]]: 63
//│ case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}: 51 --->
//│ 	[N]: 58
//│ 	[C 1 [N]]: 59
//│ case ys² of {N  => [N] | _  => case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}}: 52 --->
//│ 	[N]: 62
//│ 	[C 2 [N]]: 63
//│ case xs² of {N  => [N] | _  => case ys² of {N  => [N] | _  => case xs² of {C xs³ xt¹ => case ys² of {C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)] | _  => [N]} | _  => [N]}}}: 53 --->
//│ 	[N]: 58
//│ 	[C 1 [N]]: 59
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ zip₀([C 1 [N]], [C 2 [N]])
//│ def zip₀(xs⁴, ys⁴) = 
//│ 	case xs⁴ of {
//│ 		N  => [N]
//│ 		| _  => case ys⁴ of {
//│ 			N  => [N]
//│ 			| _  => case xs⁴ of {
//│ 				C xs³ xt¹ => case ys⁴ of {
//│ 					C ys³ yt¹ => [C [P2 xs³ ys³] zip₀(xt¹, yt¹)]
//│ 					| _  => [N]}
//│ 				| _  => [N]}}}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: type error: f x = x f cannot be well typed in haskell
fun f(x) =
  (
    if x is
      C(h, t) then ff => C(h, ff(t))
      N then ff => N
  )(f)
f(C(3, N))
//│ |#fun| |f|(|x|)| |#=|→|(|→|#if| |x| |is|→|C|(|h|,| |t|)| |#then| |ff| |=>| |C|(|h|,| |ff|(|t|)|)|↵|N| |#then| |ff| |=>| |N|←|←|↵|)|(|f|)|←|↵|f|(|C|(|3|,| |N|)|)|
//│ Parsed: {fun f = x, => {'(' if x is ‹(C (h, t,)) then ff, => C (h, ff (t,),); (N) then ff, => N›, ')' (f,)}; f (C (3, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^14([C 3 [N]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C h⁰ t⁰ => (fun ff⁰ -> [C h⁰ ff⁰(t⁰)])
//│ 	| N  => (fun ff¹ -> [N])}(f^11)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^14]
//│ 	[f^14 · f^11] ---> [f^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C 3 [N]])
//│ def f₀(x¹) = 
//│ 	case x¹ of {
//│ 		C h¹ t¹ => (fun ff² -> [C h¹ ff²(t¹)])
//│ 		| N  => (fun ff³ -> [N])}(f₀)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 34 --->
//│ 	case x¹ of {C h¹ t¹ => (fun ff² -> [C h¹ ff²(t¹)]) | N  => (fun ff³ -> [N])}: 28
//│ [C 3 [N]]: 35 --->
//│ 	case x¹ of {C h¹ t¹ => (fun ff² -> [C h¹ ff²(t¹)]) | N  => (fun ff³ -> [N])}: 28
//│ ------------------
//│ case x¹ of {C h¹ t¹ => (fun ff² -> [C h¹ ff²(t¹)]) | N  => (fun ff³ -> [N])}: 28 --->
//│ 	[N]: 34
//│ 	[C 3 [N]]: 35
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 34 --->
//│ 	case x¹ of {C h¹ t¹ => (fun ff² -> [C h¹ ff²(t¹)]) | N  => (fun ff³ -> [N])}: 28
//│ [C 3 [N]]: 35 --->
//│ 	case x¹ of {C h¹ t¹ => (fun ff² -> [C h¹ ff²(t¹)]) | N  => (fun ff³ -> [N])}: 28
//│ ------------------
//│ case x¹ of {C h¹ t¹ => (fun ff² -> [C h¹ ff²(t¹)]) | N  => (fun ff³ -> [N])}: 28 --->
//│ 	[N]: 34
//│ 	[C 3 [N]]: 35
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀(
//│ 	let h² = 3
//│ 	in let t² = (fun _lh_dummy¹ -> (fun ff⁵ -> [N]))
//│ 	in (fun _lh_dummy⁰ -> (fun ff⁴ -> [C h² ff⁴(t²)])))
//│ def f₀(x²) = 
//│ 	x²(99, f₀)
//│ <<<<<<< after fusion <<<<<<<

// a more minimal example requiring recursive type after fusion
fun f(x) =
  (
    if x is
      N then ff => 1
  )(f)
f(N)
//│ |#fun| |f|(|x|)| |#=|→|(|→|#if| |x| |is|→|N| |#then| |ff| |=>| |1|←|←|↵|)|(|f|)|←|↵|f|(|N|)|
//│ Parsed: {fun f = x, => {'(' if x is ‹(N) then ff, => 1›, ')' (f,)}; f (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^8([N])
//│ def f(x⁰) = case x⁰ of {
//│ 	N  => (fun ff⁰ -> 1)}(f^5)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^8] (hopeless to continue)
//│ 	[f^8 · f^5] ---> [f^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([N])
//│ def f₀(x¹) = 
//│ 	case x¹ of {
//│ 		N  => (fun ff¹ -> 1)}(f₀)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 19 --->
//│ 	case x¹ of {N  => (fun ff¹ -> 1)}: 14
//│ ------------------
//│ case x¹ of {N  => (fun ff¹ -> 1)}: 14 --->
//│ 	[N]: 19
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 19 --->
//│ 	case x¹ of {N  => (fun ff¹ -> 1)}: 14
//│ ------------------
//│ case x¹ of {N  => (fun ff¹ -> 1)}: 14 --->
//│ 	[N]: 19
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀((fun _lh_dummy⁰ -> (fun ff² -> 1)))
//│ def f₀(x²) = 
//│ 	x²(99, f₀)
//│ <<<<<<< after fusion <<<<<<<





:lhError
:lhGenOCaml
:d
fun dropWhile(p, ls) = if ls is
  N then N
  C(h,t) then if p(h) then dropWhile(p, t) else C(h,t)
fun fromTo(a, b) = if a > b then N else C(a, fromTo(a + 1, b))
fun f(x) = Pair(f(C(1, N)), f(x))
f(dropWhile(x => False, C(1, N)))
//│ |#fun| |dropWhile|(|p|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|h|,|t|)| |#then| |#if| |p|(|h|)| |#then| |dropWhile|(|p|,| |t|)| |#else| |C|(|h|,|t|)|←|↵|#fun| |fromTo|(|a|,| |b|)| |#=| |#if| |a| |>| |b| |#then| |N| |#else| |C|(|a|,| |fromTo|(|a| |+| |1|,| |b|)|)|↵|#fun| |f|(|x|)| |#=| |Pair|(|f|(|C|(|1|,| |N|)|)|,| |f|(|x|)|)|↵|f|(|dropWhile|(|x| |=>| |False|,| |C|(|1|,| |N|)|)|)|
//│ Parsed: {fun dropWhile = p, ls, => if ls is ‹(N) then N; (C (h, t,)) then if (p (h,)) then dropWhile (p, t,) else C (h, t,)›; fun fromTo = a, b, => if (> (a,) (b,)) then N else C (a, fromTo (+ (a,) (1,), b,),); fun f = x, => Pair (f (C (1, N,),), f (x,),); f (dropWhile (x, => False, C (1, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^48(dropWhile^49((fun x¹ -> [False]), [C 1 [N]]))
//│ def dropWhile(p⁰, ls⁰) = case ls⁰ of {
//│ 	N  => [N]
//│ 	| C h⁰ t⁰ => if p⁰(h⁰) then dropWhile^6(p⁰, t⁰) else [C h⁰ t⁰]}
//│ def f(x⁰) = [Pair f^38([C 1 [N]]) f^43(x⁰)]
//│ def fromTo(a⁰, b⁰) = if (a⁰ > b⁰) then [N] else [C a⁰ fromTo^25((a⁰ + 1), b⁰)]
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec dropWhile p_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (p_0 h_0) then
//│ 		        ((dropWhile p_0) t_0)
//│ 		      else
//│ 		        (`C(h_0, t_0))))
//│ 		and f x_0 =
//│ 		  (`Pair((f (`C(1, (`N)))), (f x_0)))
//│ 		and fromTo a_0 b_0 =
//│ 		  (if (a_0 > b_0) then
//│ 		    (`N)
//│ 		  else
//│ 		    (`C(a_0, ((fromTo (a_0 + 1)) b_0))));;
//│ 		(f ((dropWhile (fun x_1 -> 
//│ 		  false)) (`C(1, (`N)))))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		                              val dropWhile :
//│ 		  ('a -> bool) -> ([< `C of 'a * 'b | `N ] as 'b) -> [> `C of 'a * 'b | `N ] =
//│ 		  <fun>
//│ 		val f : [> `C of int * [> `N ] ] -> ([> `Pair of 'a * 'a ] as 'a) = <fun>
//│ 		val fromTo : int -> int -> ([> `C of int * 'a | `N ] as 'a) = <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [dropWhile^49] (hopeless to continue)
//│ 	[dropWhile^49 · dropWhile^6] ---> [dropWhile^49] (using original def)
//│ [f^48]
//│ 	[f^48 · f^38] ---> [f^48] (only one)
//│ 	[f^48 · f^43] ---> [f^48] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀(dropWhile₀((fun x³ -> [False]), [C 1 [N]]))
//│ def dropWhile₀(p¹, ls¹) = 
//│ 	case ls¹ of {
//│ 		N  => [N]
//│ 		| C h¹ t¹ => if p¹(h¹) then dropWhile₀(p¹, t¹) else [C h¹ t¹]}
//│ def f₀(x²) = 
//│ 	[Pair f₀([C 1 [N]]) f₀(x²)]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 91 --->
//│ 	case ls¹ of {N  => [N] | C h¹ t¹ => if p¹(h¹) then dropWhile₀(p¹, t¹) else [C h¹ t¹]}: 82
//│ [C 1 [N]]: 92 --->
//│ 	case ls¹ of {N  => [N] | C h¹ t¹ => if p¹(h¹) then dropWhile₀(p¹, t¹) else [C h¹ t¹]}: 82
//│ ------------------
//│ case ls¹ of {N  => [N] | C h¹ t¹ => if p¹(h¹) then dropWhile₀(p¹, t¹) else [C h¹ t¹]}: 82 --->
//│ 	[N]: 91
//│ 	[C 1 [N]]: 92
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 91 --->
//│ 	case ls¹ of {N  => [N] | C h¹ t¹ => if p¹(h¹) then dropWhile₀(p¹, t¹) else [C h¹ t¹]}: 82
//│ [C 1 [N]]: 92 --->
//│ 	case ls¹ of {N  => [N] | C h¹ t¹ => if p¹(h¹) then dropWhile₀(p¹, t¹) else [C h¹ t¹]}: 82
//│ ------------------
//│ case ls¹ of {N  => [N] | C h¹ t¹ => if p¹(h¹) then dropWhile₀(p¹, t¹) else [C h¹ t¹]}: 82 --->
//│ 	[N]: 91
//│ 	[C 1 [N]]: 92
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀(dropWhile₀((fun x⁴ -> [False]), 
//│ 	let h² = 1
//│ 	in let t² = (fun p³ -> [N])
//│ 	in (fun p² -> if p²(h²) then dropWhile₀(p², t²) else [C h² t²])))
//│ def dropWhile₀(p⁴, ls²) = 
//│ 	ls²(p⁴)
//│ def f₀(x⁵) = 
//│ 	[Pair f₀([C 1 [N]]) f₀(x⁵)]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec dropWhile_d0 p_2 ls_0 =
//│   (ls_0 p_2)
//│ and f_d0 x_1 =
//│   (`Pair((f_d0 (`C(1, (`N)))), (f_d0 x_1)));;
//│ (f_d0 ((dropWhile_d0 (fun x_0 -> 
//│   false)) (let rec h_0 = 1 in
//│   (let rec t_0 = (fun p_0 -> 
//│     (`N)) in
//│     (fun p_1 -> 
//│       (if (p_1 h_0) then
//│         ((dropWhile_d0 p_1) t_0)
//│       else
//│         (`C(h_0, t_0))))))))
//│ 
//│ --------------- ocaml repl result -----------------
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception:                   Lines 2-10, characters 6-27:
//│  2 | ......((dropWhile_d0 (fun x_0 -> 
//│  3 |   false)) (let rec h_0 = 1 in
//│  4 |   (let rec t_0 = (fun p_0 -> 
//│  5 |     (`N)) in
//│  6 |     (fun p_1 -> 
//│  7 |       (if (p_1 h_0) then
//│  8 |         ((dropWhile_d0 p_1) t_0)
//│  9 |       else
//│ 10 |         (`C(h_0, t_0)))))))...
//│ Error: This expression has type [> `C of int * ('a -> [> `N ]) | `N ]
//│        but an expression was expected of type [> `C of int * [> `N ] ]
//│        Types for tag `C are incompatible
//│ !!!!!!ERROR!!!!!!


:lhError
:lhGenOCaml
:lhNoIter
:d
fun break(ls) = if ls is
  N then
    let fst = N
    let snd = N
    C(fst, words1(snd))
  C(h,t) then
    let fst = N
    let snd = C(h,t)
    C(fst, words1(snd))
fun dropWhile(p, ls) = if ls is
  N then N
  C(h,t) then if p(h) then dropWhile(p, t) else C(h,t)
fun words0(ls) =
  let mident = dropWhile(x => False, ls)
  if mident is
    N then N
    _ then break(mident)
fun words1(ls) =
  let mident = dropWhile(x => False, ls)
  if mident is
    N then N
    _ then break(mident)
(x => 2)(words0)
//│ |#fun| |break|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then|→|#let| |fst| |#=| |N|↵|#let| |snd| |#=| |N|↵|C|(|fst|,| |words1|(|snd|)|)|←|↵|C|(|h|,|t|)| |#then|→|#let| |fst| |#=| |N|↵|#let| |snd| |#=| |C|(|h|,|t|)|↵|C|(|fst|,| |words1|(|snd|)|)|←|←|↵|#fun| |dropWhile|(|p|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|h|,|t|)| |#then| |#if| |p|(|h|)| |#then| |dropWhile|(|p|,| |t|)| |#else| |C|(|h|,|t|)|←|↵|#fun| |words0|(|ls|)| |#=|→|#let| |mident| |#=| |dropWhile|(|x| |=>| |False|,| |ls|)|↵|#if| |mident| |is|→|N| |#then| |N|↵|_| |#then| |break|(|mident|)|←|←|↵|#fun| |words1|(|ls|)| |#=|→|#let| |mident| |#=| |dropWhile|(|x| |=>| |False|,| |ls|)|↵|#if| |mident| |is|→|N| |#then| |N|↵|_| |#then| |break|(|mident|)|←|←|↵|(|x| |=>| |2|)|(|words0|)|
//│ Parsed: {fun break = ls, => if ls is ‹(N) then {let fst = N; let snd = N; C (fst, words1 (snd,),)}; (C (h, t,)) then {let fst = N; let snd = C (h, t,); C (fst, words1 (snd,),)}›; fun dropWhile = p, ls, => if ls is ‹(N) then N; (C (h, t,)) then if (p (h,)) then dropWhile (p, t,) else C (h, t,)›; fun words0 = ls, => {let mident = dropWhile (x, => False, ls,); if mident is ‹(N) then N; (_) then break (mident,)›}; fun words1 = ls, => {let mident = dropWhile (x, => False, ls,); if mident is ‹(N) then N; (_) then break (mident,)›}; '(' x, => 2, ')' (words0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (fun x² -> 2)(words0^71)
//│ def break(ls⁰) = case ls⁰ of {
//│ 	N  => 
//│ 		let fst⁰ = [N]
//│ 		in let snd⁰ = [N]
//│ 		in [C fst⁰ words1^5(snd⁰)]
//│ 	| C h⁰ t⁰ => 
//│ 		let fst¹ = [N]
//│ 		in let snd¹ = [C h⁰ t⁰]
//│ 		in [C fst¹ words1^16(snd¹)]}
//│ def dropWhile(p⁰, ls¹) = case ls¹ of {
//│ 	N  => [N]
//│ 	| C h¹ t¹ => if p⁰(h¹) then dropWhile^29(p⁰, t¹) else [C h¹ t¹]}
//│ def words0(ls²) = 
//│ 	let mident⁰ = dropWhile^41((fun x⁰ -> [False]), ls²)
//│ 	in case mident⁰ of {
//│ 		N  => [N]
//│ 		| _  => break^49(mident⁰)}
//│ def words1(ls³) = 
//│ 	let mident¹ = dropWhile^55((fun x¹ -> [False]), ls³)
//│ 	in case mident¹ of {
//│ 		N  => [N]
//│ 		| _  => break^63(mident¹)}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec break ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (let rec fst_0 = (`N) in
//│ 		        (let rec snd_0 = (`N) in
//│ 		          (`C(fst_0, (words1 snd_0)))))
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (let rec fst_1 = (`N) in
//│ 		        (let rec snd_1 = (`C(h_0, t_0)) in
//│ 		          (`C(fst_1, (words1 snd_1))))))
//│ 		and dropWhile p_0 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (if (p_0 h_1) then
//│ 		        ((dropWhile p_0) t_1)
//│ 		      else
//│ 		        (`C(h_1, t_1))))
//│ 		and words0 ls_2 =
//│ 		  (let rec mident_0 = ((dropWhile (fun x_0 -> 
//│ 		    false)) ls_2) in
//│ 		    (match mident_0 with
//│ 		      | `N -> 
//│ 		        (`N)
//│ 		      | _ -> 
//│ 		        (break mident_0)))
//│ 		and words1 ls_3 =
//│ 		  (let rec mident_1 = ((dropWhile (fun x_1 -> 
//│ 		    false)) ls_3) in
//│ 		    (match mident_1 with
//│ 		      | `N -> 
//│ 		        (`N)
//│ 		      | _ -> 
//│ 		        (break mident_1)));;
//│ 		((fun x_2 -> 
//│ 		  2) words0)
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		                                                                    val break :
//│ 		  [ `C of 'a * ([ `C of 'a * 'b | `N ] as 'b) | `N ] ->
//│ 		  ([> `C of [> `N ] * 'c | `N ] as 'c) = <fun>
//│ 		val dropWhile :
//│ 		  ('a -> bool) -> ([ `C of 'a * 'b | `N ] as 'b) -> [ `C of 'a * 'b | `N ] =
//│ 		  <fun>
//│ 		val words0 :
//│ 		  ([ `C of 'b * 'a | `N ] as 'a) -> ([> `C of [> `N ] * 'c | `N ] as 'c) =
//│ 		  <fun>
//│ 		val words1 :
//│ 		  ([ `C of 'b * 'a | `N ] as 'a) -> ([> `C of [> `N ] * 'c | `N ] as 'c) =
//│ 		  <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [words0^71] (hopeless to continue)
//│ 	[words0^71 · break^49] (using original def)
//│ 		[words0^71 · break^49 · words1^16] (using original def)
//│ 			[words0^71 · break^49 · words1^16 · break^63] ---> [words0^71 · break^49] (using original def)
//│ 			[words0^71 · break^49 · words1^16 · dropWhile^55] (using original def)
//│ 				[words0^71 · break^49 · words1^16 · dropWhile^55 · dropWhile^29] ---> [words0^71 · break^49 · words1^16 · dropWhile^55] (using original def)
//│ 		[words0^71 · break^49 · words1^5] (using original def)
//│ 			[words0^71 · break^49 · words1^5 · break^63] ---> [words0^71 · break^49] (using original def)
//│ 			[words0^71 · break^49 · words1^5 · dropWhile^55] (using original def)
//│ 				[words0^71 · break^49 · words1^5 · dropWhile^55 · dropWhile^29] ---> [words0^71 · break^49 · words1^5 · dropWhile^55] (using original def)
//│ 	[words0^71 · dropWhile^41] (using original def)
//│ 		[words0^71 · dropWhile^41 · dropWhile^29] ---> [words0^71 · dropWhile^41] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (fun x⁶ -> 2)(words0₀)
//│ def words0₀(ls⁴) = 
//│ 	let mident² = dropWhile₂((fun x³ -> [False]), ls⁴)
//│ 	in case mident² of {
//│ 		N  => [N]
//│ 		| _  => break₀(mident²)}
//│ 	where
//│ 	def break₀(ls⁸) = 
//│ 		case ls⁸ of {
//│ 			N  => 
//│ 				let fst² = [N]
//│ 				in let snd² = [N]
//│ 				in [C fst² words1₁(snd²)]
//│ 			| C h⁴ t⁴ => 
//│ 				let fst³ = [N]
//│ 				in let snd³ = [C h⁴ t⁴]
//│ 				in [C fst³ words1₀(snd³)]}
//│ 		where
//│ 		def words1₀(ls¹⁰) = 
//│ 			let mident⁴ = dropWhile₀((fun x⁵ -> [False]), ls¹⁰)
//│ 			in case mident⁴ of {
//│ 				N  => [N]
//│ 				| _  => break₀(mident⁴)}
//│ 			where
//│ 			def dropWhile₀(p³, ls⁹) = 
//│ 				case ls⁹ of {
//│ 					N  => [N]
//│ 					| C h⁵ t⁵ => if p³(h⁵) then dropWhile₀(p³, t⁵) else [C h⁵ t⁵]}
//│ 		def words1₁(ls⁵) = 
//│ 			let mident³ = dropWhile₁((fun x⁴ -> [False]), ls⁵)
//│ 			in case mident³ of {
//│ 				N  => [N]
//│ 				| _  => break₀(mident³)}
//│ 			where
//│ 			def dropWhile₁(p¹, ls⁶) = 
//│ 				case ls⁶ of {
//│ 					N  => [N]
//│ 					| C h² t² => if p¹(h²) then dropWhile₁(p¹, t²) else [C h² t²]}
//│ 	def dropWhile₂(p², ls⁷) = 
//│ 		case ls⁷ of {
//│ 			N  => [N]
//│ 			| C h³ t³ => if p²(h³) then dropWhile₂(p², t³) else [C h³ t³]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 102 --->
//│ 	case mident³ of {N  => [N] | _  => break₀(mident³)}: 98
//│ 	case ls⁸ of {N  => let fst² = [N]
//│ in let snd² = [N]
//│ in [C fst² words1₁(snd²)] | C h⁴ t⁴ => let fst³ = [N]
//│ in let snd³ = [C h⁴ t⁴]
//│ in [C fst³ words1₀(snd³)]}: 156
//│ [C h² t²]: 113 --->
//│ 	case mident³ of {N  => [N] | _  => break₀(mident³)}: 98
//│ 	case ls⁸ of {N  => let fst² = [N]
//│ in let snd² = [N]
//│ in [C fst² words1₁(snd²)] | C h⁴ t⁴ => let fst³ = [N]
//│ in let snd³ = [C h⁴ t⁴]
//│ in [C fst³ words1₀(snd³)]}: 156
//│ [N]: 119 --->
//│ 	case mident² of {N  => [N] | _  => break₀(mident²)}: 84
//│ 	case ls⁸ of {N  => let fst² = [N]
//│ in let snd² = [N]
//│ in [C fst² words1₁(snd²)] | C h⁴ t⁴ => let fst³ = [N]
//│ in let snd³ = [C h⁴ t⁴]
//│ in [C fst³ words1₀(snd³)]}: 156
//│ [C h³ t³]: 130 --->
//│ 	case mident² of {N  => [N] | _  => break₀(mident²)}: 84
//│ 	case ls⁸ of {N  => let fst² = [N]
//│ in let snd² = [N]
//│ in [C fst² words1₁(snd²)] | C h⁴ t⁴ => let fst³ = [N]
//│ in let snd³ = [C h⁴ t⁴]
//│ in [C fst³ words1₀(snd³)]}: 156
//│ [N]: 137 --->
//│ 	case ls⁶ of {N  => [N] | C h² t² => if p¹(h²) then dropWhile₁(p¹, t²) else [C h² t²]}: 115
//│ [C h⁴ t⁴]: 148 --->
//│ 	case ls⁹ of {N  => [N] | C h⁵ t⁵ => if p³(h⁵) then dropWhile₀(p³, t⁵) else [C h⁵ t⁵]}: 172
//│ [N]: 159 --->
//│ 	case ls⁸ of {N  => let fst² = [N]
//│ in let snd² = [N]
//│ in [C fst² words1₁(snd²)] | C h⁴ t⁴ => let fst³ = [N]
//│ in let snd³ = [C h⁴ t⁴]
//│ in [C fst³ words1₀(snd³)]}: 156
//│ 	case mident⁴ of {N  => [N] | _  => break₀(mident⁴)}: 186
//│ [C h⁵ t⁵]: 170 --->
//│ 	case ls⁸ of {N  => let fst² = [N]
//│ in let snd² = [N]
//│ in [C fst² words1₁(snd²)] | C h⁴ t⁴ => let fst³ = [N]
//│ in let snd³ = [C h⁴ t⁴]
//│ in [C fst³ words1₀(snd³)]}: 156
//│ 	case mident⁴ of {N  => [N] | _  => break₀(mident⁴)}: 186
//│ ------------------
//│ case mident² of {N  => [N] | _  => break₀(mident²)}: 84 --->
//│ 	[N]: 119
//│ 	[C h³ t³]: 130
//│ case mident³ of {N  => [N] | _  => break₀(mident³)}: 98 --->
//│ 	[N]: 102
//│ 	[C h² t²]: 113
//│ case ls⁶ of {N  => [N] | C h² t² => if p¹(h²) then dropWhile₁(p¹, t²) else [C h² t²]}: 115 --->
//│ 	[N]: 137
//│ case ls⁸ of {N  => let fst² = [N]
//│ in let snd² = [N]
//│ in [C fst² words1₁(snd²)] | C h⁴ t⁴ => let fst³ = [N]
//│ in let snd³ = [C h⁴ t⁴]
//│ in [C fst³ words1₀(snd³)]}: 156 --->
//│ 	[N]: 102
//│ 	[C h² t²]: 113
//│ 	[N]: 119
//│ 	[C h³ t³]: 130
//│ 	[N]: 159
//│ 	[C h⁵ t⁵]: 170
//│ case ls⁹ of {N  => [N] | C h⁵ t⁵ => if p³(h⁵) then dropWhile₀(p³, t⁵) else [C h⁵ t⁵]}: 172 --->
//│ 	[C h⁴ t⁴]: 148
//│ case mident⁴ of {N  => [N] | _  => break₀(mident⁴)}: 186 --->
//│ 	[N]: 159
//│ 	[C h⁵ t⁵]: 170
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 137 --->
//│ 	case ls⁶ of {N  => [N] | C h² t² => if p¹(h²) then dropWhile₁(p¹, t²) else [C h² t²]}: 115
//│ [C h⁴ t⁴]: 148 --->
//│ 	case ls⁹ of {N  => [N] | C h⁵ t⁵ => if p³(h⁵) then dropWhile₀(p³, t⁵) else [C h⁵ t⁵]}: 172
//│ ------------------
//│ case ls⁶ of {N  => [N] | C h² t² => if p¹(h²) then dropWhile₁(p¹, t²) else [C h² t²]}: 115 --->
//│ 	[N]: 137
//│ case ls⁹ of {N  => [N] | C h⁵ t⁵ => if p³(h⁵) then dropWhile₀(p³, t⁵) else [C h⁵ t⁵]}: 172 --->
//│ 	[C h⁴ t⁴]: 148
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (fun x⁷ -> 2)(words0₀)
//│ def words0₀(ls¹²) = 
//│ 	let mident⁶ = dropWhile₂((fun x⁹ -> [False]), ls¹²)
//│ 	in case mident⁶ of {
//│ 		N  => [N]
//│ 		| _  => break₀(mident⁶)}
//│ 	where
//│ 	def break₀(ls¹⁷) = 
//│ 		case ls¹⁷ of {
//│ 			N  => 
//│ 				let fst⁴ = [N]
//│ 				in let snd⁴ = (fun p⁷ -> [N])
//│ 				in [C fst⁴ words1₁(snd⁴)]
//│ 			| C h⁴ t⁴ => 
//│ 				let fst⁵ = [N]
//│ 				in let snd⁵ = 	
//│ 					let h⁶ = h⁴
//│ 					in let t⁶ = t⁴
//│ 					in (fun p⁸ -> if p⁸(h⁶) then dropWhile₀(p⁸, t⁶) else [C h⁶ t⁶])
//│ 				in [C fst⁵ words1₀(snd⁵)]}
//│ 		where
//│ 		def words1₀(ls¹⁴) = 
//│ 			let mident⁷ = dropWhile₀((fun x¹⁰ -> [False]), ls¹⁴)
//│ 			in case mident⁷ of {
//│ 				N  => [N]
//│ 				| _  => break₀(mident⁷)}
//│ 			where
//│ 			def dropWhile₀(p⁵, ls¹⁵) = 
//│ 				ls¹⁵(p⁵)
//│ 		def words1₁(ls¹¹) = 
//│ 			let mident⁵ = dropWhile₁((fun x⁸ -> [False]), ls¹¹)
//│ 			in case mident⁵ of {
//│ 				N  => [N]
//│ 				| _  => break₀(mident⁵)}
//│ 			where
//│ 			def dropWhile₁(p⁶, ls¹⁶) = 
//│ 				ls¹⁶(p⁶)
//│ 	def dropWhile₂(p⁴, ls¹³) = 
//│ 		case ls¹³ of {
//│ 			N  => [N]
//│ 			| C h³ t³ => if p⁴(h³) then dropWhile₂(p⁴, t³) else [C h³ t³]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec break_d0 ls_6 =
//│   (match ls_6 with
//│     | `N -> 
//│       (let rec fst_0 = (`N) in
//│         (let rec snd_0 = (fun p_3 -> 
//│           (`N)) in
//│           (`C(fst_0, (words1_d1 snd_0)))))
//│     | `C(h_1, t_1) -> 
//│       (let rec fst_1 = (`N) in
//│         (let rec snd_1 = (let rec h_2 = h_1 in
//│           (let rec t_2 = t_1 in
//│             (fun p_4 -> 
//│               (if (p_4 h_2) then
//│                 ((dropWhile_d0 p_4) t_2)
//│               else
//│                 (`C(h_2, t_2)))))) in
//│           (`C(fst_1, (words1_d0 snd_1))))))
//│ and dropWhile_d0 p_1 ls_4 =
//│   (ls_4 p_1)
//│ and dropWhile_d1 p_2 ls_5 =
//│   (ls_5 p_2)
//│ and dropWhile_d2 p_0 ls_2 =
//│   (match ls_2 with
//│     | `N -> 
//│       (`N)
//│     | `C(h_0, t_0) -> 
//│       (if (p_0 h_0) then
//│         ((dropWhile_d2 p_0) t_0)
//│       else
//│         (`C(h_0, t_0))))
//│ and words0_d0 ls_1 =
//│   (let rec mident_1 = ((dropWhile_d2 (fun x_2 -> 
//│     false)) ls_1) in
//│     (match mident_1 with
//│       | `N -> 
//│         (`N)
//│       | _ -> 
//│         (break_d0 mident_1)))
//│ and words1_d0 ls_3 =
//│   (let rec mident_2 = ((dropWhile_d0 (fun x_3 -> 
//│     false)) ls_3) in
//│     (match mident_2 with
//│       | `N -> 
//│         (`N)
//│       | _ -> 
//│         (break_d0 mident_2)))
//│ and words1_d1 ls_0 =
//│   (let rec mident_0 = ((dropWhile_d1 (fun x_1 -> 
//│     false)) ls_0) in
//│     (match mident_0 with
//│       | `N -> 
//│         (`N)
//│       | _ -> 
//│         (break_d0 mident_0)));;
//│ ((fun x_0 -> 
//│   2) words0_d0)
//│ 
//│ --------------- ocaml repl result -----------------
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception:                                                                                                           Line 38, characters 18-26:
//│ 38 |         (break_d0 mident_1)))
//│                        ^^^^^^^^
//│ Error: This expression has type
//│          [> `C of 'a * ([< `C of 'a * 'b | `N ] as 'b) | `N ]
//│        but an expression was expected of type
//│          [< `C of 'a * (('a -> bool) -> [> `C of 'a * 'c ] as 'c) | `N > `N ]
//│        Types for tag `C are incompatible
//│ !!!!!!ERROR!!!!!!
