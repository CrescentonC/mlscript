:NewParser
:ParseOnly


// WRONG: Initial program, not immediately fusable:
// _LUMBERHACK_ERROR
_LUMBERHACK_EVAL
fun count(c, xs) = if xs is
  C(h, t) then count(c + 1, t)
  N then c
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
count(0, rev(N, N))
//│ |_LUMBERHACK_EVAL|↵|#fun| |count|(|c|,| |xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |count|(|c| |+| |1|,| |t|)|↵|N| |#then| |c|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|count|(|0|,| |rev|(|N|,| |N|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun count = c, xs, => if xs is ‹(C (h, t,)) then count (+ (c,) (1,), t,); (N) then c›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; count (0, rev (N, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ count^27(0, rev^30([N], [N]))
//│ def count(c⁰, xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => count^2((c⁰ + 1), t⁰)
//│ 	| N  => c⁰}
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev^16([C h1⁰ a⁰], t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 0
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1⁰ a⁰]: 19 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => count((c⁰ + 1), t⁰) | N  => c⁰}: 12
//│ [N]: 31 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => count((c⁰ + 1), t⁰) | N  => c⁰}: 12
//│ [N]: 33 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰) | N  => a⁰}: 24
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => count((c⁰ + 1), t⁰) | N  => c⁰}: 12 --->
//│ 	[C h1⁰ a⁰]: 19
//│ 	[N]: 31
//│ case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰) | N  => a⁰}: 24 --->
//│ 	DeadCodeProd
//│ 	[N]: 33
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h1⁰ a⁰]: 19 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => count((c⁰ + 1), t⁰) | N  => c⁰}: 12
//│ [N]: 31 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => count((c⁰ + 1), t⁰) | N  => c⁰}: 12
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => count((c⁰ + 1), t⁰) | N  => c⁰}: 12 --->
//│ 	[C h1⁰ a⁰]: 19
//│ 	[N]: 31
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ count(0, rev((fun c¹ -> c¹), [N]))
//│ def count(c², xs¹) = xs¹(c²)
//│ def rev(a¹, ys¹) = case ys¹ of {
//│ 	C h1⁰ t1⁰ => rev(
//│ 		let t¹ = a¹
//│ 		in let h¹ = h1⁰
//│ 		in (fun c³ -> count((c³ + 1), t¹)), t1⁰)
//│ 	| N  => a¹}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 0
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ count
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ rev -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ rev((fun c⁰ -> c⁰), [N], 0)
//│ def count(c¹, xs⁰) = xs⁰(c¹)
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev(
//│ 		let t⁰ = a⁰
//│ 		in let h⁰ = h1⁰
//│ 		in (fun c² -> t⁰((c² + 1))), t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ rev((fun c⁰ -> c⁰), [N], 0)
//│ def count(c¹, xs⁰) = xs⁰(c¹)
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev(
//│ 		let t⁰ = a⁰
//│ 		in let h⁰ = h1⁰
//│ 		in (fun c² -> t⁰((c² + 1))), t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<< after floating out <<<<<<<

// NOTE: new way to push in?
_LUMBERHACK_EVAL
fun count(c, xs) = (if xs is
  C(h, t) then c => count(c + 1, t)
  N then c => c
)(c)
fun rev(a, ys) = (if ys is
  C(h1, t1) then a => rev(C(h1, a), t1)
  N then a => a
)(a)
count(0, rev(C(1, C(2, N)), N))
//│ |_LUMBERHACK_EVAL|↵|#fun| |count|(|c|,| |xs|)| |#=| |(|#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |c| |=>| |count|(|c| |+| |1|,| |t|)|↵|N| |#then| |c| |=>| |c|←|↵|)|(|c|)|↵|#fun| |rev|(|a|,| |ys|)| |#=| |(|#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |a| |=>| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a| |=>| |a|←|↵|)|(|a|)|↵|count|(|0|,| |rev|(|C|(|1|,| |C|(|2|,| |N|)|)|,| |N|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun count = c, xs, => '(' if xs is ‹(C (h, t,)) then c, => count (+ (c,) (1,), t,); (N) then c, => c›, ')' (c,); fun rev = a, ys, => '(' if ys is ‹(C (h1, t1,)) then a, => rev (C (h1, a,), t1,); (N) then a, => a›, ')' (a,); count (0, rev (C (1, C (2, N,),), N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ count^35(0, rev^38([C 1 [C 2 [N]]], [N]))
//│ def count(c⁰, xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => (fun c¹ -> count^2((c¹ + 1), t⁰))
//│ 	| N  => (fun c² -> c²)}(c⁰)
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => (fun a¹ -> rev^20([C h1⁰ a¹], t1⁰))
//│ 	| N  => (fun a² -> a²)}(a⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 2
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1⁰ a¹]: 23 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14
//│ [N]: 41 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14
//│ [C 2 [N]]: 42 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14
//│ [C 1 [C 2 [N]]]: 43 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14
//│ [N]: 45 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => (fun a¹ -> rev([C h1⁰ a¹], t1⁰)) | N  => (fun a² -> a²)}: 30
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14 --->
//│ 	[C h1⁰ a¹]: 23
//│ 	[N]: 41
//│ 	[C 2 [N]]: 42
//│ 	[C 1 [C 2 [N]]]: 43
//│ case ys⁰ of {C h1⁰ t1⁰ => (fun a¹ -> rev([C h1⁰ a¹], t1⁰)) | N  => (fun a² -> a²)}: 30 --->
//│ 	DeadCodeProd
//│ 	[N]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h1⁰ a¹]: 23 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14
//│ [N]: 41 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14
//│ [C 2 [N]]: 42 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14
//│ [C 1 [C 2 [N]]]: 43 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => (fun c¹ -> count((c¹ + 1), t⁰)) | N  => (fun c² -> c²)}: 14 --->
//│ 	[C h1⁰ a¹]: 23
//│ 	[N]: 41
//│ 	[C 2 [N]]: 42
//│ 	[C 1 [C 2 [N]]]: 43
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ count(0, rev(
//│ 	let t¹ = 	
//│ 		let t² = (fun c⁵ -> c⁵)
//│ 		in let h² = 2
//│ 		in (fun c⁴ -> count((c⁴ + 1), t²))
//│ 	in let h¹ = 1
//│ 	in (fun c³ -> count((c³ + 1), t¹)), [N]))
//│ def count(c⁶, xs¹) = xs¹(c⁶)
//│ def rev(a³, ys¹) = case ys¹ of {
//│ 	C h1⁰ t1⁰ => (fun a⁴ -> rev(
//│ 		let t³ = a⁴
//│ 		in let h³ = h1⁰
//│ 		in (fun c⁷ -> count((c⁷ + 1), t³)), t1⁰))
//│ 	| N  => (fun a⁵ -> a⁵)}(a³)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 2
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ count
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ rev -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ rev(
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun c⁰ -> c⁰)
//│ 		in let h⁰ = 2
//│ 		in (fun c¹ -> t¹((c¹ + 1)))
//│ 	in let h¹ = 1
//│ 	in (fun c² -> t⁰((c² + 1))), [N], 0)
//│ def count(c³, xs⁰) = xs⁰(c³)
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => (fun a¹ -> rev(
//│ 		let t² = a¹
//│ 		in let h² = h1⁰
//│ 		in (fun c⁴ -> t²((c⁴ + 1))), t1⁰))
//│ 	| N  => (fun a² -> a²)}(a⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ rev(
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun c⁰ -> c⁰)
//│ 		in let h⁰ = 2
//│ 		in (fun c¹ -> t¹((c¹ + 1)))
//│ 	in let h¹ = 1
//│ 	in (fun c² -> t⁰((c² + 1))), [N], 0)
//│ def count(c³, xs⁰) = xs⁰(c³)
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => (fun a¹ -> rev(
//│ 		let t² = a¹
//│ 		in let h² = h1⁰
//│ 		in (fun c⁴ -> t²((c⁴ + 1))), t1⁰))
//│ 	| N  => (fun a² -> a²)}(a⁰)
//│ <<<<<<< after floating out <<<<<<<


// WRONG:
// Fusablified program:
// _LUMBERHACK_ERROR
_LUMBERHACK_EVAL
fun count(xs) = if xs is
  C(h, t) then c => count(t)(c + 1)
  N then c => c
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
fun init = N
count(rev(N, init))(0)
//│ |_LUMBERHACK_EVAL|↵|#fun| |count|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |c| |=>| |count|(|t|)|(|c| |+| |1|)|↵|N| |#then| |c| |=>| |c|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |init| |#=| |N|↵|count|(|rev|(|N|,| |init|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun count = xs, => if xs is ‹(C (h, t,)) then c, => count (t,) (+ (c,) (1,),); (N) then c, => c›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; fun init = N; count (rev (N, init,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ count^29(rev^30([N], init^33), 0)
//│ def count(xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => (fun c⁰ -> count^2(t⁰, (c⁰ + 1)))
//│ 	| N  => (fun c¹ -> c¹)}
//│ def init = [N]
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev^17([C h1⁰ a⁰], t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 0
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1⁰ a⁰]: 20 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c⁰ -> count(t⁰, (c⁰ + 1))) | N  => (fun c¹ -> c¹)}: 14
//│ [N]: 28 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰) | N  => a⁰}: 25
//│ [N]: 31 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c⁰ -> count(t⁰, (c⁰ + 1))) | N  => (fun c¹ -> c¹)}: 14
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => (fun c⁰ -> count(t⁰, (c⁰ + 1))) | N  => (fun c¹ -> c¹)}: 14 --->
//│ 	[C h1⁰ a⁰]: 20
//│ 	[N]: 31
//│ case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰) | N  => a⁰}: 25 --->
//│ 	DeadCodeProd
//│ 	[N]: 28
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h1⁰ a⁰]: 20 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c⁰ -> count(t⁰, (c⁰ + 1))) | N  => (fun c¹ -> c¹)}: 14
//│ [N]: 31 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun c⁰ -> count(t⁰, (c⁰ + 1))) | N  => (fun c¹ -> c¹)}: 14
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => (fun c⁰ -> count(t⁰, (c⁰ + 1))) | N  => (fun c¹ -> c¹)}: 14 --->
//│ 	[C h1⁰ a⁰]: 20
//│ 	[N]: 31
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ count(rev((fun c² -> c²), init), 0)
//│ def count(xs¹) = xs¹
//│ def init = [N]
//│ def rev(a¹, ys¹) = case ys¹ of {
//│ 	C h1⁰ t1⁰ => rev(
//│ 		let t¹ = a¹
//│ 		in let h¹ = h1⁰
//│ 		in (fun c³ -> count(t¹, (c³ + 1))), t1⁰)
//│ 	| N  => a¹}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 0
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ count
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ rev -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ rev((fun c⁰ -> c⁰), init, 0)
//│ def count(xs⁰) = xs⁰
//│ def init = [N]
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev(
//│ 		let t⁰ = a⁰
//│ 		in let h⁰ = h1⁰
//│ 		in (fun c¹ -> t⁰((c¹ + 1))), t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ rev((fun c⁰ -> c⁰), init, 0)
//│ def count(xs⁰) = xs⁰
//│ def init = [N]
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev(
//│ 		let t⁰ = a⁰
//│ 		in let h⁰ = h1⁰
//│ 		in (fun c¹ -> t⁰((c¹ + 1))), t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<< after floating out <<<<<<<


// WRONG:
// FIXME
// Paper example (original)
// _LUMBERHACK_ERROR
_LUMBERHACK_EVAL
fun idxSum(i, xs) = if xs is
  C(h, t) then add(i, idxSum(add(i, 1), t))
  N then 0
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
idxSum(0, rev(N, N))
//│ |_LUMBERHACK_EVAL|↵|#fun| |idxSum|(|i|,| |xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |add|(|i|,| |idxSum|(|add|(|i|,| |1|)|,| |t|)|)|↵|N| |#then| |0|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|idxSum|(|0|,| |rev|(|N|,| |N|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun idxSum = i, xs, => if xs is ‹(C (h, t,)) then add (i, idxSum (add (i, 1,), t,),); (N) then 0›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; idxSum (0, rev (N, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ idxSum^31(0, rev^34([N], [N]))
//│ def idxSum(i⁰, xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => add⁰(i⁰, idxSum^5(add⁰(i⁰, 1), t⁰))
//│ 	| N  => 0}
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev^20([C h1⁰ a⁰], t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 0
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1⁰ a⁰]: 23 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => add⁰(i⁰, idxSum(add⁰(i⁰, 1), t⁰)) | N  => 0}: 16
//│ [N]: 35 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => add⁰(i⁰, idxSum(add⁰(i⁰, 1), t⁰)) | N  => 0}: 16
//│ [N]: 37 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰) | N  => a⁰}: 28
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => add⁰(i⁰, idxSum(add⁰(i⁰, 1), t⁰)) | N  => 0}: 16 --->
//│ 	[C h1⁰ a⁰]: 23
//│ 	[N]: 35
//│ case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰) | N  => a⁰}: 28 --->
//│ 	DeadCodeProd
//│ 	[N]: 37
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h1⁰ a⁰]: 23 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => add⁰(i⁰, idxSum(add⁰(i⁰, 1), t⁰)) | N  => 0}: 16
//│ [N]: 35 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => add⁰(i⁰, idxSum(add⁰(i⁰, 1), t⁰)) | N  => 0}: 16
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => add⁰(i⁰, idxSum(add⁰(i⁰, 1), t⁰)) | N  => 0}: 16 --->
//│ 	[C h1⁰ a⁰]: 23
//│ 	[N]: 35
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ idxSum(0, rev((fun i¹ -> 0), [N]))
//│ def idxSum(i², xs¹) = xs¹(i²)
//│ def rev(a¹, ys¹) = case ys¹ of {
//│ 	C h1⁰ t1⁰ => rev(
//│ 		let t¹ = a¹
//│ 		in let h¹ = h1⁰
//│ 		in (fun i³ -> add⁰(i³, idxSum(add⁰(i³, 1), t¹))), t1⁰)
//│ 	| N  => a¹}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 0
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ idxSum
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ rev -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ rev((fun i⁰ -> 0), [N], 0)
//│ def idxSum(i¹, xs⁰) = xs⁰(i¹)
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev(
//│ 		let t⁰ = a⁰
//│ 		in let h⁰ = h1⁰
//│ 		in (fun i² -> add⁰(i², t⁰(add⁰(i², 1)))), t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ rev((fun i⁰ -> 0), [N], 0)
//│ def idxSum(i¹, xs⁰) = xs⁰(i¹)
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev(
//│ 		let t⁰ = a⁰
//│ 		in let h⁰ = h1⁰
//│ 		in (fun i² -> add⁰(i², t⁰(add⁰(i², 1)))), t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<< after floating out <<<<<<<



// WRONG:
// _LUMBERHACK_ERROR
_LUMBERHACK_EVAL
fun count(xs) = if xs is
  C(h, t) then add(1, count(t))
  N then 0
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
fun init = N
count(rev(N, init))
//│ |_LUMBERHACK_EVAL|↵|#fun| |count|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |add|(|1|,| |count|(|t|)|)|↵|N| |#then| |0|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |init| |#=| |N|↵|count|(|rev|(|N|,| |init|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun count = xs, => if xs is ‹(C (h, t,)) then add (1, count (t,),); (N) then 0›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; fun init = N; count (rev (N, init,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ count^25(rev^26([N], init^29))
//│ def count(xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => add⁰(1, count^5(t⁰))
//│ 	| N  => 0}
//│ def init = [N]
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev^13([C h1⁰ a⁰], t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 0
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1⁰ a⁰]: 16 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => add⁰(1, count(t⁰)) | N  => 0}: 10
//│ [N]: 24 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰) | N  => a⁰}: 21
//│ [N]: 27 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => add⁰(1, count(t⁰)) | N  => 0}: 10
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => add⁰(1, count(t⁰)) | N  => 0}: 10 --->
//│ 	[C h1⁰ a⁰]: 16
//│ 	[N]: 27
//│ case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰) | N  => a⁰}: 21 --->
//│ 	DeadCodeProd
//│ 	[N]: 24
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h1⁰ a⁰]: 16 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => add⁰(1, count(t⁰)) | N  => 0}: 10
//│ [N]: 27 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => add⁰(1, count(t⁰)) | N  => 0}: 10
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => add⁰(1, count(t⁰)) | N  => 0}: 10 --->
//│ 	[C h1⁰ a⁰]: 16
//│ 	[N]: 27
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ count(rev((fun _lh_dummy⁰ -> 0), init))
//│ def count(xs¹) = xs¹(99)
//│ def init = [N]
//│ def rev(a¹, ys¹) = case ys¹ of {
//│ 	C h1⁰ t1⁰ => rev(
//│ 		let t¹ = a¹
//│ 		in let h¹ = h1⁰
//│ 		in (fun _lh_dummy¹ -> add⁰(1, count(t¹))), t1⁰)
//│ 	| N  => a¹}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 0
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ count
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ rev -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ rev((fun _lh_dummy⁰ -> 0), init, 99)
//│ def count(xs⁰) = xs⁰(99)
//│ def init = [N]
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev(
//│ 		let t⁰ = a⁰
//│ 		in let h⁰ = h1⁰
//│ 		in (fun _lh_dummy¹ -> add⁰(1, t⁰(99))), t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ rev((fun _lh_dummy⁰ -> 0), init, 99)
//│ def count(xs⁰) = xs⁰(99)
//│ def init = [N]
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev(
//│ 		let t⁰ = a⁰
//│ 		in let h⁰ = h1⁰
//│ 		in (fun _lh_dummy¹ -> add⁰(1, t⁰(99))), t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<< after floating out <<<<<<<


// WRONG:
// _LUMBERHACK_ERROR
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
fun init = C(0, init)
rev(N, init)
//│ |#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |init| |#=| |C|(|0|,| |init|)|↵|rev|(|N|,| |init|)|
//│ Parsed: {fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; fun init = C (0, init,); rev (N, init,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^16([N], init^19)
//│ def init = [C 0 init^14]
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev^2([C h1⁰ a⁰], t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 0 init]: 15 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰) | N  => a⁰}: 10
//│ ------------------
//│ case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰) | N  => a⁰}: 10 --->
//│ 	[C 0 init]: 15
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 0 init]: 15 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰) | N  => a⁰}: 10
//│ ------------------
//│ case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰) | N  => a⁰}: 10 --->
//│ 	[C 0 init]: 15
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev([N], init)
//│ def init = 
//│ 	let t1¹ = init
//│ 	in let h1¹ = 0
//│ 	in (fun a² -> rev([C h1¹ a²], t1¹))
//│ def rev(a¹, ys¹) = ys¹(a¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ init -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ init([N])
//│ def init = 
//│ 	let t1⁰ = init
//│ 	in let h1⁰ = 0
//│ 	in (fun a¹ -> t1⁰([C h1⁰ a¹]))
//│ def rev(a⁰, ys⁰) = ys⁰(a⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ init([N])
//│ def init = 
//│ 	let t1⁰ = init
//│ 	in let h1⁰ = 0
//│ 	in (fun a¹ -> t1⁰([C h1⁰ a¹]))
//│ def rev(a⁰, ys⁰) = ys⁰(a⁰)
//│ <<<<<<< after floating out <<<<<<<

// WRONG:
// _LUMBERHACK_ERROR
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
fun init = C(0, init)
rev(N, init)
//│ |#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|←|↵|#fun| |init| |#=| |C|(|0|,| |init|)|↵|rev|(|N|,| |init|)|
//│ Parsed: {fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,)›; fun init = C (0, init,); rev (N, init,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^15([N], init^18)
//│ def init = [C 0 init^13]
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev^2([C h1⁰ a⁰], t1⁰)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 0 init]: 14 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰)}: 9
//│ ------------------
//│ case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰)}: 9 --->
//│ 	[C 0 init]: 14
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 0 init]: 14 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰)}: 9
//│ ------------------
//│ case ys⁰ of {C h1⁰ t1⁰ => rev([C h1⁰ a⁰], t1⁰)}: 9 --->
//│ 	[C 0 init]: 14
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev([N], init)
//│ def init = 
//│ 	let t1¹ = init
//│ 	in let h1¹ = 0
//│ 	in (fun a² -> rev([C h1¹ a²], t1¹))
//│ def rev(a¹, ys¹) = ys¹(a¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ init -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ init([N])
//│ def init = 
//│ 	let t1⁰ = init
//│ 	in let h1⁰ = 0
//│ 	in (fun a¹ -> t1⁰([C h1⁰ a¹]))
//│ def rev(a⁰, ys⁰) = ys⁰(a⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ init([N])
//│ def init = 
//│ 	let t1⁰ = init
//│ 	in let h1⁰ = 0
//│ 	in (fun a¹ -> t1⁰([C h1⁰ a¹]))
//│ def rev(a⁰, ys⁰) = ys⁰(a⁰)
//│ <<<<<<< after floating out <<<<<<<



// WRONG:
// _LUMBERHACK_ERROR
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(a, t1)
  N then a
fun rev2(a2, ys2) = if ys2 is
  C(h12, t12) then rev2(a2, t12)
  N then a2
fun init = C(0, init)
fun init2 = C(0, init2)
rev(rev2, init)(1, init2)
//│ |#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|a|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |rev2|(|a2|,| |ys2|)| |#=| |#if| |ys2| |is|→|C|(|h12|,| |t12|)| |#then| |rev2|(|a2|,| |t12|)|↵|N| |#then| |a2|←|↵|#fun| |init| |#=| |C|(|0|,| |init|)|↵|#fun| |init2| |#=| |C|(|0|,| |init2|)|↵|rev|(|rev2|,| |init|)|(|1|,| |init2|)|
//│ Parsed: {fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (a, t1,); (N) then a›; fun rev2 = a2, ys2, => if ys2 is ‹(C (h12, t12,)) then rev2 (a2, t12,); (N) then a2›; fun init = C (0, init,); fun init2 = C (0, init2,); rev (rev2, init,) (1, init2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^27(rev2^28, init^30, 1, init2^34)
//│ def init = [C 0 init^22]
//│ def init2 = [C 0 init2^25]
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev^2(a⁰, t1⁰)
//│ 	| N  => a⁰}
//│ def rev2(a2⁰, ys2⁰) = case ys2⁰ of {
//│ 	C h12⁰ t12⁰ => rev2^12(a2⁰, t12⁰)
//│ 	| N  => a2⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 0 init]: 23 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => rev(a⁰, t1⁰) | N  => a⁰}: 8
//│ [C 0 init2]: 26 --->
//│ 	case ys2⁰ of {C h12⁰ t12⁰ => rev2(a2⁰, t12⁰) | N  => a2⁰}: 18
//│ ------------------
//│ case ys⁰ of {C h1⁰ t1⁰ => rev(a⁰, t1⁰) | N  => a⁰}: 8 --->
//│ 	[C 0 init]: 23
//│ case ys2⁰ of {C h12⁰ t12⁰ => rev2(a2⁰, t12⁰) | N  => a2⁰}: 18 --->
//│ 	[C 0 init2]: 26
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 0 init]: 23 --->
//│ 	case ys⁰ of {C h1⁰ t1⁰ => rev(a⁰, t1⁰) | N  => a⁰}: 8
//│ [C 0 init2]: 26 --->
//│ 	case ys2⁰ of {C h12⁰ t12⁰ => rev2(a2⁰, t12⁰) | N  => a2⁰}: 18
//│ ------------------
//│ case ys⁰ of {C h1⁰ t1⁰ => rev(a⁰, t1⁰) | N  => a⁰}: 8 --->
//│ 	[C 0 init]: 23
//│ case ys2⁰ of {C h12⁰ t12⁰ => rev2(a2⁰, t12⁰) | N  => a2⁰}: 18 --->
//│ 	[C 0 init2]: 26
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(rev2, init, 1, init2)
//│ def init = 
//│ 	let t1¹ = init
//│ 	in let h1¹ = 0
//│ 	in (fun a² -> rev(a², t1¹))
//│ def init2 = 
//│ 	let t12¹ = init2
//│ 	in let h12¹ = 0
//│ 	in (fun a2² -> rev2(a2², t12¹))
//│ def rev(a¹, ys¹) = ys¹(a¹)
//│ def rev2(a2¹, ys2¹) = ys2¹(a2¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev2, rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ init -> 0
//│ init2 -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ init(rev2, 1, init2)
//│ def init = 
//│ 	let t1⁰ = init
//│ 	in let h1⁰ = 0
//│ 	in (fun a¹ -> t1⁰(a¹))
//│ def init2 = 
//│ 	let t12⁰ = init2
//│ 	in let h12⁰ = 0
//│ 	in (fun a2¹ -> t12⁰(a2¹))
//│ def rev(a⁰, ys⁰) = ys⁰(a⁰)
//│ def rev2(a2⁰, ys2⁰) = ys2⁰(a2⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ init(rev2, 1, init2)
//│ def init = 
//│ 	let t1⁰ = init
//│ 	in let h1⁰ = 0
//│ 	in (fun a¹ -> t1⁰(a¹))
//│ def init2 = 
//│ 	let t12⁰ = init2
//│ 	in let h12⁰ = 0
//│ 	in (fun a2¹ -> t12⁰(a2¹))
//│ def rev(a⁰, ys⁰) = ys⁰(a⁰)
//│ def rev2(a2⁰, ys2⁰) = ys2⁰(a2⁰)
//│ <<<<<<< after floating out <<<<<<<
