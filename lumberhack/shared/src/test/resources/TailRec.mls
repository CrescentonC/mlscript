:NewParser
:ParseOnly


// WRONG: Initial program, not immediately fusable:
// _LUMBERHACK_ERROR
_LUMBERHACK_EVAL
fun count(c, xs) = if xs is
  C(h, t) then count(c + 1, t)
  N then c
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
count(0, rev(N, N))
//│ |_LUMBERHACK_EVAL|↵|#fun| |count|(|c|,| |xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |count|(|c| |+| |1|,| |t|)|↵|N| |#then| |c|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|count|(|0|,| |rev|(|N|,| |N|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun count = c, xs, => if xs is ‹(C (h, t,)) then count (+ (c,) (1,), t,); (N) then c›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; count (0, rev (N, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ count^27(0, rev^30([N], [N]))
//│ def count(c⁰, xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => count^2((c⁰ + 1), t⁰)
//│ 	| N  => c⁰}
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev^16([C h1⁰ a⁰], t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 0
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [count^27] (hopeless to continue)
//│ 	[count^27 · count^2] ---> [count^27] (using original def)
//│ [rev^30] (hopeless to continue)
//│ 	[rev^30 · rev^16] ---> [rev^30] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ count_₀(0, rev_₀([N], [N]))
//│ def count_₀(c¹, xs¹) = 
//│ 	case xs¹ of {
//│ 		C h¹ t¹ => count_₀((c¹ + 1), t¹)
//│ 		| N  => c¹}
//│ def rev_₀(a¹, ys¹) = 
//│ 	case ys¹ of {
//│ 		C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹)
//│ 		| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1¹ a¹]: 54 --->
//│ 	case xs¹ of {C h¹ t¹ => count_₀((c¹ + 1), t¹) | N  => c¹}: 47
//│ [N]: 66 --->
//│ 	case xs¹ of {C h¹ t¹ => count_₀((c¹ + 1), t¹) | N  => c¹}: 47
//│ [N]: 68 --->
//│ 	case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹) | N  => a¹}: 59
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => count_₀((c¹ + 1), t¹) | N  => c¹}: 47 --->
//│ 	[C h1¹ a¹]: 54
//│ 	[N]: 66
//│ case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹) | N  => a¹}: 59 --->
//│ 	DeadCodeProd
//│ 	[N]: 68
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h1¹ a¹]: 54 --->
//│ 	case xs¹ of {C h¹ t¹ => count_₀((c¹ + 1), t¹) | N  => c¹}: 47
//│ [N]: 66 --->
//│ 	case xs¹ of {C h¹ t¹ => count_₀((c¹ + 1), t¹) | N  => c¹}: 47
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => count_₀((c¹ + 1), t¹) | N  => c¹}: 47 --->
//│ 	[C h1¹ a¹]: 54
//│ 	[N]: 66
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ count_₀(0, rev_₀((fun c² -> c²), [N]))
//│ def count_₀(c³, xs²) = 
//│ 	xs²(c³)
//│ def rev_₀(a², ys²) = 
//│ 	case ys² of {
//│ 		C h1¹ t1¹ => rev_₀(
//│ 			let t² = a²
//│ 			in (fun c⁴ -> count_₀((c⁴ + 1), t²)), t1¹)
//│ 		| N  => a²}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 0
//│ <<<<<<< evaluate <<<<<<<

// NOTE: new way to push in?
_LUMBERHACK_EVAL
fun count(c, xs) = (if xs is
  C(h, t) then c => count(c + 1, t)
  N then c => c
)(c)
fun rev(a, ys) = (if ys is
  C(h1, t1) then a => rev(C(h1, a), t1)
  N then a => a
)(a)
count(0, rev(C(1, C(2, N)), N))
//│ |_LUMBERHACK_EVAL|↵|#fun| |count|(|c|,| |xs|)| |#=| |(|#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |c| |=>| |count|(|c| |+| |1|,| |t|)|↵|N| |#then| |c| |=>| |c|←|↵|)|(|c|)|↵|#fun| |rev|(|a|,| |ys|)| |#=| |(|#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |a| |=>| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a| |=>| |a|←|↵|)|(|a|)|↵|count|(|0|,| |rev|(|C|(|1|,| |C|(|2|,| |N|)|)|,| |N|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun count = c, xs, => '(' if xs is ‹(C (h, t,)) then c, => count (+ (c,) (1,), t,); (N) then c, => c›, ')' (c,); fun rev = a, ys, => '(' if ys is ‹(C (h1, t1,)) then a, => rev (C (h1, a,), t1,); (N) then a, => a›, ')' (a,); count (0, rev (C (1, C (2, N,),), N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ count^35(0, rev^38([C 1 [C 2 [N]]], [N]))
//│ def count(c⁰, xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => (fun c¹ -> count^2((c¹ + 1), t⁰))
//│ 	| N  => (fun c² -> c²)}(c⁰)
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => (fun a¹ -> rev^20([C h1⁰ a¹], t1⁰))
//│ 	| N  => (fun a² -> a²)}(a⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 2
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [count^35] (hopeless to continue)
//│ 	[count^35 · count^2] ---> [count^35] (using original def)
//│ [rev^38] (hopeless to continue)
//│ 	[rev^38 · rev^20] ---> [rev^38] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ count_₀(0, rev_₀([C 1 [C 2 [N]]], [N]))
//│ def count_₀(c³, xs¹) = 
//│ 	case xs¹ of {
//│ 		C h¹ t¹ => (fun c⁴ -> count_₀((c⁴ + 1), t¹))
//│ 		| N  => (fun c⁵ -> c⁵)}(c³)
//│ def rev_₀(a³, ys¹) = 
//│ 	case ys¹ of {
//│ 		C h1¹ t1¹ => (fun a⁴ -> rev_₀([C h1¹ a⁴], t1¹))
//│ 		| N  => (fun a⁵ -> a⁵)}(a³)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1¹ a⁴]: 70 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c⁴ -> count_₀((c⁴ + 1), t¹)) | N  => (fun c⁵ -> c⁵)}: 61
//│ [N]: 88 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c⁴ -> count_₀((c⁴ + 1), t¹)) | N  => (fun c⁵ -> c⁵)}: 61
//│ [C 2 [N]]: 89 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c⁴ -> count_₀((c⁴ + 1), t¹)) | N  => (fun c⁵ -> c⁵)}: 61
//│ [C 1 [C 2 [N]]]: 90 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c⁴ -> count_₀((c⁴ + 1), t¹)) | N  => (fun c⁵ -> c⁵)}: 61
//│ [N]: 92 --->
//│ 	case ys¹ of {C h1¹ t1¹ => (fun a⁴ -> rev_₀([C h1¹ a⁴], t1¹)) | N  => (fun a⁵ -> a⁵)}: 77
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => (fun c⁴ -> count_₀((c⁴ + 1), t¹)) | N  => (fun c⁵ -> c⁵)}: 61 --->
//│ 	[C h1¹ a⁴]: 70
//│ 	[N]: 88
//│ 	[C 2 [N]]: 89
//│ 	[C 1 [C 2 [N]]]: 90
//│ case ys¹ of {C h1¹ t1¹ => (fun a⁴ -> rev_₀([C h1¹ a⁴], t1¹)) | N  => (fun a⁵ -> a⁵)}: 77 --->
//│ 	DeadCodeProd
//│ 	[N]: 92
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h1¹ a⁴]: 70 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c⁴ -> count_₀((c⁴ + 1), t¹)) | N  => (fun c⁵ -> c⁵)}: 61
//│ [N]: 88 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c⁴ -> count_₀((c⁴ + 1), t¹)) | N  => (fun c⁵ -> c⁵)}: 61
//│ [C 2 [N]]: 89 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c⁴ -> count_₀((c⁴ + 1), t¹)) | N  => (fun c⁵ -> c⁵)}: 61
//│ [C 1 [C 2 [N]]]: 90 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c⁴ -> count_₀((c⁴ + 1), t¹)) | N  => (fun c⁵ -> c⁵)}: 61
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => (fun c⁴ -> count_₀((c⁴ + 1), t¹)) | N  => (fun c⁵ -> c⁵)}: 61 --->
//│ 	[C h1¹ a⁴]: 70
//│ 	[N]: 88
//│ 	[C 2 [N]]: 89
//│ 	[C 1 [C 2 [N]]]: 90
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ count_₀(0, rev_₀(
//│ 	let t² = 	
//│ 		let t³ = (fun c⁸ -> c⁸)
//│ 		in (fun c⁷ -> count_₀((c⁷ + 1), t³))
//│ 	in (fun c⁶ -> count_₀((c⁶ + 1), t²)), [N]))
//│ def count_₀(c⁹, xs²) = 
//│ 	xs²(c⁹)
//│ def rev_₀(a⁶, ys²) = 
//│ 	case ys² of {
//│ 		C h1¹ t1¹ => (fun a⁷ -> rev_₀(
//│ 			let t⁴ = a⁷
//│ 			in (fun c¹⁰ -> count_₀((c¹⁰ + 1), t⁴)), t1¹))
//│ 		| N  => (fun a⁸ -> a⁸)}(a⁶)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 2
//│ <<<<<<< evaluate <<<<<<<


// WRONG:
// Fusablified program:
// _LUMBERHACK_ERROR
_LUMBERHACK_EVAL
fun count(xs) = if xs is
  C(h, t) then c => count(t)(c + 1)
  N then c => c
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
fun init = N
count(rev(N, init))(0)
//│ |_LUMBERHACK_EVAL|↵|#fun| |count|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |c| |=>| |count|(|t|)|(|c| |+| |1|)|↵|N| |#then| |c| |=>| |c|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |init| |#=| |N|↵|count|(|rev|(|N|,| |init|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun count = xs, => if xs is ‹(C (h, t,)) then c, => count (t,) (+ (c,) (1,),); (N) then c, => c›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; fun init = N; count (rev (N, init,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ count^29(rev^30([N], init^33), 0)
//│ def count(xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => (fun c⁰ -> count^2(t⁰, (c⁰ + 1)))
//│ 	| N  => (fun c¹ -> c¹)}
//│ def init = [N]
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev^17([C h1⁰ a⁰], t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 0
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [count^29] (hopeless to continue)
//│ 	[count^29 · count^2] ---> [count^29] (using original def)
//│ [init^33] (hopeless to continue)
//│ [rev^30] (hopeless to continue)
//│ 	[rev^30 · rev^17] ---> [rev^30] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ count_₀(rev_₀([N], init_₀), 0)
//│ def count_₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		C h¹ t¹ => (fun c² -> count_₀(t¹, (c² + 1)))
//│ 		| N  => (fun c³ -> c³)}
//│ def init_₀ = 
//│ 	[N]
//│ def rev_₀(a¹, ys¹) = 
//│ 	case ys¹ of {
//│ 		C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹)
//│ 		| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1¹ a¹]: 42 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c² -> count_₀(t¹, (c² + 1))) | N  => (fun c³ -> c³)}: 63
//│ [N]: 65 --->
//│ 	case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹) | N  => a¹}: 47
//│ [N]: 68 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c² -> count_₀(t¹, (c² + 1))) | N  => (fun c³ -> c³)}: 63
//│ ------------------
//│ case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹) | N  => a¹}: 47 --->
//│ 	DeadCodeProd
//│ 	[N]: 65
//│ case xs¹ of {C h¹ t¹ => (fun c² -> count_₀(t¹, (c² + 1))) | N  => (fun c³ -> c³)}: 63 --->
//│ 	[C h1¹ a¹]: 42
//│ 	[N]: 68
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h1¹ a¹]: 42 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c² -> count_₀(t¹, (c² + 1))) | N  => (fun c³ -> c³)}: 63
//│ [N]: 68 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c² -> count_₀(t¹, (c² + 1))) | N  => (fun c³ -> c³)}: 63
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => (fun c² -> count_₀(t¹, (c² + 1))) | N  => (fun c³ -> c³)}: 63 --->
//│ 	[C h1¹ a¹]: 42
//│ 	[N]: 68
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ count_₀(rev_₀((fun c⁴ -> c⁴), init_₀), 0)
//│ def count_₀(xs²) = 
//│ 	xs²
//│ def init_₀ = 
//│ 	[N]
//│ def rev_₀(a², ys²) = 
//│ 	case ys² of {
//│ 		C h1¹ t1¹ => rev_₀(
//│ 			let t² = a²
//│ 			in (fun c⁵ -> count_₀(t², (c⁵ + 1))), t1¹)
//│ 		| N  => a²}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 0
//│ <<<<<<< evaluate <<<<<<<


// WRONG:
// FIXME
// Paper example (original)
// _LUMBERHACK_ERROR
_LUMBERHACK_EVAL
fun idxSum(i, xs) = if xs is
  C(h, t) then add(i, idxSum(add(i, 1), t))
  N then 0
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
idxSum(0, rev(N, N))
//│ |_LUMBERHACK_EVAL|↵|#fun| |idxSum|(|i|,| |xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |add|(|i|,| |idxSum|(|add|(|i|,| |1|)|,| |t|)|)|↵|N| |#then| |0|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|idxSum|(|0|,| |rev|(|N|,| |N|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun idxSum = i, xs, => if xs is ‹(C (h, t,)) then add (i, idxSum (add (i, 1,), t,),); (N) then 0›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; idxSum (0, rev (N, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ idxSum^31(0, rev^34([N], [N]))
//│ def idxSum(i⁰, xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => add⁰(i⁰, idxSum^5(add⁰(i⁰, 1), t⁰))
//│ 	| N  => 0}
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev^20([C h1⁰ a⁰], t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 0
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [idxSum^31] (hopeless to continue)
//│ 	[idxSum^31 · idxSum^5] ---> [idxSum^31] (using original def)
//│ [rev^34] (hopeless to continue)
//│ 	[rev^34 · rev^20] ---> [rev^34] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ idxSum_₀(0, rev_₀([N], [N]))
//│ def idxSum_₀(i¹, xs¹) = 
//│ 	case xs¹ of {
//│ 		C h¹ t¹ => add⁰(i¹, idxSum_₀(add⁰(i¹, 1), t¹))
//│ 		| N  => 0}
//│ def rev_₀(a¹, ys¹) = 
//│ 	case ys¹ of {
//│ 		C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹)
//│ 		| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1¹ a¹]: 44 --->
//│ 	case xs¹ of {C h¹ t¹ => add⁰(i¹, idxSum_₀(add⁰(i¹, 1), t¹)) | N  => 0}: 67
//│ [N]: 74 --->
//│ 	case xs¹ of {C h¹ t¹ => add⁰(i¹, idxSum_₀(add⁰(i¹, 1), t¹)) | N  => 0}: 67
//│ [N]: 76 --->
//│ 	case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹) | N  => a¹}: 49
//│ ------------------
//│ case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹) | N  => a¹}: 49 --->
//│ 	DeadCodeProd
//│ 	[N]: 76
//│ case xs¹ of {C h¹ t¹ => add⁰(i¹, idxSum_₀(add⁰(i¹, 1), t¹)) | N  => 0}: 67 --->
//│ 	[C h1¹ a¹]: 44
//│ 	[N]: 74
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h1¹ a¹]: 44 --->
//│ 	case xs¹ of {C h¹ t¹ => add⁰(i¹, idxSum_₀(add⁰(i¹, 1), t¹)) | N  => 0}: 67
//│ [N]: 74 --->
//│ 	case xs¹ of {C h¹ t¹ => add⁰(i¹, idxSum_₀(add⁰(i¹, 1), t¹)) | N  => 0}: 67
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => add⁰(i¹, idxSum_₀(add⁰(i¹, 1), t¹)) | N  => 0}: 67 --->
//│ 	[C h1¹ a¹]: 44
//│ 	[N]: 74
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ idxSum_₀(0, rev_₀((fun i² -> 0), [N]))
//│ def idxSum_₀(i⁴, xs²) = 
//│ 	xs²(i⁴)
//│ def rev_₀(a², ys²) = 
//│ 	case ys² of {
//│ 		C h1¹ t1¹ => rev_₀(
//│ 			let t² = a²
//│ 			in (fun i³ -> add⁰(i³, idxSum_₀(add⁰(i³, 1), t²))), t1¹)
//│ 		| N  => a²}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 0
//│ <<<<<<< evaluate <<<<<<<



// WRONG:
// _LUMBERHACK_ERROR
_LUMBERHACK_EVAL
fun count(xs) = if xs is
  C(h, t) then add(1, count(t))
  N then 0
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
fun init = N
count(rev(N, init))
//│ |_LUMBERHACK_EVAL|↵|#fun| |count|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |add|(|1|,| |count|(|t|)|)|↵|N| |#then| |0|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |init| |#=| |N|↵|count|(|rev|(|N|,| |init|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun count = xs, => if xs is ‹(C (h, t,)) then add (1, count (t,),); (N) then 0›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; fun init = N; count (rev (N, init,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ count^25(rev^26([N], init^29))
//│ def count(xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => add⁰(1, count^5(t⁰))
//│ 	| N  => 0}
//│ def init = [N]
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev^13([C h1⁰ a⁰], t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 0
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [count^25] (hopeless to continue)
//│ 	[count^25 · count^5] ---> [count^25] (using original def)
//│ [init^29] (hopeless to continue)
//│ [rev^26] (hopeless to continue)
//│ 	[rev^26 · rev^13] ---> [rev^26] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ count_₀(rev_₀([N], init_₀))
//│ def count_₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		C h¹ t¹ => add⁰(1, count_₀(t¹))
//│ 		| N  => 0}
//│ def init_₀ = 
//│ 	[N]
//│ def rev_₀(a¹, ys¹) = 
//│ 	case ys¹ of {
//│ 		C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹)
//│ 		| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 43 --->
//│ 	case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹) | N  => a¹}: 53
//│ [C h1¹ a¹]: 48 --->
//│ 	case xs¹ of {C h¹ t¹ => add⁰(1, count_₀(t¹)) | N  => 0}: 41
//│ [N]: 58 --->
//│ 	case xs¹ of {C h¹ t¹ => add⁰(1, count_₀(t¹)) | N  => 0}: 41
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => add⁰(1, count_₀(t¹)) | N  => 0}: 41 --->
//│ 	[C h1¹ a¹]: 48
//│ 	[N]: 58
//│ case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹) | N  => a¹}: 53 --->
//│ 	DeadCodeProd
//│ 	[N]: 43
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h1¹ a¹]: 48 --->
//│ 	case xs¹ of {C h¹ t¹ => add⁰(1, count_₀(t¹)) | N  => 0}: 41
//│ [N]: 58 --->
//│ 	case xs¹ of {C h¹ t¹ => add⁰(1, count_₀(t¹)) | N  => 0}: 41
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => add⁰(1, count_₀(t¹)) | N  => 0}: 41 --->
//│ 	[C h1¹ a¹]: 48
//│ 	[N]: 58
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ count_₀(rev_₀((fun _lh_dummy⁰ -> 0), init_₀))
//│ def count_₀(xs²) = 
//│ 	xs²(99)
//│ def init_₀ = 
//│ 	[N]
//│ def rev_₀(a², ys²) = 
//│ 	case ys² of {
//│ 		C h1¹ t1¹ => rev_₀(
//│ 			let t² = a²
//│ 			in (fun _lh_dummy¹ -> add⁰(1, count_₀(t²))), t1¹)
//│ 		| N  => a²}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 0
//│ <<<<<<< evaluate <<<<<<<


// WRONG:
// _LUMBERHACK_ERROR
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
fun init = C(0, init)
rev(N, init)
//│ |#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |init| |#=| |C|(|0|,| |init|)|↵|rev|(|N|,| |init|)|
//│ Parsed: {fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; fun init = C (0, init,); rev (N, init,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^16([N], init^19)
//│ def init = [C 0 init^14]
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev^2([C h1⁰ a⁰], t1⁰)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [init^19] (hopeless to continue)
//│ 	[init^19 · init^14] ---> [init^19] (using original def)
//│ [rev^16] (hopeless to continue)
//│ 	[rev^16 · rev^2] ---> [rev^16] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀([N], init_₀)
//│ def init_₀ = 
//│ 	[C 0 init_₀]
//│ def rev_₀(a¹, ys¹) = 
//│ 	case ys¹ of {
//│ 		C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹)
//│ 		| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 0 init_₀]: 23 --->
//│ 	case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹) | N  => a¹}: 33
//│ ------------------
//│ case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹) | N  => a¹}: 33 --->
//│ 	[C 0 init_₀]: 23
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 0 init_₀]: 23 --->
//│ 	case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹) | N  => a¹}: 33
//│ ------------------
//│ case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹) | N  => a¹}: 33 --->
//│ 	[C 0 init_₀]: 23
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀([N], init_₀)
//│ def init_₀ = 
//│ 	let t1² = init_₀
//│ 	in let h1² = 0
//│ 	in (fun a² -> rev_₀([C h1² a²], t1²))
//│ def rev_₀(a³, ys²) = 
//│ 	ys²(a³)
//│ <<<<<<< after fusion <<<<<<<

// WRONG:
// _LUMBERHACK_ERROR
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
fun init = C(0, init)
rev(N, init)
//│ |#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|←|↵|#fun| |init| |#=| |C|(|0|,| |init|)|↵|rev|(|N|,| |init|)|
//│ Parsed: {fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,)›; fun init = C (0, init,); rev (N, init,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^15([N], init^18)
//│ def init = [C 0 init^13]
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev^2([C h1⁰ a⁰], t1⁰)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [init^18] (hopeless to continue)
//│ 	[init^18 · init^13] ---> [init^18] (using original def)
//│ [rev^15] (hopeless to continue)
//│ 	[rev^15 · rev^2] ---> [rev^15] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀([N], init_₀)
//│ def init_₀ = 
//│ 	[C 0 init_₀]
//│ def rev_₀(a¹, ys¹) = 
//│ 	case ys¹ of {
//│ 		C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 0 init_₀]: 22 --->
//│ 	case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹)}: 31
//│ ------------------
//│ case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹)}: 31 --->
//│ 	[C 0 init_₀]: 22
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 0 init_₀]: 22 --->
//│ 	case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹)}: 31
//│ ------------------
//│ case ys¹ of {C h1¹ t1¹ => rev_₀([C h1¹ a¹], t1¹)}: 31 --->
//│ 	[C 0 init_₀]: 22
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀([N], init_₀)
//│ def init_₀ = 
//│ 	let t1² = init_₀
//│ 	in let h1² = 0
//│ 	in (fun a² -> rev_₀([C h1² a²], t1²))
//│ def rev_₀(a³, ys²) = 
//│ 	ys²(a³)
//│ <<<<<<< after fusion <<<<<<<



// WRONG:
// _LUMBERHACK_ERROR
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(a, t1)
  N then a
fun rev2(a2, ys2) = if ys2 is
  C(h12, t12) then rev2(a2, t12)
  N then a2
fun init = C(0, init)
fun init2 = C(0, init2)
rev(rev2, init)(1, init2)
//│ |#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|a|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |rev2|(|a2|,| |ys2|)| |#=| |#if| |ys2| |is|→|C|(|h12|,| |t12|)| |#then| |rev2|(|a2|,| |t12|)|↵|N| |#then| |a2|←|↵|#fun| |init| |#=| |C|(|0|,| |init|)|↵|#fun| |init2| |#=| |C|(|0|,| |init2|)|↵|rev|(|rev2|,| |init|)|(|1|,| |init2|)|
//│ Parsed: {fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (a, t1,); (N) then a›; fun rev2 = a2, ys2, => if ys2 is ‹(C (h12, t12,)) then rev2 (a2, t12,); (N) then a2›; fun init = C (0, init,); fun init2 = C (0, init2,); rev (rev2, init,) (1, init2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^27(rev2^28, init^30, 1, init2^34)
//│ def init = [C 0 init^22]
//│ def init2 = [C 0 init2^25]
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h1⁰ t1⁰ => rev^2(a⁰, t1⁰)
//│ 	| N  => a⁰}
//│ def rev2(a2⁰, ys2⁰) = case ys2⁰ of {
//│ 	C h12⁰ t12⁰ => rev2^12(a2⁰, t12⁰)
//│ 	| N  => a2⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [init2^34] (hopeless to continue)
//│ 	[init2^34 · init2^25] ---> [init2^34] (using original def)
//│ [init^30] (hopeless to continue)
//│ 	[init^30 · init^22] ---> [init^30] (using original def)
//│ [rev2^28] (hopeless to continue)
//│ 	[rev2^28 · rev2^12] ---> [rev2^28] (using original def)
//│ [rev^27] (hopeless to continue)
//│ 	[rev^27 · rev^2] ---> [rev^27] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀(rev2_₀, init_₀, 1, init2_₀)
//│ def init2_₀ = 
//│ 	[C 0 init2_₀]
//│ def init_₀ = 
//│ 	[C 0 init_₀]
//│ def rev2_₀(a2¹, ys2¹) = 
//│ 	case ys2¹ of {
//│ 		C h12¹ t12¹ => rev2_₀(a2¹, t12¹)
//│ 		| N  => a2¹}
//│ def rev_₀(a¹, ys¹) = 
//│ 	case ys¹ of {
//│ 		C h1¹ t1¹ => rev_₀(a¹, t1¹)
//│ 		| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 0 init2_₀]: 38 --->
//│ 	case ys2¹ of {C h12¹ t12¹ => rev2_₀(a2¹, t12¹) | N  => a2¹}: 59
//│ [C 0 init_₀]: 41 --->
//│ 	case ys¹ of {C h1¹ t1¹ => rev_₀(a¹, t1¹) | N  => a¹}: 49
//│ ------------------
//│ case ys¹ of {C h1¹ t1¹ => rev_₀(a¹, t1¹) | N  => a¹}: 49 --->
//│ 	[C 0 init_₀]: 41
//│ case ys2¹ of {C h12¹ t12¹ => rev2_₀(a2¹, t12¹) | N  => a2¹}: 59 --->
//│ 	[C 0 init2_₀]: 38
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 0 init2_₀]: 38 --->
//│ 	case ys2¹ of {C h12¹ t12¹ => rev2_₀(a2¹, t12¹) | N  => a2¹}: 59
//│ [C 0 init_₀]: 41 --->
//│ 	case ys¹ of {C h1¹ t1¹ => rev_₀(a¹, t1¹) | N  => a¹}: 49
//│ ------------------
//│ case ys¹ of {C h1¹ t1¹ => rev_₀(a¹, t1¹) | N  => a¹}: 49 --->
//│ 	[C 0 init_₀]: 41
//│ case ys2¹ of {C h12¹ t12¹ => rev2_₀(a2¹, t12¹) | N  => a2¹}: 59 --->
//│ 	[C 0 init2_₀]: 38
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(rev2_₀, init_₀, 1, init2_₀)
//│ def init2_₀ = 
//│ 	let t12² = init2_₀
//│ 	in (fun a2² -> rev2_₀(a2², t12²))
//│ def init_₀ = 
//│ 	let t1² = init_₀
//│ 	in (fun a² -> rev_₀(a², t1²))
//│ def rev2_₀(a2³, ys2²) = 
//│ 	ys2²(a2³)
//│ def rev_₀(a³, ys²) = 
//│ 	ys²(a³)
//│ <<<<<<< after fusion <<<<<<<
