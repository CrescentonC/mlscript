:NewParser
:ParseOnly


// Initial program, not immediately fusable:
fun count(c, xs) = if xs is
    C(h, t) then count(add(c, 1), t)
    N then c
fun rev(a, ys) = if ys is
    C(h1, t1) then rev(C(h1, a), t1)
    N then a
count(0, rev(N, N))
//│ |#fun| |count|(|c|,| |xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |count|(|add|(|c|,| |1|)|,| |t|)|↵|N| |#then| |c|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|count|(|0|,| |rev|(|N|,| |N|)|)|
//│ Parsed: {fun count = c, xs, => if xs is ‹(C (h, t,)) then count (add (c, 1,), t,); (N) then c›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; count (0, rev (N, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((count^27 0) ((rev^30 [N]) [N]))
//│ def count = (fun c:8 -> (fun xs:9 -> case xs:9 of {
//│ 	C h:10 t:11 => ((count^2 ((add:4 c:8) 1)) t:11)
//│ 	| N => c:8}))
//│ def rev = (fun a:12 -> (fun ys:13 -> case ys:13 of {
//│ 	C h1:14 t1:15 => ((rev^16 [C h1:14 a:12]) t1:15)
//│ 	| N => a:12}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('h1:14, 'a:12) <: 'xs:9
//│ 	[+rev^16 · +rev^16 · +rev^16 · -rev^30 · +count^27 · +count^2 · +count^2]  --->  [+rev^16 · +rev^16 · -rev^30 · +count^27 · +count^2]
//│ 	[+rev^16 · +rev^16 · +rev^16 · -rev^16 · -rev^30 · +count^27 · +count^2 · +count^2]  --->  [+rev^16 · +rev^16 · -rev^16 · -rev^30 · +count^27 · +count^2]
//│ NoProd <: 't:11
//│ 	[+rev^30 · +rev^16 · -rev^30 · +count^27 · +count^2 · +count^2]  --->  [+rev^30 · +rev^16 · -rev^30 · +count^27 · +count^2]
//│ 	[+rev^30 · +rev^16 · +rev^16 · -rev^30 · +count^27 · +count^2 · +count^2 · +count^2]  --->  [+rev^30 · +rev^16 · +rev^16 · -rev^30 · +count^27 · +count^2 · +count^2]
//│ 	[+rev^30 · +rev^16 · -rev^16 · -rev^30 · +count^27 · +count^2 · +count^2]  --->  [+rev^30 · +rev^16 · -rev^16 · -rev^30 · +count^27 · +count^2]
//│ 	[+rev^30 · +rev^16 · +rev^16 · -rev^16 · -rev^30 · +count^27 · +count^2 · +count^2 · +count^2]  --->  [+rev^30 · +rev^16 · +rev^16 · -rev^16 · -rev^30 · +count^27 · +count^2 · +count^2]
//│ NoProd <: 'ys:13
//│ 	[+rev^30 · +rev^16 · +rev^16]  --->  [+rev^30 · +rev^16]
//│ NoProd <: 'xs:9
//│ 	[+rev^30 · -rev^30 · +count^27 · +count^2 · +count^2]  --->  [+rev^30 · -rev^30 · +count^27 · +count^2]
//│ 	[+rev^30 · -rev^16 · -rev^30 · +count^27 · +count^2 · +count^2]  --->  [+rev^30 · -rev^16 · -rev^30 · +count^27 · +count^2]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [count^27]
//│ 	[count^27 · count^2]
//│ 		[count^27 · count^2 · count^2] ---> [count^27 · count^2] (only one)
//│ [rev^30]
//│ 	[rev^30 · rev^16]
//│ 		[rev^30 · rev^16 · rev^16] ---> [rev^30 · rev^16] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1:22 a:20] --->
//│ 	case xs:29 of {C h:30 t:31 => ((count^27_count^2 ((add:4 c:28) 1)) t:31) | N => c:28}
//│ 	case xs:33 of {C h:34 t:35 => ((count^27_count^2 ((add:4 c:32) 1)) t:35) | N => c:32}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C h1:26 a:24] --->
//│ 	case xs:29 of {C h:30 t:31 => ((count^27_count^2 ((add:4 c:28) 1)) t:31) | N => c:28}
//│ 	case xs:33 of {C h:34 t:35 => ((count^27_count^2 ((add:4 c:32) 1)) t:35) | N => c:32}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N] --->
//│ 	case xs:29 of {C h:30 t:31 => ((count^27_count^2 ((add:4 c:28) 1)) t:31) | N => c:28}
//│ 	case xs:33 of {C h:34 t:35 => ((count^27_count^2 ((add:4 c:32) 1)) t:35) | N => c:32}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N] --->
//│ 	case ys:21 of {C h1:22 t1:23 => ((rev^30_rev^16 [C h1:22 a:20]) t1:23) | N => a:20}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((count^27 0) ((rev^30 c:28) a:20))
//│ def count = (fun c:8 -> (fun xs:9 -> case xs:9 of {
//│ 	C h:10 t:11 => ((count ((add:4 c:8) 1)) t:11)
//│ 	| N => c:8}))
//│ def count^27 = (fun c:32 -> (fun xs:33 -> xs:33))
//│ def count^27_count^2 = (fun c:28 -> (fun xs:29 -> xs:29))
//│ def rev = (fun a:12 -> (fun ys:13 -> case ys:13 of {
//│ 	C h1:14 t1:15 => ((rev [C h1:14 a:12]) t1:15)
//│ 	| N => a:12}))
//│ def rev^30 = (fun a:20 -> (fun ys:21 -> ys:21))
//│ def rev^30_rev^16 = (fun a:24 -> (fun ys:25 -> case ys:25 of {
//│ 	C h1:26 t1:27 => ((rev^30_rev^16 
//│ 		let h:34 = h1:26
//│ 		in let t:35 = a:24
//│ 		in ((count^27_count^2 ((add:4 c:32) 1)) t:35)) t1:27)
//│ 	| N => a:24}))
//│ <<<<<<< after fusion <<<<<<<


// Fusablified program:
fun count(xs) = if xs is
    C(h, t) then c => count(t)(add(c, 1))
    N then c => c
fun rev(a, ys) = if ys is
    C(h1, t1) then rev(C(h1, a), t1)
    N then a
fun init = N
count(rev(N, init))(0)
//│ |#fun| |count|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |c| |=>| |count|(|t|)|(|add|(|c|,| |1|)|)|↵|N| |#then| |c| |=>| |c|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |init| |#=| |N|↵|count|(|rev|(|N|,| |init|)|)|(|0|)|
//│ Parsed: {fun count = xs, => if xs is ‹(C (h, t,)) then c, => count (t,) (add (c, 1,),); (N) then c, => c›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; fun init = N; count (rev (N, init,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((count^29 ((rev^30 [N]) init^33)) 0)
//│ def count = (fun xs:9 -> case xs:9 of {
//│ 	C h:10 t:11 => (fun c:12 -> ((count^2 t:11) ((add:4 c:12) 1)))
//│ 	| N => (fun c:13 -> c:13)})
//│ def init = [N]
//│ def rev = (fun a:14 -> (fun ys:15 -> case ys:15 of {
//│ 	C h1:16 t1:17 => ((rev^17 [C h1:16 a:14]) t1:17)
//│ 	| N => a:14}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('h1:16, 'a:14) <: 'xs:9
//│ 	[+rev^17 · +rev^17 · +rev^17 · -rev^30 · +count^29 · +count^2 · +count^2]  --->  [+rev^17 · +rev^17 · -rev^30 · +count^29 · +count^2]
//│ 	[+rev^17 · +rev^17 · +rev^17 · -rev^17 · -rev^30 · +count^29 · +count^2 · +count^2]  --->  [+rev^17 · +rev^17 · -rev^17 · -rev^30 · +count^29 · +count^2]
//│ NoProd <: 't:11
//│ 	[+rev^30 · +rev^17 · -rev^30 · +count^29 · +count^2 · +count^2]  --->  [+rev^30 · +rev^17 · -rev^30 · +count^29 · +count^2]
//│ 	[+rev^30 · +rev^17 · +rev^17 · -rev^30 · +count^29 · +count^2 · +count^2 · +count^2]  --->  [+rev^30 · +rev^17 · +rev^17 · -rev^30 · +count^29 · +count^2 · +count^2]
//│ 	[+rev^30 · +rev^17 · -rev^17 · -rev^30 · +count^29 · +count^2 · +count^2]  --->  [+rev^30 · +rev^17 · -rev^17 · -rev^30 · +count^29 · +count^2]
//│ 	[+rev^30 · +rev^17 · +rev^17 · -rev^17 · -rev^30 · +count^29 · +count^2 · +count^2 · +count^2]  --->  [+rev^30 · +rev^17 · +rev^17 · -rev^17 · -rev^30 · +count^29 · +count^2 · +count^2]
//│ NoProd <: 'xs:9
//│ 	[+rev^30 · -rev^30 · +count^29 · +count^2 · +count^2]  --->  [+rev^30 · -rev^30 · +count^29 · +count^2]
//│ 	[+rev^30 · -rev^17 · -rev^30 · +count^29 · +count^2 · +count^2]  --->  [+rev^30 · -rev^17 · -rev^30 · +count^29 · +count^2]
//│ NoProd <: 'ys:15
//│ 	[-init^33 · +rev^30 · +rev^17 · +rev^17]  --->  [-init^33 · +rev^30 · +rev^17]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [count^29]
//│ 	[count^29 · count^2]
//│ 		[count^29 · count^2 · count^2] ---> [count^29 · count^2] (only one)
//│ [init^33]
//│ [rev^30]
//│ 	[rev^30 · rev^17]
//│ 		[rev^30 · rev^17 · rev^17] ---> [rev^30 · rev^17] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N] --->
//│ 	case ys:29 of {C h1:30 t1:31 => ((rev^30_rev^17 [C h1:30 a:28]) t1:31) | N => a:28}
//│ [C h1:30 a:28] --->
//│ 	case xs:23 of {C h:24 t:25 => (fun c:26 -> ((count^29_count^2 t:25) ((add:4 c:26) 1))) | N => (fun c:27 -> c:27)}
//│ 	case xs:36 of {C h:37 t:38 => (fun c:39 -> ((count^29_count^2 t:38) ((add:4 c:39) 1))) | N => (fun c:40 -> c:40)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C h1:34 a:32] --->
//│ 	case xs:23 of {C h:24 t:25 => (fun c:26 -> ((count^29_count^2 t:25) ((add:4 c:26) 1))) | N => (fun c:27 -> c:27)}
//│ 	case xs:36 of {C h:37 t:38 => (fun c:39 -> ((count^29_count^2 t:38) ((add:4 c:39) 1))) | N => (fun c:40 -> c:40)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N] --->
//│ 	case xs:23 of {C h:24 t:25 => (fun c:26 -> ((count^29_count^2 t:25) ((add:4 c:26) 1))) | N => (fun c:27 -> c:27)}
//│ 	case xs:36 of {C h:37 t:38 => (fun c:39 -> ((count^29_count^2 t:38) ((add:4 c:39) 1))) | N => (fun c:40 -> c:40)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((count^29 ((rev^30 (fun c:40 -> c:40)) init^33)) 0)
//│ def count = (fun xs:9 -> case xs:9 of {
//│ 	C h:10 t:11 => (fun c:12 -> ((count t:11) ((add:4 c:12) 1)))
//│ 	| N => (fun c:13 -> c:13)})
//│ def count^29 = (fun xs:36 -> xs:36)
//│ def count^29_count^2 = (fun xs:23 -> xs:23)
//│ def init = [N]
//│ def init^33 = a:28
//│ def rev = (fun a:14 -> (fun ys:15 -> case ys:15 of {
//│ 	C h1:16 t1:17 => ((rev [C h1:16 a:14]) t1:17)
//│ 	| N => a:14}))
//│ def rev^30 = (fun a:28 -> (fun ys:29 -> ys:29))
//│ def rev^30_rev^17 = (fun a:32 -> (fun ys:33 -> case ys:33 of {
//│ 	C h1:34 t1:35 => ((rev^30_rev^17 
//│ 		let h:37 = h1:34
//│ 		in let t:38 = a:32
//│ 		in (fun c:39 -> ((count^29_count^2 t:38) ((add:4 c:39) 1)))) t1:35)
//│ 	| N => a:32}))
//│ <<<<<<< after fusion <<<<<<<


// FIXME
// Paper example (original)
fun idxSum(i, xs) = if xs is
    C(h, t) then add(i, idxSum(add(i, 1), t))
    N then 0
fun rev(a, ys) = if ys is
    C(h1, t1) then rev(C(h1, a), t1)
    N then a
idxSum(0, rev(N, N))
//│ |#fun| |idxSum|(|i|,| |xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |add|(|i|,| |idxSum|(|add|(|i|,| |1|)|,| |t|)|)|↵|N| |#then| |0|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|idxSum|(|0|,| |rev|(|N|,| |N|)|)|
//│ Parsed: {fun idxSum = i, xs, => if xs is ‹(C (h, t,)) then add (i, idxSum (add (i, 1,), t,),); (N) then 0›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; idxSum (0, rev (N, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((idxSum^31 0) ((rev^34 [N]) [N]))
//│ def idxSum = (fun i:8 -> (fun xs:9 -> case xs:9 of {
//│ 	C h:10 t:11 => ((add:4 i:8) ((idxSum^5 ((add:4 i:8) 1)) t:11))
//│ 	| N => 0}))
//│ def rev = (fun a:12 -> (fun ys:13 -> case ys:13 of {
//│ 	C h1:14 t1:15 => ((rev^20 [C h1:14 a:12]) t1:15)
//│ 	| N => a:12}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('h1:14, 'a:12) <: 'xs:9
//│ 	[+rev^20 · +rev^20 · +rev^20 · -rev^34 · +idxSum^31 · +idxSum^5 · +idxSum^5]  --->  [+rev^20 · +rev^20 · -rev^34 · +idxSum^31 · +idxSum^5]
//│ 	[+rev^20 · +rev^20 · +rev^20 · -rev^20 · -rev^34 · +idxSum^31 · +idxSum^5 · +idxSum^5]  --->  [+rev^20 · +rev^20 · -rev^20 · -rev^34 · +idxSum^31 · +idxSum^5]
//│ NoProd <: 't:11
//│ 	[+rev^34 · +rev^20 · -rev^34 · +idxSum^31 · +idxSum^5 · +idxSum^5]  --->  [+rev^34 · +rev^20 · -rev^34 · +idxSum^31 · +idxSum^5]
//│ 	[+rev^34 · +rev^20 · +rev^20 · -rev^34 · +idxSum^31 · +idxSum^5 · +idxSum^5 · +idxSum^5]  --->  [+rev^34 · +rev^20 · +rev^20 · -rev^34 · +idxSum^31 · +idxSum^5 · +idxSum^5]
//│ 	[+rev^34 · +rev^20 · -rev^20 · -rev^34 · +idxSum^31 · +idxSum^5 · +idxSum^5]  --->  [+rev^34 · +rev^20 · -rev^20 · -rev^34 · +idxSum^31 · +idxSum^5]
//│ 	[+rev^34 · +rev^20 · +rev^20 · -rev^20 · -rev^34 · +idxSum^31 · +idxSum^5 · +idxSum^5 · +idxSum^5]  --->  [+rev^34 · +rev^20 · +rev^20 · -rev^20 · -rev^34 · +idxSum^31 · +idxSum^5 · +idxSum^5]
//│ NoProd <: 'xs:9
//│ 	[+rev^34 · -rev^34 · +idxSum^31 · +idxSum^5 · +idxSum^5]  --->  [+rev^34 · -rev^34 · +idxSum^31 · +idxSum^5]
//│ 	[+rev^34 · -rev^20 · -rev^34 · +idxSum^31 · +idxSum^5 · +idxSum^5]  --->  [+rev^34 · -rev^20 · -rev^34 · +idxSum^31 · +idxSum^5]
//│ NoProd <: 'ys:13
//│ 	[+rev^34 · +rev^20 · +rev^20]  --->  [+rev^34 · +rev^20]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [idxSum^31]
//│ 	[idxSum^31 · idxSum^5]
//│ 		[idxSum^31 · idxSum^5 · idxSum^5] ---> [idxSum^31 · idxSum^5] (only one)
//│ [rev^34]
//│ 	[rev^34 · rev^20]
//│ 		[rev^34 · rev^20 · rev^20] ---> [rev^34 · rev^20] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N] --->
//│ 	case xs:21 of {C h:22 t:23 => ((add:4 i:20) ((idxSum^31_idxSum^5 ((add:4 i:20) 1)) t:23)) | N => 0}
//│ 	case xs:33 of {C h:34 t:35 => ((add:4 i:32) ((idxSum^31_idxSum^5 ((add:4 i:32) 1)) t:35)) | N => 0}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N] --->
//│ 	case ys:25 of {C h1:26 t1:27 => ((rev^34_rev^20 [C h1:26 a:24]) t1:27) | N => a:24}
//│ [C h1:26 a:24] --->
//│ 	case xs:21 of {C h:22 t:23 => ((add:4 i:20) ((idxSum^31_idxSum^5 ((add:4 i:20) 1)) t:23)) | N => 0}
//│ 	case xs:33 of {C h:34 t:35 => ((add:4 i:32) ((idxSum^31_idxSum^5 ((add:4 i:32) 1)) t:35)) | N => 0}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C h1:30 a:28] --->
//│ 	case xs:21 of {C h:22 t:23 => ((add:4 i:20) ((idxSum^31_idxSum^5 ((add:4 i:20) 1)) t:23)) | N => 0}
//│ 	case xs:33 of {C h:34 t:35 => ((add:4 i:32) ((idxSum^31_idxSum^5 ((add:4 i:32) 1)) t:35)) | N => 0}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((idxSum^31 0) ((rev^34 0) a:24))
//│ def idxSum = (fun i:8 -> (fun xs:9 -> case xs:9 of {
//│ 	C h:10 t:11 => ((add:4 i:8) ((idxSum ((add:4 i:8) 1)) t:11))
//│ 	| N => 0}))
//│ def idxSum^31 = (fun i:32 -> (fun xs:33 -> xs:33))
//│ def idxSum^31_idxSum^5 = (fun i:20 -> (fun xs:21 -> xs:21))
//│ def rev = (fun a:12 -> (fun ys:13 -> case ys:13 of {
//│ 	C h1:14 t1:15 => ((rev [C h1:14 a:12]) t1:15)
//│ 	| N => a:12}))
//│ def rev^34 = (fun a:24 -> (fun ys:25 -> ys:25))
//│ def rev^34_rev^20 = (fun a:28 -> (fun ys:29 -> case ys:29 of {
//│ 	C h1:30 t1:31 => ((rev^34_rev^20 
//│ 		let h:34 = h1:30
//│ 		in let t:35 = a:28
//│ 		in ((add:4 i:32) ((idxSum^31_idxSum^5 ((add:4 i:32) 1)) t:35))) t1:31)
//│ 	| N => a:28}))
//│ <<<<<<< after fusion <<<<<<<




fun count(xs) = if xs is
    C(h, t) then add(1, count(t))
    N then 0
fun rev(a, ys) = if ys is
    C(h1, t1) then rev(C(h1, a), t1)
    N then a
fun init = N
count(rev(N, init))
//│ |#fun| |count|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |add|(|1|,| |count|(|t|)|)|↵|N| |#then| |0|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |init| |#=| |N|↵|count|(|rev|(|N|,| |init|)|)|
//│ Parsed: {fun count = xs, => if xs is ‹(C (h, t,)) then add (1, count (t,),); (N) then 0›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; fun init = N; count (rev (N, init,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (count^25 ((rev^26 [N]) init^29))
//│ def count = (fun xs:9 -> case xs:9 of {
//│ 	C h:10 t:11 => ((add:4 1) (count^5 t:11))
//│ 	| N => 0})
//│ def init = [N]
//│ def rev = (fun a:12 -> (fun ys:13 -> case ys:13 of {
//│ 	C h1:14 t1:15 => ((rev^13 [C h1:14 a:12]) t1:15)
//│ 	| N => a:12}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('h1:14, 'a:12) <: 'xs:9
//│ 	[+rev^13 · +rev^13 · +rev^13 · -rev^26 · +count^25 · +count^5 · +count^5]  --->  [+rev^13 · +rev^13 · -rev^26 · +count^25 · +count^5]
//│ 	[+rev^13 · +rev^13 · +rev^13 · -rev^13 · -rev^26 · +count^25 · +count^5 · +count^5]  --->  [+rev^13 · +rev^13 · -rev^13 · -rev^26 · +count^25 · +count^5]
//│ NoProd <: 't:11
//│ 	[+rev^26 · +rev^13 · -rev^26 · +count^25 · +count^5 · +count^5]  --->  [+rev^26 · +rev^13 · -rev^26 · +count^25 · +count^5]
//│ 	[+rev^26 · +rev^13 · +rev^13 · -rev^26 · +count^25 · +count^5 · +count^5 · +count^5]  --->  [+rev^26 · +rev^13 · +rev^13 · -rev^26 · +count^25 · +count^5 · +count^5]
//│ 	[+rev^26 · +rev^13 · -rev^13 · -rev^26 · +count^25 · +count^5 · +count^5]  --->  [+rev^26 · +rev^13 · -rev^13 · -rev^26 · +count^25 · +count^5]
//│ 	[+rev^26 · +rev^13 · +rev^13 · -rev^13 · -rev^26 · +count^25 · +count^5 · +count^5 · +count^5]  --->  [+rev^26 · +rev^13 · +rev^13 · -rev^13 · -rev^26 · +count^25 · +count^5 · +count^5]
//│ NoProd <: 'ys:13
//│ 	[-init^29 · +rev^26 · +rev^13 · +rev^13]  --->  [-init^29 · +rev^26 · +rev^13]
//│ NoProd <: 'xs:9
//│ 	[+rev^26 · -rev^26 · +count^25 · +count^5 · +count^5]  --->  [+rev^26 · -rev^26 · +count^25 · +count^5]
//│ 	[+rev^26 · -rev^13 · -rev^26 · +count^25 · +count^5 · +count^5]  --->  [+rev^26 · -rev^13 · -rev^26 · +count^25 · +count^5]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [count^25]
//│ 	[count^25 · count^5]
//│ 		[count^25 · count^5 · count^5] ---> [count^25 · count^5] (only one)
//│ [init^29]
//│ [rev^26]
//│ 	[rev^26 · rev^13]
//│ 		[rev^26 · rev^13 · rev^13] ---> [rev^26 · rev^13] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1:23 a:21] --->
//│ 	case xs:25 of {C h:26 t:27 => ((add:4 1) (count^25_count^5 t:27)) | N => 0}
//│ 	case xs:32 of {C h:33 t:34 => ((add:4 1) (count^25_count^5 t:34)) | N => 0}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N] --->
//│ 	case ys:29 of {C h1:30 t1:31 => ((rev^26_rev^13 [C h1:30 a:28]) t1:31) | N => a:28}
//│ [C h1:30 a:28] --->
//│ 	case xs:25 of {C h:26 t:27 => ((add:4 1) (count^25_count^5 t:27)) | N => 0}
//│ 	case xs:32 of {C h:33 t:34 => ((add:4 1) (count^25_count^5 t:34)) | N => 0}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N] --->
//│ 	case xs:25 of {C h:26 t:27 => ((add:4 1) (count^25_count^5 t:27)) | N => 0}
//│ 	case xs:32 of {C h:33 t:34 => ((add:4 1) (count^25_count^5 t:34)) | N => 0}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (count^25 ((rev^26 0) init^29))
//│ def count = (fun xs:9 -> case xs:9 of {
//│ 	C h:10 t:11 => ((add:4 1) (count t:11))
//│ 	| N => 0})
//│ def count^25 = (fun xs:32 -> xs:32)
//│ def count^25_count^5 = (fun xs:25 -> case xs:25 of {
//│ 	C h:26 t:27 => ((add:4 1) (count^25_count^5 t:27))
//│ 	| N => 0})
//│ def init = [N]
//│ def init^29 = a:28
//│ def rev = (fun a:12 -> (fun ys:13 -> case ys:13 of {
//│ 	C h1:14 t1:15 => ((rev [C h1:14 a:12]) t1:15)
//│ 	| N => a:12}))
//│ def rev^26 = (fun a:28 -> (fun ys:29 -> ys:29))
//│ def rev^26_rev^13 = (fun a:21 -> (fun ys:22 -> case ys:22 of {
//│ 	C h1:23 t1:24 => ((rev^26_rev^13 
//│ 		let h:33 = h1:23
//│ 		in let t:34 = a:21
//│ 		in ((add:4 1) (count^25_count^5 t:34))) t1:24)
//│ 	| N => a:21}))
//│ <<<<<<< after fusion <<<<<<<


fun rev(a, ys) = if ys is
    C(h1, t1) then rev(C(h1, a), t1)
    N then a
fun init = C(0, init)
rev(N, init)
//│ |#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |init| |#=| |C|(|0|,| |init|)|↵|rev|(|N|,| |init|)|
//│ Parsed: {fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; fun init = C (0, init,); rev (N, init,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev^16 [N]) init^19)
//│ def init = [C 0 init^14]
//│ def rev = (fun a:8 -> (fun ys:9 -> case ys:9 of {
//│ 	C h1:10 t1:11 => ((rev^2 [C h1:10 a:8]) t1:11)
//│ 	| N => a:8}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(Int, 'init:7) <: 'ys:9
//│ 	[-init^14 · -init^14 · -init^19 · +rev^16 · +rev^2 · +rev^2]  --->  [-init^14 · -init^19 · +rev^16 · +rev^2]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [init^19]
//│ 	[init^19 · init^14]
//│ 		[init^19 · init^14 · init^14] ---> [init^19 · init^14] (only one)
//│ [rev^16]
//│ 	[rev^16 · rev^2]
//│ 		[rev^16 · rev^2 · rev^2] ---> [rev^16 · rev^2] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 0 init^19_init^14] --->
//│ 	case ys:21 of {C h1:22 t1:23 => ((rev^16_rev^2 [C h1:22 a:20]) t1:23) | N => a:20}
//│ [C 0 init^19_init^14] --->
//│ 	case ys:17 of {C h1:18 t1:19 => ((rev^16_rev^2 [C h1:18 a:16]) t1:19) | N => a:16}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev^16 [N]) init^19)
//│ def init = [C 0 init]
//│ def init^19 = 
//│ 	let h1:22 = 0
//│ 	in let t1:23 = init^19_init^14
//│ 	in ((rev^16_rev^2 [C h1:22 a:20]) t1:23)
//│ def init^19_init^14 = 
//│ 	let h1:18 = 0
//│ 	in let t1:19 = init^19_init^14
//│ 	in ((rev^16_rev^2 [C h1:18 a:16]) t1:19)
//│ def rev = (fun a:8 -> (fun ys:9 -> case ys:9 of {
//│ 	C h1:10 t1:11 => ((rev [C h1:10 a:8]) t1:11)
//│ 	| N => a:8}))
//│ def rev^16 = (fun a:20 -> (fun ys:21 -> ys:21))
//│ def rev^16_rev^2 = (fun a:16 -> (fun ys:17 -> ys:17))
//│ <<<<<<< after fusion <<<<<<<

fun rev(a, ys) = if ys is
    C(h1, t1) then rev(C(h1, a), t1)
fun init = C(0, init)
rev(N, init)
//│ |#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|←|↵|#fun| |init| |#=| |C|(|0|,| |init|)|↵|rev|(|N|,| |init|)|
//│ Parsed: {fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,)›; fun init = C (0, init,); rev (N, init,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev^15 [N]) init^18)
//│ def init = [C 0 init^13]
//│ def rev = (fun a:8 -> (fun ys:9 -> case ys:9 of {
//│ 	C h1:10 t1:11 => ((rev^2 [C h1:10 a:8]) t1:11)}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(Int, 'init:7) <: 'ys:9
//│ 	[-init^13 · -init^13 · -init^18 · +rev^15 · +rev^2 · +rev^2]  --->  [-init^13 · -init^18 · +rev^15 · +rev^2]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [init^18]
//│ 	[init^18 · init^13]
//│ 		[init^18 · init^13 · init^13] ---> [init^18 · init^13] (only one)
//│ [rev^15]
//│ 	[rev^15 · rev^2]
//│ 		[rev^15 · rev^2 · rev^2] ---> [rev^15 · rev^2] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 0 init^18_init^13] --->
//│ 	case ys:17 of {C h1:18 t1:19 => ((rev^15_rev^2 [C h1:18 a:16]) t1:19)}
//│ [C 0 init^18_init^13] --->
//│ 	case ys:21 of {C h1:22 t1:23 => ((rev^15_rev^2 [C h1:22 a:20]) t1:23)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev^15 [N]) init^18)
//│ def init = [C 0 init]
//│ def init^18 = 
//│ 	let h1:22 = 0
//│ 	in let t1:23 = init^18_init^13
//│ 	in ((rev^15_rev^2 [C h1:22 a:20]) t1:23)
//│ def init^18_init^13 = 
//│ 	let h1:18 = 0
//│ 	in let t1:19 = init^18_init^13
//│ 	in ((rev^15_rev^2 [C h1:18 a:16]) t1:19)
//│ def rev = (fun a:8 -> (fun ys:9 -> case ys:9 of {
//│ 	C h1:10 t1:11 => ((rev [C h1:10 a:8]) t1:11)}))
//│ def rev^15 = (fun a:20 -> (fun ys:21 -> ys:21))
//│ def rev^15_rev^2 = (fun a:16 -> (fun ys:17 -> ys:17))
//│ <<<<<<< after fusion <<<<<<<

fun c(x) = if x is
    C(a) then c(a)
    N then N
//│ |#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|↵|N| |#then| |N|←|
//│ Parsed: {fun c = x, => if x is ‹(C (a,)) then c (a,); (N) then N›}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def c = (fun x:7 -> case x:7 of {
//│ 	C a:8 => (c^2 a:8)
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ def c = (fun x:7 -> case x:7 of {
//│ 	C a:8 => (c a:8)
//│ 	| N => [N]})
//│ <<<<<<< after fusion <<<<<<<


fun rev(a, ys) = if ys is
    C(h1, t1) then rev(a, t1)
    N then a
fun rev2(a2, ys2) = if ys2 is
    C(h12, t12) then rev2(a2, t12)
    N then a2
fun init = C(0, init)
fun init2 = C(0, init2)
rev(rev2, init)(1, init2)
//│ |#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|a|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |rev2|(|a2|,| |ys2|)| |#=| |#if| |ys2| |is|→|C|(|h12|,| |t12|)| |#then| |rev2|(|a2|,| |t12|)|↵|N| |#then| |a2|←|↵|#fun| |init| |#=| |C|(|0|,| |init|)|↵|#fun| |init2| |#=| |C|(|0|,| |init2|)|↵|rev|(|rev2|,| |init|)|(|1|,| |init2|)|
//│ Parsed: {fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (a, t1,); (N) then a›; fun rev2 = a2, ys2, => if ys2 is ‹(C (h12, t12,)) then rev2 (a2, t12,); (N) then a2›; fun init = C (0, init,); fun init2 = C (0, init2,); rev (rev2, init,) (1, init2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((((rev^27 rev2^28) init^30) 1) init2^34)
//│ def init = [C 0 init^22]
//│ def init2 = [C 0 init2^25]
//│ def rev = (fun a:10 -> (fun ys:11 -> case ys:11 of {
//│ 	C h1:12 t1:13 => ((rev^2 a:10) t1:13)
//│ 	| N => a:10}))
//│ def rev2 = (fun a2:14 -> (fun ys2:15 -> case ys2:15 of {
//│ 	C h12:16 t12:17 => ((rev2^12 a2:14) t12:17)
//│ 	| N => a2:14}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(Int, 'init2:9) <: 'ys2:15
//│ 	[-init2^25 · -init2^34 · +rev^27 · +rev^2 · -rev^27 · +rev2^28 · +rev2^12]  --->  [-init2^34 · +rev^27 · +rev^2 · -rev^27 · +rev2^28]
//│ 	[-init2^25 · -init2^34 · +rev^27 · -rev^27 · +rev2^28 · +rev2^12]  --->  [-init2^34 · +rev^27 · -rev^27 · +rev2^28]
//│ C(Int, 'init:8) <: 'ys:11
//│ 	[-init^22 · -init^22 · -init^30 · +rev^27 · +rev^2 · +rev^2]  --->  [-init^22 · -init^30 · +rev^27 · +rev^2]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [init2^34]
//│ 	[init2^34 · init2^25] ---> [init2^34] (only one)
//│ [init^30]
//│ 	[init^30 · init^22]
//│ 		[init^30 · init^22 · init^22] ---> [init^30 · init^22] (only one)
//│ [rev2^28]
//│ 	[rev2^28 · rev2^12] ---> [rev2^28] (only one)
//│ [rev^27]
//│ 	[rev^27 · rev^2]
//│ 		[rev^27 · rev^2 · rev^2] ---> [rev^27 · rev^2] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 0 init^30_init^22] --->
//│ 	case ys:33 of {C h1:34 t1:35 => ((rev^27_rev^2 a:32) t1:35) | N => a:32}
//│ [C 0 init^30_init^22] --->
//│ 	case ys:25 of {C h1:26 t1:27 => ((rev^27_rev^2 a:24) t1:27) | N => a:24}
//│ [C 0 init2^34] --->
//│ 	case ys2:29 of {C h12:30 t12:31 => ((rev2^28 a2:28) t12:31) | N => a2:28}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((((rev^27 rev2^28) init^30) 1) init2^34)
//│ def init = [C 0 init]
//│ def init2 = [C 0 init2]
//│ def init2^34 = 
//│ 	let h12:30 = 0
//│ 	in let t12:31 = init2^34
//│ 	in ((rev2^28 a2:28) t12:31)
//│ def init^30 = 
//│ 	let h1:34 = 0
//│ 	in let t1:35 = init^30_init^22
//│ 	in ((rev^27_rev^2 a:32) t1:35)
//│ def init^30_init^22 = 
//│ 	let h1:26 = 0
//│ 	in let t1:27 = init^30_init^22
//│ 	in ((rev^27_rev^2 a:24) t1:27)
//│ def rev = (fun a:10 -> (fun ys:11 -> case ys:11 of {
//│ 	C h1:12 t1:13 => ((rev a:10) t1:13)
//│ 	| N => a:10}))
//│ def rev2 = (fun a2:14 -> (fun ys2:15 -> case ys2:15 of {
//│ 	C h12:16 t12:17 => ((rev2 a2:14) t12:17)
//│ 	| N => a2:14}))
//│ def rev2^28 = (fun a2:28 -> (fun ys2:29 -> ys2:29))
//│ def rev^27 = (fun a:32 -> (fun ys:33 -> ys:33))
//│ def rev^27_rev^2 = (fun a:24 -> (fun ys:25 -> ys:25))
//│ <<<<<<< after fusion <<<<<<<
