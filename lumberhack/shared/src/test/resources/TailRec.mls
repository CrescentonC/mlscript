:NewParser
:ParseOnly


// WRONG: Initial program, not immediately fusable:
_LUMBERHACK_ERROR
fun count(c, xs) = if xs is
  C(h, t) then count(c + 1, t)
  N then c
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
count(0, rev(N, N))
//│ |_LUMBERHACK_ERROR|↵|#fun| |count|(|c|,| |xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |count|(|c| |+| |1|,| |t|)|↵|N| |#then| |c|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|count|(|0|,| |rev|(|N|,| |N|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun count = c, xs, => if xs is ‹(C (h, t,)) then count (+ (c,) (1,), t,); (N) then c›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; count (0, rev (N, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((count^27 0) ((rev^30 [N]) [N]))
//│ def count = (fun c⁰ -> (fun xs⁰ -> case xs⁰ of {
//│ 	C h⁰ t⁰ => ((count^2 (c⁰ + 1)) t⁰)
//│ 	| N => c⁰}))
//│ def rev = (fun a⁰ -> (fun ys⁰ -> case ys⁰ of {
//│ 	C h1⁰ t1⁰ => ((rev^16 [C h1⁰ a⁰]) t1⁰)
//│ 	| N => a⁰}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [count^27] (hopeless to continue)
//│ 	[count^27 · count^2] ---> [count^27] (using original def)
//│ [rev^30]
//│ 	[rev^30 · rev^16] (hopeless to continue)
//│ 		[rev^30 · rev^16 · rev^16] ---> [rev^30 · rev^16] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((count₀ 0) ((rev₀ [N]) [N]))
//│ def count₀ = 
//│ 	(fun c¹ -> (fun xs¹ -> case xs¹ of {
//│ 		C h¹ t¹ => ((count₀ (c¹ + 1)) t¹)
//│ 		| N => c¹}))
//│ def rev₀ = 
//│ 	(fun a¹ -> (fun ys¹ -> case ys¹ of {
//│ 		C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹)
//│ 		| N => a¹}))
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun a² -> (fun ys² -> case ys² of {
//│ 			C h1² t1² => ((rev₁ [C h1² a²]) t1²)
//│ 			| N => a²}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1² a²]: 52 --->
//│ 	case xs¹ of {C h¹ t¹ => ((count₀ (c¹ + 1)) t¹) | N => c¹}: 71
//│ [C h1¹ a¹]: 40 --->
//│ 	case xs¹ of {C h¹ t¹ => ((count₀ (c¹ + 1)) t¹) | N => c¹}: 71
//│ [N]: 80 --->
//│ 	case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹) | N => a¹}: 45
//│ [N]: 78 --->
//│ 	case xs¹ of {C h¹ t¹ => ((count₀ (c¹ + 1)) t¹) | N => c¹}: 71
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 80 --->
//│ 	case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹) | N => a¹}: 45
//│ ------------------
//│ case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹) | N => a¹}: 45 --->
//│ 	[N]: 80
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((count₀ 0) ((rev₀ [N]) a¹))
//│ def count₀ = 
//│ 	(fun c¹ -> (fun xs¹ -> case xs¹ of {
//│ 		C h¹ t¹ => ((count₀ (c¹ + 1)) t¹)
//│ 		| N => c¹}))
//│ def rev₀ = 
//│ 	(fun a¹ -> (fun ys¹ -> ys¹))
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun a² -> (fun ys² -> case ys² of {
//│ 			C h1² t1² => ((rev₁ [C h1² a²]) t1²)
//│ 			| N => a²}))
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: binding not found: Ident(false,a,1)
//│ !!!!!!ERROR!!!!!!


// WRONG:
// Fusablified program:
_LUMBERHACK_ERROR
fun count(xs) = if xs is
  C(h, t) then c => count(t)(c + 1)
  N then c => c
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
fun init = N
count(rev(N, init))(0)
//│ |_LUMBERHACK_ERROR|↵|#fun| |count|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |c| |=>| |count|(|t|)|(|c| |+| |1|)|↵|N| |#then| |c| |=>| |c|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |init| |#=| |N|↵|count|(|rev|(|N|,| |init|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun count = xs, => if xs is ‹(C (h, t,)) then c, => count (t,) (+ (c,) (1,),); (N) then c, => c›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; fun init = N; count (rev (N, init,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((count^29 ((rev^30 [N]) init^33)) 0)
//│ def count = (fun xs⁰ -> case xs⁰ of {
//│ 	C h⁰ t⁰ => (fun c⁰ -> ((count^2 t⁰) (c⁰ + 1)))
//│ 	| N => (fun c¹ -> c¹)})
//│ def init = [N]
//│ def rev = (fun a⁰ -> (fun ys⁰ -> case ys⁰ of {
//│ 	C h1⁰ t1⁰ => ((rev^17 [C h1⁰ a⁰]) t1⁰)
//│ 	| N => a⁰}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [count^29] (hopeless to continue)
//│ 	[count^29 · count^2] ---> [count^29] (using original def)
//│ [init^33] (hopeless to continue)
//│ [rev^30]
//│ 	[rev^30 · rev^17] (hopeless to continue)
//│ 		[rev^30 · rev^17 · rev^17] ---> [rev^30 · rev^17] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((count₀ ((rev₀ [N]) init₀)) 0)
//│ def count₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		C h¹ t¹ => (fun c² -> ((count₀ t¹) (c² + 1)))
//│ 		| N => (fun c³ -> c³)})
//│ def init₀ = 
//│ 	[N]
//│ def rev₀ = 
//│ 	(fun a¹ -> (fun ys¹ -> case ys¹ of {
//│ 		C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹)
//│ 		| N => a¹}))
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun a² -> (fun ys² -> case ys² of {
//│ 			C h1² t1² => ((rev₁ [C h1² a²]) t1²)
//│ 			| N => a²}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1² a²]: 69 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c² -> ((count₀ t¹) (c² + 1))) | N => (fun c³ -> c³)}: 63
//│ [C h1¹ a¹]: 42 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c² -> ((count₀ t¹) (c² + 1))) | N => (fun c³ -> c³)}: 63
//│ [N]: 80 --->
//│ 	case xs¹ of {C h¹ t¹ => (fun c² -> ((count₀ t¹) (c² + 1))) | N => (fun c³ -> c³)}: 63
//│ [N]: 77 --->
//│ 	case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹) | N => a¹}: 47
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 77 --->
//│ 	case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹) | N => a¹}: 47
//│ ------------------
//│ case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹) | N => a¹}: 47 --->
//│ 	[N]: 77
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((count₀ ((rev₀ [N]) init₀)) 0)
//│ def count₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		C h¹ t¹ => (fun c² -> ((count₀ t¹) (c² + 1)))
//│ 		| N => (fun c³ -> c³)})
//│ def init₀ = 
//│ 	a¹
//│ def rev₀ = 
//│ 	(fun a¹ -> (fun ys¹ -> ys¹))
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun a² -> (fun ys² -> case ys² of {
//│ 			C h1² t1² => ((rev₁ [C h1² a²]) t1²)
//│ 			| N => a²}))
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: binding not found: Ident(false,a,1)
//│ !!!!!!ERROR!!!!!!


// WRONG:
// FIXME
// Paper example (original)
_LUMBERHACK_ERROR
fun idxSum(i, xs) = if xs is
  C(h, t) then add(i, idxSum(add(i, 1), t))
  N then 0
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
idxSum(0, rev(N, N))
//│ |_LUMBERHACK_ERROR|↵|#fun| |idxSum|(|i|,| |xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |add|(|i|,| |idxSum|(|add|(|i|,| |1|)|,| |t|)|)|↵|N| |#then| |0|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|idxSum|(|0|,| |rev|(|N|,| |N|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun idxSum = i, xs, => if xs is ‹(C (h, t,)) then add (i, idxSum (add (i, 1,), t,),); (N) then 0›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; idxSum (0, rev (N, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((idxSum^31 0) ((rev^34 [N]) [N]))
//│ def idxSum = (fun i⁰ -> (fun xs⁰ -> case xs⁰ of {
//│ 	C h⁰ t⁰ => ((add⁰ i⁰) ((idxSum^5 ((add⁰ i⁰) 1)) t⁰))
//│ 	| N => 0}))
//│ def rev = (fun a⁰ -> (fun ys⁰ -> case ys⁰ of {
//│ 	C h1⁰ t1⁰ => ((rev^20 [C h1⁰ a⁰]) t1⁰)
//│ 	| N => a⁰}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [idxSum^31] (hopeless to continue)
//│ 	[idxSum^31 · idxSum^5] ---> [idxSum^31] (using original def)
//│ [rev^34]
//│ 	[rev^34 · rev^20] (hopeless to continue)
//│ 		[rev^34 · rev^20 · rev^20] ---> [rev^34 · rev^20] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((idxSum₀ 0) ((rev₀ [N]) [N]))
//│ def idxSum₀ = 
//│ 	(fun i¹ -> (fun xs¹ -> case xs¹ of {
//│ 		C h¹ t¹ => ((add⁰ i¹) ((idxSum₀ ((add⁰ i¹) 1)) t¹))
//│ 		| N => 0}))
//│ def rev₀ = 
//│ 	(fun a¹ -> (fun ys¹ -> case ys¹ of {
//│ 		C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹)
//│ 		| N => a¹}))
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun a² -> (fun ys² -> case ys² of {
//│ 			C h1² t1² => ((rev₁ [C h1² a²]) t1²)
//│ 			| N => a²}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1² a²]: 56 --->
//│ 	case xs¹ of {C h¹ t¹ => ((add⁰ i¹) ((idxSum₀ ((add⁰ i¹) 1)) t¹)) | N => 0}: 79
//│ [C h1¹ a¹]: 44 --->
//│ 	case xs¹ of {C h¹ t¹ => ((add⁰ i¹) ((idxSum₀ ((add⁰ i¹) 1)) t¹)) | N => 0}: 79
//│ [N]: 86 --->
//│ 	case xs¹ of {C h¹ t¹ => ((add⁰ i¹) ((idxSum₀ ((add⁰ i¹) 1)) t¹)) | N => 0}: 79
//│ [N]: 88 --->
//│ 	case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹) | N => a¹}: 49
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 88 --->
//│ 	case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹) | N => a¹}: 49
//│ ------------------
//│ case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹) | N => a¹}: 49 --->
//│ 	[N]: 88
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((idxSum₀ 0) ((rev₀ [N]) a¹))
//│ def idxSum₀ = 
//│ 	(fun i¹ -> (fun xs¹ -> case xs¹ of {
//│ 		C h¹ t¹ => ((add⁰ i¹) ((idxSum₀ ((add⁰ i¹) 1)) t¹))
//│ 		| N => 0}))
//│ def rev₀ = 
//│ 	(fun a¹ -> (fun ys¹ -> ys¹))
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun a² -> (fun ys² -> case ys² of {
//│ 			C h1² t1² => ((rev₁ [C h1² a²]) t1²)
//│ 			| N => a²}))
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: binding not found: Ident(false,a,1)
//│ !!!!!!ERROR!!!!!!



// WRONG:
_LUMBERHACK_ERROR
fun count(xs) = if xs is
  C(h, t) then add(1, count(t))
  N then 0
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
fun init = N
count(rev(N, init))
//│ |_LUMBERHACK_ERROR|↵|#fun| |count|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |add|(|1|,| |count|(|t|)|)|↵|N| |#then| |0|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |init| |#=| |N|↵|count|(|rev|(|N|,| |init|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun count = xs, => if xs is ‹(C (h, t,)) then add (1, count (t,),); (N) then 0›; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; fun init = N; count (rev (N, init,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (count^25 ((rev^26 [N]) init^29))
//│ def count = (fun xs⁰ -> case xs⁰ of {
//│ 	C h⁰ t⁰ => ((add⁰ 1) (count^5 t⁰))
//│ 	| N => 0})
//│ def init = [N]
//│ def rev = (fun a⁰ -> (fun ys⁰ -> case ys⁰ of {
//│ 	C h1⁰ t1⁰ => ((rev^13 [C h1⁰ a⁰]) t1⁰)
//│ 	| N => a⁰}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [count^25] (hopeless to continue)
//│ 	[count^25 · count^5] ---> [count^25] (using original def)
//│ [init^29] (hopeless to continue)
//│ [rev^26]
//│ 	[rev^26 · rev^13] (hopeless to continue)
//│ 		[rev^26 · rev^13 · rev^13] ---> [rev^26 · rev^13] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (count₀ ((rev₀ [N]) init₀))
//│ def count₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		C h¹ t¹ => ((add⁰ 1) (count₀ t¹))
//│ 		| N => 0})
//│ def init₀ = 
//│ 	[N]
//│ def rev₀ = 
//│ 	(fun a² -> (fun ys² -> case ys² of {
//│ 		C h1² t1² => ((rev₁ [C h1² a²]) t1²)
//│ 		| N => a²}))
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun a¹ -> (fun ys¹ -> case ys¹ of {
//│ 			C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹)
//│ 			| N => a¹}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h1¹ a¹]: 36 --->
//│ 	case xs¹ of {C h¹ t¹ => ((add⁰ 1) (count₀ t¹)) | N => 0}: 53
//│ [C h1² a²]: 60 --->
//│ 	case xs¹ of {C h¹ t¹ => ((add⁰ 1) (count₀ t¹)) | N => 0}: 53
//│ [N]: 70 --->
//│ 	case xs¹ of {C h¹ t¹ => ((add⁰ 1) (count₀ t¹)) | N => 0}: 53
//│ [N]: 55 --->
//│ 	case ys² of {C h1² t1² => ((rev₁ [C h1² a²]) t1²) | N => a²}: 65
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 55 --->
//│ 	case ys² of {C h1² t1² => ((rev₁ [C h1² a²]) t1²) | N => a²}: 65
//│ ------------------
//│ case ys² of {C h1² t1² => ((rev₁ [C h1² a²]) t1²) | N => a²}: 65 --->
//│ 	[N]: 55
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (count₀ ((rev₀ [N]) init₀))
//│ def count₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		C h¹ t¹ => ((add⁰ 1) (count₀ t¹))
//│ 		| N => 0})
//│ def init₀ = 
//│ 	a²
//│ def rev₀ = 
//│ 	(fun a² -> (fun ys² -> ys²))
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun a¹ -> (fun ys¹ -> case ys¹ of {
//│ 			C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹)
//│ 			| N => a¹}))
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: binding not found: Ident(false,a,2)
//│ !!!!!!ERROR!!!!!!


// WRONG:
_LUMBERHACK_ERROR
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
  N then a
fun init = C(0, init)
rev(N, init)
//│ |_LUMBERHACK_ERROR|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |init| |#=| |C|(|0|,| |init|)|↵|rev|(|N|,| |init|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,); (N) then a›; fun init = C (0, init,); rev (N, init,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev^16 [N]) init^19)
//│ def init = [C 0 init^14]
//│ def rev = (fun a⁰ -> (fun ys⁰ -> case ys⁰ of {
//│ 	C h1⁰ t1⁰ => ((rev^2 [C h1⁰ a⁰]) t1⁰)
//│ 	| N => a⁰}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [init^19]
//│ 	[init^19 · init^14]
//│ 		[init^19 · init^14 · init^14] ---> [init^19 · init^14] (only one)
//│ [rev^16]
//│ 	[rev^16 · rev^2]
//│ 		[rev^16 · rev^2 · rev^2] ---> [rev^16 · rev^2] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev₀ [N]) init₀)
//│ def init₀ = 
//│ 	[C 0 init₁]
//│ 	where
//│ 	def init₁ = 
//│ 		[C 0 init₁]
//│ def rev₀ = 
//│ 	(fun a² -> (fun ys² -> case ys² of {
//│ 		C h1² t1² => ((rev₁ [C h1² a²]) t1²)
//│ 		| N => a²}))
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun a¹ -> (fun ys¹ -> case ys¹ of {
//│ 			C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹)
//│ 			| N => a¹}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 0 init₁]: 50 --->
//│ 	case ys² of {C h1² t1² => ((rev₁ [C h1² a²]) t1²) | N => a²}: 45
//│ [C 0 init₁]: 35 --->
//│ 	case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹) | N => a¹}: 30
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 0 init₁]: 35 --->
//│ 	case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹) | N => a¹}: 30
//│ [C 0 init₁]: 50 --->
//│ 	case ys² of {C h1² t1² => ((rev₁ [C h1² a²]) t1²) | N => a²}: 45
//│ ------------------
//│ case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹) | N => a¹}: 30 --->
//│ 	[C 0 init₁]: 35
//│ case ys² of {C h1² t1² => ((rev₁ [C h1² a²]) t1²) | N => a²}: 45 --->
//│ 	[C 0 init₁]: 50
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev₀ [N]) init₀)
//│ def init₀ = 
//│ 	let h1² = 0
//│ 	in let t1² = init₁
//│ 	in ((rev₁ [C h1² a²]) t1²)
//│ 	where
//│ 	def init₁ = 
//│ 		let h1¹ = 0
//│ 		in let t1¹ = init₁
//│ 		in ((rev₁ [C h1¹ a¹]) t1¹)
//│ def rev₀ = 
//│ 	(fun a² -> (fun ys² -> ys²))
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun a¹ -> (fun ys¹ -> ys¹))
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: binding not found: Ident(false,a,1)
//│ !!!!!!ERROR!!!!!!

// WRONG:
_LUMBERHACK_ERROR
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(C(h1, a), t1)
fun init = C(0, init)
rev(N, init)
//│ |_LUMBERHACK_ERROR|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|C|(|h1|,| |a|)|,| |t1|)|←|↵|#fun| |init| |#=| |C|(|0|,| |init|)|↵|rev|(|N|,| |init|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (C (h1, a,), t1,)›; fun init = C (0, init,); rev (N, init,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev^15 [N]) init^18)
//│ def init = [C 0 init^13]
//│ def rev = (fun a⁰ -> (fun ys⁰ -> case ys⁰ of {
//│ 	C h1⁰ t1⁰ => ((rev^2 [C h1⁰ a⁰]) t1⁰)}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [init^18]
//│ 	[init^18 · init^13]
//│ 		[init^18 · init^13 · init^13] ---> [init^18 · init^13] (only one)
//│ [rev^15]
//│ 	[rev^15 · rev^2]
//│ 		[rev^15 · rev^2 · rev^2] ---> [rev^15 · rev^2] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev₀ [N]) init₀)
//│ def init₀ = 
//│ 	[C 0 init₁]
//│ 	where
//│ 	def init₁ = 
//│ 		[C 0 init₁]
//│ def rev₀ = 
//│ 	(fun a¹ -> (fun ys¹ -> case ys¹ of {
//│ 		C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹)}))
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun a² -> (fun ys² -> case ys² of {
//│ 			C h1² t1² => ((rev₁ [C h1² a²]) t1²)}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 0 init₁]: 22 --->
//│ 	case ys² of {C h1² t1² => ((rev₁ [C h1² a²]) t1²)}: 42
//│ [C 0 init₁]: 47 --->
//│ 	case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹)}: 31
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 0 init₁]: 22 --->
//│ 	case ys² of {C h1² t1² => ((rev₁ [C h1² a²]) t1²)}: 42
//│ [C 0 init₁]: 47 --->
//│ 	case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹)}: 31
//│ ------------------
//│ case ys¹ of {C h1¹ t1¹ => ((rev₁ [C h1¹ a¹]) t1¹)}: 31 --->
//│ 	[C 0 init₁]: 47
//│ case ys² of {C h1² t1² => ((rev₁ [C h1² a²]) t1²)}: 42 --->
//│ 	[C 0 init₁]: 22
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev₀ [N]) init₀)
//│ def init₀ = 
//│ 	let h1¹ = 0
//│ 	in let t1¹ = init₁
//│ 	in ((rev₁ [C h1¹ a¹]) t1¹)
//│ 	where
//│ 	def init₁ = 
//│ 		let h1² = 0
//│ 		in let t1² = init₁
//│ 		in ((rev₁ [C h1² a²]) t1²)
//│ def rev₀ = 
//│ 	(fun a¹ -> (fun ys¹ -> ys¹))
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun a² -> (fun ys² -> ys²))
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: binding not found: Ident(false,a,2)
//│ !!!!!!ERROR!!!!!!



// WRONG:
_LUMBERHACK_ERROR
fun rev(a, ys) = if ys is
  C(h1, t1) then rev(a, t1)
  N then a
fun rev2(a2, ys2) = if ys2 is
  C(h12, t12) then rev2(a2, t12)
  N then a2
fun init = C(0, init)
fun init2 = C(0, init2)
rev(rev2, init)(1, init2)
//│ |_LUMBERHACK_ERROR|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h1|,| |t1|)| |#then| |rev|(|a|,| |t1|)|↵|N| |#then| |a|←|↵|#fun| |rev2|(|a2|,| |ys2|)| |#=| |#if| |ys2| |is|→|C|(|h12|,| |t12|)| |#then| |rev2|(|a2|,| |t12|)|↵|N| |#then| |a2|←|↵|#fun| |init| |#=| |C|(|0|,| |init|)|↵|#fun| |init2| |#=| |C|(|0|,| |init2|)|↵|rev|(|rev2|,| |init|)|(|1|,| |init2|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun rev = a, ys, => if ys is ‹(C (h1, t1,)) then rev (a, t1,); (N) then a›; fun rev2 = a2, ys2, => if ys2 is ‹(C (h12, t12,)) then rev2 (a2, t12,); (N) then a2›; fun init = C (0, init,); fun init2 = C (0, init2,); rev (rev2, init,) (1, init2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((((rev^27 rev2^28) init^30) 1) init2^34)
//│ def init = [C 0 init^22]
//│ def init2 = [C 0 init2^25]
//│ def rev = (fun a⁰ -> (fun ys⁰ -> case ys⁰ of {
//│ 	C h1⁰ t1⁰ => ((rev^2 a⁰) t1⁰)
//│ 	| N => a⁰}))
//│ def rev2 = (fun a2⁰ -> (fun ys2⁰ -> case ys2⁰ of {
//│ 	C h12⁰ t12⁰ => ((rev2^12 a2⁰) t12⁰)
//│ 	| N => a2⁰}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [init2^34]
//│ 	[init2^34 · init2^25] ---> [init2^34] (only one)
//│ [init^30]
//│ 	[init^30 · init^22]
//│ 		[init^30 · init^22 · init^22] ---> [init^30 · init^22] (only one)
//│ [rev2^28]
//│ 	[rev2^28 · rev2^12] ---> [rev2^28] (only one)
//│ [rev^27]
//│ 	[rev^27 · rev^2]
//│ 		[rev^27 · rev^2 · rev^2] ---> [rev^27 · rev^2] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((((rev₀ rev2₀) init₀) 1) init2₀)
//│ def init2₀ = 
//│ 	[C 0 init2₀]
//│ def init₀ = 
//│ 	[C 0 init₁]
//│ 	where
//│ 	def init₁ = 
//│ 		[C 0 init₁]
//│ def rev2₀ = 
//│ 	(fun a2¹ -> (fun ys2¹ -> case ys2¹ of {
//│ 		C h12¹ t12¹ => ((rev2₀ a2¹) t12¹)
//│ 		| N => a2¹}))
//│ def rev₀ = 
//│ 	(fun a¹ -> (fun ys¹ -> case ys¹ of {
//│ 		C h1¹ t1¹ => ((rev₁ a¹) t1¹)
//│ 		| N => a¹}))
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun a² -> (fun ys² -> case ys² of {
//│ 			C h1² t1² => ((rev₁ a²) t1²)
//│ 			| N => a²}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 0 init2₀]: 38 --->
//│ 	case ys2¹ of {C h12¹ t12¹ => ((rev2₀ a2¹) t12¹) | N => a2¹}: 62
//│ [C 0 init₁]: 54 --->
//│ 	case ys² of {C h1² t1² => ((rev₁ a²) t1²) | N => a²}: 72
//│ [C 0 init₁]: 41 --->
//│ 	case ys¹ of {C h1¹ t1¹ => ((rev₁ a¹) t1¹) | N => a¹}: 49
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 0 init2₀]: 38 --->
//│ 	case ys2¹ of {C h12¹ t12¹ => ((rev2₀ a2¹) t12¹) | N => a2¹}: 62
//│ [C 0 init₁]: 41 --->
//│ 	case ys¹ of {C h1¹ t1¹ => ((rev₁ a¹) t1¹) | N => a¹}: 49
//│ [C 0 init₁]: 54 --->
//│ 	case ys² of {C h1² t1² => ((rev₁ a²) t1²) | N => a²}: 72
//│ ------------------
//│ case ys¹ of {C h1¹ t1¹ => ((rev₁ a¹) t1¹) | N => a¹}: 49 --->
//│ 	[C 0 init₁]: 41
//│ case ys2¹ of {C h12¹ t12¹ => ((rev2₀ a2¹) t12¹) | N => a2¹}: 62 --->
//│ 	[C 0 init2₀]: 38
//│ case ys² of {C h1² t1² => ((rev₁ a²) t1²) | N => a²}: 72 --->
//│ 	[C 0 init₁]: 54
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((((rev₀ rev2₀) init₀) 1) init2₀)
//│ def init2₀ = 
//│ 	let h12¹ = 0
//│ 	in let t12¹ = init2₀
//│ 	in ((rev2₀ a2¹) t12¹)
//│ def init₀ = 
//│ 	let h1¹ = 0
//│ 	in let t1¹ = init₁
//│ 	in ((rev₁ a¹) t1¹)
//│ 	where
//│ 	def init₁ = 
//│ 		let h1² = 0
//│ 		in let t1² = init₁
//│ 		in ((rev₁ a²) t1²)
//│ def rev2₀ = 
//│ 	(fun a2¹ -> (fun ys2¹ -> ys2¹))
//│ def rev₀ = 
//│ 	(fun a¹ -> (fun ys¹ -> ys¹))
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun a² -> (fun ys² -> ys²))
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: binding not found: Ident(false,a,1)
//│ !!!!!!ERROR!!!!!!
