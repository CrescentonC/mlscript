:NewParser
:ParseOnly


fun map(ls) = if ls is
  C(h, t) then C(
    primitive(h),
    map(t)
  )
  N then N
let l = C(K, C(KK, l))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|primitive|(|h|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |l|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C (primitive (h,), map (t,),); (N) then N›; let l = C (K, C (KK, l,),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^17 l^18)
//│ def l = [C [K] [C [KK] l^14]]
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C (primitive⁰ h⁰) (map^5 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^18]
//│ 	[l^18 · l^14] ---> [l^18] (only one)
//│ [map^17]
//│ 	[map^17 · map^5]
//│ 		[map^17 · map^5 · map^5] ---> [map^17] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	[C [K] [C [KK] l₀]]
//│ def map₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h² t² => [C (primitive⁰ h²) (map₁ t²)]
//│ 		| N => [N]})
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls¹ -> case ls¹ of {
//│ 			C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)]
//│ 			| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [KK] l₀]: 45 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 29
//│ [C [K] [C [KK] l₀]]: 46 --->
//│ 	case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 40
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 29 --->
//│ 	[C [KK] l₀]: 45
//│ case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 40 --->
//│ 	[C [K] [C [KK] l₀]]: 46
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [KK] l₀]: 45 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 29
//│ [C [K] [C [KK] l₀]]: 46 --->
//│ 	case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 40
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 29 --->
//│ 	[C [KK] l₀]: 45
//│ case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 40 --->
//│ 	[C [K] [C [KK] l₀]]: 46
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	let h³ = [K]
//│ 	in let t³ = 	
//│ 		let h⁴ = [KK]
//│ 		in let t⁴ = l₀
//│ 		in [C (primitive⁰ h⁴) (map₀ t⁴)]
//│ 	in [C (primitive⁰ h³) (map₁ t³)]
//│ def map₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls³ -> ls³)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l₀^2] (hopeless to continue)
//│ 	[l₀^2 · l₀^10] ---> [l₀^2] (using original def)
//│ 	[l₀^2 · map₀^14] (using original def)
//│ 	[l₀^2 · map₁^23] (using original def)
//│ [map₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀₁ l₀₀)
//│ def l₀₀ = 
//│ 	let h² = [K]
//│ 	in let t² = 	
//│ 		let h³ = [KK]
//│ 		in let t³ = l₀₀
//│ 		in [C (primitive⁰ h³) (map₀₀ t³)]
//│ 	in [C (primitive⁰ h²) (map₁₀ t²)]
//│ 	where
//│ 	def map₀₀ = 
//│ 		(fun ls² -> ls²)
//│ 	def map₁₀ = 
//│ 		(fun ls³ -> ls³)
//│ def map₀₁ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀₁ l₀₀)
//│ def l₀₀ = 
//│ 	let h² = [K]
//│ 	in let t² = 	
//│ 		let h³ = [KK]
//│ 		in let t³ = l₀₀
//│ 		in [C (primitive⁰ h³) (map₀₀ t³)]
//│ 	in [C (primitive⁰ h²) (map₁₀ t²)]
//│ 	where
//│ 	def map₀₀ = 
//│ 		(fun ls⁵ -> ls⁵)
//│ 	def map₁₀ = 
//│ 		(fun ls⁶ -> ls⁶)
//│ def map₀₁ = 
//│ 	(fun ls⁷ -> ls⁷)
//│ <<<<<<< after fusion <<<<<<<


fun map(ls) = if ls is
  C(h, t) then C(
    primitive(h),
    map(t)
  )
  N then N
let l = C(K, C(KK, l))
map(C(S, l))
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|primitive|(|h|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |l|)|)|↵|map|(|C|(|S|,| |l|)|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C (primitive (h,), map (t,),); (N) then N›; let l = C (K, C (KK, l,),); map (C (S, l,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^17 [C [S] l^19])
//│ def l = [C [K] [C [KK] l^14]]
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C (primitive⁰ h⁰) (map^5 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^19] (hopeless to continue)
//│ 	[l^19 · l^14] ---> [l^19] (using original def)
//│ [map^17]
//│ 	[map^17 · map^5]
//│ 		[map^17 · map^5 · map^5] ---> [map^17] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀ [C [S] l₀])
//│ def l₀ = 
//│ 	[C [K] [C [KK] l₀]]
//│ def map₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h² t² => [C (primitive⁰ h²) (map₁ t²)]
//│ 		| N => [N]})
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls¹ -> case ls¹ of {
//│ 			C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)]
//│ 			| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [KK] l₀]: 47 --->
//│ 	case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 42
//│ [C [K] [C [KK] l₀]]: 48 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 31
//│ [C [S] l₀]: 52 --->
//│ 	case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 42
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 31 --->
//│ 	[C [K] [C [KK] l₀]]: 48
//│ case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 42 --->
//│ 	[C [KK] l₀]: 47
//│ 	[C [S] l₀]: 52
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [KK] l₀]: 47 --->
//│ 	case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 42
//│ [C [K] [C [KK] l₀]]: 48 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 31
//│ [C [S] l₀]: 52 --->
//│ 	case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 42
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 31 --->
//│ 	[C [K] [C [KK] l₀]]: 48
//│ case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 42 --->
//│ 	[C [KK] l₀]: 47
//│ 	[C [S] l₀]: 52
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀ 
//│ 	let h³ = [S]
//│ 	in let t³ = l₀
//│ 	in [C (primitive⁰ h³) (map₁ t³)])
//│ def l₀ = 
//│ 	let h⁴ = [K]
//│ 	in let t⁴ = 	
//│ 		let h⁵ = [KK]
//│ 		in let t⁵ = l₀
//│ 		in [C (primitive⁰ h⁵) (map₁ t⁵)]
//│ 	in [C (primitive⁰ h⁴) (map₀ t⁴)]
//│ def map₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls³ -> ls³)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l₀^3] (hopeless to continue)
//│ 	[l₀^3 · l₀^20] ---> [l₀^3] (using original def)
//│ 	[l₀^3 · map₀^33] (using original def)
//│ 	[l₀^3 · map₁^24] (using original def)
//│ [map₀^1] (hopeless to continue)
//│ [map₁^7] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀₁ 
//│ 	let h⁵ = [S]
//│ 	in let t⁵ = l₀₀
//│ 	in [C (primitive⁰ h⁵) (map₁₁ t⁵)])
//│ def l₀₀ = 
//│ 	let h³ = [K]
//│ 	in let t³ = 	
//│ 		let h⁴ = [KK]
//│ 		in let t⁴ = l₀₀
//│ 		in [C (primitive⁰ h⁴) (map₁₀ t⁴)]
//│ 	in [C (primitive⁰ h³) (map₀₀ t³)]
//│ 	where
//│ 	def map₀₀ = 
//│ 		(fun ls³ -> ls³)
//│ 	def map₁₀ = 
//│ 		(fun ls² -> ls²)
//│ def map₀₁ = 
//│ 	(fun ls⁵ -> ls⁵)
//│ def map₁₁ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀₁ 
//│ 	let h⁵ = [S]
//│ 	in let t⁵ = l₀₀
//│ 	in [C (primitive⁰ h⁵) (map₁₁ t⁵)])
//│ def l₀₀ = 
//│ 	let h³ = [K]
//│ 	in let t³ = 	
//│ 		let h⁴ = [KK]
//│ 		in let t⁴ = l₀₀
//│ 		in [C (primitive⁰ h⁴) (map₁₀ t⁴)]
//│ 	in [C (primitive⁰ h³) (map₀₀ t³)]
//│ 	where
//│ 	def map₀₀ = 
//│ 		(fun ls⁷ -> ls⁷)
//│ 	def map₁₀ = 
//│ 		(fun ls⁹ -> ls⁹)
//│ def map₀₁ = 
//│ 	(fun ls⁸ -> ls⁸)
//│ def map₁₁ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ <<<<<<< after fusion <<<<<<<


fun map(ls) = if ls is
  C(h, t) then C(
    primitive(h),
    map(t)
  )
  N then N
let l = C(K, C(KK, C(KKK, l)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|primitive|(|h|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKK|,| |l|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C (primitive (h,), map (t,),); (N) then N›; let l = C (K, C (KK, C (KKK, l,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^19 l^20)
//│ def l = [C [K] [C [KK] [C [KKK] l^15]]]
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C (primitive⁰ h⁰) (map^5 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^20]
//│ 	[l^20 · l^15] ---> [l^20] (only one)
//│ [map^19]
//│ 	[map^19 · map^5]
//│ 		[map^19 · map^5 · map^5]
//│ 			[map^19 · map^5 · map^5 · map^5] ---> [map^19] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	[C [K] [C [KK] [C [KKK] l₀]]]
//│ def map₀ = 
//│ 	(fun ls³ -> case ls³ of {
//│ 		C h³ t³ => [C (primitive⁰ h³) (map₁ t³)]
//│ 		| N => [N]})
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls² -> case ls² of {
//│ 			C h² t² => [C (primitive⁰ h²) (map₂ t²)]
//│ 			| N => [N]})
//│ 		where
//│ 		def map₂ = 
//│ 			(fun ls¹ -> case ls¹ of {
//│ 				C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)]
//│ 				| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [KKK] l₀]: 48 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 31
//│ [C [KK] [C [KKK] l₀]]: 49 --->
//│ 	case ls² of {C h² t² => [C (primitive⁰ h²) (map₂ t²)] | N => [N]}: 42
//│ [C [K] [C [KK] [C [KKK] l₀]]]: 50 --->
//│ 	case ls³ of {C h³ t³ => [C (primitive⁰ h³) (map₁ t³)] | N => [N]}: 60
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 31 --->
//│ 	[C [KKK] l₀]: 48
//│ case ls² of {C h² t² => [C (primitive⁰ h²) (map₂ t²)] | N => [N]}: 42 --->
//│ 	[C [KK] [C [KKK] l₀]]: 49
//│ case ls³ of {C h³ t³ => [C (primitive⁰ h³) (map₁ t³)] | N => [N]}: 60 --->
//│ 	[C [K] [C [KK] [C [KKK] l₀]]]: 50
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [KKK] l₀]: 48 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 31
//│ [C [KK] [C [KKK] l₀]]: 49 --->
//│ 	case ls² of {C h² t² => [C (primitive⁰ h²) (map₂ t²)] | N => [N]}: 42
//│ [C [K] [C [KK] [C [KKK] l₀]]]: 50 --->
//│ 	case ls³ of {C h³ t³ => [C (primitive⁰ h³) (map₁ t³)] | N => [N]}: 60
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 31 --->
//│ 	[C [KKK] l₀]: 48
//│ case ls² of {C h² t² => [C (primitive⁰ h²) (map₂ t²)] | N => [N]}: 42 --->
//│ 	[C [KK] [C [KKK] l₀]]: 49
//│ case ls³ of {C h³ t³ => [C (primitive⁰ h³) (map₁ t³)] | N => [N]}: 60 --->
//│ 	[C [K] [C [KK] [C [KKK] l₀]]]: 50
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	let h⁴ = [K]
//│ 	in let t⁴ = 	
//│ 		let h⁵ = [KK]
//│ 		in let t⁵ = 	
//│ 			let h⁶ = [KKK]
//│ 			in let t⁶ = l₀
//│ 			in [C (primitive⁰ h⁶) (map₀ t⁶)]
//│ 		in [C (primitive⁰ h⁵) (map₂ t⁵)]
//│ 	in [C (primitive⁰ h⁴) (map₁ t⁴)]
//│ def map₀ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls⁵ -> ls⁵)
//│ 		where
//│ 		def map₂ = 
//│ 			(fun ls⁴ -> ls⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l₀^2] (hopeless to continue)
//│ 	[l₀^2 · l₀^11] ---> [l₀^2] (using original def)
//│ 	[l₀^2 · map₀^15] (using original def)
//│ 	[l₀^2 · map₁^33] (using original def)
//│ 	[l₀^2 · map₂^24] (using original def)
//│ [map₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀₁ l₀₀)
//│ def l₀₀ = 
//│ 	let h³ = [K]
//│ 	in let t³ = 	
//│ 		let h⁴ = [KK]
//│ 		in let t⁴ = 	
//│ 			let h⁵ = [KKK]
//│ 			in let t⁵ = l₀₀
//│ 			in [C (primitive⁰ h⁵) (map₀₀ t⁵)]
//│ 		in [C (primitive⁰ h⁴) (map₂₀ t⁴)]
//│ 	in [C (primitive⁰ h³) (map₁₀ t³)]
//│ 	where
//│ 	def map₀₀ = 
//│ 		(fun ls⁵ -> ls⁵)
//│ 	def map₁₀ = 
//│ 		(fun ls³ -> ls³)
//│ 	def map₂₀ = 
//│ 		(fun ls⁴ -> ls⁴)
//│ def map₀₁ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀₁ l₀₀)
//│ def l₀₀ = 
//│ 	let h³ = [K]
//│ 	in let t³ = 	
//│ 		let h⁴ = [KK]
//│ 		in let t⁴ = 	
//│ 			let h⁵ = [KKK]
//│ 			in let t⁵ = l₀₀
//│ 			in [C (primitive⁰ h⁵) (map₀₀ t⁵)]
//│ 		in [C (primitive⁰ h⁴) (map₂₀ t⁴)]
//│ 	in [C (primitive⁰ h³) (map₁₀ t³)]
//│ 	where
//│ 	def map₀₀ = 
//│ 		(fun ls⁷ -> ls⁷)
//│ 	def map₁₀ = 
//│ 		(fun ls⁹ -> ls⁹)
//│ 	def map₂₀ = 
//│ 		(fun ls¹⁰ -> ls¹⁰)
//│ def map₀₁ = 
//│ 	(fun ls⁸ -> ls⁸)
//│ <<<<<<< after fusion <<<<<<<
