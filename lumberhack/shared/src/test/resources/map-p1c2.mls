:NewParser
:ParseOnly


fun map(ls) = if ls is
  C(h, t) then C(
    primitive(h),
    map(t)
  )
  N then N
let l = C(K, C(KK, l))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|primitive|(|h|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |l|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C (primitive (h,), map (t,),); (N) then N›; let l = C (K, C (KK, l,),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^17 l^18)
//│ def l = [C [K] [C [KK] l^14]]
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C (primitive⁰ h⁰) (map^5 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^18]
//│ 	[l^18 · l^14] ---> [l^18] (only one)
//│ [map^17]
//│ 	[map^17 · map^5]
//│ 		[map^17 · map^5 · map^5] ---> [map^17] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	[C [K] [C [KK] l₀]]
//│ def map₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h² t² => [C (primitive⁰ h²) (map₁ t²)]
//│ 		| N => [N]})
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls¹ -> case ls¹ of {
//│ 			C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)]
//│ 			| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [KK] l₀]: 45 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 29
//│ [C [K] [C [KK] l₀]]: 46 --->
//│ 	case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 40
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [KK] l₀]: 45 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 29
//│ [C [K] [C [KK] l₀]]: 46 --->
//│ 	case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 40
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 29 --->
//│ 	[C [KK] l₀]: 45
//│ case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 40 --->
//│ 	[C [K] [C [KK] l₀]]: 46
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	let h³ = [K]
//│ 	in let t³ = 	
//│ 		let h⁴ = [KK]
//│ 		in let t⁴ = l₀
//│ 		in [C (primitive⁰ h⁴) (map₀ t⁴)]
//│ 	in [C (primitive⁰ h³) (map₁ t³)]
//│ def map₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls³ -> ls³)
//│ <<<<<<< after fusion <<<<<<<


fun map(ls) = if ls is
  C(h, t) then C(
    primitive(h),
    map(t)
  )
  N then N
let l = C(K, C(KK, l))
map(C(S, l))
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|primitive|(|h|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |l|)|)|↵|map|(|C|(|S|,| |l|)|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C (primitive (h,), map (t,),); (N) then N›; let l = C (K, C (KK, l,),); map (C (S, l,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^17 [C [S] l^19])
//│ def l = [C [K] [C [KK] l^14]]
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C (primitive⁰ h⁰) (map^5 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^19] (hopeless to continue)
//│ 	[l^19 · l^14] ---> [l^19] (using original def)
//│ [map^17]
//│ 	[map^17 · map^5]
//│ 		[map^17 · map^5 · map^5] ---> [map^17] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀ [C [S] l₀])
//│ def l₀ = 
//│ 	[C [K] [C [KK] l₀]]
//│ def map₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h² t² => [C (primitive⁰ h²) (map₁ t²)]
//│ 		| N => [N]})
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls¹ -> case ls¹ of {
//│ 			C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)]
//│ 			| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [KK] l₀]: 47 --->
//│ 	case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 42
//│ [C [K] [C [KK] l₀]]: 48 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 31
//│ [C [S] l₀]: 52 --->
//│ 	case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 42
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [KK] l₀]: 47 --->
//│ 	case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 42
//│ [C [K] [C [KK] l₀]]: 48 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 31
//│ [C [S] l₀]: 52 --->
//│ 	case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 42
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C (primitive⁰ h¹) (map₀ t¹)] | N => [N]}: 31 --->
//│ 	[C [K] [C [KK] l₀]]: 48
//│ case ls² of {C h² t² => [C (primitive⁰ h²) (map₁ t²)] | N => [N]}: 42 --->
//│ 	[C [KK] l₀]: 47
//│ 	[C [S] l₀]: 52
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀ 
//│ 	let h³ = [S]
//│ 	in let t³ = l₀
//│ 	in [C (primitive⁰ h³) (map₁ t³)])
//│ def l₀ = 
//│ 	let h⁴ = [K]
//│ 	in let t⁴ = 	
//│ 		let h⁵ = [KK]
//│ 		in let t⁵ = l₀
//│ 		in [C (primitive⁰ h⁵) (map₁ t⁵)]
//│ 	in [C (primitive⁰ h⁴) (map₀ t⁴)]
//│ def map₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls³ -> ls³)
//│ <<<<<<< after fusion <<<<<<<



