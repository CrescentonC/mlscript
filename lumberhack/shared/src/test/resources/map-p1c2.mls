:NewParser
:ParseOnly


fun map(ls) = if ls is
  C(h, t) then C(
    primitive(h),
    map(t)
  )
  N then N
let l = C(K, C(KK, l))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|primitive|(|h|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |l|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C (primitive (h,), map (t,),); (N) then N›; let l = C (K, C (KK, l,),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^17(l^18)
//│ def l = [C [K] [C [KK] l^14]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C primitive⁰(h⁰) map^5(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [KK] l]: 15 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ [C [K] [C [KK] l]]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10 --->
//│ 	[C [KK] l]: 15
//│ 	[C [K] [C [KK] l]]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [KK] l]: 15 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ [C [K] [C [KK] l]]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10 --->
//│ 	[C [KK] l]: 15
//│ 	[C [K] [C [KK] l]]: 16
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(l)
//│ def l = 
//│ 	let t¹ = 	
//│ 		let t² = l
//│ 		in let h² = [KK]
//│ 		in (fun _lh_dummy¹ -> [C primitive⁰(h²) map(t²)])
//│ 	in let h¹ = [K]
//│ 	in (fun _lh_dummy⁰ -> [C primitive⁰(h¹) map(t¹)])
//│ def map(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<


fun map(ls) = if ls is
  C(h, t) then C(
    primitive(h),
    map(t)
  )
  N then N
let l = C(K, C(KK, l))
map(C(S, l))
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|primitive|(|h|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |l|)|)|↵|map|(|C|(|S|,| |l|)|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C (primitive (h,), map (t,),); (N) then N›; let l = C (K, C (KK, l,),); map (C (S, l,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^17([C [S] l^19])
//│ def l = [C [K] [C [KK] l^14]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C primitive⁰(h⁰) map^5(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [KK] l]: 15 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ [C [K] [C [KK] l]]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ [C [S] l]: 20 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10 --->
//│ 	[C [KK] l]: 15
//│ 	[C [K] [C [KK] l]]: 16
//│ 	[C [S] l]: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [KK] l]: 15 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ [C [K] [C [KK] l]]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ [C [S] l]: 20 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10 --->
//│ 	[C [KK] l]: 15
//│ 	[C [K] [C [KK] l]]: 16
//│ 	[C [S] l]: 20
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(
//│ 	let t¹ = l
//│ 	in let h¹ = [S]
//│ 	in (fun _lh_dummy⁰ -> [C primitive⁰(h¹) map(t¹)]))
//│ def l = 
//│ 	let t² = 	
//│ 		let t³ = l
//│ 		in let h³ = [KK]
//│ 		in (fun _lh_dummy² -> [C primitive⁰(h³) map(t³)])
//│ 	in let h² = [K]
//│ 	in (fun _lh_dummy¹ -> [C primitive⁰(h²) map(t²)])
//│ def map(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<


fun map(ls) = if ls is
  C(h, t) then C(
    primitive(h),
    map(t)
  )
  N then N
let l = C(K, C(KK, C(KKK, l)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|primitive|(|h|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKK|,| |l|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C (primitive (h,), map (t,),); (N) then N›; let l = C (K, C (KK, C (KKK, l,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^19(l^20)
//│ def l = [C [K] [C [KK] [C [KKK] l^15]]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C primitive⁰(h⁰) map^5(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [KKK] l]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ [C [KK] [C [KKK] l]]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ [C [K] [C [KK] [C [KKK] l]]]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10 --->
//│ 	[C [KKK] l]: 16
//│ 	[C [KK] [C [KKK] l]]: 17
//│ 	[C [K] [C [KK] [C [KKK] l]]]: 18
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [KKK] l]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ [C [KK] [C [KKK] l]]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ [C [K] [C [KK] [C [KKK] l]]]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C primitive⁰(h⁰) map(t⁰)] | N  => [N]}: 10 --->
//│ 	[C [KKK] l]: 16
//│ 	[C [KK] [C [KKK] l]]: 17
//│ 	[C [K] [C [KK] [C [KKK] l]]]: 18
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(l)
//│ def l = 
//│ 	let t¹ = 	
//│ 		let t² = 	
//│ 			let t³ = l
//│ 			in let h³ = [KKK]
//│ 			in (fun _lh_dummy² -> [C primitive⁰(h³) map(t³)])
//│ 		in let h² = [KK]
//│ 		in (fun _lh_dummy¹ -> [C primitive⁰(h²) map(t²)])
//│ 	in let h¹ = [K]
//│ 	in (fun _lh_dummy⁰ -> [C primitive⁰(h¹) map(t¹)])
//│ def map(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
