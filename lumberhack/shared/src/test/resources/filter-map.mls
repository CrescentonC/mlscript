:NewParser
:ParseOnly


fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun filter(xs, p) = if xs is
  C(h, t) then if p(h) then C(h, filter(t, p)) else filter(t, p)
  N then N
filter(map(primitive, primitive), primitive)
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |filter|(|xs|,| |p|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |p|(|h|)| |#then| |C|(|h|,| |filter|(|t|,| |p|)|)| |#else| |filter|(|t|,| |p|)|↵|N| |#then| |N|←|↵|filter|(|map|(|primitive|,| |primitive|)|,| |primitive|)|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun filter = xs, p, => if xs is ‹(C (h, t,)) then if (p (h,)) then C (h, filter (t, p,),) else filter (t, p,); (N) then N›; filter (map (primitive, primitive,), primitive,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ filter^36(map^37(primitive⁰, primitive⁰), primitive⁰)
//│ def filter(xs⁰, p⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => if p⁰(h¹) then [C h¹ filter^20(t¹, p⁰)] else filter^26(t¹, p⁰)
//│ 	| N  => [N]}
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case xs⁰ of {C h¹ t¹ => if p⁰(h¹) then [C h¹ filter(t¹, p⁰)] else filter(t¹, p⁰) | N  => [N]}: 33
//│ [N]: 11 --->
//│ 	case xs⁰ of {C h¹ t¹ => if p⁰(h¹) then [C h¹ filter(t¹, p⁰)] else filter(t¹, p⁰) | N  => [N]}: 33
//│ ------------------
//│ case xs⁰ of {C h¹ t¹ => if p⁰(h¹) then [C h¹ filter(t¹, p⁰)] else filter(t¹, p⁰) | N  => [N]}: 33 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case xs⁰ of {C h¹ t¹ => if p⁰(h¹) then [C h¹ filter(t¹, p⁰)] else filter(t¹, p⁰) | N  => [N]}: 33
//│ [N]: 11 --->
//│ 	case xs⁰ of {C h¹ t¹ => if p⁰(h¹) then [C h¹ filter(t¹, p⁰)] else filter(t¹, p⁰) | N  => [N]}: 33
//│ ------------------
//│ case xs⁰ of {C h¹ t¹ => if p⁰(h¹) then [C h¹ filter(t¹, p⁰)] else filter(t¹, p⁰) | N  => [N]}: 33 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ filter(map(primitive⁰, primitive⁰), primitive⁰)
//│ def filter(xs¹, p³) = xs¹(p³)
//│ def map(ls¹, f¹) = case ls¹ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t² = map(t⁰, f¹)
//│ 		in let h² = f¹(h⁰)
//│ 		in (fun p¹ -> if p¹(h²) then [C h² filter(t², p¹)] else filter(t², p¹))
//│ 	| N  => (fun p² -> [N])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ filter
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ map -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ map(primitive⁰, primitive⁰, primitive⁰)
//│ def filter(xs⁰, p²) = xs⁰(p²)
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t¹ = map(t⁰, f⁰)
//│ 		in let h¹ = f⁰(h⁰)
//│ 		in (fun p⁰ -> if p⁰(h¹) then [C h¹ t¹(p⁰)] else t¹(p⁰))
//│ 	| N  => (fun p¹ -> [N])}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ map(primitive⁰, primitive⁰, primitive⁰)
//│ def filter(xs⁰, p⁰) = xs⁰(p⁰)
//│ def map(ls⁰, f⁰, _lh_popOutId_0⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t¹ = map(t⁰, f⁰)
//│ 		in let h¹ = f⁰(h⁰)
//│ 		in if _lh_popOutId_0⁰(h¹) then [C h¹ t¹(_lh_popOutId_0⁰)] else t¹(_lh_popOutId_0⁰)
//│ 	| N  => [N]}
//│ <<<<<<< after floating out <<<<<<<

_LUMBERHACK_EVAL
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun filter(xs, p) = if xs is
  C(h, t) then if p(h) then C(h, filter(t, p)) else filter(t, p)
  N then N
filter(map(C(1, C(2, C(3, N))), x => x * 2), x => x > 3)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |filter|(|xs|,| |p|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |p|(|h|)| |#then| |C|(|h|,| |filter|(|t|,| |p|)|)| |#else| |filter|(|t|,| |p|)|↵|N| |#then| |N|←|↵|filter|(|map|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|,| |x| |=>| |x| |*| |2|)|,| |x| |=>| |x| |>| |3|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun filter = xs, p, => if xs is ‹(C (h, t,)) then if (p (h,)) then C (h, filter (t, p,),) else filter (t, p,); (N) then N›; filter (map (C (1, C (2, C (3, N,),),), x, => * (x,) (2,),), x, => > (x,) (3,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ filter^36(map^37([C 1 [C 2 [C 3 [N]]]], (fun x⁰ -> (x⁰ * 2))), (fun x¹ -> (x¹ > 3)))
//│ def filter(xs⁰, p⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => if p⁰(h¹) then [C h¹ filter^20(t¹, p⁰)] else filter^26(t¹, p⁰)
//│ 	| N  => [N]}
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 4 [C 6 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case xs⁰ of {C h¹ t¹ => if p⁰(h¹) then [C h¹ filter(t¹, p⁰)] else filter(t¹, p⁰) | N  => [N]}: 33
//│ [N]: 11 --->
//│ 	case xs⁰ of {C h¹ t¹ => if p⁰(h¹) then [C h¹ filter(t¹, p⁰)] else filter(t¹, p⁰) | N  => [N]}: 33
//│ [N]: 41 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [C 3 [N]]: 42 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [C 2 [C 3 [N]]]: 43 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [C 1 [C 2 [C 3 [N]]]]: 44 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 41
//│ 	[C 3 [N]]: 42
//│ 	[C 2 [C 3 [N]]]: 43
//│ 	[C 1 [C 2 [C 3 [N]]]]: 44
//│ case xs⁰ of {C h¹ t¹ => if p⁰(h¹) then [C h¹ filter(t¹, p⁰)] else filter(t¹, p⁰) | N  => [N]}: 33 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case xs⁰ of {C h¹ t¹ => if p⁰(h¹) then [C h¹ filter(t¹, p⁰)] else filter(t¹, p⁰) | N  => [N]}: 33
//│ [N]: 11 --->
//│ 	case xs⁰ of {C h¹ t¹ => if p⁰(h¹) then [C h¹ filter(t¹, p⁰)] else filter(t¹, p⁰) | N  => [N]}: 33
//│ [N]: 41 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [C 3 [N]]: 42 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [C 2 [C 3 [N]]]: 43 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [C 1 [C 2 [C 3 [N]]]]: 44 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 41
//│ 	[C 3 [N]]: 42
//│ 	[C 2 [C 3 [N]]]: 43
//│ 	[C 1 [C 2 [C 3 [N]]]]: 44
//│ case xs⁰ of {C h¹ t¹ => if p⁰(h¹) then [C h¹ filter(t¹, p⁰)] else filter(t¹, p⁰) | N  => [N]}: 33 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ filter(map(
//│ 	let t² = 	
//│ 		let t⁴ = 	
//│ 			let t⁶ = (fun f⁴ -> (fun p⁴ -> [N]))
//│ 			in let h⁶ = 3
//│ 			in (fun f³ -> 
//│ 				let t⁷ = map(t⁶, f³)
//│ 				in let h⁷ = f³(h⁶)
//│ 				in (fun p³ -> if p³(h⁷) then [C h⁷ filter(t⁷, p³)] else filter(t⁷, p³)))
//│ 		in let h⁴ = 2
//│ 		in (fun f² -> 
//│ 			let t⁵ = map(t⁴, f²)
//│ 			in let h⁵ = f²(h⁴)
//│ 			in (fun p² -> if p²(h⁵) then [C h⁵ filter(t⁵, p²)] else filter(t⁵, p²)))
//│ 	in let h² = 1
//│ 	in (fun f¹ -> 
//│ 		let t³ = map(t², f¹)
//│ 		in let h³ = f¹(h²)
//│ 		in (fun p¹ -> if p¹(h³) then [C h³ filter(t³, p¹)] else filter(t³, p¹))), (fun x² -> (x² * 2))), (fun x³ -> (x³ > 3)))
//│ def filter(xs¹, p⁵) = xs¹(p⁵)
//│ def map(ls¹, f⁵) = ls¹(f⁵)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 4 [C 6 [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ filter, map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun f⁰ -> (fun p⁰ -> [N]))
//│ 			in let h⁰ = 3
//│ 			in (fun f¹ -> 
//│ 				let t³ = t²(f¹)
//│ 				in let h¹ = f¹(h⁰)
//│ 				in (fun p¹ -> if p¹(h¹) then [C h¹ t³(p¹)] else t³(p¹)))
//│ 		in let h² = 2
//│ 		in (fun f² -> 
//│ 			let t⁴ = t¹(f²)
//│ 			in let h³ = f²(h²)
//│ 			in (fun p² -> if p²(h³) then [C h³ t⁴(p²)] else t⁴(p²)))
//│ 	in let h⁴ = 1
//│ 	in (fun f³ -> 
//│ 		let t⁵ = t⁰(f³)
//│ 		in let h⁵ = f³(h⁴)
//│ 		in (fun p³ -> if p³(h⁵) then [C h⁵ t⁵(p³)] else t⁵(p³)))((fun x⁰ -> (x⁰ * 2)), (fun x¹ -> (x¹ > 3)))
//│ def filter(xs⁰, p⁴) = xs⁰(p⁴)
//│ def map(ls⁰, f⁴) = ls⁰(f⁴)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun f⁰ -> (fun p⁰ -> [N]))
//│ 			in let h⁰ = 3
//│ 			in (fun f¹ -> 
//│ 				let t³ = t²(f¹)
//│ 				in let h¹ = f¹(h⁰)
//│ 				in (fun p¹ -> if p¹(h¹) then [C h¹ t³(p¹)] else t³(p¹)))
//│ 		in let h² = 2
//│ 		in (fun f² -> 
//│ 			let t⁴ = t¹(f²)
//│ 			in let h³ = f²(h²)
//│ 			in (fun p² -> if p²(h³) then [C h³ t⁴(p²)] else t⁴(p²)))
//│ 	in let h⁴ = 1
//│ 	in (fun f³ -> 
//│ 		let t⁵ = t⁰(f³)
//│ 		in let h⁵ = f³(h⁴)
//│ 		in (fun p³ -> if p³(h⁵) then [C h⁵ t⁵(p³)] else t⁵(p³)))((fun x⁰ -> (x⁰ * 2)), (fun x¹ -> (x¹ > 3)))
//│ def filter(xs⁰, p⁴) = xs⁰(p⁴)
//│ def map(ls⁰, f⁴) = ls⁰(f⁴)
//│ <<<<<<< after floating out <<<<<<<
