:NewParser
:ParseOnly


_LUMBERHACK_EVAL
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then ls
map(map(primId(C(1, C(2, N))), x => x * x), x => x + x)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |ls|←|↵|map|(|map|(|primId|(|C|(|1|,| |C|(|2|,| |N|)|)|)|,| |x| |=>| |x| |*| |x|)|,| |x| |=>| |x| |+| |x|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then ls›; map (map (primId (C (1, C (2, N,),),), x, => * (x,) (x,),), x, => + (x,) (x,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^15(map^16(primId⁰([C 1 [C 2 [N]]]), (fun x⁰ -> (x⁰ * x⁰))), (fun x¹ -> (x¹ + x¹)))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => ls⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 2 [C 8 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => ls⁰}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => ls⁰}: 12 --->
//│ 	NoProd
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(map(primId⁰([C 1 [C 2 [N]]]), (fun x² -> (x² * x²))), (fun x³ -> (x³ + x³)))
//│ def map(ls¹, f¹) = case ls¹ of {
//│ 	C h⁰ t⁰ => [C f¹(h⁰) map(t⁰, f¹)]
//│ 	| N  => ls¹}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 8 [N]]]
//│ <<<<<<< evaluate <<<<<<<
