:NewParser
:ParseOnly

:lhError
:lhInOCaml
let rec a = 4;;
let rec f = function A -> B | C -> D;;
let rec d a b = match a with
  | `A(s, d) -> `D
  | _ -> `S
  | k -> `D;;
let rec f (h:t) = h;;
let val = [false;true;false];;
f val
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ "compilation_unit" (
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"=" ()
//│ 			"number" ()))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"=" ()
//│ 			"function_expression" (
//│ 				"function" ()
//│ 				"match_case" (
//│ 					"constructor_path" (
//│ 						"constructor_name" ())
//│ 					"->" ()
//│ 					"constructor_path" (
//│ 						"constructor_name" ()))
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"constructor_path" (
//│ 						"constructor_name" ())
//│ 					"->" ()
//│ 					"constructor_path" (
//│ 						"constructor_name" ())))))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"parameter" (
//│ 				"value_pattern" ())
//│ 			"parameter" (
//│ 				"value_pattern" ())
//│ 			"=" ()
//│ 			"match_expression" (
//│ 				"match" ()
//│ 				"value_path" (
//│ 					"value_name" ())
//│ 				"with" ()
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"tag_pattern" (
//│ 						"tag" (
//│ 							"`" ())
//│ 						"parenthesized_pattern" (
//│ 							"(" ()
//│ 							"tuple_pattern" (
//│ 								"value_pattern" ()
//│ 								"," ()
//│ 								"value_pattern" ())
//│ 							")" ()))
//│ 					"->" ()
//│ 					"tag" (
//│ 						"`" ()))
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"value_pattern" ()
//│ 					"->" ()
//│ 					"tag" (
//│ 						"`" ()))
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"value_pattern" ()
//│ 					"->" ()
//│ 					"tag" (
//│ 						"`" ())))))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"parameter" (
//│ 				"typed_pattern" (
//│ 					"(" ()
//│ 					"value_pattern" ()
//│ 					":" ()
//│ 					"type_constructor_path" (
//│ 						"type_constructor" ())
//│ 					")" ()))
//│ 			"=" ()
//│ 			"value_path" (
//│ 				"value_name" ())))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"=" ()
//│ 			"list_expression" (
//│ 				"[" ()
//│ 				"boolean" (
//│ 					"false" ())
//│ 				";" ()
//│ 				"boolean" (
//│ 					"true" ())
//│ 				";" ()
//│ 				"boolean" (
//│ 					"false" ())
//│ 				"]" ())))
//│ 	";;" ()
//│ 	"expression_item" (
//│ 		"application_expression" (
//│ 			"value_path" (
//│ 				"value_name" ())
//│ 			"value_path" (
//│ 				"value_name" ()))))
//│ !!!!!!ERROR!!!!!!
//│ scala.NotImplementedError: an implementation is missing
//│ !!!!!!ERROR!!!!!!



:lhInHaskell
:lhGenOCaml
[x | x <- [1,2]]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 	LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]
//│ 	| LH_N  => [LH_N]})
//│ in _lh_listcomp_fun¹([LH_C 1 [LH_C 2 [LH_N]]])
//│ 		---------- unoptimized ocaml gen ----------
//│ 		(let rec _lh_listcomp_fun_1 = (fun _lh_listcomp_fun_para_1 -> 
//│ 		  (match _lh_listcomp_fun_para_1 with
//│ 		    | (_lh_listcomp_fun_ls_h_1 :: _lh_listcomp_fun_ls_t_1) -> 
//│ 		      (_lh_listcomp_fun_ls_h_1::(_lh_listcomp_fun_1 _lh_listcomp_fun_ls_t_1))
//│ 		    | [] -> 
//│ 		      [])) in
//│ 		  (_lh_listcomp_fun_1 (1::(2::[]))))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ 
//│ 	let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 		LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun¹([LH_C 1 [LH_C 2 [LH_N]]])
//│ 
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 30 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ [LH_C 2 [LH_N]]: 31 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ [LH_C 1 [LH_C 2 [LH_N]]]: 32 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ ------------------
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25 --->
//│ 	[LH_N]: 30
//│ 	[LH_C 2 [LH_N]]: 31
//│ 	[LH_C 1 [LH_C 2 [LH_N]]]: 32
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_N]: 30 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ [LH_C 2 [LH_N]]: 31 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ [LH_C 1 [LH_C 2 [LH_N]]]: 32 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ ------------------
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25 --->
//│ 	[LH_N]: 30
//│ 	[LH_C 2 [LH_N]]: 31
//│ 	[LH_C 1 [LH_C 2 [LH_N]]]: 32
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> _lh_listcomp_fun_para²(_lh_listcomp_fun²))
//│ 	in _lh_listcomp_fun²(
//│ 		let _lh_listcomp_fun_ls_h² = 1
//│ 		in let _lh_listcomp_fun_ls_t² = 	
//│ 			let _lh_listcomp_fun_ls_h³ = 2
//│ 			in let _lh_listcomp_fun_ls_t³ = (fun _lh_listcomp_fun⁵ -> [LH_N])
//│ 			in (fun _lh_listcomp_fun⁴ -> [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t³)])
//│ 		in (fun _lh_listcomp_fun³ -> [LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun³(_lh_listcomp_fun_ls_t²)]))
//│ 
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ (let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│   (_lh_listcomp_fun_para_0 _lh_listcomp_fun_0)) in
//│   (_lh_listcomp_fun_0 (let rec _lh_listcomp_fun_ls_h_0 = 1 in
//│     (let rec _lh_listcomp_fun_ls_t_0 = (let rec _lh_listcomp_fun_ls_h_1 = 2 in
//│       (let rec _lh_listcomp_fun_ls_t_1 = (fun _lh_listcomp_fun_1 -> 
//│         []) in
//│         (fun _lh_listcomp_fun_2 -> 
//│           (_lh_listcomp_fun_ls_h_1::(_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_1))))) in
//│       (fun _lh_listcomp_fun_3 -> 
//│         (_lh_listcomp_fun_ls_h_0::(_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_0)))))))
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhInHaskell
:lhGenOCaml
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = [ (q:b) | b <- gen (n-1) nq, q <- [1..nq], safe q 1 b ]
nsoln nq = length (gen nq nq)
nsoln 10
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ nsoln₀^413(10)
//│ def enumFromTo₀(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo₀^276((a² + 1), b²)] else [LH_N]
//│ def gen₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 			LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 				let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 					LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀^353(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 					| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 				in _lh_listcomp_fun³(enumFromTo₀^377(1, _lh_gen_arg2¹))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun²(gen₀^388((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length₀(ls⁷) = case ls⁷ of {
//│ 	LH_C h⁷ t⁸ => (1 + length₀^406(t⁸))
//│ 	| LH_N  => 0}
//│ def nsoln₀(_lh_nsoln_arg1¹) = length₀^290(gen₀^291(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀^331(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_d0 a_2 b_2 =
//│ 		  (if (a_2 <= b_2) then
//│ 		    (a_2::((enumFromTo_d0 (a_2 + 1)) b_2))
//│ 		  else
//│ 		    [])
//│ 		and gen_d0 _lh_gen_arg1_1 _lh_gen_arg2_1 =
//│ 		  (match _lh_gen_arg1_1 with
//│ 		    | 0 -> 
//│ 		      ([]::[])
//│ 		    | _ -> 
//│ 		      (let rec _lh_listcomp_fun_2 = (fun _lh_listcomp_fun_para_2 -> 
//│ 		        (match _lh_listcomp_fun_para_2 with
//│ 		          | (_lh_listcomp_fun_ls_h_2 :: _lh_listcomp_fun_ls_t_2) -> 
//│ 		            (let rec _lh_listcomp_fun_3 = (fun _lh_listcomp_fun_para_3 -> 
//│ 		              (match _lh_listcomp_fun_para_3 with
//│ 		                | (_lh_listcomp_fun_ls_h_3 :: _lh_listcomp_fun_ls_t_3) -> 
//│ 		                  (if (((safe_d0 _lh_listcomp_fun_ls_h_3) 1) _lh_listcomp_fun_ls_h_2) then
//│ 		                    ((_lh_listcomp_fun_ls_h_3::_lh_listcomp_fun_ls_h_2)::(_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3))
//│ 		                  else
//│ 		                    (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3))
//│ 		                | [] -> 
//│ 		                  (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_2))) in
//│ 		              (_lh_listcomp_fun_3 ((enumFromTo_d0 1) _lh_gen_arg2_1)))
//│ 		          | [] -> 
//│ 		            [])) in
//│ 		        (_lh_listcomp_fun_2 ((gen_d0 (_lh_gen_arg1_1 - 1)) _lh_gen_arg2_1))))
//│ 		and length_d0 ls_7 =
//│ 		  (match ls_7 with
//│ 		    | (h_7 :: t_8) -> 
//│ 		      (1 + (length_d0 t_8))
//│ 		    | [] -> 
//│ 		      0)
//│ 		and nsoln_d0 _lh_nsoln_arg1_1 =
//│ 		  (length_d0 ((gen_d0 _lh_nsoln_arg1_1) _lh_nsoln_arg1_1))
//│ 		and safe_d0 _lh_safe_arg1_1 _lh_safe_arg2_1 _lh_safe_arg3_1 =
//│ 		  (match _lh_safe_arg3_1 with
//│ 		    | [] -> 
//│ 		      true
//│ 		    | (_lh_safe_LH_C_0_1 :: _lh_safe_LH_C_1_1) -> 
//│ 		      ((((_lh_safe_arg1_1 != _lh_safe_LH_C_0_1) && (_lh_safe_arg1_1 != (_lh_safe_LH_C_0_1 + _lh_safe_arg2_1))) && (_lh_safe_arg1_1 != (_lh_safe_LH_C_0_1 - _lh_safe_arg2_1))) && (((safe_d0 _lh_safe_arg1_1) (_lh_safe_arg2_1 + 1)) _lh_safe_LH_C_1_1)));;
//│ 		(nsoln_d0 10)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [nsoln₀^413] (hopeless to continue)
//│ 	[nsoln₀^413 · gen₀^291] (using original def)
//│ 		[nsoln₀^413 · gen₀^291 · enumFromTo₀^377] (using original def)
//│ 			[nsoln₀^413 · gen₀^291 · enumFromTo₀^377 · enumFromTo₀^276] ---> [nsoln₀^413 · gen₀^291 · enumFromTo₀^377] (using original def)
//│ 		[nsoln₀^413 · gen₀^291 · gen₀^388] ---> [nsoln₀^413 · gen₀^291] (using original def)
//│ 		[nsoln₀^413 · gen₀^291 · safe₀^353] (using original def)
//│ 			[nsoln₀^413 · gen₀^291 · safe₀^353 · safe₀^331] ---> [nsoln₀^413 · gen₀^291 · safe₀^353] (using original def)
//│ 	[nsoln₀^413 · length₀^290] (using original def)
//│ 		[nsoln₀^413 · length₀^290 · length₀^406] ---> [nsoln₀^413 · length₀^290] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ nsoln₀₀(10)
//│ def nsoln₀₀(_lh_nsoln_arg1¹) = 
//│ 	length₀₀(gen₀₀(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ 	where
//│ 	def gen₀₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = 
//│ 		case _lh_gen_arg1¹ of {
//│ 			0  => [LH_C [LH_N] [LH_N]]
//│ 			| _  => 
//│ 				let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 					LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 						let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 							LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 							| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 						in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹))
//│ 					| LH_N  => [LH_N]})
//│ 				in _lh_listcomp_fun²(gen₀₀((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ 		where
//│ 		def enumFromTo₀₀(a¹, b¹) = 
//│ 			if (a¹ <= b¹) then [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)] else [LH_N]
//│ 		def safe₀₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = 
//│ 			case _lh_safe_arg3¹ of {
//│ 				LH_N  => [True]
//│ 				| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}
//│ 	def length₀₀(ls¹) = 
//│ 		case ls¹ of {
//│ 			LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 			| LH_N  => 0}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 148 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}: 258
//│ [LH_N]: 149 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 185
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 211
//│ [LH_C [LH_N] [LH_N]]: 150 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 185
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 211
//│ [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 162 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}: 258
//│ [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 166 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 185
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 211
//│ [LH_N]: 184 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 185
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 211
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 285 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 174
//│ [LH_N]: 286 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 174
//│ ------------------
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 174 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 285
//│ 	[LH_N]: 286
//│ case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 185 --->
//│ 	[LH_N]: 149
//│ 	[LH_C [LH_N] [LH_N]]: 150
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 166
//│ 	[LH_N]: 184
//│ case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 211 --->
//│ 	[LH_N]: 149
//│ 	[LH_C [LH_N] [LH_N]]: 150
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 166
//│ 	[LH_N]: 184
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}: 258 --->
//│ 	[LH_N]: 148
//│ 	[LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 162
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_N]: 148 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}: 258
//│ [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 162 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}: 258
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 285 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 174
//│ [LH_N]: 286 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 174
//│ ------------------
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 174 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 285
//│ 	[LH_N]: 286
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}: 258 --->
//│ 	[LH_N]: 148
//│ 	[LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 162
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ nsoln₀₀(10)
//│ def nsoln₀₀(_lh_nsoln_arg1²) = 
//│ 	length₀₀(gen₀₀(_lh_nsoln_arg1², _lh_nsoln_arg1²))
//│ 	where
//│ 	def gen₀₀(_lh_gen_arg1², _lh_gen_arg2²) = 
//│ 		case _lh_gen_arg1² of {
//│ 			0  => [LH_C (fun _lh_safe_arg1⁴ -> (fun _lh_safe_arg2⁴ -> [True])) [LH_N]]
//│ 			| _  => 
//│ 				let _lh_listcomp_fun⁸ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {
//│ 					LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 						let _lh_listcomp_fun⁹ = (fun _lh_listcomp_fun_para⁵ -> _lh_listcomp_fun_para⁵(_lh_listcomp_fun_ls_h², _lh_listcomp_fun⁹, _lh_listcomp_fun⁸, _lh_listcomp_fun_ls_t²))
//│ 						in _lh_listcomp_fun⁹(enumFromTo₀₀(1, _lh_gen_arg2²))
//│ 					| LH_N  => [LH_N]})
//│ 				in _lh_listcomp_fun⁸(gen₀₀((_lh_gen_arg1² - 1), _lh_gen_arg2²))}
//│ 		where
//│ 		def enumFromTo₀₀(a², b²) = 
//│ 			if (a² <= b²) then 
//│ 				let _lh_listcomp_fun_ls_h⁴ = a²
//│ 				in let _lh_listcomp_fun_ls_t⁴ = enumFromTo₀₀((a² + 1), b²)
//│ 				in (fun _lh_listcomp_fun_ls_h⁵ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_listcomp_fun⁵ -> (fun _lh_listcomp_fun_ls_t⁵ -> if safe₀₀(_lh_listcomp_fun_ls_h⁴, 1, _lh_listcomp_fun_ls_h⁵) then [LH_C 
//│ 					let _lh_safe_LH_C_0² = _lh_listcomp_fun_ls_h⁴
//│ 					in let _lh_safe_LH_C_1² = _lh_listcomp_fun_ls_h⁵
//│ 					in (fun _lh_safe_arg1² -> (fun _lh_safe_arg2² -> ((((_lh_safe_arg1² /= _lh_safe_LH_C_0²) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0² + _lh_safe_arg2²))) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0² - _lh_safe_arg2²))) && safe₀₀(_lh_safe_arg1², (_lh_safe_arg2² + 1), _lh_safe_LH_C_1²)))) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴))))) else (fun _lh_listcomp_fun_ls_h⁶ -> (fun _lh_listcomp_fun⁶ -> (fun _lh_listcomp_fun⁷ -> (fun _lh_listcomp_fun_ls_t⁶ -> _lh_listcomp_fun⁷(_lh_listcomp_fun_ls_t⁶)))))
//│ 		def safe₀₀(_lh_safe_arg1³, _lh_safe_arg2³, _lh_safe_arg3²) = 
//│ 			_lh_safe_arg3²(_lh_safe_arg1³, _lh_safe_arg2³)
//│ 	def length₀₀(ls²) = 
//│ 		case ls² of {
//│ 			LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 			| LH_N  => 0}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec enumFromTo_d0_d0 a_0 b_0 =
//│   (if (a_0 <= b_0) then
//│     (let rec _lh_listcomp_fun_ls_h_0 = a_0 in
//│       (let rec _lh_listcomp_fun_ls_t_0 = ((enumFromTo_d0_d0 (a_0 + 1)) b_0) in
//│         (fun _lh_listcomp_fun_ls_h_1 _lh_listcomp_fun_0 _lh_listcomp_fun_1 _lh_listcomp_fun_ls_t_1 -> 
//│           (if (((safe_d0_d0 _lh_listcomp_fun_ls_h_0) 1) _lh_listcomp_fun_ls_h_1) then
//│             ((let rec _lh_safe_LH_C_0_0 = _lh_listcomp_fun_ls_h_0 in
//│               (let rec _lh_safe_LH_C_1_0 = _lh_listcomp_fun_ls_h_1 in
//│                 (fun _lh_safe_arg1_0 _lh_safe_arg2_0 -> 
//│                   ((((_lh_safe_arg1_0 != _lh_safe_LH_C_0_0) && (_lh_safe_arg1_0 != (_lh_safe_LH_C_0_0 + _lh_safe_arg2_0))) && (_lh_safe_arg1_0 != (_lh_safe_LH_C_0_0 - _lh_safe_arg2_0))) && (((safe_d0_d0 _lh_safe_arg1_0) (_lh_safe_arg2_0 + 1)) _lh_safe_LH_C_1_0)))))::(_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0))
//│           else
//│             (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0)))))
//│   else
//│     (fun _lh_listcomp_fun_ls_h_2 _lh_listcomp_fun_2 _lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_2 -> 
//│       (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_2)))
//│ and gen_d0_d0 _lh_gen_arg1_0 _lh_gen_arg2_0 =
//│   (match _lh_gen_arg1_0 with
//│     | 0 -> 
//│       ((fun _lh_safe_arg1_2 _lh_safe_arg2_2 -> 
//│         true)::[])
//│     | _ -> 
//│       (let rec _lh_listcomp_fun_4 = (fun _lh_listcomp_fun_para_0 -> 
//│         (match _lh_listcomp_fun_para_0 with
//│           | (_lh_listcomp_fun_ls_h_3 :: _lh_listcomp_fun_ls_t_3) -> 
//│             (let rec _lh_listcomp_fun_5 = (fun _lh_listcomp_fun_para_1 -> 
//│               ((((_lh_listcomp_fun_para_1 _lh_listcomp_fun_ls_h_3) _lh_listcomp_fun_5) _lh_listcomp_fun_4) _lh_listcomp_fun_ls_t_3)) in
//│               (_lh_listcomp_fun_5 ((enumFromTo_d0_d0 1) _lh_gen_arg2_0)))
//│           | [] -> 
//│             [])) in
//│         (_lh_listcomp_fun_4 ((gen_d0_d0 (_lh_gen_arg1_0 - 1)) _lh_gen_arg2_0))))
//│ and length_d0_d0 ls_0 =
//│   (match ls_0 with
//│     | (h_0 :: t_0) -> 
//│       (1 + (length_d0_d0 t_0))
//│     | [] -> 
//│       0)
//│ and nsoln_d0_d0 _lh_nsoln_arg1_0 =
//│   (length_d0_d0 ((gen_d0_d0 _lh_nsoln_arg1_0) _lh_nsoln_arg1_0))
//│ and safe_d0_d0 _lh_safe_arg1_1 _lh_safe_arg2_1 _lh_safe_arg3_0 =
//│   ((_lh_safe_arg3_0 _lh_safe_arg1_1) _lh_safe_arg2_1);;
//│ (nsoln_d0_d0 10)
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<



:lhInHaskell
:lhGenOCaml
testMapmap ls = map (\x -> x + 1) $ map (\x -> x + x) ls
testMapmap $ primId [1..500000]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapmap₀^252(primId⁰(enumFromTo₀^254(1, 500000)))
//│ def enumFromTo₀(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo₀^210((a² + 1), b²)] else [LH_N]
//│ def map₀(f⁴, ls⁷) = case ls⁷ of {
//│ 	LH_C h⁷ t⁸ => [LH_C f⁴(h⁷) map₀^228(f⁴, t⁸)]
//│ 	| LH_N  => [LH_N]}
//│ def map₁(f⁵, ls⁸) = case ls⁸ of {
//│ 	LH_C h⁸ t⁹ => [LH_C f⁵(h⁸) map₁^242(f⁵, t⁹)]
//│ 	| LH_N  => [LH_N]}
//│ def testMapmap₀(_lh_testMapmap_arg1¹) = map₀^184((fun x² -> (x² + 1)), map₁^192((fun x³ -> (x³ + x³)), _lh_testMapmap_arg1¹))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_d0 a_2 b_2 =
//│ 		  (if (a_2 <= b_2) then
//│ 		    (a_2::((enumFromTo_d0 (a_2 + 1)) b_2))
//│ 		  else
//│ 		    [])
//│ 		and map_d0 f_4 ls_7 =
//│ 		  (match ls_7 with
//│ 		    | (h_7 :: t_8) -> 
//│ 		      ((f_4 h_7)::((map_d0 f_4) t_8))
//│ 		    | [] -> 
//│ 		      [])
//│ 		and map_d1 f_5 ls_8 =
//│ 		  (match ls_8 with
//│ 		    | (h_8 :: t_9) -> 
//│ 		      ((f_5 h_8)::((map_d1 f_5) t_9))
//│ 		    | [] -> 
//│ 		      [])
//│ 		and testMapmap_d0 _lh_testMapmap_arg1_1 =
//│ 		  ((map_d0 (fun x_2 -> 
//│ 		    (x_2 + 1))) ((map_d1 (fun x_3 -> 
//│ 		    (x_3 + x_3))) _lh_testMapmap_arg1_1));;
//│ 		(testMapmap_d0 ((enumFromTo_d0 1) 500000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo₀^254]
//│ 	[enumFromTo₀^254 · enumFromTo₀^210] ---> [enumFromTo₀^254] (only one)
//│ [testMapmap₀^252]
//│ 	[testMapmap₀^252 · map₀^184]
//│ 		[testMapmap₀^252 · map₀^184 · map₀^228] ---> [testMapmap₀^252 · map₀^184] (only one)
//│ 	[testMapmap₀^252 · map₁^192]
//│ 		[testMapmap₀^252 · map₁^192 · map₁^242] ---> [testMapmap₀^252 · map₁^192] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testMapmap₀₀(primId⁰(enumFromTo₀₀(1, 500000)))
//│ def enumFromTo₀₀(a¹, b¹) = 
//│ 	if (a¹ <= b¹) then [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)] else [LH_N]
//│ def testMapmap₀₀(_lh_testMapmap_arg1¹) = 
//│ 	map₀₀((fun x² -> (x² + 1)), map₁₀((fun x³ -> (x³ + x³)), _lh_testMapmap_arg1¹))
//│ 	where
//│ 	def map₀₀(f², ls²) = 
//│ 		case ls² of {
//│ 			LH_C h² t² => [LH_C f²(h²) map₀₀(f², t²)]
//│ 			| LH_N  => [LH_N]}
//│ 	def map₁₀(f³, ls³) = 
//│ 		case ls³ of {
//│ 			LH_C h³ t³ => [LH_C f³(h³) map₁₀(f³, t³)]
//│ 			| LH_N  => [LH_N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f³(h³) map₁₀(f³, t³)]: 101 --->
//│ 	case ls² of {LH_C h² t² => [LH_C f²(h²) map₀₀(f², t²)] | LH_N  => [LH_N]}: 89
//│ [LH_N]: 102 --->
//│ 	case ls² of {LH_C h² t² => [LH_C f²(h²) map₀₀(f², t²)] | LH_N  => [LH_N]}: 89
//│ ------------------
//│ case ls² of {LH_C h² t² => [LH_C f²(h²) map₀₀(f², t²)] | LH_N  => [LH_N]}: 89 --->
//│ 	[LH_C f³(h³) map₁₀(f³, t³)]: 101
//│ 	[LH_N]: 102
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f³(h³) map₁₀(f³, t³)]: 101 --->
//│ 	case ls² of {LH_C h² t² => [LH_C f²(h²) map₀₀(f², t²)] | LH_N  => [LH_N]}: 89
//│ [LH_N]: 102 --->
//│ 	case ls² of {LH_C h² t² => [LH_C f²(h²) map₀₀(f², t²)] | LH_N  => [LH_N]}: 89
//│ ------------------
//│ case ls² of {LH_C h² t² => [LH_C f²(h²) map₀₀(f², t²)] | LH_N  => [LH_N]}: 89 --->
//│ 	[LH_C f³(h³) map₁₀(f³, t³)]: 101
//│ 	[LH_N]: 102
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapmap₀₀(primId⁰(enumFromTo₀₀(1, 500000)))
//│ def enumFromTo₀₀(a², b²) = 
//│ 	if (a² <= b²) then [LH_C a² enumFromTo₀₀((a² + 1), b²)] else [LH_N]
//│ def testMapmap₀₀(_lh_testMapmap_arg1²) = 
//│ 	map₀₀((fun x⁴ -> (x⁴ + 1)), map₁₀((fun x⁵ -> (x⁵ + x⁵)), _lh_testMapmap_arg1²))
//│ 	where
//│ 	def map₀₀(f⁴, ls⁴) = 
//│ 		ls⁴(f⁴)
//│ 	def map₁₀(f⁵, ls⁵) = 
//│ 		case ls⁵ of {
//│ 			LH_C h³ t³ => 
//│ 				let h⁴ = f⁵(h³)
//│ 				in let t⁴ = map₁₀(f⁵, t³)
//│ 				in (fun f⁶ -> [LH_C f⁶(h⁴) map₀₀(f⁶, t⁴)])
//│ 			| LH_N  => (fun f⁷ -> [LH_N])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ (*
//│ ocamlfind ocamlopt -rectypes -thread -O3 ./Mapmap.ml -o "./Mapmap.out" -linkpkg -package "core_unix.command_unix" -linkpkg -package "core_bench" && ./Mapmap.out && rm ./*.cmx ./*.out ./*.cmi ./*.o
//│ *)
//│ (* #use "topfind";;
//│ #require "core_unix.command_unix";;
//│ #require "core_bench";; *)
//│ open Core_bench;;
//│ 
//│ (* original *)
//│ let rec enumFromTo_d0 a_2 b_2 =
//│   (if (a_2 <= b_2) then
//│     (a_2::((enumFromTo_d0 (a_2 + 1)) b_2))
//│   else
//│     [])
//│ and map_d0 f_4 ls_7 =
//│   (match ls_7 with
//│     | (h_7 :: t_8) -> 
//│       ((f_4 h_7)::((map_d0 f_4) t_8))
//│     | [] -> 
//│       [])
//│ and map_d1 f_5 ls_8 =
//│   (match ls_8 with
//│     | (h_8 :: t_9) -> 
//│       ((f_5 h_8)::((map_d1 f_5) t_9))
//│     | [] -> 
//│       [])
//│ and testMapmap_d0 _lh_testMapmap_arg1_1 =
//│   ((map_d0 (fun x_2 -> 
//│     (x_2 + 1))) ((map_d1 (fun x_3 -> 
//│     (x_3 + x_3))) _lh_testMapmap_arg1_1));;
//│ 
//│ (* lumberhack *)
//│ let rec enumFromTo_d0_d0 a_0 b_0 =
//│   (if (a_0 <= b_0) then
//│     (a_0::((enumFromTo_d0_d0 (a_0 + 1)) b_0))
//│   else
//│     [])
//│ and map_d0_d0 f_0 ls_0 =
//│   (ls_0 f_0)
//│ and map_d1_d0 f_1 ls_1 =
//│   (match ls_1 with
//│     | (h_0 :: t_0) -> 
//│       (let rec h_1 = (f_1 h_0) in
//│         (let rec t_1 = ((map_d1_d0 f_1) t_0) in
//│           (fun f_2 -> 
//│             ((f_2 h_1)::((map_d0_d0 f_2) t_1)))))
//│     | [] -> 
//│       (fun f_3 -> 
//│         []))
//│ and testMapmap_d0_d0 _lh_testMapmap_arg1_0 =
//│   ((map_d0_d0 (fun x_0 -> 
//│     (x_0 + 1))) ((map_d1_d0 (fun x_1 -> 
//│     (x_1 + x_1))) _lh_testMapmap_arg1_0));;
//│ 
//│ (* lumberhack_pop_out *)
//│ let rec enumFromTo_d0_d0_d0 a_1 b_1 =
//│   (if (a_1 <= b_1) then
//│     (a_1::((enumFromTo_d0_d0_d0 (a_1 + 1)) b_1))
//│   else
//│     [])
//│ and map_d0_d0_d0 f_4 ls_2 =
//│   (ls_2 f_4)
//│ and map_d0_d0_d1 f_5 ls_3 =
//│   (ls_3 f_5)
//│ and map_d1_d0_d0 f_6 ls_4 _lh_popOutId_0_0 =
//│   (match ls_4 with
//│     | (h_2 :: t_2) -> 
//│       (let rec h_3 = (f_6 h_2) in
//│         (let rec t_3 = ((map_d1_d0_d0 f_6) t_2) in
//│           ((_lh_popOutId_0_0 h_3)::((map_d0_d0_d1 _lh_popOutId_0_0) t_3))))
//│     | [] -> 
//│       [])
//│ and testMapmap_d0_d0_d0 _lh_testMapmap_arg1_1 =
//│   ((map_d0_d0_d0 (fun x_2 -> 
//│     (x_2 + 1))) ((map_d1_d0_d0 (fun x_3 -> 
//│     (x_3 + x_3))) _lh_testMapmap_arg1_1));;
//│ 
//│ Command_unix.run (Bench.make_command [
//│   Bench.Test.create ~name:"original_Mapmap" (fun () -> ignore ((testMapmap_d0 ((enumFromTo_d0 1) 500000))));
//│   Bench.Test.create ~name:"lumberhack_Mapmap" (fun () -> ignore ((testMapmap_d0_d0 ((enumFromTo_d0_d0 1) 500000))));
//│   Bench.Test.create ~name:"lumberhack_pop_out_Mapmap" (fun () -> ignore ((testMapmap_d0_d0_d0 ((enumFromTo_d0_d0_d0 1) 500000))));
//│ ])
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


// NOTE: lumberhack is slightly slower, since this lastDrive and
// last is also somehow accumulating-parametric?
:lhGenOCaml
fun enumFromTo(a, b) = if a < b then C(a, enumFromTo(a + 1, b)) else N
fun filter(ls, f) = if ls is
  C(h, t) then if f(h) then C(h, filter(t, f)) else filter(t, f)
  N then N
fun lastDrive(ls) = if ls is
  C(h, t) then Some(last(h, t))
  N then None
fun last(a, ls) = if ls is
  N then a
  C(h, t) then last(h, t)
fun testLastFilterPolyVar(ls) = lastDrive(filter(ls, x => x < 1000))
fun _lhManualLastFilter(ls, f, a) = if ls is
  C(h, t) then if f(h) then _lhManualLastFilter(t, f, Some(h)) else _lhManualLastFilter(t, f, a)
  N then a
fun testManual(ls) = _lhManualLastFilter(ls, x => x < 1000, None)
testLastFilterPolyVar(primId(enumFromTo(1, 500000)))
testManual(primId(enumFromTo(1, 500000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |filter|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |C|(|h|,| |filter|(|t|,| |f|)|)| |#else| |filter|(|t|,| |f|)|↵|N| |#then| |N|←|↵|#fun| |lastDrive|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |Some|(|last|(|h|,| |t|)|)|↵|N| |#then| |None|←|↵|#fun| |last|(|a|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a|↵|C|(|h|,| |t|)| |#then| |last|(|h|,| |t|)|←|↵|#fun| |testLastFilterPolyVar|(|ls|)| |#=| |lastDrive|(|filter|(|ls|,| |x| |=>| |x| |<| |1000|)|)|↵|#fun| |_lhManualLastFilter|(|ls|,| |f|,| |a|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |_lhManualLastFilter|(|t|,| |f|,| |Some|(|h|)|)| |#else| |_lhManualLastFilter|(|t|,| |f|,| |a|)|↵|N| |#then| |a|←|↵|#fun| |testManual|(|ls|)| |#=| |_lhManualLastFilter|(|ls|,| |x| |=>| |x| |<| |1000|,| |None|)|↵|testLastFilterPolyVar|(|primId|(|enumFromTo|(|1|,| |500000|)|)|)|↵|testManual|(|primId|(|enumFromTo|(|1|,| |500000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (< (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun filter = ls, f, => if ls is ‹(C (h, t,)) then if (f (h,)) then C (h, filter (t, f,),) else filter (t, f,); (N) then N›; fun lastDrive = ls, => if ls is ‹(C (h, t,)) then Some (last (h, t,),); (N) then None›; fun last = a, ls, => if ls is ‹(N) then a; (C (h, t,)) then last (h, t,)›; fun testLastFilterPolyVar = ls, => lastDrive (filter (ls, x, => < (x,) (1000,),),); fun _lhManualLastFilter = ls, f, a, => if ls is ‹(C (h, t,)) then if (f (h,)) then _lhManualLastFilter (t, f, Some (h,),) else _lhManualLastFilter (t, f, a,); (N) then a›; fun testManual = ls, => _lhManualLastFilter (ls, x, => < (x,) (1000,), None,); testLastFilterPolyVar (primId (enumFromTo (1, 500000,),),); testManual (primId (enumFromTo (1, 500000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testLastFilterPolyVar^113(primId⁰(enumFromTo^115(1, 500000)))
//│ testManual^122(primId⁰(enumFromTo^124(1, 500000)))
//│ def _lhManualLastFilter(ls⁴, f¹, a²) = case ls⁴ of {
//│ 	C h³ t³ => if f¹(h³) then _lhManualLastFilter^79(t³, f¹, [Some h³]) else _lhManualLastFilter^87(t³, f¹, a²)
//│ 	| N  => a²}
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ < b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def filter(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter^26(t⁰, f⁰)] else filter^32(t⁰, f⁰)
//│ 	| N  => [N]}
//│ def last(a¹, ls²) = case ls² of {
//│ 	N  => a¹
//│ 	| C h² t² => last^54(h², t²)}
//│ def lastDrive(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => [Some last^43(h¹, t¹)]
//│ 	| N  => [None]}
//│ def testLastFilterPolyVar(ls³) = lastDrive^62(filter^63(ls³, (fun x⁰ -> (x⁰ < 1000))))
//│ def testManual(ls⁵) = _lhManualLastFilter^100(ls⁵, (fun x¹ -> (x¹ < 1000)), [None])
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec _lhManualLastFilter ls_4 f_1 a_2 =
//│ 		  (match ls_4 with
//│ 		    | `C(h_3, t_3) -> 
//│ 		      (if (f_1 h_3) then
//│ 		        (((_lhManualLastFilter t_3) f_1) (`Some(h_3)))
//│ 		      else
//│ 		        (((_lhManualLastFilter t_3) f_1) a_2))
//│ 		    | `N -> 
//│ 		      a_2)
//│ 		and enumFromTo a_0 b_0 =
//│ 		  (if (a_0 < b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N))
//│ 		and filter ls_0 f_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (f_0 h_0) then
//│ 		        (`C(h_0, ((filter t_0) f_0)))
//│ 		      else
//│ 		        ((filter t_0) f_0))
//│ 		    | `N -> 
//│ 		      (`N))
//│ 		and last a_1 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      a_1
//│ 		    | `C(h_2, t_2) -> 
//│ 		      ((last h_2) t_2))
//│ 		and lastDrive ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (`Some(((last h_1) t_1)))
//│ 		    | `N -> 
//│ 		      (`None))
//│ 		and testLastFilterPolyVar ls_3 =
//│ 		  (lastDrive ((filter ls_3) (fun x_0 -> 
//│ 		    (x_0 < 1000))))
//│ 		and testManual ls_5 =
//│ 		  (((_lhManualLastFilter ls_5) (fun x_1 -> 
//│ 		    (x_1 < 1000))) (`None));;
//│ 		(testLastFilterPolyVar ((enumFromTo 1) 500000))
//│ 		(testManual ((enumFromTo 1) 500000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo^115] (hopeless to continue)
//│ 	[enumFromTo^115 · enumFromTo^7] ---> [enumFromTo^115] (using original def)
//│ [enumFromTo^124]
//│ 	[enumFromTo^124 · enumFromTo^7] ---> [enumFromTo^124] (only one)
//│ [testLastFilterPolyVar^113]
//│ 	[testLastFilterPolyVar^113 · filter^63]
//│ 		[testLastFilterPolyVar^113 · filter^63 · filter^26] (hopeless to continue)
//│ 			[testLastFilterPolyVar^113 · filter^63 · filter^26 · filter^26] ---> [testLastFilterPolyVar^113 · filter^63 · filter^26] (using original def)
//│ 			[testLastFilterPolyVar^113 · filter^63 · filter^26 · filter^32] ---> [testLastFilterPolyVar^113 · filter^63 · filter^26] (using original def)
//│ 		[testLastFilterPolyVar^113 · filter^63 · filter^32] ---> [testLastFilterPolyVar^113 · filter^63] (only one)
//│ 	[testLastFilterPolyVar^113 · lastDrive^62] (hopeless to continue)
//│ 		[testLastFilterPolyVar^113 · lastDrive^62 · last^43] (using original def)
//│ 			[testLastFilterPolyVar^113 · lastDrive^62 · last^43 · last^54] ---> [testLastFilterPolyVar^113 · lastDrive^62 · last^43] (using original def)
//│ [testManual^122]
//│ 	[testManual^122 · _lhManualLastFilter^100]
//│ 		[testManual^122 · _lhManualLastFilter^100 · _lhManualLastFilter^79] (hopeless to continue)
//│ 			[testManual^122 · _lhManualLastFilter^100 · _lhManualLastFilter^79 · _lhManualLastFilter^79] ---> [testManual^122 · _lhManualLastFilter^100 · _lhManualLastFilter^79] (using original def)
//│ 			[testManual^122 · _lhManualLastFilter^100 · _lhManualLastFilter^79 · _lhManualLastFilter^87] ---> [testManual^122 · _lhManualLastFilter^100 · _lhManualLastFilter^79] (using original def)
//│ 		[testManual^122 · _lhManualLastFilter^100 · _lhManualLastFilter^87] ---> [testManual^122 · _lhManualLastFilter^100] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testLastFilterPolyVar₀(primId⁰(enumFromTo₀(1, 500000)))
//│ testManual₀(primId⁰(enumFromTo₁(1, 500000)))
//│ def enumFromTo₀(a⁴, b¹) = 
//│ 	if (a⁴ < b¹) then [C a⁴ enumFromTo₀((a⁴ + 1), b¹)] else [N]
//│ def enumFromTo₁(a⁵, b²) = 
//│ 	if (a⁵ < b²) then [C a⁵ enumFromTo₁((a⁵ + 1), b²)] else [N]
//│ def testLastFilterPolyVar₀(ls¹¹) = 
//│ 	lastDrive₀(filter₀(ls¹¹, (fun x³ -> (x³ < 1000))))
//│ 	where
//│ 	def filter₀(ls⁶, f²) = 
//│ 		case ls⁶ of {
//│ 			C h⁴ t⁴ => if f²(h⁴) then [C h⁴ filter₁(t⁴, f²)] else filter₀(t⁴, f²)
//│ 			| N  => [N]}
//│ 		where
//│ 		def filter₁(ls⁹, f³) = 
//│ 			case ls⁹ of {
//│ 				C h⁶ t⁶ => if f³(h⁶) then [C h⁶ filter₁(t⁶, f³)] else filter₁(t⁶, f³)
//│ 				| N  => [N]}
//│ 	def lastDrive₀(ls¹³) = 
//│ 		case ls¹³ of {
//│ 			C h⁹ t⁹ => [Some last₀(h⁹, t⁹)]
//│ 			| N  => [None]}
//│ 		where
//│ 		def last₀(a³, ls⁷) = 
//│ 			case ls⁷ of {
//│ 				N  => a³
//│ 				| C h⁵ t⁵ => last₀(h⁵, t⁵)}
//│ def testManual₀(ls⁸) = 
//│ 	_lhManualLastFilter₀(ls⁸, (fun x² -> (x² < 1000)), [None])
//│ 	where
//│ 	def _lhManualLastFilter₀(ls¹², f⁵, a⁷) = 
//│ 		case ls¹² of {
//│ 			C h⁸ t⁸ => if f⁵(h⁸) then _lhManualLastFilter₁(t⁸, f⁵, [Some h⁸]) else _lhManualLastFilter₀(t⁸, f⁵, a⁷)
//│ 			| N  => a⁷}
//│ 		where
//│ 		def _lhManualLastFilter₁(ls¹⁰, f⁴, a⁶) = 
//│ 			case ls¹⁰ of {
//│ 				C h⁷ t⁷ => if f⁴(h⁷) then _lhManualLastFilter₁(t⁷, f⁴, [Some h⁷]) else _lhManualLastFilter₁(t⁷, f⁴, a⁶)
//│ 				| N  => a⁶}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁴ filter₁(t⁴, f²)]: 141 --->
//│ 	case ls¹³ of {C h⁹ t⁹ => [Some last₀(h⁹, t⁹)] | N  => [None]}: 307
//│ [N]: 148 --->
//│ 	case ls¹³ of {C h⁹ t⁹ => [Some last₀(h⁹, t⁹)] | N  => [None]}: 307
//│ [C h⁶ filter₁(t⁶, f³)]: 185 --->
//│ 	case ls⁷ of {N  => a³ | C h⁵ t⁵ => last₀(h⁵, t⁵)}: 159
//│ [N]: 192 --->
//│ 	case ls⁷ of {N  => a³ | C h⁵ t⁵ => last₀(h⁵, t⁵)}: 159
//│ ------------------
//│ case ls⁷ of {N  => a³ | C h⁵ t⁵ => last₀(h⁵, t⁵)}: 159 --->
//│ 	[C h⁶ filter₁(t⁶, f³)]: 185
//│ 	[N]: 192
//│ case ls¹³ of {C h⁹ t⁹ => [Some last₀(h⁹, t⁹)] | N  => [None]}: 307 --->
//│ 	[C h⁴ filter₁(t⁴, f²)]: 141
//│ 	[N]: 148
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h⁴ filter₁(t⁴, f²)]: 141 --->
//│ 	case ls¹³ of {C h⁹ t⁹ => [Some last₀(h⁹, t⁹)] | N  => [None]}: 307
//│ [N]: 148 --->
//│ 	case ls¹³ of {C h⁹ t⁹ => [Some last₀(h⁹, t⁹)] | N  => [None]}: 307
//│ [C h⁶ filter₁(t⁶, f³)]: 185 --->
//│ 	case ls⁷ of {N  => a³ | C h⁵ t⁵ => last₀(h⁵, t⁵)}: 159
//│ [N]: 192 --->
//│ 	case ls⁷ of {N  => a³ | C h⁵ t⁵ => last₀(h⁵, t⁵)}: 159
//│ ------------------
//│ case ls⁷ of {N  => a³ | C h⁵ t⁵ => last₀(h⁵, t⁵)}: 159 --->
//│ 	[C h⁶ filter₁(t⁶, f³)]: 185
//│ 	[N]: 192
//│ case ls¹³ of {C h⁹ t⁹ => [Some last₀(h⁹, t⁹)] | N  => [None]}: 307 --->
//│ 	[C h⁴ filter₁(t⁴, f²)]: 141
//│ 	[N]: 148
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testLastFilterPolyVar₀(primId⁰(enumFromTo₀(1, 500000)))
//│ testManual₀(primId⁰(enumFromTo₁(1, 500000)))
//│ def enumFromTo₀(a¹¹, b³) = 
//│ 	if (a¹¹ < b³) then [C a¹¹ enumFromTo₀((a¹¹ + 1), b³)] else [N]
//│ def enumFromTo₁(a¹², b⁴) = 
//│ 	if (a¹² < b⁴) then [C a¹² enumFromTo₁((a¹² + 1), b⁴)] else [N]
//│ def testLastFilterPolyVar₀(ls²⁰) = 
//│ 	lastDrive₀(filter₀(ls²⁰, (fun x⁵ -> (x⁵ < 1000))))
//│ 	where
//│ 	def filter₀(ls¹⁷, f⁷) = 
//│ 		case ls¹⁷ of {
//│ 			C h⁴ t⁴ => if f⁷(h⁴) then 
//│ 				let h¹¹ = h⁴
//│ 				in let t¹¹ = filter₁(t⁴, f⁷)
//│ 				in [Some last₀(h¹¹, t¹¹)] else filter₀(t⁴, f⁷)
//│ 			| N  => [None]}
//│ 		where
//│ 		def filter₁(ls¹⁵, f⁶) = 
//│ 			case ls¹⁵ of {
//│ 				C h⁶ t⁶ => if f⁶(h⁶) then 
//│ 					let h¹⁰ = h⁶
//│ 					in let t¹⁰ = filter₁(t⁶, f⁶)
//│ 					in (fun a⁸ -> last₀(h¹⁰, t¹⁰)) else filter₁(t⁶, f⁶)
//│ 				| N  => (fun a⁹ -> a⁹)}
//│ 	def lastDrive₀(ls¹⁴) = 
//│ 		ls¹⁴
//│ 		where
//│ 		def last₀(a¹⁰, ls¹⁶) = 
//│ 			ls¹⁶(a¹⁰)
//│ def testManual₀(ls¹⁸) = 
//│ 	_lhManualLastFilter₀(ls¹⁸, (fun x⁴ -> (x⁴ < 1000)), [None])
//│ 	where
//│ 	def _lhManualLastFilter₀(ls²¹, f⁹, a¹⁴) = 
//│ 		case ls²¹ of {
//│ 			C h⁸ t⁸ => if f⁹(h⁸) then _lhManualLastFilter₁(t⁸, f⁹, [Some h⁸]) else _lhManualLastFilter₀(t⁸, f⁹, a¹⁴)
//│ 			| N  => a¹⁴}
//│ 		where
//│ 		def _lhManualLastFilter₁(ls¹⁹, f⁸, a¹³) = 
//│ 			case ls¹⁹ of {
//│ 				C h⁷ t⁷ => if f⁸(h⁷) then _lhManualLastFilter₁(t⁷, f⁸, [Some h⁷]) else _lhManualLastFilter₁(t⁷, f⁸, a¹³)
//│ 				| N  => a¹³}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ (*
//│ ocamlfind ocamlopt -rectypes -thread -O3 ./LastFilterPolyVar.ml -o "./LastFilterPolyVar.out" -linkpkg -package "core_unix.command_unix" -linkpkg -package "core_bench" && ./LastFilterPolyVar.out && rm ./*.cmx ./*.out ./*.cmi ./*.o
//│ *)
//│ (* #use "topfind";;
//│ #require "core_unix.command_unix";;
//│ #require "core_bench";; *)
//│ open Core_bench;;
//│ 
//│ (* original *)
//│ let rec _lhManualLastFilter ls_4 f_1 a_2 =
//│   (match ls_4 with
//│     | `C(h_3, t_3) -> 
//│       (if (f_1 h_3) then
//│         (((_lhManualLastFilter t_3) f_1) (`Some(h_3)))
//│       else
//│         (((_lhManualLastFilter t_3) f_1) a_2))
//│     | `N -> 
//│       a_2)
//│ and enumFromTo a_0 b_0 =
//│   (if (a_0 < b_0) then
//│     (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│   else
//│     (`N))
//│ and filter ls_0 f_0 =
//│   (match ls_0 with
//│     | `C(h_0, t_0) -> 
//│       (if (f_0 h_0) then
//│         (`C(h_0, ((filter t_0) f_0)))
//│       else
//│         ((filter t_0) f_0))
//│     | `N -> 
//│       (`N))
//│ and last a_1 ls_2 =
//│   (match ls_2 with
//│     | `N -> 
//│       a_1
//│     | `C(h_2, t_2) -> 
//│       ((last h_2) t_2))
//│ and lastDrive ls_1 =
//│   (match ls_1 with
//│     | `C(h_1, t_1) -> 
//│       (`Some(((last h_1) t_1)))
//│     | `N -> 
//│       (`None))
//│ and testLastFilterPolyVar ls_3 =
//│   (lastDrive ((filter ls_3) (fun x_0 -> 
//│     (x_0 < 1000))))
//│ and testManual ls_5 =
//│   (((_lhManualLastFilter ls_5) (fun x_1 -> 
//│     (x_1 < 1000))) (`None));;
//│ 
//│ (* lumberhack *)
//│ let rec enumFromTo_d0 a_3 b_0 =
//│   (if (a_3 < b_0) then
//│     (`C(a_3, ((enumFromTo_d0 (a_3 + 1)) b_0)))
//│   else
//│     (`N))
//│ and enumFromTo_d1 a_4 b_1 =
//│   (if (a_4 < b_1) then
//│     (`C(a_4, ((enumFromTo_d1 (a_4 + 1)) b_1)))
//│   else
//│     (`N))
//│ and filter_d0 ls_3 f_1 =
//│   (match ls_3 with
//│     | `C(h_2, t_2) -> 
//│       (if (f_1 h_2) then
//│         (let rec h_3 = h_2 in
//│           (let rec t_3 = ((filter_d1 t_2) f_1) in
//│             (`Some(((last_d0 h_3) t_3)))))
//│       else
//│         ((filter_d0 t_2) f_1))
//│     | `N -> 
//│       (`None))
//│ and filter_d1 ls_1 f_0 =
//│   (match ls_1 with
//│     | `C(h_0, t_0) -> 
//│       (if (f_0 h_0) then
//│         (let rec h_1 = h_0 in
//│           (let rec t_1 = ((filter_d1 t_0) f_0) in
//│             (fun a_0 -> 
//│               ((last_d0 h_1) t_1))))
//│       else
//│         ((filter_d1 t_0) f_0))
//│     | `N -> 
//│       (fun a_1 -> 
//│         a_1))
//│ and lastDrive_d0 ls_0 =
//│   ls_0
//│ and last_d0 a_2 ls_2 =
//│   (ls_2 a_2)
//│ and testLastFilterPolyVar_d0 ls_6 =
//│   (lastDrive_d0 ((filter_d0 ls_6) (fun x_1 -> 
//│     (x_1 < 1000))));;
//│ 
//│ (* lumberhack_pop_out *)
//│ let rec enumFromTo_d0_d0 a_1_0 b_3 =
//│   (if (a_1_0 < b_3) then
//│     (`C(a_1_0, ((enumFromTo_d0_d0 (a_1_0 + 1)) b_3)))
//│   else
//│     (`N))
//│ and enumFromTo_d1_d0 a_7 b_2 =
//│   (if (a_7 < b_2) then
//│     (`C(a_7, ((enumFromTo_d1_d0 (a_7 + 1)) b_2)))
//│   else
//│     (`N))
//│ and filter_d0_d0 ls_1_3 f_6 =
//│   (match ls_1_3 with
//│     | `C(h_8, t_8) -> 
//│       (if (f_6 h_8) then
//│         (let rec h_9 = h_8 in
//│           (let rec t_9 = ((filter_d1_d0 t_8) f_6) in
//│             (`Some(((last_d0_d1 h_9) t_9)))))
//│       else
//│         ((filter_d0_d0 t_8) f_6))
//│     | `N -> 
//│       (`None))
//│ and filter_d1_d0 ls_1_4 f_7 =
//│   (match ls_1_4 with
//│     | `C(h_1_0, t_1_0) -> 
//│       (if (f_7 h_1_0) then
//│         (let rec h_1_1 = h_1_0 in
//│           (let rec t_1_1 = ((filter_d1_d0 t_1_0) f_7) in
//│             (fun a_1_2 -> 
//│               ((last_d0_d0 h_1_1) t_1_1))))
//│       else
//│         ((filter_d1_d0 t_1_0) f_7))
//│     | `N -> 
//│       (fun a_1_3 -> 
//│         a_1_3))
//│ and lastDrive_d0_d0 ls_1_5 =
//│   ls_1_5
//│ and last_d0_d0 a_8 ls_8 =
//│   (ls_8 a_8)
//│ and last_d0_d1 a_1_4 ls_1_6 =
//│   (ls_1_6 a_1_4)
//│ and testLastFilterPolyVar_d0_d0 ls_1_1 =
//│   (lastDrive_d0_d0 ((filter_d0_d0 ls_1_1) (fun x_3 -> 
//│     (x_3 < 1000))));;
//│ 
//│ Command_unix.run (Bench.make_command [
//│   Bench.Test.create ~name:"original_LastFilterPolyVar" (fun () -> ignore ((testLastFilterPolyVar ((enumFromTo 1) 500000))));
//│   Bench.Test.create ~name:"manual_LastFilterPolyVar" (fun () -> ignore ((testManual ((enumFromTo 1) 500000))));
//│   Bench.Test.create ~name:"lumberhack_LastFilterPolyVar" (fun () -> ignore ((testLastFilterPolyVar_d0 ((enumFromTo_d0 1) 500000))));
//│   Bench.Test.create ~name:"lumberhack_pop_out_LastFilterPolyVar" (fun () -> ignore ((testLastFilterPolyVar_d0_d0 ((enumFromTo_d0_d0 1) 500000))));
//│ ])
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun enumFromTo(a, b) = if a < b then C(a, enumFromTo(a + 1, b)) else N
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun testMapmapPolyVar(ls) = map(map(ls, x => x + 1), x => x * x)
fun _lhManual(ls, f1, f2) = if ls is
  C(h, t) then C(f2(f1(h)), _lhManual(t, f1, f2))
  N then N
fun testManual(ls) = _lhManual(ls, x => x + 1, x => x * x)
testMapmapPolyVar(primId(enumFromTo(1, 100000)))
testManual(primId(enumFromTo(1, 100000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |testMapmapPolyVar|(|ls|)| |#=| |map|(|map|(|ls|,| |x| |=>| |x| |+| |1|)|,| |x| |=>| |x| |*| |x|)|↵|#fun| |_lhManual|(|ls|,| |f1|,| |f2|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f2|(|f1|(|h|)|)|,| |_lhManual|(|t|,| |f1|,| |f2|)|)|↵|N| |#then| |N|←|↵|#fun| |testManual|(|ls|)| |#=| |_lhManual|(|ls|,| |x| |=>| |x| |+| |1|,| |x| |=>| |x| |*| |x|)|↵|testMapmapPolyVar|(|primId|(|enumFromTo|(|1|,| |100000|)|)|)|↵|testManual|(|primId|(|enumFromTo|(|1|,| |100000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (< (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun testMapmapPolyVar = ls, => map (map (ls, x, => + (x,) (1,),), x, => * (x,) (x,),); fun _lhManual = ls, f1, f2, => if ls is ‹(C (h, t,)) then C (f2 (f1 (h,),), _lhManual (t, f1, f2,),); (N) then N›; fun testManual = ls, => _lhManual (ls, x, => + (x,) (1,), x, => * (x,) (x,),); testMapmapPolyVar (primId (enumFromTo (1, 100000,),),); testManual (primId (enumFromTo (1, 100000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapmapPolyVar^92(primId⁰(enumFromTo^94(1, 100000)))
//│ testManual^101(primId⁰(enumFromTo^103(1, 100000)))
//│ def _lhManual(ls², f1⁰, f2⁰) = case ls² of {
//│ 	C h¹ t¹ => [C f2⁰(f1⁰(h¹)) _lhManual^61(t¹, f1⁰, f2⁰)]
//│ 	| N  => [N]}
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ < b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^25(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ def testManual(ls³) = _lhManual^74(ls³, (fun x² -> (x² + 1)), (fun x³ -> (x³ * x³)))
//│ def testMapmapPolyVar(ls¹) = map^35(map^36(ls¹, (fun x⁰ -> (x⁰ + 1))), (fun x¹ -> (x¹ * x¹)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec _lhManual ls_2 f1_0 f2_0 =
//│ 		  (match ls_2 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (`C((f2_0 (f1_0 h_1)), (((_lhManual t_1) f1_0) f2_0)))
//│ 		    | `N -> 
//│ 		      (`N))
//│ 		and enumFromTo a_0 b_0 =
//│ 		  (if (a_0 < b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N))
//│ 		and map ls_0 f_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map t_0) f_0)))
//│ 		    | `N -> 
//│ 		      (`N))
//│ 		and testManual ls_3 =
//│ 		  (((_lhManual ls_3) (fun x_2 -> 
//│ 		    (x_2 + 1))) (fun x_3 -> 
//│ 		    (x_3 * x_3)))
//│ 		and testMapmapPolyVar ls_1 =
//│ 		  ((map ((map ls_1) (fun x_0 -> 
//│ 		    (x_0 + 1)))) (fun x_1 -> 
//│ 		    (x_1 * x_1)));;
//│ 		(testMapmapPolyVar ((enumFromTo 1) 100000))
//│ 		(testManual ((enumFromTo 1) 100000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo^103]
//│ 	[enumFromTo^103 · enumFromTo^7] ---> [enumFromTo^103] (only one)
//│ [enumFromTo^94] (hopeless to continue)
//│ 	[enumFromTo^94 · enumFromTo^7] ---> [enumFromTo^94] (using original def)
//│ [testManual^101]
//│ 	[testManual^101 · _lhManual^74]
//│ 		[testManual^101 · _lhManual^74 · _lhManual^61] ---> [testManual^101 · _lhManual^74] (only one)
//│ [testMapmapPolyVar^92]
//│ 	[testMapmapPolyVar^92 · map^35]
//│ 		[testMapmapPolyVar^92 · map^35 · map^25] ---> [testMapmapPolyVar^92 · map^35] (only one)
//│ 	[testMapmapPolyVar^92 · map^36]
//│ 		[testMapmapPolyVar^92 · map^36 · map^25] ---> [testMapmapPolyVar^92 · map^36] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testMapmapPolyVar₀(primId⁰(enumFromTo₁(1, 100000)))
//│ testManual₀(primId⁰(enumFromTo₀(1, 100000)))
//│ def enumFromTo₀(a¹, b¹) = 
//│ 	if (a¹ < b¹) then [C a¹ enumFromTo₀((a¹ + 1), b¹)] else [N]
//│ def enumFromTo₁(a², b²) = 
//│ 	if (a² < b²) then [C a² enumFromTo₁((a² + 1), b²)] else [N]
//│ def testManual₀(ls⁴) = 
//│ 	_lhManual₀(ls⁴, (fun x⁴ -> (x⁴ + 1)), (fun x⁵ -> (x⁵ * x⁵)))
//│ 	where
//│ 	def _lhManual₀(ls⁶, f1¹, f2¹) = 
//│ 		case ls⁶ of {
//│ 			C h³ t³ => [C f2¹(f1¹(h³)) _lhManual₀(t³, f1¹, f2¹)]
//│ 			| N  => [N]}
//│ def testMapmapPolyVar₀(ls⁷) = 
//│ 	map₀(map₁(ls⁷, (fun x⁶ -> (x⁶ + 1))), (fun x⁷ -> (x⁷ * x⁷)))
//│ 	where
//│ 	def map₀(ls⁵, f¹) = 
//│ 		case ls⁵ of {
//│ 			C h² t² => [C f¹(h²) map₀(t², f¹)]
//│ 			| N  => [N]}
//│ 	def map₁(ls⁸, f²) = 
//│ 		case ls⁸ of {
//│ 			C h⁴ t⁴ => [C f²(h⁴) map₁(t⁴, f²)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f²(h⁴) map₁(t⁴, f²)]: 210 --->
//│ 	case ls⁵ of {C h² t² => [C f¹(h²) map₀(t², f¹)] | N  => [N]}: 139
//│ [N]: 211 --->
//│ 	case ls⁵ of {C h² t² => [C f¹(h²) map₀(t², f¹)] | N  => [N]}: 139
//│ ------------------
//│ case ls⁵ of {C h² t² => [C f¹(h²) map₀(t², f¹)] | N  => [N]}: 139 --->
//│ 	[C f²(h⁴) map₁(t⁴, f²)]: 210
//│ 	[N]: 211
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f²(h⁴) map₁(t⁴, f²)]: 210 --->
//│ 	case ls⁵ of {C h² t² => [C f¹(h²) map₀(t², f¹)] | N  => [N]}: 139
//│ [N]: 211 --->
//│ 	case ls⁵ of {C h² t² => [C f¹(h²) map₀(t², f¹)] | N  => [N]}: 139
//│ ------------------
//│ case ls⁵ of {C h² t² => [C f¹(h²) map₀(t², f¹)] | N  => [N]}: 139 --->
//│ 	[C f²(h⁴) map₁(t⁴, f²)]: 210
//│ 	[N]: 211
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapmapPolyVar₀(primId⁰(enumFromTo₁(1, 100000)))
//│ testManual₀(primId⁰(enumFromTo₀(1, 100000)))
//│ def enumFromTo₀(a⁴, b⁴) = 
//│ 	if (a⁴ < b⁴) then [C a⁴ enumFromTo₀((a⁴ + 1), b⁴)] else [N]
//│ def enumFromTo₁(a³, b³) = 
//│ 	if (a³ < b³) then [C a³ enumFromTo₁((a³ + 1), b³)] else [N]
//│ def testManual₀(ls¹³) = 
//│ 	_lhManual₀(ls¹³, (fun x¹⁰ -> (x¹⁰ + 1)), (fun x¹¹ -> (x¹¹ * x¹¹)))
//│ 	where
//│ 	def _lhManual₀(ls⁹, f1², f2²) = 
//│ 		case ls⁹ of {
//│ 			C h³ t³ => [C f2²(f1²(h³)) _lhManual₀(t³, f1², f2²)]
//│ 			| N  => [N]}
//│ def testMapmapPolyVar₀(ls¹⁰) = 
//│ 	map₀(map₁(ls¹⁰, (fun x⁸ -> (x⁸ + 1))), (fun x⁹ -> (x⁹ * x⁹)))
//│ 	where
//│ 	def map₀(ls¹¹, f³) = 
//│ 		ls¹¹(f³)
//│ 	def map₁(ls¹², f⁴) = 
//│ 		case ls¹² of {
//│ 			C h⁴ t⁴ => 
//│ 				let h⁵ = f⁴(h⁴)
//│ 				in let t⁵ = map₁(t⁴, f⁴)
//│ 				in (fun f⁵ -> [C f⁵(h⁵) map₀(t⁵, f⁵)])
//│ 			| N  => (fun f⁶ -> [N])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ (*
//│ ocamlfind ocamlopt -rectypes -thread -O3 ./MapmapPolyVar.ml -o "./MapmapPolyVar.out" -linkpkg -package "core_unix.command_unix" -linkpkg -package "core_bench" && ./MapmapPolyVar.out && rm ./*.cmx ./*.out ./*.cmi ./*.o
//│ *)
//│ (* #use "topfind";;
//│ #require "core_unix.command_unix";;
//│ #require "core_bench";; *)
//│ open Core_bench;;
//│ 
//│ (* original *)
//│ let rec _lhManual ls_2 f1_0 f2_0 =
//│   (match ls_2 with
//│     | `C(h_1, t_1) -> 
//│       (`C((f2_0 (f1_0 h_1)), (((_lhManual t_1) f1_0) f2_0)))
//│     | `N -> 
//│       (`N))
//│ and enumFromTo a_0 b_0 =
//│   (if (a_0 < b_0) then
//│     (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│   else
//│     (`N))
//│ and map ls_0 f_0 =
//│   (match ls_0 with
//│     | `C(h_0, t_0) -> 
//│       (`C((f_0 h_0), ((map t_0) f_0)))
//│     | `N -> 
//│       (`N))
//│ and testManual ls_3 =
//│   (((_lhManual ls_3) (fun x_2 -> 
//│     (x_2 + 1))) (fun x_3 -> 
//│     (x_3 * x_3)))
//│ and testMapmapPolyVar ls_1 =
//│   ((map ((map ls_1) (fun x_0 -> 
//│     (x_0 + 1)))) (fun x_1 -> 
//│     (x_1 * x_1)));;
//│ 
//│ (* lumberhack *)
//│ let rec enumFromTo_d0 a_1 b_1 =
//│   (if (a_1 < b_1) then
//│     (`C(a_1, ((enumFromTo_d0 (a_1 + 1)) b_1)))
//│   else
//│     (`N))
//│ and enumFromTo_d1 a_0 b_0 =
//│   (if (a_0 < b_0) then
//│     (`C(a_0, ((enumFromTo_d1 (a_0 + 1)) b_0)))
//│   else
//│     (`N))
//│ and map_d0 ls_2 f_0 =
//│   (ls_2 f_0)
//│ and map_d1 ls_3 f_1 =
//│   (match ls_3 with
//│     | `C(h_1, t_1) -> 
//│       (let rec h_2 = (f_1 h_1) in
//│         (let rec t_2 = ((map_d1 t_1) f_1) in
//│           (fun f_2 -> 
//│             (`C((f_2 h_2), ((map_d0 t_2) f_2))))))
//│     | `N -> 
//│       (fun f_3 -> 
//│         (`N)))
//│ and testMapmapPolyVar_d0 ls_1 =
//│   ((map_d0 ((map_d1 ls_1) (fun x_0 -> 
//│     (x_0 + 1)))) (fun x_1 -> 
//│     (x_1 * x_1)));;
//│ 
//│ (* lumberhack_pop_out *)
//│ let rec enumFromTo_d0_d0 a_3 b_3 =
//│   (if (a_3 < b_3) then
//│     (`C(a_3, ((enumFromTo_d0_d0 (a_3 + 1)) b_3)))
//│   else
//│     (`N))
//│ and enumFromTo_d1_d0 a_2 b_2 =
//│   (if (a_2 < b_2) then
//│     (`C(a_2, ((enumFromTo_d1_d0 (a_2 + 1)) b_2)))
//│   else
//│     (`N))
//│ and map_d0_d0 ls_9 f_8 =
//│   (ls_9 f_8)
//│ and map_d0_d1 ls_6 f_4 =
//│   (ls_6 f_4)
//│ and map_d1_d0 ls_7 f_5 _lh_popOutId_0_0 =
//│   (match ls_7 with
//│     | `C(h_4, t_4) -> 
//│       (let rec h_5 = (f_5 h_4) in
//│         (let rec t_5 = ((map_d1_d0 t_4) f_5) in
//│           (`C((_lh_popOutId_0_0 h_5), ((map_d0_d1 t_5) _lh_popOutId_0_0)))))
//│     | `N -> 
//│       (`N))
//│ and testMapmapPolyVar_d0_d0 ls_1_0 =
//│   ((map_d0_d0 ((map_d1_d0 ls_1_0) (fun x_6 -> 
//│     (x_6 + 1)))) (fun x_7 -> 
//│     (x_7 * x_7)));;
//│ 
//│ Command_unix.run (Bench.make_command [
//│   Bench.Test.create ~name:"original_MapmapPolyVar" (fun () -> ignore ((testMapmapPolyVar ((enumFromTo 1) 100000))));
//│   Bench.Test.create ~name:"manual_MapmapPolyVar" (fun () -> ignore ((testManual ((enumFromTo 1) 100000))));
//│   Bench.Test.create ~name:"lumberhack_MapmapPolyVar" (fun () -> ignore ((testMapmapPolyVar_d0 ((enumFromTo_d1 1) 100000))));
//│   Bench.Test.create ~name:"lumberhack_pop_out_MapmapPolyVar" (fun () -> ignore ((testMapmapPolyVar_d0_d0 ((enumFromTo_d1_d0 1) 100000))));
//│ ])
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


// NOTE: digression: simply use `let r = f(h) in C(r, map(t, f))` will be faster
:lhGenOCaml
fun enumFromTo(a, b) = if a < b then C(a, enumFromTo(a + 1, b)) else N
fun map(ls, f) = if ls is
  C(h, t) then let r = f(h) in C(r, map(t, f))
  N then N
fun testMapmapPolyVarLet(ls) = map(map(ls, x => x + 1), x => x * x)
testMapmapPolyVarLet(primId(enumFromTo(1, 100000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#let| |r| |#=| |f|(|h|)| |#in| |C|(|r|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |testMapmapPolyVarLet|(|ls|)| |#=| |map|(|map|(|ls|,| |x| |=>| |x| |+| |1|)|,| |x| |=>| |x| |*| |x|)|↵|testMapmapPolyVarLet|(|primId|(|enumFromTo|(|1|,| |100000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (< (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun map = ls, f, => if ls is ‹(C (h, t,)) then let r = f (h,) in C (r, map (t, f,),); (N) then N›; fun testMapmapPolyVarLet = ls, => map (map (ls, x, => + (x,) (1,),), x, => * (x,) (x,),); testMapmapPolyVarLet (primId (enumFromTo (1, 100000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapmapPolyVarLet^57(primId⁰(enumFromTo^59(1, 100000)))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ < b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let r⁰ = f⁰(h⁰)
//│ 		in [C r⁰ map^26(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ def testMapmapPolyVarLet(ls¹) = map^37(map^38(ls¹, (fun x⁰ -> (x⁰ + 1))), (fun x¹ -> (x¹ * x¹)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 < b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N))
//│ 		and map ls_0 f_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (let rec r_0 = (f_0 h_0) in
//│ 		        (`C(r_0, ((map t_0) f_0))))
//│ 		    | `N -> 
//│ 		      (`N))
//│ 		and testMapmapPolyVarLet ls_1 =
//│ 		  ((map ((map ls_1) (fun x_0 -> 
//│ 		    (x_0 + 1)))) (fun x_1 -> 
//│ 		    (x_1 * x_1)));;
//│ 		(testMapmapPolyVarLet ((enumFromTo 1) 100000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo^59]
//│ 	[enumFromTo^59 · enumFromTo^7] ---> [enumFromTo^59] (only one)
//│ [testMapmapPolyVarLet^57]
//│ 	[testMapmapPolyVarLet^57 · map^37]
//│ 		[testMapmapPolyVarLet^57 · map^37 · map^26] ---> [testMapmapPolyVarLet^57 · map^37] (only one)
//│ 	[testMapmapPolyVarLet^57 · map^38]
//│ 		[testMapmapPolyVarLet^57 · map^38 · map^26] ---> [testMapmapPolyVarLet^57 · map^38] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testMapmapPolyVarLet₀(primId⁰(enumFromTo₀(1, 100000)))
//│ def enumFromTo₀(a¹, b¹) = 
//│ 	if (a¹ < b¹) then [C a¹ enumFromTo₀((a¹ + 1), b¹)] else [N]
//│ def testMapmapPolyVarLet₀(ls³) = 
//│ 	map₀(map₁(ls³, (fun x² -> (x² + 1))), (fun x³ -> (x³ * x³)))
//│ 	where
//│ 	def map₀(ls², f¹) = 
//│ 		case ls² of {
//│ 			C h¹ t¹ => 
//│ 				let r¹ = f¹(h¹)
//│ 				in [C r¹ map₀(t¹, f¹)]
//│ 			| N  => [N]}
//│ 	def map₁(ls⁴, f²) = 
//│ 		case ls⁴ of {
//│ 			C h² t² => 
//│ 				let r² = f²(h²)
//│ 				in [C r² map₁(t², f²)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C r² map₁(t², f²)]: 132 --->
//│ 	case ls² of {C h¹ t¹ => let r¹ = f¹(h¹)
//│ in [C r¹ map₀(t¹, f¹)] | N  => [N]}: 79
//│ [N]: 134 --->
//│ 	case ls² of {C h¹ t¹ => let r¹ = f¹(h¹)
//│ in [C r¹ map₀(t¹, f¹)] | N  => [N]}: 79
//│ ------------------
//│ case ls² of {C h¹ t¹ => let r¹ = f¹(h¹)
//│ in [C r¹ map₀(t¹, f¹)] | N  => [N]}: 79 --->
//│ 	[C r² map₁(t², f²)]: 132
//│ 	[N]: 134
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C r² map₁(t², f²)]: 132 --->
//│ 	case ls² of {C h¹ t¹ => let r¹ = f¹(h¹)
//│ in [C r¹ map₀(t¹, f¹)] | N  => [N]}: 79
//│ [N]: 134 --->
//│ 	case ls² of {C h¹ t¹ => let r¹ = f¹(h¹)
//│ in [C r¹ map₀(t¹, f¹)] | N  => [N]}: 79
//│ ------------------
//│ case ls² of {C h¹ t¹ => let r¹ = f¹(h¹)
//│ in [C r¹ map₀(t¹, f¹)] | N  => [N]}: 79 --->
//│ 	[C r² map₁(t², f²)]: 132
//│ 	[N]: 134
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapmapPolyVarLet₀(primId⁰(enumFromTo₀(1, 100000)))
//│ def enumFromTo₀(a², b²) = 
//│ 	if (a² < b²) then [C a² enumFromTo₀((a² + 1), b²)] else [N]
//│ def testMapmapPolyVarLet₀(ls⁶) = 
//│ 	map₀(map₁(ls⁶, (fun x⁴ -> (x⁴ + 1))), (fun x⁵ -> (x⁵ * x⁵)))
//│ 	where
//│ 	def map₀(ls⁵, f³) = 
//│ 		ls⁵(f³)
//│ 	def map₁(ls⁷, f⁴) = 
//│ 		case ls⁷ of {
//│ 			C h² t² => 
//│ 				let r³ = f⁴(h²)
//│ 				in let h³ = r³
//│ 				in let t³ = map₁(t², f⁴)
//│ 				in (fun f⁵ -> 
//│ 					let r⁴ = f⁵(h³)
//│ 					in [C r⁴ map₀(t³, f⁵)])
//│ 			| N  => (fun f⁶ -> [N])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ (*
//│ ocamlfind ocamlopt -rectypes -thread -O3 ./MapmapPolyVarLet.ml -o "./MapmapPolyVarLet.out" -linkpkg -package "core_unix.command_unix" -linkpkg -package "core_bench" && ./MapmapPolyVarLet.out && rm ./*.cmx ./*.out ./*.cmi ./*.o
//│ *)
//│ (* #use "topfind";;
//│ #require "core_unix.command_unix";;
//│ #require "core_bench";; *)
//│ open Core_bench;;
//│ 
//│ (* original *)
//│ let rec enumFromTo a_0 b_0 =
//│   (if (a_0 < b_0) then
//│     (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│   else
//│     (`N))
//│ and map ls_0 f_0 =
//│   (match ls_0 with
//│     | `C(h_0, t_0) -> 
//│       (let rec r_0 = (f_0 h_0) in
//│         (`C(r_0, ((map t_0) f_0))))
//│     | `N -> 
//│       (`N))
//│ and testMapmapPolyVarLet ls_1 =
//│   ((map ((map ls_1) (fun x_0 -> 
//│     (x_0 + 1)))) (fun x_1 -> 
//│     (x_1 * x_1)));;
//│ 
//│ (* lumberhack *)
//│ let rec enumFromTo_d0 a_0 b_0 =
//│   (if (a_0 < b_0) then
//│     (`C(a_0, ((enumFromTo_d0 (a_0 + 1)) b_0)))
//│   else
//│     (`N))
//│ and map_d0 ls_0 f_0 =
//│   (ls_0 f_0)
//│ and map_d1 ls_2 f_1 =
//│   (match ls_2 with
//│     | `C(h_0, t_0) -> 
//│       (let rec r_0 = (f_1 h_0) in
//│         (let rec h_1 = r_0 in
//│           (let rec t_1 = ((map_d1 t_0) f_1) in
//│             (fun f_2 -> 
//│               (let rec r_1 = (f_2 h_1) in
//│                 (`C(r_1, ((map_d0 t_1) f_2))))))))
//│     | `N -> 
//│       (fun f_3 -> 
//│         (`N)))
//│ and testMapmapPolyVarLet_d0 ls_1 =
//│   ((map_d0 ((map_d1 ls_1) (fun x_0 -> 
//│     (x_0 + 1)))) (fun x_1 -> 
//│     (x_1 * x_1)));;
//│ 
//│ (* lumberhack_pop_out *)
//│ let rec enumFromTo_d0_d0 a_1 b_1 =
//│   (if (a_1 < b_1) then
//│     (`C(a_1, ((enumFromTo_d0_d0 (a_1 + 1)) b_1)))
//│   else
//│     (`N))
//│ and map_d0_d0 ls_3 f_4 =
//│   (ls_3 f_4)
//│ and map_d0_d1 ls_4 f_5 =
//│   (ls_4 f_5)
//│ and map_d1_d0 ls_5 f_6 _lh_popOutId_0_0 =
//│   (match ls_5 with
//│     | `C(h_2, t_2) -> 
//│       (let rec r_2 = (f_6 h_2) in
//│         (let rec h_3 = r_2 in
//│           (let rec t_3 = ((map_d1_d0 t_2) f_6) in
//│             (let rec r_3 = (_lh_popOutId_0_0 h_3) in
//│               (`C(r_3, ((map_d0_d1 t_3) _lh_popOutId_0_0)))))))
//│     | `N -> 
//│       (`N))
//│ and testMapmapPolyVarLet_d0_d0 ls_6 =
//│   ((map_d0_d0 ((map_d1_d0 ls_6) (fun x_2 -> 
//│     (x_2 + 1)))) (fun x_3 -> 
//│     (x_3 * x_3)));;
//│ 
//│ Command_unix.run (Bench.make_command [
//│   Bench.Test.create ~name:"original_MapmapPolyVarLet" (fun () -> ignore ((testMapmapPolyVarLet ((enumFromTo 1) 100000))));
//│   Bench.Test.create ~name:"lumberhack_MapmapPolyVarLet" (fun () -> ignore ((testMapmapPolyVarLet_d0 ((enumFromTo_d0 1) 100000))));
//│   Bench.Test.create ~name:"lumberhack_pop_out_MapmapPolyVarLet" (fun () -> ignore ((testMapmapPolyVarLet_d0_d0 ((enumFromTo_d0_d0 1) 100000))));
//│ ])
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
:lhInHaskell
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = [ (q:b) | b <- gen (n-1) nq, q <- [1..nq], safe q 1 b ]
nsoln nq = length (gen nq nq)
testQueen n = nsoln n
testQueen $ primId 11
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testQueen₀^423(primId⁰(11))
//│ def enumFromTo₀(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo₀^409((a² + 1), b²)] else [LH_N]
//│ def gen₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 			LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 				let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 					LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀^343(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 					| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 				in _lh_listcomp_fun³(enumFromTo₀^367(1, _lh_gen_arg2¹))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun²(gen₀^378((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length₀(ls⁷) = case ls⁷ of {
//│ 	LH_C h⁷ t⁸ => (1 + length₀^396(t⁸))
//│ 	| LH_N  => 0}
//│ def nsoln₀(_lh_nsoln_arg1¹) = length₀^325(gen₀^326(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀^309(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}
//│ def testQueen₀(_lh_testQueen_arg1¹) = nsoln₀^333(_lh_testQueen_arg1¹)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_d0 a_2 b_2 =
//│ 		  (if (a_2 <= b_2) then
//│ 		    (a_2::((enumFromTo_d0 (a_2 + 1)) b_2))
//│ 		  else
//│ 		    [])
//│ 		and gen_d0 _lh_gen_arg1_1 _lh_gen_arg2_1 =
//│ 		  (match _lh_gen_arg1_1 with
//│ 		    | 0 -> 
//│ 		      ([]::[])
//│ 		    | _ -> 
//│ 		      (let rec _lh_listcomp_fun_2 = (fun _lh_listcomp_fun_para_2 -> 
//│ 		        (match _lh_listcomp_fun_para_2 with
//│ 		          | (_lh_listcomp_fun_ls_h_2 :: _lh_listcomp_fun_ls_t_2) -> 
//│ 		            (let rec _lh_listcomp_fun_3 = (fun _lh_listcomp_fun_para_3 -> 
//│ 		              (match _lh_listcomp_fun_para_3 with
//│ 		                | (_lh_listcomp_fun_ls_h_3 :: _lh_listcomp_fun_ls_t_3) -> 
//│ 		                  (if (((safe_d0 _lh_listcomp_fun_ls_h_3) 1) _lh_listcomp_fun_ls_h_2) then
//│ 		                    ((_lh_listcomp_fun_ls_h_3::_lh_listcomp_fun_ls_h_2)::(_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3))
//│ 		                  else
//│ 		                    (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3))
//│ 		                | [] -> 
//│ 		                  (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_2))) in
//│ 		              (_lh_listcomp_fun_3 ((enumFromTo_d0 1) _lh_gen_arg2_1)))
//│ 		          | [] -> 
//│ 		            [])) in
//│ 		        (_lh_listcomp_fun_2 ((gen_d0 (_lh_gen_arg1_1 - 1)) _lh_gen_arg2_1))))
//│ 		and length_d0 ls_7 =
//│ 		  (match ls_7 with
//│ 		    | (h_7 :: t_8) -> 
//│ 		      (1 + (length_d0 t_8))
//│ 		    | [] -> 
//│ 		      0)
//│ 		and nsoln_d0 _lh_nsoln_arg1_1 =
//│ 		  (length_d0 ((gen_d0 _lh_nsoln_arg1_1) _lh_nsoln_arg1_1))
//│ 		and safe_d0 _lh_safe_arg1_1 _lh_safe_arg2_1 _lh_safe_arg3_1 =
//│ 		  (match _lh_safe_arg3_1 with
//│ 		    | [] -> 
//│ 		      true
//│ 		    | (_lh_safe_LH_C_0_1 :: _lh_safe_LH_C_1_1) -> 
//│ 		      ((((_lh_safe_arg1_1 != _lh_safe_LH_C_0_1) && (_lh_safe_arg1_1 != (_lh_safe_LH_C_0_1 + _lh_safe_arg2_1))) && (_lh_safe_arg1_1 != (_lh_safe_LH_C_0_1 - _lh_safe_arg2_1))) && (((safe_d0 _lh_safe_arg1_1) (_lh_safe_arg2_1 + 1)) _lh_safe_LH_C_1_1)))
//│ 		and testQueen_d0 _lh_testQueen_arg1_1 =
//│ 		  (nsoln_d0 _lh_testQueen_arg1_1);;
//│ 		(testQueen_d0 11)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testQueen₀^423] (hopeless to continue)
//│ 	[testQueen₀^423 · nsoln₀^333] (using original def)
//│ 		[testQueen₀^423 · nsoln₀^333 · gen₀^326] (using original def)
//│ 			[testQueen₀^423 · nsoln₀^333 · gen₀^326 · enumFromTo₀^367] (using original def)
//│ 				[testQueen₀^423 · nsoln₀^333 · gen₀^326 · enumFromTo₀^367 · enumFromTo₀^409] ---> [testQueen₀^423 · nsoln₀^333 · gen₀^326 · enumFromTo₀^367] (using original def)
//│ 			[testQueen₀^423 · nsoln₀^333 · gen₀^326 · gen₀^378] ---> [testQueen₀^423 · nsoln₀^333 · gen₀^326] (using original def)
//│ 			[testQueen₀^423 · nsoln₀^333 · gen₀^326 · safe₀^343] (using original def)
//│ 				[testQueen₀^423 · nsoln₀^333 · gen₀^326 · safe₀^343 · safe₀^309] ---> [testQueen₀^423 · nsoln₀^333 · gen₀^326 · safe₀^343] (using original def)
//│ 		[testQueen₀^423 · nsoln₀^333 · length₀^325] (using original def)
//│ 			[testQueen₀^423 · nsoln₀^333 · length₀^325 · length₀^396] ---> [testQueen₀^423 · nsoln₀^333 · length₀^325] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testQueen₀₀(primId⁰(11))
//│ def testQueen₀₀(_lh_testQueen_arg1¹) = 
//│ 	nsoln₀₀(_lh_testQueen_arg1¹)
//│ 	where
//│ 	def nsoln₀₀(_lh_nsoln_arg1¹) = 
//│ 		length₀₀(gen₀₀(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ 		where
//│ 		def gen₀₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = 
//│ 			case _lh_gen_arg1¹ of {
//│ 				0  => [LH_C [LH_N] [LH_N]]
//│ 				| _  => 
//│ 					let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 						LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 							let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 								LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 								| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 							in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹))
//│ 						| LH_N  => [LH_N]})
//│ 					in _lh_listcomp_fun²(gen₀₀((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ 			where
//│ 			def enumFromTo₀₀(a¹, b¹) = 
//│ 				if (a¹ <= b¹) then [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)] else [LH_N]
//│ 			def safe₀₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = 
//│ 				case _lh_safe_arg3¹ of {
//│ 					LH_N  => [True]
//│ 					| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}
//│ 		def length₀₀(ls¹) = 
//│ 			case ls¹ of {
//│ 				LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 				| LH_N  => 0}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 225 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 272
//│ [LH_N]: 226 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 272
//│ [LH_N]: 246 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}: 206
//│ [LH_N]: 247 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 239
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 283
//│ [LH_C [LH_N] [LH_N]]: 248 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 239
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 283
//│ [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 260 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}: 206
//│ [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 264 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 239
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 283
//│ [LH_N]: 282 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 239
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 283
//│ ------------------
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}: 206 --->
//│ 	[LH_N]: 246
//│ 	[LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 260
//│ case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 239 --->
//│ 	[LH_N]: 247
//│ 	[LH_C [LH_N] [LH_N]]: 248
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 264
//│ 	[LH_N]: 282
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 272 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 225
//│ 	[LH_N]: 226
//│ case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 283 --->
//│ 	[LH_N]: 247
//│ 	[LH_C [LH_N] [LH_N]]: 248
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 264
//│ 	[LH_N]: 282
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 225 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 272
//│ [LH_N]: 226 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 272
//│ [LH_N]: 246 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}: 206
//│ [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 260 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}: 206
//│ ------------------
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))}: 206 --->
//│ 	[LH_N]: 246
//│ 	[LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 260
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 272 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 225
//│ 	[LH_N]: 226
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testQueen₀₀(primId⁰(11))
//│ def testQueen₀₀(_lh_testQueen_arg1²) = 
//│ 	nsoln₀₀(_lh_testQueen_arg1²)
//│ 	where
//│ 	def nsoln₀₀(_lh_nsoln_arg1²) = 
//│ 		length₀₀(gen₀₀(_lh_nsoln_arg1², _lh_nsoln_arg1²))
//│ 		where
//│ 		def gen₀₀(_lh_gen_arg1², _lh_gen_arg2²) = 
//│ 			case _lh_gen_arg1² of {
//│ 				0  => [LH_C (fun _lh_safe_arg1⁴ -> (fun _lh_safe_arg2⁴ -> [True])) [LH_N]]
//│ 				| _  => 
//│ 					let _lh_listcomp_fun⁸ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {
//│ 						LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 							let _lh_listcomp_fun⁹ = (fun _lh_listcomp_fun_para⁵ -> _lh_listcomp_fun_para⁵(_lh_listcomp_fun_ls_h², _lh_listcomp_fun⁹, _lh_listcomp_fun⁸, _lh_listcomp_fun_ls_t²))
//│ 							in _lh_listcomp_fun⁹(enumFromTo₀₀(1, _lh_gen_arg2²))
//│ 						| LH_N  => [LH_N]})
//│ 					in _lh_listcomp_fun⁸(gen₀₀((_lh_gen_arg1² - 1), _lh_gen_arg2²))}
//│ 			where
//│ 			def enumFromTo₀₀(a², b²) = 
//│ 				if (a² <= b²) then 
//│ 					let _lh_listcomp_fun_ls_h⁴ = a²
//│ 					in let _lh_listcomp_fun_ls_t⁴ = enumFromTo₀₀((a² + 1), b²)
//│ 					in (fun _lh_listcomp_fun_ls_h⁵ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_listcomp_fun⁵ -> (fun _lh_listcomp_fun_ls_t⁵ -> if safe₀₀(_lh_listcomp_fun_ls_h⁴, 1, _lh_listcomp_fun_ls_h⁵) then [LH_C 
//│ 						let _lh_safe_LH_C_0² = _lh_listcomp_fun_ls_h⁴
//│ 						in let _lh_safe_LH_C_1² = _lh_listcomp_fun_ls_h⁵
//│ 						in (fun _lh_safe_arg1² -> (fun _lh_safe_arg2² -> ((((_lh_safe_arg1² /= _lh_safe_LH_C_0²) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0² + _lh_safe_arg2²))) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0² - _lh_safe_arg2²))) && safe₀₀(_lh_safe_arg1², (_lh_safe_arg2² + 1), _lh_safe_LH_C_1²)))) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴))))) else (fun _lh_listcomp_fun_ls_h⁶ -> (fun _lh_listcomp_fun⁶ -> (fun _lh_listcomp_fun⁷ -> (fun _lh_listcomp_fun_ls_t⁶ -> _lh_listcomp_fun⁷(_lh_listcomp_fun_ls_t⁶)))))
//│ 			def safe₀₀(_lh_safe_arg1³, _lh_safe_arg2³, _lh_safe_arg3²) = 
//│ 				_lh_safe_arg3²(_lh_safe_arg1³, _lh_safe_arg2³)
//│ 		def length₀₀(ls²) = 
//│ 			case ls² of {
//│ 				LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 				| LH_N  => 0}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ (*
//│ ocamlfind ocamlopt -rectypes -thread -O3 ./Queen.ml -o "./Queen.out" -linkpkg -package "core_unix.command_unix" -linkpkg -package "core_bench" && ./Queen.out && rm ./*.cmx ./*.out ./*.cmi ./*.o
//│ *)
//│ (* #use "topfind";;
//│ #require "core_unix.command_unix";;
//│ #require "core_bench";; *)
//│ open Core_bench;;
//│ 
//│ (* original *)
//│ let rec enumFromTo_d0 a_2 b_2 =
//│   (if (a_2 <= b_2) then
//│     (a_2::((enumFromTo_d0 (a_2 + 1)) b_2))
//│   else
//│     [])
//│ and gen_d0 _lh_gen_arg1_1 _lh_gen_arg2_1 =
//│   (match _lh_gen_arg1_1 with
//│     | 0 -> 
//│       ([]::[])
//│     | _ -> 
//│       (let rec _lh_listcomp_fun_2 = (fun _lh_listcomp_fun_para_2 -> 
//│         (match _lh_listcomp_fun_para_2 with
//│           | (_lh_listcomp_fun_ls_h_2 :: _lh_listcomp_fun_ls_t_2) -> 
//│             (let rec _lh_listcomp_fun_3 = (fun _lh_listcomp_fun_para_3 -> 
//│               (match _lh_listcomp_fun_para_3 with
//│                 | (_lh_listcomp_fun_ls_h_3 :: _lh_listcomp_fun_ls_t_3) -> 
//│                   (if (((safe_d0 _lh_listcomp_fun_ls_h_3) 1) _lh_listcomp_fun_ls_h_2) then
//│                     ((_lh_listcomp_fun_ls_h_3::_lh_listcomp_fun_ls_h_2)::(_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3))
//│                   else
//│                     (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3))
//│                 | [] -> 
//│                   (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_2))) in
//│               (_lh_listcomp_fun_3 ((enumFromTo_d0 1) _lh_gen_arg2_1)))
//│           | [] -> 
//│             [])) in
//│         (_lh_listcomp_fun_2 ((gen_d0 (_lh_gen_arg1_1 - 1)) _lh_gen_arg2_1))))
//│ and length_d0 ls_7 =
//│   (match ls_7 with
//│     | (h_7 :: t_8) -> 
//│       (1 + (length_d0 t_8))
//│     | [] -> 
//│       0)
//│ and nsoln_d0 _lh_nsoln_arg1_1 =
//│   (length_d0 ((gen_d0 _lh_nsoln_arg1_1) _lh_nsoln_arg1_1))
//│ and safe_d0 _lh_safe_arg1_1 _lh_safe_arg2_1 _lh_safe_arg3_1 =
//│   (match _lh_safe_arg3_1 with
//│     | [] -> 
//│       true
//│     | (_lh_safe_LH_C_0_1 :: _lh_safe_LH_C_1_1) -> 
//│       ((((_lh_safe_arg1_1 != _lh_safe_LH_C_0_1) && (_lh_safe_arg1_1 != (_lh_safe_LH_C_0_1 + _lh_safe_arg2_1))) && (_lh_safe_arg1_1 != (_lh_safe_LH_C_0_1 - _lh_safe_arg2_1))) && (((safe_d0 _lh_safe_arg1_1) (_lh_safe_arg2_1 + 1)) _lh_safe_LH_C_1_1)))
//│ and testQueen_d0 _lh_testQueen_arg1_1 =
//│   (nsoln_d0 _lh_testQueen_arg1_1);;
//│ 
//│ (* lumberhack *)
//│ let rec enumFromTo_d0_d0 a_0 b_0 =
//│   (if (a_0 <= b_0) then
//│     (let rec _lh_listcomp_fun_ls_h_0 = a_0 in
//│       (let rec _lh_listcomp_fun_ls_t_0 = ((enumFromTo_d0_d0 (a_0 + 1)) b_0) in
//│         (fun _lh_listcomp_fun_ls_h_1 _lh_listcomp_fun_0 _lh_listcomp_fun_1 _lh_listcomp_fun_ls_t_1 -> 
//│           (if (((safe_d0_d0 _lh_listcomp_fun_ls_h_0) 1) _lh_listcomp_fun_ls_h_1) then
//│             ((let rec _lh_safe_LH_C_0_0 = _lh_listcomp_fun_ls_h_0 in
//│               (let rec _lh_safe_LH_C_1_0 = _lh_listcomp_fun_ls_h_1 in
//│                 (fun _lh_safe_arg1_0 _lh_safe_arg2_0 -> 
//│                   ((((_lh_safe_arg1_0 != _lh_safe_LH_C_0_0) && (_lh_safe_arg1_0 != (_lh_safe_LH_C_0_0 + _lh_safe_arg2_0))) && (_lh_safe_arg1_0 != (_lh_safe_LH_C_0_0 - _lh_safe_arg2_0))) && (((safe_d0_d0 _lh_safe_arg1_0) (_lh_safe_arg2_0 + 1)) _lh_safe_LH_C_1_0)))))::(_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0))
//│           else
//│             (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0)))))
//│   else
//│     (fun _lh_listcomp_fun_ls_h_2 _lh_listcomp_fun_2 _lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_2 -> 
//│       (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_2)))
//│ and gen_d0_d0 _lh_gen_arg1_0 _lh_gen_arg2_0 =
//│   (match _lh_gen_arg1_0 with
//│     | 0 -> 
//│       ((fun _lh_safe_arg1_2 _lh_safe_arg2_2 -> 
//│         true)::[])
//│     | _ -> 
//│       (let rec _lh_listcomp_fun_4 = (fun _lh_listcomp_fun_para_0 -> 
//│         (match _lh_listcomp_fun_para_0 with
//│           | (_lh_listcomp_fun_ls_h_3 :: _lh_listcomp_fun_ls_t_3) -> 
//│             (let rec _lh_listcomp_fun_5 = (fun _lh_listcomp_fun_para_1 -> 
//│               ((((_lh_listcomp_fun_para_1 _lh_listcomp_fun_ls_h_3) _lh_listcomp_fun_5) _lh_listcomp_fun_4) _lh_listcomp_fun_ls_t_3)) in
//│               (_lh_listcomp_fun_5 ((enumFromTo_d0_d0 1) _lh_gen_arg2_0)))
//│           | [] -> 
//│             [])) in
//│         (_lh_listcomp_fun_4 ((gen_d0_d0 (_lh_gen_arg1_0 - 1)) _lh_gen_arg2_0))))
//│ and length_d0_d0 ls_0 =
//│   (match ls_0 with
//│     | (h_0 :: t_0) -> 
//│       (1 + (length_d0_d0 t_0))
//│     | [] -> 
//│       0)
//│ and nsoln_d0_d0 _lh_nsoln_arg1_0 =
//│   (length_d0_d0 ((gen_d0_d0 _lh_nsoln_arg1_0) _lh_nsoln_arg1_0))
//│ and safe_d0_d0 _lh_safe_arg1_1 _lh_safe_arg2_1 _lh_safe_arg3_0 =
//│   ((_lh_safe_arg3_0 _lh_safe_arg1_1) _lh_safe_arg2_1)
//│ and testQueen_d0_d0 _lh_testQueen_arg1_0 =
//│   (nsoln_d0_d0 _lh_testQueen_arg1_0);;
//│ 
//│ (* lumberhack_pop_out *)
//│ let rec enumFromTo_d0_d0_d0 a_1 b_1 _lh_popOutId_0_0 _lh_popOutId_1_0 _lh_popOutId_2_0 _lh_popOutId_3_0 =
//│   (if (a_1 <= b_1) then
//│     (let rec _lh_listcomp_fun_ls_h_4 = a_1 in
//│       (let rec _lh_listcomp_fun_ls_t_4 = ((enumFromTo_d0_d0_d0 (a_1 + 1)) b_1) in
//│         (if (((safe_d0_d0_d0 _lh_listcomp_fun_ls_h_4) 1) _lh_popOutId_0_0) then
//│           ((let rec _lh_safe_LH_C_0_1 = _lh_listcomp_fun_ls_h_4 in
//│             (let rec _lh_safe_LH_C_1_1 = _lh_popOutId_0_0 in
//│               (fun _lh_safe_arg1_4 _lh_safe_arg2_4 -> 
//│                 ((((_lh_safe_arg1_4 != _lh_safe_LH_C_0_1) && (_lh_safe_arg1_4 != (_lh_safe_LH_C_0_1 + _lh_safe_arg2_4))) && (_lh_safe_arg1_4 != (_lh_safe_LH_C_0_1 - _lh_safe_arg2_4))) && (((safe_d0_d0_d1 _lh_safe_arg1_4) (_lh_safe_arg2_4 + 1)) _lh_safe_LH_C_1_1)))))::(_lh_popOutId_1_0 _lh_listcomp_fun_ls_t_4))
//│         else
//│           (_lh_popOutId_1_0 _lh_listcomp_fun_ls_t_4))))
//│   else
//│     (_lh_popOutId_2_0 _lh_popOutId_3_0))
//│ and gen_d0_d0_d0 _lh_gen_arg1_1 _lh_gen_arg2_1 =
//│   (match _lh_gen_arg1_1 with
//│     | 0 -> 
//│       ((fun _lh_safe_arg1_6 _lh_safe_arg2_6 -> 
//│         true)::[])
//│     | _ -> 
//│       (let rec _lh_listcomp_fun_1_0 = (fun _lh_listcomp_fun_para_2 -> 
//│         (match _lh_listcomp_fun_para_2 with
//│           | (_lh_listcomp_fun_ls_h_7 :: _lh_listcomp_fun_ls_t_7) -> 
//│             (let rec _lh_listcomp_fun_1_1 = (fun _lh_listcomp_fun_para_3 -> 
//│               ((((_lh_listcomp_fun_para_3 _lh_listcomp_fun_ls_h_7) _lh_listcomp_fun_1_1) _lh_listcomp_fun_1_0) _lh_listcomp_fun_ls_t_7)) in
//│               (_lh_listcomp_fun_1_1 ((enumFromTo_d0_d0_d0 1) _lh_gen_arg2_1)))
//│           | [] -> 
//│             [])) in
//│         (_lh_listcomp_fun_1_0 ((gen_d0_d0_d0 (_lh_gen_arg1_1 - 1)) _lh_gen_arg2_1))))
//│ and length_d0_d0_d0 ls_1 =
//│   (match ls_1 with
//│     | (h_1 :: t_1) -> 
//│       (1 + (length_d0_d0_d0 t_1))
//│     | [] -> 
//│       0)
//│ and nsoln_d0_d0_d0 _lh_nsoln_arg1_1 =
//│   (length_d0_d0_d0 ((gen_d0_d0_d0 _lh_nsoln_arg1_1) _lh_nsoln_arg1_1))
//│ and safe_d0_d0_d0 _lh_safe_arg1_5 _lh_safe_arg2_5 _lh_safe_arg3_2 =
//│   ((_lh_safe_arg3_2 _lh_safe_arg1_5) _lh_safe_arg2_5)
//│ and safe_d0_d0_d1 _lh_safe_arg1_3 _lh_safe_arg2_3 _lh_safe_arg3_1 =
//│   ((_lh_safe_arg3_1 _lh_safe_arg1_3) _lh_safe_arg2_3)
//│ and testQueen_d0_d0_d0 _lh_testQueen_arg1_1 =
//│   (nsoln_d0_d0_d0 _lh_testQueen_arg1_1);;
//│ 
//│ Command_unix.run (Bench.make_command [
//│   Bench.Test.create ~name:"original_Queen" (fun () -> ignore ((testQueen_d0 11)));
//│   Bench.Test.create ~name:"lumberhack_Queen" (fun () -> ignore ((testQueen_d0_d0 11)));
//│   Bench.Test.create ~name:"lumberhack_pop_out_Queen" (fun () -> ignore ((testQueen_d0_d0_d0 11)));
//│ ])
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
