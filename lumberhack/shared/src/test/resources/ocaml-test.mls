:NewParser
:ParseOnly

:lhError
:lhInOCaml
let rec a = 4;;
let rec f = function A -> B | C -> D;;
let rec d a b = match a with
  | `A(s, d) -> `D
  | _ -> `S
  | k -> `D;;
let rec f (h:t) = h;;
let val = [false;true;false];;
f val
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ "compilation_unit" (
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"=" ()
//│ 			"number" ()))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"=" ()
//│ 			"function_expression" (
//│ 				"function" ()
//│ 				"match_case" (
//│ 					"constructor_path" (
//│ 						"constructor_name" ())
//│ 					"->" ()
//│ 					"constructor_path" (
//│ 						"constructor_name" ()))
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"constructor_path" (
//│ 						"constructor_name" ())
//│ 					"->" ()
//│ 					"constructor_path" (
//│ 						"constructor_name" ())))))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"parameter" (
//│ 				"value_pattern" ())
//│ 			"parameter" (
//│ 				"value_pattern" ())
//│ 			"=" ()
//│ 			"match_expression" (
//│ 				"match" ()
//│ 				"value_path" (
//│ 					"value_name" ())
//│ 				"with" ()
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"tag_pattern" (
//│ 						"tag" (
//│ 							"`" ())
//│ 						"parenthesized_pattern" (
//│ 							"(" ()
//│ 							"tuple_pattern" (
//│ 								"value_pattern" ()
//│ 								"," ()
//│ 								"value_pattern" ())
//│ 							")" ()))
//│ 					"->" ()
//│ 					"tag" (
//│ 						"`" ()))
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"value_pattern" ()
//│ 					"->" ()
//│ 					"tag" (
//│ 						"`" ()))
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"value_pattern" ()
//│ 					"->" ()
//│ 					"tag" (
//│ 						"`" ())))))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"parameter" (
//│ 				"typed_pattern" (
//│ 					"(" ()
//│ 					"value_pattern" ()
//│ 					":" ()
//│ 					"type_constructor_path" (
//│ 						"type_constructor" ())
//│ 					")" ()))
//│ 			"=" ()
//│ 			"value_path" (
//│ 				"value_name" ())))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"=" ()
//│ 			"list_expression" (
//│ 				"[" ()
//│ 				"boolean" (
//│ 					"false" ())
//│ 				";" ()
//│ 				"boolean" (
//│ 					"true" ())
//│ 				";" ()
//│ 				"boolean" (
//│ 					"false" ())
//│ 				"]" ())))
//│ 	";;" ()
//│ 	"expression_item" (
//│ 		"application_expression" (
//│ 			"value_path" (
//│ 				"value_name" ())
//│ 			"value_path" (
//│ 				"value_name" ()))))
//│ !!!!!!ERROR!!!!!!
//│ scala.NotImplementedError: an implementation is missing
//│ !!!!!!ERROR!!!!!!



:lhInHaskell
:lhGenOCaml
[x | x <- [1,2]]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 	LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]
//│ 	| LH_N  => [LH_N]})
//│ in _lh_listcomp_fun¹([LH_C 1 [LH_C 2 [LH_N]]])
//│ 		---------- unoptimized ocaml gen ----------
//│ 		(let rec _lh_listcomp_fun_1 = (fun _lh_listcomp_fun_para_1 -> 
//│ 		  (match _lh_listcomp_fun_para_1 with
//│ 		    | (_lh_listcomp_fun_ls_h_1 :: _lh_listcomp_fun_ls_t_1) -> 
//│ 		      (_lh_listcomp_fun_ls_h_1::(_lh_listcomp_fun_1 _lh_listcomp_fun_ls_t_1))
//│ 		    | [] -> 
//│ 		      [])) in
//│ 		  (_lh_listcomp_fun_1 (1::(2::[]))))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ 
//│ 	let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 		LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun¹([LH_C 1 [LH_C 2 [LH_N]]])
//│ 
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 30 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ [LH_C 2 [LH_N]]: 31 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ [LH_C 1 [LH_C 2 [LH_N]]]: 32 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ ------------------
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25 --->
//│ 	[LH_N]: 30
//│ 	[LH_C 2 [LH_N]]: 31
//│ 	[LH_C 1 [LH_C 2 [LH_N]]]: 32
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_N]: 30 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ [LH_C 2 [LH_N]]: 31 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ [LH_C 1 [LH_C 2 [LH_N]]]: 32 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ ------------------
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25 --->
//│ 	[LH_N]: 30
//│ 	[LH_C 2 [LH_N]]: 31
//│ 	[LH_C 1 [LH_C 2 [LH_N]]]: 32
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> _lh_listcomp_fun_para²(_lh_listcomp_fun²))
//│ 	in _lh_listcomp_fun²(
//│ 		let _lh_listcomp_fun_ls_h² = 1
//│ 		in let _lh_listcomp_fun_ls_t² = 	
//│ 			let _lh_listcomp_fun_ls_h³ = 2
//│ 			in let _lh_listcomp_fun_ls_t³ = (fun _lh_listcomp_fun⁵ -> [LH_N])
//│ 			in (fun _lh_listcomp_fun⁴ -> [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t³)])
//│ 		in (fun _lh_listcomp_fun³ -> [LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun³(_lh_listcomp_fun_ls_t²)]))
//│ 
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ (let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│   (_lh_listcomp_fun_para_0 _lh_listcomp_fun_0)) in
//│   (_lh_listcomp_fun_0 (let rec _lh_listcomp_fun_ls_h_0 = 1 in
//│     (let rec _lh_listcomp_fun_ls_t_0 = (let rec _lh_listcomp_fun_ls_h_1 = 2 in
//│       (let rec _lh_listcomp_fun_ls_t_1 = (fun _lh_listcomp_fun_1 -> 
//│         []) in
//│         (fun _lh_listcomp_fun_2 -> 
//│           (_lh_listcomp_fun_ls_h_1::(_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_1))))) in
//│       (fun _lh_listcomp_fun_3 -> 
//│         (_lh_listcomp_fun_ls_h_0::(_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_0)))))))
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhInHaskell
:lhGenOCaml
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = [ (q:b) | b <- gen (n-1) nq, q <- [1..nq], safe q 1 b ]
nsoln nq = length (gen nq nq)
nsoln 10
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ nsoln₀^419(10)
//│ def enumFromTo₀(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo₀^279((a² + 1), b²)] else [LH_N]
//│ def gen₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 			LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 				let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 					LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀^359(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 					| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 				in _lh_listcomp_fun³(enumFromTo₀^383(1, _lh_gen_arg2¹))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun²(gen₀^394((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length₀(ls⁷) = case ls⁷ of {
//│ 	LH_C h⁷ t⁸ => (1 + length₀^412(t⁸))
//│ 	| LH_N  => 0}
//│ def nsoln₀(_lh_nsoln_arg1¹) = length₀^293(gen₀^294(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀^334(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))
//│ 	| _  => error⁰("match error")}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_d0 a_2 b_2 =
//│ 		  (if (a_2 <= b_2) then
//│ 		    (a_2::((enumFromTo_d0 (a_2 + 1)) b_2))
//│ 		  else
//│ 		    []);;
//│ 		let rec length_d0 ls_7 =
//│ 		  (match ls_7 with
//│ 		    | (h_7 :: t_8) -> 
//│ 		      (1 + (length_d0 t_8))
//│ 		    | [] -> 
//│ 		      0);;
//│ 		let rec safe_d0 _lh_safe_arg1_1 _lh_safe_arg2_1 _lh_safe_arg3_1 =
//│ 		  (match _lh_safe_arg3_1 with
//│ 		    | [] -> 
//│ 		      true
//│ 		    | (_lh_safe_LH_C_0_1 :: _lh_safe_LH_C_1_1) -> 
//│ 		      ((((_lh_safe_arg1_1 != _lh_safe_LH_C_0_1) && (_lh_safe_arg1_1 != (_lh_safe_LH_C_0_1 + _lh_safe_arg2_1))) && (_lh_safe_arg1_1 != (_lh_safe_LH_C_0_1 - _lh_safe_arg2_1))) && (((safe_d0 _lh_safe_arg1_1) (_lh_safe_arg2_1 + 1)) _lh_safe_LH_C_1_1))
//│ 		    | _ -> 
//│ 		      (failwith "match error"));;
//│ 		let rec gen_d0 _lh_gen_arg1_1 _lh_gen_arg2_1 =
//│ 		  (match _lh_gen_arg1_1 with
//│ 		    | 0 -> 
//│ 		      ([]::[])
//│ 		    | _ -> 
//│ 		      (let rec _lh_listcomp_fun_2 = (fun _lh_listcomp_fun_para_2 -> 
//│ 		        (match _lh_listcomp_fun_para_2 with
//│ 		          | (_lh_listcomp_fun_ls_h_2 :: _lh_listcomp_fun_ls_t_2) -> 
//│ 		            (let rec _lh_listcomp_fun_3 = (fun _lh_listcomp_fun_para_3 -> 
//│ 		              (match _lh_listcomp_fun_para_3 with
//│ 		                | (_lh_listcomp_fun_ls_h_3 :: _lh_listcomp_fun_ls_t_3) -> 
//│ 		                  (if (((safe_d0 _lh_listcomp_fun_ls_h_3) 1) _lh_listcomp_fun_ls_h_2) then
//│ 		                    ((_lh_listcomp_fun_ls_h_3::_lh_listcomp_fun_ls_h_2)::(_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3))
//│ 		                  else
//│ 		                    (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3))
//│ 		                | [] -> 
//│ 		                  (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_2))) in
//│ 		              (_lh_listcomp_fun_3 ((enumFromTo_d0 1) _lh_gen_arg2_1)))
//│ 		          | [] -> 
//│ 		            [])) in
//│ 		        (_lh_listcomp_fun_2 ((gen_d0 (_lh_gen_arg1_1 - 1)) _lh_gen_arg2_1))))
//│ 		and nsoln_d0 _lh_nsoln_arg1_1 =
//│ 		  (length_d0 ((gen_d0 _lh_nsoln_arg1_1) _lh_nsoln_arg1_1));;
//│ 		(nsoln_d0 10)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [nsoln₀^419] (hopeless to continue)
//│ 	[nsoln₀^419 · gen₀^294] (using original def)
//│ 		[nsoln₀^419 · gen₀^294 · enumFromTo₀^383] (using original def)
//│ 			[nsoln₀^419 · gen₀^294 · enumFromTo₀^383 · enumFromTo₀^279] ---> [nsoln₀^419 · gen₀^294 · enumFromTo₀^383] (using original def)
//│ 		[nsoln₀^419 · gen₀^294 · gen₀^394] ---> [nsoln₀^419 · gen₀^294] (using original def)
//│ 		[nsoln₀^419 · gen₀^294 · safe₀^359] (using original def)
//│ 			[nsoln₀^419 · gen₀^294 · safe₀^359 · safe₀^334] ---> [nsoln₀^419 · gen₀^294 · safe₀^359] (using original def)
//│ 	[nsoln₀^419 · length₀^293] (using original def)
//│ 		[nsoln₀^419 · length₀^293 · length₀^412] ---> [nsoln₀^419 · length₀^293] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ nsoln₀₀(10)
//│ def nsoln₀₀(_lh_nsoln_arg1¹) = 
//│ 	length₀₀(gen₀₀(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ 	where
//│ 	def gen₀₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = 
//│ 		case _lh_gen_arg1¹ of {
//│ 			0  => [LH_C [LH_N] [LH_N]]
//│ 			| _  => 
//│ 				let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 					LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 						let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 							LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 							| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 						in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹))
//│ 					| LH_N  => [LH_N]})
//│ 				in _lh_listcomp_fun²(gen₀₀((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ 		where
//│ 		def enumFromTo₀₀(a¹, b¹) = 
//│ 			if (a¹ <= b¹) then [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)] else [LH_N]
//│ 		def safe₀₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = 
//│ 			case _lh_safe_arg3¹ of {
//│ 				LH_N  => [True]
//│ 				| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))
//│ 				| _  => error⁰("match error")}
//│ 	def length₀₀(ls¹) = 
//│ 		case ls¹ of {
//│ 			LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 			| LH_N  => 0}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 203 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 198
//│ [LH_N]: 204 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 240
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 286
//│ [LH_C [LH_N] [LH_N]]: 205 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 240
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 286
//│ [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 217 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 198
//│ [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 221 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 240
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 286
//│ [LH_N]: 239 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 240
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 286
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 272 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 229
//│ [LH_N]: 273 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 229
//│ ------------------
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 198 --->
//│ 	[LH_N]: 203
//│ 	[LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 217
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 229 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 272
//│ 	[LH_N]: 273
//│ case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 240 --->
//│ 	[LH_N]: 204
//│ 	[LH_C [LH_N] [LH_N]]: 205
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 221
//│ 	[LH_N]: 239
//│ case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 286 --->
//│ 	[LH_N]: 204
//│ 	[LH_C [LH_N] [LH_N]]: 205
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 221
//│ 	[LH_N]: 239
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_N]: 203 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 198
//│ [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 217 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 198
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 272 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 229
//│ [LH_N]: 273 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 229
//│ ------------------
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 198 --->
//│ 	[LH_N]: 203
//│ 	[LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 217
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 229 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 272
//│ 	[LH_N]: 273
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ nsoln₀₀(10)
//│ def nsoln₀₀(_lh_nsoln_arg1²) = 
//│ 	length₀₀(gen₀₀(_lh_nsoln_arg1², _lh_nsoln_arg1²))
//│ 	where
//│ 	def gen₀₀(_lh_gen_arg1², _lh_gen_arg2²) = 
//│ 		case _lh_gen_arg1² of {
//│ 			0  => [LH_C (fun _lh_safe_arg1⁴ -> (fun _lh_safe_arg2⁴ -> [True])) [LH_N]]
//│ 			| _  => 
//│ 				let _lh_listcomp_fun⁸ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {
//│ 					LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 						let _lh_listcomp_fun⁹ = (fun _lh_listcomp_fun_para⁵ -> _lh_listcomp_fun_para⁵(_lh_listcomp_fun_ls_h², _lh_listcomp_fun⁹, _lh_listcomp_fun⁸, _lh_listcomp_fun_ls_t²))
//│ 						in _lh_listcomp_fun⁹(enumFromTo₀₀(1, _lh_gen_arg2²))
//│ 					| LH_N  => [LH_N]})
//│ 				in _lh_listcomp_fun⁸(gen₀₀((_lh_gen_arg1² - 1), _lh_gen_arg2²))}
//│ 		where
//│ 		def enumFromTo₀₀(a², b²) = 
//│ 			if (a² <= b²) then 
//│ 				let _lh_listcomp_fun_ls_h⁴ = a²
//│ 				in let _lh_listcomp_fun_ls_t⁴ = enumFromTo₀₀((a² + 1), b²)
//│ 				in (fun _lh_listcomp_fun_ls_h⁵ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_listcomp_fun⁵ -> (fun _lh_listcomp_fun_ls_t⁵ -> if safe₀₀(_lh_listcomp_fun_ls_h⁴, 1, _lh_listcomp_fun_ls_h⁵) then [LH_C 
//│ 					let _lh_safe_LH_C_0² = _lh_listcomp_fun_ls_h⁴
//│ 					in let _lh_safe_LH_C_1² = _lh_listcomp_fun_ls_h⁵
//│ 					in (fun _lh_safe_arg1² -> (fun _lh_safe_arg2² -> ((((_lh_safe_arg1² /= _lh_safe_LH_C_0²) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0² + _lh_safe_arg2²))) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0² - _lh_safe_arg2²))) && safe₀₀(_lh_safe_arg1², (_lh_safe_arg2² + 1), _lh_safe_LH_C_1²)))) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴))))) else (fun _lh_listcomp_fun_ls_h⁶ -> (fun _lh_listcomp_fun⁶ -> (fun _lh_listcomp_fun⁷ -> (fun _lh_listcomp_fun_ls_t⁶ -> _lh_listcomp_fun⁷(_lh_listcomp_fun_ls_t⁶)))))
//│ 		def safe₀₀(_lh_safe_arg1³, _lh_safe_arg2³, _lh_safe_arg3²) = 
//│ 			_lh_safe_arg3²(_lh_safe_arg1³, _lh_safe_arg2³)
//│ 	def length₀₀(ls²) = 
//│ 		case ls² of {
//│ 			LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 			| LH_N  => 0}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec length_d0_d0 ls_0 =
//│   (match ls_0 with
//│     | (h_0 :: t_0) -> 
//│       (1 + (length_d0_d0 t_0))
//│     | [] -> 
//│       0);;
//│ let rec safe_d0_d0 _lh_safe_arg1_1 _lh_safe_arg2_1 _lh_safe_arg3_0 =
//│   ((_lh_safe_arg3_0 _lh_safe_arg1_1) _lh_safe_arg2_1);;
//│ let rec enumFromTo_d0_d0 a_0 b_0 =
//│   (if (a_0 <= b_0) then
//│     (let rec _lh_listcomp_fun_ls_h_0 = a_0 in
//│       (let rec _lh_listcomp_fun_ls_t_0 = ((enumFromTo_d0_d0 (a_0 + 1)) b_0) in
//│         (fun _lh_listcomp_fun_ls_h_1 _lh_listcomp_fun_0 _lh_listcomp_fun_1 _lh_listcomp_fun_ls_t_1 -> 
//│           (if (((safe_d0_d0 _lh_listcomp_fun_ls_h_0) 1) _lh_listcomp_fun_ls_h_1) then
//│             ((let rec _lh_safe_LH_C_0_0 = _lh_listcomp_fun_ls_h_0 in
//│               (let rec _lh_safe_LH_C_1_0 = _lh_listcomp_fun_ls_h_1 in
//│                 (fun _lh_safe_arg1_0 _lh_safe_arg2_0 -> 
//│                   ((((_lh_safe_arg1_0 != _lh_safe_LH_C_0_0) && (_lh_safe_arg1_0 != (_lh_safe_LH_C_0_0 + _lh_safe_arg2_0))) && (_lh_safe_arg1_0 != (_lh_safe_LH_C_0_0 - _lh_safe_arg2_0))) && (((safe_d0_d0 _lh_safe_arg1_0) (_lh_safe_arg2_0 + 1)) _lh_safe_LH_C_1_0)))))::(_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0))
//│           else
//│             (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0)))))
//│   else
//│     (fun _lh_listcomp_fun_ls_h_2 _lh_listcomp_fun_2 _lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_2 -> 
//│       (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_2)))
//│ and gen_d0_d0 _lh_gen_arg1_0 _lh_gen_arg2_0 =
//│   (match _lh_gen_arg1_0 with
//│     | 0 -> 
//│       ((fun _lh_safe_arg1_2 _lh_safe_arg2_2 -> 
//│         true)::[])
//│     | _ -> 
//│       (let rec _lh_listcomp_fun_4 = (fun _lh_listcomp_fun_para_0 -> 
//│         (match _lh_listcomp_fun_para_0 with
//│           | (_lh_listcomp_fun_ls_h_3 :: _lh_listcomp_fun_ls_t_3) -> 
//│             (let rec _lh_listcomp_fun_5 = (fun _lh_listcomp_fun_para_1 -> 
//│               ((((_lh_listcomp_fun_para_1 _lh_listcomp_fun_ls_h_3) _lh_listcomp_fun_5) _lh_listcomp_fun_4) _lh_listcomp_fun_ls_t_3)) in
//│               (_lh_listcomp_fun_5 ((enumFromTo_d0_d0 1) _lh_gen_arg2_0)))
//│           | [] -> 
//│             [])) in
//│         (_lh_listcomp_fun_4 ((gen_d0_d0 (_lh_gen_arg1_0 - 1)) _lh_gen_arg2_0))))
//│ and nsoln_d0_d0 _lh_nsoln_arg1_0 =
//│   (length_d0_d0 ((gen_d0_d0 _lh_nsoln_arg1_0) _lh_nsoln_arg1_0));;
//│ (nsoln_d0_d0 10)
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<



:lhInHaskell
:lhGenOCaml
testMapmapBuiltInType ls = map (\x -> x + 1) $ map (\x -> x * x) ls
testMapmapBuiltInType $ primId [1..100000]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapmapBuiltInType₀^252(primId⁰(enumFromTo₀^254(1, 100000)))
//│ def enumFromTo₀(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo₀^204((a² + 1), b²)] else [LH_N]
//│ def map₀(f⁴, ls⁷) = case ls⁷ of {
//│ 	LH_C h⁷ t⁸ => [LH_C f⁴(h⁷) map₀^188(f⁴, t⁸)]
//│ 	| LH_N  => [LH_N]}
//│ def map₁(f⁵, ls⁸) = case ls⁸ of {
//│ 	LH_C h⁸ t⁹ => [LH_C f⁵(h⁸) map₁^242(f⁵, t⁹)]
//│ 	| LH_N  => [LH_N]}
//│ def testMapmapBuiltInType₀(_lh_testMapmapBuiltInType_arg1¹) = map₀^218((fun x² -> (x² + 1)), map₁^226((fun x³ -> (x³ * x³)), _lh_testMapmapBuiltInType_arg1¹))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_d0 a_2 b_2 =
//│ 		  (if (a_2 <= b_2) then
//│ 		    (a_2::((enumFromTo_d0 (a_2 + 1)) b_2))
//│ 		  else
//│ 		    []);;
//│ 		let rec map_d0 f_4 ls_7 =
//│ 		  (match ls_7 with
//│ 		    | (h_7 :: t_8) -> 
//│ 		      ((f_4 h_7)::((map_d0 f_4) t_8))
//│ 		    | [] -> 
//│ 		      []);;
//│ 		let rec map_d1 f_5 ls_8 =
//│ 		  (match ls_8 with
//│ 		    | (h_8 :: t_9) -> 
//│ 		      ((f_5 h_8)::((map_d1 f_5) t_9))
//│ 		    | [] -> 
//│ 		      []);;
//│ 		let rec testMapmapBuiltInType_d0 _lh_testMapmapBuiltInType_arg1_1 =
//│ 		  ((map_d0 (fun x_2 -> 
//│ 		    (x_2 + 1))) ((map_d1 (fun x_3 -> 
//│ 		    (x_3 * x_3))) _lh_testMapmapBuiltInType_arg1_1));;
//│ 		(testMapmapBuiltInType_d0 ((enumFromTo_d0 1) 100000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo₀^254]
//│ 	[enumFromTo₀^254 · enumFromTo₀^204] ---> [enumFromTo₀^254] (only one)
//│ [testMapmapBuiltInType₀^252]
//│ 	[testMapmapBuiltInType₀^252 · map₀^218]
//│ 		[testMapmapBuiltInType₀^252 · map₀^218 · map₀^188] ---> [testMapmapBuiltInType₀^252 · map₀^218] (only one)
//│ 	[testMapmapBuiltInType₀^252 · map₁^226]
//│ 		[testMapmapBuiltInType₀^252 · map₁^226 · map₁^242] ---> [testMapmapBuiltInType₀^252 · map₁^226] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testMapmapBuiltInType₀₀(primId⁰(enumFromTo₀₀(1, 100000)))
//│ def enumFromTo₀₀(a¹, b¹) = 
//│ 	if (a¹ <= b¹) then [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)] else [LH_N]
//│ def testMapmapBuiltInType₀₀(_lh_testMapmapBuiltInType_arg1¹) = 
//│ 	map₀₀((fun x² -> (x² + 1)), map₁₀((fun x³ -> (x³ * x³)), _lh_testMapmapBuiltInType_arg1¹))
//│ 	where
//│ 	def map₀₀(f², ls²) = 
//│ 		case ls² of {
//│ 			LH_C h² t² => [LH_C f²(h²) map₀₀(f², t²)]
//│ 			| LH_N  => [LH_N]}
//│ 	def map₁₀(f³, ls³) = 
//│ 		case ls³ of {
//│ 			LH_C h³ t³ => [LH_C f³(h³) map₁₀(f³, t³)]
//│ 			| LH_N  => [LH_N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f³(h³) map₁₀(f³, t³)]: 101 --->
//│ 	case ls² of {LH_C h² t² => [LH_C f²(h²) map₀₀(f², t²)] | LH_N  => [LH_N]}: 89
//│ [LH_N]: 102 --->
//│ 	case ls² of {LH_C h² t² => [LH_C f²(h²) map₀₀(f², t²)] | LH_N  => [LH_N]}: 89
//│ ------------------
//│ case ls² of {LH_C h² t² => [LH_C f²(h²) map₀₀(f², t²)] | LH_N  => [LH_N]}: 89 --->
//│ 	[LH_C f³(h³) map₁₀(f³, t³)]: 101
//│ 	[LH_N]: 102
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f³(h³) map₁₀(f³, t³)]: 101 --->
//│ 	case ls² of {LH_C h² t² => [LH_C f²(h²) map₀₀(f², t²)] | LH_N  => [LH_N]}: 89
//│ [LH_N]: 102 --->
//│ 	case ls² of {LH_C h² t² => [LH_C f²(h²) map₀₀(f², t²)] | LH_N  => [LH_N]}: 89
//│ ------------------
//│ case ls² of {LH_C h² t² => [LH_C f²(h²) map₀₀(f², t²)] | LH_N  => [LH_N]}: 89 --->
//│ 	[LH_C f³(h³) map₁₀(f³, t³)]: 101
//│ 	[LH_N]: 102
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapmapBuiltInType₀₀(primId⁰(enumFromTo₀₀(1, 100000)))
//│ def enumFromTo₀₀(a², b²) = 
//│ 	if (a² <= b²) then [LH_C a² enumFromTo₀₀((a² + 1), b²)] else [LH_N]
//│ def testMapmapBuiltInType₀₀(_lh_testMapmapBuiltInType_arg1²) = 
//│ 	map₀₀((fun x⁴ -> (x⁴ + 1)), map₁₀((fun x⁵ -> (x⁵ * x⁵)), _lh_testMapmapBuiltInType_arg1²))
//│ 	where
//│ 	def map₀₀(f⁴, ls⁴) = 
//│ 		ls⁴(f⁴)
//│ 	def map₁₀(f⁵, ls⁵) = 
//│ 		case ls⁵ of {
//│ 			LH_C h³ t³ => 
//│ 				let h⁴ = f⁵(h³)
//│ 				in let t⁴ = map₁₀(f⁵, t³)
//│ 				in (fun f⁶ -> [LH_C f⁶(h⁴) map₀₀(f⁶, t⁴)])
//│ 			| LH_N  => (fun f⁷ -> [LH_N])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


// NOTE: lumberhack is slightly slower, since this lastDrive and
// last is also somehow accumulating-parametric?
:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun filter(ls, f) = if ls is
  C(h, t) then if f(h) then C(h, filter(t, f)) else filter(t, f)
  N then N
fun lastDrive(ls) = if ls is
  C(h, t) then Some(last(h, t))
  N then None
fun last(a, ls) = if ls is
  N then a
  C(h, t) then last(h, t)
fun testLastFilter(ls) = lastDrive(filter(ls, x => x < 1000))
fun _lhManualLastFilter(ls, f, a) = if ls is
  C(h, t) then if f(h) then _lhManualLastFilter(t, f, Some(h)) else _lhManualLastFilter(t, f, a)
  N then a
fun testManual(ls) = _lhManualLastFilter(ls, x => x < 1000, None)
testLastFilter(primId(enumFromTo(1, 500000)))
testManual(primId(enumFromTo(1, 500000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |filter|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |C|(|h|,| |filter|(|t|,| |f|)|)| |#else| |filter|(|t|,| |f|)|↵|N| |#then| |N|←|↵|#fun| |lastDrive|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |Some|(|last|(|h|,| |t|)|)|↵|N| |#then| |None|←|↵|#fun| |last|(|a|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a|↵|C|(|h|,| |t|)| |#then| |last|(|h|,| |t|)|←|↵|#fun| |testLastFilter|(|ls|)| |#=| |lastDrive|(|filter|(|ls|,| |x| |=>| |x| |<| |1000|)|)|↵|#fun| |_lhManualLastFilter|(|ls|,| |f|,| |a|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |_lhManualLastFilter|(|t|,| |f|,| |Some|(|h|)|)| |#else| |_lhManualLastFilter|(|t|,| |f|,| |a|)|↵|N| |#then| |a|←|↵|#fun| |testManual|(|ls|)| |#=| |_lhManualLastFilter|(|ls|,| |x| |=>| |x| |<| |1000|,| |None|)|↵|testLastFilter|(|primId|(|enumFromTo|(|1|,| |500000|)|)|)|↵|testManual|(|primId|(|enumFromTo|(|1|,| |500000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun filter = ls, f, => if ls is ‹(C (h, t,)) then if (f (h,)) then C (h, filter (t, f,),) else filter (t, f,); (N) then N›; fun lastDrive = ls, => if ls is ‹(C (h, t,)) then Some (last (h, t,),); (N) then None›; fun last = a, ls, => if ls is ‹(N) then a; (C (h, t,)) then last (h, t,)›; fun testLastFilter = ls, => lastDrive (filter (ls, x, => < (x,) (1000,),),); fun _lhManualLastFilter = ls, f, a, => if ls is ‹(C (h, t,)) then if (f (h,)) then _lhManualLastFilter (t, f, Some (h,),) else _lhManualLastFilter (t, f, a,); (N) then a›; fun testManual = ls, => _lhManualLastFilter (ls, x, => < (x,) (1000,), None,); testLastFilter (primId (enumFromTo (1, 500000,),),); testManual (primId (enumFromTo (1, 500000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testLastFilter^113(primId⁰(enumFromTo^115(1, 500000)))
//│ testManual^122(primId⁰(enumFromTo^124(1, 500000)))
//│ def _lhManualLastFilter(ls⁴, f¹, a²) = case ls⁴ of {
//│ 	C h³ t³ => if f¹(h³) then _lhManualLastFilter^79(t³, f¹, [Some h³]) else _lhManualLastFilter^87(t³, f¹, a²)
//│ 	| N  => a²}
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def filter(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter^26(t⁰, f⁰)] else filter^32(t⁰, f⁰)
//│ 	| N  => [N]}
//│ def last(a¹, ls²) = case ls² of {
//│ 	N  => a¹
//│ 	| C h² t² => last^54(h², t²)}
//│ def lastDrive(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => [Some last^43(h¹, t¹)]
//│ 	| N  => [None]}
//│ def testLastFilter(ls³) = lastDrive^62(filter^63(ls³, (fun x⁰ -> (x⁰ < 1000))))
//│ def testManual(ls⁵) = _lhManualLastFilter^100(ls⁵, (fun x¹ -> (x¹ < 1000)), [None])
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec _lhManualLastFilter ls_4 f_1 a_2 =
//│ 		  (match ls_4 with
//│ 		    | `C(h_3, t_3) -> 
//│ 		      (if (f_1 h_3) then
//│ 		        (((_lhManualLastFilter t_3) f_1) (`Some(h_3)))
//│ 		      else
//│ 		        (((_lhManualLastFilter t_3) f_1) a_2))
//│ 		    | `N -> 
//│ 		      a_2);;
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec filter ls_0 f_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (f_0 h_0) then
//│ 		        (`C(h_0, ((filter t_0) f_0)))
//│ 		      else
//│ 		        ((filter t_0) f_0))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec last a_1 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      a_1
//│ 		    | `C(h_2, t_2) -> 
//│ 		      ((last h_2) t_2));;
//│ 		let rec lastDrive ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (`Some(((last h_1) t_1)))
//│ 		    | `N -> 
//│ 		      (`None))
//│ 		and testLastFilter ls_3 =
//│ 		  (lastDrive ((filter ls_3) (fun x_0 -> 
//│ 		    (x_0 < 1000))))
//│ 		and testManual ls_5 =
//│ 		  (((_lhManualLastFilter ls_5) (fun x_1 -> 
//│ 		    (x_1 < 1000))) (`None));;
//│ 		(testLastFilter ((enumFromTo 1) 500000))
//│ 		(testManual ((enumFromTo 1) 500000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo^115] (hopeless to continue)
//│ 	[enumFromTo^115 · enumFromTo^7] ---> [enumFromTo^115] (using original def)
//│ [enumFromTo^124]
//│ 	[enumFromTo^124 · enumFromTo^7] ---> [enumFromTo^124] (only one)
//│ [testLastFilter^113]
//│ 	[testLastFilter^113 · filter^63]
//│ 		[testLastFilter^113 · filter^63 · filter^26] (hopeless to continue)
//│ 			[testLastFilter^113 · filter^63 · filter^26 · filter^26] ---> [testLastFilter^113 · filter^63 · filter^26] (using original def)
//│ 			[testLastFilter^113 · filter^63 · filter^26 · filter^32] ---> [testLastFilter^113 · filter^63 · filter^26] (using original def)
//│ 		[testLastFilter^113 · filter^63 · filter^32] ---> [testLastFilter^113 · filter^63] (only one)
//│ 	[testLastFilter^113 · lastDrive^62] (hopeless to continue)
//│ 		[testLastFilter^113 · lastDrive^62 · last^43] (using original def)
//│ 			[testLastFilter^113 · lastDrive^62 · last^43 · last^54] ---> [testLastFilter^113 · lastDrive^62 · last^43] (using original def)
//│ [testManual^122]
//│ 	[testManual^122 · _lhManualLastFilter^100]
//│ 		[testManual^122 · _lhManualLastFilter^100 · _lhManualLastFilter^79] (hopeless to continue)
//│ 			[testManual^122 · _lhManualLastFilter^100 · _lhManualLastFilter^79 · _lhManualLastFilter^79] ---> [testManual^122 · _lhManualLastFilter^100 · _lhManualLastFilter^79] (using original def)
//│ 			[testManual^122 · _lhManualLastFilter^100 · _lhManualLastFilter^79 · _lhManualLastFilter^87] ---> [testManual^122 · _lhManualLastFilter^100 · _lhManualLastFilter^79] (using original def)
//│ 		[testManual^122 · _lhManualLastFilter^100 · _lhManualLastFilter^87] ---> [testManual^122 · _lhManualLastFilter^100] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testLastFilter₀(primId⁰(enumFromTo₀(1, 500000)))
//│ testManual₀(primId⁰(enumFromTo₁(1, 500000)))
//│ def enumFromTo₀(a⁷, b²) = 
//│ 	if (a⁷ <= b²) then [C a⁷ enumFromTo₀((a⁷ + 1), b²)] else [N]
//│ def enumFromTo₁(a³, b¹) = 
//│ 	if (a³ <= b¹) then [C a³ enumFromTo₁((a³ + 1), b¹)] else [N]
//│ def testLastFilter₀(ls¹⁰) = 
//│ 	lastDrive₀(filter₀(ls¹⁰, (fun x² -> (x² < 1000))))
//│ 	where
//│ 	def filter₀(ls¹³, f⁵) = 
//│ 		case ls¹³ of {
//│ 			C h⁹ t⁹ => if f⁵(h⁹) then [C h⁹ filter₁(t⁹, f⁵)] else filter₀(t⁹, f⁵)
//│ 			| N  => [N]}
//│ 		where
//│ 		def filter₁(ls⁶, f²) = 
//│ 			case ls⁶ of {
//│ 				C h⁴ t⁴ => if f²(h⁴) then [C h⁴ filter₁(t⁴, f²)] else filter₁(t⁴, f²)
//│ 				| N  => [N]}
//│ 	def lastDrive₀(ls¹¹) = 
//│ 		case ls¹¹ of {
//│ 			C h⁸ t⁸ => [Some last₀(h⁸, t⁸)]
//│ 			| N  => [None]}
//│ 		where
//│ 		def last₀(a⁵, ls⁸) = 
//│ 			case ls⁸ of {
//│ 				N  => a⁵
//│ 				| C h⁶ t⁶ => last₀(h⁶, t⁶)}
//│ def testManual₀(ls¹²) = 
//│ 	_lhManualLastFilter₀(ls¹², (fun x³ -> (x³ < 1000)), [None])
//│ 	where
//│ 	def _lhManualLastFilter₀(ls⁹, f⁴, a⁶) = 
//│ 		case ls⁹ of {
//│ 			C h⁷ t⁷ => if f⁴(h⁷) then _lhManualLastFilter₁(t⁷, f⁴, [Some h⁷]) else _lhManualLastFilter₀(t⁷, f⁴, a⁶)
//│ 			| N  => a⁶}
//│ 		where
//│ 		def _lhManualLastFilter₁(ls⁷, f³, a⁴) = 
//│ 			case ls⁷ of {
//│ 				C h⁵ t⁵ => if f³(h⁵) then _lhManualLastFilter₁(t⁵, f³, [Some h⁵]) else _lhManualLastFilter₁(t⁵, f³, a⁴)
//│ 				| N  => a⁴}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁴ filter₁(t⁴, f²)]: 161 --->
//│ 	case ls⁸ of {N  => a⁵ | C h⁶ t⁶ => last₀(h⁶, t⁶)}: 204
//│ [N]: 168 --->
//│ 	case ls⁸ of {N  => a⁵ | C h⁶ t⁶ => last₀(h⁶, t⁶)}: 204
//│ [C h⁹ filter₁(t⁹, f⁵)]: 298 --->
//│ 	case ls¹¹ of {C h⁸ t⁸ => [Some last₀(h⁸, t⁸)] | N  => [None]}: 273
//│ [N]: 305 --->
//│ 	case ls¹¹ of {C h⁸ t⁸ => [Some last₀(h⁸, t⁸)] | N  => [None]}: 273
//│ ------------------
//│ case ls⁸ of {N  => a⁵ | C h⁶ t⁶ => last₀(h⁶, t⁶)}: 204 --->
//│ 	[C h⁴ filter₁(t⁴, f²)]: 161
//│ 	[N]: 168
//│ case ls¹¹ of {C h⁸ t⁸ => [Some last₀(h⁸, t⁸)] | N  => [None]}: 273 --->
//│ 	[C h⁹ filter₁(t⁹, f⁵)]: 298
//│ 	[N]: 305
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h⁴ filter₁(t⁴, f²)]: 161 --->
//│ 	case ls⁸ of {N  => a⁵ | C h⁶ t⁶ => last₀(h⁶, t⁶)}: 204
//│ [N]: 168 --->
//│ 	case ls⁸ of {N  => a⁵ | C h⁶ t⁶ => last₀(h⁶, t⁶)}: 204
//│ [C h⁹ filter₁(t⁹, f⁵)]: 298 --->
//│ 	case ls¹¹ of {C h⁸ t⁸ => [Some last₀(h⁸, t⁸)] | N  => [None]}: 273
//│ [N]: 305 --->
//│ 	case ls¹¹ of {C h⁸ t⁸ => [Some last₀(h⁸, t⁸)] | N  => [None]}: 273
//│ ------------------
//│ case ls⁸ of {N  => a⁵ | C h⁶ t⁶ => last₀(h⁶, t⁶)}: 204 --->
//│ 	[C h⁴ filter₁(t⁴, f²)]: 161
//│ 	[N]: 168
//│ case ls¹¹ of {C h⁸ t⁸ => [Some last₀(h⁸, t⁸)] | N  => [None]}: 273 --->
//│ 	[C h⁹ filter₁(t⁹, f⁵)]: 298
//│ 	[N]: 305
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testLastFilter₀(primId⁰(enumFromTo₀(1, 500000)))
//│ testManual₀(primId⁰(enumFromTo₁(1, 500000)))
//│ def enumFromTo₀(a¹², b³) = 
//│ 	if (a¹² <= b³) then [C a¹² enumFromTo₀((a¹² + 1), b³)] else [N]
//│ def enumFromTo₁(a¹³, b⁴) = 
//│ 	if (a¹³ <= b⁴) then [C a¹³ enumFromTo₁((a¹³ + 1), b⁴)] else [N]
//│ def testLastFilter₀(ls¹⁷) = 
//│ 	lastDrive₀(filter₀(ls¹⁷, (fun x⁴ -> (x⁴ < 1000))))
//│ 	where
//│ 	def filter₀(ls¹⁸, f⁷) = 
//│ 		case ls¹⁸ of {
//│ 			C h⁹ t⁹ => if f⁷(h⁹) then 
//│ 				let h¹¹ = h⁹
//│ 				in let t¹¹ = filter₁(t⁹, f⁷)
//│ 				in [Some last₀(h¹¹, t¹¹)] else filter₀(t⁹, f⁷)
//│ 			| N  => [None]}
//│ 		where
//│ 		def filter₁(ls¹⁵, f⁶) = 
//│ 			case ls¹⁵ of {
//│ 				C h⁴ t⁴ => if f⁶(h⁴) then 
//│ 					let h¹⁰ = h⁴
//│ 					in let t¹⁰ = filter₁(t⁴, f⁶)
//│ 					in (fun a⁸ -> last₀(h¹⁰, t¹⁰)) else filter₁(t⁴, f⁶)
//│ 				| N  => (fun a⁹ -> a⁹)}
//│ 	def lastDrive₀(ls¹⁴) = 
//│ 		ls¹⁴
//│ 		where
//│ 		def last₀(a¹⁰, ls¹⁶) = 
//│ 			ls¹⁶(a¹⁰)
//│ def testManual₀(ls²⁰) = 
//│ 	_lhManualLastFilter₀(ls²⁰, (fun x⁵ -> (x⁵ < 1000)), [None])
//│ 	where
//│ 	def _lhManualLastFilter₀(ls¹⁹, f⁸, a¹¹) = 
//│ 		case ls¹⁹ of {
//│ 			C h⁷ t⁷ => if f⁸(h⁷) then _lhManualLastFilter₁(t⁷, f⁸, [Some h⁷]) else _lhManualLastFilter₀(t⁷, f⁸, a¹¹)
//│ 			| N  => a¹¹}
//│ 		where
//│ 		def _lhManualLastFilter₁(ls²¹, f⁹, a¹⁴) = 
//│ 			case ls²¹ of {
//│ 				C h⁵ t⁵ => if f⁹(h⁵) then _lhManualLastFilter₁(t⁵, f⁹, [Some h⁵]) else _lhManualLastFilter₁(t⁵, f⁹, a¹⁴)
//│ 				| N  => a¹⁴}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun filter(ls, f) = if ls is
  C(h, t) then if f(h) then C(h, filter(t, f)) else filter(t, f)
  N then N
fun lastDrive(ls) = if ls is
  C(h, t) then Some(last(h, t))
  N then None
fun last(a, ls) = if ls is
  N then a
  C(h, t) then last(h, t)
fun testLastFilterEnum(n) = lastDrive(filter(enumFromTo(1, n), x => x < 1000))
testLastFilterEnum(primId(500000))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |filter|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |C|(|h|,| |filter|(|t|,| |f|)|)| |#else| |filter|(|t|,| |f|)|↵|N| |#then| |N|←|↵|#fun| |lastDrive|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |Some|(|last|(|h|,| |t|)|)|↵|N| |#then| |None|←|↵|#fun| |last|(|a|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a|↵|C|(|h|,| |t|)| |#then| |last|(|h|,| |t|)|←|↵|#fun| |testLastFilterEnum|(|n|)| |#=| |lastDrive|(|filter|(|enumFromTo|(|1|,| |n|)|,| |x| |=>| |x| |<| |1000|)|)|↵|testLastFilterEnum|(|primId|(|500000|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun filter = ls, f, => if ls is ‹(C (h, t,)) then if (f (h,)) then C (h, filter (t, f,),) else filter (t, f,); (N) then N›; fun lastDrive = ls, => if ls is ‹(C (h, t,)) then Some (last (h, t,),); (N) then None›; fun last = a, ls, => if ls is ‹(N) then a; (C (h, t,)) then last (h, t,)›; fun testLastFilterEnum = n, => lastDrive (filter (enumFromTo (1, n,), x, => < (x,) (1000,),),); testLastFilterEnum (primId (500000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testLastFilterEnum^79(primId⁰(500000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def filter(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter^26(t⁰, f⁰)] else filter^32(t⁰, f⁰)
//│ 	| N  => [N]}
//│ def last(a¹, ls²) = case ls² of {
//│ 	N  => a¹
//│ 	| C h² t² => last^54(h², t²)}
//│ def lastDrive(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => [Some last^43(h¹, t¹)]
//│ 	| N  => [None]}
//│ def testLastFilterEnum(n⁰) = lastDrive^62(filter^63(enumFromTo^64(1, n⁰), (fun x⁰ -> (x⁰ < 1000))))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec filter ls_0 f_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (f_0 h_0) then
//│ 		        (`C(h_0, ((filter t_0) f_0)))
//│ 		      else
//│ 		        ((filter t_0) f_0))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec last a_1 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      a_1
//│ 		    | `C(h_2, t_2) -> 
//│ 		      ((last h_2) t_2));;
//│ 		let rec lastDrive ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (`Some(((last h_1) t_1)))
//│ 		    | `N -> 
//│ 		      (`None))
//│ 		and testLastFilterEnum n_0 =
//│ 		  (lastDrive ((filter ((enumFromTo 1) n_0)) (fun x_0 -> 
//│ 		    (x_0 < 1000))));;
//│ 		(testLastFilterEnum 500000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testLastFilterEnum^79] (hopeless to continue)
//│ 	[testLastFilterEnum^79 · enumFromTo^64] (using original def)
//│ 		[testLastFilterEnum^79 · enumFromTo^64 · enumFromTo^7] ---> [testLastFilterEnum^79 · enumFromTo^64] (using original def)
//│ 	[testLastFilterEnum^79 · filter^63] (using original def)
//│ 		[testLastFilterEnum^79 · filter^63 · filter^26] ---> [testLastFilterEnum^79 · filter^63] (using original def)
//│ 		[testLastFilterEnum^79 · filter^63 · filter^32] ---> [testLastFilterEnum^79 · filter^63] (using original def)
//│ 	[testLastFilterEnum^79 · lastDrive^62] (using original def)
//│ 		[testLastFilterEnum^79 · lastDrive^62 · last^43] (using original def)
//│ 			[testLastFilterEnum^79 · lastDrive^62 · last^43 · last^54] ---> [testLastFilterEnum^79 · lastDrive^62 · last^43] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testLastFilterEnum₀(primId⁰(500000))
//│ def testLastFilterEnum₀(n¹) = 
//│ 	lastDrive₀(filter₀(enumFromTo₀(1, n¹), (fun x¹ -> (x¹ < 1000))))
//│ 	where
//│ 	def enumFromTo₀(a², b¹) = 
//│ 		if (a² <= b¹) then [C a² enumFromTo₀((a² + 1), b¹)] else [N]
//│ 	def filter₀(ls⁴, f¹) = 
//│ 		case ls⁴ of {
//│ 			C h⁴ t⁴ => if f¹(h⁴) then [C h⁴ filter₀(t⁴, f¹)] else filter₀(t⁴, f¹)
//│ 			| N  => [N]}
//│ 	def lastDrive₀(ls³) = 
//│ 		case ls³ of {
//│ 			C h³ t³ => [Some last₀(h³, t³)]
//│ 			| N  => [None]}
//│ 		where
//│ 		def last₀(a³, ls⁵) = 
//│ 			case ls⁵ of {
//│ 				N  => a³
//│ 				| C h⁵ t⁵ => last₀(h⁵, t⁵)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a² enumFromTo₀((a² + 1), b¹)]: 99 --->
//│ 	case ls⁴ of {C h⁴ t⁴ => if f¹(h⁴) then [C h⁴ filter₀(t⁴, f¹)] else filter₀(t⁴, f¹) | N  => [N]}: 132
//│ [N]: 100 --->
//│ 	case ls⁴ of {C h⁴ t⁴ => if f¹(h⁴) then [C h⁴ filter₀(t⁴, f¹)] else filter₀(t⁴, f¹) | N  => [N]}: 132
//│ [C h⁴ filter₀(t⁴, f¹)]: 124 --->
//│ 	case ls³ of {C h³ t³ => [Some last₀(h³, t³)] | N  => [None]}: 112
//│ 	case ls⁵ of {N  => a³ | C h⁵ t⁵ => last₀(h⁵, t⁵)}: 159
//│ [N]: 131 --->
//│ 	case ls³ of {C h³ t³ => [Some last₀(h³, t³)] | N  => [None]}: 112
//│ 	case ls⁵ of {N  => a³ | C h⁵ t⁵ => last₀(h⁵, t⁵)}: 159
//│ ------------------
//│ case ls³ of {C h³ t³ => [Some last₀(h³, t³)] | N  => [None]}: 112 --->
//│ 	[C h⁴ filter₀(t⁴, f¹)]: 124
//│ 	[N]: 131
//│ case ls⁴ of {C h⁴ t⁴ => if f¹(h⁴) then [C h⁴ filter₀(t⁴, f¹)] else filter₀(t⁴, f¹) | N  => [N]}: 132 --->
//│ 	[C a² enumFromTo₀((a² + 1), b¹)]: 99
//│ 	[N]: 100
//│ case ls⁵ of {N  => a³ | C h⁵ t⁵ => last₀(h⁵, t⁵)}: 159 --->
//│ 	[C h⁴ filter₀(t⁴, f¹)]: 124
//│ 	[N]: 131
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C a² enumFromTo₀((a² + 1), b¹)]: 99 --->
//│ 	case ls⁴ of {C h⁴ t⁴ => if f¹(h⁴) then [C h⁴ filter₀(t⁴, f¹)] else filter₀(t⁴, f¹) | N  => [N]}: 132
//│ [N]: 100 --->
//│ 	case ls⁴ of {C h⁴ t⁴ => if f¹(h⁴) then [C h⁴ filter₀(t⁴, f¹)] else filter₀(t⁴, f¹) | N  => [N]}: 132
//│ ------------------
//│ case ls⁴ of {C h⁴ t⁴ => if f¹(h⁴) then [C h⁴ filter₀(t⁴, f¹)] else filter₀(t⁴, f¹) | N  => [N]}: 132 --->
//│ 	[C a² enumFromTo₀((a² + 1), b¹)]: 99
//│ 	[N]: 100
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testLastFilterEnum₀(primId⁰(500000))
//│ def testLastFilterEnum₀(n²) = 
//│ 	lastDrive₀(filter₀(enumFromTo₀(1, n²), (fun x² -> (x² < 1000))))
//│ 	where
//│ 	def enumFromTo₀(a⁴, b²) = 
//│ 		if (a⁴ <= b²) then 
//│ 			let h⁶ = a⁴
//│ 			in let t⁶ = enumFromTo₀((a⁴ + 1), b²)
//│ 			in (fun f² -> if f²(h⁶) then [C h⁶ filter₀(t⁶, f²)] else filter₀(t⁶, f²)) else (fun f³ -> [N])
//│ 	def filter₀(ls⁸, f⁴) = 
//│ 		ls⁸(f⁴)
//│ 	def lastDrive₀(ls⁶) = 
//│ 		case ls⁶ of {
//│ 			C h³ t³ => [Some last₀(h³, t³)]
//│ 			| N  => [None]}
//│ 		where
//│ 		def last₀(a⁵, ls⁷) = 
//│ 			case ls⁷ of {
//│ 				N  => a⁵
//│ 				| C h⁵ t⁵ => last₀(h⁵, t⁵)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun testMapmap(ls) = map(x => x + 1, map(x => x * x, ls))
fun _lhManual(ls, f1, f2) = if ls is
  C(h, t) then C(f2(f1(h)), _lhManual(t, f1, f2))
  N then N
fun testManual(ls) = _lhManual(ls, x => x * x, x => x + 1)
testMapmap(primId(enumFromTo(1, 100000)))
testManual(primId(enumFromTo(1, 100000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |testMapmap|(|ls|)| |#=| |map|(|x| |=>| |x| |+| |1|,| |map|(|x| |=>| |x| |*| |x|,| |ls|)|)|↵|#fun| |_lhManual|(|ls|,| |f1|,| |f2|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f2|(|f1|(|h|)|)|,| |_lhManual|(|t|,| |f1|,| |f2|)|)|↵|N| |#then| |N|←|↵|#fun| |testManual|(|ls|)| |#=| |_lhManual|(|ls|,| |x| |=>| |x| |*| |x|,| |x| |=>| |x| |+| |1|)|↵|testMapmap|(|primId|(|enumFromTo|(|1|,| |100000|)|)|)|↵|testManual|(|primId|(|enumFromTo|(|1|,| |100000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun testMapmap = ls, => map (x, => + (x,) (1,), map (x, => * (x,) (x,), ls,),); fun _lhManual = ls, f1, f2, => if ls is ‹(C (h, t,)) then C (f2 (f1 (h,),), _lhManual (t, f1, f2,),); (N) then N›; fun testManual = ls, => _lhManual (ls, x, => * (x,) (x,), x, => + (x,) (1,),); testMapmap (primId (enumFromTo (1, 100000,),),); testManual (primId (enumFromTo (1, 100000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapmap^92(primId⁰(enumFromTo^94(1, 100000)))
//│ testManual^101(primId⁰(enumFromTo^103(1, 100000)))
//│ def _lhManual(ls², f1⁰, f2⁰) = case ls² of {
//│ 	C h¹ t¹ => [C f2⁰(f1⁰(h¹)) _lhManual^61(t¹, f1⁰, f2⁰)]
//│ 	| N  => [N]}
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^25(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def testManual(ls³) = _lhManual^74(ls³, (fun x² -> (x² * x²)), (fun x³ -> (x³ + 1)))
//│ def testMapmap(ls¹) = map^35((fun x⁰ -> (x⁰ + 1)), map^43((fun x¹ -> (x¹ * x¹)), ls¹))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec _lhManual ls_2 f1_0 f2_0 =
//│ 		  (match ls_2 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (`C((f2_0 (f1_0 h_1)), (((_lhManual t_1) f1_0) f2_0)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec testManual ls_3 =
//│ 		  (((_lhManual ls_3) (fun x_2 -> 
//│ 		    (x_2 * x_2))) (fun x_3 -> 
//│ 		    (x_3 + 1)))
//│ 		and testMapmap ls_1 =
//│ 		  ((map (fun x_0 -> 
//│ 		    (x_0 + 1))) ((map (fun x_1 -> 
//│ 		    (x_1 * x_1))) ls_1));;
//│ 		(testMapmap ((enumFromTo 1) 100000))
//│ 		(testManual ((enumFromTo 1) 100000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo^103]
//│ 	[enumFromTo^103 · enumFromTo^7] ---> [enumFromTo^103] (only one)
//│ [enumFromTo^94] (hopeless to continue)
//│ 	[enumFromTo^94 · enumFromTo^7] ---> [enumFromTo^94] (using original def)
//│ [testManual^101]
//│ 	[testManual^101 · _lhManual^74]
//│ 		[testManual^101 · _lhManual^74 · _lhManual^61] ---> [testManual^101 · _lhManual^74] (only one)
//│ [testMapmap^92]
//│ 	[testMapmap^92 · map^35]
//│ 		[testMapmap^92 · map^35 · map^25] ---> [testMapmap^92 · map^35] (only one)
//│ 	[testMapmap^92 · map^43]
//│ 		[testMapmap^92 · map^43 · map^25] ---> [testMapmap^92 · map^43] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testMapmap₀(primId⁰(enumFromTo₁(1, 100000)))
//│ testManual₀(primId⁰(enumFromTo₀(1, 100000)))
//│ def enumFromTo₀(a¹, b¹) = 
//│ 	if (a¹ <= b¹) then [C a¹ enumFromTo₀((a¹ + 1), b¹)] else [N]
//│ def enumFromTo₁(a², b²) = 
//│ 	if (a² <= b²) then [C a² enumFromTo₁((a² + 1), b²)] else [N]
//│ def testManual₀(ls⁴) = 
//│ 	_lhManual₀(ls⁴, (fun x⁴ -> (x⁴ * x⁴)), (fun x⁵ -> (x⁵ + 1)))
//│ 	where
//│ 	def _lhManual₀(ls⁶, f1¹, f2¹) = 
//│ 		case ls⁶ of {
//│ 			C h³ t³ => [C f2¹(f1¹(h³)) _lhManual₀(t³, f1¹, f2¹)]
//│ 			| N  => [N]}
//│ def testMapmap₀(ls⁸) = 
//│ 	map₀((fun x⁶ -> (x⁶ + 1)), map₁((fun x⁷ -> (x⁷ * x⁷)), ls⁸))
//│ 	where
//│ 	def map₀(f², ls⁷) = 
//│ 		case ls⁷ of {
//│ 			C h⁴ t⁴ => [C f²(h⁴) map₀(f², t⁴)]
//│ 			| N  => [N]}
//│ 	def map₁(f¹, ls⁵) = 
//│ 		case ls⁵ of {
//│ 			C h² t² => [C f¹(h²) map₁(f¹, t²)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f¹(h²) map₁(f¹, t²)]: 137 --->
//│ 	case ls⁷ of {C h⁴ t⁴ => [C f²(h⁴) map₀(f², t⁴)] | N  => [N]}: 192
//│ [N]: 138 --->
//│ 	case ls⁷ of {C h⁴ t⁴ => [C f²(h⁴) map₀(f², t⁴)] | N  => [N]}: 192
//│ ------------------
//│ case ls⁷ of {C h⁴ t⁴ => [C f²(h⁴) map₀(f², t⁴)] | N  => [N]}: 192 --->
//│ 	[C f¹(h²) map₁(f¹, t²)]: 137
//│ 	[N]: 138
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f¹(h²) map₁(f¹, t²)]: 137 --->
//│ 	case ls⁷ of {C h⁴ t⁴ => [C f²(h⁴) map₀(f², t⁴)] | N  => [N]}: 192
//│ [N]: 138 --->
//│ 	case ls⁷ of {C h⁴ t⁴ => [C f²(h⁴) map₀(f², t⁴)] | N  => [N]}: 192
//│ ------------------
//│ case ls⁷ of {C h⁴ t⁴ => [C f²(h⁴) map₀(f², t⁴)] | N  => [N]}: 192 --->
//│ 	[C f¹(h²) map₁(f¹, t²)]: 137
//│ 	[N]: 138
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapmap₀(primId⁰(enumFromTo₁(1, 100000)))
//│ testManual₀(primId⁰(enumFromTo₀(1, 100000)))
//│ def enumFromTo₀(a⁴, b⁴) = 
//│ 	if (a⁴ <= b⁴) then [C a⁴ enumFromTo₀((a⁴ + 1), b⁴)] else [N]
//│ def enumFromTo₁(a³, b³) = 
//│ 	if (a³ <= b³) then [C a³ enumFromTo₁((a³ + 1), b³)] else [N]
//│ def testManual₀(ls¹³) = 
//│ 	_lhManual₀(ls¹³, (fun x¹⁰ -> (x¹⁰ * x¹⁰)), (fun x¹¹ -> (x¹¹ + 1)))
//│ 	where
//│ 	def _lhManual₀(ls⁹, f1², f2²) = 
//│ 		case ls⁹ of {
//│ 			C h³ t³ => [C f2²(f1²(h³)) _lhManual₀(t³, f1², f2²)]
//│ 			| N  => [N]}
//│ def testMapmap₀(ls¹⁰) = 
//│ 	map₀((fun x⁸ -> (x⁸ + 1)), map₁((fun x⁹ -> (x⁹ * x⁹)), ls¹⁰))
//│ 	where
//│ 	def map₀(f³, ls¹¹) = 
//│ 		ls¹¹(f³)
//│ 	def map₁(f⁴, ls¹²) = 
//│ 		case ls¹² of {
//│ 			C h² t² => 
//│ 				let h⁵ = f⁴(h²)
//│ 				in let t⁵ = map₁(f⁴, t²)
//│ 				in (fun f⁵ -> [C f⁵(h⁵) map₀(f⁵, t⁵)])
//│ 			| N  => (fun f⁶ -> [N])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


// NOTE: digression: simply use `let r = f(h) in C(r, map(t, f))` will be faster
:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun map(f, ls) = if ls is
  C(h, t) then let r = f(h) in C(r, map(f, t))
  N then N
fun testMapmapLet(ls) = map(x => x + 1, map(x => x * x, ls))
testMapmapLet(primId(enumFromTo(1, 100000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#let| |r| |#=| |f|(|h|)| |#in| |C|(|r|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |testMapmapLet|(|ls|)| |#=| |map|(|x| |=>| |x| |+| |1|,| |map|(|x| |=>| |x| |*| |x|,| |ls|)|)|↵|testMapmapLet|(|primId|(|enumFromTo|(|1|,| |100000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun map = f, ls, => if ls is ‹(C (h, t,)) then let r = f (h,) in C (r, map (f, t,),); (N) then N›; fun testMapmapLet = ls, => map (x, => + (x,) (1,), map (x, => * (x,) (x,), ls,),); testMapmapLet (primId (enumFromTo (1, 100000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapmapLet^57(primId⁰(enumFromTo^59(1, 100000)))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let r⁰ = f⁰(h⁰)
//│ 		in [C r⁰ map^26(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def testMapmapLet(ls¹) = map^37((fun x⁰ -> (x⁰ + 1)), map^45((fun x¹ -> (x¹ * x¹)), ls¹))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (let rec r_0 = (f_0 h_0) in
//│ 		        (`C(r_0, ((map f_0) t_0))))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec testMapmapLet ls_1 =
//│ 		  ((map (fun x_0 -> 
//│ 		    (x_0 + 1))) ((map (fun x_1 -> 
//│ 		    (x_1 * x_1))) ls_1));;
//│ 		(testMapmapLet ((enumFromTo 1) 100000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo^59]
//│ 	[enumFromTo^59 · enumFromTo^7] ---> [enumFromTo^59] (only one)
//│ [testMapmapLet^57]
//│ 	[testMapmapLet^57 · map^37]
//│ 		[testMapmapLet^57 · map^37 · map^26] ---> [testMapmapLet^57 · map^37] (only one)
//│ 	[testMapmapLet^57 · map^45]
//│ 		[testMapmapLet^57 · map^45 · map^26] ---> [testMapmapLet^57 · map^45] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testMapmapLet₀(primId⁰(enumFromTo₀(1, 100000)))
//│ def enumFromTo₀(a¹, b¹) = 
//│ 	if (a¹ <= b¹) then [C a¹ enumFromTo₀((a¹ + 1), b¹)] else [N]
//│ def testMapmapLet₀(ls³) = 
//│ 	map₀((fun x² -> (x² + 1)), map₁((fun x³ -> (x³ * x³)), ls³))
//│ 	where
//│ 	def map₀(f², ls⁴) = 
//│ 		case ls⁴ of {
//│ 			C h² t² => 
//│ 				let r² = f²(h²)
//│ 				in [C r² map₀(f², t²)]
//│ 			| N  => [N]}
//│ 	def map₁(f¹, ls²) = 
//│ 		case ls² of {
//│ 			C h¹ t¹ => 
//│ 				let r¹ = f¹(h¹)
//│ 				in [C r¹ map₁(f¹, t¹)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C r¹ map₁(f¹, t¹)]: 76 --->
//│ 	case ls⁴ of {C h² t² => let r² = f²(h²)
//│ in [C r² map₀(f², t²)] | N  => [N]}: 135
//│ [N]: 78 --->
//│ 	case ls⁴ of {C h² t² => let r² = f²(h²)
//│ in [C r² map₀(f², t²)] | N  => [N]}: 135
//│ ------------------
//│ case ls⁴ of {C h² t² => let r² = f²(h²)
//│ in [C r² map₀(f², t²)] | N  => [N]}: 135 --->
//│ 	[C r¹ map₁(f¹, t¹)]: 76
//│ 	[N]: 78
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C r¹ map₁(f¹, t¹)]: 76 --->
//│ 	case ls⁴ of {C h² t² => let r² = f²(h²)
//│ in [C r² map₀(f², t²)] | N  => [N]}: 135
//│ [N]: 78 --->
//│ 	case ls⁴ of {C h² t² => let r² = f²(h²)
//│ in [C r² map₀(f², t²)] | N  => [N]}: 135
//│ ------------------
//│ case ls⁴ of {C h² t² => let r² = f²(h²)
//│ in [C r² map₀(f², t²)] | N  => [N]}: 135 --->
//│ 	[C r¹ map₁(f¹, t¹)]: 76
//│ 	[N]: 78
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapmapLet₀(primId⁰(enumFromTo₀(1, 100000)))
//│ def enumFromTo₀(a², b²) = 
//│ 	if (a² <= b²) then [C a² enumFromTo₀((a² + 1), b²)] else [N]
//│ def testMapmapLet₀(ls⁶) = 
//│ 	map₀((fun x⁴ -> (x⁴ + 1)), map₁((fun x⁵ -> (x⁵ * x⁵)), ls⁶))
//│ 	where
//│ 	def map₀(f⁶, ls⁷) = 
//│ 		ls⁷(f⁶)
//│ 	def map₁(f³, ls⁵) = 
//│ 		case ls⁵ of {
//│ 			C h¹ t¹ => 
//│ 				let r³ = f³(h¹)
//│ 				in let h³ = r³
//│ 				in let t³ = map₁(f³, t¹)
//│ 				in (fun f⁴ -> 
//│ 					let r⁴ = f⁴(h³)
//│ 					in [C r⁴ map₀(f⁴, t³)])
//│ 			| N  => (fun f⁵ -> [N])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
:lhInHaskell
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = flatMap (\b ->
              flatMap (\q -> if (safe q 1 b) then [q:b] else []) [1..nq]
            ) (gen (n-1) nq)
flatMap f [] = []
flatMap f (h:t) = append (f h) (flatMap f t)
append [] ys = ys
append (h:t) ys = h:(append t ys)
nsoln nq = length (gen nq nq)
testQueenUsingFlatMap n = nsoln n
testQueenUsingFlatMap $ primId 11
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testQueenUsingFlatMap₀^507(primId⁰(11))
//│ def append₀(_lh_append_arg1¹, _lh_append_arg2¹) = case _lh_append_arg1¹ of {
//│ 	LH_N  => _lh_append_arg2¹
//│ 	| LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append₀^304(_lh_append_LH_C_1¹, _lh_append_arg2¹)]
//│ 	| _  => error⁰("match error")}
//│ def append₁(_lh_append_arg1², _lh_append_arg2²) = case _lh_append_arg1² of {
//│ 	LH_N  => _lh_append_arg2²
//│ 	| LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append₁^495(_lh_append_LH_C_1², _lh_append_arg2²)]
//│ 	| _  => error⁰("match error")}
//│ def enumFromTo₀(a², b⁴) = if (a² <= b⁴) then [LH_C a² enumFromTo₀^455((a² + 1), b⁴)] else [LH_N]
//│ def flatMap₀(_lh_flatMap_arg1², _lh_flatMap_arg2²) = case _lh_flatMap_arg2² of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append₀^475(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap₀^480(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²))
//│ 	| _  => error⁰("match error")}
//│ def flatMap₁(_lh_flatMap_arg1¹, _lh_flatMap_arg2¹) = case _lh_flatMap_arg2¹ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append₁^389(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap₁^394(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹))
//│ 	| _  => error⁰("match error")}
//│ def gen₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => flatMap₀^410((fun b³ -> flatMap₁^411((fun q¹ -> if safe₀^412(q¹, 1, b³) then [LH_C [LH_C q¹ b³] [LH_N]] else [LH_N]), enumFromTo₀^428(1, _lh_gen_arg2¹))), gen₀^436((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length₀(ls⁷) = case ls⁷ of {
//│ 	LH_C h⁷ t⁸ => (1 + length₀^380(t⁸))
//│ 	| LH_N  => 0}
//│ def nsoln₀(_lh_nsoln_arg1¹) = length₀^316(gen₀^317(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀^357(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))
//│ 	| _  => error⁰("match error")}
//│ def testQueenUsingFlatMap₀(_lh_testQueenUsingFlatMap_arg1¹) = nsoln₀^469(_lh_testQueenUsingFlatMap_arg1¹)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec append_d0 _lh_append_arg1_1 _lh_append_arg2_1 =
//│ 		  (match _lh_append_arg1_1 with
//│ 		    | [] -> 
//│ 		      _lh_append_arg2_1
//│ 		    | (_lh_append_LH_C_0_1 :: _lh_append_LH_C_1_1) -> 
//│ 		      (_lh_append_LH_C_0_1::((append_d0 _lh_append_LH_C_1_1) _lh_append_arg2_1))
//│ 		    | _ -> 
//│ 		      (failwith "match error"));;
//│ 		let rec append_d1 _lh_append_arg1_2 _lh_append_arg2_2 =
//│ 		  (match _lh_append_arg1_2 with
//│ 		    | [] -> 
//│ 		      _lh_append_arg2_2
//│ 		    | (_lh_append_LH_C_0_2 :: _lh_append_LH_C_1_2) -> 
//│ 		      (_lh_append_LH_C_0_2::((append_d1 _lh_append_LH_C_1_2) _lh_append_arg2_2))
//│ 		    | _ -> 
//│ 		      (failwith "match error"));;
//│ 		let rec enumFromTo_d0 a_2 b_4 =
//│ 		  (if (a_2 <= b_4) then
//│ 		    (a_2::((enumFromTo_d0 (a_2 + 1)) b_4))
//│ 		  else
//│ 		    []);;
//│ 		let rec length_d0 ls_7 =
//│ 		  (match ls_7 with
//│ 		    | (h_7 :: t_8) -> 
//│ 		      (1 + (length_d0 t_8))
//│ 		    | [] -> 
//│ 		      0);;
//│ 		let rec safe_d0 _lh_safe_arg1_1 _lh_safe_arg2_1 _lh_safe_arg3_1 =
//│ 		  (match _lh_safe_arg3_1 with
//│ 		    | [] -> 
//│ 		      true
//│ 		    | (_lh_safe_LH_C_0_1 :: _lh_safe_LH_C_1_1) -> 
//│ 		      ((((_lh_safe_arg1_1 != _lh_safe_LH_C_0_1) && (_lh_safe_arg1_1 != (_lh_safe_LH_C_0_1 + _lh_safe_arg2_1))) && (_lh_safe_arg1_1 != (_lh_safe_LH_C_0_1 - _lh_safe_arg2_1))) && (((safe_d0 _lh_safe_arg1_1) (_lh_safe_arg2_1 + 1)) _lh_safe_LH_C_1_1))
//│ 		    | _ -> 
//│ 		      (failwith "match error"));;
//│ 		let rec flatMap_d0 _lh_flatMap_arg1_2 _lh_flatMap_arg2_2 =
//│ 		  (match _lh_flatMap_arg2_2 with
//│ 		    | [] -> 
//│ 		      []
//│ 		    | (_lh_flatMap_LH_C_0_2 :: _lh_flatMap_LH_C_1_2) -> 
//│ 		      ((append_d0 (_lh_flatMap_arg1_2 _lh_flatMap_LH_C_0_2)) ((flatMap_d0 _lh_flatMap_arg1_2) _lh_flatMap_LH_C_1_2))
//│ 		    | _ -> 
//│ 		      (failwith "match error"))
//│ 		and flatMap_d1 _lh_flatMap_arg1_1 _lh_flatMap_arg2_1 =
//│ 		  (match _lh_flatMap_arg2_1 with
//│ 		    | [] -> 
//│ 		      []
//│ 		    | (_lh_flatMap_LH_C_0_1 :: _lh_flatMap_LH_C_1_1) -> 
//│ 		      ((append_d1 (_lh_flatMap_arg1_1 _lh_flatMap_LH_C_0_1)) ((flatMap_d1 _lh_flatMap_arg1_1) _lh_flatMap_LH_C_1_1))
//│ 		    | _ -> 
//│ 		      (failwith "match error"))
//│ 		and gen_d0 _lh_gen_arg1_1 _lh_gen_arg2_1 =
//│ 		  (match _lh_gen_arg1_1 with
//│ 		    | 0 -> 
//│ 		      ([]::[])
//│ 		    | _ -> 
//│ 		      ((flatMap_d0 (fun b_3 -> 
//│ 		        ((flatMap_d1 (fun q_1 -> 
//│ 		          (if (((safe_d0 q_1) 1) b_3) then
//│ 		            ((q_1::b_3)::[])
//│ 		          else
//│ 		            []))) ((enumFromTo_d0 1) _lh_gen_arg2_1)))) ((gen_d0 (_lh_gen_arg1_1 - 1)) _lh_gen_arg2_1)))
//│ 		and nsoln_d0 _lh_nsoln_arg1_1 =
//│ 		  (length_d0 ((gen_d0 _lh_nsoln_arg1_1) _lh_nsoln_arg1_1))
//│ 		and testQueenUsingFlatMap_d0 _lh_testQueenUsingFlatMap_arg1_1 =
//│ 		  (nsoln_d0 _lh_testQueenUsingFlatMap_arg1_1);;
//│ 		(testQueenUsingFlatMap_d0 11)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testQueenUsingFlatMap₀^507] (hopeless to continue)
//│ 	[testQueenUsingFlatMap₀^507 · nsoln₀^469] (using original def)
//│ 		[testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317] (using original def)
//│ 			[testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · enumFromTo₀^428] (using original def)
//│ 				[testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · enumFromTo₀^428 · enumFromTo₀^455] ---> [testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · enumFromTo₀^428] (using original def)
//│ 			[testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · flatMap₀^410] (using original def)
//│ 				[testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · flatMap₀^410 · append₀^475] (using original def)
//│ 					[testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · flatMap₀^410 · append₀^475 · append₀^304] ---> [testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · flatMap₀^410 · append₀^475] (using original def)
//│ 				[testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · flatMap₀^410 · flatMap₀^480] ---> [testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · flatMap₀^410] (using original def)
//│ 			[testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · flatMap₁^411] (using original def)
//│ 				[testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · flatMap₁^411 · append₁^389] (using original def)
//│ 					[testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · flatMap₁^411 · append₁^389 · append₁^495] ---> [testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · flatMap₁^411 · append₁^389] (using original def)
//│ 				[testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · flatMap₁^411 · flatMap₁^394] ---> [testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · flatMap₁^411] (using original def)
//│ 			[testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · gen₀^436] ---> [testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317] (using original def)
//│ 			[testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · safe₀^412] (using original def)
//│ 				[testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · safe₀^412 · safe₀^357] ---> [testQueenUsingFlatMap₀^507 · nsoln₀^469 · gen₀^317 · safe₀^412] (using original def)
//│ 		[testQueenUsingFlatMap₀^507 · nsoln₀^469 · length₀^316] (using original def)
//│ 			[testQueenUsingFlatMap₀^507 · nsoln₀^469 · length₀^316 · length₀^380] ---> [testQueenUsingFlatMap₀^507 · nsoln₀^469 · length₀^316] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testQueenUsingFlatMap₀₀(primId⁰(11))
//│ def testQueenUsingFlatMap₀₀(_lh_testQueenUsingFlatMap_arg1¹) = 
//│ 	nsoln₀₀(_lh_testQueenUsingFlatMap_arg1¹)
//│ 	where
//│ 	def nsoln₀₀(_lh_nsoln_arg1¹) = 
//│ 		length₀₀(gen₀₀(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ 		where
//│ 		def gen₀₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = 
//│ 			case _lh_gen_arg1¹ of {
//│ 				0  => [LH_C [LH_N] [LH_N]]
//│ 				| _  => flatMap₀₀((fun b³ -> flatMap₁₀((fun q¹ -> if safe₀₀(q¹, 1, b³) then [LH_C [LH_C q¹ b³] [LH_N]] else [LH_N]), enumFromTo₀₀(1, _lh_gen_arg2¹))), gen₀₀((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ 			where
//│ 			def enumFromTo₀₀(a¹, b²) = 
//│ 				if (a¹ <= b²) then [LH_C a¹ enumFromTo₀₀((a¹ + 1), b²)] else [LH_N]
//│ 			def flatMap₀₀(_lh_flatMap_arg1³, _lh_flatMap_arg2³) = 
//│ 				case _lh_flatMap_arg2³ of {
//│ 					LH_N  => [LH_N]
//│ 					| LH_C _lh_flatMap_LH_C_0³ _lh_flatMap_LH_C_1³ => append₀₀(_lh_flatMap_arg1³(_lh_flatMap_LH_C_0³), flatMap₀₀(_lh_flatMap_arg1³, _lh_flatMap_LH_C_1³))
//│ 					| _  => error⁰("match error")}
//│ 				where
//│ 				def append₀₀(_lh_append_arg1², _lh_append_arg2²) = 
//│ 					case _lh_append_arg1² of {
//│ 						LH_N  => _lh_append_arg2²
//│ 						| LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append₀₀(_lh_append_LH_C_1², _lh_append_arg2²)]
//│ 						| _  => error⁰("match error")}
//│ 			def flatMap₁₀(_lh_flatMap_arg1², _lh_flatMap_arg2²) = 
//│ 				case _lh_flatMap_arg2² of {
//│ 					LH_N  => [LH_N]
//│ 					| LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append₁₀(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap₁₀(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²))
//│ 					| _  => error⁰("match error")}
//│ 				where
//│ 				def append₁₀(_lh_append_arg1³, _lh_append_arg2³) = 
//│ 					case _lh_append_arg1³ of {
//│ 						LH_N  => _lh_append_arg2³
//│ 						| LH_C _lh_append_LH_C_0³ _lh_append_LH_C_1³ => [LH_C _lh_append_LH_C_0³ append₁₀(_lh_append_LH_C_1³, _lh_append_arg2³)]
//│ 						| _  => error⁰("match error")}
//│ 			def safe₀₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = 
//│ 				case _lh_safe_arg3¹ of {
//│ 					LH_N  => [True]
//│ 					| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))
//│ 					| _  => error⁰("match error")}
//│ 		def length₀₀(ls¹) = 
//│ 			case ls¹ of {
//│ 				LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 				| LH_N  => 0}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b²)]: 235 --->
//│ 	case _lh_flatMap_arg2² of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append₁₀(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap₁₀(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²)) | _  => error⁰("match error")}: 290
//│ [LH_N]: 236 --->
//│ 	case _lh_flatMap_arg2² of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append₁₀(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap₁₀(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²)) | _  => error⁰("match error")}: 290
//│ [LH_C _lh_append_LH_C_0² append₀₀(_lh_append_LH_C_1², _lh_append_arg2²)]: 248 --->
//│ 	case _lh_flatMap_arg2³ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0³ _lh_flatMap_LH_C_1³ => append₀₀(_lh_flatMap_arg1³(_lh_flatMap_LH_C_0³), flatMap₀₀(_lh_flatMap_arg1³, _lh_flatMap_LH_C_1³)) | _  => error⁰("match error")}: 309
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 373
//│ [LH_C _lh_append_LH_C_0³ append₁₀(_lh_append_LH_C_1³, _lh_append_arg2³)]: 263 --->
//│ 	case _lh_append_arg1² of {LH_N  => _lh_append_arg2² | LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append₀₀(_lh_append_LH_C_1², _lh_append_arg2²)] | _  => error⁰("match error")}: 252
//│ [LH_N]: 275 --->
//│ 	case _lh_append_arg1² of {LH_N  => _lh_append_arg2² | LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append₀₀(_lh_append_LH_C_1², _lh_append_arg2²)] | _  => error⁰("match error")}: 252
//│ [LH_N]: 294 --->
//│ 	case _lh_flatMap_arg2³ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0³ _lh_flatMap_LH_C_1³ => append₀₀(_lh_flatMap_arg1³(_lh_flatMap_LH_C_0³), flatMap₀₀(_lh_flatMap_arg1³, _lh_flatMap_LH_C_1³)) | _  => error⁰("match error")}: 309
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 373
//│ [LH_N]: 376 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 360
//│ [LH_N]: 377 --->
//│ 	case _lh_flatMap_arg2³ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0³ _lh_flatMap_LH_C_1³ => append₀₀(_lh_flatMap_arg1³(_lh_flatMap_LH_C_0³), flatMap₀₀(_lh_flatMap_arg1³, _lh_flatMap_LH_C_1³)) | _  => error⁰("match error")}: 309
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 373
//│ [LH_C [LH_N] [LH_N]]: 378 --->
//│ 	case _lh_flatMap_arg2³ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0³ _lh_flatMap_LH_C_1³ => append₀₀(_lh_flatMap_arg1³(_lh_flatMap_LH_C_0³), flatMap₀₀(_lh_flatMap_arg1³, _lh_flatMap_LH_C_1³)) | _  => error⁰("match error")}: 309
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 373
//│ [LH_C q¹ b³]: 390 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 360
//│ [LH_N]: 391 --->
//│ 	case _lh_append_arg1³ of {LH_N  => _lh_append_arg2³ | LH_C _lh_append_LH_C_0³ _lh_append_LH_C_1³ => [LH_C _lh_append_LH_C_0³ append₁₀(_lh_append_LH_C_1³, _lh_append_arg2³)] | _  => error⁰("match error")}: 267
//│ [LH_C [LH_C q¹ b³] [LH_N]]: 392 --->
//│ 	case _lh_append_arg1³ of {LH_N  => _lh_append_arg2³ | LH_C _lh_append_LH_C_0³ _lh_append_LH_C_1³ => [LH_C _lh_append_LH_C_0³ append₁₀(_lh_append_LH_C_1³, _lh_append_arg2³)] | _  => error⁰("match error")}: 267
//│ [LH_N]: 393 --->
//│ 	case _lh_append_arg1³ of {LH_N  => _lh_append_arg2³ | LH_C _lh_append_LH_C_0³ _lh_append_LH_C_1³ => [LH_C _lh_append_LH_C_0³ append₁₀(_lh_append_LH_C_1³, _lh_append_arg2³)] | _  => error⁰("match error")}: 267
//│ ------------------
//│ case _lh_append_arg1² of {LH_N  => _lh_append_arg2² | LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append₀₀(_lh_append_LH_C_1², _lh_append_arg2²)] | _  => error⁰("match error")}: 252 --->
//│ 	[LH_C _lh_append_LH_C_0³ append₁₀(_lh_append_LH_C_1³, _lh_append_arg2³)]: 263
//│ 	[LH_N]: 275
//│ case _lh_append_arg1³ of {LH_N  => _lh_append_arg2³ | LH_C _lh_append_LH_C_0³ _lh_append_LH_C_1³ => [LH_C _lh_append_LH_C_0³ append₁₀(_lh_append_LH_C_1³, _lh_append_arg2³)] | _  => error⁰("match error")}: 267 --->
//│ 	[LH_N]: 391
//│ 	[LH_C [LH_C q¹ b³] [LH_N]]: 392
//│ 	[LH_N]: 393
//│ case _lh_flatMap_arg2² of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append₁₀(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap₁₀(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²)) | _  => error⁰("match error")}: 290 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b²)]: 235
//│ 	[LH_N]: 236
//│ case _lh_flatMap_arg2³ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0³ _lh_flatMap_LH_C_1³ => append₀₀(_lh_flatMap_arg1³(_lh_flatMap_LH_C_0³), flatMap₀₀(_lh_flatMap_arg1³, _lh_flatMap_LH_C_1³)) | _  => error⁰("match error")}: 309 --->
//│ 	[LH_C _lh_append_LH_C_0² append₀₀(_lh_append_LH_C_1², _lh_append_arg2²)]: 248
//│ 	[LH_N]: 294
//│ 	[LH_N]: 377
//│ 	[LH_C [LH_N] [LH_N]]: 378
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 360 --->
//│ 	[LH_N]: 376
//│ 	[LH_C q¹ b³]: 390
//│ case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 373 --->
//│ 	[LH_C _lh_append_LH_C_0² append₀₀(_lh_append_LH_C_1², _lh_append_arg2²)]: 248
//│ 	[LH_N]: 294
//│ 	[LH_N]: 377
//│ 	[LH_C [LH_N] [LH_N]]: 378
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b²)]: 235 --->
//│ 	case _lh_flatMap_arg2² of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append₁₀(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap₁₀(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²)) | _  => error⁰("match error")}: 290
//│ [LH_N]: 236 --->
//│ 	case _lh_flatMap_arg2² of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append₁₀(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap₁₀(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²)) | _  => error⁰("match error")}: 290
//│ [LH_C _lh_append_LH_C_0³ append₁₀(_lh_append_LH_C_1³, _lh_append_arg2³)]: 263 --->
//│ 	case _lh_append_arg1² of {LH_N  => _lh_append_arg2² | LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append₀₀(_lh_append_LH_C_1², _lh_append_arg2²)] | _  => error⁰("match error")}: 252
//│ [LH_N]: 275 --->
//│ 	case _lh_append_arg1² of {LH_N  => _lh_append_arg2² | LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append₀₀(_lh_append_LH_C_1², _lh_append_arg2²)] | _  => error⁰("match error")}: 252
//│ [LH_N]: 376 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 360
//│ [LH_C q¹ b³]: 390 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 360
//│ [LH_N]: 391 --->
//│ 	case _lh_append_arg1³ of {LH_N  => _lh_append_arg2³ | LH_C _lh_append_LH_C_0³ _lh_append_LH_C_1³ => [LH_C _lh_append_LH_C_0³ append₁₀(_lh_append_LH_C_1³, _lh_append_arg2³)] | _  => error⁰("match error")}: 267
//│ [LH_C [LH_C q¹ b³] [LH_N]]: 392 --->
//│ 	case _lh_append_arg1³ of {LH_N  => _lh_append_arg2³ | LH_C _lh_append_LH_C_0³ _lh_append_LH_C_1³ => [LH_C _lh_append_LH_C_0³ append₁₀(_lh_append_LH_C_1³, _lh_append_arg2³)] | _  => error⁰("match error")}: 267
//│ [LH_N]: 393 --->
//│ 	case _lh_append_arg1³ of {LH_N  => _lh_append_arg2³ | LH_C _lh_append_LH_C_0³ _lh_append_LH_C_1³ => [LH_C _lh_append_LH_C_0³ append₁₀(_lh_append_LH_C_1³, _lh_append_arg2³)] | _  => error⁰("match error")}: 267
//│ ------------------
//│ case _lh_append_arg1² of {LH_N  => _lh_append_arg2² | LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append₀₀(_lh_append_LH_C_1², _lh_append_arg2²)] | _  => error⁰("match error")}: 252 --->
//│ 	[LH_C _lh_append_LH_C_0³ append₁₀(_lh_append_LH_C_1³, _lh_append_arg2³)]: 263
//│ 	[LH_N]: 275
//│ case _lh_append_arg1³ of {LH_N  => _lh_append_arg2³ | LH_C _lh_append_LH_C_0³ _lh_append_LH_C_1³ => [LH_C _lh_append_LH_C_0³ append₁₀(_lh_append_LH_C_1³, _lh_append_arg2³)] | _  => error⁰("match error")}: 267 --->
//│ 	[LH_N]: 391
//│ 	[LH_C [LH_C q¹ b³] [LH_N]]: 392
//│ 	[LH_N]: 393
//│ case _lh_flatMap_arg2² of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append₁₀(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap₁₀(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²)) | _  => error⁰("match error")}: 290 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b²)]: 235
//│ 	[LH_N]: 236
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 360 --->
//│ 	[LH_N]: 376
//│ 	[LH_C q¹ b³]: 390
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testQueenUsingFlatMap₀₀(primId⁰(11))
//│ def testQueenUsingFlatMap₀₀(_lh_testQueenUsingFlatMap_arg1²) = 
//│ 	nsoln₀₀(_lh_testQueenUsingFlatMap_arg1²)
//│ 	where
//│ 	def nsoln₀₀(_lh_nsoln_arg1²) = 
//│ 		length₀₀(gen₀₀(_lh_nsoln_arg1², _lh_nsoln_arg1²))
//│ 		where
//│ 		def gen₀₀(_lh_gen_arg1², _lh_gen_arg2²) = 
//│ 			case _lh_gen_arg1² of {
//│ 				0  => [LH_C (fun _lh_safe_arg1³ -> (fun _lh_safe_arg2³ -> [True])) [LH_N]]
//│ 				| _  => flatMap₀₀((fun b⁵ -> flatMap₁₀((fun q² -> if safe₀₀(q², 1, b⁵) then 
//│ 					let _lh_append_LH_C_0⁴ = 	
//│ 						let _lh_safe_LH_C_0² = q²
//│ 						in let _lh_safe_LH_C_1² = b⁵
//│ 						in (fun _lh_safe_arg1⁴ -> (fun _lh_safe_arg2⁴ -> ((((_lh_safe_arg1⁴ /= _lh_safe_LH_C_0²) && (_lh_safe_arg1⁴ /= (_lh_safe_LH_C_0² + _lh_safe_arg2⁴))) && (_lh_safe_arg1⁴ /= (_lh_safe_LH_C_0² - _lh_safe_arg2⁴))) && safe₀₀(_lh_safe_arg1⁴, (_lh_safe_arg2⁴ + 1), _lh_safe_LH_C_1²))))
//│ 					in let _lh_append_LH_C_1⁴ = (fun _lh_append_arg2⁹ -> _lh_append_arg2⁹)
//│ 					in (fun _lh_append_arg2⁷ -> 
//│ 						let _lh_append_LH_C_0⁵ = _lh_append_LH_C_0⁴
//│ 						in let _lh_append_LH_C_1⁵ = append₁₀(_lh_append_LH_C_1⁴, _lh_append_arg2⁷)
//│ 						in (fun _lh_append_arg2⁸ -> [LH_C _lh_append_LH_C_0⁵ append₀₀(_lh_append_LH_C_1⁵, _lh_append_arg2⁸)])) else (fun _lh_append_arg2¹⁰ -> _lh_append_arg2¹⁰)), enumFromTo₀₀(1, _lh_gen_arg2²))), gen₀₀((_lh_gen_arg1² - 1), _lh_gen_arg2²))}
//│ 			where
//│ 			def enumFromTo₀₀(a², b⁴) = 
//│ 				if (a² <= b⁴) then 
//│ 					let _lh_flatMap_LH_C_0⁴ = a²
//│ 					in let _lh_flatMap_LH_C_1⁴ = enumFromTo₀₀((a² + 1), b⁴)
//│ 					in (fun _lh_flatMap_arg1⁴ -> append₁₀(_lh_flatMap_arg1⁴(_lh_flatMap_LH_C_0⁴), flatMap₁₀(_lh_flatMap_arg1⁴, _lh_flatMap_LH_C_1⁴))) else (fun _lh_flatMap_arg1⁵ -> (fun _lh_append_arg2⁵ -> _lh_append_arg2⁵))
//│ 			def flatMap₀₀(_lh_flatMap_arg1⁶, _lh_flatMap_arg2⁴) = 
//│ 				case _lh_flatMap_arg2⁴ of {
//│ 					LH_N  => [LH_N]
//│ 					| LH_C _lh_flatMap_LH_C_0³ _lh_flatMap_LH_C_1³ => append₀₀(_lh_flatMap_arg1⁶(_lh_flatMap_LH_C_0³), flatMap₀₀(_lh_flatMap_arg1⁶, _lh_flatMap_LH_C_1³))
//│ 					| _  => error⁰("match error")}
//│ 				where
//│ 				def append₀₀(_lh_append_arg1⁵, _lh_append_arg2⁶) = 
//│ 					_lh_append_arg1⁵(_lh_append_arg2⁶)
//│ 			def flatMap₁₀(_lh_flatMap_arg1⁷, _lh_flatMap_arg2⁵) = 
//│ 				_lh_flatMap_arg2⁵(_lh_flatMap_arg1⁷)
//│ 				where
//│ 				def append₁₀(_lh_append_arg1⁴, _lh_append_arg2⁴) = 
//│ 					_lh_append_arg1⁴(_lh_append_arg2⁴)
//│ 			def safe₀₀(_lh_safe_arg1², _lh_safe_arg2², _lh_safe_arg3²) = 
//│ 				_lh_safe_arg3²(_lh_safe_arg1², _lh_safe_arg2²)
//│ 		def length₀₀(ls²) = 
//│ 			case ls² of {
//│ 				LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 				| LH_N  => 0}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<



:lhGenOCaml
:lhInHaskell
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = [ (q:b) | b <- gen (n-1) nq, q <- [1..nq], safe q 1 b ]
nsoln nq = length (gen nq nq)
testQueen n = nsoln n
testQueen $ primId 11
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testQueen₀^429(primId⁰(11))
//│ def enumFromTo₀(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo₀^415((a² + 1), b²)] else [LH_N]
//│ def gen₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 			LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 				let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 					LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀^349(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 					| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 				in _lh_listcomp_fun³(enumFromTo₀^373(1, _lh_gen_arg2¹))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun²(gen₀^384((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length₀(ls⁷) = case ls⁷ of {
//│ 	LH_C h⁷ t⁸ => (1 + length₀^402(t⁸))
//│ 	| LH_N  => 0}
//│ def nsoln₀(_lh_nsoln_arg1¹) = length₀^331(gen₀^332(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀^312(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))
//│ 	| _  => error⁰("match error")}
//│ def testQueen₀(_lh_testQueen_arg1¹) = nsoln₀^339(_lh_testQueen_arg1¹)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_d0 a_2 b_2 =
//│ 		  (if (a_2 <= b_2) then
//│ 		    (a_2::((enumFromTo_d0 (a_2 + 1)) b_2))
//│ 		  else
//│ 		    []);;
//│ 		let rec length_d0 ls_7 =
//│ 		  (match ls_7 with
//│ 		    | (h_7 :: t_8) -> 
//│ 		      (1 + (length_d0 t_8))
//│ 		    | [] -> 
//│ 		      0);;
//│ 		let rec safe_d0 _lh_safe_arg1_1 _lh_safe_arg2_1 _lh_safe_arg3_1 =
//│ 		  (match _lh_safe_arg3_1 with
//│ 		    | [] -> 
//│ 		      true
//│ 		    | (_lh_safe_LH_C_0_1 :: _lh_safe_LH_C_1_1) -> 
//│ 		      ((((_lh_safe_arg1_1 != _lh_safe_LH_C_0_1) && (_lh_safe_arg1_1 != (_lh_safe_LH_C_0_1 + _lh_safe_arg2_1))) && (_lh_safe_arg1_1 != (_lh_safe_LH_C_0_1 - _lh_safe_arg2_1))) && (((safe_d0 _lh_safe_arg1_1) (_lh_safe_arg2_1 + 1)) _lh_safe_LH_C_1_1))
//│ 		    | _ -> 
//│ 		      (failwith "match error"));;
//│ 		let rec gen_d0 _lh_gen_arg1_1 _lh_gen_arg2_1 =
//│ 		  (match _lh_gen_arg1_1 with
//│ 		    | 0 -> 
//│ 		      ([]::[])
//│ 		    | _ -> 
//│ 		      (let rec _lh_listcomp_fun_2 = (fun _lh_listcomp_fun_para_2 -> 
//│ 		        (match _lh_listcomp_fun_para_2 with
//│ 		          | (_lh_listcomp_fun_ls_h_2 :: _lh_listcomp_fun_ls_t_2) -> 
//│ 		            (let rec _lh_listcomp_fun_3 = (fun _lh_listcomp_fun_para_3 -> 
//│ 		              (match _lh_listcomp_fun_para_3 with
//│ 		                | (_lh_listcomp_fun_ls_h_3 :: _lh_listcomp_fun_ls_t_3) -> 
//│ 		                  (if (((safe_d0 _lh_listcomp_fun_ls_h_3) 1) _lh_listcomp_fun_ls_h_2) then
//│ 		                    ((_lh_listcomp_fun_ls_h_3::_lh_listcomp_fun_ls_h_2)::(_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3))
//│ 		                  else
//│ 		                    (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3))
//│ 		                | [] -> 
//│ 		                  (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_2))) in
//│ 		              (_lh_listcomp_fun_3 ((enumFromTo_d0 1) _lh_gen_arg2_1)))
//│ 		          | [] -> 
//│ 		            [])) in
//│ 		        (_lh_listcomp_fun_2 ((gen_d0 (_lh_gen_arg1_1 - 1)) _lh_gen_arg2_1))))
//│ 		and nsoln_d0 _lh_nsoln_arg1_1 =
//│ 		  (length_d0 ((gen_d0 _lh_nsoln_arg1_1) _lh_nsoln_arg1_1))
//│ 		and testQueen_d0 _lh_testQueen_arg1_1 =
//│ 		  (nsoln_d0 _lh_testQueen_arg1_1);;
//│ 		(testQueen_d0 11)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testQueen₀^429] (hopeless to continue)
//│ 	[testQueen₀^429 · nsoln₀^339] (using original def)
//│ 		[testQueen₀^429 · nsoln₀^339 · gen₀^332] (using original def)
//│ 			[testQueen₀^429 · nsoln₀^339 · gen₀^332 · enumFromTo₀^373] (using original def)
//│ 				[testQueen₀^429 · nsoln₀^339 · gen₀^332 · enumFromTo₀^373 · enumFromTo₀^415] ---> [testQueen₀^429 · nsoln₀^339 · gen₀^332 · enumFromTo₀^373] (using original def)
//│ 			[testQueen₀^429 · nsoln₀^339 · gen₀^332 · gen₀^384] ---> [testQueen₀^429 · nsoln₀^339 · gen₀^332] (using original def)
//│ 			[testQueen₀^429 · nsoln₀^339 · gen₀^332 · safe₀^349] (using original def)
//│ 				[testQueen₀^429 · nsoln₀^339 · gen₀^332 · safe₀^349 · safe₀^312] ---> [testQueen₀^429 · nsoln₀^339 · gen₀^332 · safe₀^349] (using original def)
//│ 		[testQueen₀^429 · nsoln₀^339 · length₀^331] (using original def)
//│ 			[testQueen₀^429 · nsoln₀^339 · length₀^331 · length₀^402] ---> [testQueen₀^429 · nsoln₀^339 · length₀^331] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testQueen₀₀(primId⁰(11))
//│ def testQueen₀₀(_lh_testQueen_arg1¹) = 
//│ 	nsoln₀₀(_lh_testQueen_arg1¹)
//│ 	where
//│ 	def nsoln₀₀(_lh_nsoln_arg1¹) = 
//│ 		length₀₀(gen₀₀(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ 		where
//│ 		def gen₀₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = 
//│ 			case _lh_gen_arg1¹ of {
//│ 				0  => [LH_C [LH_N] [LH_N]]
//│ 				| _  => 
//│ 					let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 						LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 							let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 								LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 								| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 							in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹))
//│ 						| LH_N  => [LH_N]})
//│ 					in _lh_listcomp_fun²(gen₀₀((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ 			where
//│ 			def enumFromTo₀₀(a¹, b¹) = 
//│ 				if (a¹ <= b¹) then [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)] else [LH_N]
//│ 			def safe₀₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = 
//│ 				case _lh_safe_arg3¹ of {
//│ 					LH_N  => [True]
//│ 					| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))
//│ 					| _  => error⁰("match error")}
//│ 		def length₀₀(ls¹) = 
//│ 			case ls¹ of {
//│ 				LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 				| LH_N  => 0}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 235 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 267
//│ [LH_N]: 236 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 267
//│ [LH_N]: 241 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 216
//│ [LH_N]: 242 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 278
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 304
//│ [LH_C [LH_N] [LH_N]]: 243 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 278
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 304
//│ [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 255 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 216
//│ [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 259 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 278
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 304
//│ [LH_N]: 277 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 278
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 304
//│ ------------------
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 216 --->
//│ 	[LH_N]: 241
//│ 	[LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 255
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 267 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 235
//│ 	[LH_N]: 236
//│ case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 278 --->
//│ 	[LH_N]: 242
//│ 	[LH_C [LH_N] [LH_N]]: 243
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 259
//│ 	[LH_N]: 277
//│ case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 304 --->
//│ 	[LH_N]: 242
//│ 	[LH_C [LH_N] [LH_N]]: 243
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 259
//│ 	[LH_N]: 277
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 235 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 267
//│ [LH_N]: 236 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 267
//│ [LH_N]: 241 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 216
//│ [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 255 --->
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 216
//│ ------------------
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰("match error")}: 216 --->
//│ 	[LH_N]: 241
//│ 	[LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 255
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 267 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 235
//│ 	[LH_N]: 236
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testQueen₀₀(primId⁰(11))
//│ def testQueen₀₀(_lh_testQueen_arg1²) = 
//│ 	nsoln₀₀(_lh_testQueen_arg1²)
//│ 	where
//│ 	def nsoln₀₀(_lh_nsoln_arg1²) = 
//│ 		length₀₀(gen₀₀(_lh_nsoln_arg1², _lh_nsoln_arg1²))
//│ 		where
//│ 		def gen₀₀(_lh_gen_arg1², _lh_gen_arg2²) = 
//│ 			case _lh_gen_arg1² of {
//│ 				0  => [LH_C (fun _lh_safe_arg1⁴ -> (fun _lh_safe_arg2⁴ -> [True])) [LH_N]]
//│ 				| _  => 
//│ 					let _lh_listcomp_fun⁸ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {
//│ 						LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 							let _lh_listcomp_fun⁹ = (fun _lh_listcomp_fun_para⁵ -> _lh_listcomp_fun_para⁵(_lh_listcomp_fun_ls_h², _lh_listcomp_fun⁹, _lh_listcomp_fun⁸, _lh_listcomp_fun_ls_t²))
//│ 							in _lh_listcomp_fun⁹(enumFromTo₀₀(1, _lh_gen_arg2²))
//│ 						| LH_N  => [LH_N]})
//│ 					in _lh_listcomp_fun⁸(gen₀₀((_lh_gen_arg1² - 1), _lh_gen_arg2²))}
//│ 			where
//│ 			def enumFromTo₀₀(a², b²) = 
//│ 				if (a² <= b²) then 
//│ 					let _lh_listcomp_fun_ls_h⁴ = a²
//│ 					in let _lh_listcomp_fun_ls_t⁴ = enumFromTo₀₀((a² + 1), b²)
//│ 					in (fun _lh_listcomp_fun_ls_h⁵ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_listcomp_fun⁵ -> (fun _lh_listcomp_fun_ls_t⁵ -> if safe₀₀(_lh_listcomp_fun_ls_h⁴, 1, _lh_listcomp_fun_ls_h⁵) then [LH_C 
//│ 						let _lh_safe_LH_C_0² = _lh_listcomp_fun_ls_h⁴
//│ 						in let _lh_safe_LH_C_1² = _lh_listcomp_fun_ls_h⁵
//│ 						in (fun _lh_safe_arg1² -> (fun _lh_safe_arg2² -> ((((_lh_safe_arg1² /= _lh_safe_LH_C_0²) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0² + _lh_safe_arg2²))) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0² - _lh_safe_arg2²))) && safe₀₀(_lh_safe_arg1², (_lh_safe_arg2² + 1), _lh_safe_LH_C_1²)))) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴))))) else (fun _lh_listcomp_fun_ls_h⁶ -> (fun _lh_listcomp_fun⁶ -> (fun _lh_listcomp_fun⁷ -> (fun _lh_listcomp_fun_ls_t⁶ -> _lh_listcomp_fun⁷(_lh_listcomp_fun_ls_t⁶)))))
//│ 			def safe₀₀(_lh_safe_arg1³, _lh_safe_arg2³, _lh_safe_arg3²) = 
//│ 				_lh_safe_arg3²(_lh_safe_arg1³, _lh_safe_arg2³)
//│ 		def length₀₀(ls²) = 
//│ 			case ls² of {
//│ 				LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 				| LH_N  => 0}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun sum(ls) = summ(0, ls)
fun summ(acc, ls) = if ls is
  N then acc
  C(h, t) then summ(acc + h, t)
fun testSumMapSumAcc(n) = sum(map(x => x * x, enumFromTo(1, n)))
testSumMapSumAcc(primId(300000))
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |sum|(|ls|)| |#=| |summ|(|0|,| |ls|)|↵|#fun| |summ|(|acc|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc|↵|C|(|h|,| |t|)| |#then| |summ|(|acc| |+| |h|,| |t|)|←|↵|#fun| |testSumMapSumAcc|(|n|)| |#=| |sum|(|map|(|x| |=>| |x| |*| |x|,| |enumFromTo|(|1|,| |n|)|)|)|↵|testSumMapSumAcc|(|primId|(|300000|)|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun sum = ls, => summ (0, ls,); fun summ = acc, ls, => if ls is ‹(N) then acc; (C (h, t,)) then summ (+ (acc,) (h,), t,)›; fun testSumMapSumAcc = n, => sum (map (x, => * (x,) (x,), enumFromTo (1, n,),),); testSumMapSumAcc (primId (300000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumMapSumAcc^72(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^21((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def sum(ls¹) = summ^35(0, ls¹)
//│ def summ(acc⁰, ls²) = case ls² of {
//│ 	N  => acc⁰
//│ 	| C h¹ t¹ => summ^43((acc⁰ + h¹), t¹)}
//│ def testSumMapSumAcc(n⁰) = sum^55(map^56((fun x⁰ -> (x⁰ * x⁰)), enumFromTo^64(1, n⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec summ acc_0 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      acc_0
//│ 		    | `C(h_1, t_1) -> 
//│ 		      ((summ (acc_0 + h_1)) t_1));;
//│ 		let rec sum ls_1 =
//│ 		  ((summ 0) ls_1)
//│ 		and testSumMapSumAcc n_0 =
//│ 		  (sum ((map (fun x_0 -> 
//│ 		    (x_0 * x_0))) ((enumFromTo 1) n_0)));;
//│ 		(testSumMapSumAcc 300000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testSumMapSumAcc^72] (hopeless to continue)
//│ 	[testSumMapSumAcc^72 · enumFromTo^64] (using original def)
//│ 		[testSumMapSumAcc^72 · enumFromTo^64 · enumFromTo^21] ---> [testSumMapSumAcc^72 · enumFromTo^64] (using original def)
//│ 	[testSumMapSumAcc^72 · map^56] (using original def)
//│ 		[testSumMapSumAcc^72 · map^56 · map^5] ---> [testSumMapSumAcc^72 · map^56] (using original def)
//│ 	[testSumMapSumAcc^72 · sum^55] (using original def)
//│ 		[testSumMapSumAcc^72 · sum^55 · summ^35] (using original def)
//│ 			[testSumMapSumAcc^72 · sum^55 · summ^35 · summ^43] ---> [testSumMapSumAcc^72 · sum^55 · summ^35] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testSumMapSumAcc₀(primId⁰(300000))
//│ def testSumMapSumAcc₀(n¹) = 
//│ 	sum₀(map₀((fun x¹ -> (x¹ * x¹)), enumFromTo₀(1, n¹)))
//│ 	where
//│ 	def enumFromTo₀(a¹, b¹) = 
//│ 		if (a¹ <= b¹) then [C a¹ enumFromTo₀((a¹ + 1), b¹)] else [N]
//│ 	def map₀(f¹, ls³) = 
//│ 		case ls³ of {
//│ 			C h² t² => [C f¹(h²) map₀(f¹, t²)]
//│ 			| N  => [N]}
//│ 	def sum₀(ls⁵) = 
//│ 		summ₀(0, ls⁵)
//│ 		where
//│ 		def summ₀(acc¹, ls⁴) = 
//│ 			case ls⁴ of {
//│ 				N  => acc¹
//│ 				| C h³ t³ => summ₀((acc¹ + h³), t³)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f¹(h²) map₀(f¹, t²)]: 86 --->
//│ 	case ls⁴ of {N  => acc¹ | C h³ t³ => summ₀((acc¹ + h³), t³)}: 122
//│ [N]: 87 --->
//│ 	case ls⁴ of {N  => acc¹ | C h³ t³ => summ₀((acc¹ + h³), t³)}: 122
//│ [C a¹ enumFromTo₀((a¹ + 1), b¹)]: 106 --->
//│ 	case ls³ of {C h² t² => [C f¹(h²) map₀(f¹, t²)] | N  => [N]}: 88
//│ [N]: 107 --->
//│ 	case ls³ of {C h² t² => [C f¹(h²) map₀(f¹, t²)] | N  => [N]}: 88
//│ ------------------
//│ case ls³ of {C h² t² => [C f¹(h²) map₀(f¹, t²)] | N  => [N]}: 88 --->
//│ 	[C a¹ enumFromTo₀((a¹ + 1), b¹)]: 106
//│ 	[N]: 107
//│ case ls⁴ of {N  => acc¹ | C h³ t³ => summ₀((acc¹ + h³), t³)}: 122 --->
//│ 	[C f¹(h²) map₀(f¹, t²)]: 86
//│ 	[N]: 87
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f¹(h²) map₀(f¹, t²)]: 86 --->
//│ 	case ls⁴ of {N  => acc¹ | C h³ t³ => summ₀((acc¹ + h³), t³)}: 122
//│ [N]: 87 --->
//│ 	case ls⁴ of {N  => acc¹ | C h³ t³ => summ₀((acc¹ + h³), t³)}: 122
//│ [C a¹ enumFromTo₀((a¹ + 1), b¹)]: 106 --->
//│ 	case ls³ of {C h² t² => [C f¹(h²) map₀(f¹, t²)] | N  => [N]}: 88
//│ [N]: 107 --->
//│ 	case ls³ of {C h² t² => [C f¹(h²) map₀(f¹, t²)] | N  => [N]}: 88
//│ ------------------
//│ case ls³ of {C h² t² => [C f¹(h²) map₀(f¹, t²)] | N  => [N]}: 88 --->
//│ 	[C a¹ enumFromTo₀((a¹ + 1), b¹)]: 106
//│ 	[N]: 107
//│ case ls⁴ of {N  => acc¹ | C h³ t³ => summ₀((acc¹ + h³), t³)}: 122 --->
//│ 	[C f¹(h²) map₀(f¹, t²)]: 86
//│ 	[N]: 87
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumMapSumAcc₀(primId⁰(300000))
//│ def testSumMapSumAcc₀(n²) = 
//│ 	sum₀(map₀((fun x² -> (x² * x²)), enumFromTo₀(1, n²)))
//│ 	where
//│ 	def enumFromTo₀(a², b²) = 
//│ 		if (a² <= b²) then 
//│ 			let h⁴ = a²
//│ 			in let t⁴ = enumFromTo₀((a² + 1), b²)
//│ 			in (fun f³ -> 
//│ 				let h⁵ = f³(h⁴)
//│ 				in let t⁵ = map₀(f³, t⁴)
//│ 				in (fun acc³ -> summ₀((acc³ + h⁵), t⁵))) else (fun f⁴ -> (fun acc⁴ -> acc⁴))
//│ 	def map₀(f², ls⁸) = 
//│ 		ls⁸(f²)
//│ 	def sum₀(ls⁶) = 
//│ 		summ₀(0, ls⁶)
//│ 		where
//│ 		def summ₀(acc², ls⁷) = 
//│ 			ls⁷(acc²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun sum(ls) = if ls is
  C(h, t) then h + sum(t)
  N then 0
fun testSumMap(n) = sum(map(x => x * x, enumFromTo(1, n)))
testSumMap(primId(300000))
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |h| |+| |sum|(|t|)|↵|N| |#then| |0|←|↵|#fun| |testSumMap|(|n|)| |#=| |sum|(|map|(|x| |=>| |x| |*| |x|,| |enumFromTo|(|1|,| |n|)|)|)|↵|testSumMap|(|primId|(|300000|)|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun sum = ls, => if ls is ‹(C (h, t,)) then + (h,) (sum (t,),); (N) then 0›; fun testSumMap = n, => sum (map (x, => * (x,) (x,), enumFromTo (1, n,),),); testSumMap (primId (300000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumMap^63(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^21((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def sum(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => (h¹ + sum^39(t¹))
//│ 	| N  => 0}
//│ def testSumMap(n⁰) = sum^46(map^47((fun x⁰ -> (x⁰ * x⁰)), enumFromTo^55(1, n⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec sum ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (h_1 + (sum t_1))
//│ 		    | `N -> 
//│ 		      0);;
//│ 		let rec testSumMap n_0 =
//│ 		  (sum ((map (fun x_0 -> 
//│ 		    (x_0 * x_0))) ((enumFromTo 1) n_0)));;
//│ 		(testSumMap 300000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testSumMap^63] (hopeless to continue)
//│ 	[testSumMap^63 · enumFromTo^55] (using original def)
//│ 		[testSumMap^63 · enumFromTo^55 · enumFromTo^21] ---> [testSumMap^63 · enumFromTo^55] (using original def)
//│ 	[testSumMap^63 · map^47] (using original def)
//│ 		[testSumMap^63 · map^47 · map^5] ---> [testSumMap^63 · map^47] (using original def)
//│ 	[testSumMap^63 · sum^46] (using original def)
//│ 		[testSumMap^63 · sum^46 · sum^39] ---> [testSumMap^63 · sum^46] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testSumMap₀(primId⁰(300000))
//│ def testSumMap₀(n¹) = 
//│ 	sum₀(map₀((fun x¹ -> (x¹ * x¹)), enumFromTo₀(1, n¹)))
//│ 	where
//│ 	def enumFromTo₀(a¹, b¹) = 
//│ 		if (a¹ <= b¹) then [C a¹ enumFromTo₀((a¹ + 1), b¹)] else [N]
//│ 	def map₀(f¹, ls³) = 
//│ 		case ls³ of {
//│ 			C h³ t³ => [C f¹(h³) map₀(f¹, t³)]
//│ 			| N  => [N]}
//│ 	def sum₀(ls²) = 
//│ 		case ls² of {
//│ 			C h² t² => (h² + sum₀(t²))
//│ 			| N  => 0}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f¹(h³) map₀(f¹, t³)]: 88 --->
//│ 	case ls² of {C h² t² => (h² + sum₀(t²)) | N  => 0}: 77
//│ [N]: 89 --->
//│ 	case ls² of {C h² t² => (h² + sum₀(t²)) | N  => 0}: 77
//│ [C a¹ enumFromTo₀((a¹ + 1), b¹)]: 108 --->
//│ 	case ls³ of {C h³ t³ => [C f¹(h³) map₀(f¹, t³)] | N  => [N]}: 90
//│ [N]: 109 --->
//│ 	case ls³ of {C h³ t³ => [C f¹(h³) map₀(f¹, t³)] | N  => [N]}: 90
//│ ------------------
//│ case ls² of {C h² t² => (h² + sum₀(t²)) | N  => 0}: 77 --->
//│ 	[C f¹(h³) map₀(f¹, t³)]: 88
//│ 	[N]: 89
//│ case ls³ of {C h³ t³ => [C f¹(h³) map₀(f¹, t³)] | N  => [N]}: 90 --->
//│ 	[C a¹ enumFromTo₀((a¹ + 1), b¹)]: 108
//│ 	[N]: 109
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f¹(h³) map₀(f¹, t³)]: 88 --->
//│ 	case ls² of {C h² t² => (h² + sum₀(t²)) | N  => 0}: 77
//│ [N]: 89 --->
//│ 	case ls² of {C h² t² => (h² + sum₀(t²)) | N  => 0}: 77
//│ [C a¹ enumFromTo₀((a¹ + 1), b¹)]: 108 --->
//│ 	case ls³ of {C h³ t³ => [C f¹(h³) map₀(f¹, t³)] | N  => [N]}: 90
//│ [N]: 109 --->
//│ 	case ls³ of {C h³ t³ => [C f¹(h³) map₀(f¹, t³)] | N  => [N]}: 90
//│ ------------------
//│ case ls² of {C h² t² => (h² + sum₀(t²)) | N  => 0}: 77 --->
//│ 	[C f¹(h³) map₀(f¹, t³)]: 88
//│ 	[N]: 89
//│ case ls³ of {C h³ t³ => [C f¹(h³) map₀(f¹, t³)] | N  => [N]}: 90 --->
//│ 	[C a¹ enumFromTo₀((a¹ + 1), b¹)]: 108
//│ 	[N]: 109
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumMap₀(primId⁰(300000))
//│ def testSumMap₀(n²) = 
//│ 	sum₀(map₀((fun x² -> (x² * x²)), enumFromTo₀(1, n²)))
//│ 	where
//│ 	def enumFromTo₀(a², b²) = 
//│ 		if (a² <= b²) then 
//│ 			let h⁴ = a²
//│ 			in let t⁴ = enumFromTo₀((a² + 1), b²)
//│ 			in (fun f³ -> 
//│ 				let h⁵ = f³(h⁴)
//│ 				in let t⁵ = map₀(f³, t⁴)
//│ 				in (h⁵ + sum₀(t⁵))) else (fun f⁴ -> 0)
//│ 	def map₀(f², ls⁵) = 
//│ 		ls⁵(f²)
//│ 	def sum₀(ls⁴) = 
//│ 		ls⁴
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
:lhInHaskell
and [] = True
and (h:t) = if h then and t else False
append [] ys = ys
append (h:t) ys = h:(append t ys)
queens 0 = [[]]
queens m = [ append p [n] | p <- queens (m - 1), n <- [1 .. 9], safe p n]
safe p n = let m = (length p) + 1 in (and [ (j /= n) && ((i + j) /= (m + n)) && ((i - j) /= (m - n)) | (i, j) <- zip [1..(m - 1)] p ])
testAnotherQueenNine n = length $ queens n
testAnotherQueenNine $ primId 9
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testAnotherQueenNine₀^571(primId⁰(9))
//│ def and₀(_lh_and_arg1¹) = case _lh_and_arg1¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and₀^455(_lh_and_LH_C_1¹) else [False]
//│ 	| _  => error⁰("match error")}
//│ def append₀(_lh_append_arg1¹, _lh_append_arg2¹) = case _lh_append_arg1¹ of {
//│ 	LH_N  => _lh_append_arg2¹
//│ 	| LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append₀^329(_lh_append_LH_C_1¹, _lh_append_arg2¹)]
//│ 	| _  => error⁰("match error")}
//│ def enumFromTo₀(a³, b³) = if (a³ <= b³) then [LH_C a³ enumFromTo₀^384((a³ + 1), b³)] else [LH_N]
//│ def enumFromTo₁(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo₁^347((a² + 1), b²)] else [LH_N]
//│ def length₀(ls⁷) = case ls⁷ of {
//│ 	LH_C h⁷ t⁸ => (1 + length₀^475(t⁸))
//│ 	| LH_N  => 0}
//│ def length₁(ls⁸) = case ls⁸ of {
//│ 	LH_C h⁸ t⁹ => (1 + length₁^564(t⁹))
//│ 	| LH_N  => 0}
//│ def queens₀(_lh_queens_arg1¹) = case _lh_queens_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 			LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => 
//│ 				let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {
//│ 					LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe₀^404(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append₀^409(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)
//│ 					| LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)})
//│ 				in _lh_listcomp_fun⁴(enumFromTo₀^430(1, 9))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun³(queens₀^441((_lh_queens_arg1¹ - 1)))}
//│ def safe₀(_lh_safe_arg1¹, _lh_safe_arg2¹) = 
//│ 	let m¹ = (length₁^483(_lh_safe_arg1¹) + 1)
//│ 	in and₀^489(
//│ 		let _lh_listcomp_fun⁵ = (fun _lh_listcomp_fun_para⁵ -> case _lh_listcomp_fun_para⁵ of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {
//│ 				LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)]
//│ 				| _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)}
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁵(zip₀^541(enumFromTo₁^542(1, (m¹ - 1)), _lh_safe_arg1¹)))
//│ def testAnotherQueenNine₀(_lh_testAnotherQueenNine_arg1¹) = length₀^465(queens₀^466(_lh_testAnotherQueenNine_arg1¹))
//│ def zip₀(xs¹, ys¹) = case xs¹ of {
//│ 	LH_C hx¹ tx¹ => case ys¹ of {
//│ 		LH_C hy¹ ty¹ => [LH_C [LH_P2 hx¹ hy¹] zip₀^366(tx¹, ty¹)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec and_d0 _lh_and_arg1_1 =
//│ 		  (match _lh_and_arg1_1 with
//│ 		    | [] -> 
//│ 		      true
//│ 		    | (_lh_and_LH_C_0_1 :: _lh_and_LH_C_1_1) -> 
//│ 		      (if _lh_and_LH_C_0_1 then
//│ 		        (and_d0 _lh_and_LH_C_1_1)
//│ 		      else
//│ 		        false)
//│ 		    | _ -> 
//│ 		      (failwith "match error"));;
//│ 		let rec append_d0 _lh_append_arg1_1 _lh_append_arg2_1 =
//│ 		  (match _lh_append_arg1_1 with
//│ 		    | [] -> 
//│ 		      _lh_append_arg2_1
//│ 		    | (_lh_append_LH_C_0_1 :: _lh_append_LH_C_1_1) -> 
//│ 		      (_lh_append_LH_C_0_1::((append_d0 _lh_append_LH_C_1_1) _lh_append_arg2_1))
//│ 		    | _ -> 
//│ 		      (failwith "match error"));;
//│ 		let rec enumFromTo_d0 a_3 b_3 =
//│ 		  (if (a_3 <= b_3) then
//│ 		    (a_3::((enumFromTo_d0 (a_3 + 1)) b_3))
//│ 		  else
//│ 		    []);;
//│ 		let rec enumFromTo_d1 a_2 b_2 =
//│ 		  (if (a_2 <= b_2) then
//│ 		    (a_2::((enumFromTo_d1 (a_2 + 1)) b_2))
//│ 		  else
//│ 		    []);;
//│ 		let rec length_d0 ls_7 =
//│ 		  (match ls_7 with
//│ 		    | (h_7 :: t_8) -> 
//│ 		      (1 + (length_d0 t_8))
//│ 		    | [] -> 
//│ 		      0);;
//│ 		let rec length_d1 ls_8 =
//│ 		  (match ls_8 with
//│ 		    | (h_8 :: t_9) -> 
//│ 		      (1 + (length_d1 t_9))
//│ 		    | [] -> 
//│ 		      0);;
//│ 		let rec zip_d0 xs_1 ys_1 =
//│ 		  (match xs_1 with
//│ 		    | (hx_1 :: tx_1) -> 
//│ 		      (match ys_1 with
//│ 		        | (hy_1 :: ty_1) -> 
//│ 		          ((hx_1, hy_1)::((zip_d0 tx_1) ty_1))
//│ 		        | [] -> 
//│ 		          [])
//│ 		    | [] -> 
//│ 		      []);;
//│ 		let rec queens_d0 _lh_queens_arg1_1 =
//│ 		  (match _lh_queens_arg1_1 with
//│ 		    | 0 -> 
//│ 		      ([]::[])
//│ 		    | _ -> 
//│ 		      (let rec _lh_listcomp_fun_3 = (fun _lh_listcomp_fun_para_3 -> 
//│ 		        (match _lh_listcomp_fun_para_3 with
//│ 		          | (_lh_listcomp_fun_ls_h_3 :: _lh_listcomp_fun_ls_t_3) -> 
//│ 		            (let rec _lh_listcomp_fun_4 = (fun _lh_listcomp_fun_para_4 -> 
//│ 		              (match _lh_listcomp_fun_para_4 with
//│ 		                | (_lh_listcomp_fun_ls_h_4 :: _lh_listcomp_fun_ls_t_4) -> 
//│ 		                  (if ((safe_d0 _lh_listcomp_fun_ls_h_3) _lh_listcomp_fun_ls_h_4) then
//│ 		                    (((append_d0 _lh_listcomp_fun_ls_h_3) (_lh_listcomp_fun_ls_h_4::[]))::(_lh_listcomp_fun_4 _lh_listcomp_fun_ls_t_4))
//│ 		                  else
//│ 		                    (_lh_listcomp_fun_4 _lh_listcomp_fun_ls_t_4))
//│ 		                | [] -> 
//│ 		                  (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3))) in
//│ 		              (_lh_listcomp_fun_4 ((enumFromTo_d0 1) 9)))
//│ 		          | [] -> 
//│ 		            [])) in
//│ 		        (_lh_listcomp_fun_3 (queens_d0 (_lh_queens_arg1_1 - 1)))))
//│ 		and safe_d0 _lh_safe_arg1_1 _lh_safe_arg2_1 =
//│ 		  (let rec m_1 = ((length_d1 _lh_safe_arg1_1) + 1) in
//│ 		    (and_d0 (let rec _lh_listcomp_fun_5 = (fun _lh_listcomp_fun_para_5 -> 
//│ 		      (match _lh_listcomp_fun_para_5 with
//│ 		        | (_lh_listcomp_fun_ls_h_5 :: _lh_listcomp_fun_ls_t_5) -> 
//│ 		          (match _lh_listcomp_fun_ls_h_5 with
//│ 		            | (_lh_safe_LH_P2_0_1, _lh_safe_LH_P2_1_1) -> 
//│ 		              ((((_lh_safe_LH_P2_1_1 != _lh_safe_arg2_1) && ((_lh_safe_LH_P2_0_1 + _lh_safe_LH_P2_1_1) != (m_1 + _lh_safe_arg2_1))) && ((_lh_safe_LH_P2_0_1 - _lh_safe_LH_P2_1_1) != (m_1 - _lh_safe_arg2_1)))::(_lh_listcomp_fun_5 _lh_listcomp_fun_ls_t_5))
//│ 		            | _ -> 
//│ 		              (_lh_listcomp_fun_5 _lh_listcomp_fun_ls_t_5))
//│ 		        | [] -> 
//│ 		          [])) in
//│ 		      (_lh_listcomp_fun_5 ((zip_d0 ((enumFromTo_d1 1) (m_1 - 1))) _lh_safe_arg1_1)))))
//│ 		and testAnotherQueenNine_d0 _lh_testAnotherQueenNine_arg1_1 =
//│ 		  (length_d0 (queens_d0 _lh_testAnotherQueenNine_arg1_1));;
//│ 		(testAnotherQueenNine_d0 9)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testAnotherQueenNine₀^571] (hopeless to continue)
//│ 	[testAnotherQueenNine₀^571 · length₀^465] (using original def)
//│ 		[testAnotherQueenNine₀^571 · length₀^465 · length₀^475] ---> [testAnotherQueenNine₀^571 · length₀^465] (using original def)
//│ 	[testAnotherQueenNine₀^571 · queens₀^466] (using original def)
//│ 		[testAnotherQueenNine₀^571 · queens₀^466 · append₀^409] (using original def)
//│ 			[testAnotherQueenNine₀^571 · queens₀^466 · append₀^409 · append₀^329] ---> [testAnotherQueenNine₀^571 · queens₀^466 · append₀^409] (using original def)
//│ 		[testAnotherQueenNine₀^571 · queens₀^466 · enumFromTo₀^430] (using original def)
//│ 			[testAnotherQueenNine₀^571 · queens₀^466 · enumFromTo₀^430 · enumFromTo₀^384] ---> [testAnotherQueenNine₀^571 · queens₀^466 · enumFromTo₀^430] (using original def)
//│ 		[testAnotherQueenNine₀^571 · queens₀^466 · queens₀^441] ---> [testAnotherQueenNine₀^571 · queens₀^466] (using original def)
//│ 		[testAnotherQueenNine₀^571 · queens₀^466 · safe₀^404] (using original def)
//│ 			[testAnotherQueenNine₀^571 · queens₀^466 · safe₀^404 · and₀^489] (using original def)
//│ 				[testAnotherQueenNine₀^571 · queens₀^466 · safe₀^404 · and₀^489 · and₀^455] ---> [testAnotherQueenNine₀^571 · queens₀^466 · safe₀^404 · and₀^489] (using original def)
//│ 			[testAnotherQueenNine₀^571 · queens₀^466 · safe₀^404 · enumFromTo₁^542] (using original def)
//│ 				[testAnotherQueenNine₀^571 · queens₀^466 · safe₀^404 · enumFromTo₁^542 · enumFromTo₁^347] ---> [testAnotherQueenNine₀^571 · queens₀^466 · safe₀^404 · enumFromTo₁^542] (using original def)
//│ 			[testAnotherQueenNine₀^571 · queens₀^466 · safe₀^404 · length₁^483] (using original def)
//│ 				[testAnotherQueenNine₀^571 · queens₀^466 · safe₀^404 · length₁^483 · length₁^564] ---> [testAnotherQueenNine₀^571 · queens₀^466 · safe₀^404 · length₁^483] (using original def)
//│ 			[testAnotherQueenNine₀^571 · queens₀^466 · safe₀^404 · zip₀^541] (using original def)
//│ 				[testAnotherQueenNine₀^571 · queens₀^466 · safe₀^404 · zip₀^541 · zip₀^366] ---> [testAnotherQueenNine₀^571 · queens₀^466 · safe₀^404 · zip₀^541] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testAnotherQueenNine₀₀(primId⁰(9))
//│ def testAnotherQueenNine₀₀(_lh_testAnotherQueenNine_arg1¹) = 
//│ 	length₀₀(queens₀₀(_lh_testAnotherQueenNine_arg1¹))
//│ 	where
//│ 	def length₀₀(ls²) = 
//│ 		case ls² of {
//│ 			LH_C h² t² => (1 + length₀₀(t²))
//│ 			| LH_N  => 0}
//│ 	def queens₀₀(_lh_queens_arg1¹) = 
//│ 		case _lh_queens_arg1¹ of {
//│ 			0  => [LH_C [LH_N] [LH_N]]
//│ 			| _  => 
//│ 				let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 					LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => 
//│ 						let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {
//│ 							LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe₀₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)
//│ 							| LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)})
//│ 						in _lh_listcomp_fun⁴(enumFromTo₀₀(1, 9))
//│ 					| LH_N  => [LH_N]})
//│ 				in _lh_listcomp_fun³(queens₀₀((_lh_queens_arg1¹ - 1)))}
//│ 		where
//│ 		def append₀₀(_lh_append_arg1¹, _lh_append_arg2¹) = 
//│ 			case _lh_append_arg1¹ of {
//│ 				LH_N  => _lh_append_arg2¹
//│ 				| LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append₀₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)]
//│ 				| _  => error⁰("match error")}
//│ 		def enumFromTo₀₀(a³, b³) = 
//│ 			if (a³ <= b³) then [LH_C a³ enumFromTo₀₀((a³ + 1), b³)] else [LH_N]
//│ 		def safe₀₀(_lh_safe_arg1¹, _lh_safe_arg2¹) = 
//│ 			let m¹ = (length₁₀(_lh_safe_arg1¹) + 1)
//│ 			in and₀₀(
//│ 				let _lh_listcomp_fun⁵ = (fun _lh_listcomp_fun_para⁵ -> case _lh_listcomp_fun_para⁵ of {
//│ 					LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {
//│ 						LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)]
//│ 						| _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)}
//│ 					| LH_N  => [LH_N]})
//│ 				in _lh_listcomp_fun⁵(zip₀₀(enumFromTo₁₀(1, (m¹ - 1)), _lh_safe_arg1¹)))
//│ 			where
//│ 			def and₀₀(_lh_and_arg1¹) = 
//│ 				case _lh_and_arg1¹ of {
//│ 					LH_N  => [True]
//│ 					| LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and₀₀(_lh_and_LH_C_1¹) else [False]
//│ 					| _  => error⁰("match error")}
//│ 			def enumFromTo₁₀(a², b²) = 
//│ 				if (a² <= b²) then [LH_C a² enumFromTo₁₀((a² + 1), b²)] else [LH_N]
//│ 			def length₁₀(ls³) = 
//│ 				case ls³ of {
//│ 					LH_C h³ t³ => (1 + length₁₀(t³))
//│ 					| LH_N  => 0}
//│ 			def zip₀₀(xs¹, ys¹) = 
//│ 				case xs¹ of {
//│ 					LH_C hx¹ tx¹ => case ys¹ of {
//│ 						LH_C hy¹ ty¹ => [LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)]
//│ 						| LH_N  => [LH_N]}
//│ 					| LH_N  => [LH_N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 252 --->
//│ 	case ls³ of {LH_C h³ t³ => (1 + length₁₀(t³)) | LH_N  => 0}: 416
//│ 	case ys¹ of {LH_C hy¹ ty¹ => [LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)] | LH_N  => [LH_N]}: 436
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append₀₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰("match error")}: 453
//│ [LH_N]: 253 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe₀₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)})
//│ in _lh_listcomp_fun⁴(enumFromTo₀₀(1, 9)) | LH_N  => [LH_N]}: 291
//│ 	case ls² of {LH_C h² t² => (1 + length₀₀(t²)) | LH_N  => 0}: 314
//│ [LH_C [LH_N] [LH_N]]: 254 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe₀₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)})
//│ in _lh_listcomp_fun⁴(enumFromTo₀₀(1, 9)) | LH_N  => [LH_N]}: 291
//│ 	case ls² of {LH_C h² t² => (1 + length₀₀(t²)) | LH_N  => 0}: 314
//│ [LH_N]: 266 --->
//│ 	case ls³ of {LH_C h³ t³ => (1 + length₁₀(t³)) | LH_N  => 0}: 416
//│ 	case ys¹ of {LH_C hy¹ ty¹ => [LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)] | LH_N  => [LH_N]}: 436
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append₀₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰("match error")}: 453
//│ [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]: 267 --->
//│ 	case ls³ of {LH_C h³ t³ => (1 + length₁₀(t³)) | LH_N  => 0}: 416
//│ 	case ys¹ of {LH_C hy¹ ty¹ => [LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)] | LH_N  => [LH_N]}: 436
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append₀₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰("match error")}: 453
//│ [LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)]: 272 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe₀₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)})
//│ in _lh_listcomp_fun⁴(enumFromTo₀₀(1, 9)) | LH_N  => [LH_N]}: 291
//│ 	case ls² of {LH_C h² t² => (1 + length₀₀(t²)) | LH_N  => 0}: 314
//│ [LH_N]: 290 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe₀₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)})
//│ in _lh_listcomp_fun⁴(enumFromTo₀₀(1, 9)) | LH_N  => [LH_N]}: 291
//│ 	case ls² of {LH_C h² t² => (1 + length₀₀(t²)) | LH_N  => 0}: 314
//│ [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)]: 366 --->
//│ 	case _lh_and_arg1¹ of {LH_N  => [True] | LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and₀₀(_lh_and_LH_C_1¹) else [False] | _  => error⁰("match error")}: 405
//│ [LH_N]: 371 --->
//│ 	case _lh_and_arg1¹ of {LH_N  => [True] | LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and₀₀(_lh_and_LH_C_1¹) else [False] | _  => error⁰("match error")}: 405
//│ [LH_P2 hx¹ hy¹]: 428 --->
//│ 	case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)}: 370
//│ [LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)]: 434 --->
//│ 	case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 372
//│ [LH_N]: 435 --->
//│ 	case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 372
//│ [LH_N]: 437 --->
//│ 	case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 372
//│ [LH_C _lh_append_LH_C_0¹ append₀₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 449 --->
//│ 	case ls³ of {LH_C h³ t³ => (1 + length₁₀(t³)) | LH_N  => 0}: 416
//│ 	case ys¹ of {LH_C hy¹ ty¹ => [LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)] | LH_N  => [LH_N]}: 436
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append₀₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰("match error")}: 453
//│ [LH_C a² enumFromTo₁₀((a² + 1), b²)]: 471 --->
//│ 	case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 438
//│ [LH_N]: 472 --->
//│ 	case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 438
//│ [LH_C a³ enumFromTo₀₀((a³ + 1), b³)]: 491 --->
//│ 	case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe₀₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)}: 280
//│ [LH_N]: 492 --->
//│ 	case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe₀₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)}: 280
//│ ------------------
//│ case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe₀₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)}: 280 --->
//│ 	[LH_C a³ enumFromTo₀₀((a³ + 1), b³)]: 491
//│ 	[LH_N]: 492
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe₀₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)})
//│ in _lh_listcomp_fun⁴(enumFromTo₀₀(1, 9)) | LH_N  => [LH_N]}: 291 --->
//│ 	[LH_N]: 253
//│ 	[LH_C [LH_N] [LH_N]]: 254
//│ 	[LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)]: 272
//│ 	[LH_N]: 290
//│ case ls² of {LH_C h² t² => (1 + length₀₀(t²)) | LH_N  => 0}: 314 --->
//│ 	[LH_N]: 253
//│ 	[LH_C [LH_N] [LH_N]]: 254
//│ 	[LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)]: 272
//│ 	[LH_N]: 290
//│ case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)}: 370 --->
//│ 	[LH_P2 hx¹ hy¹]: 428
//│ case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 372 --->
//│ 	[LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)]: 434
//│ 	[LH_N]: 435
//│ 	[LH_N]: 437
//│ case _lh_and_arg1¹ of {LH_N  => [True] | LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and₀₀(_lh_and_LH_C_1¹) else [False] | _  => error⁰("match error")}: 405 --->
//│ 	[LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)]: 366
//│ 	[LH_N]: 371
//│ case ls³ of {LH_C h³ t³ => (1 + length₁₀(t³)) | LH_N  => 0}: 416 --->
//│ 	[LH_N]: 252
//│ 	[LH_N]: 266
//│ 	[LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]: 267
//│ 	[LH_C _lh_append_LH_C_0¹ append₀₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 449
//│ case ys¹ of {LH_C hy¹ ty¹ => [LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)] | LH_N  => [LH_N]}: 436 --->
//│ 	[LH_N]: 252
//│ 	[LH_N]: 266
//│ 	[LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]: 267
//│ 	[LH_C _lh_append_LH_C_0¹ append₀₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 449
//│ case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 438 --->
//│ 	[LH_C a² enumFromTo₁₀((a² + 1), b²)]: 471
//│ 	[LH_N]: 472
//│ case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append₀₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰("match error")}: 453 --->
//│ 	[LH_N]: 252
//│ 	[LH_N]: 266
//│ 	[LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]: 267
//│ 	[LH_C _lh_append_LH_C_0¹ append₀₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 449
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)]: 366 --->
//│ 	case _lh_and_arg1¹ of {LH_N  => [True] | LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and₀₀(_lh_and_LH_C_1¹) else [False] | _  => error⁰("match error")}: 405
//│ [LH_N]: 371 --->
//│ 	case _lh_and_arg1¹ of {LH_N  => [True] | LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and₀₀(_lh_and_LH_C_1¹) else [False] | _  => error⁰("match error")}: 405
//│ [LH_P2 hx¹ hy¹]: 428 --->
//│ 	case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)}: 370
//│ [LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)]: 434 --->
//│ 	case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 372
//│ [LH_N]: 435 --->
//│ 	case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 372
//│ [LH_N]: 437 --->
//│ 	case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 372
//│ [LH_C a² enumFromTo₁₀((a² + 1), b²)]: 471 --->
//│ 	case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 438
//│ [LH_N]: 472 --->
//│ 	case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 438
//│ [LH_C a³ enumFromTo₀₀((a³ + 1), b³)]: 491 --->
//│ 	case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe₀₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)}: 280
//│ [LH_N]: 492 --->
//│ 	case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe₀₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)}: 280
//│ ------------------
//│ case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe₀₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append₀₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)}: 280 --->
//│ 	[LH_C a³ enumFromTo₀₀((a³ + 1), b³)]: 491
//│ 	[LH_N]: 492
//│ case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)}: 370 --->
//│ 	[LH_P2 hx¹ hy¹]: 428
//│ case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 372 --->
//│ 	[LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)]: 434
//│ 	[LH_N]: 435
//│ 	[LH_N]: 437
//│ case _lh_and_arg1¹ of {LH_N  => [True] | LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and₀₀(_lh_and_LH_C_1¹) else [False] | _  => error⁰("match error")}: 405 --->
//│ 	[LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)]: 366
//│ 	[LH_N]: 371
//│ case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C [LH_P2 hx¹ hy¹] zip₀₀(tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 438 --->
//│ 	[LH_C a² enumFromTo₁₀((a² + 1), b²)]: 471
//│ 	[LH_N]: 472
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testAnotherQueenNine₀₀(primId⁰(9))
//│ def testAnotherQueenNine₀₀(_lh_testAnotherQueenNine_arg1²) = 
//│ 	length₀₀(queens₀₀(_lh_testAnotherQueenNine_arg1²))
//│ 	where
//│ 	def length₀₀(ls⁴) = 
//│ 		case ls⁴ of {
//│ 			LH_C h² t² => (1 + length₀₀(t²))
//│ 			| LH_N  => 0}
//│ 	def queens₀₀(_lh_queens_arg1²) = 
//│ 		case _lh_queens_arg1² of {
//│ 			0  => [LH_C [LH_N] [LH_N]]
//│ 			| _  => 
//│ 				let _lh_listcomp_fun⁶ = (fun _lh_listcomp_fun_para⁶ -> case _lh_listcomp_fun_para⁶ of {
//│ 					LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => 
//│ 						let _lh_listcomp_fun⁷ = (fun _lh_listcomp_fun_para⁷ -> _lh_listcomp_fun_para⁷(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun⁷, _lh_listcomp_fun⁶, _lh_listcomp_fun_ls_t³))
//│ 						in _lh_listcomp_fun⁷(enumFromTo₀₀(1, 9))
//│ 					| LH_N  => [LH_N]})
//│ 				in _lh_listcomp_fun⁶(queens₀₀((_lh_queens_arg1² - 1)))}
//│ 		where
//│ 		def append₀₀(_lh_append_arg1², _lh_append_arg2²) = 
//│ 			case _lh_append_arg1² of {
//│ 				LH_N  => _lh_append_arg2²
//│ 				| LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append₀₀(_lh_append_LH_C_1¹, _lh_append_arg2²)]
//│ 				| _  => error⁰("match error")}
//│ 		def enumFromTo₀₀(a⁵, b⁵) = 
//│ 			if (a⁵ <= b⁵) then 
//│ 				let _lh_listcomp_fun_ls_h⁷ = a⁵
//│ 				in let _lh_listcomp_fun_ls_t⁸ = enumFromTo₀₀((a⁵ + 1), b⁵)
//│ 				in (fun _lh_listcomp_fun_ls_h⁸ -> (fun _lh_listcomp_fun¹³ -> (fun _lh_listcomp_fun¹⁴ -> (fun _lh_listcomp_fun_ls_t⁹ -> if safe₀₀(_lh_listcomp_fun_ls_h⁸, _lh_listcomp_fun_ls_h⁷) then [LH_C append₀₀(_lh_listcomp_fun_ls_h⁸, [LH_C _lh_listcomp_fun_ls_h⁷ [LH_N]]) _lh_listcomp_fun¹³(_lh_listcomp_fun_ls_t⁸)] else _lh_listcomp_fun¹³(_lh_listcomp_fun_ls_t⁸))))) else (fun _lh_listcomp_fun_ls_h⁹ -> (fun _lh_listcomp_fun¹⁵ -> (fun _lh_listcomp_fun¹⁶ -> (fun _lh_listcomp_fun_ls_t¹⁰ -> _lh_listcomp_fun¹⁶(_lh_listcomp_fun_ls_t¹⁰)))))
//│ 		def safe₀₀(_lh_safe_arg1², _lh_safe_arg2²) = 
//│ 			let m² = (length₁₀(_lh_safe_arg1²) + 1)
//│ 			in and₀₀(
//│ 				let _lh_listcomp_fun⁸ = (fun _lh_listcomp_fun_para⁸ -> _lh_listcomp_fun_para⁸(_lh_safe_arg2², m², _lh_listcomp_fun⁸))
//│ 				in _lh_listcomp_fun⁸(zip₀₀(enumFromTo₁₀(1, (m² - 1)), _lh_safe_arg1²)))
//│ 			where
//│ 			def and₀₀(_lh_and_arg1²) = 
//│ 				_lh_and_arg1²
//│ 			def enumFromTo₁₀(a⁴, b⁴) = 
//│ 				if (a⁴ <= b⁴) then 
//│ 					let hx² = a⁴
//│ 					in let tx² = enumFromTo₁₀((a⁴ + 1), b⁴)
//│ 					in (fun ys³ -> case ys³ of {
//│ 						LH_C hy¹ ty¹ => 
//│ 							let _lh_listcomp_fun_ls_h⁶ = 	
//│ 								let _lh_safe_LH_P2_0² = hx²
//│ 								in let _lh_safe_LH_P2_1² = hy¹
//│ 								in (fun _lh_safe_arg2⁴ -> (fun m⁴ -> (fun _lh_listcomp_fun¹⁰ -> (fun _lh_listcomp_fun_ls_t⁷ -> 
//│ 									let _lh_and_LH_C_0² = (((_lh_safe_LH_P2_1² /= _lh_safe_arg2⁴) && ((_lh_safe_LH_P2_0² + _lh_safe_LH_P2_1²) /= (m⁴ + _lh_safe_arg2⁴))) && ((_lh_safe_LH_P2_0² - _lh_safe_LH_P2_1²) /= (m⁴ - _lh_safe_arg2⁴)))
//│ 									in let _lh_and_LH_C_1² = _lh_listcomp_fun¹⁰(_lh_listcomp_fun_ls_t⁷)
//│ 									in if _lh_and_LH_C_0² then and₀₀(_lh_and_LH_C_1²) else [False]))))
//│ 							in let _lh_listcomp_fun_ls_t⁶ = zip₀₀(tx², ty¹)
//│ 							in (fun _lh_safe_arg2³ -> (fun m³ -> (fun _lh_listcomp_fun⁹ -> _lh_listcomp_fun_ls_h⁶(_lh_safe_arg2³, m³, _lh_listcomp_fun⁹, _lh_listcomp_fun_ls_t⁶))))
//│ 						| LH_N  => (fun _lh_safe_arg2⁵ -> (fun m⁵ -> (fun _lh_listcomp_fun¹¹ -> [True])))}) else (fun ys⁴ -> (fun _lh_safe_arg2⁶ -> (fun m⁶ -> (fun _lh_listcomp_fun¹² -> [True]))))
//│ 			def length₁₀(ls⁵) = 
//│ 				case ls⁵ of {
//│ 					LH_C h³ t³ => (1 + length₁₀(t³))
//│ 					| LH_N  => 0}
//│ 			def zip₀₀(xs², ys²) = 
//│ 				xs²(ys²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<



:lhInHaskell
:lhGenOCaml
sum [] = 0
sum (h:t) = h + (sum t)
testSumMapBuiltInType n = sum $ map (\x -> x * x) (enumFromTo 1 n)
testSumMapBuiltInType $ primId 300000
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumMapBuiltInType₀^256(primId⁰(300000))
//│ def enumFromTo₀(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo₀^242((a² + 1), b²)] else [LH_N]
//│ def map₀(f⁴, ls⁷) = case ls⁷ of {
//│ 	LH_C h⁷ t⁸ => [LH_C f⁴(h⁷) map₀^195(f⁴, t⁸)]
//│ 	| LH_N  => [LH_N]}
//│ def sum₀(_lh_sum_arg1¹) = case _lh_sum_arg1¹ of {
//│ 	LH_N  => 0
//│ 	| LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum₀^227(_lh_sum_LH_C_1¹))
//│ 	| _  => error⁰("match error")}
//│ def testSumMapBuiltInType₀(_lh_testSumMapBuiltInType_arg1¹) = sum₀^205(map₀^206((fun x¹ -> (x¹ * x¹)), enumFromTo₀^214(1, _lh_testSumMapBuiltInType_arg1¹)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_d0 a_2 b_2 =
//│ 		  (if (a_2 <= b_2) then
//│ 		    (a_2::((enumFromTo_d0 (a_2 + 1)) b_2))
//│ 		  else
//│ 		    []);;
//│ 		let rec map_d0 f_4 ls_7 =
//│ 		  (match ls_7 with
//│ 		    | (h_7 :: t_8) -> 
//│ 		      ((f_4 h_7)::((map_d0 f_4) t_8))
//│ 		    | [] -> 
//│ 		      []);;
//│ 		let rec sum_d0 _lh_sum_arg1_1 =
//│ 		  (match _lh_sum_arg1_1 with
//│ 		    | [] -> 
//│ 		      0
//│ 		    | (_lh_sum_LH_C_0_1 :: _lh_sum_LH_C_1_1) -> 
//│ 		      (_lh_sum_LH_C_0_1 + (sum_d0 _lh_sum_LH_C_1_1))
//│ 		    | _ -> 
//│ 		      (failwith "match error"));;
//│ 		let rec testSumMapBuiltInType_d0 _lh_testSumMapBuiltInType_arg1_1 =
//│ 		  (sum_d0 ((map_d0 (fun x_1 -> 
//│ 		    (x_1 * x_1))) ((enumFromTo_d0 1) _lh_testSumMapBuiltInType_arg1_1)));;
//│ 		(testSumMapBuiltInType_d0 300000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testSumMapBuiltInType₀^256] (hopeless to continue)
//│ 	[testSumMapBuiltInType₀^256 · enumFromTo₀^214] (using original def)
//│ 		[testSumMapBuiltInType₀^256 · enumFromTo₀^214 · enumFromTo₀^242] ---> [testSumMapBuiltInType₀^256 · enumFromTo₀^214] (using original def)
//│ 	[testSumMapBuiltInType₀^256 · map₀^206] (using original def)
//│ 		[testSumMapBuiltInType₀^256 · map₀^206 · map₀^195] ---> [testSumMapBuiltInType₀^256 · map₀^206] (using original def)
//│ 	[testSumMapBuiltInType₀^256 · sum₀^205] (using original def)
//│ 		[testSumMapBuiltInType₀^256 · sum₀^205 · sum₀^227] ---> [testSumMapBuiltInType₀^256 · sum₀^205] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testSumMapBuiltInType₀₀(primId⁰(300000))
//│ def testSumMapBuiltInType₀₀(_lh_testSumMapBuiltInType_arg1¹) = 
//│ 	sum₀₀(map₀₀((fun x¹ -> (x¹ * x¹)), enumFromTo₀₀(1, _lh_testSumMapBuiltInType_arg1¹)))
//│ 	where
//│ 	def enumFromTo₀₀(a¹, b¹) = 
//│ 		if (a¹ <= b¹) then [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)] else [LH_N]
//│ 	def map₀₀(f¹, ls¹) = 
//│ 		case ls¹ of {
//│ 			LH_C h¹ t¹ => [LH_C f¹(h¹) map₀₀(f¹, t¹)]
//│ 			| LH_N  => [LH_N]}
//│ 	def sum₀₀(_lh_sum_arg1¹) = 
//│ 		case _lh_sum_arg1¹ of {
//│ 			LH_N  => 0
//│ 			| LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum₀₀(_lh_sum_LH_C_1¹))
//│ 			| _  => error⁰("match error")}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f¹(h¹) map₀₀(f¹, t¹)]: 94 --->
//│ 	case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum₀₀(_lh_sum_LH_C_1¹)) | _  => error⁰("match error")}: 83
//│ [LH_N]: 95 --->
//│ 	case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum₀₀(_lh_sum_LH_C_1¹)) | _  => error⁰("match error")}: 83
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 114 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => [LH_C f¹(h¹) map₀₀(f¹, t¹)] | LH_N  => [LH_N]}: 96
//│ [LH_N]: 115 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => [LH_C f¹(h¹) map₀₀(f¹, t¹)] | LH_N  => [LH_N]}: 96
//│ ------------------
//│ case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum₀₀(_lh_sum_LH_C_1¹)) | _  => error⁰("match error")}: 83 --->
//│ 	[LH_C f¹(h¹) map₀₀(f¹, t¹)]: 94
//│ 	[LH_N]: 95
//│ case ls¹ of {LH_C h¹ t¹ => [LH_C f¹(h¹) map₀₀(f¹, t¹)] | LH_N  => [LH_N]}: 96 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 114
//│ 	[LH_N]: 115
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f¹(h¹) map₀₀(f¹, t¹)]: 94 --->
//│ 	case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum₀₀(_lh_sum_LH_C_1¹)) | _  => error⁰("match error")}: 83
//│ [LH_N]: 95 --->
//│ 	case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum₀₀(_lh_sum_LH_C_1¹)) | _  => error⁰("match error")}: 83
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 114 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => [LH_C f¹(h¹) map₀₀(f¹, t¹)] | LH_N  => [LH_N]}: 96
//│ [LH_N]: 115 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => [LH_C f¹(h¹) map₀₀(f¹, t¹)] | LH_N  => [LH_N]}: 96
//│ ------------------
//│ case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum₀₀(_lh_sum_LH_C_1¹)) | _  => error⁰("match error")}: 83 --->
//│ 	[LH_C f¹(h¹) map₀₀(f¹, t¹)]: 94
//│ 	[LH_N]: 95
//│ case ls¹ of {LH_C h¹ t¹ => [LH_C f¹(h¹) map₀₀(f¹, t¹)] | LH_N  => [LH_N]}: 96 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 114
//│ 	[LH_N]: 115
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumMapBuiltInType₀₀(primId⁰(300000))
//│ def testSumMapBuiltInType₀₀(_lh_testSumMapBuiltInType_arg1²) = 
//│ 	sum₀₀(map₀₀((fun x² -> (x² * x²)), enumFromTo₀₀(1, _lh_testSumMapBuiltInType_arg1²)))
//│ 	where
//│ 	def enumFromTo₀₀(a², b²) = 
//│ 		if (a² <= b²) then 
//│ 			let h² = a²
//│ 			in let t² = enumFromTo₀₀((a² + 1), b²)
//│ 			in (fun f³ -> 
//│ 				let _lh_sum_LH_C_0² = f³(h²)
//│ 				in let _lh_sum_LH_C_1² = map₀₀(f³, t²)
//│ 				in (_lh_sum_LH_C_0² + sum₀₀(_lh_sum_LH_C_1²))) else (fun f⁴ -> 0)
//│ 	def map₀₀(f², ls²) = 
//│ 		ls²(f²)
//│ 	def sum₀₀(_lh_sum_arg1²) = 
//│ 		_lh_sum_arg1²
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun genTree(n, i) = if n <= 0 then N(i) else T(genTree(n - 1, i), genTree(n - 1, i + 1))
fun flip(t) = if t is
  T(l, r) then T(flip(r), flip(l))
  N(v) then N(v)
fun ff(t) = flip(flip(t))
fun testFlipFlip(t) = ff(t)
testFlipFlip(primId(genTree(17, 0)))
//│ |#fun| |genTree|(|n|,| |i|)| |#=| |#if| |n| |<=| |0| |#then| |N|(|i|)| |#else| |T|(|genTree|(|n| |-| |1|,| |i|)|,| |genTree|(|n| |-| |1|,| |i| |+| |1|)|)|↵|#fun| |flip|(|t|)| |#=| |#if| |t| |is|→|T|(|l|,| |r|)| |#then| |T|(|flip|(|r|)|,| |flip|(|l|)|)|↵|N|(|v|)| |#then| |N|(|v|)|←|↵|#fun| |ff|(|t|)| |#=| |flip|(|flip|(|t|)|)|↵|#fun| |testFlipFlip|(|t|)| |#=| |ff|(|t|)|↵|testFlipFlip|(|primId|(|genTree|(|17|,| |0|)|)|)|
//│ Parsed: {fun genTree = n, i, => if (<= (n,) (0,)) then N (i,) else T (genTree (- (n,) (1,), i,), genTree (- (n,) (1,), + (i,) (1,),),); fun flip = t, => if t is ‹(T (l, r,)) then T (flip (r,), flip (l,),); (N (v,)) then N (v,)›; fun ff = t, => flip (flip (t,),); fun testFlipFlip = t, => ff (t,); testFlipFlip (primId (genTree (17, 0,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testFlipFlip^56(primId⁰(genTree^58(17, 0)))
//│ def ff(t¹) = flip^46(flip^47(t¹))
//│ def flip(t⁰) = case t⁰ of {
//│ 	T l⁰ r⁰ => [T flip^35(r⁰) flip^38(l⁰)]
//│ 	| N v⁰ => [N v⁰]}
//│ def genTree(n⁰, i⁰) = if (n⁰ <= 0) then [N i⁰] else [T genTree^8((n⁰ - 1), i⁰) genTree^17((n⁰ - 1), (i⁰ + 1))]
//│ def testFlipFlip(t²) = ff^52(t²)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec flip t_0 =
//│ 		  (match t_0 with
//│ 		    | `T(l_0, r_0) -> 
//│ 		      (`T((flip r_0), (flip l_0)))
//│ 		    | `N(v_0) -> 
//│ 		      (`N(v_0)));;
//│ 		let rec genTree n_0 i_0 =
//│ 		  (if (n_0 <= 0) then
//│ 		    (`N(i_0))
//│ 		  else
//│ 		    (`T(((genTree (n_0 - 1)) i_0), ((genTree (n_0 - 1)) (i_0 + 1)))));;
//│ 		let rec ff t_1 =
//│ 		  (flip (flip t_1))
//│ 		and testFlipFlip t_2 =
//│ 		  (ff t_2);;
//│ 		(testFlipFlip ((genTree 17) 0))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [genTree^58]
//│ 	[genTree^58 · genTree^17] ---> [genTree^58] (only one)
//│ 	[genTree^58 · genTree^8] ---> [genTree^58] (only one)
//│ [testFlipFlip^56]
//│ 	[testFlipFlip^56 · ff^52]
//│ 		[testFlipFlip^56 · ff^52 · flip^46]
//│ 			[testFlipFlip^56 · ff^52 · flip^46 · flip^35] ---> [testFlipFlip^56 · ff^52 · flip^46] (only one)
//│ 			[testFlipFlip^56 · ff^52 · flip^46 · flip^38] ---> [testFlipFlip^56 · ff^52 · flip^46] (only one)
//│ 		[testFlipFlip^56 · ff^52 · flip^47]
//│ 			[testFlipFlip^56 · ff^52 · flip^47 · flip^35] ---> [testFlipFlip^56 · ff^52 · flip^47] (only one)
//│ 			[testFlipFlip^56 · ff^52 · flip^47 · flip^38] ---> [testFlipFlip^56 · ff^52 · flip^47] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testFlipFlip₀(primId⁰(genTree₀(17, 0)))
//│ def genTree₀(n¹, i¹) = 
//│ 	if (n¹ <= 0) then [N i¹] else [T genTree₀((n¹ - 1), i¹) genTree₀((n¹ - 1), (i¹ + 1))]
//│ def testFlipFlip₀(t⁶) = 
//│ 	ff₀(t⁶)
//│ 	where
//│ 	def ff₀(t⁴) = 
//│ 		flip₀(flip₁(t⁴))
//│ 		where
//│ 		def flip₀(t³) = 
//│ 			case t³ of {
//│ 				T l¹ r¹ => [T flip₀(r¹) flip₀(l¹)]
//│ 				| N v¹ => [N v¹]}
//│ 		def flip₁(t⁵) = 
//│ 			case t⁵ of {
//│ 				T l² r² => [T flip₁(r²) flip₁(l²)]
//│ 				| N v² => [N v²]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [T flip₁(r²) flip₁(l²)]: 123 --->
//│ 	case t³ of {T l¹ r¹ => [T flip₀(r¹) flip₀(l¹)] | N v¹ => [N v¹]}: 75
//│ [N v²]: 125 --->
//│ 	case t³ of {T l¹ r¹ => [T flip₀(r¹) flip₀(l¹)] | N v¹ => [N v¹]}: 75
//│ ------------------
//│ case t³ of {T l¹ r¹ => [T flip₀(r¹) flip₀(l¹)] | N v¹ => [N v¹]}: 75 --->
//│ 	[T flip₁(r²) flip₁(l²)]: 123
//│ 	[N v²]: 125
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [T flip₁(r²) flip₁(l²)]: 123 --->
//│ 	case t³ of {T l¹ r¹ => [T flip₀(r¹) flip₀(l¹)] | N v¹ => [N v¹]}: 75
//│ [N v²]: 125 --->
//│ 	case t³ of {T l¹ r¹ => [T flip₀(r¹) flip₀(l¹)] | N v¹ => [N v¹]}: 75
//│ ------------------
//│ case t³ of {T l¹ r¹ => [T flip₀(r¹) flip₀(l¹)] | N v¹ => [N v¹]}: 75 --->
//│ 	[T flip₁(r²) flip₁(l²)]: 123
//│ 	[N v²]: 125
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testFlipFlip₀(primId⁰(genTree₀(17, 0)))
//│ def genTree₀(n², i²) = 
//│ 	if (n² <= 0) then [N i²] else [T genTree₀((n² - 1), i²) genTree₀((n² - 1), (i² + 1))]
//│ def testFlipFlip₀(t¹⁰) = 
//│ 	ff₀(t¹⁰)
//│ 	where
//│ 	def ff₀(t⁷) = 
//│ 		flip₀(flip₁(t⁷))
//│ 		where
//│ 		def flip₀(t⁹) = 
//│ 			t⁹
//│ 		def flip₁(t⁸) = 
//│ 			case t⁸ of {
//│ 				T l² r² => 
//│ 					let l³ = flip₁(r²)
//│ 					in let r³ = flip₁(l²)
//│ 					in [T flip₀(r³) flip₀(l³)]
//│ 				| N v² => 
//│ 					let v³ = v²
//│ 					in [N v³]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun foldl(f, s, ls) = if ls is
  C(h, t) then foldl(f, f(s, h), t)
  N then s
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun testFoldMap(n) = foldl(
  i => x => i + x,
  0,
  map(x => x * x, primId(enumFromTo(1, n)))
)
testFoldMap(primId(300000))
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |foldl|(|f|,| |s|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |foldl|(|f|,| |f|(|s|,| |h|)|,| |t|)|↵|N| |#then| |s|←|↵|#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |testFoldMap|(|n|)| |#=| |foldl|(|→|i| |=>| |x| |=>| |i| |+| |x|,|↵|0|,|↵|map|(|x| |=>| |x| |*| |x|,| |primId|(|enumFromTo|(|1|,| |n|)|)|)|←|↵|)|↵|testFoldMap|(|primId|(|300000|)|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun foldl = f, s, ls, => if ls is ‹(C (h, t,)) then foldl (f, f (s, h,), t,); (N) then s›; fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun testFoldMap = n, => foldl (i, => x, => + (i,) (x,), 0, map (x, => * (x,) (x,), primId (enumFromTo (1, n,),),),); testFoldMap (primId (300000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testFoldMap^81(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^38((a⁰ + 1), b⁰)] else [N]
//│ def foldl(f¹, s⁰, ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => foldl^16(f¹, f¹(s⁰, h¹), t¹)
//│ 	| N  => s⁰}
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def testFoldMap(n⁰) = foldl^52((fun i⁰ -> (fun x⁰ -> (i⁰ + x⁰))), 0, map^63((fun x¹ -> (x¹ * x¹)), primId⁰(enumFromTo^72(1, n⁰))))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec foldl f_1 s_0 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (((foldl f_1) ((f_1 s_0) h_1)) t_1)
//│ 		    | `N -> 
//│ 		      s_0);;
//│ 		let rec map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec testFoldMap n_0 =
//│ 		  (((foldl (fun i_0 x_0 -> 
//│ 		    (i_0 + x_0))) 0) ((map (fun x_1 -> 
//│ 		    (x_1 * x_1))) ((enumFromTo 1) n_0)));;
//│ 		(testFoldMap 300000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testFoldMap^81] (hopeless to continue)
//│ 	[testFoldMap^81 · enumFromTo^72] (using original def)
//│ 		[testFoldMap^81 · enumFromTo^72 · enumFromTo^38] ---> [testFoldMap^81 · enumFromTo^72] (using original def)
//│ 	[testFoldMap^81 · foldl^52] (using original def)
//│ 		[testFoldMap^81 · foldl^52 · foldl^16] ---> [testFoldMap^81 · foldl^52] (using original def)
//│ 	[testFoldMap^81 · map^63] (using original def)
//│ 		[testFoldMap^81 · map^63 · map^5] ---> [testFoldMap^81 · map^63] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testFoldMap₀(primId⁰(300000))
//│ def testFoldMap₀(n¹) = 
//│ 	foldl₀((fun i¹ -> (fun x² -> (i¹ + x²))), 0, map₀((fun x³ -> (x³ * x³)), primId⁰(enumFromTo₀(1, n¹))))
//│ 	where
//│ 	def enumFromTo₀(a¹, b¹) = 
//│ 		if (a¹ <= b¹) then [C a¹ enumFromTo₀((a¹ + 1), b¹)] else [N]
//│ 	def foldl₀(f², s¹, ls²) = 
//│ 		case ls² of {
//│ 			C h² t² => foldl₀(f², f²(s¹, h²), t²)
//│ 			| N  => s¹}
//│ 	def map₀(f³, ls³) = 
//│ 		case ls³ of {
//│ 			C h³ t³ => [C f³(h³) map₀(f³, t³)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f³(h³) map₀(f³, t³)]: 112 --->
//│ 	case ls² of {C h² t² => foldl₀(f², f²(s¹, h²), t²) | N  => s¹}: 99
//│ [N]: 113 --->
//│ 	case ls² of {C h² t² => foldl₀(f², f²(s¹, h²), t²) | N  => s¹}: 99
//│ ------------------
//│ case ls² of {C h² t² => foldl₀(f², f²(s¹, h²), t²) | N  => s¹}: 99 --->
//│ 	[C f³(h³) map₀(f³, t³)]: 112
//│ 	[N]: 113
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f³(h³) map₀(f³, t³)]: 112 --->
//│ 	case ls² of {C h² t² => foldl₀(f², f²(s¹, h²), t²) | N  => s¹}: 99
//│ [N]: 113 --->
//│ 	case ls² of {C h² t² => foldl₀(f², f²(s¹, h²), t²) | N  => s¹}: 99
//│ ------------------
//│ case ls² of {C h² t² => foldl₀(f², f²(s¹, h²), t²) | N  => s¹}: 99 --->
//│ 	[C f³(h³) map₀(f³, t³)]: 112
//│ 	[N]: 113
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testFoldMap₀(primId⁰(300000))
//│ def testFoldMap₀(n²) = 
//│ 	foldl₀((fun i² -> (fun x⁴ -> (i² + x⁴))), 0, map₀((fun x⁵ -> (x⁵ * x⁵)), primId⁰(enumFromTo₀(1, n²))))
//│ 	where
//│ 	def enumFromTo₀(a², b²) = 
//│ 		if (a² <= b²) then [C a² enumFromTo₀((a² + 1), b²)] else [N]
//│ 	def foldl₀(f⁴, s², ls⁴) = 
//│ 		ls⁴(s², f⁴)
//│ 	def map₀(f⁵, ls⁵) = 
//│ 		case ls⁵ of {
//│ 			C h³ t³ => 
//│ 				let h⁴ = f⁵(h³)
//│ 				in let t⁴ = map₀(f⁵, t³)
//│ 				in (fun s³ -> (fun f⁶ -> foldl₀(f⁶, f⁶(s³, h⁴), t⁴)))
//│ 			| N  => (fun s⁴ -> (fun f⁷ -> s⁴))}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun map(f, xs) = if xs is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun qrev(a, ys) = if ys is
  C(h, t) then qrev(C(h, a), t)
  N then a
fun testMapQrev(ls) = map(x => x + 1, qrev(N, ls))
testMapQrev(primId(enumFromTo(1, 10000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |map|(|f|,| |xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |qrev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |qrev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |testMapQrev|(|ls|)| |#=| |map|(|x| |=>| |x| |+| |1|,| |qrev|(|N|,| |ls|)|)|↵|testMapQrev|(|primId|(|enumFromTo|(|1|,| |10000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun map = f, xs, => if xs is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun qrev = a, ys, => if ys is ‹(C (h, t,)) then qrev (C (h, a,), t,); (N) then a›; fun testMapQrev = ls, => map (x, => + (x,) (1,), qrev (N, ls,),); testMapQrev (primId (enumFromTo (1, 10000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapQrev^62(primId⁰(enumFromTo^64(1, 10000)))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^25(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def qrev(a¹, ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => qrev^36([C h¹ a¹], t¹)
//│ 	| N  => a¹}
//│ def testMapQrev(ls⁰) = map^47((fun x⁰ -> (x⁰ + 1)), qrev^55([N], ls⁰))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec map f_0 xs_0 =
//│ 		  (match xs_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec qrev a_1 ys_0 =
//│ 		  (match ys_0 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      ((qrev (`C(h_1, a_1))) t_1)
//│ 		    | `N -> 
//│ 		      a_1);;
//│ 		let rec testMapQrev ls_0 =
//│ 		  ((map (fun x_0 -> 
//│ 		    (x_0 + 1))) ((qrev (`N)) ls_0));;
//│ 		(testMapQrev ((enumFromTo 1) 10000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo^64]
//│ 	[enumFromTo^64 · enumFromTo^7] ---> [enumFromTo^64] (only one)
//│ [testMapQrev^62]
//│ 	[testMapQrev^62 · map^47]
//│ 		[testMapQrev^62 · map^47 · map^25] ---> [testMapQrev^62 · map^47] (only one)
//│ 	[testMapQrev^62 · qrev^55]
//│ 		[testMapQrev^62 · qrev^55 · qrev^36] ---> [testMapQrev^62 · qrev^55] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testMapQrev₀(primId⁰(enumFromTo₀(1, 10000)))
//│ def enumFromTo₀(a², b¹) = 
//│ 	if (a² <= b¹) then [C a² enumFromTo₀((a² + 1), b¹)] else [N]
//│ def testMapQrev₀(ls¹) = 
//│ 	map₀((fun x¹ -> (x¹ + 1)), qrev₀([N], ls¹))
//│ 	where
//│ 	def map₀(f¹, xs¹) = 
//│ 		case xs¹ of {
//│ 			C h³ t³ => [C f¹(h³) map₀(f¹, t³)]
//│ 			| N  => [N]}
//│ 	def qrev₀(a³, ys¹) = 
//│ 		case ys¹ of {
//│ 			C h² t² => qrev₀([C h² a³], t²)
//│ 			| N  => a³}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 80 --->
//│ 	case xs¹ of {C h³ t³ => [C f¹(h³) map₀(f¹, t³)] | N  => [N]}: 129
//│ [C h² a³]: 110 --->
//│ 	case xs¹ of {C h³ t³ => [C f¹(h³) map₀(f¹, t³)] | N  => [N]}: 129
//│ ------------------
//│ case xs¹ of {C h³ t³ => [C f¹(h³) map₀(f¹, t³)] | N  => [N]}: 129 --->
//│ 	[N]: 80
//│ 	[C h² a³]: 110
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 80 --->
//│ 	case xs¹ of {C h³ t³ => [C f¹(h³) map₀(f¹, t³)] | N  => [N]}: 129
//│ [C h² a³]: 110 --->
//│ 	case xs¹ of {C h³ t³ => [C f¹(h³) map₀(f¹, t³)] | N  => [N]}: 129
//│ ------------------
//│ case xs¹ of {C h³ t³ => [C f¹(h³) map₀(f¹, t³)] | N  => [N]}: 129 --->
//│ 	[N]: 80
//│ 	[C h² a³]: 110
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapQrev₀(primId⁰(enumFromTo₀(1, 10000)))
//│ def enumFromTo₀(a⁴, b²) = 
//│ 	if (a⁴ <= b²) then [C a⁴ enumFromTo₀((a⁴ + 1), b²)] else [N]
//│ def testMapQrev₀(ls²) = 
//│ 	map₀((fun x² -> (x² + 1)), qrev₀((fun f² -> [N]), ls²))
//│ 	where
//│ 	def map₀(f⁴, xs²) = 
//│ 		xs²(f⁴)
//│ 	def qrev₀(a⁵, ys²) = 
//│ 		case ys² of {
//│ 			C h² t² => qrev₀(
//│ 				let h⁴ = h²
//│ 				in let t⁴ = a⁵
//│ 				in (fun f³ -> [C f³(h⁴) map₀(f³, t⁴)]), t²)
//│ 			| N  => a⁵}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun map(f, xs) = if xs is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun qrev(a, ys) = if ys is
  C(h, t) then qrev(C(h, a), t)
  N then a
fun _lhManualQrevMap(f, xs, a) = if xs is
  C(h, t) then _lhManualQrevMap(f, t, C(f(h), a))
  N then a
fun testQrevMap(ls) = qrev(N, map(x => x + 1, ls))
fun testManual(ls) = _lhManualQrevMap(x => x + 1, ls, N)
testQrevMap(primId(enumFromTo(1, 10000)))
testManual(primId(enumFromTo(1, 10000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |map|(|f|,| |xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |qrev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |qrev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |_lhManualQrevMap|(|f|,| |xs|,| |a|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |_lhManualQrevMap|(|f|,| |t|,| |C|(|f|(|h|)|,| |a|)|)|↵|N| |#then| |a|←|↵|#fun| |testQrevMap|(|ls|)| |#=| |qrev|(|N|,| |map|(|x| |=>| |x| |+| |1|,| |ls|)|)|↵|#fun| |testManual|(|ls|)| |#=| |_lhManualQrevMap|(|x| |=>| |x| |+| |1|,| |ls|,| |N|)|↵|testQrevMap|(|primId|(|enumFromTo|(|1|,| |10000|)|)|)|↵|testManual|(|primId|(|enumFromTo|(|1|,| |10000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun map = f, xs, => if xs is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun qrev = a, ys, => if ys is ‹(C (h, t,)) then qrev (C (h, a,), t,); (N) then a›; fun _lhManualQrevMap = f, xs, a, => if xs is ‹(C (h, t,)) then _lhManualQrevMap (f, t, C (f (h,), a,),); (N) then a›; fun testQrevMap = ls, => qrev (N, map (x, => + (x,) (1,), ls,),); fun testManual = ls, => _lhManualQrevMap (x, => + (x,) (1,), ls, N,); testQrevMap (primId (enumFromTo (1, 10000,),),); testManual (primId (enumFromTo (1, 10000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testQrevMap^92(primId⁰(enumFromTo^94(1, 10000)))
//│ testManual^101(primId⁰(enumFromTo^103(1, 10000)))
//│ def _lhManualQrevMap(f¹, xs¹, a²) = case xs¹ of {
//│ 	C h² t² => _lhManualQrevMap^48(f¹, t², [C f¹(h²) a²])
//│ 	| N  => a²}
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^25(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def qrev(a¹, ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => qrev^36([C h¹ a¹], t¹)
//│ 	| N  => a¹}
//│ def testManual(ls¹) = _lhManualQrevMap^79((fun x¹ -> (x¹ + 1)), ls¹, [N])
//│ def testQrevMap(ls⁰) = qrev^64([N], map^67((fun x⁰ -> (x⁰ + 1)), ls⁰))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec _lhManualQrevMap f_1 xs_1 a_2 =
//│ 		  (match xs_1 with
//│ 		    | `C(h_2, t_2) -> 
//│ 		      (((_lhManualQrevMap f_1) t_2) (`C((f_1 h_2), a_2)))
//│ 		    | `N -> 
//│ 		      a_2);;
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec map f_0 xs_0 =
//│ 		  (match xs_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec qrev a_1 ys_0 =
//│ 		  (match ys_0 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      ((qrev (`C(h_1, a_1))) t_1)
//│ 		    | `N -> 
//│ 		      a_1);;
//│ 		let rec testManual ls_1 =
//│ 		  (((_lhManualQrevMap (fun x_1 -> 
//│ 		    (x_1 + 1))) ls_1) (`N))
//│ 		and testQrevMap ls_0 =
//│ 		  ((qrev (`N)) ((map (fun x_0 -> 
//│ 		    (x_0 + 1))) ls_0));;
//│ 		(testQrevMap ((enumFromTo 1) 10000))
//│ 		(testManual ((enumFromTo 1) 10000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo^103]
//│ 	[enumFromTo^103 · enumFromTo^7] ---> [enumFromTo^103] (only one)
//│ [enumFromTo^94] (hopeless to continue)
//│ 	[enumFromTo^94 · enumFromTo^7] ---> [enumFromTo^94] (using original def)
//│ [testManual^101]
//│ 	[testManual^101 · _lhManualQrevMap^79]
//│ 		[testManual^101 · _lhManualQrevMap^79 · _lhManualQrevMap^48] ---> [testManual^101 · _lhManualQrevMap^79] (only one)
//│ [testQrevMap^92]
//│ 	[testQrevMap^92 · map^67]
//│ 		[testQrevMap^92 · map^67 · map^25] ---> [testQrevMap^92 · map^67] (only one)
//│ 	[testQrevMap^92 · qrev^64] (hopeless to continue)
//│ 		[testQrevMap^92 · qrev^64 · qrev^36] ---> [testQrevMap^92 · qrev^64] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testQrevMap₀(primId⁰(enumFromTo₁(1, 10000)))
//│ testManual₀(primId⁰(enumFromTo₀(1, 10000)))
//│ def enumFromTo₀(a⁴, b¹) = 
//│ 	if (a⁴ <= b¹) then [C a⁴ enumFromTo₀((a⁴ + 1), b¹)] else [N]
//│ def enumFromTo₁(a⁵, b²) = 
//│ 	if (a⁵ <= b²) then [C a⁵ enumFromTo₁((a⁵ + 1), b²)] else [N]
//│ def testManual₀(ls²) = 
//│ 	_lhManualQrevMap₀((fun x² -> (x² + 1)), ls², [N])
//│ 	where
//│ 	def _lhManualQrevMap₀(f³, xs³, a⁶) = 
//│ 		case xs³ of {
//│ 			C h⁵ t⁵ => _lhManualQrevMap₀(f³, t⁵, [C f³(h⁵) a⁶])
//│ 			| N  => a⁶}
//│ def testQrevMap₀(ls³) = 
//│ 	qrev₀([N], map₀((fun x³ -> (x³ + 1)), ls³))
//│ 	where
//│ 	def map₀(f², xs²) = 
//│ 		case xs² of {
//│ 			C h⁴ t⁴ => [C f²(h⁴) map₀(f², t⁴)]
//│ 			| N  => [N]}
//│ 	def qrev₀(a³, ys¹) = 
//│ 		case ys¹ of {
//│ 			C h³ t³ => qrev₀([C h³ a³], t³)
//│ 			| N  => a³}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f²(h⁴) map₀(f², t⁴)]: 164 --->
//│ 	case ys¹ of {C h³ t³ => qrev₀([C h³ a³], t³) | N  => a³}: 119
//│ [N]: 165 --->
//│ 	case ys¹ of {C h³ t³ => qrev₀([C h³ a³], t³) | N  => a³}: 119
//│ ------------------
//│ case ys¹ of {C h³ t³ => qrev₀([C h³ a³], t³) | N  => a³}: 119 --->
//│ 	[C f²(h⁴) map₀(f², t⁴)]: 164
//│ 	[N]: 165
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f²(h⁴) map₀(f², t⁴)]: 164 --->
//│ 	case ys¹ of {C h³ t³ => qrev₀([C h³ a³], t³) | N  => a³}: 119
//│ [N]: 165 --->
//│ 	case ys¹ of {C h³ t³ => qrev₀([C h³ a³], t³) | N  => a³}: 119
//│ ------------------
//│ case ys¹ of {C h³ t³ => qrev₀([C h³ a³], t³) | N  => a³}: 119 --->
//│ 	[C f²(h⁴) map₀(f², t⁴)]: 164
//│ 	[N]: 165
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testQrevMap₀(primId⁰(enumFromTo₁(1, 10000)))
//│ testManual₀(primId⁰(enumFromTo₀(1, 10000)))
//│ def enumFromTo₀(a¹², b⁴) = 
//│ 	if (a¹² <= b⁴) then [C a¹² enumFromTo₀((a¹² + 1), b⁴)] else [N]
//│ def enumFromTo₁(a⁹, b³) = 
//│ 	if (a⁹ <= b³) then [C a⁹ enumFromTo₁((a⁹ + 1), b³)] else [N]
//│ def testManual₀(ls⁵) = 
//│ 	_lhManualQrevMap₀((fun x⁵ -> (x⁵ + 1)), ls⁵, [N])
//│ 	where
//│ 	def _lhManualQrevMap₀(f⁴, xs⁴, a⁷) = 
//│ 		case xs⁴ of {
//│ 			C h⁵ t⁵ => _lhManualQrevMap₀(f⁴, t⁵, [C f⁴(h⁵) a⁷])
//│ 			| N  => a⁷}
//│ def testQrevMap₀(ls⁴) = 
//│ 	qrev₀([N], map₀((fun x⁴ -> (x⁴ + 1)), ls⁴))
//│ 	where
//│ 	def map₀(f⁵, xs⁵) = 
//│ 		case xs⁵ of {
//│ 			C h⁴ t⁴ => 
//│ 				let h⁶ = f⁵(h⁴)
//│ 				in let t⁶ = map₀(f⁵, t⁴)
//│ 				in (fun a¹⁰ -> qrev₀([C h⁶ a¹⁰], t⁶))
//│ 			| N  => (fun a¹¹ -> a¹¹)}
//│ 	def qrev₀(a⁸, ys²) = 
//│ 		ys²(a⁸)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
