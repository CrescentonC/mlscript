:NewParser
:ParseOnly

:lhError
:lhInOCaml
let rec a = 4;;
let rec f = function A -> B | C -> D;;
let rec d a b = match a with
  | `A(s, d) -> `D
  | _ -> `S
  | k -> `D;;
let rec f (h:t) = h;;
let val = [false;true;false];;
f val
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ "compilation_unit" (
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"=" ()
//│ 			"number" ()))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"=" ()
//│ 			"function_expression" (
//│ 				"function" ()
//│ 				"match_case" (
//│ 					"constructor_path" (
//│ 						"constructor_name" ())
//│ 					"->" ()
//│ 					"constructor_path" (
//│ 						"constructor_name" ()))
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"constructor_path" (
//│ 						"constructor_name" ())
//│ 					"->" ()
//│ 					"constructor_path" (
//│ 						"constructor_name" ())))))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"parameter" (
//│ 				"value_pattern" ())
//│ 			"parameter" (
//│ 				"value_pattern" ())
//│ 			"=" ()
//│ 			"match_expression" (
//│ 				"match" ()
//│ 				"value_path" (
//│ 					"value_name" ())
//│ 				"with" ()
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"tag_pattern" (
//│ 						"tag" (
//│ 							"`" ())
//│ 						"parenthesized_pattern" (
//│ 							"(" ()
//│ 							"tuple_pattern" (
//│ 								"value_pattern" ()
//│ 								"," ()
//│ 								"value_pattern" ())
//│ 							")" ()))
//│ 					"->" ()
//│ 					"tag" (
//│ 						"`" ()))
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"value_pattern" ()
//│ 					"->" ()
//│ 					"tag" (
//│ 						"`" ()))
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"value_pattern" ()
//│ 					"->" ()
//│ 					"tag" (
//│ 						"`" ())))))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"parameter" (
//│ 				"typed_pattern" (
//│ 					"(" ()
//│ 					"value_pattern" ()
//│ 					":" ()
//│ 					"type_constructor_path" (
//│ 						"type_constructor" ())
//│ 					")" ()))
//│ 			"=" ()
//│ 			"value_path" (
//│ 				"value_name" ())))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"=" ()
//│ 			"list_expression" (
//│ 				"[" ()
//│ 				"boolean" (
//│ 					"false" ())
//│ 				";" ()
//│ 				"boolean" (
//│ 					"true" ())
//│ 				";" ()
//│ 				"boolean" (
//│ 					"false" ())
//│ 				"]" ())))
//│ 	";;" ()
//│ 	"expression_item" (
//│ 		"application_expression" (
//│ 			"value_path" (
//│ 				"value_name" ())
//│ 			"value_path" (
//│ 				"value_name" ()))))
//│ !!!!!!ERROR!!!!!!
//│ scala.NotImplementedError: an implementation is missing
//│ !!!!!!ERROR!!!!!!



:lhInHaskell
:lhGenOCaml
[x | x <- [1,2]]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 	LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]
//│ 	| LH_N  => [LH_N]})
//│ in _lh_listcomp_fun¹([LH_C 1 [LH_C 2 [LH_N]]])
//│ 		---------- unoptimized ocaml gen ----------
//│ 		(let rec _lh_listcomp_fun_1 = (fun _lh_listcomp_fun_para_1 -> 
//│ 		  (match _lh_listcomp_fun_para_1 with
//│ 		    | `LH_C(_lh_listcomp_fun_ls_h_1, _lh_listcomp_fun_ls_t_1) -> 
//│ 		      (`LH_C(_lh_listcomp_fun_ls_h_1, (_lh_listcomp_fun_1 _lh_listcomp_fun_ls_t_1)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))) in
//│ 		  (_lh_listcomp_fun_1 (`LH_C(1, (`LH_C(2, (`LH_N)))))))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ 
//│ 	let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 		LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun¹([LH_C 1 [LH_C 2 [LH_N]]])
//│ 
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 30 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ [LH_C 2 [LH_N]]: 31 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ [LH_C 1 [LH_C 2 [LH_N]]]: 32 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ ------------------
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25 --->
//│ 	[LH_N]: 30
//│ 	[LH_C 2 [LH_N]]: 31
//│ 	[LH_C 1 [LH_C 2 [LH_N]]]: 32
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_N]: 30 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ [LH_C 2 [LH_N]]: 31 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ [LH_C 1 [LH_C 2 [LH_N]]]: 32 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25
//│ ------------------
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => [LH_N]}: 25 --->
//│ 	[LH_N]: 30
//│ 	[LH_C 2 [LH_N]]: 31
//│ 	[LH_C 1 [LH_C 2 [LH_N]]]: 32
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> _lh_listcomp_fun_para²(_lh_listcomp_fun²))
//│ 	in _lh_listcomp_fun²(
//│ 		let _lh_listcomp_fun_ls_h² = 1
//│ 		in let _lh_listcomp_fun_ls_t² = 	
//│ 			let _lh_listcomp_fun_ls_h³ = 2
//│ 			in let _lh_listcomp_fun_ls_t³ = (fun _lh_listcomp_fun⁵ -> [LH_N])
//│ 			in (fun _lh_listcomp_fun⁴ -> [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t³)])
//│ 		in (fun _lh_listcomp_fun³ -> [LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun³(_lh_listcomp_fun_ls_t²)]))
//│ 
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ (let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│   (_lh_listcomp_fun_para_0 _lh_listcomp_fun_0)) in
//│   (_lh_listcomp_fun_0 (let rec _lh_listcomp_fun_ls_h_0 = 1 in
//│     (let rec _lh_listcomp_fun_ls_t_0 = (let rec _lh_listcomp_fun_ls_h_1 = 2 in
//│       (let rec _lh_listcomp_fun_ls_t_1 = (fun _lh_listcomp_fun_1 -> 
//│         (`LH_N)) in
//│         (fun _lh_listcomp_fun_2 -> 
//│           (`LH_C(_lh_listcomp_fun_ls_h_1, (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_1)))))) in
//│       (fun _lh_listcomp_fun_3 -> 
//│         (`LH_C(_lh_listcomp_fun_ls_h_0, (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_0))))))))
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhInHaskell
:lhGenOCaml
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = [ (q:b) | b <- gen (n-1) nq, q <- [1..nq], safe q 1 b ]
nsoln nq = length (gen nq nq)
nsoln 10
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ nsoln₀^862(10)
//│ def enumFromTo₀(a⁵, b²) = if (a⁵ <= b²) then [LH_C a⁵ enumFromTo₀^848((a⁵ + 1), b²)] else [LH_N]
//│ def gen₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 			LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 				let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 					LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀^724(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 					| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 				in _lh_listcomp_fun³(enumFromTo₀^748(1, _lh_gen_arg2¹))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun²(gen₀^759((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length₀(ls¹⁹) = case ls¹⁹ of {
//│ 	LH_C h²⁰ t²² => (1 + length₀^835(t²²))
//│ 	| LH_N  => 0}
//│ def nsoln₀(_lh_nsoln_arg1¹) = length₀^773(gen₀^774(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀^814(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))
//│ 	| _  => error⁰}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_d0 a_5 b_2 =
//│ 		  (if (a_5 <= b_2) then
//│ 		    (`LH_C(a_5, ((enumFromTo_d0 (a_5 + 1)) b_2)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and gen_d0 _lh_gen_arg1_1 _lh_gen_arg2_1 =
//│ 		  (match _lh_gen_arg1_1 with
//│ 		    | 0 -> 
//│ 		      (`LH_C((`LH_N), (`LH_N)))
//│ 		    | _ -> 
//│ 		      (let rec _lh_listcomp_fun_2 = (fun _lh_listcomp_fun_para_2 -> 
//│ 		        (match _lh_listcomp_fun_para_2 with
//│ 		          | `LH_C(_lh_listcomp_fun_ls_h_2, _lh_listcomp_fun_ls_t_2) -> 
//│ 		            (let rec _lh_listcomp_fun_3 = (fun _lh_listcomp_fun_para_3 -> 
//│ 		              (match _lh_listcomp_fun_para_3 with
//│ 		                | `LH_C(_lh_listcomp_fun_ls_h_3, _lh_listcomp_fun_ls_t_3) -> 
//│ 		                  (if (((safe_d0 _lh_listcomp_fun_ls_h_3) 1) _lh_listcomp_fun_ls_h_2) then
//│ 		                    (`LH_C((`LH_C(_lh_listcomp_fun_ls_h_3, _lh_listcomp_fun_ls_h_2)), (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3)))
//│ 		                  else
//│ 		                    (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3))
//│ 		                | `LH_N -> 
//│ 		                  (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_2))) in
//│ 		              (_lh_listcomp_fun_3 ((enumFromTo_d0 1) _lh_gen_arg2_1)))
//│ 		          | `LH_N -> 
//│ 		            (`LH_N))) in
//│ 		        (_lh_listcomp_fun_2 ((gen_d0 (_lh_gen_arg1_1 - 1)) _lh_gen_arg2_1))))
//│ 		and length_d0 ls_1_9 =
//│ 		  (match ls_1_9 with
//│ 		    | `LH_C(h_2_0, t_2_2) -> 
//│ 		      (1 + (length_d0 t_2_2))
//│ 		    | `LH_N -> 
//│ 		      0)
//│ 		and nsoln_d0 _lh_nsoln_arg1_1 =
//│ 		  (length_d0 ((gen_d0 _lh_nsoln_arg1_1) _lh_nsoln_arg1_1))
//│ 		and safe_d0 _lh_safe_arg1_1 _lh_safe_arg2_1 _lh_safe_arg3_1 =
//│ 		  (match _lh_safe_arg3_1 with
//│ 		    | `LH_N -> 
//│ 		      true
//│ 		    | `LH_C(_lh_safe_LH_C_0_1, _lh_safe_LH_C_1_1) -> 
//│ 		      ((((_lh_safe_arg1_1 <> _lh_safe_LH_C_0_1) && (_lh_safe_arg1_1 <> (_lh_safe_LH_C_0_1 + _lh_safe_arg2_1))) && (_lh_safe_arg1_1 <> (_lh_safe_LH_C_0_1 - _lh_safe_arg2_1))) && (((safe_d0 _lh_safe_arg1_1) (_lh_safe_arg2_1 + 1)) _lh_safe_LH_C_1_1))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		(nsoln_d0 10)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [nsoln₀^862] (hopeless to continue)
//│ 	[nsoln₀^862 · gen₀^774] (using original def)
//│ 		[nsoln₀^862 · gen₀^774 · enumFromTo₀^748] (using original def)
//│ 			[nsoln₀^862 · gen₀^774 · enumFromTo₀^748 · enumFromTo₀^848] ---> [nsoln₀^862 · gen₀^774 · enumFromTo₀^748] (using original def)
//│ 		[nsoln₀^862 · gen₀^774 · gen₀^759] ---> [nsoln₀^862 · gen₀^774] (using original def)
//│ 		[nsoln₀^862 · gen₀^774 · safe₀^724] (using original def)
//│ 			[nsoln₀^862 · gen₀^774 · safe₀^724 · safe₀^814] ---> [nsoln₀^862 · gen₀^774 · safe₀^724] (using original def)
//│ 	[nsoln₀^862 · length₀^773] (using original def)
//│ 		[nsoln₀^862 · length₀^773 · length₀^835] ---> [nsoln₀^862 · length₀^773] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ nsoln₀₀(10)
//│ def nsoln₀₀(_lh_nsoln_arg1¹) = 
//│ 	length₀₀(gen₀₀(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ 	where
//│ 	def gen₀₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = 
//│ 		case _lh_gen_arg1¹ of {
//│ 			0  => [LH_C [LH_N] [LH_N]]
//│ 			| _  => 
//│ 				let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 					LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 						let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 							LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 							| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 						in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹))
//│ 					| LH_N  => [LH_N]})
//│ 				in _lh_listcomp_fun²(gen₀₀((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ 		where
//│ 		def enumFromTo₀₀(a¹, b¹) = 
//│ 			if (a¹ <= b¹) then [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)] else [LH_N]
//│ 		def safe₀₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = 
//│ 			case _lh_safe_arg3¹ of {
//│ 				LH_N  => [True]
//│ 				| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))
//│ 				| _  => error⁰}
//│ 	def length₀₀(ls¹) = 
//│ 		case ls¹ of {
//│ 			LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 			| LH_N  => 0}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 207 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰}: 202
//│ [LH_N]: 208 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 244
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 270
//│ [LH_C [LH_N] [LH_N]]: 209 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 244
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 270
//│ [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 221 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰}: 202
//│ [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 225 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 244
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 270
//│ [LH_N]: 243 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 244
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 270
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 287 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 233
//│ [LH_N]: 288 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 233
//│ ------------------
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe₀₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰}: 202 --->
//│ 	[LH_N]: 207
//│ 	[LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 221
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 233 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 287
//│ 	[LH_N]: 288
//│ case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo₀₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 244 --->
//│ 	[LH_N]: 208
//│ 	[LH_C [LH_N] [LH_N]]: 209
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 225
//│ 	[LH_N]: 243
//│ case ls¹ of {LH_C h¹ t¹ => (1 + length₀₀(t¹)) | LH_N  => 0}: 270 --->
//│ 	[LH_N]: 208
//│ 	[LH_C [LH_N] [LH_N]]: 209
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 225
//│ 	[LH_N]: 243
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 287 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 233
//│ [LH_N]: 288 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 233
//│ ------------------
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe₀₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 233 --->
//│ 	[LH_C a¹ enumFromTo₀₀((a¹ + 1), b¹)]: 287
//│ 	[LH_N]: 288
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ nsoln₀₀(10)
//│ def nsoln₀₀(_lh_nsoln_arg1²) = 
//│ 	length₀₀(gen₀₀(_lh_nsoln_arg1², _lh_nsoln_arg1²))
//│ 	where
//│ 	def gen₀₀(_lh_gen_arg1², _lh_gen_arg2²) = 
//│ 		case _lh_gen_arg1² of {
//│ 			0  => [LH_C [LH_N] [LH_N]]
//│ 			| _  => 
//│ 				let _lh_listcomp_fun⁸ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {
//│ 					LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 						let _lh_listcomp_fun⁹ = (fun _lh_listcomp_fun_para⁵ -> _lh_listcomp_fun_para⁵(_lh_listcomp_fun_ls_h², _lh_listcomp_fun⁹, _lh_listcomp_fun_ls_t², _lh_listcomp_fun⁸))
//│ 						in _lh_listcomp_fun⁹(enumFromTo₀₀(1, _lh_gen_arg2²))
//│ 					| LH_N  => [LH_N]})
//│ 				in _lh_listcomp_fun⁸(gen₀₀((_lh_gen_arg1² - 1), _lh_gen_arg2²))}
//│ 		where
//│ 		def enumFromTo₀₀(a², b²) = 
//│ 			if (a² <= b²) then 
//│ 				let _lh_listcomp_fun_ls_h⁴ = a²
//│ 				in let _lh_listcomp_fun_ls_t⁴ = enumFromTo₀₀((a² + 1), b²)
//│ 				in (fun _lh_listcomp_fun_ls_h⁵ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_listcomp_fun_ls_t⁵ -> (fun _lh_listcomp_fun⁵ -> if safe₀₀(_lh_listcomp_fun_ls_h⁴, 1, _lh_listcomp_fun_ls_h⁵) then [LH_C [LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_h⁵] _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴))))) else (fun _lh_listcomp_fun_ls_h⁶ -> (fun _lh_listcomp_fun⁶ -> (fun _lh_listcomp_fun_ls_t⁶ -> (fun _lh_listcomp_fun⁷ -> _lh_listcomp_fun⁷(_lh_listcomp_fun_ls_t⁶)))))
//│ 		def safe₀₀(_lh_safe_arg1², _lh_safe_arg2², _lh_safe_arg3²) = 
//│ 			case _lh_safe_arg3² of {
//│ 				LH_N  => [True]
//│ 				| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1² /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2²))) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2²))) && safe₀₀(_lh_safe_arg1², (_lh_safe_arg2² + 1), _lh_safe_LH_C_1¹))
//│ 				| _  => error⁰}
//│ 	def length₀₀(ls²) = 
//│ 		case ls² of {
//│ 			LH_C h¹ t¹ => (1 + length₀₀(t¹))
//│ 			| LH_N  => 0}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec enumFromTo_d0_d0 a_0 b_0 =
//│   (if (a_0 <= b_0) then
//│     (let rec _lh_listcomp_fun_ls_h_0 = a_0 in
//│       (let rec _lh_listcomp_fun_ls_t_0 = ((enumFromTo_d0_d0 (a_0 + 1)) b_0) in
//│         (fun _lh_listcomp_fun_ls_h_1 _lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_1 _lh_listcomp_fun_1 -> 
//│           (if (((safe_d0_d0 _lh_listcomp_fun_ls_h_0) 1) _lh_listcomp_fun_ls_h_1) then
//│             (`LH_C((`LH_C(_lh_listcomp_fun_ls_h_0, _lh_listcomp_fun_ls_h_1)), (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0)))
//│           else
//│             (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0)))))
//│   else
//│     (fun _lh_listcomp_fun_ls_h_2 _lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_2 _lh_listcomp_fun_3 -> 
//│       (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_2)))
//│ and gen_d0_d0 _lh_gen_arg1_0 _lh_gen_arg2_0 =
//│   (match _lh_gen_arg1_0 with
//│     | 0 -> 
//│       (`LH_C((`LH_N), (`LH_N)))
//│     | _ -> 
//│       (let rec _lh_listcomp_fun_4 = (fun _lh_listcomp_fun_para_0 -> 
//│         (match _lh_listcomp_fun_para_0 with
//│           | `LH_C(_lh_listcomp_fun_ls_h_3, _lh_listcomp_fun_ls_t_3) -> 
//│             (let rec _lh_listcomp_fun_5 = (fun _lh_listcomp_fun_para_1 -> 
//│               ((((_lh_listcomp_fun_para_1 _lh_listcomp_fun_ls_h_3) _lh_listcomp_fun_5) _lh_listcomp_fun_ls_t_3) _lh_listcomp_fun_4)) in
//│               (_lh_listcomp_fun_5 ((enumFromTo_d0_d0 1) _lh_gen_arg2_0)))
//│           | `LH_N -> 
//│             (`LH_N))) in
//│         (_lh_listcomp_fun_4 ((gen_d0_d0 (_lh_gen_arg1_0 - 1)) _lh_gen_arg2_0))))
//│ and length_d0_d0 ls_0 =
//│   (match ls_0 with
//│     | `LH_C(h_0, t_0) -> 
//│       (1 + (length_d0_d0 t_0))
//│     | `LH_N -> 
//│       0)
//│ and nsoln_d0_d0 _lh_nsoln_arg1_0 =
//│   (length_d0_d0 ((gen_d0_d0 _lh_nsoln_arg1_0) _lh_nsoln_arg1_0))
//│ and safe_d0_d0 _lh_safe_arg1_0 _lh_safe_arg2_0 _lh_safe_arg3_0 =
//│   (match _lh_safe_arg3_0 with
//│     | `LH_N -> 
//│       true
//│     | `LH_C(_lh_safe_LH_C_0_0, _lh_safe_LH_C_1_0) -> 
//│       ((((_lh_safe_arg1_0 <> _lh_safe_LH_C_0_0) && (_lh_safe_arg1_0 <> (_lh_safe_LH_C_0_0 + _lh_safe_arg2_0))) && (_lh_safe_arg1_0 <> (_lh_safe_LH_C_0_0 - _lh_safe_arg2_0))) && (((safe_d0_d0 _lh_safe_arg1_0) (_lh_safe_arg2_0 + 1)) _lh_safe_LH_C_1_0))
//│     | _ -> 
//│       (failwith "error"));;
//│ (nsoln_d0_d0 10)
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


