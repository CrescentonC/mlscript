:NewParser
:ParseOnly

:lhError
:lhInOCaml
let rec a = 4;;
let rec f = function A -> B | C -> D;;
let rec d a b = match a with
  | `A(s, d) -> `D
  | _ -> `S
  | k -> `D;;
let rec f (h:t) = h;;
let val = [false;true;false];;
f val
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ "compilation_unit" (
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"=" ()
//│ 			"number" ()))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"=" ()
//│ 			"function_expression" (
//│ 				"function" ()
//│ 				"match_case" (
//│ 					"constructor_path" (
//│ 						"constructor_name" ())
//│ 					"->" ()
//│ 					"constructor_path" (
//│ 						"constructor_name" ()))
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"constructor_path" (
//│ 						"constructor_name" ())
//│ 					"->" ()
//│ 					"constructor_path" (
//│ 						"constructor_name" ())))))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"parameter" (
//│ 				"value_pattern" ())
//│ 			"parameter" (
//│ 				"value_pattern" ())
//│ 			"=" ()
//│ 			"match_expression" (
//│ 				"match" ()
//│ 				"value_path" (
//│ 					"value_name" ())
//│ 				"with" ()
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"tag_pattern" (
//│ 						"tag" (
//│ 							"`" ())
//│ 						"parenthesized_pattern" (
//│ 							"(" ()
//│ 							"tuple_pattern" (
//│ 								"value_pattern" ()
//│ 								"," ()
//│ 								"value_pattern" ())
//│ 							")" ()))
//│ 					"->" ()
//│ 					"tag" (
//│ 						"`" ()))
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"value_pattern" ()
//│ 					"->" ()
//│ 					"tag" (
//│ 						"`" ()))
//│ 				"|" ()
//│ 				"match_case" (
//│ 					"value_pattern" ()
//│ 					"->" ()
//│ 					"tag" (
//│ 						"`" ())))))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"rec" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"parameter" (
//│ 				"typed_pattern" (
//│ 					"(" ()
//│ 					"value_pattern" ()
//│ 					":" ()
//│ 					"type_constructor_path" (
//│ 						"type_constructor" ())
//│ 					")" ()))
//│ 			"=" ()
//│ 			"value_path" (
//│ 				"value_name" ())))
//│ 	";;" ()
//│ 	"value_definition" (
//│ 		"let" ()
//│ 		"let_binding" (
//│ 			"value_name" ()
//│ 			"=" ()
//│ 			"list_expression" (
//│ 				"[" ()
//│ 				"boolean" (
//│ 					"false" ())
//│ 				";" ()
//│ 				"boolean" (
//│ 					"true" ())
//│ 				";" ()
//│ 				"boolean" (
//│ 					"false" ())
//│ 				"]" ())))
//│ 	";;" ()
//│ 	"expression_item" (
//│ 		"application_expression" (
//│ 			"value_path" (
//│ 				"value_name" ())
//│ 			"value_path" (
//│ 				"value_name" ()))))
//│ !!!!!!ERROR!!!!!!
//│ scala.NotImplementedError: an implementation is missing
//│ !!!!!!ERROR!!!!!!



:lhInHaskell
:lhGenOCaml
[x | x <- [1,2]]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 	LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]
//│ 	| LH_N  => [LH_N]})
//│ in _lh_listcomp_fun⁰([LH_C 1 [LH_C 2 [LH_N]]])
//│ 		---------- unoptimized ocaml gen ----------
//│ 		
//│ 		(let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│ 		  (match _lh_listcomp_fun_para_0 with
//│ 		    | `LH_C(_lh_listcomp_fun_ls_h_0, _lh_listcomp_fun_ls_t_0) -> 
//│ 		      (`LH_C(_lh_listcomp_fun_ls_h_0, (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))) in
//│ 		  (_lh_listcomp_fun_0 (`LH_C(1, (`LH_C(2, (`LH_N)))))))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 13 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 8
//│ [LH_C 2 [LH_N]]: 14 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 8
//│ [LH_C 1 [LH_C 2 [LH_N]]]: 15 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 8
//│ ------------------
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 8 --->
//│ 	[LH_N]: 13
//│ 	[LH_C 2 [LH_N]]: 14
//│ 	[LH_C 1 [LH_C 2 [LH_N]]]: 15
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_N]: 13 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 8
//│ [LH_C 2 [LH_N]]: 14 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 8
//│ [LH_C 1 [LH_C 2 [LH_N]]]: 15 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 8
//│ ------------------
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | LH_N  => [LH_N]}: 8 --->
//│ 	[LH_N]: 13
//│ 	[LH_C 2 [LH_N]]: 14
//│ 	[LH_C 1 [LH_C 2 [LH_N]]]: 15
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun¹))
//│ in _lh_listcomp_fun¹(
//│ 	let _lh_listcomp_fun_ls_t¹ = 	
//│ 		let _lh_listcomp_fun_ls_t² = (fun _lh_listcomp_fun⁴ -> [LH_N])
//│ 		in let _lh_listcomp_fun_ls_h² = 2
//│ 		in (fun _lh_listcomp_fun³ -> [LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun³(_lh_listcomp_fun_ls_t²)])
//│ 	in let _lh_listcomp_fun_ls_h¹ = 1
//│ 	in (fun _lh_listcomp_fun² -> [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun²(_lh_listcomp_fun_ls_t¹)]))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ 
//│ (let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│   (_lh_listcomp_fun_para_0 _lh_listcomp_fun_0)) in
//│   (_lh_listcomp_fun_0 (let rec _lh_listcomp_fun_ls_t_0 = (let rec _lh_listcomp_fun_ls_t_1 = (fun _lh_listcomp_fun_1 -> 
//│     (`LH_N)) in
//│     (let rec _lh_listcomp_fun_ls_h_0 = 2 in
//│       (fun _lh_listcomp_fun_2 -> 
//│         (`LH_C(_lh_listcomp_fun_ls_h_0, (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_1)))))) in
//│     (let rec _lh_listcomp_fun_ls_h_1 = 1 in
//│       (fun _lh_listcomp_fun_3 -> 
//│         (`LH_C(_lh_listcomp_fun_ls_h_1, (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_0))))))))
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhInHaskell
:lhGenOCaml
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = [ (q:b) | b <- gen (n-1) nq, q <- [1..nq], safe q 1 b ]
nsoln nq = length (gen nq nq)
nsoln 10
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ nsoln_lh_₁^145(10)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^57((a⁰ + 1), b⁰)] else [LH_N]
//│ def gen_lh_₁(_lh_gen_arg1⁰, _lh_gen_arg2⁰) = case _lh_gen_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 				let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 					LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁^77(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)
//│ 					| LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ 				in _lh_listcomp_fun¹(enumFromTo_lh_₁^101(1, _lh_gen_arg2⁰))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁰(gen_lh_₁^112((_lh_gen_arg1⁰ - 1), _lh_gen_arg2⁰))}
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁^130(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1⁰) = length_lh_₁^137(gen_lh_₁^138(_lh_nsoln_arg1⁰, _lh_nsoln_arg1⁰))
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁰, _lh_safe_arg3⁰) = case _lh_safe_arg3⁰ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁^34(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_lh__d1 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d1 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec safe_lh__d1 _lh_safe_arg1_0 _lh_safe_arg2_0 _lh_safe_arg3_0 =
//│ 		  (match _lh_safe_arg3_0 with
//│ 		    | `LH_N -> 
//│ 		      true
//│ 		    | `LH_C(_lh_safe_LH_C_0_0, _lh_safe_LH_C_1_0) -> 
//│ 		      ((((_lh_safe_arg1_0 <> _lh_safe_LH_C_0_0) && (_lh_safe_arg1_0 <> (_lh_safe_LH_C_0_0 + _lh_safe_arg2_0))) && (_lh_safe_arg1_0 <> (_lh_safe_LH_C_0_0 - _lh_safe_arg2_0))) && (((safe_lh__d1 _lh_safe_arg1_0) (_lh_safe_arg2_0 + 1)) _lh_safe_LH_C_1_0))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec gen_lh__d1 _lh_gen_arg1_0 _lh_gen_arg2_0 =
//│ 		  (match _lh_gen_arg1_0 with
//│ 		    | 0 -> 
//│ 		      (`LH_C((`LH_N), (`LH_N)))
//│ 		    | _ -> 
//│ 		      (let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│ 		        (match _lh_listcomp_fun_para_0 with
//│ 		          | `LH_C(_lh_listcomp_fun_ls_h_0, _lh_listcomp_fun_ls_t_0) -> 
//│ 		            (let rec _lh_listcomp_fun_1 = (fun _lh_listcomp_fun_para_1 -> 
//│ 		              (match _lh_listcomp_fun_para_1 with
//│ 		                | `LH_C(_lh_listcomp_fun_ls_h_1, _lh_listcomp_fun_ls_t_1) -> 
//│ 		                  (if (((safe_lh__d1 _lh_listcomp_fun_ls_h_1) 1) _lh_listcomp_fun_ls_h_0) then
//│ 		                    (`LH_C((`LH_C(_lh_listcomp_fun_ls_h_1, _lh_listcomp_fun_ls_h_0)), (_lh_listcomp_fun_1 _lh_listcomp_fun_ls_t_1)))
//│ 		                  else
//│ 		                    (_lh_listcomp_fun_1 _lh_listcomp_fun_ls_t_1))
//│ 		                | `LH_N -> 
//│ 		                  (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0))) in
//│ 		              (_lh_listcomp_fun_1 ((enumFromTo_lh__d1 1) _lh_gen_arg2_0)))
//│ 		          | `LH_N -> 
//│ 		            (`LH_N))) in
//│ 		        (_lh_listcomp_fun_0 ((gen_lh__d1 (_lh_gen_arg1_0 - 1)) _lh_gen_arg2_0))));;
//│ 		let rec length_lh__d1 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (1 + (length_lh__d1 t_0))
//│ 		    | `LH_N -> 
//│ 		      0);;
//│ 		let rec nsoln_lh__d1 _lh_nsoln_arg1_0 =
//│ 		  (length_lh__d1 ((gen_lh__d1 _lh_nsoln_arg1_0) _lh_nsoln_arg1_0));;
//│ 		(nsoln_lh__d1 10)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 66 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98
//│ [LH_N]: 67 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98
//│ [LH_N]: 72 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 47
//│ [LH_N]: 73 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135
//│ [LH_C [LH_N] [LH_N]]: 74 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135
//│ [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰]: 86 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 47
//│ [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 90 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135
//│ [LH_N]: 108 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135
//│ ------------------
//│ case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 47 --->
//│ 	[LH_N]: 72
//│ 	[LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰]: 86
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 66
//│ 	[LH_N]: 67
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109 --->
//│ 	[LH_N]: 73
//│ 	[LH_C [LH_N] [LH_N]]: 74
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 90
//│ 	[LH_N]: 108
//│ case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135 --->
//│ 	[LH_N]: 73
//│ 	[LH_C [LH_N] [LH_N]]: 74
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 90
//│ 	[LH_N]: 108
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 66 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98
//│ [LH_N]: 67 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98
//│ ------------------
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 66
//│ 	[LH_N]: 67
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ nsoln_lh_₁(10)
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let _lh_listcomp_fun_ls_t² = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let _lh_listcomp_fun_ls_h² = a¹
//│ 	in (fun _lh_listcomp_fun_ls_h³ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_listcomp_fun_ls_t³ -> (fun _lh_listcomp_fun⁵ -> if safe_lh_₁(_lh_listcomp_fun_ls_h², 1, _lh_listcomp_fun_ls_h³) then [LH_C [LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_h³] _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t²))))) else (fun _lh_listcomp_fun_ls_h⁴ -> (fun _lh_listcomp_fun⁶ -> (fun _lh_listcomp_fun_ls_t⁴ -> (fun _lh_listcomp_fun⁷ -> _lh_listcomp_fun⁷(_lh_listcomp_fun_ls_t⁴)))))
//│ def gen_lh_₁(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 				let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> _lh_listcomp_fun_para³(_lh_listcomp_fun_ls_h⁰, _lh_listcomp_fun³, _lh_listcomp_fun_ls_t⁰, _lh_listcomp_fun²))
//│ 				in _lh_listcomp_fun³(enumFromTo_lh_₁(1, _lh_gen_arg2¹))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun²(gen_lh_₁((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length_lh_₁(ls¹) = case ls¹ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1¹) = length_lh_₁(gen_lh_₁(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe_lh_₁(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2¹))) && safe_lh_₁(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec safe_lh__d1 _lh_safe_arg1_0 _lh_safe_arg2_0 _lh_safe_arg3_0 =
//│   (match _lh_safe_arg3_0 with
//│     | `LH_N -> 
//│       true
//│     | `LH_C(_lh_safe_LH_C_0_0, _lh_safe_LH_C_1_0) -> 
//│       ((((_lh_safe_arg1_0 <> _lh_safe_LH_C_0_0) && (_lh_safe_arg1_0 <> (_lh_safe_LH_C_0_0 + _lh_safe_arg2_0))) && (_lh_safe_arg1_0 <> (_lh_safe_LH_C_0_0 - _lh_safe_arg2_0))) && (((safe_lh__d1 _lh_safe_arg1_0) (_lh_safe_arg2_0 + 1)) _lh_safe_LH_C_1_0))
//│     | _ -> 
//│       (failwith "error"));;
//│ let rec enumFromTo_lh__d1 a_0 b_0 =
//│   (if (a_0 <= b_0) then
//│     (let rec _lh_listcomp_fun_ls_t_1 = ((enumFromTo_lh__d1 (a_0 + 1)) b_0) in
//│       (let rec _lh_listcomp_fun_ls_h_1 = a_0 in
//│         (fun _lh_listcomp_fun_ls_h_2 _lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_2 _lh_listcomp_fun_3 -> 
//│           (if (((safe_lh__d1 _lh_listcomp_fun_ls_h_1) 1) _lh_listcomp_fun_ls_h_2) then
//│             (`LH_C((`LH_C(_lh_listcomp_fun_ls_h_1, _lh_listcomp_fun_ls_h_2)), (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_1)))
//│           else
//│             (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_1)))))
//│   else
//│     (fun _lh_listcomp_fun_ls_h_3 _lh_listcomp_fun_4 _lh_listcomp_fun_ls_t_3 _lh_listcomp_fun_5 -> 
//│       (_lh_listcomp_fun_5 _lh_listcomp_fun_ls_t_3)));;
//│ let rec gen_lh__d1 _lh_gen_arg1_0 _lh_gen_arg2_0 =
//│   (match _lh_gen_arg1_0 with
//│     | 0 -> 
//│       (`LH_C((`LH_N), (`LH_N)))
//│     | _ -> 
//│       (let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│         (match _lh_listcomp_fun_para_0 with
//│           | `LH_C(_lh_listcomp_fun_ls_h_0, _lh_listcomp_fun_ls_t_0) -> 
//│             (let rec _lh_listcomp_fun_1 = (fun _lh_listcomp_fun_para_1 -> 
//│               ((((_lh_listcomp_fun_para_1 _lh_listcomp_fun_ls_h_0) _lh_listcomp_fun_1) _lh_listcomp_fun_ls_t_0) _lh_listcomp_fun_0)) in
//│               (_lh_listcomp_fun_1 ((enumFromTo_lh__d1 1) _lh_gen_arg2_0)))
//│           | `LH_N -> 
//│             (`LH_N))) in
//│         (_lh_listcomp_fun_0 ((gen_lh__d1 (_lh_gen_arg1_0 - 1)) _lh_gen_arg2_0))));;
//│ let rec length_lh__d1 ls_0 =
//│   (match ls_0 with
//│     | `LH_C(h_0, t_0) -> 
//│       (1 + (length_lh__d1 t_0))
//│     | `LH_N -> 
//│       0);;
//│ let rec nsoln_lh__d1 _lh_nsoln_arg1_0 =
//│   (length_lh__d1 ((gen_lh__d1 _lh_nsoln_arg1_0) _lh_nsoln_arg1_0));;
//│ (nsoln_lh__d1 10)
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


