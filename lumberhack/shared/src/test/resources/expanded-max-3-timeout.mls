:NewParser
:ParseOnly

// WRONG: could have more fusion done
fun max(ms) = if ms is
  C(h, t) then m => if h > m then max(t)(h) else max(t)(m)
  N then m => m
max(C(1, C(3, C(2, N))))(0)
//│ |#fun| |max|(|ms|)| |#=| |#if| |ms| |is|→|C|(|h|,| |t|)| |#then| |m| |=>| |#if| |h| |>| |m| |#then| |max|(|t|)|(|h|)| |#else| |max|(|t|)|(|m|)|↵|N| |#then| |m| |=>| |m|←|↵|max|(|C|(|1|,| |C|(|3|,| |C|(|2|,| |N|)|)|)|)|(|0|)|
//│ Parsed: {fun max = ms, => if ms is ‹(C (h, t,)) then m, => if (> (h,) (m,)) then max (t,) (h,) else max (t,) (m,); (N) then m, => m›; max (C (1, C (3, C (2, N,),),),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((max^23 [C 1 [C 3 [C 2 [N]]]]) 0)
//│ def max = (fun ms⁰ -> case ms⁰ of {
//│ 	C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then ((max^7 t⁰) h⁰) else ((max^12 t⁰) m⁰))
//│ 	| N => (fun m¹ -> m¹)})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [max^23]
//│ 	[max^23 · max^12]
//│ 		[max^23 · max^12 · max^12] ---> [max^23] (only one)
//│ 		[max^23 · max^12 · max^7] (hopeless to continue)
//│ 			[max^23 · max^12 · max^7 · max^12] ---> [max^23 · max^12 · max^7] (using original def)
//│ 			[max^23 · max^12 · max^7 · max^7] ---> [max^23 · max^12 · max^7] (using original def)
//│ 	[max^23 · max^7] ---> [max^23] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((max₀ [C 1 [C 3 [C 2 [N]]]]) 0)
//│ def max₀ = 
//│ 	(fun ms² -> case ms² of {
//│ 		C h² t² => (fun m⁴ -> if (h² > m⁴) then ((max₀ t²) h²) else ((max₁ t²) m⁴))
//│ 		| N => (fun m⁵ -> m⁵)})
//│ 	where
//│ 	def max₁ = 
//│ 		(fun ms³ -> case ms³ of {
//│ 			C h³ t³ => (fun m⁶ -> if (h³ > m⁶) then ((max₂ t³) h³) else ((max₀ t³) m⁶))
//│ 			| N => (fun m⁷ -> m⁷)})
//│ 		where
//│ 		def max₂ = 
//│ 			(fun ms¹ -> case ms¹ of {
//│ 				C h¹ t¹ => (fun m² -> if (h¹ > m²) then ((max₂ t¹) h¹) else ((max₂ t¹) m²))
//│ 				| N => (fun m³ -> m³)})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 3 [C 2 [N]]]]: 107 --->
//│ 	case ms² of {C h² t² => (fun m⁴ -> if (h² > m⁴) then ((max₀ t²) h²) else ((max₁ t²) m⁴)) | N => (fun m⁵ -> m⁵)}: 76
//│ [C 2 [N]]: 105 --->
//│ 	case ms² of {C h² t² => (fun m⁴ -> if (h² > m⁴) then ((max₀ t²) h²) else ((max₁ t²) m⁴)) | N => (fun m⁵ -> m⁵)}: 76
//│ 	case ms³ of {C h³ t³ => (fun m⁶ -> if (h³ > m⁶) then ((max₂ t³) h³) else ((max₀ t³) m⁶)) | N => (fun m⁷ -> m⁷)}: 98
//│ 	case ms¹ of {C h¹ t¹ => (fun m² -> if (h¹ > m²) then ((max₂ t¹) h¹) else ((max₂ t¹) m²)) | N => (fun m³ -> m³)}: 54
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C 3 [C 2 [N]]]: 106 --->
//│ 	case ms² of {C h² t² => (fun m⁴ -> if (h² > m⁴) then ((max₀ t²) h²) else ((max₁ t²) m⁴)) | N => (fun m⁵ -> m⁵)}: 76
//│ 	case ms³ of {C h³ t³ => (fun m⁶ -> if (h³ > m⁶) then ((max₂ t³) h³) else ((max₀ t³) m⁶)) | N => (fun m⁷ -> m⁷)}: 98
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N]: 104 --->
//│ 	case ms² of {C h² t² => (fun m⁴ -> if (h² > m⁴) then ((max₀ t²) h²) else ((max₁ t²) m⁴)) | N => (fun m⁵ -> m⁵)}: 76
//│ 	case ms³ of {C h³ t³ => (fun m⁶ -> if (h³ > m⁶) then ((max₂ t³) h³) else ((max₀ t³) m⁶)) | N => (fun m⁷ -> m⁷)}: 98
//│ 	case ms¹ of {C h¹ t¹ => (fun m² -> if (h¹ > m²) then ((max₂ t¹) h¹) else ((max₂ t¹) m²)) | N => (fun m³ -> m³)}: 54
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((max₀ [C 1 [C 3 [C 2 [N]]]]) 0)
//│ def max₀ = 
//│ 	(fun ms⁵ -> case ms⁵ of {
//│ 		C h² t² => (fun m¹⁰ -> if (h² > m¹⁰) then ((max₀ t²) h²) else ((max₁ t²) m¹⁰))
//│ 		| N => (fun m¹¹ -> m¹¹)})
//│ 	where
//│ 	def max₁ = 
//│ 		(fun ms⁶ -> case ms⁶ of {
//│ 			C h³ t³ => (fun m¹² -> if (h³ > m¹²) then ((max₂ t³) h³) else ((max₀ t³) m¹²))
//│ 			| N => (fun m¹³ -> m¹³)})
//│ 		where
//│ 		def max₂ = 
//│ 			(fun ms⁴ -> case ms⁴ of {
//│ 				C h¹ t¹ => (fun m⁸ -> if (h¹ > m⁸) then ((max₂ t¹) h¹) else ((max₂ t¹) m⁸))
//│ 				| N => (fun m⁹ -> m⁹)})
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: will not timeout now
_LUMBERHACK_EVAL
fun max = x => x
max(
  let h = 1
  let t = (
    let h = 3
    let t = (
      let h = 2
      let t = m => m
      m => if (h > m) then max(t)(h) else max(t)(m)
    )
    (m => if h > m then max(t)(h) else max(t)(m))
  )
  (m => if (h > m) then max(t)(h) else max(t)(m))
)(0)
//│ |_LUMBERHACK_EVAL|↵|#fun| |max| |#=| |x| |=>| |x|↵|max|(|→|#let| |h| |#=| |1|↵|#let| |t| |#=| |(|→|#let| |h| |#=| |3|↵|#let| |t| |#=| |(|→|#let| |h| |#=| |2|↵|#let| |t| |#=| |m| |=>| |m|↵|m| |=>| |#if| |(|h| |>| |m|)| |#then| |max|(|t|)|(|h|)| |#else| |max|(|t|)|(|m|)|←|↵|)|↵|(|m| |=>| |#if| |h| |>| |m| |#then| |max|(|t|)|(|h|)| |#else| |max|(|t|)|(|m|)|)|←|↵|)|↵|(|m| |=>| |#if| |(|h| |>| |m|)| |#then| |max|(|t|)|(|h|)| |#else| |max|(|t|)|(|m|)|)|←|↵|)|(|0|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun max = x, => x; max (let h = 1 in let t = '(' let h = 3 in let t = '(' let h = 2 in let t = m, => m in m, => if ('(' > (h,) (m,), ')') then max (t,) (h,) else max (t,) (m,), ')' in '(' m, => if (> (h,) (m,)) then max (t,) (h,) else max (t,) (m,), ')', ')' in '(' m, => if ('(' > (h,) (m,), ')') then max (t,) (h,) else max (t,) (m,), ')',) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((max^3 
//│ 	let h⁰ = 1
//│ 	in let t⁰ = 	
//│ 		let h¹ = 3
//│ 		in let t¹ = 	
//│ 			let h² = 2
//│ 			in let t² = (fun m⁰ -> m⁰)
//│ 			in (fun m¹ -> if (h² > m¹) then ((max^14 t²) h²) else ((max^19 t²) m¹))
//│ 		in (fun m² -> if (h¹ > m²) then ((max^33 t¹) h¹) else ((max^38 t¹) m²))
//│ 	in (fun m³ -> if (h⁰ > m³) then ((max^52 t⁰) h⁰) else ((max^57 t⁰) m³))) 0)
//│ def max = (fun x⁰ -> x⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [max^14] (hopeless to continue)
//│ [max^19] (hopeless to continue)
//│ [max^33] (hopeless to continue)
//│ [max^38] (hopeless to continue)
//│ [max^3] (hopeless to continue)
//│ [max^52] (hopeless to continue)
//│ [max^57] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((max₄ 
//│ 	let h³ = 1
//│ 	in let t³ = 	
//│ 		let h⁴ = 3
//│ 		in let t⁴ = 	
//│ 			let h⁵ = 2
//│ 			in let t⁵ = (fun m⁴ -> m⁴)
//│ 			in (fun m⁵ -> if (h⁵ > m⁵) then ((max₀ t⁵) h⁵) else ((max₁ t⁵) m⁵))
//│ 		in (fun m⁶ -> if (h⁴ > m⁶) then ((max₂ t⁴) h⁴) else ((max₃ t⁴) m⁶))
//│ 	in (fun m⁷ -> if (h³ > m⁷) then ((max₅ t³) h³) else ((max₆ t³) m⁷))) 0)
//│ def max₀ = 
//│ 	(fun x³ -> x³)
//│ def max₁ = 
//│ 	(fun x⁵ -> x⁵)
//│ def max₂ = 
//│ 	(fun x⁷ -> x⁷)
//│ def max₃ = 
//│ 	(fun x⁴ -> x⁴)
//│ def max₄ = 
//│ 	(fun x¹ -> x¹)
//│ def max₅ = 
//│ 	(fun x² -> x²)
//│ def max₆ = 
//│ 	(fun x⁶ -> x⁶)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((max₄ 
//│ 	let h³ = 1
//│ 	in let t³ = 	
//│ 		let h⁴ = 3
//│ 		in let t⁴ = 	
//│ 			let h⁵ = 2
//│ 			in let t⁵ = (fun m⁸ -> m⁸)
//│ 			in (fun m⁹ -> if (h⁵ > m⁹) then ((max₀ t⁵) h⁵) else ((max₁ t⁵) m⁹))
//│ 		in (fun m¹⁰ -> if (h⁴ > m¹⁰) then ((max₂ t⁴) h⁴) else ((max₃ t⁴) m¹⁰))
//│ 	in (fun m¹¹ -> if (h³ > m¹¹) then ((max₅ t³) h³) else ((max₆ t³) m¹¹))) 0)
//│ def max₀ = 
//│ 	(fun x¹³ -> x¹³)
//│ def max₁ = 
//│ 	(fun x¹⁰ -> x¹⁰)
//│ def max₂ = 
//│ 	(fun x¹⁴ -> x¹⁴)
//│ def max₃ = 
//│ 	(fun x¹² -> x¹²)
//│ def max₄ = 
//│ 	(fun x⁹ -> x⁹)
//│ def max₅ = 
//│ 	(fun x⁸ -> x⁸)
//│ def max₆ = 
//│ 	(fun x¹¹ -> x¹¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 3
//│ <<<<<<< evaluate <<<<<<<


// CORRECT:
// NOTE: if max is duplicated for each call site, less likely to timeout
fun max = y => y
fun max0 = x => x
fun max1 = x => x
fun max2 = x => x
fun max3 = x => x
fun max4 = x => x
fun max5 = x => x
max(
  let h = 1
  let t = (
    let h = 3
    let t = (
      let h = 2
      let t = m => m
      m => if (h > m) then max0(t)(h) else max1(t)(m)
    )
    (m => if h > m then max2(t)(h) else max3(t)(m))
  )
  (m => if (h > m) then max4(t)(h) else max5(t)(m))
)(0)
//│ |#fun| |max| |#=| |y| |=>| |y|↵|#fun| |max0| |#=| |x| |=>| |x|↵|#fun| |max1| |#=| |x| |=>| |x|↵|#fun| |max2| |#=| |x| |=>| |x|↵|#fun| |max3| |#=| |x| |=>| |x|↵|#fun| |max4| |#=| |x| |=>| |x|↵|#fun| |max5| |#=| |x| |=>| |x|↵|max|(|→|#let| |h| |#=| |1|↵|#let| |t| |#=| |(|→|#let| |h| |#=| |3|↵|#let| |t| |#=| |(|→|#let| |h| |#=| |2|↵|#let| |t| |#=| |m| |=>| |m|↵|m| |=>| |#if| |(|h| |>| |m|)| |#then| |max0|(|t|)|(|h|)| |#else| |max1|(|t|)|(|m|)|←|↵|)|↵|(|m| |=>| |#if| |h| |>| |m| |#then| |max2|(|t|)|(|h|)| |#else| |max3|(|t|)|(|m|)|)|←|↵|)|↵|(|m| |=>| |#if| |(|h| |>| |m|)| |#then| |max4|(|t|)|(|h|)| |#else| |max5|(|t|)|(|m|)|)|←|↵|)|(|0|)|
//│ Parsed: {fun max = y, => y; fun max0 = x, => x; fun max1 = x, => x; fun max2 = x, => x; fun max3 = x, => x; fun max4 = x, => x; fun max5 = x, => x; max (let h = 1 in let t = '(' let h = 3 in let t = '(' let h = 2 in let t = m, => m in m, => if ('(' > (h,) (m,), ')') then max0 (t,) (h,) else max1 (t,) (m,), ')' in '(' m, => if (> (h,) (m,)) then max2 (t,) (h,) else max3 (t,) (m,), ')', ')' in '(' m, => if ('(' > (h,) (m,), ')') then max4 (t,) (h,) else max5 (t,) (m,), ')',) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((max^15 
//│ 	let h⁰ = 1
//│ 	in let t⁰ = 	
//│ 		let h¹ = 3
//│ 		in let t¹ = 	
//│ 			let h² = 2
//│ 			in let t² = (fun m⁰ -> m⁰)
//│ 			in (fun m¹ -> if (h² > m¹) then ((max0^26 t²) h²) else ((max1^31 t²) m¹))
//│ 		in (fun m² -> if (h¹ > m²) then ((max2^45 t¹) h¹) else ((max3^50 t¹) m²))
//│ 	in (fun m³ -> if (h⁰ > m³) then ((max4^64 t⁰) h⁰) else ((max5^69 t⁰) m³))) 0)
//│ def max = (fun y⁰ -> y⁰)
//│ def max0 = (fun x⁰ -> x⁰)
//│ def max1 = (fun x¹ -> x¹)
//│ def max2 = (fun x² -> x²)
//│ def max3 = (fun x³ -> x³)
//│ def max4 = (fun x⁴ -> x⁴)
//│ def max5 = (fun x⁵ -> x⁵)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [max0^26] (hopeless to continue)
//│ [max1^31] (hopeless to continue)
//│ [max2^45] (hopeless to continue)
//│ [max3^50] (hopeless to continue)
//│ [max4^64] (hopeless to continue)
//│ [max5^69] (hopeless to continue)
//│ [max^15] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((max₀ 
//│ 	let h³ = 1
//│ 	in let t³ = 	
//│ 		let h⁴ = 3
//│ 		in let t⁴ = 	
//│ 			let h⁵ = 2
//│ 			in let t⁵ = (fun m⁴ -> m⁴)
//│ 			in (fun m⁵ -> if (h⁵ > m⁵) then ((max0₀ t⁵) h⁵) else ((max1₀ t⁵) m⁵))
//│ 		in (fun m⁶ -> if (h⁴ > m⁶) then ((max2₀ t⁴) h⁴) else ((max3₀ t⁴) m⁶))
//│ 	in (fun m⁷ -> if (h³ > m⁷) then ((max4₀ t³) h³) else ((max5₀ t³) m⁷))) 0)
//│ def max0₀ = 
//│ 	(fun x⁸ -> x⁸)
//│ def max1₀ = 
//│ 	(fun x¹¹ -> x¹¹)
//│ def max2₀ = 
//│ 	(fun x⁶ -> x⁶)
//│ def max3₀ = 
//│ 	(fun x⁷ -> x⁷)
//│ def max4₀ = 
//│ 	(fun x⁹ -> x⁹)
//│ def max5₀ = 
//│ 	(fun x¹⁰ -> x¹⁰)
//│ def max₀ = 
//│ 	(fun y¹ -> y¹)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((max₀ 
//│ 	let h³ = 1
//│ 	in let t³ = 	
//│ 		let h⁴ = 3
//│ 		in let t⁴ = 	
//│ 			let h⁵ = 2
//│ 			in let t⁵ = (fun m⁸ -> m⁸)
//│ 			in (fun m⁹ -> if (h⁵ > m⁹) then ((max0₀ t⁵) h⁵) else ((max1₀ t⁵) m⁹))
//│ 		in (fun m¹⁰ -> if (h⁴ > m¹⁰) then ((max2₀ t⁴) h⁴) else ((max3₀ t⁴) m¹⁰))
//│ 	in (fun m¹¹ -> if (h³ > m¹¹) then ((max4₀ t³) h³) else ((max5₀ t³) m¹¹))) 0)
//│ def max0₀ = 
//│ 	(fun x¹⁷ -> x¹⁷)
//│ def max1₀ = 
//│ 	(fun x¹² -> x¹²)
//│ def max2₀ = 
//│ 	(fun x¹⁴ -> x¹⁴)
//│ def max3₀ = 
//│ 	(fun x¹⁵ -> x¹⁵)
//│ def max4₀ = 
//│ 	(fun x¹³ -> x¹³)
//│ def max5₀ = 
//│ 	(fun x¹⁶ -> x¹⁶)
//│ def max₀ = 
//│ 	(fun y² -> y²)
//│ <<<<<<< after fusion <<<<<<<

// infinite list
fun max(ms) = if ms is
  C(h, t) then m => if h > m then max(t)(h) else max(t)(m)
  N then m => m
let l = C(1, C(3, C(2, C(5, l))))
max(l)(0)
//│ |#fun| |max|(|ms|)| |#=| |#if| |ms| |is|→|C|(|h|,| |t|)| |#then| |m| |=>| |#if| |h| |>| |m| |#then| |max|(|t|)|(|h|)| |#else| |max|(|t|)|(|m|)|↵|N| |#then| |m| |=>| |m|←|↵|#let| |l| |#=| |C|(|1|,| |C|(|3|,| |C|(|2|,| |C|(|5|,| |l|)|)|)|)|↵|max|(|l|)|(|0|)|
//│ Parsed: {fun max = ms, => if ms is ‹(C (h, t,)) then m, => if (> (h,) (m,)) then max (t,) (h,) else max (t,) (m,); (N) then m, => m›; let l = C (1, C (3, C (2, C (5, l,),),),); max (l,) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((max^32 l^33) 0)
//│ def l = [C 1 [C 3 [C 2 [C 5 l^27]]]]
//│ def max = (fun ms⁰ -> case ms⁰ of {
//│ 	C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then ((max^7 t⁰) h⁰) else ((max^12 t⁰) m⁰))
//│ 	| N => (fun m¹ -> m¹)})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^33]
//│ 	[l^33 · l^27] ---> [l^33] (only one)
//│ [max^32]
//│ 	[max^32 · max^12]
//│ 		[max^32 · max^12 · max^12] ---> [max^32] (only one)
//│ 		[max^32 · max^12 · max^7] (hopeless to continue)
//│ 			[max^32 · max^12 · max^7 · max^12] ---> [max^32 · max^12 · max^7] (using original def)
//│ 			[max^32 · max^12 · max^7 · max^7] ---> [max^32 · max^12 · max^7] (using original def)
//│ 	[max^32 · max^7] ---> [max^32] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((max₀ l₀) 0)
//│ def l₀ = 
//│ 	[C 1 [C 3 [C 2 [C 5 l₀]]]]
//│ def max₀ = 
//│ 	(fun ms² -> case ms² of {
//│ 		C h² t² => (fun m⁴ -> if (h² > m⁴) then ((max₀ t²) h²) else ((max₁ t²) m⁴))
//│ 		| N => (fun m⁵ -> m⁵)})
//│ 	where
//│ 	def max₁ = 
//│ 		(fun ms¹ -> case ms¹ of {
//│ 			C h¹ t¹ => (fun m² -> if (h¹ > m²) then ((max₂ t¹) h¹) else ((max₀ t¹) m²))
//│ 			| N => (fun m³ -> m³)})
//│ 		where
//│ 		def max₂ = 
//│ 			(fun ms³ -> case ms³ of {
//│ 				C h³ t³ => (fun m⁶ -> if (h³ > m⁶) then ((max₂ t³) h³) else ((max₂ t³) m⁶))
//│ 				| N => (fun m⁷ -> m⁷)})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 3 [C 2 [C 5 l₀]]]]: 45 --->
//│ 	case ms² of {C h² t² => (fun m⁴ -> if (h² > m⁴) then ((max₀ t²) h²) else ((max₁ t²) m⁴)) | N => (fun m⁵ -> m⁵)}: 88
//│ 	case ms¹ of {C h¹ t¹ => (fun m² -> if (h¹ > m²) then ((max₂ t¹) h¹) else ((max₀ t¹) m²)) | N => (fun m³ -> m³)}: 66
//│ 	case ms³ of {C h³ t³ => (fun m⁶ -> if (h³ > m⁶) then ((max₂ t³) h³) else ((max₂ t³) m⁶)) | N => (fun m⁷ -> m⁷)}: 110
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C 2 [C 5 l₀]]: 43 --->
//│ 	case ms² of {C h² t² => (fun m⁴ -> if (h² > m⁴) then ((max₀ t²) h²) else ((max₁ t²) m⁴)) | N => (fun m⁵ -> m⁵)}: 88
//│ 	case ms¹ of {C h¹ t¹ => (fun m² -> if (h¹ > m²) then ((max₂ t¹) h¹) else ((max₀ t¹) m²)) | N => (fun m³ -> m³)}: 66
//│ 	case ms³ of {C h³ t³ => (fun m⁶ -> if (h³ > m⁶) then ((max₂ t³) h³) else ((max₂ t³) m⁶)) | N => (fun m⁷ -> m⁷)}: 110
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C 3 [C 2 [C 5 l₀]]]: 44 --->
//│ 	case ms² of {C h² t² => (fun m⁴ -> if (h² > m⁴) then ((max₀ t²) h²) else ((max₁ t²) m⁴)) | N => (fun m⁵ -> m⁵)}: 88
//│ 	case ms¹ of {C h¹ t¹ => (fun m² -> if (h¹ > m²) then ((max₂ t¹) h¹) else ((max₀ t¹) m²)) | N => (fun m³ -> m³)}: 66
//│ 	case ms³ of {C h³ t³ => (fun m⁶ -> if (h³ > m⁶) then ((max₂ t³) h³) else ((max₂ t³) m⁶)) | N => (fun m⁷ -> m⁷)}: 110
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C 5 l₀]: 42 --->
//│ 	case ms² of {C h² t² => (fun m⁴ -> if (h² > m⁴) then ((max₀ t²) h²) else ((max₁ t²) m⁴)) | N => (fun m⁵ -> m⁵)}: 88
//│ 	case ms¹ of {C h¹ t¹ => (fun m² -> if (h¹ > m²) then ((max₂ t¹) h¹) else ((max₀ t¹) m²)) | N => (fun m³ -> m³)}: 66
//│ 	case ms³ of {C h³ t³ => (fun m⁶ -> if (h³ > m⁶) then ((max₂ t³) h³) else ((max₂ t³) m⁶)) | N => (fun m⁷ -> m⁷)}: 110
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((max₀ l₀) 0)
//│ def l₀ = 
//│ 	[C 1 [C 3 [C 2 [C 5 l₀]]]]
//│ def max₀ = 
//│ 	(fun ms⁵ -> case ms⁵ of {
//│ 		C h² t² => (fun m¹⁰ -> if (h² > m¹⁰) then ((max₀ t²) h²) else ((max₁ t²) m¹⁰))
//│ 		| N => (fun m¹¹ -> m¹¹)})
//│ 	where
//│ 	def max₁ = 
//│ 		(fun ms⁴ -> case ms⁴ of {
//│ 			C h¹ t¹ => (fun m⁸ -> if (h¹ > m⁸) then ((max₂ t¹) h¹) else ((max₀ t¹) m⁸))
//│ 			| N => (fun m⁹ -> m⁹)})
//│ 		where
//│ 		def max₂ = 
//│ 			(fun ms⁶ -> case ms⁶ of {
//│ 				C h³ t³ => (fun m¹² -> if (h³ > m¹²) then ((max₂ t³) h³) else ((max₂ t³) m¹²))
//│ 				| N => (fun m¹³ -> m¹³)})
//│ <<<<<<< after fusion <<<<<<<
