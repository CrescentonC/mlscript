:NewParser
:ParseOnly

// WRONG: example for must merge duplicated defs
fun max(ms) = if ms is
  C(h, t) then m => if h > m then max(t)(h) else max(t)(m)
  N then m => m
max(C(1, N))(0)
//│ |#fun| |max|(|ms|)| |#=| |#if| |ms| |is|→|C|(|h|,| |t|)| |#then| |m| |=>| |#if| |h| |>| |m| |#then| |max|(|t|)|(|h|)| |#else| |max|(|t|)|(|m|)|↵|N| |#then| |m| |=>| |m|←|↵|max|(|C|(|1|,| |N|)|)|(|0|)|
//│ Parsed: {fun max = ms, => if ms is ‹(C (h, t,)) then m, => if (> (h,) (m,)) then max (t,) (h,) else max (t,) (m,); (N) then m, => m›; max (C (1, N,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ max^23([C 1 [N]], 0)
//│ def max(ms⁰) = case ms⁰ of {
//│ 	C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max^7(t⁰, h⁰) else max^12(t⁰, m⁰))
//│ 	| N  => (fun m¹ -> m¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 25 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ [C 1 [N]]: 26 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ ------------------
//│ case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21 --->
//│ 	[N]: 25
//│ 	[C 1 [N]]: 26
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 25 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ [C 1 [N]]: 26 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ ------------------
//│ case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21 --->
//│ 	[N]: 25
//│ 	[C 1 [N]]: 26
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ max(
//│ 	let t¹ = (fun m³ -> m³)
//│ 	in let h¹ = 1
//│ 	in (fun m² -> if (h¹ > m²) then max(t¹, h¹) else max(t¹, m²)), 0)
//│ def max(ms¹) = ms¹
//│ <<<<<<< after fusion <<<<<<<




// WRONG: could have more fusion done
fun max(ms) = if ms is
  C(h, t) then m => if h > m then max(t)(h) else max(t)(m)
  N then m => m
max(C(1, C(3, C(2, N))))(0)
//│ |#fun| |max|(|ms|)| |#=| |#if| |ms| |is|→|C|(|h|,| |t|)| |#then| |m| |=>| |#if| |h| |>| |m| |#then| |max|(|t|)|(|h|)| |#else| |max|(|t|)|(|m|)|↵|N| |#then| |m| |=>| |m|←|↵|max|(|C|(|1|,| |C|(|3|,| |C|(|2|,| |N|)|)|)|)|(|0|)|
//│ Parsed: {fun max = ms, => if ms is ‹(C (h, t,)) then m, => if (> (h,) (m,)) then max (t,) (h,) else max (t,) (m,); (N) then m, => m›; max (C (1, C (3, C (2, N,),),),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ max^23([C 1 [C 3 [C 2 [N]]]], 0)
//│ def max(ms⁰) = case ms⁰ of {
//│ 	C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max^7(t⁰, h⁰) else max^12(t⁰, m⁰))
//│ 	| N  => (fun m¹ -> m¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 27 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ [C 2 [N]]: 28 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ [C 3 [C 2 [N]]]: 29 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ [C 1 [C 3 [C 2 [N]]]]: 30 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ ------------------
//│ case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21 --->
//│ 	[N]: 27
//│ 	[C 2 [N]]: 28
//│ 	[C 3 [C 2 [N]]]: 29
//│ 	[C 1 [C 3 [C 2 [N]]]]: 30
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 27 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ [C 2 [N]]: 28 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ [C 3 [C 2 [N]]]: 29 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ [C 1 [C 3 [C 2 [N]]]]: 30 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ ------------------
//│ case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21 --->
//│ 	[N]: 27
//│ 	[C 2 [N]]: 28
//│ 	[C 3 [C 2 [N]]]: 29
//│ 	[C 1 [C 3 [C 2 [N]]]]: 30
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ max(
//│ 	let t¹ = 	
//│ 		let t² = 	
//│ 			let t³ = (fun m⁵ -> m⁵)
//│ 			in let h³ = 2
//│ 			in (fun m⁴ -> if (h³ > m⁴) then max(t³, h³) else max(t³, m⁴))
//│ 		in let h² = 3
//│ 		in (fun m³ -> if (h² > m³) then max(t², h²) else max(t², m³))
//│ 	in let h¹ = 1
//│ 	in (fun m² -> if (h¹ > m²) then max(t¹, h¹) else max(t¹, m²)), 0)
//│ def max(ms¹) = ms¹
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: will not timeout now
_LUMBERHACK_EVAL
fun max = x => x
max(
  let h = 1
  let t = (
    let h = 3
    let t = (
      let h = 2
      let t = m => m
      m => if (h > m) then max(t)(h) else max(t)(m)
    )
    (m => if h > m then max(t)(h) else max(t)(m))
  )
  (m => if (h > m) then max(t)(h) else max(t)(m))
)(0)
//│ |_LUMBERHACK_EVAL|↵|#fun| |max| |#=| |x| |=>| |x|↵|max|(|→|#let| |h| |#=| |1|↵|#let| |t| |#=| |(|→|#let| |h| |#=| |3|↵|#let| |t| |#=| |(|→|#let| |h| |#=| |2|↵|#let| |t| |#=| |m| |=>| |m|↵|m| |=>| |#if| |(|h| |>| |m|)| |#then| |max|(|t|)|(|h|)| |#else| |max|(|t|)|(|m|)|←|↵|)|↵|(|m| |=>| |#if| |h| |>| |m| |#then| |max|(|t|)|(|h|)| |#else| |max|(|t|)|(|m|)|)|←|↵|)|↵|(|m| |=>| |#if| |(|h| |>| |m|)| |#then| |max|(|t|)|(|h|)| |#else| |max|(|t|)|(|m|)|)|←|↵|)|(|0|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun max = x, => x; max (let h = 1 in let t = '(' let h = 3 in let t = '(' let h = 2 in let t = m, => m in m, => if ('(' > (h,) (m,), ')') then max (t,) (h,) else max (t,) (m,), ')' in '(' m, => if (> (h,) (m,)) then max (t,) (h,) else max (t,) (m,), ')', ')' in '(' m, => if ('(' > (h,) (m,), ')') then max (t,) (h,) else max (t,) (m,), ')',) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ max^3(
//│ 	let h⁰ = 1
//│ 	in let t⁰ = 	
//│ 		let h¹ = 3
//│ 		in let t¹ = 	
//│ 			let h² = 2
//│ 			in let t² = (fun m⁰ -> m⁰)
//│ 			in (fun m¹ -> if (h² > m¹) then max^14(t², h²) else max^19(t², m¹))
//│ 		in (fun m² -> if (h¹ > m²) then max^33(t¹, h¹) else max^38(t¹, m²))
//│ 	in (fun m³ -> if (h⁰ > m³) then max^52(t⁰, h⁰) else max^57(t⁰, m³)), 0)
//│ def max(x⁰) = x⁰
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 3
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ max(
//│ 	let h³ = 1
//│ 	in let t³ = 	
//│ 		let h⁴ = 3
//│ 		in let t⁴ = 	
//│ 			let h⁵ = 2
//│ 			in let t⁵ = (fun m⁴ -> m⁴)
//│ 			in (fun m⁵ -> if (h⁵ > m⁵) then max(t⁵, h⁵) else max(t⁵, m⁵))
//│ 		in (fun m⁶ -> if (h⁴ > m⁶) then max(t⁴, h⁴) else max(t⁴, m⁶))
//│ 	in (fun m⁷ -> if (h³ > m⁷) then max(t³, h³) else max(t³, m⁷)), 0)
//│ def max(x¹) = x¹
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 3
//│ <<<<<<< evaluate <<<<<<<


// CORRECT:
// NOTE: if max is duplicated for each call site, less likely to timeout
fun max = y => y
fun max0 = x => x
fun max1 = x => x
fun max2 = x => x
fun max3 = x => x
fun max4 = x => x
fun max5 = x => x
max(
  let h = 1
  let t = (
    let h = 3
    let t = (
      let h = 2
      let t = m => m
      m => if (h > m) then max0(t)(h) else max1(t)(m)
    )
    (m => if h > m then max2(t)(h) else max3(t)(m))
  )
  (m => if (h > m) then max4(t)(h) else max5(t)(m))
)(0)
//│ |#fun| |max| |#=| |y| |=>| |y|↵|#fun| |max0| |#=| |x| |=>| |x|↵|#fun| |max1| |#=| |x| |=>| |x|↵|#fun| |max2| |#=| |x| |=>| |x|↵|#fun| |max3| |#=| |x| |=>| |x|↵|#fun| |max4| |#=| |x| |=>| |x|↵|#fun| |max5| |#=| |x| |=>| |x|↵|max|(|→|#let| |h| |#=| |1|↵|#let| |t| |#=| |(|→|#let| |h| |#=| |3|↵|#let| |t| |#=| |(|→|#let| |h| |#=| |2|↵|#let| |t| |#=| |m| |=>| |m|↵|m| |=>| |#if| |(|h| |>| |m|)| |#then| |max0|(|t|)|(|h|)| |#else| |max1|(|t|)|(|m|)|←|↵|)|↵|(|m| |=>| |#if| |h| |>| |m| |#then| |max2|(|t|)|(|h|)| |#else| |max3|(|t|)|(|m|)|)|←|↵|)|↵|(|m| |=>| |#if| |(|h| |>| |m|)| |#then| |max4|(|t|)|(|h|)| |#else| |max5|(|t|)|(|m|)|)|←|↵|)|(|0|)|
//│ Parsed: {fun max = y, => y; fun max0 = x, => x; fun max1 = x, => x; fun max2 = x, => x; fun max3 = x, => x; fun max4 = x, => x; fun max5 = x, => x; max (let h = 1 in let t = '(' let h = 3 in let t = '(' let h = 2 in let t = m, => m in m, => if ('(' > (h,) (m,), ')') then max0 (t,) (h,) else max1 (t,) (m,), ')' in '(' m, => if (> (h,) (m,)) then max2 (t,) (h,) else max3 (t,) (m,), ')', ')' in '(' m, => if ('(' > (h,) (m,), ')') then max4 (t,) (h,) else max5 (t,) (m,), ')',) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ max^15(
//│ 	let h⁰ = 1
//│ 	in let t⁰ = 	
//│ 		let h¹ = 3
//│ 		in let t¹ = 	
//│ 			let h² = 2
//│ 			in let t² = (fun m⁰ -> m⁰)
//│ 			in (fun m¹ -> if (h² > m¹) then max0^26(t², h²) else max1^31(t², m¹))
//│ 		in (fun m² -> if (h¹ > m²) then max2^45(t¹, h¹) else max3^50(t¹, m²))
//│ 	in (fun m³ -> if (h⁰ > m³) then max4^64(t⁰, h⁰) else max5^69(t⁰, m³)), 0)
//│ def max(y⁰) = y⁰
//│ def max0(x⁰) = x⁰
//│ def max1(x¹) = x¹
//│ def max2(x²) = x²
//│ def max3(x³) = x³
//│ def max4(x⁴) = x⁴
//│ def max5(x⁵) = x⁵
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ max(
//│ 	let h³ = 1
//│ 	in let t³ = 	
//│ 		let h⁴ = 3
//│ 		in let t⁴ = 	
//│ 			let h⁵ = 2
//│ 			in let t⁵ = (fun m⁴ -> m⁴)
//│ 			in (fun m⁵ -> if (h⁵ > m⁵) then max0(t⁵, h⁵) else max1(t⁵, m⁵))
//│ 		in (fun m⁶ -> if (h⁴ > m⁶) then max2(t⁴, h⁴) else max3(t⁴, m⁶))
//│ 	in (fun m⁷ -> if (h³ > m⁷) then max4(t³, h³) else max5(t³, m⁷)), 0)
//│ def max(y¹) = y¹
//│ def max0(x¹⁰) = x¹⁰
//│ def max1(x⁶) = x⁶
//│ def max2(x⁸) = x⁸
//│ def max3(x⁹) = x⁹
//│ def max4(x⁷) = x⁷
//│ def max5(x¹¹) = x¹¹
//│ <<<<<<< after fusion <<<<<<<

// infinite list
fun max(ms) = if ms is
  C(h, t) then m => if h > m then max(t)(h) else max(t)(m)
  N then m => m
let l = C(1, C(3, C(2, C(5, l))))
max(l)(0)
//│ |#fun| |max|(|ms|)| |#=| |#if| |ms| |is|→|C|(|h|,| |t|)| |#then| |m| |=>| |#if| |h| |>| |m| |#then| |max|(|t|)|(|h|)| |#else| |max|(|t|)|(|m|)|↵|N| |#then| |m| |=>| |m|←|↵|#let| |l| |#=| |C|(|1|,| |C|(|3|,| |C|(|2|,| |C|(|5|,| |l|)|)|)|)|↵|max|(|l|)|(|0|)|
//│ Parsed: {fun max = ms, => if ms is ‹(C (h, t,)) then m, => if (> (h,) (m,)) then max (t,) (h,) else max (t,) (m,); (N) then m, => m›; let l = C (1, C (3, C (2, C (5, l,),),),); max (l,) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ max^32(l^33, 0)
//│ def l = [C 1 [C 3 [C 2 [C 5 l^27]]]]
//│ def max(ms⁰) = case ms⁰ of {
//│ 	C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max^7(t⁰, h⁰) else max^12(t⁰, m⁰))
//│ 	| N  => (fun m¹ -> m¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 5 l]: 28 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ [C 2 [C 5 l]]: 29 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ [C 3 [C 2 [C 5 l]]]: 30 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ [C 1 [C 3 [C 2 [C 5 l]]]]: 31 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ ------------------
//│ case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21 --->
//│ 	[C 5 l]: 28
//│ 	[C 2 [C 5 l]]: 29
//│ 	[C 3 [C 2 [C 5 l]]]: 30
//│ 	[C 1 [C 3 [C 2 [C 5 l]]]]: 31
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 5 l]: 28 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ [C 2 [C 5 l]]: 29 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ [C 3 [C 2 [C 5 l]]]: 30 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ [C 1 [C 3 [C 2 [C 5 l]]]]: 31 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21
//│ ------------------
//│ case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> if (h⁰ > m⁰) then max(t⁰, h⁰) else max(t⁰, m⁰)) | N  => (fun m¹ -> m¹)}: 21 --->
//│ 	[C 5 l]: 28
//│ 	[C 2 [C 5 l]]: 29
//│ 	[C 3 [C 2 [C 5 l]]]: 30
//│ 	[C 1 [C 3 [C 2 [C 5 l]]]]: 31
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ max(l, 0)
//│ def l = 
//│ 	let t¹ = 	
//│ 		let t² = 	
//│ 			let t³ = 	
//│ 				let t⁴ = l
//│ 				in let h⁴ = 5
//│ 				in (fun m⁵ -> if (h⁴ > m⁵) then max(t⁴, h⁴) else max(t⁴, m⁵))
//│ 			in let h³ = 2
//│ 			in (fun m⁴ -> if (h³ > m⁴) then max(t³, h³) else max(t³, m⁴))
//│ 		in let h² = 3
//│ 		in (fun m³ -> if (h² > m³) then max(t², h²) else max(t², m³))
//│ 	in let h¹ = 1
//│ 	in (fun m² -> if (h¹ > m²) then max(t¹, h¹) else max(t¹, m²))
//│ def max(ms¹) = ms¹
//│ <<<<<<< after fusion <<<<<<<
