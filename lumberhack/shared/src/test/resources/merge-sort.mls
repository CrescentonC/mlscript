:NewParser
:ParseOnly

// WRONG: cannot be fused
:lhEval
fun firsts(xs) = if xs is
  N then N
  C(h, t) then if t is
    N then C(h, N)
    C(hh, tt) then C(h, firsts(tt))
fun seconds(xs) = if xs is
  N then N
  C(h, t) then if t is
    N then N
    C(hh, tt) then C(hh, seconds(tt))
fun merge(xs, ys) = if xs is
  N then ys
  C(hx, tx) then if ys is
    N then xs
    C(hy, ty) then if hy > hx then C(hx, merge(tx, ys)) else C(hy, merge(xs, ty))
fun msort(ls) = if ls is
  N then N
  C(h, t) then if t is
    N then C(h, N)
    C(hh, tt) then merge(msort(firsts(ls)), msort(seconds(ls)))
msort(primId(C(2, C(1, C(3, N)))))
//│ |#fun| |firsts|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |N|↵|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |C|(|h|,| |N|)|↵|C|(|hh|,| |tt|)| |#then| |C|(|h|,| |firsts|(|tt|)|)|←|←|↵|#fun| |seconds|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |N|↵|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |N|↵|C|(|hh|,| |tt|)| |#then| |C|(|hh|,| |seconds|(|tt|)|)|←|←|↵|#fun| |merge|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|hx|,| |tx|)| |#then| |#if| |ys| |is|→|N| |#then| |xs|↵|C|(|hy|,| |ty|)| |#then| |#if| |hy| |>| |hx| |#then| |C|(|hx|,| |merge|(|tx|,| |ys|)|)| |#else| |C|(|hy|,| |merge|(|xs|,| |ty|)|)|←|←|↵|#fun| |msort|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |C|(|h|,| |N|)|↵|C|(|hh|,| |tt|)| |#then| |merge|(|msort|(|firsts|(|ls|)|)|,| |msort|(|seconds|(|ls|)|)|)|←|←|↵|msort|(|primId|(|C|(|2|,| |C|(|1|,| |C|(|3|,| |N|)|)|)|)|)|
//│ Parsed: {fun firsts = xs, => if xs is ‹(N) then N; (C (h, t,)) then if t is ‹(N) then C (h, N,); (C (hh, tt,)) then C (h, firsts (tt,),)››; fun seconds = xs, => if xs is ‹(N) then N; (C (h, t,)) then if t is ‹(N) then N; (C (hh, tt,)) then C (hh, seconds (tt,),)››; fun merge = xs, ys, => if xs is ‹(N) then ys; (C (hx, tx,)) then if ys is ‹(N) then xs; (C (hy, ty,)) then if (> (hy,) (hx,)) then C (hx, merge (tx, ys,),) else C (hy, merge (xs, ty,),)››; fun msort = ls, => if ls is ‹(N) then N; (C (h, t,)) then if t is ‹(N) then C (h, N,); (C (hh, tt,)) then merge (msort (firsts (ls,),), msort (seconds (ls,),),)››; msort (primId (C (2, C (1, C (3, N,),),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ msort^77(primId⁰([C 2 [C 1 [C 3 [N]]]]))
//│ def firsts(xs⁰) = case xs⁰ of {
//│ 	N  => [N]
//│ 	| C h⁰ t⁰ => case t⁰ of {
//│ 		N  => [C h⁰ [N]]
//│ 		| C hh⁰ tt⁰ => [C h⁰ firsts^8(tt⁰)]}}
//│ def merge(xs², ys⁰) = case xs² of {
//│ 	N  => ys⁰
//│ 	| C hx⁰ tx⁰ => case ys⁰ of {
//│ 		N  => xs²
//│ 		| C hy⁰ ty⁰ => if (hy⁰ > hx⁰) then [C hx⁰ merge^37(tx⁰, ys⁰)] else [C hy⁰ merge^44(xs², ty⁰)]}}
//│ def msort(ls⁰) = case ls⁰ of {
//│ 	N  => [N]
//│ 	| C h² t² => case t² of {
//│ 		N  => [C h² [N]]
//│ 		| C hh² tt² => merge^61(msort^62(firsts^63(ls⁰)), msort^68(seconds^69(ls⁰)))}}
//│ def seconds(xs¹) = case xs¹ of {
//│ 	N  => [N]
//│ 	| C h¹ t¹ => case t¹ of {
//│ 		N  => [N]
//│ 		| C hh¹ tt¹ => [C hh¹ seconds^20(tt¹)]}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 2 --->
//│ 	DeadCodeCons
//│ 	case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}: 12
//│ 	case xs⁰ of {N  => [N] | C h⁰ t⁰ => case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}}: 13
//│ 	case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}: 24
//│ 	case xs¹ of {N  => [N] | C h¹ t¹ => case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}}: 25
//│ 	case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}: 74
//│ 	case ls⁰ of {N  => [N] | C h² t² => case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}}: 75
//│ [N]: 5 --->
//│ 	DeadCodeCons
//│ 	case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}: 12
//│ 	case xs⁰ of {N  => [N] | C h⁰ t⁰ => case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}}: 13
//│ 	case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}: 24
//│ 	case xs¹ of {N  => [N] | C h¹ t¹ => case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}}: 25
//│ 	case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}: 74
//│ [C h⁰ [N]]: 6 --->
//│ 	DeadCodeCons
//│ 	case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}: 12
//│ 	case xs⁰ of {N  => [N] | C h⁰ t⁰ => case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}}: 13
//│ 	case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}: 24
//│ 	case xs¹ of {N  => [N] | C h¹ t¹ => case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}}: 25
//│ 	case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}: 74
//│ 	case ls⁰ of {N  => [N] | C h² t² => case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}}: 75
//│ [C h⁰ firsts(tt⁰)]: 11 --->
//│ 	DeadCodeCons
//│ 	case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}: 12
//│ 	case xs⁰ of {N  => [N] | C h⁰ t⁰ => case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}}: 13
//│ 	case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}: 24
//│ 	case xs¹ of {N  => [N] | C h¹ t¹ => case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}}: 25
//│ 	case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}: 74
//│ 	case ls⁰ of {N  => [N] | C h² t² => case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}}: 75
//│ [N]: 16 --->
//│ 	DeadCodeCons
//│ 	case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}: 12
//│ 	case xs⁰ of {N  => [N] | C h⁰ t⁰ => case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}}: 13
//│ 	case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}: 24
//│ 	case xs¹ of {N  => [N] | C h¹ t¹ => case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}}: 25
//│ 	case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}: 74
//│ 	case ls⁰ of {N  => [N] | C h² t² => case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}}: 75
//│ [N]: 18 --->
//│ 	DeadCodeCons
//│ 	case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}: 12
//│ 	case xs⁰ of {N  => [N] | C h⁰ t⁰ => case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}}: 13
//│ 	case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}: 24
//│ 	case xs¹ of {N  => [N] | C h¹ t¹ => case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}}: 25
//│ 	case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}: 74
//│ 	case ls⁰ of {N  => [N] | C h² t² => case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}}: 75
//│ [C hh¹ seconds(tt¹)]: 23 --->
//│ 	DeadCodeCons
//│ 	case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}: 12
//│ 	case xs⁰ of {N  => [N] | C h⁰ t⁰ => case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}}: 13
//│ 	case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}: 24
//│ 	case xs¹ of {N  => [N] | C h¹ t¹ => case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}}: 25
//│ 	case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}: 74
//│ 	case ls⁰ of {N  => [N] | C h² t² => case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}}: 75
//│ [C hx⁰ merge(tx⁰, ys⁰)]: 42 --->
//│ 	NoCons
//│ 	case ys⁰ of {N  => xs² | C hy⁰ ty⁰ => if (hy⁰ > hx⁰) then [C hx⁰ merge(tx⁰, ys⁰)] else [C hy⁰ merge(xs², ty⁰)]}: 51
//│ 	case xs² of {N  => ys⁰ | C hx⁰ tx⁰ => case ys⁰ of {N  => xs² | C hy⁰ ty⁰ => if (hy⁰ > hx⁰) then [C hx⁰ merge(tx⁰, ys⁰)] else [C hy⁰ merge(xs², ty⁰)]}}: 52
//│ [C hy⁰ merge(xs², ty⁰)]: 49 --->
//│ 	NoCons
//│ 	case ys⁰ of {N  => xs² | C hy⁰ ty⁰ => if (hy⁰ > hx⁰) then [C hx⁰ merge(tx⁰, ys⁰)] else [C hy⁰ merge(xs², ty⁰)]}: 51
//│ 	case xs² of {N  => ys⁰ | C hx⁰ tx⁰ => case ys⁰ of {N  => xs² | C hy⁰ ty⁰ => if (hy⁰ > hx⁰) then [C hx⁰ merge(tx⁰, ys⁰)] else [C hy⁰ merge(xs², ty⁰)]}}: 52
//│ [N]: 56 --->
//│ 	NoCons
//│ 	case ys⁰ of {N  => xs² | C hy⁰ ty⁰ => if (hy⁰ > hx⁰) then [C hx⁰ merge(tx⁰, ys⁰)] else [C hy⁰ merge(xs², ty⁰)]}: 51
//│ 	case xs² of {N  => ys⁰ | C hx⁰ tx⁰ => case ys⁰ of {N  => xs² | C hy⁰ ty⁰ => if (hy⁰ > hx⁰) then [C hx⁰ merge(tx⁰, ys⁰)] else [C hy⁰ merge(xs², ty⁰)]}}: 52
//│ [N]: 59 --->
//│ 	NoCons
//│ 	case ys⁰ of {N  => xs² | C hy⁰ ty⁰ => if (hy⁰ > hx⁰) then [C hx⁰ merge(tx⁰, ys⁰)] else [C hy⁰ merge(xs², ty⁰)]}: 51
//│ 	case xs² of {N  => ys⁰ | C hx⁰ tx⁰ => case ys⁰ of {N  => xs² | C hy⁰ ty⁰ => if (hy⁰ > hx⁰) then [C hx⁰ merge(tx⁰, ys⁰)] else [C hy⁰ merge(xs², ty⁰)]}}: 52
//│ [C h² [N]]: 60 --->
//│ 	NoCons
//│ 	case ys⁰ of {N  => xs² | C hy⁰ ty⁰ => if (hy⁰ > hx⁰) then [C hx⁰ merge(tx⁰, ys⁰)] else [C hy⁰ merge(xs², ty⁰)]}: 51
//│ 	case xs² of {N  => ys⁰ | C hx⁰ tx⁰ => case ys⁰ of {N  => xs² | C hy⁰ ty⁰ => if (hy⁰ > hx⁰) then [C hx⁰ merge(tx⁰, ys⁰)] else [C hy⁰ merge(xs², ty⁰)]}}: 52
//│ ------------------
//│ case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}: 12 --->
//│ 	NoProd
//│ 	[N]: 2
//│ 	[N]: 5
//│ 	[C h⁰ [N]]: 6
//│ 	[C h⁰ firsts(tt⁰)]: 11
//│ 	[N]: 16
//│ 	[N]: 18
//│ 	[C hh¹ seconds(tt¹)]: 23
//│ case xs⁰ of {N  => [N] | C h⁰ t⁰ => case t⁰ of {N  => [C h⁰ [N]] | C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}}: 13 --->
//│ 	NoProd
//│ 	[N]: 2
//│ 	[N]: 5
//│ 	[C h⁰ [N]]: 6
//│ 	[C h⁰ firsts(tt⁰)]: 11
//│ 	[N]: 16
//│ 	[N]: 18
//│ 	[C hh¹ seconds(tt¹)]: 23
//│ case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}: 24 --->
//│ 	NoProd
//│ 	[N]: 2
//│ 	[N]: 5
//│ 	[C h⁰ [N]]: 6
//│ 	[C h⁰ firsts(tt⁰)]: 11
//│ 	[N]: 16
//│ 	[N]: 18
//│ 	[C hh¹ seconds(tt¹)]: 23
//│ case xs¹ of {N  => [N] | C h¹ t¹ => case t¹ of {N  => [N] | C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}}: 25 --->
//│ 	NoProd
//│ 	[N]: 2
//│ 	[N]: 5
//│ 	[C h⁰ [N]]: 6
//│ 	[C h⁰ firsts(tt⁰)]: 11
//│ 	[N]: 16
//│ 	[N]: 18
//│ 	[C hh¹ seconds(tt¹)]: 23
//│ case ys⁰ of {N  => xs² | C hy⁰ ty⁰ => if (hy⁰ > hx⁰) then [C hx⁰ merge(tx⁰, ys⁰)] else [C hy⁰ merge(xs², ty⁰)]}: 51 --->
//│ 	[C hx⁰ merge(tx⁰, ys⁰)]: 42
//│ 	[C hy⁰ merge(xs², ty⁰)]: 49
//│ 	[N]: 56
//│ 	[N]: 59
//│ 	[C h² [N]]: 60
//│ case xs² of {N  => ys⁰ | C hx⁰ tx⁰ => case ys⁰ of {N  => xs² | C hy⁰ ty⁰ => if (hy⁰ > hx⁰) then [C hx⁰ merge(tx⁰, ys⁰)] else [C hy⁰ merge(xs², ty⁰)]}}: 52 --->
//│ 	[C hx⁰ merge(tx⁰, ys⁰)]: 42
//│ 	[C hy⁰ merge(xs², ty⁰)]: 49
//│ 	[N]: 56
//│ 	[N]: 59
//│ 	[C h² [N]]: 60
//│ case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}: 74 --->
//│ 	NoProd
//│ 	[N]: 2
//│ 	[N]: 5
//│ 	[C h⁰ [N]]: 6
//│ 	[C h⁰ firsts(tt⁰)]: 11
//│ 	[N]: 16
//│ 	[N]: 18
//│ 	[C hh¹ seconds(tt¹)]: 23
//│ case ls⁰ of {N  => [N] | C h² t² => case t² of {N  => [C h² [N]] | C hh² tt² => merge(msort(firsts(ls⁰)), msort(seconds(ls⁰)))}}: 75 --->
//│ 	NoProd
//│ 	[N]: 2
//│ 	[C h⁰ [N]]: 6
//│ 	[C h⁰ firsts(tt⁰)]: 11
//│ 	[N]: 16
//│ 	[N]: 18
//│ 	[C hh¹ seconds(tt¹)]: 23
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ msort(primId⁰([C 2 [C 1 [C 3 [N]]]]))
//│ def firsts(xs³) = case xs³ of {
//│ 	N  => [N]
//│ 	| C h⁰ t⁰ => case t⁰ of {
//│ 		N  => [C h⁰ [N]]
//│ 		| C hh⁰ tt⁰ => [C h⁰ firsts(tt⁰)]}}
//│ def merge(xs⁵, ys¹) = case xs⁵ of {
//│ 	N  => ys¹
//│ 	| C hx⁰ tx⁰ => case ys¹ of {
//│ 		N  => xs⁵
//│ 		| C hy⁰ ty⁰ => if (hy⁰ > hx⁰) then [C hx⁰ merge(tx⁰, ys¹)] else [C hy⁰ merge(xs⁵, ty⁰)]}}
//│ def msort(ls¹) = case ls¹ of {
//│ 	N  => [N]
//│ 	| C h² t² => case t² of {
//│ 		N  => [C h² [N]]
//│ 		| C hh² tt² => merge(msort(firsts(ls¹)), msort(seconds(ls¹)))}}
//│ def seconds(xs⁴) = case xs⁴ of {
//│ 	N  => [N]
//│ 	| C h¹ t¹ => case t¹ of {
//│ 		N  => [N]
//│ 		| C hh¹ tt¹ => [C hh¹ seconds(tt¹)]}}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [N]]]]
//│ <<<<<<< evaluate <<<<<<<


// :lhInHaskell
// merge [] ys = ys
// merge xs [] = xs
// merge (hx:tx) (hy:ty) = if hy > hx then (hx:(merge tx (hy:ty))) else (hy:(merge (hx:tx) ty))
// msort [] = []
// msort (h:[]) = [h]
// msort ls = merge (msort $ firsts ls) (msort $ seconds ls)
// firsts [] = []
// firsts (h:[]) = [h]
// firsts (h:hh:t) = h:(firsts t)
// seconds [] = []
// seconds (h:[]) = []
// seconds (h:hh:t) = hh:(seconds t)
// msort [1,3,2]


