:NewParser
:ParseOnly


// CORRECT: resolved by add lazy to and remove unused let bindings introduced by deforestation 
:lhInHaskell
head $ [1..3]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ head_lh_₁^26(enumFromTo_lh_₁^27(1, 3))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^12((a⁰ + 1), b⁰)] else [LH_N]
//│ def head_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => h⁰
//│ 	| LH_N  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 21 --->
//│ 	DeadCodeCons
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => h⁰ | LH_N  => error⁰}: 4
//│ [LH_N]: 22 --->
//│ 	DeadCodeCons
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => h⁰ | LH_N  => error⁰}: 4
//│ ------------------
//│ case ls⁰ of {LH_C h⁰ t⁰ => h⁰ | LH_N  => error⁰}: 4 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 21
//│ 	[LH_N]: 22
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ head_lh_₁(enumFromTo_lh_₁(1, 3))
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then [LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b¹)] else [LH_N]
//│ def head_lh_₁(ls¹) = case ls¹ of {
//│ 	LH_C h⁰ t⁰ => h⁰
//│ 	| LH_N  => error⁰}
//│ <<<<<<< after fusion <<<<<<<


// WRONG:
:lhInHaskell
head ([1] ++ [])
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ head_lh_₁^18(mappend_lh_₁^19([LH_C 1 [LH_N]], [LH_N]))
//│ def head_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h¹ t¹ => h¹
//│ 	| LH_N  => error⁰}
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁^3(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8 --->
//│ 	DeadCodeCons
//│ 	case ls⁰ of {LH_C h¹ t¹ => h¹ | LH_N  => error⁰}: 16
//│ [LH_N]: 21 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C 1 [LH_N]]: 22 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_N]: 24 --->
//│ 	DeadCodeCons
//│ 	case ls⁰ of {LH_C h¹ t¹ => h¹ | LH_N  => error⁰}: 16
//│ ------------------
//│ case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10 --->
//│ 	[LH_N]: 21
//│ 	[LH_C 1 [LH_N]]: 22
//│ case ls⁰ of {LH_C h¹ t¹ => h¹ | LH_N  => error⁰}: 16 --->
//│ 	[LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8
//│ 	[LH_N]: 24
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_N]: 21 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C 1 [LH_N]]: 22 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10 --->
//│ 	[LH_N]: 21
//│ 	[LH_C 1 [LH_N]]: 22
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ head_lh_₁(mappend_lh_₁(
//│ 	let t² = (fun ys² -> ys²)
//│ 	in let h² = 1
//│ 	in (fun ys¹ -> [LH_C h² mappend_lh_₁(t², ys¹)]), [LH_N]))
//│ def head_lh_₁(ls¹) = case ls¹ of {
//│ 	LH_C h¹ t¹ => h¹
//│ 	| LH_N  => error⁰}
//│ def mappend_lh_₁(xs¹, ys³) = xs¹(ys³)
//│ <<<<<<< after fusion <<<<<<<


// WRONG:
:lhInHaskell
f a b = if True then a else b
head $ f [1] []
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ head_lh_₁^12(f_lh_₁^13([LH_C 1 [LH_N]], [LH_N]))
//│ def f_lh_₁(_lh_f_arg1⁰, _lh_f_arg2⁰) = if [True] then _lh_f_arg1⁰ else _lh_f_arg2⁰
//│ def head_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => h⁰
//│ 	| LH_N  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C 1 [LH_N]]: 16 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => h⁰ | LH_N  => error⁰}: 10
//│ [LH_N]: 18 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => h⁰ | LH_N  => error⁰}: 10
//│ ------------------
//│ case ls⁰ of {LH_C h⁰ t⁰ => h⁰ | LH_N  => error⁰}: 10 --->
//│ 	[LH_C 1 [LH_N]]: 16
//│ 	[LH_N]: 18
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C 1 [LH_N]]: 16 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => h⁰ | LH_N  => error⁰}: 10
//│ [LH_N]: 18 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => h⁰ | LH_N  => error⁰}: 10
//│ ------------------
//│ case ls⁰ of {LH_C h⁰ t⁰ => h⁰ | LH_N  => error⁰}: 10 --->
//│ 	[LH_C 1 [LH_N]]: 16
//│ 	[LH_N]: 18
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ head_lh_₁(f_lh_₁(
//│ 	let h¹ = 1
//│ 	in (fun _lh_dummy⁰ -> h¹), (fun _lh_dummy¹ -> error⁰)))
//│ def f_lh_₁(_lh_f_arg1¹, _lh_f_arg2¹) = if [True] then _lh_f_arg1¹ else _lh_f_arg2¹
//│ def head_lh_₁(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
