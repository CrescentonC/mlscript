:NewParser
:ParseOnly

fun p(x) =
  if x == 0 then N
  else
    if x >= 2 then C(p(x - 1))
    else
      let temp = C(p(x + 1))
      f(temp)
      temp
fun f(z) = if z is
  C(b) then b
  N then 1
fun c(xx) = if xx is
  C(aa) then primitive(aa)
  N then N
c(p(0))
//│ |#fun| |p|(|x|)| |#=|→|#if| |x| |==| |0| |#then| |N|↵|#else|→|#if| |x| |>=| |2| |#then| |C|(|p|(|x| |-| |1|)|)|↵|#else|→|#let| |temp| |#=| |C|(|p|(|x| |+| |1|)|)|↵|f|(|temp|)|↵|temp|←|←|←|↵|#fun| |f|(|z|)| |#=| |#if| |z| |is|→|C|(|b|)| |#then| |b|↵|N| |#then| |1|←|↵|#fun| |c|(|xx|)| |#=| |#if| |xx| |is|→|C|(|aa|)| |#then| |primitive|(|aa|)|↵|N| |#then| |N|←|↵|c|(|p|(|0|)|)|
//│ Parsed: {fun p = x, => {if (== (x,) (0,)) then N else {if (>= (x,) (2,)) then C (p (- (x,) (1,),),) else {let temp = C (p (+ (x,) (1,),),); f (temp,); temp}}}; fun f = z, => if z is ‹(C (b,)) then b; (N) then 1›; fun c = xx, => if xx is ‹(C (aa,)) then primitive (aa,); (N) then N›; c (p (0,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^49 (p^50 0))
//│ def c = (fun xx⁰ -> case xx⁰ of {
//│ 	C aa⁰ => (primitive⁰ aa⁰)
//│ 	| N => [N]})
//│ def f = (fun z⁰ -> case z⁰ of {
//│ 	C b⁰ => b⁰
//│ 	| N => 1})
//│ def p = (fun x⁰ -> if (x⁰ == 0) then [N] else if (x⁰ >= 2) then [C (p^12 (x⁰ - 1))] else 
//│ 	let temp⁰ = [C (p^20 (x⁰ + 1))]
//│ 	in (f^28 temp⁰)
//│ 	temp⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^49] (hopeless to continue)
//│ [p^50] (hopeless to continue)
//│ 	[p^50 · f^28] (using original def)
//│ 	[p^50 · p^12] ---> [p^50] (using original def)
//│ 	[p^50 · p^20] ---> [p^50] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C (p₀ (x¹ + 1))] --->
//│ 	case xx¹ of {C aa¹ => (primitive⁰ aa¹) | N => [N]}
//│ 	case z¹ of {C b¹ => b¹ | N => 1}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C (p₀ (x¹ - 1))] --->
//│ 	case xx¹ of {C aa¹ => (primitive⁰ aa¹) | N => [N]}
//│ [N] --->
//│ 	case xx¹ of {C aa¹ => (primitive⁰ aa¹) | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ (p₀ 0))
//│ def c₀ = 
//│ 	(fun xx¹ -> xx¹)
//│ def p₀ = 
//│ 	(fun x¹ -> if (x¹ == 0) then [N] else if (x¹ >= 2) then 
//│ 		let aa¹ = (p₀ (x¹ - 1))
//│ 		in (primitive⁰ aa¹) else 
//│ 		let temp¹ = 	
//│ 			let b¹ = (p₀ (x¹ + 1))
//│ 			in b¹
//│ 		in (f₀ temp¹)
//│ 		temp¹)
//│ 	where
//│ 	def f₀ = 
//│ 		(fun z¹ -> z¹)
//│ <<<<<<< after fusion <<<<<<<

