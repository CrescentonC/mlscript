:NewParser
:ParseOnly

fun p(x) =
  if x == 0 then N
  else
    if x >= 2 then C(p(x - 1))
    else
      let temp = C(p(x + 1))
      f(temp)
      temp
fun f(z) = if z is
  C(b) then b
  N then 1
fun c(xx) = if xx is
  C(aa) then primitive(aa)
  N then N
c(p(0))
//│ |#fun| |p|(|x|)| |#=|→|#if| |x| |==| |0| |#then| |N|↵|#else|→|#if| |x| |>=| |2| |#then| |C|(|p|(|x| |-| |1|)|)|↵|#else|→|#let| |temp| |#=| |C|(|p|(|x| |+| |1|)|)|↵|f|(|temp|)|↵|temp|←|←|←|↵|#fun| |f|(|z|)| |#=| |#if| |z| |is|→|C|(|b|)| |#then| |b|↵|N| |#then| |1|←|↵|#fun| |c|(|xx|)| |#=| |#if| |xx| |is|→|C|(|aa|)| |#then| |primitive|(|aa|)|↵|N| |#then| |N|←|↵|c|(|p|(|0|)|)|
//│ Parsed: {fun p = x, => {if (== (x,) (0,)) then N else {if (>= (x,) (2,)) then C (p (- (x,) (1,),),) else {let temp = C (p (+ (x,) (1,),),); f (temp,); temp}}}; fun f = z, => if z is ‹(C (b,)) then b; (N) then 1›; fun c = xx, => if xx is ‹(C (aa,)) then primitive (aa,); (N) then N›; c (p (0,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^49(p^50(0))
//│ def c(xx⁰) = case xx⁰ of {
//│ 	C aa⁰ => primitive⁰(aa⁰)
//│ 	| N  => [N]}
//│ def f(z⁰) = case z⁰ of {
//│ 	C b⁰ => b⁰
//│ 	| N  => 1}
//│ def p(x⁰) = if (x⁰ == 0) then [N] else if (x⁰ >= 2) then [C p^12((x⁰ - 1))] else 
//│ 	let temp⁰ = [C p^20((x⁰ + 1))]
//│ 	in f^28(temp⁰)
//│ 	temp⁰
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 6 --->
//│ 	NoCons
//│ 	DeadCodeCons
//│ 	case xx⁰ of {C aa⁰ => primitive⁰(aa⁰) | N  => [N]}: 47
//│ [C p((x⁰ - 1))]: 19 --->
//│ 	NoCons
//│ 	DeadCodeCons
//│ 	case xx⁰ of {C aa⁰ => primitive⁰(aa⁰) | N  => [N]}: 47
//│ [C p((x⁰ + 1))]: 27 --->
//│ 	DeadCodeCons
//│ 	NoCons
//│ 	case z⁰ of {C b⁰ => b⁰ | N  => 1}: 40
//│ 	case xx⁰ of {C aa⁰ => primitive⁰(aa⁰) | N  => [N]}: 47
//│ ------------------
//│ case z⁰ of {C b⁰ => b⁰ | N  => 1}: 40 --->
//│ 	[C p((x⁰ + 1))]: 27
//│ case xx⁰ of {C aa⁰ => primitive⁰(aa⁰) | N  => [N]}: 47 --->
//│ 	[N]: 6
//│ 	[C p((x⁰ - 1))]: 19
//│ 	[C p((x⁰ + 1))]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(p(0))
//│ def c(xx¹) = case xx¹ of {
//│ 	C aa⁰ => primitive⁰(aa⁰)
//│ 	| N  => [N]}
//│ def f(z¹) = case z¹ of {
//│ 	C b⁰ => b⁰
//│ 	| N  => 1}
//│ def p(x¹) = if (x¹ == 0) then [N] else if (x¹ >= 2) then [C p((x¹ - 1))] else 
//│ 	let temp¹ = [C p((x¹ + 1))]
//│ 	in f(temp¹)
//│ 	temp¹
//│ <<<<<<< after fusion <<<<<<<

// WRONG:
fun last(ls) = if ls is
  C(h, t) then if t is
    C(hh, tt) then Some(last(t))
    N then Some(h)
  N then None
last(C(A, C(B, N)))
//│ |#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|t|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|C|(|A|,| |C|(|B|,| |N|)|)|)|
//│ Parsed: {fun last = ls, => if ls is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then Some (last (t,),); (N) then Some (h,)›; (N) then None›; last (C (A, C (B, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ last^13([C [A] [C [B] [N]]])
//│ def last(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		C hh⁰ tt⁰ => [Some last^3(t⁰)]
//│ 		| N  => [Some h⁰]}
//│ 	| N  => [None]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 16 --->
//│ 	DeadCodeCons
//│ 	case t⁰ of {C hh⁰ tt⁰ => [Some last(t⁰)] | N  => [Some h⁰]}: 9
//│ 	case ls⁰ of {C h⁰ t⁰ => case t⁰ of {C hh⁰ tt⁰ => [Some last(t⁰)] | N  => [Some h⁰]} | N  => [None]}: 11
//│ [C [B] [N]]: 17 --->
//│ 	case t⁰ of {C hh⁰ tt⁰ => [Some last(t⁰)] | N  => [Some h⁰]}: 9
//│ 	case ls⁰ of {C h⁰ t⁰ => case t⁰ of {C hh⁰ tt⁰ => [Some last(t⁰)] | N  => [Some h⁰]} | N  => [None]}: 11
//│ [C [A] [C [B] [N]]]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case t⁰ of {C hh⁰ tt⁰ => [Some last(t⁰)] | N  => [Some h⁰]} | N  => [None]}: 11
//│ ------------------
//│ case t⁰ of {C hh⁰ tt⁰ => [Some last(t⁰)] | N  => [Some h⁰]}: 9 --->
//│ 	[N]: 16
//│ 	[C [B] [N]]: 17
//│ case ls⁰ of {C h⁰ t⁰ => case t⁰ of {C hh⁰ tt⁰ => [Some last(t⁰)] | N  => [Some h⁰]} | N  => [None]}: 11 --->
//│ 	[N]: 16
//│ 	[C [B] [N]]: 17
//│ 	[C [A] [C [B] [N]]]: 18
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ last([C [A] [C [B] [N]]])
//│ def last(ls¹) = case ls¹ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		C hh⁰ tt⁰ => [Some last(t⁰)]
//│ 		| N  => [Some h⁰]}
//│ 	| N  => [None]}
//│ <<<<<<< after fusion <<<<<<<

