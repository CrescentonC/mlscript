:NewParser
:ParseOnly

_LUMBERHACK_EVAL
fun zip(xs, ys) = if xs is
  C(hx, tx) then if ys is
    C(hy, ty) then C(P2(hx, hy), zip(tx, ty))
    N then N
  N then N
fun fromTo(a, b) = if a < (b + 1) then C(a, fromTo(a + 1, b)) else N
fun main(n) =
  zip(fromTo(1, n), fromTo(1 + 2, n + 2))
  n
main(3)
//│ |_LUMBERHACK_EVAL|↵|#fun| |zip|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|hx|,| |tx|)| |#then| |#if| |ys| |is|→|C|(|hy|,| |ty|)| |#then| |C|(|P2|(|hx|,| |hy|)|,| |zip|(|tx|,| |ty|)|)|↵|N| |#then| |N|←|↵|N| |#then| |N|←|↵|#fun| |fromTo|(|a|,| |b|)| |#=| |#if| |a| |<| |(|b| |+| |1|)| |#then| |C|(|a|,| |fromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |main|(|n|)| |#=|→|zip|(|fromTo|(|1|,| |n|)|,| |fromTo|(|1| |+| |2|,| |n| |+| |2|)|)|↵|n|←|↵|main|(|3|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun zip = xs, ys, => if xs is ‹(C (hx, tx,)) then if ys is ‹(C (hy, ty,)) then C (P2 (hx, hy,), zip (tx, ty,),); (N) then N›; (N) then N›; fun fromTo = a, b, => if (< (a,) (+ (b,) (1,),)) then C (a, fromTo (+ (a,) (1,), b,),) else N; fun main = n, => {zip (fromTo (1, n,), fromTo (+ (1,) (2,), + (n,) (2,),),); n}; main (3,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^66(3)
//│ def fromTo(a⁰, b⁰) = if (a⁰ < (b⁰ + 1)) then [C a⁰ fromTo^28((a⁰ + 1), b⁰)] else [N]
//│ def main(n⁰) = 
//│ 	zip^42(fromTo^43(1, n⁰), fromTo^49((1 + 2), (n⁰ + 2)))
//│ 	n⁰
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C hx⁰ tx⁰ => case ys⁰ of {
//│ 		C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip^6(tx⁰, ty⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 
//│ 	[C [P2 1 3] [C [P2 2 4] [C [P2 3 5] [N]]]]
//│ 	3
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a⁰ fromTo((a⁰ + 1), b⁰)]: 37 --->
//│ 	case ys⁰ of {C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)] | N  => [N]}: 13
//│ 	case xs⁰ of {C hx⁰ tx⁰ => case ys⁰ of {C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)] | N  => [N]} | N  => [N]}: 15
//│ [N]: 38 --->
//│ 	case ys⁰ of {C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)] | N  => [N]}: 13
//│ 	case xs⁰ of {C hx⁰ tx⁰ => case ys⁰ of {C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)] | N  => [N]} | N  => [N]}: 15
//│ ------------------
//│ case ys⁰ of {C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)] | N  => [N]}: 13 --->
//│ 	[C a⁰ fromTo((a⁰ + 1), b⁰)]: 37
//│ 	[N]: 38
//│ case xs⁰ of {C hx⁰ tx⁰ => case ys⁰ of {C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)] | N  => [N]} | N  => [N]}: 15 --->
//│ 	[C a⁰ fromTo((a⁰ + 1), b⁰)]: 37
//│ 	[N]: 38
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main(3)
//│ def fromTo(a¹, b¹) = if (a¹ < (b¹ + 1)) then [C a¹ fromTo((a¹ + 1), b¹)] else [N]
//│ def main(n¹) = 
//│ 	zip(fromTo(1, n¹), fromTo((1 + 2), (n¹ + 2)))
//│ 	n¹
//│ def zip(xs¹, ys¹) = case xs¹ of {
//│ 	C hx⁰ tx⁰ => case ys¹ of {
//│ 		C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 
//│ 	[C [P2 1 3] [C [P2 2 4] [C [P2 3 5] [N]]]]
//│ 	3
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ main(3)
//│ def fromTo(a⁰, b⁰) = if (a⁰ < (b⁰ + 1)) then [C a⁰ fromTo((a⁰ + 1), b⁰)] else [N]
//│ def main(n⁰) = 
//│ 	zip(fromTo(1, n⁰), fromTo((1 + 2), (n⁰ + 2)))
//│ 	n⁰
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C hx⁰ tx⁰ => case ys⁰ of {
//│ 		C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ main(3)
//│ def fromTo(a⁰, b⁰) = if (a⁰ < (b⁰ + 1)) then [C a⁰ fromTo((a⁰ + 1), b⁰)] else [N]
//│ def main(n⁰) = 
//│ 	zip(fromTo(1, n⁰), fromTo((1 + 2), (n⁰ + 2)))
//│ 	n⁰
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C hx⁰ tx⁰ => case ys⁰ of {
//│ 		C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<< after floating out <<<<<<<


_LUMBERHACK_EVAL
fun zip(xs, ys) = if xs is
  C(hx, tx) then if ys is
    C(hy, ty) then C(P2(hx, hy), zip(tx, ty))
    N then N
  N then N
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun mapZip(f, ls) = if ls is
  C(h, t) then C(f(h), mapZip(f, t))
  N then N
fun fp2(p) = if p is
  P2(a, b) then a + b
mapZip(
  fp2,
  zip(
    map(x => x + 1, primId(C(1, C(2, N)))),
    map(x => x + 2, primId(C(3, C(4, N))))
  )
)
//│ |_LUMBERHACK_EVAL|↵|#fun| |zip|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|hx|,| |tx|)| |#then| |#if| |ys| |is|→|C|(|hy|,| |ty|)| |#then| |C|(|P2|(|hx|,| |hy|)|,| |zip|(|tx|,| |ty|)|)|↵|N| |#then| |N|←|↵|N| |#then| |N|←|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapZip|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |mapZip|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |fp2|(|p|)| |#=| |#if| |p| |is|→|P2|(|a|,| |b|)| |#then| |a| |+| |b|←|↵|mapZip|(|→|fp2|,|↵|zip|(|→|map|(|x| |=>| |x| |+| |1|,| |primId|(|C|(|1|,| |C|(|2|,| |N|)|)|)|)|,|↵|map|(|x| |=>| |x| |+| |2|,| |primId|(|C|(|3|,| |C|(|4|,| |N|)|)|)|)|←|↵|)|←|↵|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun zip = xs, ys, => if xs is ‹(C (hx, tx,)) then if ys is ‹(C (hy, ty,)) then C (P2 (hx, hy,), zip (tx, ty,),); (N) then N›; (N) then N›; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun mapZip = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), mapZip (f, t,),); (N) then N›; fun fp2 = p, => if p is ‹(P2 (a, b,)) then + (a,) (b,)›; mapZip (fp2, zip (map (x, => + (x,) (1,), primId (C (1, C (2, N,),),),), map (x, => + (x,) (2,), primId (C (3, C (4, N,),),),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ mapZip^54(fp2^55, zip^57(map^58((fun x⁰ -> (x⁰ + 1)), primId⁰([C 1 [C 2 [N]]])), map^75((fun x¹ -> (x¹ + 2)), primId⁰([C 3 [C 4 [N]]]))))
//│ def fp2(p⁰) = case p⁰ of {
//│ 	P2 a⁰ b⁰ => (a⁰ + b⁰)}
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^22(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def mapZip(f¹, ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => [C f¹(h¹) mapZip^36(f¹, t¹)]
//│ 	| N  => [N]}
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C hx⁰ tx⁰ => case ys⁰ of {
//│ 		C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip^6(tx⁰, ty⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 7 [C 9 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [P2 hx⁰ hy⁰]: 5 --->
//│ 	case p⁰ of {P2 a⁰ b⁰ => (a⁰ + b⁰)}: 52
//│ [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)]: 11 --->
//│ 	case ls¹ of {C h¹ t¹ => [C f¹(h¹) mapZip(f¹, t¹)] | N  => [N]}: 43
//│ [N]: 12 --->
//│ 	case ls¹ of {C h¹ t¹ => [C f¹(h¹) mapZip(f¹, t¹)] | N  => [N]}: 43
//│ [N]: 14 --->
//│ 	case ls¹ of {C h¹ t¹ => [C f¹(h¹) mapZip(f¹, t¹)] | N  => [N]}: 43
//│ [C f⁰(h⁰) map(f⁰, t⁰)]: 27 --->
//│ 	case ys⁰ of {C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)] | N  => [N]}: 13
//│ 	case xs⁰ of {C hx⁰ tx⁰ => case ys⁰ of {C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)] | N  => [N]} | N  => [N]}: 15
//│ [N]: 28 --->
//│ 	case ys⁰ of {C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)] | N  => [N]}: 13
//│ 	case xs⁰ of {C hx⁰ tx⁰ => case ys⁰ of {C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)] | N  => [N]} | N  => [N]}: 15
//│ ------------------
//│ case ys⁰ of {C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)] | N  => [N]}: 13 --->
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 27
//│ 	[N]: 28
//│ case xs⁰ of {C hx⁰ tx⁰ => case ys⁰ of {C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)] | N  => [N]} | N  => [N]}: 15 --->
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 27
//│ 	[N]: 28
//│ case ls¹ of {C h¹ t¹ => [C f¹(h¹) mapZip(f¹, t¹)] | N  => [N]}: 43 --->
//│ 	[C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)]: 11
//│ 	[N]: 12
//│ 	[N]: 14
//│ case p⁰ of {P2 a⁰ b⁰ => (a⁰ + b⁰)}: 52 --->
//│ 	[P2 hx⁰ hy⁰]: 5
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [P2 hx⁰ hy⁰]: 5 --->
//│ 	case p⁰ of {P2 a⁰ b⁰ => (a⁰ + b⁰)}: 52
//│ [C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)]: 11 --->
//│ 	case ls¹ of {C h¹ t¹ => [C f¹(h¹) mapZip(f¹, t¹)] | N  => [N]}: 43
//│ [N]: 12 --->
//│ 	case ls¹ of {C h¹ t¹ => [C f¹(h¹) mapZip(f¹, t¹)] | N  => [N]}: 43
//│ [N]: 14 --->
//│ 	case ls¹ of {C h¹ t¹ => [C f¹(h¹) mapZip(f¹, t¹)] | N  => [N]}: 43
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C f¹(h¹) mapZip(f¹, t¹)] | N  => [N]}: 43 --->
//│ 	[C [P2 hx⁰ hy⁰] zip(tx⁰, ty⁰)]: 11
//│ 	[N]: 12
//│ 	[N]: 14
//│ case p⁰ of {P2 a⁰ b⁰ => (a⁰ + b⁰)}: 52 --->
//│ 	[P2 hx⁰ hy⁰]: 5
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ mapZip(fp2, zip(map((fun x² -> (x² + 1)), primId⁰([C 1 [C 2 [N]]])), map((fun x³ -> (x³ + 2)), primId⁰([C 3 [C 4 [N]]]))))
//│ def fp2(p¹) = p¹(99)
//│ def map(f⁵, ls²) = case ls² of {
//│ 	C h⁰ t⁰ => [C f⁵(h⁰) map(f⁵, t⁰)]
//│ 	| N  => [N]}
//│ def mapZip(f⁶, ls³) = ls³(f⁶)
//│ def zip(xs¹, ys¹) = case xs¹ of {
//│ 	C hx⁰ tx⁰ => case ys¹ of {
//│ 		C hy⁰ ty⁰ => 
//│ 			let t² = zip(tx⁰, ty⁰)
//│ 			in let h² = 	
//│ 				let b¹ = hy⁰
//│ 				in let a¹ = hx⁰
//│ 				in (fun _lh_dummy⁰ -> (a¹ + b¹))
//│ 			in (fun f² -> [C f²(h²) mapZip(f², t²)])
//│ 		| N  => (fun f³ -> [N])}
//│ 	| N  => (fun f⁴ -> [N])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 7 [C 9 [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ fp2, mapZip
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ zip -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ zip(map((fun x⁰ -> (x⁰ + 1)), primId⁰([C 1 [C 2 [N]]])), map((fun x¹ -> (x¹ + 2)), primId⁰([C 3 [C 4 [N]]])), fp2)
//│ def fp2(p⁰) = p⁰(99)
//│ def map(f³, ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => [C f³(h¹) map(f³, t¹)]
//│ 	| N  => [N]}
//│ def mapZip(f⁴, ls¹) = ls¹(f⁴)
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C hx⁰ tx⁰ => case ys⁰ of {
//│ 		C hy⁰ ty⁰ => 
//│ 			let t⁰ = zip(tx⁰, ty⁰)
//│ 			in let h⁰ = 	
//│ 				let b⁰ = hy⁰
//│ 				in let a⁰ = hx⁰
//│ 				in (fun _lh_dummy⁰ -> (a⁰ + b⁰))
//│ 			in (fun f⁰ -> [C f⁰(h⁰) t⁰(f⁰)])
//│ 		| N  => (fun f¹ -> [N])}
//│ 	| N  => (fun f² -> [N])}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ zip(map((fun x⁰ -> (x⁰ + 1)), primId⁰([C 1 [C 2 [N]]])), map((fun x¹ -> (x¹ + 2)), primId⁰([C 3 [C 4 [N]]])), fp2)
//│ def fp2(p⁰) = p⁰(99)
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => [C f⁰(h¹) map(f⁰, t¹)]
//│ 	| N  => [N]}
//│ def mapZip(f¹, ls¹) = ls¹(f¹)
//│ def zip(xs⁰, ys⁰, _lh_popOutId_0⁰) = case xs⁰ of {
//│ 	C hx⁰ tx⁰ => case ys⁰ of {
//│ 		C hy⁰ ty⁰ => 
//│ 			let t⁰ = zip(tx⁰, ty⁰)
//│ 			in let h⁰ = 	
//│ 				let b⁰ = hy⁰
//│ 				in let a⁰ = hx⁰
//│ 				in (fun _lh_dummy⁰ -> (a⁰ + b⁰))
//│ 			in [C _lh_popOutId_0⁰(h⁰) t⁰(_lh_popOutId_0⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<< after floating out <<<<<<<
