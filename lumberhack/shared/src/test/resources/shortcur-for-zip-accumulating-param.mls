:NewParser
:ParseOnly

_LUMBERHACK_EVAL
fun zip(xs, ys) = if xs is
  C(hx, tx) then if ys is
    C(hy, ty) then C(P2(hx, hy), zip(tx, ty))
    N then N
  N then N
fun fromTo(a, b) = if a < (b + 1) then C(a, fromTo(a + 1, b)) else N
fun main(n) =
  zip(fromTo(1, n), fromTo(1 + 2, n + 2))
  n
main(3)
//│ |_LUMBERHACK_EVAL|↵|#fun| |zip|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|hx|,| |tx|)| |#then| |#if| |ys| |is|→|C|(|hy|,| |ty|)| |#then| |C|(|P2|(|hx|,| |hy|)|,| |zip|(|tx|,| |ty|)|)|↵|N| |#then| |N|←|↵|N| |#then| |N|←|↵|#fun| |fromTo|(|a|,| |b|)| |#=| |#if| |a| |<| |(|b| |+| |1|)| |#then| |C|(|a|,| |fromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |main|(|n|)| |#=|→|zip|(|fromTo|(|1|,| |n|)|,| |fromTo|(|1| |+| |2|,| |n| |+| |2|)|)|↵|n|←|↵|main|(|3|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun zip = xs, ys, => if xs is ‹(C (hx, tx,)) then if ys is ‹(C (hy, ty,)) then C (P2 (hx, hy,), zip (tx, ty,),); (N) then N›; (N) then N›; fun fromTo = a, b, => if (< (a,) (+ (b,) (1,),)) then C (a, fromTo (+ (a,) (1,), b,),) else N; fun main = n, => {zip (fromTo (1, n,), fromTo (+ (1,) (2,), + (n,) (2,),),); n}; main (3,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^66(3)
//│ def fromTo(a⁰, b⁰) = if (a⁰ < (b⁰ + 1)) then [C a⁰ fromTo^28((a⁰ + 1), b⁰)] else [N]
//│ def main(n⁰) = 
//│ 	zip^42(fromTo^43(1, n⁰), fromTo^49((1 + 2), (n⁰ + 2)))
//│ 	n⁰
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C hx⁰ tx⁰ => case ys⁰ of {
//│ 		C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip^6(tx⁰, ty⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 
//│ 	[C [P2 1 3] [C [P2 2 4] [C [P2 3 5] [N]]]]
//│ 	3
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [main^66] (hopeless to continue)
//│ 	[main^66 · fromTo^43] (using original def)
//│ 		[main^66 · fromTo^43 · fromTo^28] ---> [main^66 · fromTo^43] (using original def)
//│ 	[main^66 · fromTo^49] (using original def)
//│ 		[main^66 · fromTo^49 · fromTo^28] ---> [main^66 · fromTo^49] (using original def)
//│ 	[main^66 · zip^42] (using original def)
//│ 		[main^66 · zip^42 · zip^6] ---> [main^66 · zip^42] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ main₀(3)
//│ def main₀(n¹) = 
//│ 	zip₀(fromTo₀(1, n¹), fromTo₁((1 + 2), (n¹ + 2)))
//│ 	n¹
//│ 	where
//│ 	def fromTo₀(a¹, b¹) = 
//│ 		if (a¹ < (b¹ + 1)) then [C a¹ fromTo₀((a¹ + 1), b¹)] else [N]
//│ 	def fromTo₁(a², b²) = 
//│ 		if (a² < (b² + 1)) then [C a² fromTo₁((a² + 1), b²)] else [N]
//│ 	def zip₀(xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			C hx¹ tx¹ => case ys¹ of {
//│ 				C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)]
//│ 				| N  => [N]}
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a¹ fromTo₀((a¹ + 1), b¹)]: 112 --->
//│ 	case xs¹ of {C hx¹ tx¹ => case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]} | N  => [N]}: 155
//│ [N]: 113 --->
//│ 	case xs¹ of {C hx¹ tx¹ => case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]} | N  => [N]}: 155
//│ [C a² fromTo₁((a² + 1), b²)]: 136 --->
//│ 	case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]}: 153
//│ [N]: 137 --->
//│ 	case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]}: 153
//│ ------------------
//│ case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]}: 153 --->
//│ 	[C a² fromTo₁((a² + 1), b²)]: 136
//│ 	[N]: 137
//│ case xs¹ of {C hx¹ tx¹ => case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]} | N  => [N]}: 155 --->
//│ 	[C a¹ fromTo₀((a¹ + 1), b¹)]: 112
//│ 	[N]: 113
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C a¹ fromTo₀((a¹ + 1), b¹)]: 112 --->
//│ 	case xs¹ of {C hx¹ tx¹ => case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]} | N  => [N]}: 155
//│ [N]: 113 --->
//│ 	case xs¹ of {C hx¹ tx¹ => case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]} | N  => [N]}: 155
//│ [C a² fromTo₁((a² + 1), b²)]: 136 --->
//│ 	case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]}: 153
//│ [N]: 137 --->
//│ 	case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]}: 153
//│ ------------------
//│ case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]}: 153 --->
//│ 	[C a² fromTo₁((a² + 1), b²)]: 136
//│ 	[N]: 137
//│ case xs¹ of {C hx¹ tx¹ => case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]} | N  => [N]}: 155 --->
//│ 	[C a¹ fromTo₀((a¹ + 1), b¹)]: 112
//│ 	[N]: 113
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main₀(3)
//│ def main₀(n²) = 
//│ 	zip₀(fromTo₀(1, n²), fromTo₁((1 + 2), (n² + 2)))
//│ 	n²
//│ 	where
//│ 	def fromTo₀(a³, b³) = 
//│ 		if (a³ < (b³ + 1)) then 
//│ 			let hx² = a³
//│ 			in let tx² = fromTo₀((a³ + 1), b³)
//│ 			in (fun ys² -> ys²(hx², tx²)) else (fun ys³ -> [N])
//│ 	def fromTo₁(a⁴, b⁴) = 
//│ 		if (a⁴ < (b⁴ + 1)) then 
//│ 			let hy² = a⁴
//│ 			in let ty² = fromTo₁((a⁴ + 1), b⁴)
//│ 			in (fun hx³ -> (fun tx³ -> [C [P2 hx³ hy²] zip₀(tx³, ty²)])) else (fun hx⁴ -> (fun tx⁴ -> [N]))
//│ 	def zip₀(xs², ys⁴) = 
//│ 		xs²(ys⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 
//│ 	[C [P2 1 3] [C [P2 2 4] [C [P2 3 5] [N]]]]
//│ 	3
//│ <<<<<<< evaluate <<<<<<<


_LUMBERHACK_EVAL
fun zip(xs, ys) = if xs is
  C(hx, tx) then if ys is
    C(hy, ty) then C(P2(hx, hy), zip(tx, ty))
    N then N
  N then N
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun mapZip(f, ls) = if ls is
  C(h, t) then C(f(h), mapZip(f, t))
  N then N
fun fp2(p) = if p is
  P2(a, b) then a + b
mapZip(
  fp2,
  zip(
    map(x => x + 1, primId(C(1, C(2, N)))),
    map(x => x + 2, primId(C(3, C(4, N))))
  )
)
//│ |_LUMBERHACK_EVAL|↵|#fun| |zip|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|hx|,| |tx|)| |#then| |#if| |ys| |is|→|C|(|hy|,| |ty|)| |#then| |C|(|P2|(|hx|,| |hy|)|,| |zip|(|tx|,| |ty|)|)|↵|N| |#then| |N|←|↵|N| |#then| |N|←|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapZip|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |mapZip|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |fp2|(|p|)| |#=| |#if| |p| |is|→|P2|(|a|,| |b|)| |#then| |a| |+| |b|←|↵|mapZip|(|→|fp2|,|↵|zip|(|→|map|(|x| |=>| |x| |+| |1|,| |primId|(|C|(|1|,| |C|(|2|,| |N|)|)|)|)|,|↵|map|(|x| |=>| |x| |+| |2|,| |primId|(|C|(|3|,| |C|(|4|,| |N|)|)|)|)|←|↵|)|←|↵|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun zip = xs, ys, => if xs is ‹(C (hx, tx,)) then if ys is ‹(C (hy, ty,)) then C (P2 (hx, hy,), zip (tx, ty,),); (N) then N›; (N) then N›; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun mapZip = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), mapZip (f, t,),); (N) then N›; fun fp2 = p, => if p is ‹(P2 (a, b,)) then + (a,) (b,)›; mapZip (fp2, zip (map (x, => + (x,) (1,), primId (C (1, C (2, N,),),),), map (x, => + (x,) (2,), primId (C (3, C (4, N,),),),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ mapZip^54(fp2^55, zip^57(map^58((fun x⁰ -> (x⁰ + 1)), primId⁰([C 1 [C 2 [N]]])), map^75((fun x¹ -> (x¹ + 2)), primId⁰([C 3 [C 4 [N]]]))))
//│ def fp2(p⁰) = case p⁰ of {
//│ 	P2 a⁰ b⁰ => (a⁰ + b⁰)}
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^22(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def mapZip(f¹, ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => [C f¹(h¹) mapZip^36(f¹, t¹)]
//│ 	| N  => [N]}
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C hx⁰ tx⁰ => case ys⁰ of {
//│ 		C hy⁰ ty⁰ => [C [P2 hx⁰ hy⁰] zip^6(tx⁰, ty⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 7 [C 9 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fp2^55] (hopeless to continue)
//│ [mapZip^54]
//│ 	[mapZip^54 · mapZip^36] ---> [mapZip^54] (only one)
//│ [map^58]
//│ 	[map^58 · map^22] ---> [map^58] (only one)
//│ [map^75]
//│ 	[map^75 · map^22] ---> [map^75] (only one)
//│ [zip^57]
//│ 	[zip^57 · zip^6] ---> [zip^57] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ mapZip₀(fp2₀, zip₀(map₀((fun x² -> (x² + 1)), primId⁰([C 1 [C 2 [N]]])), map₁((fun x³ -> (x³ + 2)), primId⁰([C 3 [C 4 [N]]]))))
//│ def fp2₀(p¹) = 
//│ 	case p¹ of {
//│ 		P2 a¹ b¹ => (a¹ + b¹)}
//│ def mapZip₀(f², ls²) = 
//│ 	case ls² of {
//│ 		C h² t² => [C f²(h²) mapZip₀(f², t²)]
//│ 		| N  => [N]}
//│ def map₀(f⁴, ls⁴) = 
//│ 	case ls⁴ of {
//│ 		C h⁴ t⁴ => [C f⁴(h⁴) map₀(f⁴, t⁴)]
//│ 		| N  => [N]}
//│ def map₁(f³, ls³) = 
//│ 	case ls³ of {
//│ 		C h³ t³ => [C f³(h³) map₁(f³, t³)]
//│ 		| N  => [N]}
//│ def zip₀(xs¹, ys¹) = 
//│ 	case xs¹ of {
//│ 		C hx¹ tx¹ => case ys¹ of {
//│ 			C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)]
//│ 			| N  => [N]}
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f³(h³) map₁(f³, t³)]: 116 --->
//│ 	case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]}: 133
//│ [N]: 117 --->
//│ 	case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]}: 133
//│ [P2 hx¹ hy¹]: 125 --->
//│ 	case p¹ of {P2 a¹ b¹ => (a¹ + b¹)}: 158
//│ [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)]: 131 --->
//│ 	case ls² of {C h² t² => [C f²(h²) mapZip₀(f², t²)] | N  => [N]}: 104
//│ [N]: 132 --->
//│ 	case ls² of {C h² t² => [C f²(h²) mapZip₀(f², t²)] | N  => [N]}: 104
//│ [N]: 134 --->
//│ 	case ls² of {C h² t² => [C f²(h²) mapZip₀(f², t²)] | N  => [N]}: 104
//│ [C f⁴(h⁴) map₀(f⁴, t⁴)]: 147 --->
//│ 	case xs¹ of {C hx¹ tx¹ => case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]} | N  => [N]}: 135
//│ [N]: 148 --->
//│ 	case xs¹ of {C hx¹ tx¹ => case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]} | N  => [N]}: 135
//│ ------------------
//│ case ls² of {C h² t² => [C f²(h²) mapZip₀(f², t²)] | N  => [N]}: 104 --->
//│ 	[C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)]: 131
//│ 	[N]: 132
//│ 	[N]: 134
//│ case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]}: 133 --->
//│ 	[C f³(h³) map₁(f³, t³)]: 116
//│ 	[N]: 117
//│ case xs¹ of {C hx¹ tx¹ => case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]} | N  => [N]}: 135 --->
//│ 	[C f⁴(h⁴) map₀(f⁴, t⁴)]: 147
//│ 	[N]: 148
//│ case p¹ of {P2 a¹ b¹ => (a¹ + b¹)}: 158 --->
//│ 	[P2 hx¹ hy¹]: 125
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f³(h³) map₁(f³, t³)]: 116 --->
//│ 	case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]}: 133
//│ [N]: 117 --->
//│ 	case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]}: 133
//│ [P2 hx¹ hy¹]: 125 --->
//│ 	case p¹ of {P2 a¹ b¹ => (a¹ + b¹)}: 158
//│ [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)]: 131 --->
//│ 	case ls² of {C h² t² => [C f²(h²) mapZip₀(f², t²)] | N  => [N]}: 104
//│ [N]: 132 --->
//│ 	case ls² of {C h² t² => [C f²(h²) mapZip₀(f², t²)] | N  => [N]}: 104
//│ [N]: 134 --->
//│ 	case ls² of {C h² t² => [C f²(h²) mapZip₀(f², t²)] | N  => [N]}: 104
//│ [C f⁴(h⁴) map₀(f⁴, t⁴)]: 147 --->
//│ 	case xs¹ of {C hx¹ tx¹ => case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]} | N  => [N]}: 135
//│ [N]: 148 --->
//│ 	case xs¹ of {C hx¹ tx¹ => case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]} | N  => [N]}: 135
//│ ------------------
//│ case ls² of {C h² t² => [C f²(h²) mapZip₀(f², t²)] | N  => [N]}: 104 --->
//│ 	[C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)]: 131
//│ 	[N]: 132
//│ 	[N]: 134
//│ case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]}: 133 --->
//│ 	[C f³(h³) map₁(f³, t³)]: 116
//│ 	[N]: 117
//│ case xs¹ of {C hx¹ tx¹ => case ys¹ of {C hy¹ ty¹ => [C [P2 hx¹ hy¹] zip₀(tx¹, ty¹)] | N  => [N]} | N  => [N]}: 135 --->
//│ 	[C f⁴(h⁴) map₀(f⁴, t⁴)]: 147
//│ 	[N]: 148
//│ case p¹ of {P2 a¹ b¹ => (a¹ + b¹)}: 158 --->
//│ 	[P2 hx¹ hy¹]: 125
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ mapZip₀(fp2₀, zip₀(map₀((fun x⁴ -> (x⁴ + 1)), primId⁰([C 1 [C 2 [N]]])), map₁((fun x⁵ -> (x⁵ + 2)), primId⁰([C 3 [C 4 [N]]]))))
//│ def fp2₀(p²) = 
//│ 	p²
//│ def mapZip₀(f⁵, ls⁵) = 
//│ 	ls⁵(f⁵)
//│ def map₀(f⁶, ls⁶) = 
//│ 	case ls⁶ of {
//│ 		C h⁴ t⁴ => 
//│ 			let hx² = f⁶(h⁴)
//│ 			in let tx² = map₀(f⁶, t⁴)
//│ 			in (fun ys³ -> ys³(hx², tx²))
//│ 		| N  => (fun ys⁴ -> (fun f⁷ -> [N]))}
//│ def map₁(f⁸, ls⁷) = 
//│ 	case ls⁷ of {
//│ 		C h³ t³ => 
//│ 			let hy² = f⁸(h³)
//│ 			in let ty² = map₁(f⁸, t³)
//│ 			in (fun hx³ -> (fun tx³ -> 
//│ 				let h⁵ = 	
//│ 					let a² = hx³
//│ 					in let b² = hy²
//│ 					in (a² + b²)
//│ 				in let t⁵ = zip₀(tx³, ty²)
//│ 				in (fun f⁹ -> [C f⁹(h⁵) mapZip₀(f⁹, t⁵)])))
//│ 		| N  => (fun hx⁴ -> (fun tx⁴ -> (fun f¹⁰ -> [N])))}
//│ def zip₀(xs², ys²) = 
//│ 	xs²(ys²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 7 [C 9 [N]]]
//│ <<<<<<< evaluate <<<<<<<
