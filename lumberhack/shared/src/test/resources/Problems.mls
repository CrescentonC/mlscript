:NewParser
:ParseOnly


// WRONG: infinite rewrting how to produce a finite rewrtten program?
let p = Pair(A, B)
fun c(x) = if x is
  Pair(a, b) then c(Pair(b, a))
c(p)
//│ |#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^12(p^13)
//│ def c(x⁰) = case x⁰ of {
//│ 	Pair a⁰ b⁰ => c^5([Pair b⁰ a⁰])}
//│ def p = [Pair [A] [B]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Pair [A] [B]]: 3 --->
//│ 	case x⁰ of {Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}: 10
//│ [Pair b⁰ a⁰]: 8 --->
//│ 	case x⁰ of {Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}: 10
//│ ------------------
//│ case x⁰ of {Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}: 10 --->
//│ 	[Pair [A] [B]]: 3
//│ 	[Pair b⁰ a⁰]: 8
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(p)
//│ def c(x¹) = case x¹ of {
//│ 	Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}
//│ def p = [Pair [A] [B]]
//│ <<<<<<< after fusion <<<<<<<

// Just a more valid/reasonable version of the above
// WRONG: recursive strategy
let p = Wrap(3)
fun c(x) = if x is
  Wrap(a) then if a > 0 then c(Wrap(a - 1)) else Wrap(0)
c(p)
//│ |#let| |p| |#=| |Wrap|(|3|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Wrap|(|a|)| |#then| |#if| |a| |>| |0| |#then| |c|(|Wrap|(|a| |-| |1|)|)| |#else| |Wrap|(|0|)|←|↵|c|(|p|)|
//│ Parsed: {let p = Wrap (3,); fun c = x, => if x is ‹(Wrap (a,)) then if (> (a,) (0,)) then c (Wrap (- (a,) (1,),),) else Wrap (0,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^22(p^23)
//│ def c(x⁰) = case x⁰ of {
//│ 	Wrap a⁰ => if (a⁰ > 0) then c^9([Wrap (a⁰ - 1)]) else [Wrap 0]}
//│ def p = [Wrap 3]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Wrap 3]: 2 --->
//│ 	case x⁰ of {Wrap a⁰ => if (a⁰ > 0) then c([Wrap (a⁰ - 1)]) else [Wrap 0]}: 20
//│ [Wrap (a⁰ - 1)]: 15 --->
//│ 	case x⁰ of {Wrap a⁰ => if (a⁰ > 0) then c([Wrap (a⁰ - 1)]) else [Wrap 0]}: 20
//│ ------------------
//│ case x⁰ of {Wrap a⁰ => if (a⁰ > 0) then c([Wrap (a⁰ - 1)]) else [Wrap 0]}: 20 --->
//│ 	[Wrap 3]: 2
//│ 	[Wrap (a⁰ - 1)]: 15
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(p)
//│ def c(x¹) = case x¹ of {
//│ 	Wrap a⁰ => if (a⁰ > 0) then c([Wrap (a⁰ - 1)]) else [Wrap 0]}
//│ def p = [Wrap 3]
//│ <<<<<<< after fusion <<<<<<<



// WRONG: branching and conflict, but can be solved by rewriting into
// NOTE: some program not be able to write?
fun last(ls) = if ls is
  C(h, t) then if t is
    N then Some(h)
    C(hh, tt) then last(t)
  N then None
let p = C(1, C(2, N))
last(p)
//│ |#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |last|(|t|)|←|↵|N| |#then| |None|←|↵|#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|last|(|p|)|
//│ Parsed: {fun last = ls, => if ls is ‹(C (h, t,)) then if t is ‹(N) then Some (h,); (C (hh, tt,)) then last (t,)›; (N) then None›; let p = C (1, C (2, N,),); last (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ last^17(p^18)
//│ def last(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N  => [Some h⁰]
//│ 		| C hh⁰ tt⁰ => last^5(t⁰)}
//│ 	| N  => [None]}
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 14 --->
//│ 	DeadCodeCons
//│ 	case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)}: 8
//│ 	case ls⁰ of {C h⁰ t⁰ => case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)} | N  => [None]}: 10
//│ [C 2 [N]]: 15 --->
//│ 	case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)}: 8
//│ 	case ls⁰ of {C h⁰ t⁰ => case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)} | N  => [None]}: 10
//│ [C 1 [C 2 [N]]]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)} | N  => [None]}: 10
//│ ------------------
//│ case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)}: 8 --->
//│ 	[N]: 14
//│ 	[C 2 [N]]: 15
//│ case ls⁰ of {C h⁰ t⁰ => case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)} | N  => [None]}: 10 --->
//│ 	[N]: 14
//│ 	[C 2 [N]]: 15
//│ 	[C 1 [C 2 [N]]]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ last(p)
//│ def last(ls¹) = case ls¹ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N  => [Some h⁰]
//│ 		| C hh⁰ tt⁰ => last(t⁰)}
//│ 	| N  => [None]}
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<< after fusion <<<<<<<

// WRONG: one consumer cannot be expanded fully?
fun idxSum(ls) = if ls is
  N then acc => 0
  C(h, t) then acc => acc + idxSum(t)(acc + 1)
fun rev(lss) = if lss is
  N then a => a
  C(hh, tt) then a => rev(tt, C(hh, a))
idxSum(rev(C(1, C(2, N)))(N))(0)
//│ |#fun| |idxSum|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc| |=>| |0|↵|C|(|h|,| |t|)| |#then| |acc| |=>| |acc| |+| |idxSum|(|t|)|(|acc| |+| |1|)|←|↵|#fun| |rev|(|lss|)| |#=| |#if| |lss| |is|→|N| |#then| |a| |=>| |a|↵|C|(|hh|,| |tt|)| |#then| |a| |=>| |rev|(|tt|,| |C|(|hh|,| |a|)|)|←|↵|idxSum|(|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|N|)|)|(|0|)|
//│ Parsed: {fun idxSum = ls, => if ls is ‹(N) then acc, => 0; (C (h, t,)) then acc, => + (acc,) (idxSum (t,) (+ (acc,) (1,),),)›; fun rev = lss, => if lss is ‹(N) then a, => a; (C (hh, tt,)) then a, => rev (tt, C (hh, a,),)›; idxSum (rev (C (1, C (2, N,),),) (N,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ idxSum^33(rev^34([C 1 [C 2 [N]]], [N]), 0)
//│ def idxSum(ls⁰) = case ls⁰ of {
//│ 	N  => (fun acc⁰ -> 0)
//│ 	| C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum^7(t⁰, (acc¹ + 1))))}
//│ def rev(lss⁰) = case lss⁰ of {
//│ 	N  => (fun a⁰ -> a⁰)
//│ 	| C hh⁰ tt⁰ => (fun a¹ -> rev^23(tt⁰, [C hh⁰ a¹]))}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh⁰ a¹]: 28 --->
//│ 	case ls⁰ of {N  => (fun acc⁰ -> 0) | C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum(t⁰, (acc¹ + 1))))}: 18
//│ [N]: 37 --->
//│ 	case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31
//│ [C 2 [N]]: 38 --->
//│ 	case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31
//│ [N]: 41 --->
//│ 	case ls⁰ of {N  => (fun acc⁰ -> 0) | C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum(t⁰, (acc¹ + 1))))}: 18
//│ ------------------
//│ case ls⁰ of {N  => (fun acc⁰ -> 0) | C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum(t⁰, (acc¹ + 1))))}: 18 --->
//│ 	[C hh⁰ a¹]: 28
//│ 	[N]: 41
//│ case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31 --->
//│ 	[N]: 37
//│ 	[C 2 [N]]: 38
//│ 	[C 1 [C 2 [N]]]: 39
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C hh⁰ a¹]: 28 --->
//│ 	case ls⁰ of {N  => (fun acc⁰ -> 0) | C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum(t⁰, (acc¹ + 1))))}: 18
//│ [N]: 37 --->
//│ 	case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31
//│ [C 2 [N]]: 38 --->
//│ 	case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31
//│ [N]: 41 --->
//│ 	case ls⁰ of {N  => (fun acc⁰ -> 0) | C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum(t⁰, (acc¹ + 1))))}: 18
//│ ------------------
//│ case ls⁰ of {N  => (fun acc⁰ -> 0) | C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum(t⁰, (acc¹ + 1))))}: 18 --->
//│ 	[C hh⁰ a¹]: 28
//│ 	[N]: 41
//│ case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31 --->
//│ 	[N]: 37
//│ 	[C 2 [N]]: 38
//│ 	[C 1 [C 2 [N]]]: 39
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ idxSum(rev(
//│ 	let tt¹ = 	
//│ 		let tt² = (fun a⁴ -> a⁴)
//│ 		in let hh² = 2
//│ 		in (fun a³ -> rev(tt², 
//│ 			let t² = a³
//│ 			in (fun acc³ -> (acc³ + idxSum(t², (acc³ + 1))))))
//│ 	in let hh¹ = 1
//│ 	in (fun a² -> rev(tt¹, 
//│ 		let t¹ = a²
//│ 		in (fun acc² -> (acc² + idxSum(t¹, (acc² + 1)))))), (fun acc⁴ -> 0)), 0)
//│ def idxSum(ls¹) = ls¹
//│ def rev(lss¹) = lss¹
//│ <<<<<<< after fusion <<<<<<<


// WRONG: still has variable extrusion
_LUMBERHACK_EVAL
fun minuss(a) = if a is
  S(aa) then b => if b is
    S(bb) then minuss(aa, bb)
    Z then aa
  Z then n => Z
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |_LUMBERHACK_EVAL|↵|#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |#if| |b| |is|→|S|(|bb|)| |#then| |minuss|(|aa|,| |bb|)|↵|Z| |#then| |aa|←|↵|Z| |#then| |n| |=>| |Z|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun minuss = a, => if a is ‹(S (aa,)) then b, => if b is ‹(S (bb,)) then minuss (aa, bb,); (Z) then aa›; (Z) then n, => Z›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ minuss^19(fst^20, snd^22)
//│ def fst = [S [S [Z]]]
//│ def minuss(a⁰) = case a⁰ of {
//│ 	S aa⁰ => (fun b⁰ -> case b⁰ of {
//│ 		S bb⁰ => minuss^3(aa⁰, bb⁰)
//│ 		| Z  => aa⁰})
//│ 	| Z  => (fun n⁰ -> [Z])}
//│ def snd = [Z]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [S [Z]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Z]: 15 --->
//│ 	NoCons
//│ 	case a⁰ of {S aa⁰ => (fun b⁰ -> case b⁰ of {S bb⁰ => minuss(aa⁰, bb⁰) | Z  => aa⁰}) | Z  => (fun n⁰ -> [Z])}: 13
//│ [S [Z]]: 16 --->
//│ 	NoCons
//│ 	case a⁰ of {S aa⁰ => (fun b⁰ -> case b⁰ of {S bb⁰ => minuss(aa⁰, bb⁰) | Z  => aa⁰}) | Z  => (fun n⁰ -> [Z])}: 13
//│ [S [S [Z]]]: 17 --->
//│ 	case a⁰ of {S aa⁰ => (fun b⁰ -> case b⁰ of {S bb⁰ => minuss(aa⁰, bb⁰) | Z  => aa⁰}) | Z  => (fun n⁰ -> [Z])}: 13
//│ [Z]: 18 --->
//│ 	DeadCodeCons
//│ 	case b⁰ of {S bb⁰ => minuss(aa⁰, bb⁰) | Z  => aa⁰}: 9
//│ ------------------
//│ case b⁰ of {S bb⁰ => minuss(aa⁰, bb⁰) | Z  => aa⁰}: 9 --->
//│ 	DeadCodeProd
//│ 	[Z]: 18
//│ case a⁰ of {S aa⁰ => (fun b⁰ -> case b⁰ of {S bb⁰ => minuss(aa⁰, bb⁰) | Z  => aa⁰}) | Z  => (fun n⁰ -> [Z])}: 13 --->
//│ 	[Z]: 15
//│ 	[S [Z]]: 16
//│ 	[S [S [Z]]]: 17
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ minuss(fst, snd)
//│ def fst = [S [S [Z]]]
//│ def minuss(a¹) = case a¹ of {
//│ 	S aa⁰ => (fun b¹ -> case b¹ of {
//│ 		S bb⁰ => minuss(aa⁰, bb⁰)
//│ 		| Z  => aa⁰})
//│ 	| Z  => (fun n¹ -> [Z])}
//│ def snd = [Z]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [S [Z]]
//│ <<<<<<< evaluate <<<<<<<


// WRONG:
_LUMBERHACK_EVAL
fun minuss(a) = if a is
  S(aa) then b => checkb(b)(aa)
  Z then n => Z
fun checkb(b) = if b is
  S(bb) then aaa => minuss(aaa, bb)
  Z then aaa => aaa
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |_LUMBERHACK_EVAL|↵|#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |checkb|(|b|)|(|aa|)|↵|Z| |#then| |n| |=>| |Z|←|↵|#fun| |checkb|(|b|)| |#=| |#if| |b| |is|→|S|(|bb|)| |#then| |aaa| |=>| |minuss|(|aaa|,| |bb|)|↵|Z| |#then| |aaa| |=>| |aaa|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun minuss = a, => if a is ‹(S (aa,)) then b, => checkb (b,) (aa,); (Z) then n, => Z›; fun checkb = b, => if b is ‹(S (bb,)) then aaa, => minuss (aaa, bb,); (Z) then aaa, => aaa›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ minuss^27(fst^28, snd^30)
//│ def checkb(b¹) = case b¹ of {
//│ 	S bb⁰ => (fun aaa⁰ -> minuss^13(aaa⁰, bb⁰))
//│ 	| Z  => (fun aaa¹ -> aaa¹)}
//│ def fst = [S [S [Z]]]
//│ def minuss(a⁰) = case a⁰ of {
//│ 	S aa⁰ => (fun b⁰ -> checkb^2(b⁰, aa⁰))
//│ 	| Z  => (fun n⁰ -> [Z])}
//│ def snd = [Z]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [S [Z]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Z]: 23 --->
//│ 	NoCons
//│ 	case a⁰ of {S aa⁰ => (fun b⁰ -> checkb(b⁰, aa⁰)) | Z  => (fun n⁰ -> [Z])}: 10
//│ [S [Z]]: 24 --->
//│ 	NoCons
//│ 	case a⁰ of {S aa⁰ => (fun b⁰ -> checkb(b⁰, aa⁰)) | Z  => (fun n⁰ -> [Z])}: 10
//│ [S [S [Z]]]: 25 --->
//│ 	case a⁰ of {S aa⁰ => (fun b⁰ -> checkb(b⁰, aa⁰)) | Z  => (fun n⁰ -> [Z])}: 10
//│ [Z]: 26 --->
//│ 	DeadCodeCons
//│ 	case b¹ of {S bb⁰ => (fun aaa⁰ -> minuss(aaa⁰, bb⁰)) | Z  => (fun aaa¹ -> aaa¹)}: 21
//│ ------------------
//│ case a⁰ of {S aa⁰ => (fun b⁰ -> checkb(b⁰, aa⁰)) | Z  => (fun n⁰ -> [Z])}: 10 --->
//│ 	[Z]: 23
//│ 	[S [Z]]: 24
//│ 	[S [S [Z]]]: 25
//│ case b¹ of {S bb⁰ => (fun aaa⁰ -> minuss(aaa⁰, bb⁰)) | Z  => (fun aaa¹ -> aaa¹)}: 21 --->
//│ 	DeadCodeProd
//│ 	[Z]: 26
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ minuss(fst, snd)
//│ def checkb(b³) = case b³ of {
//│ 	S bb⁰ => (fun aaa² -> minuss(aaa², bb⁰))
//│ 	| Z  => (fun aaa³ -> aaa³)}
//│ def fst = [S [S [Z]]]
//│ def minuss(a¹) = case a¹ of {
//│ 	S aa⁰ => (fun b² -> checkb(b², aa⁰))
//│ 	| Z  => (fun n¹ -> [Z])}
//│ def snd = [Z]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [S [Z]]
//│ <<<<<<< evaluate <<<<<<<

// WRONG:
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let rec l1 = C(1, C(2, l1))
let rec l2 = C(9, C(8, l2))
inter(l1)(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |#rec| |l1| |#=| |C|(|1|,| |C|(|2|,| |l1|)|)|↵|#let| |#rec| |l2| |#=| |C|(|9|,| |C|(|8|,| |l2|)|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let rec l1 = C (1, C (2, l1,),); let rec l2 = C (9, C (8, l2,),); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^24(l1^25, l2^27)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 l1^16]]
//│ def l2 = [C 9 [C 8 l2^21]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 2 l1]: 17 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 1 [C 2 l1]]: 18 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 8 l2]: 22 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 9 [C 8 l2]]: 23 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12 --->
//│ 	[C 2 l1]: 17
//│ 	[C 1 [C 2 l1]]: 18
//│ 	[C 8 l2]: 22
//│ 	[C 9 [C 8 l2]]: 23
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ inter(ys³, t⁰)])}
//│ def l1 = [C 1 [C 2 l1]]
//│ def l2 = [C 9 [C 8 l2]]
//│ <<<<<<< after fusion <<<<<<<


// WRONG: push in cannot work still have binding error
// and wrong recursive knots
fun f(xs) = if xs is
  X(x1) then if x1 is
    X(x2) then if x2 is
      X(x3) then ys => if ys is
        Y(y1) then if y1 is
          Y(y2) then f(x3, y2)
let rec xx = X(X(xx))
let rec yy = Y(Y(Y(yy)))
f(xx, yy)
//│ |#fun| |f|(|xs|)| |#=| |#if| |xs| |is|→|X|(|x1|)| |#then| |#if| |x1| |is|→|X|(|x2|)| |#then| |#if| |x2| |is|→|X|(|x3|)| |#then| |ys| |=>| |#if| |ys| |is|→|Y|(|y1|)| |#then| |#if| |y1| |is|→|Y|(|y2|)| |#then| |f|(|x3|,| |y2|)|←|←|←|←|←|↵|#let| |#rec| |xx| |#=| |X|(|X|(|xx|)|)|↵|#let| |#rec| |yy| |#=| |Y|(|Y|(|Y|(|yy|)|)|)|↵|f|(|xx|,| |yy|)|
//│ Parsed: {fun f = xs, => if xs is ‹(X (x1,)) then if x1 is ‹(X (x2,)) then if x2 is ‹(X (x3,)) then ys, => if ys is ‹(Y (y1,)) then if y1 is ‹(Y (y2,)) then f (x3, y2,)›››››; let rec xx = X (X (xx,),); let rec yy = Y (Y (Y (yy,),),); f (xx, yy,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^25(xx^26, yy^28)
//│ def f(xs⁰) = case xs⁰ of {
//│ 	X x1⁰ => case x1⁰ of {
//│ 		X x2⁰ => case x2⁰ of {
//│ 			X x3⁰ => (fun ys⁰ -> case ys⁰ of {
//│ 				Y y1⁰ => case y1⁰ of {
//│ 					Y y2⁰ => f^6(x3⁰, y2⁰)}})}}}
//│ def xx = [X [X xx^18]]
//│ def yy = [Y [Y [Y yy^21]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [X xx]: 19 --->
//│ 	case x2⁰ of {X x3⁰ => (fun ys⁰ -> case ys⁰ of {Y y1⁰ => case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}})}: 14
//│ 	case x1⁰ of {X x2⁰ => case x2⁰ of {X x3⁰ => (fun ys⁰ -> case ys⁰ of {Y y1⁰ => case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}})}}: 15
//│ 	case xs⁰ of {X x1⁰ => case x1⁰ of {X x2⁰ => case x2⁰ of {X x3⁰ => (fun ys⁰ -> case ys⁰ of {Y y1⁰ => case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}})}}}: 16
//│ [X [X xx]]: 20 --->
//│ 	case x2⁰ of {X x3⁰ => (fun ys⁰ -> case ys⁰ of {Y y1⁰ => case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}})}: 14
//│ 	case x1⁰ of {X x2⁰ => case x2⁰ of {X x3⁰ => (fun ys⁰ -> case ys⁰ of {Y y1⁰ => case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}})}}: 15
//│ 	case xs⁰ of {X x1⁰ => case x1⁰ of {X x2⁰ => case x2⁰ of {X x3⁰ => (fun ys⁰ -> case ys⁰ of {Y y1⁰ => case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}})}}}: 16
//│ [Y yy]: 22 --->
//│ 	case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}: 11
//│ 	case ys⁰ of {Y y1⁰ => case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}}: 12
//│ [Y [Y yy]]: 23 --->
//│ 	case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}: 11
//│ 	case ys⁰ of {Y y1⁰ => case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}}: 12
//│ [Y [Y [Y yy]]]: 24 --->
//│ 	case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}: 11
//│ 	case ys⁰ of {Y y1⁰ => case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}}: 12
//│ ------------------
//│ case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}: 11 --->
//│ 	[Y yy]: 22
//│ 	[Y [Y yy]]: 23
//│ 	[Y [Y [Y yy]]]: 24
//│ case ys⁰ of {Y y1⁰ => case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}}: 12 --->
//│ 	[Y yy]: 22
//│ 	[Y [Y yy]]: 23
//│ 	[Y [Y [Y yy]]]: 24
//│ case x2⁰ of {X x3⁰ => (fun ys⁰ -> case ys⁰ of {Y y1⁰ => case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}})}: 14 --->
//│ 	[X xx]: 19
//│ 	[X [X xx]]: 20
//│ case x1⁰ of {X x2⁰ => case x2⁰ of {X x3⁰ => (fun ys⁰ -> case ys⁰ of {Y y1⁰ => case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}})}}: 15 --->
//│ 	[X xx]: 19
//│ 	[X [X xx]]: 20
//│ case xs⁰ of {X x1⁰ => case x1⁰ of {X x2⁰ => case x2⁰ of {X x3⁰ => (fun ys⁰ -> case ys⁰ of {Y y1⁰ => case y1⁰ of {Y y2⁰ => f(x3⁰, y2⁰)}})}}}: 16 --->
//│ 	[X xx]: 19
//│ 	[X [X xx]]: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f(xx, yy)
//│ def f(xs¹) = case xs¹ of {
//│ 	X x1⁰ => case x1⁰ of {
//│ 		X x2⁰ => case x2⁰ of {
//│ 			X x3⁰ => (fun ys¹ -> case ys¹ of {
//│ 				Y y1⁰ => case y1⁰ of {
//│ 					Y y2⁰ => f(x3⁰, y2⁰)}})}}}
//│ def xx = [X [X xx]]
//│ def yy = [Y [Y [Y yy]]]
//│ <<<<<<< after fusion <<<<<<<



// WRONG: still have binding error
// _LUMBERHACK_ERROR
fun f(x) = if x is
  C(k) then f(x)
f(C(primitive))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|k|)| |#then| |f|(|x|)|←|↵|f|(|C|(|primitive|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (k,)) then f (x,)›; f (C (primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^7([C primitive⁰])
//│ def f(x⁰) = case x⁰ of {
//│ 	C k⁰ => f^2(x⁰)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰]: 9 --->
//│ 	case x⁰ of {C k⁰ => f(x⁰)}: 5
//│ ------------------
//│ case x⁰ of {C k⁰ => f(x⁰)}: 5 --->
//│ 	[C primitive⁰]: 9
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C primitive⁰]: 9 --->
//│ 	case x⁰ of {C k⁰ => f(x⁰)}: 5
//│ ------------------
//│ case x⁰ of {C k⁰ => f(x⁰)}: 5 --->
//│ 	[C primitive⁰]: 9
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f((fun x¹ -> f(x¹)))
//│ def f(x²) = x²(x²)
//│ <<<<<<< after fusion <<<<<<<

// NOTE: this way of pushing in var is local
fun f(x) = (if x is
  C(k) then x => f(x)
)(x)
f(C(primitive))
//│ |#fun| |f|(|x|)| |#=| |(|#if| |x| |is|→|C|(|k|)| |#then| |x| |=>| |f|(|x|)|←|↵|)|(|x|)|↵|f|(|C|(|primitive|)|)|
//│ Parsed: {fun f = x, => '(' if x is ‹(C (k,)) then x, => f (x,)›, ')' (x,); f (C (primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^10([C primitive⁰])
//│ def f(x⁰) = case x⁰ of {
//│ 	C k⁰ => (fun x¹ -> f^2(x¹))}(x⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰]: 12 --->
//│ 	case x⁰ of {C k⁰ => (fun x¹ -> f(x¹))}: 6
//│ ------------------
//│ case x⁰ of {C k⁰ => (fun x¹ -> f(x¹))}: 6 --->
//│ 	[C primitive⁰]: 12
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C primitive⁰]: 12 --->
//│ 	case x⁰ of {C k⁰ => (fun x¹ -> f(x¹))}: 6
//│ ------------------
//│ case x⁰ of {C k⁰ => (fun x¹ -> f(x¹))}: 6 --->
//│ 	[C primitive⁰]: 12
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f((fun x² -> f(x²)))
//│ def f(x³) = x³(x³)
//│ <<<<<<< after fusion <<<<<<<



// CORRECT: after filtering out recursive strategies
fun f(x) = if x is
  C(k) then f(C(x))
f(C(primitive))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|k|)| |#then| |f|(|C|(|x|)|)|←|↵|f|(|C|(|primitive|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (k,)) then f (C (x,),)›; f (C (primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^8([C primitive⁰])
//│ def f(x⁰) = case x⁰ of {
//│ 	C k⁰ => f^2([C x⁰])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x⁰]: 4 --->
//│ 	DeadCodeCons
//│ 	case x⁰ of {C k⁰ => f([C x⁰])}: 6
//│ [C primitive⁰]: 10 --->
//│ 	DeadCodeCons
//│ 	case x⁰ of {C k⁰ => f([C x⁰])}: 6
//│ ------------------
//│ case x⁰ of {C k⁰ => f([C x⁰])}: 6 --->
//│ 	[C x⁰]: 4
//│ 	[C primitive⁰]: 10
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C primitive⁰])
//│ def f(x¹) = case x¹ of {
//│ 	C k⁰ => f([C x¹])}
//│ <<<<<<< after fusion <<<<<<<


// // CORRECT: after the detection and elimination of multiple matches
// NOTE: no recursive strategy stackoverflow problem
// because the infinite rewriting cannot be started by `primitive`
fun f(x) = if x is
  N then f(N)
  _ then 0
f(primitive)
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |f|(|N|)|↵|_| |#then| |0|←|↵|f|(|primitive|)|
//│ Parsed: {fun f = x, => if x is ‹(N) then f (N,); (_) then 0›; f (primitive,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^8(primitive⁰)
//│ def f(x⁰) = case x⁰ of {
//│ 	N  => f^2([N])
//│ 	| _  => 0}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 3 --->
//│ 	case x⁰ of {N  => f([N]) | _  => 0}: 6
//│ ------------------
//│ case x⁰ of {N  => f([N]) | _  => 0}: 6 --->
//│ 	[N]: 3
//│ 	NoProd
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f(primitive⁰)
//│ def f(x¹) = case x¹ of {
//│ 	N  => f([N])
//│ 	| _  => 0}
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: mutual recursive strategy can be filtered out
fun f(x) = if x is
    C(a) then f(C(a))
fun g(y) = if y is
    D(b) then f(C(b))
f(C(A))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |f|(|C|(|a|)|)|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|D|(|b|)| |#then| |f|(|C|(|b|)|)|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then f (C (a,),)›; fun g = y, => if y is ‹(D (b,)) then f (C (b,),)›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^15([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => f^2([C a⁰])}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => f^9([C b⁰])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a⁰]: 4 --->
//│ 	case x⁰ of {C a⁰ => f([C a⁰])}: 6
//│ [C b⁰]: 11 --->
//│ 	case x⁰ of {C a⁰ => f([C a⁰])}: 6
//│ [C [A]]: 17 --->
//│ 	case x⁰ of {C a⁰ => f([C a⁰])}: 6
//│ ------------------
//│ case x⁰ of {C a⁰ => f([C a⁰])}: 6 --->
//│ 	[C a⁰]: 4
//│ 	[C b⁰]: 11
//│ 	[C [A]]: 17
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C [A]])
//│ def f(x¹) = case x¹ of {
//│ 	C a⁰ => f([C a⁰])}
//│ def g(y¹) = case y¹ of {
//│ 	D b⁰ => f([C b⁰])}
//│ <<<<<<< after fusion <<<<<<<
