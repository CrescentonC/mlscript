:NewParser
:ParseOnly


// NOTE: the `p` inside `C(p)` is untouched
// TODO don't rewrite dead code
let p = C(p)
fun c(x) = if C(x) is
    C(a) then a
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |a|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then a›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:6 = [C p:6^1]
//│ def c:7 = (fun x:8 -> case [C x:8^3] of {
//│ 	C a:9 => a:9^5})
//│ (c:7^8 p:6^9)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ >>>>>>>>>> initial constraints >>>>>>>>>>
//│ ([c:7^8]: 1'c) <: ([]: ([p:6^9]: 0'p) => ([]: 5'10_callres))
//│ ([]: ([]: 2'x) => ([]: 4'6_matchres)) <: ([]: 1'c)
//│ ([]: 3'a) <: ([]: 4'6_matchres)
//│ ([]: C(([]: 2'x))) <: ([]: Destruct(C(3'a)))
//│ ([]: C(([p:6^1]: 0'p))) <: ([]: 0'p)
//│ <<<<<<<<<< initial constraints <<<<<<<<<<
//│ 
//│ ------- knots -------


// NOTE: how to produce a finite rewrtten program?
_LUMBERHACK_ERROR
let p = Pair(A, B)
fun c(x) = if x is
    Pair(a, b) then c(Pair(b, a))
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:6 = [Pair [A] [B]]
//│ def c:7 = (fun x:8 -> case x:8^4 of {
//│ 	Pair a:9 b:10 => (c:7^5 [Pair b:10^6 a:9^7])})
//│ (c:7^12 p:6^13)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ >>>>>>>>>> initial constraints >>>>>>>>>>
//│ ([c:7^12]: 1'c) <: ([]: ([p:6^13]: 0'p) => ([]: 7'14_callres))
//│ ([]: ([]: 2'x) => ([]: 6'10_matchres)) <: ([]: 1'c)
//│ ([]: 5'9_callres) <: ([]: 6'10_matchres)
//│ ([]: 2'x) <: ([]: Destruct(Pair(3'a, 4'b)))
//│ ([c:7^5]: 1'c) <: ([]: ([]: Pair(([]: 4'b), ([]: 3'a))) => ([]: 5'9_callres))
//│ ([]: Pair(([]: A), ([]: B))) <: ([]: 0'p)
//│ <<<<<<<<<< initial constraints <<<<<<<<<<
//│ 
//│ ------- knots -------
//│ B <: 4'b
//│ 	[-p:6^13 · +c:7^12 · +c:7^5 · +c:7^5]  --->  [-p:6^13 · +c:7^12]
//│ A <: 3'a
//│ 	[-p:6^13 · +c:7^12 · +c:7^5 · +c:7^5]  --->  [-p:6^13 · +c:7^12]

// Just a more valid/reasonable version of the above
// TODO support nested patterns as in `Pair(0)`
// TODO get a recursive knot even when using `primitive` (we get it without)
_LUMBERHACK_ERROR
let p = Wrap(3)
fun c(x) = if x is
    N then 0
    Wrap(a) then c(Wrap(primitive(a)))
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Wrap|(|3|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |0|↵|Wrap|(|a|)| |#then| |c|(|Wrap|(|primitive|(|a|)|)|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Wrap (3,); fun c = x, => if x is ‹(N) then 0; (Wrap (a,)) then c (Wrap (primitive (a,),),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:6 = [Wrap 3]
//│ def c:7 = (fun x:8 -> case x:8^3 of {
//│ 	N => 0
//│ 	| Wrap a:9 => (c:7^5 [Wrap (primitive:3^6 a:9^7)])})
//│ (c:7^13 p:6^14)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ >>>>>>>>>> initial constraints >>>>>>>>>>
//│ ([c:7^13]: 1'c) <: ([]: ([p:6^14]: 0'p) => ([]: 7'15_callres))
//│ ([]: ([]: 2'x) => ([]: 6'11_matchres)) <: ([]: 1'c)
//│ ([]: 5'10_callres) <: ([]: 6'11_matchres)
//│ ([]: Int) <: ([]: 6'11_matchres)
//│ ([]: 2'x) <: ([]: Destruct(N, Wrap(3'a)))
//│ ([c:7^5]: 1'c) <: ([]: ([]: Wrap(([]: 4'8_callres))) => ([]: 5'10_callres))
//│ ([]: Wrap(([]: Int))) <: ([]: 0'p)
//│ <<<<<<<<<< initial constraints <<<<<<<<<<
//│ 
//│ ------- knots -------
//│ Int <: 5'10_callres
//│ 	[-c:7^5 · -c:7^5]  --->  [-c:7^5]

fun c(x) = if primitive(x) is
    True then 0
    False then c(primitive(x))
c(0)
//│ |#fun| |c|(|x|)| |#=| |#if| |primitive|(|x|)| |is|→|True| |#then| |0|↵|False| |#then| |c|(|primitive|(|x|)|)|←|↵|c|(|0|)|
//│ Parsed: {fun c = x, => if primitive (x,) is ‹(True) then 0; (False) then c (primitive (x,),)›; c (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def c:6 = (fun x:7 -> case (primitive:3^1 x:7^2) of {
//│ 	True => 0
//│ 	| False => (c:6^5 (primitive:3^6 x:7^7))})
//│ (c:6^12 0)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ >>>>>>>>>> initial constraints >>>>>>>>>>
//│ ([c:6^12]: 0'c) <: ([]: ([]: Int) => ([]: 6'14_callres))
//│ ([]: ([]: 1'x) => ([]: 5'10_matchres)) <: ([]: 0'c)
//│ ([]: 4'9_callres) <: ([]: 5'10_matchres)
//│ ([]: Int) <: ([]: 5'10_matchres)
//│ ([]: 2'3_callres) <: ([]: Destruct(True, False))
//│ ([c:6^5]: 0'c) <: ([]: ([]: 3'8_callres) => ([]: 4'9_callres))
//│ <<<<<<<<<< initial constraints <<<<<<<<<<
//│ 
//│ ------- knots -------
//│ Int <: 4'9_callres
//│ 	[-c:6^5 · -c:6^5]  --->  [-c:6^5]


// NOTE: only the first two element is handled
_LUMBERHACK_ERROR
fun map(f, ls) = if ls is
    C(h, t) then C(f(h), map(f, t))
    N then N
fun ff(x) = if x is
    K then T
    KK then TT
    KKKK then TTTT
let l = C(K, C(KK, C(KKKK, N)))
map(ff, l)
//│ |_LUMBERHACK_ERROR|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|ff|,| |l|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; let l = C (K, C (KK, C (KKKK, N,),),); map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def map:6 = (fun f:9 -> (fun ls:10 -> case ls:10^1 of {
//│ 	C h:11 t:12 => [C (f:9^2 h:11^3) ((map:6^5 f:9^6) t:12^8)]
//│ 	| N => [N]}))
//│ def ff:7 = (fun x:13 -> case x:13^15 of {
//│ 	K => [T]
//│ 	| KK => [TT]
//│ 	| KKKK => [TTTT]})
//│ def l:8 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ ((map:6^28 ff:7^29) l:8^31)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ >>>>>>>>>> initial constraints >>>>>>>>>>
//│ ([]: 13'30_callres) <: ([]: ([l:8^31]: 2'l) => ([]: 14'32_callres))
//│ ([map:6^28]: 0'map) <: ([]: ([ff:7^29]: 1'ff) => ([]: 13'30_callres))
//│ ([]: C(([]: K), ([]: C(([]: KK), ([]: C(([]: KKKK), ([]: N))))))) <: ([]: 2'l)
//│ ([]: ([]: 11'x) => ([]: 12'19_matchres)) <: ([]: 1'ff)
//│ ([]: TTTT) <: ([]: 12'19_matchres)
//│ ([]: TT) <: ([]: 12'19_matchres)
//│ ([]: T) <: ([]: 12'19_matchres)
//│ ([]: 11'x) <: ([]: Destruct(K, KK, KKKK))
//│ ([]: ([]: 3'f) => ([]: ([]: 4'ls) => ([]: 10'12_matchres))) <: ([]: 0'map)
//│ ([]: N) <: ([]: 10'12_matchres)
//│ ([]: C(([]: 7'4_callres), ([]: 9'9_callres))) <: ([]: 10'12_matchres)
//│ ([]: 4'ls) <: ([]: Destruct(C(5'h, 6't), N))
//│ ([]: 8'7_callres) <: ([]: ([]: 6't) => ([]: 9'9_callres))
//│ ([map:6^5]: 0'map) <: ([]: ([]: 3'f) => ([]: 8'7_callres))
//│ ([]: 3'f) <: ([]: ([]: 5'h) => ([]: 7'4_callres))
//│ <<<<<<<<<< initial constraints <<<<<<<<<<
//│ 
//│ ------- knots -------
//│ 11'x => 12'19_matchres <: 3'f
//│ 	[-ff:7^29 · +map:6^28 · +map:6^5 · +map:6^5]  --->  [-ff:7^29 · +map:6^28 · +map:6^5]


// NOTE: some program not be able to write?
_LUMBERHACK_ERROR
fun last(ls) = if ls is
    C(h, t) then if t is
        N then Some(h)
        C(hh, tt) then last(t)
        // C(hh, tt) then last(C(hh, tt))
    N then None
let p = C(1, C(2, N))
last(p)
//│ |_LUMBERHACK_ERROR|↵|#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |last|(|t|)|↵|/* C(hh, tt) then last(C(hh, tt))*/|←|↵|N| |#then| |None|←|↵|#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|last|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun last = ls, => if ls is ‹(C (h, t,)) then if t is ‹(N) then Some (h,); (C (hh, tt,)) then last (t,)›; (N) then None›; let p = C (1, C (2, N,),); last (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def last:6 = (fun ls:8 -> case ls:8^1 of {
//│ 	C h:9 t:10 => case t:10^2 of {
//│ 		N => [Some h:9^3]
//│ 		| C hh:11 tt:12 => (last:6^5 t:10^6)}
//│ 	| N => [None]})
//│ def p:7 = [C 1 [C 2 [N]]]
//│ (last:6^17 p:7^18)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ >>>>>>>>>> initial constraints >>>>>>>>>>
//│ ([last:6^17]: 0'last) <: ([]: ([p:7^18]: 1'p) => ([]: 10'19_callres))
//│ ([]: C(([]: Int), ([]: C(([]: Int), ([]: N))))) <: ([]: 1'p)
//│ ([]: ([]: 2'ls) => ([]: 9'10_matchres)) <: ([]: 0'last)
//│ ([]: None) <: ([]: 9'10_matchres)
//│ ([]: 8'8_matchres) <: ([]: 9'10_matchres)
//│ ([]: 2'ls) <: ([]: Destruct(C(3'h, 4't), N))
//│ ([]: 7'7_callres) <: ([]: 8'8_matchres)
//│ ([]: Some(([]: 3'h))) <: ([]: 8'8_matchres)
//│ ([]: 4't) <: ([]: Destruct(N, C(5'hh, 6'tt)))
//│ ([last:6^5]: 0'last) <: ([]: ([]: 4't) => ([]: 7'7_callres))
//│ <<<<<<<<<< initial constraints <<<<<<<<<<
//│ 
//│ ------- knots -------
//│ Some(3'h) <: 7'7_callres
//│ 	[-last:6^5 · -last:6^5]  --->  [-last:6^5]
//│ None <: 7'7_callres
//│ 	[-last:6^5 · -last:6^5]  --->  [-last:6^5]

_LUMBERHACK_ERROR
let add = primitive
fun idxSum(ls) = if ls is
    N then acc => 0
    C(h, t) then acc => add(acc, idxSum(t)(add(acc, 1)))
fun rev(lss, a) = if lss is
    N then a
    C(hh, tt) then rev(tt, C(hh, a))
idxSum(rev(primitive, N))(0)
//│ |_LUMBERHACK_ERROR|↵|#let| |add| |#=| |primitive|↵|#fun| |idxSum|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc| |=>| |0|↵|C|(|h|,| |t|)| |#then| |acc| |=>| |add|(|acc|,| |idxSum|(|t|)|(|add|(|acc|,| |1|)|)|)|←|↵|#fun| |rev|(|lss|,| |a|)| |#=| |#if| |lss| |is|→|N| |#then| |a|↵|C|(|hh|,| |tt|)| |#then| |rev|(|tt|,| |C|(|hh|,| |a|)|)|←|↵|idxSum|(|rev|(|primitive|,| |N|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_ERROR; let add = primitive; fun idxSum = ls, => if ls is ‹(N) then acc, => 0; (C (h, t,)) then acc, => add (acc, idxSum (t,) (add (acc, 1,),),)›; fun rev = lss, a, => if lss is ‹(N) then a; (C (hh, tt,)) then rev (tt, C (hh, a,),)›; idxSum (rev (primitive, N,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def add:4 = primitive:3^1
//│ def idxSum:7 = (fun ls:9 -> case ls:9^2 of {
//│ 	N => (fun acc:10 -> 0)
//│ 	| C h:11 t:12 => (fun acc:13 -> ((add:4^5 acc:13^6) ((idxSum:7^8 t:12^9) ((add:4^11 acc:13^12) 1))))})
//│ def rev:8 = (fun lss:14 -> (fun a:15 -> case lss:14^21 of {
//│ 	N => a:15^22
//│ 	| C hh:16 tt:17 => ((rev:8^23 tt:17^24) [C hh:16^26 a:15^27])}))
//│ ((idxSum:7^33 ((rev:8^34 primitive:3^35) [N])) 0)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ >>>>>>>>>> initial constraints >>>>>>>>>>
//│ ([]: 24'39_callres) <: ([]: ([]: Int) => ([]: 25'41_callres))
//│ ([idxSum:7^33]: 1'idxSum) <: ([]: ([]: 23'38_callres) => ([]: 24'39_callres))
//│ ([]: 22'36_callres) <: ([]: ([]: N) => ([]: 23'38_callres))
//│ ([rev:8^34]: 2'rev) <: ([]: ([]: NoProd) => ([]: 22'36_callres))
//│ ([]: ([]: 15'lss) => ([]: ([]: 16'a) => ([]: 21'30_matchres))) <: ([]: 2'rev)
//│ ([]: 20'29_callres) <: ([]: 21'30_matchres)
//│ ([]: 16'a) <: ([]: 21'30_matchres)
//│ ([]: 15'lss) <: ([]: Destruct(N, C(17'hh, 18'tt)))
//│ ([]: 19'25_callres) <: ([]: ([]: C(([]: 17'hh), ([]: 16'a))) => ([]: 20'29_callres))
//│ ([rev:8^23]: 2'rev) <: ([]: ([]: 18'tt) => ([]: 19'25_callres))
//│ ([]: ([]: 3'ls) => ([]: 14'19_matchres)) <: ([]: 1'idxSum)
//│ ([]: ([]: 7'acc) => ([]: 13'17_callres)) <: ([]: 14'19_matchres)
//│ ([]: ([]: 4'acc) => ([]: Int)) <: ([]: 14'19_matchres)
//│ ([]: 3'ls) <: ([]: Destruct(N, C(5'h, 6't)))
//│ ([]: 8'7_callres) <: ([]: ([]: 12'16_callres) => ([]: 13'17_callres))
//│ ([]: 9'10_callres) <: ([]: ([]: 11'15_callres) => ([]: 12'16_callres))
//│ ([]: 10'13_callres) <: ([]: ([]: Int) => ([]: 11'15_callres))
//│ ([]: ([]: Destruct(Int)) => ([]: ([]: Destruct(Int)) => ([]: Int))) <: ([]: ([]: 7'acc) => ([]: 10'13_callres))
//│ ([idxSum:7^8]: 1'idxSum) <: ([]: ([]: 6't) => ([]: 9'10_callres))
//│ ([]: ([]: Destruct(Int)) => ([]: ([]: Destruct(Int)) => ([]: Int))) <: ([]: ([]: 7'acc) => ([]: 8'7_callres))
//│ <<<<<<<<<< initial constraints <<<<<<<<<<
//│ 
//│ ------- knots -------
//│ N <: 20'29_callres
//│ 	[+rev:8^34 · -rev:8^23 · -rev:8^23]  --->  [+rev:8^34 · -rev:8^23]
//│ C(17'hh, 16'a) <: 20'29_callres
//│ 	[+rev:8^23 · -rev:8^23 · -rev:8^23]  --->  [+rev:8^23 · -rev:8^23]
//│ C(17'hh, 16'a) <: 3'ls
//│ 	[+rev:8^23 · +rev:8^23 · +rev:8^23 · -rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8 · +idxSum:7^8]  --->  [+rev:8^23 · +rev:8^23 · -rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8]
//│ 	[+rev:8^23 · +rev:8^23 · +rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8 · +idxSum:7^8]  --->  [+rev:8^23 · +rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8]


fun minuss(a) = if a is
    S(aa) then b => if b is
        S(bb) then minuss(aa, bb)
        Z then aa
    Z then n => Z
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |#if| |b| |is|→|S|(|bb|)| |#then| |minuss|(|aa|,| |bb|)|↵|Z| |#then| |aa|←|↵|Z| |#then| |n| |=>| |Z|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {fun minuss = a, => if a is ‹(S (aa,)) then b, => if b is ‹(S (bb,)) then minuss (aa, bb,); (Z) then aa›; (Z) then n, => Z›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def minuss:6 = (fun a:9 -> case a:9^1 of {
//│ 	S aa:10 => (fun b:11 -> case b:11^2 of {
//│ 		S bb:12 => ((minuss:6^3 aa:10^4) bb:12^6)
//│ 		| Z => aa:10^8})
//│ 	| Z => (fun n:13 -> [Z])})
//│ def fst:7 = [S [S [Z]]]
//│ def snd:8 = [Z]
//│ ((minuss:6^19 fst:7^20) snd:8^22)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ >>>>>>>>>> initial constraints >>>>>>>>>>
//│ ([]: 12'21_callres) <: ([]: ([snd:8^22]: 2'snd) => ([]: 13'23_callres))
//│ ([minuss:6^19]: 0'minuss) <: ([]: ([fst:7^20]: 1'fst) => ([]: 12'21_callres))
//│ ([]: Z) <: ([]: 2'snd)
//│ ([]: S(([]: S(([]: Z))))) <: ([]: 1'fst)
//│ ([]: ([]: 3'a) => ([]: 11'13_matchres)) <: ([]: 0'minuss)
//│ ([]: ([]: 10'n) => ([]: Z)) <: ([]: 11'13_matchres)
//│ ([]: ([]: 5'b) => ([]: 9'9_matchres)) <: ([]: 11'13_matchres)
//│ ([]: 3'a) <: ([]: Destruct(S(4'aa), Z))
//│ ([]: 4'aa) <: ([]: 9'9_matchres)
//│ ([]: 8'7_callres) <: ([]: 9'9_matchres)
//│ ([]: 5'b) <: ([]: Destruct(S(6'bb), Z))
//│ ([]: 7'5_callres) <: ([]: ([]: 6'bb) => ([]: 8'7_callres))
//│ ([minuss:6^3]: 0'minuss) <: ([]: ([]: 4'aa) => ([]: 7'5_callres))
//│ <<<<<<<<<< initial constraints <<<<<<<<<<
//│ 
//│ ------- knots -------
//│ S(Z) <: 8'7_callres
//│ 	[-fst:7^20 · +minuss:6^19 · -minuss:6^3 · -minuss:6^3]  --->  [-fst:7^20 · +minuss:6^19 · -minuss:6^3]
//│ Z <: 8'7_callres
//│ 	[-minuss:6^3 · -minuss:6^3]  --->  [-minuss:6^3]
//│ 	[-fst:7^20 · +minuss:6^19 · +minuss:6^3 · -minuss:6^3 · -minuss:6^3]  --->  [-fst:7^20 · +minuss:6^19 · +minuss:6^3 · -minuss:6^3]

// FIXME: weird recursive
_LUMBERHACK_ERROR
fun minuss(a) = if a is
    S(aa) then b => checkb(b)(aa)
    Z then n => Z
fun checkb(b) = if b is
    S(bb) then aaa => minuss(aaa, bb)
    Z then aaa => aaa
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |_LUMBERHACK_ERROR|↵|#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |checkb|(|b|)|(|aa|)|↵|Z| |#then| |n| |=>| |Z|←|↵|#fun| |checkb|(|b|)| |#=| |#if| |b| |is|→|S|(|bb|)| |#then| |aaa| |=>| |minuss|(|aaa|,| |bb|)|↵|Z| |#then| |aaa| |=>| |aaa|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun minuss = a, => if a is ‹(S (aa,)) then b, => checkb (b,) (aa,); (Z) then n, => Z›; fun checkb = b, => if b is ‹(S (bb,)) then aaa, => minuss (aaa, bb,); (Z) then aaa, => aaa›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def minuss:6 = (fun a:10 -> case a:10^1 of {
//│ 	S aa:11 => (fun b:12 -> ((checkb:7^2 b:12^3) aa:11^5))
//│ 	| Z => (fun n:13 -> [Z])})
//│ def checkb:7 = (fun b:14 -> case b:14^12 of {
//│ 	S bb:15 => (fun aaa:16 -> ((minuss:6^13 aaa:16^14) bb:15^16))
//│ 	| Z => (fun aaa:17 -> aaa:17^19)})
//│ def fst:8 = [S [S [Z]]]
//│ def snd:9 = [Z]
//│ ((minuss:6^27 fst:8^28) snd:9^30)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ >>>>>>>>>> initial constraints >>>>>>>>>>
//│ ([]: 18'29_callres) <: ([]: ([snd:9^30]: 3'snd) => ([]: 19'31_callres))
//│ ([minuss:6^27]: 0'minuss) <: ([]: ([fst:8^28]: 2'fst) => ([]: 18'29_callres))
//│ ([]: Z) <: ([]: 3'snd)
//│ ([]: S(([]: S(([]: Z))))) <: ([]: 2'fst)
//│ ([]: ([]: 11'b) => ([]: 17'21_matchres)) <: ([]: 1'checkb)
//│ ([]: ([]: 16'aaa) => ([]: 16'aaa)) <: ([]: 17'21_matchres)
//│ ([]: ([]: 13'aaa) => ([]: 15'17_callres)) <: ([]: 17'21_matchres)
//│ ([]: 11'b) <: ([]: Destruct(S(12'bb), Z))
//│ ([]: 14'15_callres) <: ([]: ([]: 12'bb) => ([]: 15'17_callres))
//│ ([minuss:6^13]: 0'minuss) <: ([]: ([]: 13'aaa) => ([]: 14'15_callres))
//│ ([]: ([]: 4'a) => ([]: 10'10_matchres)) <: ([]: 0'minuss)
//│ ([]: ([]: 9'n) => ([]: Z)) <: ([]: 10'10_matchres)
//│ ([]: ([]: 6'b) => ([]: 8'6_callres)) <: ([]: 10'10_matchres)
//│ ([]: 4'a) <: ([]: Destruct(S(5'aa), Z))
//│ ([]: 7'4_callres) <: ([]: ([]: 5'aa) => ([]: 8'6_callres))
//│ ([checkb:7^2]: 1'checkb) <: ([]: ([]: 6'b) => ([]: 7'4_callres))
//│ <<<<<<<<<< initial constraints <<<<<<<<<<
//│ 
//│ ------- knots -------
//│ S(Z) <: 8'6_callres
//│ 	[-fst:8^28 · +minuss:6^27 · +checkb:7^2 · -checkb:7^2 · -minuss:6^13 · -checkb:7^2]  --->  [-fst:8^28 · +minuss:6^27 · +checkb:7^2 · -checkb:7^2]
//│ Z <: 8'6_callres
//│ 	[-fst:8^28 · +minuss:6^27 · +checkb:7^2 · +minuss:6^13 · +checkb:7^2 · -checkb:7^2 · -minuss:6^13 · -checkb:7^2]  --->  [-fst:8^28 · +minuss:6^27 · +checkb:7^2 · +minuss:6^13 · +checkb:7^2 · -checkb:7^2]
//│ 	[-minuss:6^13 · -checkb:7^2 · -minuss:6^13 · -checkb:7^2]  --->  [-minuss:6^13 · -checkb:7^2]
