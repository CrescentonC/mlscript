:NewParser
:ParseOnly


// NOTE: the `p` inside `C(p)` is untouched
// TODO don't rewrite dead code
let p = C(p)
fun c(x) = if C(x) is
    C(a) then a
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |a|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then a›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c:7^8 p:6^9)
//│ def c:7 = (fun x:8 -> case [C x:8^3] of {
//│ 	C a:9 => a:9^5})
//│ def p:6 = [C p:6^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c:7^8] ---> [c:7^8] (hopeless to continue)
//│ [p:6^9] ---> [p:6^9] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c:7^11 p:6^12)
//│ def c:7 = (fun x:8 -> case [C x:8^6] of {
//│ 	C a:9 => a:9^8})
//│ def p:6 = [C p:6^4]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 7: [C 6: x:8^6]
//│ [C x:8^6] --->
//│ 	case [C x:8^6] of {C a:9 => a:9^8}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c:7^14 p:6^15)
//│ def c:7 = (fun x:8 -> let a:9 = x:8^20
//│ in a:9^19)
//│ def p:6 = [C p:6^17]
//│ <<<<<<< after fusion <<<<<<<


// NOTE: how to produce a finite rewrtten program?
_LUMBERHACK_ERROR
let p = Pair(A, B)
fun c(x) = if x is
    Pair(a, b) then c(Pair(b, a))
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c:7^12 p:6^13)
//│ def c:7 = (fun x:8 -> case x:8^4 of {
//│ 	Pair a:9 b:10 => (c:7^5 [Pair b:10^6 a:9^7])})
//│ def p:6 = [Pair [A] [B]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c:7^12] ---> [c:7^12] (hopeless to continue)
//│ [p:6^13] ---> [p:6^13] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c:7^15 p:6^16)
//│ def c:7 = (fun x:8 -> case x:8^7 of {
//│ 	Pair a:9 b:10 => (c:7^8 [Pair b:10^9 a:9^10])})
//│ def p:6 = [Pair [A] [B]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 11: [Pair 9: b:10^9 10: a:9^10]
//│ [Pair b:10^9 a:9^10] --->
//│ 	case x:8^7 of {Pair a:9 b:10 => (c:7^8 [Pair b:10^9 a:9^10])}
//│ 6: [Pair 4: [A] 5: [B]]
//│ [Pair [A] [B]] --->
//│ 	case x:8^7 of {Pair a:9 b:10 => (c:7^8 [Pair b:10^9 a:9^10])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!

// Just a more valid/reasonable version of the above
// TODO support nested patterns as in `Pair(0)`
// TODO get a recursive knot even when using `primitive` (we get it without)
_LUMBERHACK_ERROR
let p = Wrap(3)
fun c(x) = if x is
    N then 0
    Wrap(a) then c(Wrap(primitive(a)))
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Wrap|(|3|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |0|↵|Wrap|(|a|)| |#then| |c|(|Wrap|(|primitive|(|a|)|)|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Wrap (3,); fun c = x, => if x is ‹(N) then 0; (Wrap (a,)) then c (Wrap (primitive (a,),),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c:7^13 p:6^14)
//│ def c:7 = (fun x:8 -> case x:8^3 of {
//│ 	N => 0
//│ 	| Wrap a:9 => (c:7^5 [Wrap (primitive:3^6 a:9^7)])})
//│ def p:6 = [Wrap 3]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c:7^13] ---> [c:7^13] (hopeless to continue)
//│ [p:6^14] ---> [p:6^14] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c:7^16 p:6^17)
//│ def c:7 = (fun x:8 -> case x:8^6 of {
//│ 	N => 0
//│ 	| Wrap a:9 => (c:7^8 [Wrap (primitive:3^9 a:9^10)])})
//│ def p:6 = [Wrap 3]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 12: [Wrap 11: (9: primitive:3^9 10: a:9^10)]
//│ [Wrap (primitive:3^9 a:9^10)] --->
//│ 	case x:8^6 of {N => 0 | Wrap a:9 => (c:7^8 [Wrap (primitive:3^9 a:9^10)])}
//│ 5: [Wrap 4: 3]
//│ [Wrap 3] --->
//│ 	case x:8^6 of {N => 0 | Wrap a:9 => (c:7^8 [Wrap (primitive:3^9 a:9^10)])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!

fun c(x) = if primitive(x) is
    True then 0
    False then c(primitive(x))
c(0)
//│ |#fun| |c|(|x|)| |#=| |#if| |primitive|(|x|)| |is|→|True| |#then| |0|↵|False| |#then| |c|(|primitive|(|x|)|)|←|↵|c|(|0|)|
//│ Parsed: {fun c = x, => if primitive (x,) is ‹(True) then 0; (False) then c (primitive (x,),)›; c (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c:6^12 0)
//│ def c:6 = (fun x:7 -> case (primitive:3^1 x:7^2) of {
//│ 	True => 0
//│ 	| False => (c:6^5 (primitive:3^6 x:7^7))})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c:6^12] ---> [c:6^12] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c:6^15 0)
//│ def c:6 = (fun x:7 -> case (primitive:3^4 x:7^5) of {
//│ 	True => 0
//│ 	| False => (c:6^8 (primitive:3^9 x:7^10))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c:6^18 0)
//│ def c:6 = (fun x:7 -> case (primitive:3^21 x:7^22) of {
//│ 	True => 0
//│ 	| False => (c:6^25 (primitive:3^26 x:7^27))})
//│ <<<<<<< after fusion <<<<<<<


// NOTE: only the first two element is handled
_LUMBERHACK_ERROR
fun map(f, ls) = if ls is
    C(h, t) then C(f(h), map(f, t))
    N then N
fun ff(x) = if x is
    K then T
    KK then TT
    KKKK then TTTT
let l = C(K, C(KK, C(KKKK, N)))
map(ff, l)
//│ |_LUMBERHACK_ERROR|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|ff|,| |l|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; let l = C (K, C (KK, C (KKKK, N,),),); map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((map:6^28 ff:7^29) l:8^31)
//│ def ff:7 = (fun x:13 -> case x:13^15 of {
//│ 	K => [T]
//│ 	| KK => [TT]
//│ 	| KKKK => [TTTT]})
//│ def l:8 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map:6 = (fun f:9 -> (fun ls:10 -> case ls:10^1 of {
//│ 	C h:11 t:12 => [C (f:9^2 h:11^3) ((map:6^5 f:9^6) t:12^8)]
//│ 	| N => [N]}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 6't
//│ 	[-l:8^31 · +map:6^28 · +map:6^5 · +map:6^5 · +map:6^5 · +map:6^5]  --->  [-l:8^31 · +map:6^28 · +map:6^5 · +map:6^5 · +map:6^5]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [map:6^28 · map:6^5 · map:6^5 · map:6^5 · map:6^5] --> [map:6^28 · map:6^5 · map:6^5 · map:6^5]
//│ [l:8^31] --> [l:8^31]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff:7^29] ---> [ff:7^29] (hopeless to continue)
//│ [l:8^31]
//│ 
//│ [map:6^28]
//│ 	[map:6^28 · map:6^5]
//│ 		[map:6^28 · map:6^5 · map:6^5]
//│ 			[map:6^28 · map:6^5 · map:6^5 · map:6^5]
//│ 				[map:6^28 · map:6^5 · map:6^5 · map:6^5 · map:6^5] ---> [map:6^28 · map:6^5 · map:6^5 · map:6^5] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (([map:6^28]:14^96 ff:7^97) [l:8^31]:18^99)
//│ def [l:8^31]:18 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def [map:6^28 · map:6^5 · map:6^5 · map:6^5]:17 = (fun f:25 -> (fun ls:26 -> case ls:26^33 of {
//│ 	C h:27 t:28 => [C (f:25^34 h:27^35) (([map:6^28 · map:6^5 · map:6^5 · map:6^5]:17^37 f:25^38) t:28^40)]
//│ 	| N => [N]}))
//│ def [map:6^28 · map:6^5 · map:6^5]:16 = (fun f:29 -> (fun ls:30 -> case ls:30^47 of {
//│ 	C h:31 t:32 => [C (f:29^48 h:31^49) (([map:6^28 · map:6^5 · map:6^5 · map:6^5]:17^51 f:29^52) t:32^54)]
//│ 	| N => [N]}))
//│ def [map:6^28 · map:6^5]:15 = (fun f:37 -> (fun ls:38 -> case ls:38^82 of {
//│ 	C h:39 t:40 => [C (f:37^83 h:39^84) (([map:6^28 · map:6^5 · map:6^5]:16^86 f:37^87) t:40^89)]
//│ 	| N => [N]}))
//│ def [map:6^28]:14 = (fun f:33 -> (fun ls:34 -> case ls:34^61 of {
//│ 	C h:35 t:36 => [C (f:33^62 h:35^63) (([map:6^28 · map:6^5]:15^65 f:33^66) t:36^68)]
//│ 	| N => [N]}))
//│ def ff:7 = (fun x:13 -> case x:13^20 of {
//│ 	K => [T]
//│ 	| KK => [TT]
//│ 	| KKKK => [TTTT]})
//│ def l:8 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map:6 = (fun f:9 -> (fun ls:10 -> case ls:10^6 of {
//│ 	C h:11 t:12 => [C (f:9^7 h:11^8) ((map:6^10 f:9^11) t:12^13)]
//│ 	| N => [N]}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 75: [K]
//│ [K] --->
//│ 	case x:13^20 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 76: [KK]
//│ [KK] --->
//│ 	case x:13^20 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 77: [KKKK]
//│ [KKKK] --->
//│ 	case x:13^20 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 78: [N]
//│ [N] --->
//│ 	case ls:26^33 of {C h:27 t:28 => [C (f:25^34 h:27^35) (([map:6^28 · map:6^5 · map:6^5 · map:6^5]:17^37 f:25^38) t:28^40)] | N => [N]}
//│ 79: [C 77: [KKKK] 78: [N]]
//│ [C [KKKK] [N]] --->
//│ 	case ls:30^47 of {C h:31 t:32 => [C (f:29^48 h:31^49) (([map:6^28 · map:6^5 · map:6^5 · map:6^5]:17^51 f:29^52) t:32^54)] | N => [N]}
//│ 80: [C 76: [KK] 79: [C 77: [KKKK] 78: [N]]]
//│ [C [KK] [C [KKKK] [N]]] --->
//│ 	case ls:38^82 of {C h:39 t:40 => [C (f:37^83 h:39^84) (([map:6^28 · map:6^5 · map:6^5]:16^86 f:37^87) t:40^89)] | N => [N]}
//│ 81: [C 75: [K] 80: [C 76: [KK] 79: [C 77: [KKKK] 78: [N]]]]
//│ [C [K] [C [KK] [C [KKKK] [N]]]] --->
//│ 	case ls:34^61 of {C h:35 t:36 => [C (f:33^62 h:35^63) (([map:6^28 · map:6^5]:15^65 f:33^66) t:36^68)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (([map:6^28]:14^101 ff:7^102) [l:8^31]:18^104)
//│ def [l:8^31]:18 = let h:35 = [T]
//│ in let t:36 = 
//│ 	let h:39 = [TT]
//│ 	in let t:40 = 
//│ 		let h:31 = [TTTT]
//│ 		in let t:32 = [N]
//│ 		in [C (f:29^143 h:31^144) (([map:6^28 · map:6^5 · map:6^5 · map:6^5]:17^146 f:29^147) t:32^149)]
//│ 	in [C (f:37^134 h:39^135) (([map:6^28 · map:6^5 · map:6^5]:16^137 f:37^138) t:40^140)]
//│ in [C (f:33^125 h:35^126) (([map:6^28 · map:6^5]:15^128 f:33^129) t:36^131)]
//│ def [map:6^28 · map:6^5 · map:6^5 · map:6^5]:17 = (fun f:25 -> (fun ls:26 -> ls:26^162))
//│ def [map:6^28 · map:6^5 · map:6^5]:16 = (fun f:29 -> (fun ls:30 -> ls:30^172))
//│ def [map:6^28 · map:6^5]:15 = (fun f:37 -> (fun ls:38 -> ls:38^175))
//│ def [map:6^28]:14 = (fun f:33 -> (fun ls:34 -> ls:34^106))
//│ def ff:7 = (fun x:13 -> x:13^123)
//│ def l:8 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map:6 = (fun f:9 -> (fun ls:10 -> case ls:10^109 of {
//│ 	C h:11 t:12 => [C (f:9^110 h:11^111) ((map:6^113 f:9^114) t:12^116)]
//│ 	| N => [N]}))
//│ <<<<<<< after fusion <<<<<<<


// NOTE: some program not be able to write?
_LUMBERHACK_ERROR
fun last(ls) = if ls is
    C(h, t) then if t is
        N then Some(h)
        C(hh, tt) then last(t)
        // C(hh, tt) then last(C(hh, tt))
    N then None
let p = C(1, C(2, N))
last(p)
//│ |_LUMBERHACK_ERROR|↵|#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |last|(|t|)|↵|/* C(hh, tt) then last(C(hh, tt))*/|←|↵|N| |#then| |None|←|↵|#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|last|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun last = ls, => if ls is ‹(C (h, t,)) then if t is ‹(N) then Some (h,); (C (hh, tt,)) then last (t,)›; (N) then None›; let p = C (1, C (2, N,),); last (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (last:6^17 p:7^18)
//│ def last:6 = (fun ls:8 -> case ls:8^1 of {
//│ 	C h:9 t:10 => case t:10^2 of {
//│ 		N => [Some h:9^3]
//│ 		| C hh:11 tt:12 => (last:6^5 t:10^6)}
//│ 	| N => [None]})
//│ def p:7 = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 4't
//│ 	[-p:7^18 · +last:6^17 · +last:6^5 · +last:6^5 · +last:6^5]  --->  [-p:7^18 · +last:6^17 · +last:6^5 · +last:6^5]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [last:6^17 · last:6^5 · last:6^5 · last:6^5] --> [last:6^17 · last:6^5 · last:6^5]
//│ [p:7^18] --> [p:7^18]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last:6^17]
//│ 	[last:6^17 · last:6^5]
//│ 		[last:6^17 · last:6^5 · last:6^5]
//│ 			[last:6^17 · last:6^5 · last:6^5 · last:6^5] ---> [last:6^17 · last:6^5 · last:6^5] (only one)
//│ [p:7^18]
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([last:6^17]:14^58 [p:7^18]:13^59)
//│ def [last:6^17 · last:6^5 · last:6^5]:16 = (fun ls:33 -> case ls:33^47 of {
//│ 	C h:34 t:35 => case t:35^48 of {
//│ 		N => [Some h:34^49]
//│ 		| C hh:36 tt:37 => ([last:6^17 · last:6^5 · last:6^5]:16^51 t:35^52)}
//│ 	| N => [None]})
//│ def [last:6^17 · last:6^5]:15 = (fun ls:23 -> case ls:23^25 of {
//│ 	C h:24 t:25 => case t:25^26 of {
//│ 		N => [Some h:24^27]
//│ 		| C hh:26 tt:27 => ([last:6^17 · last:6^5 · last:6^5]:16^29 t:25^30)}
//│ 	| N => [None]})
//│ def [last:6^17]:14 = (fun ls:28 -> case ls:28^36 of {
//│ 	C h:29 t:30 => case t:30^37 of {
//│ 		N => [Some h:29^38]
//│ 		| C hh:31 tt:32 => ([last:6^17 · last:6^5]:15^40 t:30^41)}
//│ 	| N => [None]})
//│ def [p:7^18]:13 = [C 1 [C 2 [N]]]
//│ def last:6 = (fun ls:8 -> case ls:8^4 of {
//│ 	C h:9 t:10 => case t:10^5 of {
//│ 		N => [Some h:9^6]
//│ 		| C hh:11 tt:12 => (last:6^8 t:10^9)}
//│ 	| N => [None]})
//│ def p:7 = [C 1 [C 2 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 22: [N]
//│ [N] --->
//│ 	case ls:33^47 of {C h:34 t:35 => case t:35^48 of {N => [Some h:34^49] | C hh:36 tt:37 => ([last:6^17 · last:6^5 · last:6^5]:16^51 t:35^52)} | N => [None]}
//│ 	case t:25^26 of {N => [Some h:24^27] | C hh:26 tt:27 => ([last:6^17 · last:6^5 · last:6^5]:16^29 t:25^30)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 23: [C 21: 2 22: [N]]
//│ [C 2 [N]] --->
//│ 	case ls:23^25 of {C h:24 t:25 => case t:25^26 of {N => [Some h:24^27] | C hh:26 tt:27 => ([last:6^17 · last:6^5 · last:6^5]:16^29 t:25^30)} | N => [None]}
//│ 	case t:30^37 of {N => [Some h:29^38] | C hh:31 tt:32 => ([last:6^17 · last:6^5]:15^40 t:30^41)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 24: [C 20: 1 23: [C 21: 2 22: [N]]]
//│ [C 1 [C 2 [N]]] --->
//│ 	case ls:28^36 of {C h:29 t:30 => case t:30^37 of {N => [Some h:29^38] | C hh:31 tt:32 => ([last:6^17 · last:6^5]:15^40 t:30^41)} | N => [None]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([last:6^17]:14^61 [p:7^18]:13^62)
//│ def [last:6^17 · last:6^5 · last:6^5]:16 = (fun ls:33 -> ls:33^73)
//│ def [last:6^17 · last:6^5]:15 = (fun ls:23 -> ls:23^71)
//│ def [last:6^17]:14 = (fun ls:28 -> ls:28^69)
//│ def [p:7^18]:13 = let h:29 = 1
//│ in let t:30 = 
//│ 	let h:24 = 2
//│ 	in let t:25 = [None]
//│ 	in case t:25^93 of {
//│ 		N => [Some h:24^94]
//│ 		| C hh:26 tt:27 => ([last:6^17 · last:6^5 · last:6^5]:16^96 t:25^97)}
//│ in case t:30^86 of {
//│ 	N => [Some h:29^87]
//│ 	| C hh:31 tt:32 => ([last:6^17 · last:6^5]:15^89 t:30^90)}
//│ def last:6 = (fun ls:8 -> case ls:8^75 of {
//│ 	C h:9 t:10 => case t:10^76 of {
//│ 		N => [Some h:9^77]
//│ 		| C hh:11 tt:12 => (last:6^79 t:10^80)}
//│ 	| N => [None]})
//│ def p:7 = [C 1 [C 2 [N]]]
//│ <<<<<<< after fusion <<<<<<<

_LUMBERHACK_ERROR
let add = primitive
fun idxSum(ls) = if ls is
    N then acc => 0
    C(h, t) then acc => add(acc, idxSum(t)(add(acc, 1)))
fun rev(lss, a) = if lss is
    N then a
    C(hh, tt) then rev(tt, C(hh, a))
idxSum(rev(primitive, N))(0)
//│ |_LUMBERHACK_ERROR|↵|#let| |add| |#=| |primitive|↵|#fun| |idxSum|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc| |=>| |0|↵|C|(|h|,| |t|)| |#then| |acc| |=>| |add|(|acc|,| |idxSum|(|t|)|(|add|(|acc|,| |1|)|)|)|←|↵|#fun| |rev|(|lss|,| |a|)| |#=| |#if| |lss| |is|→|N| |#then| |a|↵|C|(|hh|,| |tt|)| |#then| |rev|(|tt|,| |C|(|hh|,| |a|)|)|←|↵|idxSum|(|rev|(|primitive|,| |N|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_ERROR; let add = primitive; fun idxSum = ls, => if ls is ‹(N) then acc, => 0; (C (h, t,)) then acc, => add (acc, idxSum (t,) (add (acc, 1,),),)›; fun rev = lss, a, => if lss is ‹(N) then a; (C (hh, tt,)) then rev (tt, C (hh, a,),)›; idxSum (rev (primitive, N,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((idxSum:7^33 ((rev:8^34 primitive:3^35) [N])) 0)
//│ def add:4 = primitive:3^1
//│ def idxSum:7 = (fun ls:9 -> case ls:9^2 of {
//│ 	N => (fun acc:10 -> 0)
//│ 	| C h:11 t:12 => (fun acc:13 -> ((add:4^5 acc:13^6) ((idxSum:7^8 t:12^9) ((add:4^11 acc:13^12) 1))))})
//│ def rev:8 = (fun lss:14 -> (fun a:15 -> case lss:14^21 of {
//│ 	N => a:15^22
//│ 	| C hh:16 tt:17 => ((rev:8^23 tt:17^24) [C hh:16^26 a:15^27])}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(17'hh, 16'a) <: 3'ls
//│ 	[+rev:8^23 · +rev:8^23 · +rev:8^23 · -rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8 · +idxSum:7^8]  --->  [+rev:8^23 · +rev:8^23 · -rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8]
//│ 	[+rev:8^23 · +rev:8^23 · +rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8 · +idxSum:7^8]  --->  [+rev:8^23 · +rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8]
//│ NoProd <: 15'lss
//│ 	[+rev:8^34 · +rev:8^23 · +rev:8^23]  --->  [+rev:8^34 · +rev:8^23]
//│ NoProd <: 3'ls
//│ 	[+rev:8^34 · -rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8 · +idxSum:7^8]  --->  [+rev:8^34 · -rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8]
//│ 	[+rev:8^34 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8 · +idxSum:7^8]  --->  [+rev:8^34 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8]
//│ NoProd <: 6't
//│ 	[+rev:8^34 · +rev:8^23 · +rev:8^23 · -rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8 · +idxSum:7^8 · +idxSum:7^8]  --->  [+rev:8^34 · +rev:8^23 · +rev:8^23 · -rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8 · +idxSum:7^8]
//│ 	[+rev:8^34 · +rev:8^23 · +rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8 · +idxSum:7^8 · +idxSum:7^8]  --->  [+rev:8^34 · +rev:8^23 · +rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8 · +idxSum:7^8]
//│ 	[+rev:8^34 · +rev:8^23 · -rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8 · +idxSum:7^8]  --->  [+rev:8^34 · +rev:8^23 · -rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8]
//│ 	[+rev:8^34 · +rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8 · +idxSum:7^8]  --->  [+rev:8^34 · +rev:8^23 · -rev:8^34 · +idxSum:7^33 · +idxSum:7^8]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [idxSum:7^33 · idxSum:7^8 · idxSum:7^8] --> [idxSum:7^33 · idxSum:7^8]
//│ [rev:8^34 · rev:8^23 · rev:8^23] --> [rev:8^34 · rev:8^23]
//│ [rev:8^34 · rev:8^23] --> [rev:8^34 · rev:8^23]
//│ [rev:8^34] --> [rev:8^34]
//│ [] --> []
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [idxSum:7^33]
//│ 	[idxSum:7^33 · idxSum:7^8]
//│ 		[idxSum:7^33 · idxSum:7^8 · idxSum:7^8] ---> [idxSum:7^33 · idxSum:7^8] (only one)
//│ [rev:8^34]
//│ 	[rev:8^34 · rev:8^23]
//│ 		[rev:8^34 · rev:8^23 · rev:8^23] ---> [rev:8^34 · rev:8^23] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (([idxSum:7^33]:20^104 (([rev:8^34]:18^105 primitive:25^106) [N])) 0)
//│ def [idxSum:7^33 · idxSum:7^8]:21 = (fun ls:32 -> case ls:32^54 of {
//│ 	N => (fun acc:33 -> 0)
//│ 	| C h:34 t:35 => (fun acc:36 -> ((add:26^57 acc:36^58) (([idxSum:7^33 · idxSum:7^8]:21^60 t:35^61) ((add:26^63 acc:36^64) 1))))})
//│ def [idxSum:7^33]:20 = (fun ls:37 -> case ls:37^73 of {
//│ 	N => (fun acc:38 -> 0)
//│ 	| C h:39 t:40 => (fun acc:41 -> ((add:26^76 acc:41^77) (([idxSum:7^33 · idxSum:7^8]:21^79 t:40^80) ((add:26^82 acc:41^83) 1))))})
//│ def [rev:8^34 · rev:8^23]:19 = (fun lss:28 -> (fun a:29 -> case lss:28^42 of {
//│ 	N => a:29^43
//│ 	| C hh:30 tt:31 => (([rev:8^34 · rev:8^23]:19^44 tt:31^45) [C hh:30^47 a:29^48])}))
//│ def [rev:8^34]:18 = (fun lss:42 -> (fun a:43 -> case lss:42^92 of {
//│ 	N => a:43^93
//│ 	| C hh:44 tt:45 => (([rev:8^34 · rev:8^23]:19^94 tt:45^95) [C hh:44^97 a:43^98])}))
//│ def add:4 = primitive:3^10
//│ def idxSum:7 = (fun ls:9 -> case ls:9^11 of {
//│ 	N => (fun acc:10 -> 0)
//│ 	| C h:11 t:12 => (fun acc:13 -> ((add:4^14 acc:13^15) ((idxSum:7^17 t:12^18) ((add:4^20 acc:13^21) 1))))})
//│ def rev:8 = (fun lss:14 -> (fun a:15 -> case lss:14^30 of {
//│ 	N => a:15^31
//│ 	| C hh:16 tt:17 => ((rev:8^32 tt:17^33) [C hh:16^35 a:15^36])}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 108: [N]
//│ [N] --->
//│ 	case ls:32^54 of {N => (fun acc:33 -> 0) | C h:34 t:35 => (fun acc:36 -> ((add:26^57 acc:36^58) (([idxSum:7^33 · idxSum:7^8]:21^60 t:35^61) ((add:26^63 acc:36^64) 1))))}
//│ 	case ls:37^73 of {N => (fun acc:38 -> 0) | C h:39 t:40 => (fun acc:41 -> ((add:26^76 acc:41^77) (([idxSum:7^33 · idxSum:7^8]:21^79 t:40^80) ((add:26^82 acc:41^83) 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 49: [C 47: hh:30^47 48: a:29^48]
//│ [C hh:30^47 a:29^48] --->
//│ 	case ls:32^54 of {N => (fun acc:33 -> 0) | C h:34 t:35 => (fun acc:36 -> ((add:26^57 acc:36^58) (([idxSum:7^33 · idxSum:7^8]:21^60 t:35^61) ((add:26^63 acc:36^64) 1))))}
//│ 	case ls:37^73 of {N => (fun acc:38 -> 0) | C h:39 t:40 => (fun acc:41 -> ((add:26^76 acc:41^77) (([idxSum:7^33 · idxSum:7^8]:21^79 t:40^80) ((add:26^82 acc:41^83) 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 99: [C 97: hh:44^97 98: a:43^98]
//│ [C hh:44^97 a:43^98] --->
//│ 	case ls:32^54 of {N => (fun acc:33 -> 0) | C h:34 t:35 => (fun acc:36 -> ((add:26^57 acc:36^58) (([idxSum:7^33 · idxSum:7^8]:21^60 t:35^61) ((add:26^63 acc:36^64) 1))))}
//│ 	case ls:37^73 of {N => (fun acc:38 -> 0) | C h:39 t:40 => (fun acc:41 -> ((add:26^76 acc:41^77) (([idxSum:7^33 · idxSum:7^8]:21^79 t:40^80) ((add:26^82 acc:41^83) 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (([idxSum:7^33]:20^113 (([rev:8^34]:18^114 primitive:25^115) (fun acc:38 -> 0))) 0)
//│ def [idxSum:7^33 · idxSum:7^8]:21 = (fun ls:32 -> case ls:32^123 of {
//│ 	N => (fun acc:33 -> 0)
//│ 	| C h:34 t:35 => (fun acc:36 -> ((add:26^126 acc:36^127) (([idxSum:7^33 · idxSum:7^8]:21^129 t:35^130) ((add:26^132 acc:36^133) 1))))})
//│ def [idxSum:7^33]:20 = (fun ls:37 -> ls:37^228)
//│ def [rev:8^34 · rev:8^23]:19 = (fun lss:28 -> (fun a:29 -> case lss:28^201 of {
//│ 	N => a:29^202
//│ 	| C hh:30 tt:31 => (([rev:8^34 · rev:8^23]:19^203 tt:31^204) let h:39 = hh:30^222
//│ 	in let t:40 = a:29^220
//│ 	in (fun acc:41 -> ((add:26^206 acc:41^207) (([idxSum:7^33 · idxSum:7^8]:21^209 t:40^210) ((add:26^212 acc:41^213) 1)))))}))
//│ def [rev:8^34]:18 = (fun lss:42 -> (fun a:43 -> case lss:42^142 of {
//│ 	N => a:43^143
//│ 	| C hh:44 tt:45 => (([rev:8^34 · rev:8^23]:19^144 tt:45^145) let h:39 = hh:44^163
//│ 	in let t:40 = a:43^161
//│ 	in (fun acc:41 -> ((add:26^147 acc:41^148) (([idxSum:7^33 · idxSum:7^8]:21^150 t:40^151) ((add:26^153 acc:41^154) 1)))))}))
//│ def add:4 = primitive:3^181
//│ def idxSum:7 = (fun ls:9 -> case ls:9^182 of {
//│ 	N => (fun acc:10 -> 0)
//│ 	| C h:11 t:12 => (fun acc:13 -> ((add:4^185 acc:13^186) ((idxSum:7^188 t:12^189) ((add:4^191 acc:13^192) 1))))})
//│ def rev:8 = (fun lss:14 -> (fun a:15 -> case lss:14^169 of {
//│ 	N => a:15^170
//│ 	| C hh:16 tt:17 => ((rev:8^171 tt:17^172) [C hh:16^174 a:15^175])}))
//│ <<<<<<< after fusion <<<<<<<


fun minuss(a) = if a is
    S(aa) then b => if b is
        S(bb) then minuss(aa, bb)
        Z then aa
    Z then n => Z
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |#if| |b| |is|→|S|(|bb|)| |#then| |minuss|(|aa|,| |bb|)|↵|Z| |#then| |aa|←|↵|Z| |#then| |n| |=>| |Z|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {fun minuss = a, => if a is ‹(S (aa,)) then b, => if b is ‹(S (bb,)) then minuss (aa, bb,); (Z) then aa›; (Z) then n, => Z›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((minuss:6^19 fst:7^20) snd:8^22)
//│ def fst:7 = [S [S [Z]]]
//│ def minuss:6 = (fun a:9 -> case a:9^1 of {
//│ 	S aa:10 => (fun b:11 -> case b:11^2 of {
//│ 		S bb:12 => ((minuss:6^3 aa:10^4) bb:12^6)
//│ 		| Z => aa:10^8})
//│ 	| Z => (fun n:13 -> [Z])})
//│ def snd:8 = [Z]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 4'aa
//│ 	[-fst:7^20 · +minuss:6^19 · +minuss:6^3 · +minuss:6^3 · +minuss:6^3]  --->  [-fst:7^20 · +minuss:6^19 · +minuss:6^3 · +minuss:6^3]
//│ NoProd <: 5'b
//│ 	[-snd:8^22 · +minuss:6^19 · +minuss:6^3 · +minuss:6^3]  --->  [-snd:8^22 · +minuss:6^19 · +minuss:6^3]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [minuss:6^19 · minuss:6^3 · minuss:6^3 · minuss:6^3] --> [minuss:6^19 · minuss:6^3 · minuss:6^3]
//│ [minuss:6^19 · minuss:6^3 · minuss:6^3] --> [minuss:6^19 · minuss:6^3]
//│ [fst:7^20] --> [fst:7^20]
//│ [snd:8^22] --> [snd:8^22]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fst:7^20]
//│ 
//│ [minuss:6^19]
//│ 	[minuss:6^19 · minuss:6^3]
//│ 		[minuss:6^19 · minuss:6^3 · minuss:6^3] ---> [minuss:6^19 · minuss:6^3] (only one)
//│ [snd:8^22]
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (([minuss:6^19]:15^56 [fst:7^20]:17^57) [snd:8^22]:14^59)
//│ def [fst:7^20]:17 = [S [S [Z]]]
//│ def [minuss:6^19 · minuss:6^3]:16 = (fun a:29 -> case a:29^42 of {
//│ 	S aa:30 => (fun b:31 -> case b:31^43 of {
//│ 		S bb:32 => (([minuss:6^19 · minuss:6^3]:16^44 aa:30^45) bb:32^47)
//│ 		| Z => aa:30^49})
//│ 	| Z => (fun n:33 -> [Z])})
//│ def [minuss:6^19]:15 = (fun a:24 -> case a:24^28 of {
//│ 	S aa:25 => (fun b:26 -> case b:26^29 of {
//│ 		S bb:27 => (([minuss:6^19 · minuss:6^3]:16^30 aa:25^31) bb:27^33)
//│ 		| Z => aa:25^35})
//│ 	| Z => (fun n:28 -> [Z])})
//│ def [snd:8^22]:14 = [Z]
//│ def fst:7 = [S [S [Z]]]
//│ def minuss:6 = (fun a:9 -> case a:9^6 of {
//│ 	S aa:10 => (fun b:11 -> case b:11^7 of {
//│ 		S bb:12 => ((minuss:6^8 aa:10^9) bb:12^11)
//│ 		| Z => aa:10^13})
//│ 	| Z => (fun n:13 -> [Z])})
//│ def snd:8 = [Z]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 24: [Z]
//│ [Z] --->
//│ 	case b:26^29 of {S bb:27 => (([minuss:6^19 · minuss:6^3]:16^30 aa:25^31) bb:27^33) | Z => aa:25^35}
//│ 25: [Z]
//│ [Z] --->
//│ 	case a:29^42 of {S aa:30 => (fun b:31 -> case b:31^43 of {S bb:32 => (([minuss:6^19 · minuss:6^3]:16^44 aa:30^45) bb:32^47) | Z => aa:30^49}) | Z => (fun n:33 -> [Z])}
//│ 26: [S 25: [Z]]
//│ [S [Z]] --->
//│ 	case a:29^42 of {S aa:30 => (fun b:31 -> case b:31^43 of {S bb:32 => (([minuss:6^19 · minuss:6^3]:16^44 aa:30^45) bb:32^47) | Z => aa:30^49}) | Z => (fun n:33 -> [Z])}
//│ 27: [S 26: [S 25: [Z]]]
//│ [S [S [Z]]] --->
//│ 	case a:24^28 of {S aa:25 => (fun b:26 -> case b:26^29 of {S bb:27 => (([minuss:6^19 · minuss:6^3]:16^30 aa:25^31) bb:27^33) | Z => aa:25^35}) | Z => (fun n:28 -> [Z])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (([minuss:6^19]:15^61 [fst:7^20]:17^62) [snd:8^22]:14^64)
//│ def [fst:7^20]:17 = let aa:25 = 
//│ 	let aa:30 = (fun n:33 -> [Z])
//│ 	in (fun b:31 -> case b:31^68 of {
//│ 		S bb:32 => (([minuss:6^19 · minuss:6^3]:16^69 aa:30^70) bb:32^72)
//│ 		| Z => aa:30^74})
//│ in (fun b:26 -> b:26^66)
//│ def [minuss:6^19 · minuss:6^3]:16 = (fun a:29 -> a:29^81)
//│ def [minuss:6^19]:15 = (fun a:24 -> a:24^102)
//│ def [snd:8^22]:14 = aa:25^87
//│ def fst:7 = [S [S [Z]]]
//│ def minuss:6 = (fun a:9 -> case a:9^88 of {
//│ 	S aa:10 => (fun b:11 -> case b:11^89 of {
//│ 		S bb:12 => ((minuss:6^90 aa:10^91) bb:12^93)
//│ 		| Z => aa:10^95})
//│ 	| Z => (fun n:13 -> [Z])})
//│ def snd:8 = [Z]
//│ <<<<<<< after fusion <<<<<<<

// FIXME: weird recursive
_LUMBERHACK_ERROR
fun minuss(a) = if a is
    S(aa) then b => checkb(b)(aa)
    Z then n => Z
fun checkb(b) = if b is
    S(bb) then aaa => minuss(aaa, bb)
    Z then aaa => aaa
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |_LUMBERHACK_ERROR|↵|#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |checkb|(|b|)|(|aa|)|↵|Z| |#then| |n| |=>| |Z|←|↵|#fun| |checkb|(|b|)| |#=| |#if| |b| |is|→|S|(|bb|)| |#then| |aaa| |=>| |minuss|(|aaa|,| |bb|)|↵|Z| |#then| |aaa| |=>| |aaa|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun minuss = a, => if a is ‹(S (aa,)) then b, => checkb (b,) (aa,); (Z) then n, => Z›; fun checkb = b, => if b is ‹(S (bb,)) then aaa, => minuss (aaa, bb,); (Z) then aaa, => aaa›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((minuss:6^27 fst:8^28) snd:9^30)
//│ def checkb:7 = (fun b:14 -> case b:14^12 of {
//│ 	S bb:15 => (fun aaa:16 -> ((minuss:6^13 aaa:16^14) bb:15^16))
//│ 	| Z => (fun aaa:17 -> aaa:17^19)})
//│ def fst:8 = [S [S [Z]]]
//│ def minuss:6 = (fun a:10 -> case a:10^1 of {
//│ 	S aa:11 => (fun b:12 -> ((checkb:7^2 b:12^3) aa:11^5))
//│ 	| Z => (fun n:13 -> [Z])})
//│ def snd:9 = [Z]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 12'bb
//│ 	[-snd:9^30 · +minuss:6^27 · +checkb:7^2 · +minuss:6^13 · +checkb:7^2]  --->  [-snd:9^30 · +minuss:6^27 · +checkb:7^2]
//│ NoProd <: 5'aa
//│ 	[-fst:8^28 · +minuss:6^27 · +checkb:7^2 · +minuss:6^13 · +checkb:7^2 · +minuss:6^13 · +checkb:7^2 · +minuss:6^13]  --->  [-fst:8^28 · +minuss:6^27 · +checkb:7^2 · +minuss:6^13 · +checkb:7^2 · +minuss:6^13]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [minuss:6^27 · checkb:7^2 · minuss:6^13 · checkb:7^2 · minuss:6^13 · checkb:7^2 · minuss:6^13] --> [minuss:6^27 · checkb:7^2 · minuss:6^13 · checkb:7^2 · minuss:6^13]
//│ [minuss:6^27 · checkb:7^2 · minuss:6^13 · checkb:7^2] --> [minuss:6^27 · checkb:7^2]
//│ [fst:8^28] --> [fst:8^28]
//│ [snd:9^30] --> [snd:9^30]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fst:8^28]
//│ 
//│ [minuss:6^27]
//│ 	[minuss:6^27 · checkb:7^2]
//│ 		[minuss:6^27 · checkb:7^2 · minuss:6^13]
//│ 			[minuss:6^27 · checkb:7^2 · minuss:6^13 · checkb:7^2] ---> [minuss:6^27 · checkb:7^2] (only one)
//│ [snd:9^30]
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (([minuss:6^27]:18^69 [fst:8^28]:22^70) [snd:9^30]:21^72)
//│ def [fst:8^28]:22 = [S [S [Z]]]
//│ def [minuss:6^27 · checkb:7^2 · minuss:6^13]:20 = (fun a:33 -> case a:33^46 of {
//│ 	S aa:34 => (fun b:35 -> (([minuss:6^27 · checkb:7^2]:19^47 b:35^48) aa:34^50))
//│ 	| Z => (fun n:36 -> [Z])})
//│ def [minuss:6^27 · checkb:7^2]:19 = (fun b:29 -> case b:29^35 of {
//│ 	S bb:30 => (fun aaa:31 -> (([minuss:6^27 · checkb:7^2 · minuss:6^13]:20^36 aaa:31^37) bb:30^39))
//│ 	| Z => (fun aaa:32 -> aaa:32^42)})
//│ def [minuss:6^27]:18 = (fun a:37 -> case a:37^57 of {
//│ 	S aa:38 => (fun b:39 -> (([minuss:6^27 · checkb:7^2]:19^58 b:39^59) aa:38^61))
//│ 	| Z => (fun n:40 -> [Z])})
//│ def [snd:9^30]:21 = [Z]
//│ def checkb:7 = (fun b:14 -> case b:14^17 of {
//│ 	S bb:15 => (fun aaa:16 -> ((minuss:6^18 aaa:16^19) bb:15^21))
//│ 	| Z => (fun aaa:17 -> aaa:17^24)})
//│ def fst:8 = [S [S [Z]]]
//│ def minuss:6 = (fun a:10 -> case a:10^6 of {
//│ 	S aa:11 => (fun b:12 -> ((checkb:7^7 b:12^8) aa:11^10))
//│ 	| Z => (fun n:13 -> [Z])})
//│ def snd:9 = [Z]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 32: [Z]
//│ [Z] --->
//│ 	case a:33^46 of {S aa:34 => (fun b:35 -> (([minuss:6^27 · checkb:7^2]:19^47 b:35^48) aa:34^50)) | Z => (fun n:36 -> [Z])}
//│ 33: [S 32: [Z]]
//│ [S [Z]] --->
//│ 	case a:33^46 of {S aa:34 => (fun b:35 -> (([minuss:6^27 · checkb:7^2]:19^47 b:35^48) aa:34^50)) | Z => (fun n:36 -> [Z])}
//│ 34: [S 33: [S 32: [Z]]]
//│ [S [S [Z]]] --->
//│ 	case a:37^57 of {S aa:38 => (fun b:39 -> (([minuss:6^27 · checkb:7^2]:19^58 b:39^59) aa:38^61)) | Z => (fun n:40 -> [Z])}
//│ 68: [Z]
//│ [Z] --->
//│ 	case b:29^35 of {S bb:30 => (fun aaa:31 -> (([minuss:6^27 · checkb:7^2 · minuss:6^13]:20^36 aaa:31^37) bb:30^39)) | Z => (fun aaa:32 -> aaa:32^42)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (([minuss:6^27]:18^74 [fst:8^28]:22^75) [snd:9^30]:21^77)
//│ def [fst:8^28]:22 = let aa:38 = 
//│ 	let aa:34 = (fun n:36 -> [Z])
//│ 	in (fun b:35 -> (([minuss:6^27 · checkb:7^2]:19^87 b:35^88) aa:34^90))
//│ in (fun b:39 -> (([minuss:6^27 · checkb:7^2]:19^81 b:39^82) aa:38^84))
//│ def [minuss:6^27 · checkb:7^2 · minuss:6^13]:20 = (fun a:33 -> a:33^98)
//│ def [minuss:6^27 · checkb:7^2]:19 = (fun b:29 -> b:29^79)
//│ def [minuss:6^27]:18 = (fun a:37 -> a:37^125)
//│ def [snd:9^30]:21 = (fun aaa:32 -> aaa:32^127)
//│ def checkb:7 = (fun b:14 -> case b:14^114 of {
//│ 	S bb:15 => (fun aaa:16 -> ((minuss:6^115 aaa:16^116) bb:15^118))
//│ 	| Z => (fun aaa:17 -> aaa:17^121)})
//│ def fst:8 = [S [S [Z]]]
//│ def minuss:6 = (fun a:10 -> case a:10^103 of {
//│ 	S aa:11 => (fun b:12 -> ((checkb:7^104 b:12^105) aa:11^107))
//│ 	| Z => (fun n:13 -> [Z])})
//│ def snd:9 = [Z]
//│ <<<<<<< after fusion <<<<<<<


fun id(x) = if x is
    ID(b) then b
    C(a) then id(ID(C(a)))
let p = C(p)
fun c(y) = if y is
    C(aa) then c(aa)
c(id(p))
//│ |#fun| |id|(|x|)| |#=| |#if| |x| |is|→|ID|(|b|)| |#then| |b|↵|C|(|a|)| |#then| |id|(|ID|(|C|(|a|)|)|)|←|↵|#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |c|(|aa|)|←|↵|c|(|id|(|p|)|)|
//│ Parsed: {fun id = x, => if x is ‹(ID (b,)) then b; (C (a,)) then id (ID (C (a,),),)›; let p = C (p,); fun c = y, => if y is ‹(C (aa,)) then c (aa,)›; c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c:8^18 (id:6^19 p:7^20))
//│ def c:8 = (fun y:12 -> case y:12^12 of {
//│ 	C aa:13 => (c:8^13 aa:13^14)})
//│ def id:6 = (fun x:9 -> case x:9^1 of {
//│ 	ID b:10 => b:10^2
//│ 	| C a:11 => (id:6^3 [ID [C a:11^4]])})
//│ def p:7 = [C p:7^10]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(1'p_7^10) <: 9'aa
//│ 	[-p:7^10 · -p:7^10 · -p:7^20 · +id:6^19 · +id:6^3 · -id:6^19 · +c:8^18 · +c:8^13]  --->  [-p:7^10 · -p:7^20 · +id:6^19 · +id:6^3 · -id:6^19 · +c:8^18]
//│ 	[-p:7^10 · -p:7^10 · -p:7^20 · +id:6^19 · +id:6^3 · -id:6^3 · -id:6^19 · +c:8^18 · +c:8^13]  --->  [-p:7^10 · -p:7^20 · +id:6^19 · +id:6^3 · -id:6^3 · -id:6^19 · +c:8^18]
//│ NoProd <: 9'aa
//│ 	[+id:6^3 · +id:6^3 · -id:6^19 · +c:8^18 · +c:8^13]  --->  [+id:6^3 · +id:6^3 · -id:6^19 · +c:8^18]
//│ 	[+id:6^3 · +id:6^3 · -id:6^3 · -id:6^19 · +c:8^18 · +c:8^13]  --->  [+id:6^3 · +id:6^3 · -id:6^3 · -id:6^19 · +c:8^18]
//│ NoProd <: 8'y
//│ 	[-p:7^20 · +id:6^19 · -id:6^19 · +c:8^18 · +c:8^13]  --->  [-p:7^20 · +id:6^19 · -id:6^19 · +c:8^18]
//│ 	[-p:7^20 · +id:6^19 · -id:6^3 · -id:6^19 · +c:8^18 · +c:8^13]  --->  [-p:7^20 · +id:6^19 · -id:6^3 · -id:6^19 · +c:8^18]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c:8^18 · c:8^13] --> [c:8^18]
//│ [id:6^19] --> [id:6^19]
//│ [p:7^20 · p:7^10 · p:7^10] --> [p:7^20 · p:7^10]
//│ [p:7^20] --> [p:7^20]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c:8^18]
//│ 	[c:8^18 · c:8^13] ---> [c:8^18] (only one)
//│ [id:6^19]
//│ 	[id:6^19 · id:6^3] ---> [id:6^3] (hopeless to continue)
//│ [p:7^20]
//│ 	[p:7^20 · p:7^10]
//│ 		[p:7^20 · p:7^10 · p:7^10] ---> [p:7^20 · p:7^10] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([c:8^18]:17^42 ([id:6^19]:14^43 [p:7^20]:15^44))
//│ def [c:8^18]:17 = (fun y:27 -> case y:27^36 of {
//│ 	C aa:28 => ([c:8^18]:17^37 aa:28^38)})
//│ def [id:6^19]:14 = (fun x:24 -> case x:24^27 of {
//│ 	ID b:25 => b:25^28
//│ 	| C a:26 => (id:6^29 [ID [C a:26^30]])})
//│ def [p:7^20 · p:7^10]:16 = [C [p:7^20 · p:7^10]:16^25]
//│ def [p:7^20]:15 = [C [p:7^20 · p:7^10]:16^23]
//│ def c:8 = (fun y:12 -> case y:12^17 of {
//│ 	C aa:13 => (c:8^18 aa:13^19)})
//│ def id:6 = (fun x:9 -> case x:9^6 of {
//│ 	ID b:10 => b:10^7
//│ 	| C a:11 => (id:6^8 [ID [C a:11^9]])})
//│ def p:7 = [C p:7^15]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 10: [C 9: a:11^9]
//│ [C a:11^9] --->
//│ 	case y:27^36 of {C aa:28 => ([c:8^18]:17^37 aa:28^38)}
//│ 11: [ID 10: [C 9: a:11^9]]
//│ [ID [C a:11^9]] --->
//│ 	case x:9^6 of {ID b:10 => b:10^7 | C a:11 => (id:6^8 [ID [C a:11^9]])}
//│ 24: [C 23: [p:7^20 · p:7^10]:16^23]
//│ [C [p:7^20 · p:7^10]:16^23] --->
//│ 	case x:24^27 of {ID b:25 => b:25^28 | C a:26 => (id:6^29 [ID [C a:26^30]])}
//│ 26: [C 25: [p:7^20 · p:7^10]:16^25]
//│ [C [p:7^20 · p:7^10]:16^25] --->
//│ 	case y:27^36 of {C aa:28 => ([c:8^18]:17^37 aa:28^38)}
//│ 31: [C 30: a:26^30]
//│ [C a:26^30] --->
//│ 	case y:27^36 of {C aa:28 => ([c:8^18]:17^37 aa:28^38)}
//│ 32: [ID 31: [C 30: a:26^30]]
//│ [ID [C a:26^30]] --->
//│ 	case x:9^6 of {ID b:10 => b:10^7 | C a:11 => (id:6^8 [ID [C a:11^9]])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([c:8^18]:17^47 ([id:6^19]:14^48 [p:7^20]:15^49))
//│ def [c:8^18]:17 = (fun y:27 -> y:27^80)
//│ def [id:6^19]:14 = (fun x:24 -> x:24^58)
//│ def [p:7^20 · p:7^10]:16 = let aa:28 = [p:7^20 · p:7^10]:16^78
//│ in ([c:8^18]:17^75 aa:28^76)
//│ def [p:7^20]:15 = let a:26 = [p:7^20 · p:7^10]:16^73
//│ in (id:6^64 let b:10 = 
//│ 	let aa:28 = a:26^69
//│ 	in ([c:8^18]:17^66 aa:28^67)
//│ in b:10^65)
//│ def c:8 = (fun y:12 -> case y:12^52 of {
//│ 	C aa:13 => (c:8^53 aa:13^54)})
//│ def id:6 = (fun x:9 -> x:9^60)
//│ def p:7 = [C p:7^62]
//│ <<<<<<< after fusion <<<<<<<
