:NewParser
:ParseOnly


// WRONG: infinite rewrting how to produce a finite rewrtten program?
_LUMBERHACK_ERROR
let p = Pair(A, B)
fun c(x) = if x is
  Pair(a, b) then c(Pair(b, a))
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^12 p^13)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	Pair a⁰ b⁰ => (c^5 [Pair b⁰ a⁰])})
//│ def p = [Pair [A] [B]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^12] (hopeless to continue)
//│ 	[c^12 · c^5] ---> [c^12] (using original def)
//│ [p^13] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		Pair a¹ b¹ => (c₀ [Pair b¹ a¹])})
//│ def p₀ = 
//│ 	[Pair [A] [B]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Pair [A] [B]]: 25 --->
//│ 	case x¹ of {Pair a¹ b¹ => (c₀ [Pair b¹ a¹])}: 21
//│ [Pair b¹ a¹]: 19 --->
//│ 	case x¹ of {Pair a¹ b¹ => (c₀ [Pair b¹ a¹])}: 21
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Pair b¹ a¹]: 19 --->
//│ 	case x¹ of {Pair a¹ b¹ => (c₀ [Pair b¹ a¹])}: 21
//│ [Pair [A] [B]]: 25 --->
//│ 	case x¹ of {Pair a¹ b¹ => (c₀ [Pair b¹ a¹])}: 21
//│ ------------------
//│ case x¹ of {Pair a¹ b¹ => (c₀ [Pair b¹ a¹])}: 21 --->
//│ 	[Pair b¹ a¹]: 19
//│ 	[Pair [A] [B]]: 25
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!

// Just a more valid/reasonable version of the above
// WRONG: recursive strategy
_LUMBERHACK_ERROR
let p = Wrap(3)
fun c(x) = if x is
  Wrap(a) then if a > 0 then c(Wrap(a - 1)) else Wrap(0)
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Wrap|(|3|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Wrap|(|a|)| |#then| |#if| |a| |>| |0| |#then| |c|(|Wrap|(|a| |-| |1|)|)| |#else| |Wrap|(|0|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Wrap (3,); fun c = x, => if x is ‹(Wrap (a,)) then if (> (a,) (0,)) then c (Wrap (- (a,) (1,),),) else Wrap (0,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^22 p^23)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	Wrap a⁰ => if (a⁰ > 0) then (c^9 [Wrap (a⁰ - 1)]) else [Wrap 0]})
//│ def p = [Wrap 3]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^22] (hopeless to continue)
//│ 	[c^22 · c^9] ---> [c^22] (using original def)
//│ [p^23] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		Wrap a¹ => if (a¹ > 0) then (c₀ [Wrap (a¹ - 1)]) else [Wrap 0]})
//│ def p₀ = 
//│ 	[Wrap 3]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Wrap (a¹ - 1)]: 39 --->
//│ 	case x¹ of {Wrap a¹ => if (a¹ > 0) then (c₀ [Wrap (a¹ - 1)]) else [Wrap 0]}: 44
//│ [Wrap 3]: 26 --->
//│ 	case x¹ of {Wrap a¹ => if (a¹ > 0) then (c₀ [Wrap (a¹ - 1)]) else [Wrap 0]}: 44
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Wrap 3]: 26 --->
//│ 	case x¹ of {Wrap a¹ => if (a¹ > 0) then (c₀ [Wrap (a¹ - 1)]) else [Wrap 0]}: 44
//│ [Wrap (a¹ - 1)]: 39 --->
//│ 	case x¹ of {Wrap a¹ => if (a¹ > 0) then (c₀ [Wrap (a¹ - 1)]) else [Wrap 0]}: 44
//│ ------------------
//│ case x¹ of {Wrap a¹ => if (a¹ > 0) then (c₀ [Wrap (a¹ - 1)]) else [Wrap 0]}: 44 --->
//│ 	[Wrap 3]: 26
//│ 	[Wrap (a¹ - 1)]: 39
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!



// WRONG: branching and conflict, but can be solved by rewriting into
// NOTE: some program not be able to write?
_LUMBERHACK_ERROR
fun last(ls) = if ls is
  C(h, t) then if t is
    N then Some(h)
    C(hh, tt) then last(t)
  N then None
let p = C(1, C(2, N))
last(p)
//│ |_LUMBERHACK_ERROR|↵|#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |last|(|t|)|←|↵|N| |#then| |None|←|↵|#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|last|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun last = ls, => if ls is ‹(C (h, t,)) then if t is ‹(N) then Some (h,); (C (hh, tt,)) then last (t,)›; (N) then None›; let p = C (1, C (2, N,),); last (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (last^17 p^18)
//│ def last = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N => [Some h⁰]
//│ 		| C hh⁰ tt⁰ => (last^5 t⁰)}
//│ 	| N => [None]})
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^17] (hopeless to continue)
//│ 	[last^17 · last^5] ---> [last^17] (using original def)
//│ [p^18] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (last₀ p₀)
//│ def last₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => case t¹ of {
//│ 			N => [Some h¹]
//│ 			| C hh¹ tt¹ => (last₀ t¹)}
//│ 		| N => [None]})
//│ def p₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]]: 35 --->
//│ 	case ls¹ of {C h¹ t¹ => case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₀ t¹)} | N => [None]}: 29
//│ [C 2 [N]]: 34 --->
//│ 	case ls¹ of {C h¹ t¹ => case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₀ t¹)} | N => [None]}: 29
//│ 	case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₀ t¹)}: 27
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N]: 33 --->
//│ 	case ls¹ of {C h¹ t¹ => case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₀ t¹)} | N => [None]}: 29
//│ 	case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₀ t¹)}: 27
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (last₀ p₀)
//│ def last₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h¹ t¹ => case t¹ of {
//│ 			N => [Some h¹]
//│ 			| C hh¹ tt¹ => (last₀ t¹)}
//│ 		| N => [None]})
//│ def p₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!

// WRONG: one consumer cannot be expanded fully?
fun idxSum(ls) = if ls is
  N then acc => 0
  C(h, t) then acc => acc + idxSum(t)(acc + 1)
fun rev(lss) = if lss is
  N then a => a
  C(hh, tt) then a => rev(tt, C(hh, a))
idxSum(rev(C(1, C(2, N)))(N))(0)
//│ |#fun| |idxSum|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc| |=>| |0|↵|C|(|h|,| |t|)| |#then| |acc| |=>| |acc| |+| |idxSum|(|t|)|(|acc| |+| |1|)|←|↵|#fun| |rev|(|lss|)| |#=| |#if| |lss| |is|→|N| |#then| |a| |=>| |a|↵|C|(|hh|,| |tt|)| |#then| |a| |=>| |rev|(|tt|,| |C|(|hh|,| |a|)|)|←|↵|idxSum|(|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|N|)|)|(|0|)|
//│ Parsed: {fun idxSum = ls, => if ls is ‹(N) then acc, => 0; (C (h, t,)) then acc, => + (acc,) (idxSum (t,) (+ (acc,) (1,),),)›; fun rev = lss, => if lss is ‹(N) then a, => a; (C (hh, tt,)) then a, => rev (tt, C (hh, a,),)›; idxSum (rev (C (1, C (2, N,),),) (N,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((idxSum^33 ((rev^34 [C 1 [C 2 [N]]]) [N])) 0)
//│ def idxSum = (fun ls⁰ -> case ls⁰ of {
//│ 	N => (fun acc⁰ -> 0)
//│ 	| C h⁰ t⁰ => (fun acc¹ -> (acc¹ + ((idxSum^7 t⁰) (acc¹ + 1))))})
//│ def rev = (fun lss⁰ -> case lss⁰ of {
//│ 	N => (fun a⁰ -> a⁰)
//│ 	| C hh⁰ tt⁰ => (fun a¹ -> ((rev^23 tt⁰) [C hh⁰ a¹]))})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [idxSum^33] (hopeless to continue)
//│ 	[idxSum^33 · idxSum^7] ---> [idxSum^33] (using original def)
//│ [rev^34]
//│ 	[rev^34 · rev^23] (hopeless to continue)
//│ 		[rev^34 · rev^23 · rev^23] ---> [rev^34 · rev^23] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((idxSum₀ ((rev₀ [C 1 [C 2 [N]]]) [N])) 0)
//│ def idxSum₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		N => (fun acc² -> 0)
//│ 		| C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₀ t¹) (acc³ + 1))))})
//│ def rev₀ = 
//│ 	(fun lss¹ -> case lss¹ of {
//│ 		N => (fun a² -> a²)
//│ 		| C hh¹ tt¹ => (fun a³ -> ((rev₁ tt¹) [C hh¹ a³]))})
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun lss² -> case lss² of {
//│ 			N => (fun a⁴ -> a⁴)
//│ 			| C hh² tt² => (fun a⁵ -> ((rev₁ tt²) [C hh² a⁵]))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]]: 97 --->
//│ 	case lss¹ of {N => (fun a² -> a²) | C hh¹ tt¹ => (fun a³ -> ((rev₁ tt¹) [C hh¹ a³]))}: 76
//│ [C 2 [N]]: 96 --->
//│ 	case lss² of {N => (fun a⁴ -> a⁴) | C hh² tt² => (fun a⁵ -> ((rev₁ tt²) [C hh² a⁵]))}: 89
//│ [C hh² a⁵]: 86 --->
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₀ t¹) (acc³ + 1))))}: 63
//│ [C hh¹ a³]: 73 --->
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₀ t¹) (acc³ + 1))))}: 63
//│ [N]: 99 --->
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₀ t¹) (acc³ + 1))))}: 63
//│ [N]: 95 --->
//│ 	case lss² of {N => (fun a⁴ -> a⁴) | C hh² tt² => (fun a⁵ -> ((rev₁ tt²) [C hh² a⁵]))}: 89
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C hh¹ a³]: 73 --->
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₀ t¹) (acc³ + 1))))}: 63
//│ [C hh² a⁵]: 86 --->
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₀ t¹) (acc³ + 1))))}: 63
//│ [N]: 95 --->
//│ 	case lss² of {N => (fun a⁴ -> a⁴) | C hh² tt² => (fun a⁵ -> ((rev₁ tt²) [C hh² a⁵]))}: 89
//│ [C 2 [N]]: 96 --->
//│ 	case lss² of {N => (fun a⁴ -> a⁴) | C hh² tt² => (fun a⁵ -> ((rev₁ tt²) [C hh² a⁵]))}: 89
//│ [C 1 [C 2 [N]]]: 97 --->
//│ 	case lss¹ of {N => (fun a² -> a²) | C hh¹ tt¹ => (fun a³ -> ((rev₁ tt¹) [C hh¹ a³]))}: 76
//│ [N]: 99 --->
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₀ t¹) (acc³ + 1))))}: 63
//│ ------------------
//│ case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₀ t¹) (acc³ + 1))))}: 63 --->
//│ 	[C hh¹ a³]: 73
//│ 	[C hh² a⁵]: 86
//│ 	[N]: 99
//│ case lss¹ of {N => (fun a² -> a²) | C hh¹ tt¹ => (fun a³ -> ((rev₁ tt¹) [C hh¹ a³]))}: 76 --->
//│ 	[C 1 [C 2 [N]]]: 97
//│ case lss² of {N => (fun a⁴ -> a⁴) | C hh² tt² => (fun a⁵ -> ((rev₁ tt²) [C hh² a⁵]))}: 89 --->
//│ 	[N]: 95
//│ 	[C 2 [N]]: 96
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((idxSum₀ ((rev₀ 
//│ 	let hh³ = 1
//│ 	in let tt³ = 	
//│ 		let hh⁴ = 2
//│ 		in let tt⁴ = (fun a⁸ -> a⁸)
//│ 		in (fun a⁷ -> ((rev₁ tt⁴) 
//│ 			let h³ = hh⁴
//│ 			in let t³ = a⁷
//│ 			in (fun acc⁵ -> (acc⁵ + ((idxSum₀ t³) (acc⁵ + 1))))))
//│ 	in (fun a⁶ -> ((rev₁ tt³) 
//│ 		let h² = hh³
//│ 		in let t² = a⁶
//│ 		in (fun acc⁴ -> (acc⁴ + ((idxSum₀ t²) (acc⁴ + 1))))))) (fun acc⁶ -> 0))) 0)
//│ def idxSum₀ = 
//│ 	(fun ls² -> ls²)
//│ def rev₀ = 
//│ 	(fun lss³ -> lss³)
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun lss⁴ -> lss⁴)
//│ <<<<<<< after fusion <<<<<<<


// WRONG: still has variable extrusion
_LUMBERHACK_ERROR
fun minuss(a) = if a is
  S(aa) then b => if b is
    S(bb) then minuss(aa, bb)
    Z then aa
  Z then n => Z
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |_LUMBERHACK_ERROR|↵|#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |#if| |b| |is|→|S|(|bb|)| |#then| |minuss|(|aa|,| |bb|)|↵|Z| |#then| |aa|←|↵|Z| |#then| |n| |=>| |Z|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun minuss = a, => if a is ‹(S (aa,)) then b, => if b is ‹(S (bb,)) then minuss (aa, bb,); (Z) then aa›; (Z) then n, => Z›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((minuss^19 fst^20) snd^22)
//│ def fst = [S [S [Z]]]
//│ def minuss = (fun a⁰ -> case a⁰ of {
//│ 	S aa⁰ => (fun b⁰ -> case b⁰ of {
//│ 		S bb⁰ => ((minuss^3 aa⁰) bb⁰)
//│ 		| Z => aa⁰})
//│ 	| Z => (fun n⁰ -> [Z])})
//│ def snd = [Z]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fst^20] (hopeless to continue)
//│ [minuss^19] (hopeless to continue)
//│ 	[minuss^19 · minuss^3] ---> [minuss^19] (using original def)
//│ [snd^22] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((minuss₀ fst₀) snd₀)
//│ def fst₀ = 
//│ 	[S [S [Z]]]
//│ def minuss₀ = 
//│ 	(fun a¹ -> case a¹ of {
//│ 		S aa¹ => (fun b¹ -> case b¹ of {
//│ 			S bb¹ => ((minuss₀ aa¹) bb¹)
//│ 			| Z => aa¹})
//│ 		| Z => (fun n¹ -> [Z])})
//│ def snd₀ = 
//│ 	[Z]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S [S [Z]]]: 27 --->
//│ 	case a¹ of {S aa¹ => (fun b¹ -> case b¹ of {S bb¹ => ((minuss₀ aa¹) bb¹) | Z => aa¹}) | Z => (fun n¹ -> [Z])}: 40
//│ [S [Z]]: 26 --->
//│ 	case a¹ of {S aa¹ => (fun b¹ -> case b¹ of {S bb¹ => ((minuss₀ aa¹) bb¹) | Z => aa¹}) | Z => (fun n¹ -> [Z])}: 40
//│ [Z]: 24 --->
//│ 	case b¹ of {S bb¹ => ((minuss₀ aa¹) bb¹) | Z => aa¹}: 36
//│ [Z]: 25 --->
//│ 	case a¹ of {S aa¹ => (fun b¹ -> case b¹ of {S bb¹ => ((minuss₀ aa¹) bb¹) | Z => aa¹}) | Z => (fun n¹ -> [Z])}: 40
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((minuss₀ fst₀) snd₀)
//│ def fst₀ = 
//│ 	[S [S [Z]]]
//│ def minuss₀ = 
//│ 	(fun a² -> case a² of {
//│ 		S aa¹ => (fun b² -> case b² of {
//│ 			S bb¹ => ((minuss₀ aa¹) bb¹)
//│ 			| Z => aa¹})
//│ 		| Z => (fun n² -> [Z])})
//│ def snd₀ = 
//│ 	[Z]
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!


// WRONG:
fun minuss(a) = if a is
  S(aa) then b => checkb(b)(aa)
  Z then n => Z
fun checkb(b) = if b is
  S(bb) then aaa => minuss(aaa, bb)
  Z then aaa => aaa
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |checkb|(|b|)|(|aa|)|↵|Z| |#then| |n| |=>| |Z|←|↵|#fun| |checkb|(|b|)| |#=| |#if| |b| |is|→|S|(|bb|)| |#then| |aaa| |=>| |minuss|(|aaa|,| |bb|)|↵|Z| |#then| |aaa| |=>| |aaa|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {fun minuss = a, => if a is ‹(S (aa,)) then b, => checkb (b,) (aa,); (Z) then n, => Z›; fun checkb = b, => if b is ‹(S (bb,)) then aaa, => minuss (aaa, bb,); (Z) then aaa, => aaa›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((minuss^27 fst^28) snd^30)
//│ def checkb = (fun b¹ -> case b¹ of {
//│ 	S bb⁰ => (fun aaa⁰ -> ((minuss^13 aaa⁰) bb⁰))
//│ 	| Z => (fun aaa¹ -> aaa¹)})
//│ def fst = [S [S [Z]]]
//│ def minuss = (fun a⁰ -> case a⁰ of {
//│ 	S aa⁰ => (fun b⁰ -> ((checkb^2 b⁰) aa⁰))
//│ 	| Z => (fun n⁰ -> [Z])})
//│ def snd = [Z]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fst^28] (hopeless to continue)
//│ [minuss^27] (hopeless to continue)
//│ 	[minuss^27 · checkb^2] (using original def)
//│ 		[minuss^27 · checkb^2 · minuss^13] ---> [minuss^27] (using original def)
//│ [snd^30] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((minuss₀ fst₀) snd₀)
//│ def fst₀ = 
//│ 	[S [S [Z]]]
//│ def minuss₀ = 
//│ 	(fun a¹ -> case a¹ of {
//│ 		S aa¹ => (fun b² -> ((checkb₀ b²) aa¹))
//│ 		| Z => (fun n¹ -> [Z])})
//│ 	where
//│ 	def checkb₀ = 
//│ 		(fun b³ -> case b³ of {
//│ 			S bb¹ => (fun aaa² -> ((minuss₀ aaa²) bb¹))
//│ 			| Z => (fun aaa³ -> aaa³)})
//│ def snd₀ = 
//│ 	[Z]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S [S [Z]]]: 57 --->
//│ 	case a¹ of {S aa¹ => (fun b² -> ((checkb₀ b²) aa¹)) | Z => (fun n¹ -> [Z])}: 41
//│ [S [Z]]: 56 --->
//│ 	case a¹ of {S aa¹ => (fun b² -> ((checkb₀ b²) aa¹)) | Z => (fun n¹ -> [Z])}: 41
//│ [Z]: 55 --->
//│ 	case a¹ of {S aa¹ => (fun b² -> ((checkb₀ b²) aa¹)) | Z => (fun n¹ -> [Z])}: 41
//│ [Z]: 43 --->
//│ 	case b³ of {S bb¹ => (fun aaa² -> ((minuss₀ aaa²) bb¹)) | Z => (fun aaa³ -> aaa³)}: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((minuss₀ fst₀) snd₀)
//│ def fst₀ = 
//│ 	[S [S [Z]]]
//│ def minuss₀ = 
//│ 	(fun a² -> case a² of {
//│ 		S aa¹ => (fun b⁴ -> ((checkb₀ b⁴) aa¹))
//│ 		| Z => (fun n² -> [Z])})
//│ 	where
//│ 	def checkb₀ = 
//│ 		(fun b⁵ -> case b⁵ of {
//│ 			S bb¹ => (fun aaa⁴ -> ((minuss₀ aaa⁴) bb¹))
//│ 			| Z => (fun aaa⁵ -> aaa⁵)})
//│ def snd₀ = 
//│ 	[Z]
//│ <<<<<<< after fusion <<<<<<<

// WRONG:
_LUMBERHACK_ERROR
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let rec l1 = C(1, C(2, l1))
let rec l2 = C(9, C(8, l2))
inter(l1)(l2)
//│ |_LUMBERHACK_ERROR|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |#rec| |l1| |#=| |C|(|1|,| |C|(|2|,| |l1|)|)|↵|#let| |#rec| |l2| |#=| |C|(|9|,| |C|(|8|,| |l2|)|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let rec l1 = C (1, C (2, l1,),); let rec l2 = C (9, C (8, l2,),); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter^24 l1^25) l2^27)
//│ def inter = (fun xs⁰ -> case xs⁰ of {
//│ 	N => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ ((inter^5 ys¹) t⁰)])})
//│ def l1 = [C 1 [C 2 l1^16]]
//│ def l2 = [C 9 [C 8 l2^21]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^24]
//│ 	[inter^24 · inter^5]
//│ 		[inter^24 · inter^5 · inter^5]
//│ 			[inter^24 · inter^5 · inter^5 · inter^5]
//│ 				[inter^24 · inter^5 · inter^5 · inter^5 · inter^5]
//│ 					[inter^24 · inter^5 · inter^5 · inter^5 · inter^5 · inter^5] ---> [inter^24 · inter^5] (only one)
//│ [l1^25]
//│ 	[l1^25 · l1^16] ---> [l1^25] (only one)
//│ [l2^27]
//│ 	[l2^27 · l2^21] ---> [l2^27] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((inter₀ l1₀) l2₀)
//│ def inter₀ = 
//│ 	(fun xs⁵ -> case xs⁵ of {
//│ 		N => (fun ys¹⁰ -> ys¹⁰)
//│ 		| C h⁵ t⁵ => (fun ys¹¹ -> [C h⁵ ((inter₁ ys¹¹) t⁵)])})
//│ 	where
//│ 	def inter₁ = 
//│ 		(fun xs² -> case xs² of {
//│ 			N => (fun ys⁴ -> ys⁴)
//│ 			| C h² t² => (fun ys⁵ -> [C h² ((inter₂ ys⁵) t²)])})
//│ 		where
//│ 		def inter₂ = 
//│ 			(fun xs³ -> case xs³ of {
//│ 				N => (fun ys⁶ -> ys⁶)
//│ 				| C h³ t³ => (fun ys⁷ -> [C h³ ((inter₃ ys⁷) t³)])})
//│ 			where
//│ 			def inter₃ = 
//│ 				(fun xs¹ -> case xs¹ of {
//│ 					N => (fun ys² -> ys²)
//│ 					| C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₄ ys³) t¹)])})
//│ 				where
//│ 				def inter₄ = 
//│ 					(fun xs⁴ -> case xs⁴ of {
//│ 						N => (fun ys⁸ -> ys⁸)
//│ 						| C h⁴ t⁴ => (fun ys⁹ -> [C h⁴ ((inter₁ ys⁹) t⁴)])})
//│ def l1₀ = 
//│ 	[C 1 [C 2 l1₀]]
//│ def l2₀ = 
//│ 	[C 9 [C 8 l2₀]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 l1₀]]: 90 --->
//│ 	case xs⁵ of {N => (fun ys¹⁰ -> ys¹⁰) | C h⁵ t⁵ => (fun ys¹¹ -> [C h⁵ ((inter₁ ys¹¹) t⁵)])}: 102
//│ 	case xs⁴ of {N => (fun ys⁸ -> ys⁸) | C h⁴ t⁴ => (fun ys⁹ -> [C h⁴ ((inter₁ ys⁹) t⁴)])}: 79
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C 2 l1₀]: 89 --->
//│ 	case xs³ of {N => (fun ys⁶ -> ys⁶) | C h³ t³ => (fun ys⁷ -> [C h³ ((inter₃ ys⁷) t³)])}: 66
//│ [C 8 l2₀]: 84 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₄ ys³) t¹)])}: 40
//│ [C 9 [C 8 l2₀]]: 85 --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h² t² => (fun ys⁵ -> [C h² ((inter₂ ys⁵) t²)])}: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((inter₀ l1₀) l2₀)
//│ def inter₀ = 
//│ 	(fun xs⁷ -> case xs⁷ of {
//│ 		N => (fun ys¹⁴ -> ys¹⁴)
//│ 		| C h⁵ t⁵ => (fun ys¹⁵ -> [C h⁵ ((inter₁ ys¹⁵) t⁵)])})
//│ 	where
//│ 	def inter₁ = 
//│ 		(fun xs⁹ -> case xs⁹ of {
//│ 			N => (fun ys¹⁸ -> ys¹⁸)
//│ 			| C h² t² => (fun ys¹⁹ -> [C h² ((inter₂ ys¹⁹) t²)])})
//│ 		where
//│ 		def inter₂ = 
//│ 			(fun xs⁸ -> case xs⁸ of {
//│ 				N => (fun ys¹⁶ -> ys¹⁶)
//│ 				| C h³ t³ => (fun ys¹⁷ -> [C h³ ((inter₃ ys¹⁷) t³)])})
//│ 			where
//│ 			def inter₃ = 
//│ 				(fun xs¹⁰ -> case xs¹⁰ of {
//│ 					N => (fun ys²⁰ -> ys²⁰)
//│ 					| C h¹ t¹ => (fun ys²¹ -> [C h¹ ((inter₄ ys²¹) t¹)])})
//│ 				where
//│ 				def inter₄ = 
//│ 					(fun xs⁶ -> case xs⁶ of {
//│ 						N => (fun ys¹² -> ys¹²)
//│ 						| C h⁴ t⁴ => (fun ys¹³ -> [C h⁴ ((inter₁ ys¹³) t⁴)])})
//│ def l1₀ = 
//│ 	[C 1 [C 2 l1₀]]
//│ def l2₀ = 
//│ 	[C 9 [C 8 l2₀]]
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!


// WRONG: push in cannot work still have binding error
// and wrong recursive knots
_LUMBERHACK_ERROR
fun f(xs) = if xs is
  X(x1) then if x1 is
    X(x2) then if x2 is
      X(x3) then ys => if ys is
        Y(y1) then if y1 is
          Y(y2) then f(x3, y2)
let rec xx = X(X(xx))
let rec yy = Y(Y(Y(yy)))
f(xx, yy)
//│ |_LUMBERHACK_ERROR|↵|#fun| |f|(|xs|)| |#=| |#if| |xs| |is|→|X|(|x1|)| |#then| |#if| |x1| |is|→|X|(|x2|)| |#then| |#if| |x2| |is|→|X|(|x3|)| |#then| |ys| |=>| |#if| |ys| |is|→|Y|(|y1|)| |#then| |#if| |y1| |is|→|Y|(|y2|)| |#then| |f|(|x3|,| |y2|)|←|←|←|←|←|↵|#let| |#rec| |xx| |#=| |X|(|X|(|xx|)|)|↵|#let| |#rec| |yy| |#=| |Y|(|Y|(|Y|(|yy|)|)|)|↵|f|(|xx|,| |yy|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun f = xs, => if xs is ‹(X (x1,)) then if x1 is ‹(X (x2,)) then if x2 is ‹(X (x3,)) then ys, => if ys is ‹(Y (y1,)) then if y1 is ‹(Y (y2,)) then f (x3, y2,)›››››; let rec xx = X (X (xx,),); let rec yy = Y (Y (Y (yy,),),); f (xx, yy,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((f^25 xx^26) yy^28)
//│ def f = (fun xs⁰ -> case xs⁰ of {
//│ 	X x1⁰ => case x1⁰ of {
//│ 		X x2⁰ => case x2⁰ of {
//│ 			X x3⁰ => (fun ys⁰ -> case ys⁰ of {
//│ 				Y y1⁰ => case y1⁰ of {
//│ 					Y y2⁰ => ((f^6 x3⁰) y2⁰)}})}}})
//│ def xx = [X [X xx^18]]
//│ def yy = [Y [Y [Y yy^21]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^25]
//│ 	[f^25 · f^6]
//│ 		[f^25 · f^6 · f^6]
//│ 			[f^25 · f^6 · f^6 · f^6] ---> [f^25 · f^6] (only one)
//│ [xx^26]
//│ 	[xx^26 · xx^18]
//│ 		[xx^26 · xx^18 · xx^18]
//│ 			[xx^26 · xx^18 · xx^18 · xx^18]
//│ 				[xx^26 · xx^18 · xx^18 · xx^18 · xx^18] ---> [xx^26 · xx^18] (only one)
//│ [yy^28]
//│ 	[yy^28 · yy^21]
//│ 		[yy^28 · yy^21 · yy^21] ---> [yy^28] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((f₀ xx₀) yy₀)
//│ def f₀ = 
//│ 	(fun xs³ -> case xs³ of {
//│ 		X x1³ => case x1³ of {
//│ 			X x2³ => case x2³ of {
//│ 				X x3³ => (fun ys³ -> case ys³ of {
//│ 					Y y1³ => case y1³ of {
//│ 						Y y2³ => ((f₁ x3³) y2³)}})}}})
//│ 	where
//│ 	def f₁ = 
//│ 		(fun xs² -> case xs² of {
//│ 			X x1² => case x1² of {
//│ 				X x2² => case x2² of {
//│ 					X x3² => (fun ys² -> case ys² of {
//│ 						Y y1² => case y1² of {
//│ 							Y y2² => ((f₂ x3²) y2²)}})}}})
//│ 		where
//│ 		def f₂ = 
//│ 			(fun xs¹ -> case xs¹ of {
//│ 				X x1¹ => case x1¹ of {
//│ 					X x2¹ => case x2¹ of {
//│ 						X x3¹ => (fun ys¹ -> case ys¹ of {
//│ 							Y y1¹ => case y1¹ of {
//│ 								Y y2¹ => ((f₁ x3¹) y2¹)}})}}})
//│ def xx₀ = 
//│ 	[X [X xx₁]]
//│ 	where
//│ 	def xx₁ = 
//│ 		[X [X xx₂]]
//│ 		where
//│ 		def xx₂ = 
//│ 			[X [X xx₃]]
//│ 			where
//│ 			def xx₃ = 
//│ 				[X [X xx₁]]
//│ def yy₀ = 
//│ 	[Y [Y [Y yy₁]]]
//│ 	where
//│ 	def yy₁ = 
//│ 		[Y [Y [Y yy₀]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [X [X xx₁]]: 55 --->
//│ 	case xs¹ of {X x1¹ => case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}})}}}: 51
//│ [X [X xx₁]]: 62 --->
//│ 	case xs³ of {X x1³ => case x1³ of {X x2³ => case x2³ of {X x3³ => (fun ys³ -> case ys³ of {Y y1³ => case y1³ of {Y y2³ => ((f₁ x3³) y2³)}})}}}: 95
//│ [X [X xx₂]]: 35 --->
//│ 	case x2³ of {X x3³ => (fun ys³ -> case ys³ of {Y y1³ => case y1³ of {Y y2³ => ((f₁ x3³) y2³)}})}: 93
//│ 	case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}})}: 49
//│ 	 MORE THAN ONE MATCH EXPR
//│ [X [X xx₃]]: 32 --->
//│ 	case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}})}}: 77
//│ [X xx₁]: 54 --->
//│ 	case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}})}}: 50
//│ [X xx₁]: 61 --->
//│ 	case x1³ of {X x2³ => case x2³ of {X x3³ => (fun ys³ -> case ys³ of {Y y1³ => case y1³ of {Y y2³ => ((f₁ x3³) y2³)}})}}: 94
//│ [X xx₂]: 34 --->
//│ 	case xs² of {X x1² => case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}})}}}: 78
//│ [X xx₃]: 31 --->
//│ 	case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}})}: 76
//│ [Y [Y [Y yy₀]]]: 100 --->
//│ 	case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}: 46
//│ 	case y1² of {Y y2² => ((f₂ x3²) y2²)}: 73
//│ 	 MORE THAN ONE MATCH EXPR
//│ [Y [Y [Y yy₁]]]: 59 --->
//│ 	case ys³ of {Y y1³ => case y1³ of {Y y2³ => ((f₁ x3³) y2³)}}: 91
//│ 	case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}}: 47
//│ 	case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}}: 74
//│ 	 MORE THAN ONE MATCH EXPR
//│ [Y [Y yy₀]]: 99 --->
//│ 	case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}}: 47
//│ 	case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}}: 74
//│ 	 MORE THAN ONE MATCH EXPR
//│ [Y [Y yy₁]]: 58 --->
//│ 	case y1³ of {Y y2³ => ((f₁ x3³) y2³)}: 90
//│ 	case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}: 46
//│ 	case y1² of {Y y2² => ((f₂ x3²) y2²)}: 73
//│ 	 MORE THAN ONE MATCH EXPR
//│ [Y yy₀]: 98 --->
//│ 	case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}: 46
//│ 	case y1² of {Y y2² => ((f₂ x3²) y2²)}: 73
//│ 	 MORE THAN ONE MATCH EXPR
//│ [Y yy₁]: 57 --->
//│ 	case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}}: 47
//│ 	case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}}: 74
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [X xx₃]: 31 --->
//│ 	case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}})}: 76
//│ [X [X xx₃]]: 32 --->
//│ 	case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}})}}: 77
//│ [X xx₂]: 34 --->
//│ 	case xs² of {X x1² => case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}})}}}: 78
//│ [X xx₁]: 54 --->
//│ 	case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}})}}: 50
//│ [X [X xx₁]]: 55 --->
//│ 	case xs¹ of {X x1¹ => case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}})}}}: 51
//│ [X xx₁]: 61 --->
//│ 	case x1³ of {X x2³ => case x2³ of {X x3³ => (fun ys³ -> case ys³ of {Y y1³ => case y1³ of {Y y2³ => ((f₁ x3³) y2³)}})}}: 94
//│ [X [X xx₁]]: 62 --->
//│ 	case xs³ of {X x1³ => case x1³ of {X x2³ => case x2³ of {X x3³ => (fun ys³ -> case ys³ of {Y y1³ => case y1³ of {Y y2³ => ((f₁ x3³) y2³)}})}}}: 95
//│ ------------------
//│ case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}})}}: 50 --->
//│ 	[X xx₁]: 54
//│ case xs¹ of {X x1¹ => case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}})}}}: 51 --->
//│ 	[X [X xx₁]]: 55
//│ case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}})}: 76 --->
//│ 	[X xx₃]: 31
//│ case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}})}}: 77 --->
//│ 	[X [X xx₃]]: 32
//│ case xs² of {X x1² => case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}})}}}: 78 --->
//│ 	[X xx₂]: 34
//│ case x1³ of {X x2³ => case x2³ of {X x3³ => (fun ys³ -> case ys³ of {Y y1³ => case y1³ of {Y y2³ => ((f₁ x3³) y2³)}})}}: 94 --->
//│ 	[X xx₁]: 61
//│ case xs³ of {X x1³ => case x1³ of {X x2³ => case x2³ of {X x3³ => (fun ys³ -> case ys³ of {Y y1³ => case y1³ of {Y y2³ => ((f₁ x3³) y2³)}})}}}: 95 --->
//│ 	[X [X xx₁]]: 62
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((f₀ xx₀) yy₀)
//│ def f₀ = 
//│ 	(fun xs⁶ -> xs⁶)
//│ 	where
//│ 	def f₁ = 
//│ 		(fun xs⁵ -> xs⁵)
//│ 		where
//│ 		def f₂ = 
//│ 			(fun xs⁴ -> xs⁴)
//│ def xx₀ = 
//│ 	let x1⁶ = 	
//│ 		let x2⁶ = xx₁
//│ 		in case x2⁶ of {
//│ 			X x3³ => (fun ys⁶ -> case ys⁶ of {
//│ 				Y y1³ => case y1³ of {
//│ 					Y y2³ => ((f₁ x3³) y2³)}})}
//│ 	in x1⁶
//│ 	where
//│ 	def xx₁ = 
//│ 		[X 
//│ 			let x1⁴ = xx₂
//│ 			in x1⁴]
//│ 		where
//│ 		def xx₂ = 
//│ 			let x2⁴ = 	
//│ 				let x3⁴ = xx₃
//│ 				in (fun ys⁴ -> case ys⁴ of {
//│ 					Y y1² => case y1² of {
//│ 						Y y2² => ((f₂ x3⁴) y2²)}})
//│ 			in x2⁴
//│ 			where
//│ 			def xx₃ = 
//│ 				let x1⁵ = 	
//│ 					let x2⁵ = xx₁
//│ 					in case x2⁵ of {
//│ 						X x3¹ => (fun ys⁵ -> case ys⁵ of {
//│ 							Y y1¹ => case y1¹ of {
//│ 								Y y2¹ => ((f₁ x3¹) y2¹)}})}
//│ 				in x1⁵
//│ def yy₀ = 
//│ 	[Y [Y [Y yy₁]]]
//│ 	where
//│ 	def yy₁ = 
//│ 		[Y [Y [Y yy₀]]]
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!



// WRONG: still have binding error
_LUMBERHACK_ERROR
fun f(x) = if x is
  C(k) then f(x)
f(C(primitive))
//│ |_LUMBERHACK_ERROR|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|k|)| |#then| |f|(|x|)|←|↵|f|(|C|(|primitive|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun f = x, => if x is ‹(C (k,)) then f (x,)›; f (C (primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^7 [C primitive⁰])
//│ def f = (fun x⁰ -> case x⁰ of {
//│ 	C k⁰ => (f^2 x⁰)})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^7] (hopeless to continue)
//│ 	[f^7 · f^2] ---> [f^7] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ [C primitive⁰])
//│ def f₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C k¹ => (f₀ x¹)})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰]: 19 --->
//│ 	case x¹ of {C k¹ => (f₀ x¹)}: 15
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C primitive⁰]: 19 --->
//│ 	case x¹ of {C k¹ => (f₀ x¹)}: 15
//│ ------------------
//│ case x¹ of {C k¹ => (f₀ x¹)}: 15 --->
//│ 	[C primitive⁰]: 19
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ 
//│ 	let k² = primitive⁰
//│ 	in (f₀ x¹))
//│ def f₀ = 
//│ 	(fun x² -> x²)
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: binding not found: Ident(false,x,1)
//│ !!!!!!ERROR!!!!!!


// WRONG: recursive strategy
_LUMBERHACK_ERROR
fun f(x) = if x is
  C(k) then f(C(x))
f(C(primitive))
//│ |_LUMBERHACK_ERROR|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|k|)| |#then| |f|(|C|(|x|)|)|←|↵|f|(|C|(|primitive|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun f = x, => if x is ‹(C (k,)) then f (C (x,),)›; f (C (primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^8 [C primitive⁰])
//│ def f = (fun x⁰ -> case x⁰ of {
//│ 	C k⁰ => (f^2 [C x⁰])})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^8] (hopeless to continue)
//│ 	[f^8 · f^2] ---> [f^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ [C primitive⁰])
//│ def f₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C k¹ => (f₀ [C x¹])})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰]: 21 --->
//│ 	case x¹ of {C k¹ => (f₀ [C x¹])}: 17
//│ [C x¹]: 15 --->
//│ 	case x¹ of {C k¹ => (f₀ [C x¹])}: 17
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ [C primitive⁰])
//│ def f₀ = 
//│ 	(fun x² -> case x² of {
//│ 		C k¹ => (f₀ [C x²])})
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!


// // CORRECT: after the detection and elimination of multiple matches
// NOTE: no recursive strategy stackoverflow problem
// because the infinite rewriting cannot be started by `primitive`
fun f(x) = if x is
  N then f(N)
  _ then 0
f(primitive)
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |f|(|N|)|↵|_| |#then| |0|←|↵|f|(|primitive|)|
//│ Parsed: {fun f = x, => if x is ‹(N) then f (N,); (_) then 0›; f (primitive,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^8 primitive⁰)
//│ def f = (fun x⁰ -> case x⁰ of {
//│ 	N => (f^2 [N])
//│ 	| _ => 0})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^8] (hopeless to continue)
//│ 	[f^8 · f^2] ---> [f^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ primitive⁰)
//│ def f₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		N => (f₀ [N])
//│ 		| _ => 0})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 13 --->
//│ 	case x¹ of {N => (f₀ [N]) | _ => 0}: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ primitive⁰)
//│ def f₀ = 
//│ 	(fun x² -> case x² of {
//│ 		N => (f₀ [N])
//│ 		| _ => 0})
//│ <<<<<<< after fusion <<<<<<<

// WRONG: mutual recursive strategy
_LUMBERHACK_ERROR
fun f(x) = if x is
    C(a) then f(C(a))
fun g(y) = if y is
    D(b) then f(C(b))
f(C(A))
//│ |_LUMBERHACK_ERROR|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |f|(|C|(|a|)|)|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|D|(|b|)| |#then| |f|(|C|(|b|)|)|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun f = x, => if x is ‹(C (a,)) then f (C (a,),)›; fun g = y, => if y is ‹(D (b,)) then f (C (b,),)›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^15 [C [A]])
//│ def f = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => (f^2 [C a⁰])})
//│ def g = (fun y⁰ -> case y⁰ of {
//│ 	D b⁰ => (f^9 [C b⁰])})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^15] (hopeless to continue)
//│ 	[f^15 · f^2] ---> [f^15] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ [C [A]])
//│ def f₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C a¹ => (f₀ [C a¹])})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 28 --->
//│ 	case x¹ of {C a¹ => (f₀ [C a¹])}: 24
//│ [C a¹]: 22 --->
//│ 	case x¹ of {C a¹ => (f₀ [C a¹])}: 24
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C a¹]: 22 --->
//│ 	case x¹ of {C a¹ => (f₀ [C a¹])}: 24
//│ [C [A]]: 28 --->
//│ 	case x¹ of {C a¹ => (f₀ [C a¹])}: 24
//│ ------------------
//│ case x¹ of {C a¹ => (f₀ [C a¹])}: 24 --->
//│ 	[C a¹]: 22
//│ 	[C [A]]: 28
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!
