:NewParser
:ParseOnly


// NOTE: the `p` inside `C(p)` is untouched
// TODO don't rewrite dead code
let p = C(p)
fun c(x) = if C(x) is
    C(a) then a
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |a|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then a›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^8 p^9)
//│ def c = (fun x⁰ -> case [C x⁰] of {
//│ 	C a⁰ => a⁰})
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^8] (hopeless to continue)
//│ [p^9] (hopeless to continue)
//│ 	[p^9 · p^1] ---> [p^9] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case [C x¹] of {
//│ 		C a¹ => a¹})
//│ def p₀ = 
//│ 	[C p₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x¹] --->
//│ 	case [C x¹] of {C a¹ => a¹}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> 
//│ 		let a¹ = x¹
//│ 		in a¹)
//│ def p₀ = 
//│ 	[C p₀]
//│ <<<<<<< after fusion <<<<<<<


// NOTE: how to produce a finite rewrtten program?
_LUMBERHACK_ERROR
let p = Pair(A, B)
fun c(x) = if x is
    Pair(a, b) then c(Pair(b, a))
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^12 p^13)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	Pair a⁰ b⁰ => (c^5 [Pair b⁰ a⁰])})
//│ def p = [Pair [A] [B]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^12] (hopeless to continue)
//│ 	[c^12 · c^5] ---> [c^12] (using original def)
//│ [p^13] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		Pair a¹ b¹ => (c₀ [Pair b¹ a¹])})
//│ def p₀ = 
//│ 	[Pair [A] [B]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Pair [A] [B]] --->
//│ 	case x¹ of {Pair a¹ b¹ => (c₀ [Pair b¹ a¹])}
//│ [Pair b¹ a¹] --->
//│ 	case x¹ of {Pair a¹ b¹ => (c₀ [Pair b¹ a¹])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!

// Just a more valid/reasonable version of the above
// TODO get a recursive knot even when using `primitive` (we get it without)
_LUMBERHACK_ERROR
let p = Wrap(3)
fun c(x) = if x is
    N then 0
    Wrap(a) then c(Wrap(primitive(a)))
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Wrap|(|3|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |0|↵|Wrap|(|a|)| |#then| |c|(|Wrap|(|primitive|(|a|)|)|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Wrap (3,); fun c = x, => if x is ‹(N) then 0; (Wrap (a,)) then c (Wrap (primitive (a,),),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^13 p^14)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	N => 0
//│ 	| Wrap a⁰ => (c^5 [Wrap (primitive⁰ a⁰)])})
//│ def p = [Wrap 3]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^13] (hopeless to continue)
//│ 	[c^13 · c^5] ---> [c^13] (using original def)
//│ [p^14] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		N => 0
//│ 		| Wrap a¹ => (c₀ [Wrap (primitive⁰ a¹)])})
//│ def p₀ = 
//│ 	[Wrap 3]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Wrap (primitive⁰ a¹)] --->
//│ 	case x¹ of {N => 0 | Wrap a¹ => (c₀ [Wrap (primitive⁰ a¹)])}
//│ [Wrap 3] --->
//│ 	case x¹ of {N => 0 | Wrap a¹ => (c₀ [Wrap (primitive⁰ a¹)])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!

fun c(x) = if primitive(x) is
    True then 0
    False then c(primitive(x))
c(0)
//│ |#fun| |c|(|x|)| |#=| |#if| |primitive|(|x|)| |is|→|True| |#then| |0|↵|False| |#then| |c|(|primitive|(|x|)|)|←|↵|c|(|0|)|
//│ Parsed: {fun c = x, => if primitive (x,) is ‹(True) then 0; (False) then c (primitive (x,),)›; c (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^12 0)
//│ def c = (fun x⁰ -> case (primitive⁰ x⁰) of {
//│ 	True => 0
//│ 	| False => (c^5 (primitive⁰ x⁰))})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^12] (hopeless to continue)
//│ 	[c^12 · c^5] ---> [c^12] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ 0)
//│ def c₀ = 
//│ 	(fun x¹ -> case (primitive⁰ x¹) of {
//│ 		True => 0
//│ 		| False => (c₀ (primitive⁰ x¹))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ 0)
//│ def c₀ = 
//│ 	(fun x¹ -> case (primitive⁰ x¹) of {
//│ 		True => 0
//│ 		| False => (c₀ (primitive⁰ x¹))})
//│ <<<<<<< after fusion <<<<<<<


// NOTE: only the first two element is handled
_LUMBERHACK_ERROR
fun map(f, ls) = if ls is
    C(h, t) then C(f(h), map(f, t))
    N then N
fun ff(x) = if x is
    K then T
    KK then TT
    KKKK then TTTT
let l = C(K, C(KK, C(KKKK, N)))
map(ff, l)
//│ |_LUMBERHACK_ERROR|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|ff|,| |l|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; let l = C (K, C (KK, C (KKKK, N,),),); map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((map^28 ff^29) l^31)
//│ def ff = (fun x⁰ -> case x⁰ of {
//│ 	K => [T]
//│ 	| KK => [TT]
//│ 	| KKKK => [TTTT]})
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun f⁰ -> (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C (f⁰ h⁰) ((map^5 f⁰) t⁰)]
//│ 	| N => [N]}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^29] (hopeless to continue)
//│ [l^31]
//│ [map^28]
//│ 	[map^28 · map^5]
//│ 		[map^28 · map^5 · map^5]
//│ 			[map^28 · map^5 · map^5 · map^5]
//│ 				[map^28 · map^5 · map^5 · map^5 · map^5] ---> [map^28 · map^5 · map^5 · map^5] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((map₀ ff₀) l₀)
//│ def ff₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]})
//│ def l₀ = 
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map₀ = 
//│ 	(fun f⁴ -> (fun ls⁴ -> case ls⁴ of {
//│ 		C h⁴ t⁴ => [C (f⁴ h⁴) ((map₁ f⁴) t⁴)]
//│ 		| N => [N]}))
//│ 	where
//│ 	def map₁ = 
//│ 		(fun f³ -> (fun ls³ -> case ls³ of {
//│ 			C h³ t³ => [C (f³ h³) ((map₂ f³) t³)]
//│ 			| N => [N]}))
//│ 		where
//│ 		def map₂ = 
//│ 			(fun f¹ -> (fun ls¹ -> case ls¹ of {
//│ 				C h¹ t¹ => [C (f¹ h¹) ((map₃ f¹) t¹)]
//│ 				| N => [N]}))
//│ 			where
//│ 			def map₃ = 
//│ 				(fun f² -> (fun ls² -> case ls² of {
//│ 					C h² t² => [C (f² h²) ((map₃ f²) t²)]
//│ 					| N => [N]}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [KKKK] [N]] --->
//│ 	case ls¹ of {C h¹ t¹ => [C (f¹ h¹) ((map₃ f¹) t¹)] | N => [N]}
//│ [C [KK] [C [KKKK] [N]]] --->
//│ 	case ls³ of {C h³ t³ => [C (f³ h³) ((map₂ f³) t³)] | N => [N]}
//│ [C [K] [C [KK] [C [KKKK] [N]]]] --->
//│ 	case ls⁴ of {C h⁴ t⁴ => [C (f⁴ h⁴) ((map₁ f⁴) t⁴)] | N => [N]}
//│ [KKKK] --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ [KK] --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ [K] --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ [N] --->
//│ 	case ls² of {C h² t² => [C (f² h²) ((map₃ f²) t²)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((map₀ ff₀) l₀)
//│ def ff₀ = 
//│ 	(fun x¹ -> x¹)
//│ def l₀ = 
//│ 	let h⁴ = [T]
//│ 	in let t⁴ = 	
//│ 		let h³ = [TT]
//│ 		in let t³ = 	
//│ 			let h¹ = [TTTT]
//│ 			in let t¹ = [N]
//│ 			in [C (f¹ h¹) ((map₃ f¹) t¹)]
//│ 		in [C (f³ h³) ((map₂ f³) t³)]
//│ 	in [C (f⁴ h⁴) ((map₁ f⁴) t⁴)]
//│ def map₀ = 
//│ 	(fun f⁴ -> (fun ls⁴ -> ls⁴))
//│ 	where
//│ 	def map₁ = 
//│ 		(fun f³ -> (fun ls³ -> ls³))
//│ 		where
//│ 		def map₂ = 
//│ 			(fun f¹ -> (fun ls¹ -> ls¹))
//│ 			where
//│ 			def map₃ = 
//│ 				(fun f² -> (fun ls² -> ls²))
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: binding not found: Ident(false,f,1)
//│ !!!!!!ERROR!!!!!!


// NOTE: some program not be able to write?
_LUMBERHACK_ERROR
fun last(ls) = if ls is
    C(h, t) then if t is
        N then Some(h)
        C(hh, tt) then last(t)
        // C(hh, tt) then last(C(hh, tt))
    N then None
let p = C(1, C(2, N))
last(p)
//│ |_LUMBERHACK_ERROR|↵|#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |last|(|t|)|↵|/* C(hh, tt) then last(C(hh, tt))*/|←|↵|N| |#then| |None|←|↵|#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|last|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun last = ls, => if ls is ‹(C (h, t,)) then if t is ‹(N) then Some (h,); (C (hh, tt,)) then last (t,)›; (N) then None›; let p = C (1, C (2, N,),); last (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (last^17 p^18)
//│ def last = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N => [Some h⁰]
//│ 		| C hh⁰ tt⁰ => (last^5 t⁰)}
//│ 	| N => [None]})
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^17]
//│ 	[last^17 · last^5]
//│ 		[last^17 · last^5 · last^5]
//│ 			[last^17 · last^5 · last^5 · last^5] ---> [last^17 · last^5 · last^5] (only one)
//│ [p^18]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (last₀ p₀)
//│ def last₀ = 
//│ 	(fun ls³ -> case ls³ of {
//│ 		C h³ t³ => case t³ of {
//│ 			N => [Some h³]
//│ 			| C hh³ tt³ => (last₁ t³)}
//│ 		| N => [None]})
//│ 	where
//│ 	def last₁ = 
//│ 		(fun ls¹ -> case ls¹ of {
//│ 			C h¹ t¹ => case t¹ of {
//│ 				N => [Some h¹]
//│ 				| C hh¹ tt¹ => (last₂ t¹)}
//│ 			| N => [None]})
//│ 		where
//│ 		def last₂ = 
//│ 			(fun ls² -> case ls² of {
//│ 				C h² t² => case t² of {
//│ 					N => [Some h²]
//│ 					| C hh² tt² => (last₂ t²)}
//│ 				| N => [None]})
//│ def p₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]] --->
//│ 	case ls³ of {C h³ t³ => case t³ of {N => [Some h³] | C hh³ tt³ => (last₁ t³)} | N => [None]}
//│ [C 2 [N]] --->
//│ 	case ls¹ of {C h¹ t¹ => case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₂ t¹)} | N => [None]}
//│ 	case t³ of {N => [Some h³] | C hh³ tt³ => (last₁ t³)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N] --->
//│ 	case ls² of {C h² t² => case t² of {N => [Some h²] | C hh² tt² => (last₂ t²)} | N => [None]}
//│ 	case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₂ t¹)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (last₀ p₀)
//│ def last₀ = 
//│ 	(fun ls³ -> ls³)
//│ 	where
//│ 	def last₁ = 
//│ 		(fun ls¹ -> ls¹)
//│ 		where
//│ 		def last₂ = 
//│ 			(fun ls² -> ls²)
//│ def p₀ = 
//│ 	let h³ = 1
//│ 	in let t³ = 	
//│ 		let h¹ = 2
//│ 		in let t¹ = [None]
//│ 		in case t¹ of {
//│ 			N => [Some h¹]
//│ 			| C hh¹ tt¹ => (last₂ t¹)}
//│ 	in case t³ of {
//│ 		N => [Some h³]
//│ 		| C hh³ tt³ => (last₁ t³)}
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: type error Some('h¹) <: Destruct(N, C('hh³, 'tt³))
//│ !!!!!!ERROR!!!!!!

_LUMBERHACK_ERROR
fun idxSum(ls) = if ls is
    N then acc => 0
    C(h, t) then acc => acc + idxSum(t)(acc + 1)
fun rev(lss) = if lss is
    N then a => a
    C(hh, tt) then a => rev(tt, C(hh, a))
idxSum(rev(C(1, C(2, N)))(N))(0)
//│ |_LUMBERHACK_ERROR|↵|#fun| |idxSum|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc| |=>| |0|↵|C|(|h|,| |t|)| |#then| |acc| |=>| |acc| |+| |idxSum|(|t|)|(|acc| |+| |1|)|←|↵|#fun| |rev|(|lss|)| |#=| |#if| |lss| |is|→|N| |#then| |a| |=>| |a|↵|C|(|hh|,| |tt|)| |#then| |a| |=>| |rev|(|tt|,| |C|(|hh|,| |a|)|)|←|↵|idxSum|(|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|N|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun idxSum = ls, => if ls is ‹(N) then acc, => 0; (C (h, t,)) then acc, => + (acc,) (idxSum (t,) (+ (acc,) (1,),),)›; fun rev = lss, => if lss is ‹(N) then a, => a; (C (hh, tt,)) then a, => rev (tt, C (hh, a,),)›; idxSum (rev (C (1, C (2, N,),),) (N,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((idxSum^33 ((rev^34 [C 1 [C 2 [N]]]) [N])) 0)
//│ def idxSum = (fun ls⁰ -> case ls⁰ of {
//│ 	N => (fun acc⁰ -> 0)
//│ 	| C h⁰ t⁰ => (fun acc¹ -> (acc¹ + ((idxSum^7 t⁰) (acc¹ + 1))))})
//│ def rev = (fun lss⁰ -> case lss⁰ of {
//│ 	N => (fun a⁰ -> a⁰)
//│ 	| C hh⁰ tt⁰ => (fun a¹ -> ((rev^23 tt⁰) [C hh⁰ a¹]))})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [idxSum^33]
//│ 	[idxSum^33 · idxSum^7]
//│ 		[idxSum^33 · idxSum^7 · idxSum^7] ---> [idxSum^33 · idxSum^7] (only one)
//│ [rev^34]
//│ 	[rev^34 · rev^23]
//│ 		[rev^34 · rev^23 · rev^23]
//│ 			[rev^34 · rev^23 · rev^23 · rev^23] ---> [rev^34 · rev^23 · rev^23] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((idxSum₀ ((rev₀ [C 1 [C 2 [N]]]) [N])) 0)
//│ def idxSum₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		N => (fun acc⁴ -> 0)
//│ 		| C h² t² => (fun acc⁵ -> (acc⁵ + ((idxSum₁ t²) (acc⁵ + 1))))})
//│ 	where
//│ 	def idxSum₁ = 
//│ 		(fun ls¹ -> case ls¹ of {
//│ 			N => (fun acc² -> 0)
//│ 			| C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₁ t¹) (acc³ + 1))))})
//│ def rev₀ = 
//│ 	(fun lss¹ -> case lss¹ of {
//│ 		N => (fun a² -> a²)
//│ 		| C hh¹ tt¹ => (fun a³ -> ((rev₁ tt¹) [C hh¹ a³]))})
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun lss³ -> case lss³ of {
//│ 			N => (fun a⁶ -> a⁶)
//│ 			| C hh³ tt³ => (fun a⁷ -> ((rev₂ tt³) [C hh³ a⁷]))})
//│ 		where
//│ 		def rev₂ = 
//│ 			(fun lss² -> case lss² of {
//│ 				N => (fun a⁴ -> a⁴)
//│ 				| C hh² tt² => (fun a⁵ -> ((rev₂ tt²) [C hh² a⁵]))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]] --->
//│ 	case lss¹ of {N => (fun a² -> a²) | C hh¹ tt¹ => (fun a³ -> ((rev₁ tt¹) [C hh¹ a³]))}
//│ [C 2 [N]] --->
//│ 	case lss³ of {N => (fun a⁶ -> a⁶) | C hh³ tt³ => (fun a⁷ -> ((rev₂ tt³) [C hh³ a⁷]))}
//│ [C hh³ a⁷] --->
//│ 	case ls² of {N => (fun acc⁴ -> 0) | C h² t² => (fun acc⁵ -> (acc⁵ + ((idxSum₁ t²) (acc⁵ + 1))))}
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₁ t¹) (acc³ + 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C hh² a⁵] --->
//│ 	case ls² of {N => (fun acc⁴ -> 0) | C h² t² => (fun acc⁵ -> (acc⁵ + ((idxSum₁ t²) (acc⁵ + 1))))}
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₁ t¹) (acc³ + 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C hh¹ a³] --->
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₁ t¹) (acc³ + 1))))}
//│ 	case ls² of {N => (fun acc⁴ -> 0) | C h² t² => (fun acc⁵ -> (acc⁵ + ((idxSum₁ t²) (acc⁵ + 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N] --->
//│ 	case ls² of {N => (fun acc⁴ -> 0) | C h² t² => (fun acc⁵ -> (acc⁵ + ((idxSum₁ t²) (acc⁵ + 1))))}
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₁ t¹) (acc³ + 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N] --->
//│ 	case lss² of {N => (fun a⁴ -> a⁴) | C hh² tt² => (fun a⁵ -> ((rev₂ tt²) [C hh² a⁵]))}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((idxSum₀ ((rev₀ 
//│ 	let hh¹ = 1
//│ 	in let tt¹ = 	
//│ 		let hh³ = 2
//│ 		in let tt³ = (fun a⁴ -> a⁴)
//│ 		in (fun a⁷ -> ((rev₂ tt³) 
//│ 			let h² = hh³
//│ 			in let t² = a⁷
//│ 			in (fun acc⁵ -> (acc⁵ + ((idxSum₁ t²) (acc⁵ + 1))))))
//│ 	in (fun a³ -> ((rev₁ tt¹) 
//│ 		let h¹ = hh¹
//│ 		in let t¹ = a³
//│ 		in (fun acc³ -> (acc³ + ((idxSum₁ t¹) (acc³ + 1))))))) (fun acc⁴ -> 0))) 0)
//│ def idxSum₀ = 
//│ 	(fun ls² -> ls²)
//│ 	where
//│ 	def idxSum₁ = 
//│ 		(fun ls¹ -> ls¹)
//│ def rev₀ = 
//│ 	(fun lss¹ -> lss¹)
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun lss³ -> lss³)
//│ 		where
//│ 		def rev₂ = 
//│ 			(fun lss² -> lss²)
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!


fun minuss(a) = if a is
    S(aa) then b => if b is
        S(bb) then minuss(aa, bb)
        Z then aa
    Z then n => Z
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |#if| |b| |is|→|S|(|bb|)| |#then| |minuss|(|aa|,| |bb|)|↵|Z| |#then| |aa|←|↵|Z| |#then| |n| |=>| |Z|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {fun minuss = a, => if a is ‹(S (aa,)) then b, => if b is ‹(S (bb,)) then minuss (aa, bb,); (Z) then aa›; (Z) then n, => Z›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((minuss^19 fst^20) snd^22)
//│ def fst = [S [S [Z]]]
//│ def minuss = (fun a⁰ -> case a⁰ of {
//│ 	S aa⁰ => (fun b⁰ -> case b⁰ of {
//│ 		S bb⁰ => ((minuss^3 aa⁰) bb⁰)
//│ 		| Z => aa⁰})
//│ 	| Z => (fun n⁰ -> [Z])})
//│ def snd = [Z]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fst^20]
//│ [minuss^19]
//│ 	[minuss^19 · minuss^3]
//│ 		[minuss^19 · minuss^3 · minuss^3] ---> [minuss^19 · minuss^3] (only one)
//│ [snd^22]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((minuss₀ fst₀) snd₀)
//│ def fst₀ = 
//│ 	[S [S [Z]]]
//│ def minuss₀ = 
//│ 	(fun a² -> case a² of {
//│ 		S aa² => (fun b² -> case b² of {
//│ 			S bb² => ((minuss₁ aa²) bb²)
//│ 			| Z => aa²})
//│ 		| Z => (fun n² -> [Z])})
//│ 	where
//│ 	def minuss₁ = 
//│ 		(fun a¹ -> case a¹ of {
//│ 			S aa¹ => (fun b¹ -> case b¹ of {
//│ 				S bb¹ => ((minuss₁ aa¹) bb¹)
//│ 				| Z => aa¹})
//│ 			| Z => (fun n¹ -> [Z])})
//│ def snd₀ = 
//│ 	[Z]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S [S [Z]]] --->
//│ 	case a² of {S aa² => (fun b² -> case b² of {S bb² => ((minuss₁ aa²) bb²) | Z => aa²}) | Z => (fun n² -> [Z])}
//│ [S [Z]] --->
//│ 	case a¹ of {S aa¹ => (fun b¹ -> case b¹ of {S bb¹ => ((minuss₁ aa¹) bb¹) | Z => aa¹}) | Z => (fun n¹ -> [Z])}
//│ [Z] --->
//│ 	case a¹ of {S aa¹ => (fun b¹ -> case b¹ of {S bb¹ => ((minuss₁ aa¹) bb¹) | Z => aa¹}) | Z => (fun n¹ -> [Z])}
//│ [Z] --->
//│ 	case b² of {S bb² => ((minuss₁ aa²) bb²) | Z => aa²}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((minuss₀ fst₀) snd₀)
//│ def fst₀ = 
//│ 	let aa² = 	
//│ 		let aa¹ = (fun n¹ -> [Z])
//│ 		in (fun b¹ -> case b¹ of {
//│ 			S bb¹ => ((minuss₁ aa¹) bb¹)
//│ 			| Z => aa¹})
//│ 	in (fun b² -> b²)
//│ def minuss₀ = 
//│ 	(fun a² -> a²)
//│ 	where
//│ 	def minuss₁ = 
//│ 		(fun a¹ -> a¹)
//│ def snd₀ = 
//│ 	aa²
//│ <<<<<<< after fusion <<<<<<<
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: binding not found: Ident(false,aa,2)
//│ 	at: mlscript.utils.package$.lastWords(package.scala:186)
//│ 	at: mlscript.lumberhack.Ctx.apply$$anonfun$1(Deforest.scala:200)
//│ 	at: scala.collection.immutable.Map$Map4.getOrElse(Map.scala:530)
//│ 	at: mlscript.lumberhack.Ctx.apply(Deforest.scala:200)
//│ 	at: mlscript.lumberhack.Deforest.process$$anonfun$1(Deforest.scala:274)
//│ 	at: mlscript.lumberhack.Deforest$Trace$.trace(Deforest.scala:218)
//│ 	at: mlscript.lumberhack.Deforest.process(Deforest.scala:314)
//│ 	at: mlscript.lumberhack.Deforest.apply$$anonfun$2$$anonfun$1(Deforest.scala:326)
//│ 	at: scala.collection.immutable.List.map(List.scala:250)
//│ 	at: mlscript.lumberhack.Deforest.apply$$anonfun$2(Deforest.scala:336)

// FIXME: weird recursive
_LUMBERHACK_ERROR
fun minuss(a) = if a is
    S(aa) then b => checkb(b)(aa)
    Z then n => Z
fun checkb(b) = if b is
    S(bb) then aaa => minuss(aaa, bb)
    Z then aaa => aaa
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |_LUMBERHACK_ERROR|↵|#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |checkb|(|b|)|(|aa|)|↵|Z| |#then| |n| |=>| |Z|←|↵|#fun| |checkb|(|b|)| |#=| |#if| |b| |is|→|S|(|bb|)| |#then| |aaa| |=>| |minuss|(|aaa|,| |bb|)|↵|Z| |#then| |aaa| |=>| |aaa|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun minuss = a, => if a is ‹(S (aa,)) then b, => checkb (b,) (aa,); (Z) then n, => Z›; fun checkb = b, => if b is ‹(S (bb,)) then aaa, => minuss (aaa, bb,); (Z) then aaa, => aaa›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((minuss^27 fst^28) snd^30)
//│ def checkb = (fun b¹ -> case b¹ of {
//│ 	S bb⁰ => (fun aaa⁰ -> ((minuss^13 aaa⁰) bb⁰))
//│ 	| Z => (fun aaa¹ -> aaa¹)})
//│ def fst = [S [S [Z]]]
//│ def minuss = (fun a⁰ -> case a⁰ of {
//│ 	S aa⁰ => (fun b⁰ -> ((checkb^2 b⁰) aa⁰))
//│ 	| Z => (fun n⁰ -> [Z])})
//│ def snd = [Z]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fst^28]
//│ [minuss^27]
//│ 	[minuss^27 · checkb^2]
//│ 		[minuss^27 · checkb^2 · minuss^13]
//│ 			[minuss^27 · checkb^2 · minuss^13 · checkb^2] ---> [minuss^27 · checkb^2] (only one)
//│ [snd^30]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((minuss₀ fst₀) snd₀)
//│ def fst₀ = 
//│ 	[S [S [Z]]]
//│ def minuss₀ = 
//│ 	(fun a¹ -> case a¹ of {
//│ 		S aa¹ => (fun b² -> ((checkb₀ b²) aa¹))
//│ 		| Z => (fun n¹ -> [Z])})
//│ 	where
//│ 	def checkb₀ = 
//│ 		(fun b⁴ -> case b⁴ of {
//│ 			S bb¹ => (fun aaa² -> ((minuss₁ aaa²) bb¹))
//│ 			| Z => (fun aaa³ -> aaa³)})
//│ 		where
//│ 		def minuss₁ = 
//│ 			(fun a² -> case a² of {
//│ 				S aa² => (fun b³ -> ((checkb₀ b³) aa²))
//│ 				| Z => (fun n² -> [Z])})
//│ def snd₀ = 
//│ 	[Z]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S [S [Z]]] --->
//│ 	case a¹ of {S aa¹ => (fun b² -> ((checkb₀ b²) aa¹)) | Z => (fun n¹ -> [Z])}
//│ [S [Z]] --->
//│ 	case a² of {S aa² => (fun b³ -> ((checkb₀ b³) aa²)) | Z => (fun n² -> [Z])}
//│ [Z] --->
//│ 	case a² of {S aa² => (fun b³ -> ((checkb₀ b³) aa²)) | Z => (fun n² -> [Z])}
//│ [Z] --->
//│ 	case b⁴ of {S bb¹ => (fun aaa² -> ((minuss₁ aaa²) bb¹)) | Z => (fun aaa³ -> aaa³)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((minuss₀ fst₀) snd₀)
//│ def fst₀ = 
//│ 	let aa¹ = 	
//│ 		let aa² = (fun n² -> [Z])
//│ 		in (fun b³ -> ((checkb₀ b³) aa²))
//│ 	in (fun b² -> ((checkb₀ b²) aa¹))
//│ def minuss₀ = 
//│ 	(fun a¹ -> a¹)
//│ 	where
//│ 	def checkb₀ = 
//│ 		(fun b⁴ -> b⁴)
//│ 		where
//│ 		def minuss₁ = 
//│ 			(fun a² -> a²)
//│ def snd₀ = 
//│ 	(fun aaa³ -> aaa³)
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!


fun id(x) = if x is
    ID(b) then b
    C(a) then id(ID(C(a)))
let p = C(p)
fun c(y) = if y is
    C(aa) then c(aa)
c(id(p))
//│ |#fun| |id|(|x|)| |#=| |#if| |x| |is|→|ID|(|b|)| |#then| |b|↵|C|(|a|)| |#then| |id|(|ID|(|C|(|a|)|)|)|←|↵|#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |c|(|aa|)|←|↵|c|(|id|(|p|)|)|
//│ Parsed: {fun id = x, => if x is ‹(ID (b,)) then b; (C (a,)) then id (ID (C (a,),),)›; let p = C (p,); fun c = y, => if y is ‹(C (aa,)) then c (aa,)›; c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^18 (id^19 p^20))
//│ def c = (fun y⁰ -> case y⁰ of {
//│ 	C aa⁰ => (c^13 aa⁰)})
//│ def id = (fun x⁰ -> case x⁰ of {
//│ 	ID b⁰ => b⁰
//│ 	| C a⁰ => (id^3 [ID [C a⁰]])})
//│ def p = [C p^10]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^18]
//│ 	[c^18 · c^13] ---> [c^18] (only one)
//│ [id^19]
//│ 	[id^19 · id^3] (hopeless to continue)
//│ 		[id^19 · id^3 · id^3] ---> [id^19 · id^3] (using original def)
//│ [p^20]
//│ 	[p^20 · p^10]
//│ 		[p^20 · p^10 · p^10] ---> [p^20 · p^10] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ (id₀ p₀))
//│ def c₀ = 
//│ 	(fun y¹ -> case y¹ of {
//│ 		C aa¹ => (c₀ aa¹)})
//│ def id₀ = 
//│ 	(fun x² -> case x² of {
//│ 		ID b² => b²
//│ 		| C a² => (id₁ [ID [C a²]])})
//│ 	where
//│ 	def id₁ = 
//│ 		(fun x¹ -> case x¹ of {
//│ 			ID b¹ => b¹
//│ 			| C a¹ => (id₁ [ID [C a¹]])})
//│ def p₀ = 
//│ 	[C p₁]
//│ 	where
//│ 	def p₁ = 
//│ 		[C p₁]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a¹] --->
//│ 	case y¹ of {C aa¹ => (c₀ aa¹)}
//│ [C a²] --->
//│ 	case y¹ of {C aa¹ => (c₀ aa¹)}
//│ [C p₁] --->
//│ 	case y¹ of {C aa¹ => (c₀ aa¹)}
//│ [C p₁] --->
//│ 	case x² of {ID b² => b² | C a² => (id₁ [ID [C a²]])}
//│ [ID [C a¹]] --->
//│ 	case x¹ of {ID b¹ => b¹ | C a¹ => (id₁ [ID [C a¹]])}
//│ [ID [C a²]] --->
//│ 	case x¹ of {ID b¹ => b¹ | C a¹ => (id₁ [ID [C a¹]])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ (id₀ p₀))
//│ def c₀ = 
//│ 	(fun y¹ -> y¹)
//│ def id₀ = 
//│ 	(fun x² -> x²)
//│ 	where
//│ 	def id₁ = 
//│ 		(fun x¹ -> x¹)
//│ def p₀ = 
//│ 	let a² = p₁
//│ 	in (id₁ 
//│ 		let b¹ = 	
//│ 			let aa¹ = a²
//│ 			in (c₀ aa¹)
//│ 		in b¹)
//│ 	where
//│ 	def p₁ = 
//│ 		let aa¹ = p₁
//│ 		in (c₀ aa¹)
//│ <<<<<<< after fusion <<<<<<<

