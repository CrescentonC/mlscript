:NewParser
:ParseOnly


// WRONG: infinite rewrting how to produce a finite rewrtten program?
_LUMBERHACK_ERROR
let p = Pair(A, B)
fun c(x) = if x is
  Pair(a, b) then c(Pair(b, a))
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^12 p^13)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	Pair a⁰ b⁰ => (c^5 [Pair b⁰ a⁰])})
//│ def p = [Pair [A] [B]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^12] (hopeless to continue)
//│ 	[c^12 · c^5] ---> [c^12] (using original def)
//│ [p^13] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		Pair a¹ b¹ => (c₀ [Pair b¹ a¹])})
//│ def p₀ = 
//│ 	[Pair [A] [B]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Pair [A] [B]] --->
//│ 	case x¹ of {Pair a¹ b¹ => (c₀ [Pair b¹ a¹])}
//│ [Pair b¹ a¹] --->
//│ 	case x¹ of {Pair a¹ b¹ => (c₀ [Pair b¹ a¹])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!

// Just a more valid/reasonable version of the above
// WRONG: recursive strategy
_LUMBERHACK_ERROR
let p = Wrap(3)
fun c(x) = if x is
  Wrap(a) then if a > 0 then c(Wrap(a - 1)) else Wrap(0)
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Wrap|(|3|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Wrap|(|a|)| |#then| |#if| |a| |>| |0| |#then| |c|(|Wrap|(|a| |-| |1|)|)| |#else| |Wrap|(|0|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Wrap (3,); fun c = x, => if x is ‹(Wrap (a,)) then if (> (a,) (0,)) then c (Wrap (- (a,) (1,),),) else Wrap (0,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^22 p^23)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	Wrap a⁰ => if (a⁰ > 0) then (c^9 [Wrap (a⁰ - 1)]) else [Wrap 0]})
//│ def p = [Wrap 3]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^22] (hopeless to continue)
//│ 	[c^22 · c^9] ---> [c^22] (using original def)
//│ [p^23] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		Wrap a¹ => if (a¹ > 0) then (c₀ [Wrap (a¹ - 1)]) else [Wrap 0]})
//│ def p₀ = 
//│ 	[Wrap 3]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Wrap (a¹ - 1)] --->
//│ 	case x¹ of {Wrap a¹ => if (a¹ > 0) then (c₀ [Wrap (a¹ - 1)]) else [Wrap 0]}
//│ [Wrap 3] --->
//│ 	case x¹ of {Wrap a¹ => if (a¹ > 0) then (c₀ [Wrap (a¹ - 1)]) else [Wrap 0]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!



// WRONG: branching and conflict, but can be solved by rewriting into
// NOTE: some program not be able to write?
_LUMBERHACK_ERROR
fun last(ls) = if ls is
  C(h, t) then if t is
    N then Some(h)
    C(hh, tt) then last(t)
  N then None
let p = C(1, C(2, N))
last(p)
//│ |_LUMBERHACK_ERROR|↵|#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |last|(|t|)|←|↵|N| |#then| |None|←|↵|#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|last|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun last = ls, => if ls is ‹(C (h, t,)) then if t is ‹(N) then Some (h,); (C (hh, tt,)) then last (t,)›; (N) then None›; let p = C (1, C (2, N,),); last (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (last^17 p^18)
//│ def last = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N => [Some h⁰]
//│ 		| C hh⁰ tt⁰ => (last^5 t⁰)}
//│ 	| N => [None]})
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^17]
//│ 	[last^17 · last^5]
//│ 		[last^17 · last^5 · last^5]
//│ 			[last^17 · last^5 · last^5 · last^5] ---> [last^17 · last^5 · last^5] (only one)
//│ [p^18]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (last₀ p₀)
//│ def last₀ = 
//│ 	(fun ls³ -> case ls³ of {
//│ 		C h³ t³ => case t³ of {
//│ 			N => [Some h³]
//│ 			| C hh³ tt³ => (last₁ t³)}
//│ 		| N => [None]})
//│ 	where
//│ 	def last₁ = 
//│ 		(fun ls¹ -> case ls¹ of {
//│ 			C h¹ t¹ => case t¹ of {
//│ 				N => [Some h¹]
//│ 				| C hh¹ tt¹ => (last₂ t¹)}
//│ 			| N => [None]})
//│ 		where
//│ 		def last₂ = 
//│ 			(fun ls² -> case ls² of {
//│ 				C h² t² => case t² of {
//│ 					N => [Some h²]
//│ 					| C hh² tt² => (last₂ t²)}
//│ 				| N => [None]})
//│ def p₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]] --->
//│ 	case ls³ of {C h³ t³ => case t³ of {N => [Some h³] | C hh³ tt³ => (last₁ t³)} | N => [None]}
//│ [C 2 [N]] --->
//│ 	case ls¹ of {C h¹ t¹ => case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₂ t¹)} | N => [None]}
//│ 	case t³ of {N => [Some h³] | C hh³ tt³ => (last₁ t³)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N] --->
//│ 	case ls² of {C h² t² => case t² of {N => [Some h²] | C hh² tt² => (last₂ t²)} | N => [None]}
//│ 	case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₂ t¹)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (last₀ p₀)
//│ def last₀ = 
//│ 	(fun ls³ -> ls³)
//│ 	where
//│ 	def last₁ = 
//│ 		(fun ls¹ -> ls¹)
//│ 		where
//│ 		def last₂ = 
//│ 			(fun ls² -> ls²)
//│ def p₀ = 
//│ 	let h³ = 1
//│ 	in let t³ = 	
//│ 		let h¹ = 2
//│ 		in let t¹ = [None]
//│ 		in case t¹ of {
//│ 			N => [Some h¹]
//│ 			| C hh¹ tt¹ => (last₂ t¹)}
//│ 	in case t³ of {
//│ 		N => [Some h³]
//│ 		| C hh³ tt³ => (last₁ t³)}
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: type error Some('h¹) <: Destruct(N, C('hh³, 'tt³))
//│ !!!!!!ERROR!!!!!!

// WRONG: one consumer cannot be expanded fully?
fun idxSum(ls) = if ls is
  N then acc => 0
  C(h, t) then acc => acc + idxSum(t)(acc + 1)
fun rev(lss) = if lss is
  N then a => a
  C(hh, tt) then a => rev(tt, C(hh, a))
idxSum(rev(C(1, C(2, N)))(N))(0)
//│ |#fun| |idxSum|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc| |=>| |0|↵|C|(|h|,| |t|)| |#then| |acc| |=>| |acc| |+| |idxSum|(|t|)|(|acc| |+| |1|)|←|↵|#fun| |rev|(|lss|)| |#=| |#if| |lss| |is|→|N| |#then| |a| |=>| |a|↵|C|(|hh|,| |tt|)| |#then| |a| |=>| |rev|(|tt|,| |C|(|hh|,| |a|)|)|←|↵|idxSum|(|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|N|)|)|(|0|)|
//│ Parsed: {fun idxSum = ls, => if ls is ‹(N) then acc, => 0; (C (h, t,)) then acc, => + (acc,) (idxSum (t,) (+ (acc,) (1,),),)›; fun rev = lss, => if lss is ‹(N) then a, => a; (C (hh, tt,)) then a, => rev (tt, C (hh, a,),)›; idxSum (rev (C (1, C (2, N,),),) (N,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((idxSum^33 ((rev^34 [C 1 [C 2 [N]]]) [N])) 0)
//│ def idxSum = (fun ls⁰ -> case ls⁰ of {
//│ 	N => (fun acc⁰ -> 0)
//│ 	| C h⁰ t⁰ => (fun acc¹ -> (acc¹ + ((idxSum^7 t⁰) (acc¹ + 1))))})
//│ def rev = (fun lss⁰ -> case lss⁰ of {
//│ 	N => (fun a⁰ -> a⁰)
//│ 	| C hh⁰ tt⁰ => (fun a¹ -> ((rev^23 tt⁰) [C hh⁰ a¹]))})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [idxSum^33]
//│ 	[idxSum^33 · idxSum^7]
//│ 		[idxSum^33 · idxSum^7 · idxSum^7] ---> [idxSum^33 · idxSum^7] (only one)
//│ [rev^34]
//│ 	[rev^34 · rev^23]
//│ 		[rev^34 · rev^23 · rev^23]
//│ 			[rev^34 · rev^23 · rev^23 · rev^23] ---> [rev^34 · rev^23 · rev^23] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((idxSum₀ ((rev₀ [C 1 [C 2 [N]]]) [N])) 0)
//│ def idxSum₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		N => (fun acc⁴ -> 0)
//│ 		| C h² t² => (fun acc⁵ -> (acc⁵ + ((idxSum₁ t²) (acc⁵ + 1))))})
//│ 	where
//│ 	def idxSum₁ = 
//│ 		(fun ls¹ -> case ls¹ of {
//│ 			N => (fun acc² -> 0)
//│ 			| C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₁ t¹) (acc³ + 1))))})
//│ def rev₀ = 
//│ 	(fun lss¹ -> case lss¹ of {
//│ 		N => (fun a² -> a²)
//│ 		| C hh¹ tt¹ => (fun a³ -> ((rev₁ tt¹) [C hh¹ a³]))})
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun lss³ -> case lss³ of {
//│ 			N => (fun a⁶ -> a⁶)
//│ 			| C hh³ tt³ => (fun a⁷ -> ((rev₂ tt³) [C hh³ a⁷]))})
//│ 		where
//│ 		def rev₂ = 
//│ 			(fun lss² -> case lss² of {
//│ 				N => (fun a⁴ -> a⁴)
//│ 				| C hh² tt² => (fun a⁵ -> ((rev₂ tt²) [C hh² a⁵]))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]] --->
//│ 	case lss¹ of {N => (fun a² -> a²) | C hh¹ tt¹ => (fun a³ -> ((rev₁ tt¹) [C hh¹ a³]))}
//│ [C 2 [N]] --->
//│ 	case lss³ of {N => (fun a⁶ -> a⁶) | C hh³ tt³ => (fun a⁷ -> ((rev₂ tt³) [C hh³ a⁷]))}
//│ [C hh³ a⁷] --->
//│ 	case ls² of {N => (fun acc⁴ -> 0) | C h² t² => (fun acc⁵ -> (acc⁵ + ((idxSum₁ t²) (acc⁵ + 1))))}
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₁ t¹) (acc³ + 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C hh² a⁵] --->
//│ 	case ls² of {N => (fun acc⁴ -> 0) | C h² t² => (fun acc⁵ -> (acc⁵ + ((idxSum₁ t²) (acc⁵ + 1))))}
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₁ t¹) (acc³ + 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C hh¹ a³] --->
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₁ t¹) (acc³ + 1))))}
//│ 	case ls² of {N => (fun acc⁴ -> 0) | C h² t² => (fun acc⁵ -> (acc⁵ + ((idxSum₁ t²) (acc⁵ + 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N] --->
//│ 	case ls² of {N => (fun acc⁴ -> 0) | C h² t² => (fun acc⁵ -> (acc⁵ + ((idxSum₁ t²) (acc⁵ + 1))))}
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₁ t¹) (acc³ + 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N] --->
//│ 	case lss² of {N => (fun a⁴ -> a⁴) | C hh² tt² => (fun a⁵ -> ((rev₂ tt²) [C hh² a⁵]))}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((idxSum₀ ((rev₀ 
//│ 	let hh¹ = 1
//│ 	in let tt¹ = 	
//│ 		let hh³ = 2
//│ 		in let tt³ = (fun a⁴ -> a⁴)
//│ 		in (fun a⁷ -> ((rev₂ tt³) 
//│ 			let h² = hh³
//│ 			in let t² = a⁷
//│ 			in (fun acc⁵ -> (acc⁵ + ((idxSum₁ t²) (acc⁵ + 1))))))
//│ 	in (fun a³ -> ((rev₁ tt¹) 
//│ 		let h¹ = hh¹
//│ 		in let t¹ = a³
//│ 		in (fun acc³ -> (acc³ + ((idxSum₁ t¹) (acc³ + 1))))))) (fun acc⁴ -> 0))) 0)
//│ def idxSum₀ = 
//│ 	(fun ls² -> ls²)
//│ 	where
//│ 	def idxSum₁ = 
//│ 		(fun ls¹ -> ls¹)
//│ def rev₀ = 
//│ 	(fun lss¹ -> lss¹)
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun lss³ -> lss³)
//│ 		where
//│ 		def rev₂ = 
//│ 			(fun lss² -> lss²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ (0 + ((0 + 1) + 0))
//│ <<<<<<< evaluate <<<<<<<


// WRONG: still has variable extrusion
_LUMBERHACK_ERROR
fun minuss(a) = if a is
  S(aa) then b => if b is
    S(bb) then minuss(aa, bb)
    Z then aa
  Z then n => Z
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |_LUMBERHACK_ERROR|↵|#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |#if| |b| |is|→|S|(|bb|)| |#then| |minuss|(|aa|,| |bb|)|↵|Z| |#then| |aa|←|↵|Z| |#then| |n| |=>| |Z|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun minuss = a, => if a is ‹(S (aa,)) then b, => if b is ‹(S (bb,)) then minuss (aa, bb,); (Z) then aa›; (Z) then n, => Z›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((minuss^19 fst^20) snd^22)
//│ def fst = [S [S [Z]]]
//│ def minuss = (fun a⁰ -> case a⁰ of {
//│ 	S aa⁰ => (fun b⁰ -> case b⁰ of {
//│ 		S bb⁰ => ((minuss^3 aa⁰) bb⁰)
//│ 		| Z => aa⁰})
//│ 	| Z => (fun n⁰ -> [Z])})
//│ def snd = [Z]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fst^20]
//│ [minuss^19]
//│ 	[minuss^19 · minuss^3]
//│ 		[minuss^19 · minuss^3 · minuss^3] ---> [minuss^19 · minuss^3] (only one)
//│ [snd^22]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((minuss₀ fst₀) snd₀)
//│ def fst₀ = 
//│ 	[S [S [Z]]]
//│ def minuss₀ = 
//│ 	(fun a² -> case a² of {
//│ 		S aa² => (fun b² -> case b² of {
//│ 			S bb² => ((minuss₁ aa²) bb²)
//│ 			| Z => aa²})
//│ 		| Z => (fun n² -> [Z])})
//│ 	where
//│ 	def minuss₁ = 
//│ 		(fun a¹ -> case a¹ of {
//│ 			S aa¹ => (fun b¹ -> case b¹ of {
//│ 				S bb¹ => ((minuss₁ aa¹) bb¹)
//│ 				| Z => aa¹})
//│ 			| Z => (fun n¹ -> [Z])})
//│ def snd₀ = 
//│ 	[Z]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S [S [Z]]] --->
//│ 	case a² of {S aa² => (fun b² -> case b² of {S bb² => ((minuss₁ aa²) bb²) | Z => aa²}) | Z => (fun n² -> [Z])}
//│ [S [Z]] --->
//│ 	case a¹ of {S aa¹ => (fun b¹ -> case b¹ of {S bb¹ => ((minuss₁ aa¹) bb¹) | Z => aa¹}) | Z => (fun n¹ -> [Z])}
//│ [Z] --->
//│ 	case a¹ of {S aa¹ => (fun b¹ -> case b¹ of {S bb¹ => ((minuss₁ aa¹) bb¹) | Z => aa¹}) | Z => (fun n¹ -> [Z])}
//│ [Z] --->
//│ 	case b² of {S bb² => ((minuss₁ aa²) bb²) | Z => aa²}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((minuss₀ fst₀) snd₀)
//│ def fst₀ = 
//│ 	let aa² = 	
//│ 		let aa¹ = (fun n¹ -> [Z])
//│ 		in (fun b¹ -> case b¹ of {
//│ 			S bb¹ => ((minuss₁ aa¹) bb¹)
//│ 			| Z => aa¹})
//│ 	in (fun b² -> b²)
//│ def minuss₀ = 
//│ 	(fun a² -> a²)
//│ 	where
//│ 	def minuss₁ = 
//│ 		(fun a¹ -> a¹)
//│ def snd₀ = 
//│ 	aa²
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: binding not found: Ident(false,aa,2)
//│ !!!!!!ERROR!!!!!!


// WRONG:
fun minuss(a) = if a is
  S(aa) then b => checkb(b)(aa)
  Z then n => Z
fun checkb(b) = if b is
  S(bb) then aaa => minuss(aaa, bb)
  Z then aaa => aaa
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |checkb|(|b|)|(|aa|)|↵|Z| |#then| |n| |=>| |Z|←|↵|#fun| |checkb|(|b|)| |#=| |#if| |b| |is|→|S|(|bb|)| |#then| |aaa| |=>| |minuss|(|aaa|,| |bb|)|↵|Z| |#then| |aaa| |=>| |aaa|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {fun minuss = a, => if a is ‹(S (aa,)) then b, => checkb (b,) (aa,); (Z) then n, => Z›; fun checkb = b, => if b is ‹(S (bb,)) then aaa, => minuss (aaa, bb,); (Z) then aaa, => aaa›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((minuss^27 fst^28) snd^30)
//│ def checkb = (fun b¹ -> case b¹ of {
//│ 	S bb⁰ => (fun aaa⁰ -> ((minuss^13 aaa⁰) bb⁰))
//│ 	| Z => (fun aaa¹ -> aaa¹)})
//│ def fst = [S [S [Z]]]
//│ def minuss = (fun a⁰ -> case a⁰ of {
//│ 	S aa⁰ => (fun b⁰ -> ((checkb^2 b⁰) aa⁰))
//│ 	| Z => (fun n⁰ -> [Z])})
//│ def snd = [Z]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fst^28]
//│ [minuss^27]
//│ 	[minuss^27 · checkb^2]
//│ 		[minuss^27 · checkb^2 · minuss^13]
//│ 			[minuss^27 · checkb^2 · minuss^13 · checkb^2] ---> [minuss^27 · checkb^2] (only one)
//│ [snd^30]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((minuss₀ fst₀) snd₀)
//│ def fst₀ = 
//│ 	[S [S [Z]]]
//│ def minuss₀ = 
//│ 	(fun a¹ -> case a¹ of {
//│ 		S aa¹ => (fun b² -> ((checkb₀ b²) aa¹))
//│ 		| Z => (fun n¹ -> [Z])})
//│ 	where
//│ 	def checkb₀ = 
//│ 		(fun b⁴ -> case b⁴ of {
//│ 			S bb¹ => (fun aaa² -> ((minuss₁ aaa²) bb¹))
//│ 			| Z => (fun aaa³ -> aaa³)})
//│ 		where
//│ 		def minuss₁ = 
//│ 			(fun a² -> case a² of {
//│ 				S aa² => (fun b³ -> ((checkb₀ b³) aa²))
//│ 				| Z => (fun n² -> [Z])})
//│ def snd₀ = 
//│ 	[Z]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S [S [Z]]] --->
//│ 	case a¹ of {S aa¹ => (fun b² -> ((checkb₀ b²) aa¹)) | Z => (fun n¹ -> [Z])}
//│ [S [Z]] --->
//│ 	case a² of {S aa² => (fun b³ -> ((checkb₀ b³) aa²)) | Z => (fun n² -> [Z])}
//│ [Z] --->
//│ 	case a² of {S aa² => (fun b³ -> ((checkb₀ b³) aa²)) | Z => (fun n² -> [Z])}
//│ [Z] --->
//│ 	case b⁴ of {S bb¹ => (fun aaa² -> ((minuss₁ aaa²) bb¹)) | Z => (fun aaa³ -> aaa³)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((minuss₀ fst₀) snd₀)
//│ def fst₀ = 
//│ 	let aa¹ = 	
//│ 		let aa² = (fun n² -> [Z])
//│ 		in (fun b³ -> ((checkb₀ b³) aa²))
//│ 	in (fun b² -> ((checkb₀ b²) aa¹))
//│ def minuss₀ = 
//│ 	(fun a¹ -> a¹)
//│ 	where
//│ 	def checkb₀ = 
//│ 		(fun b⁴ -> b⁴)
//│ 		where
//│ 		def minuss₁ = 
//│ 			(fun a² -> a²)
//│ def snd₀ = 
//│ 	(fun aaa³ -> aaa³)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ (fun b³ -> (b³ (fun n² -> [Z])))
//│ <<<<<<< evaluate <<<<<<<

// WRONG:
_LUMBERHACK_ERROR
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let rec l1 = C(1, C(2, l1))
let rec l2 = C(9, C(8, l2))
inter(l1)(l2)
//│ |_LUMBERHACK_ERROR|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |#rec| |l1| |#=| |C|(|1|,| |C|(|2|,| |l1|)|)|↵|#let| |#rec| |l2| |#=| |C|(|9|,| |C|(|8|,| |l2|)|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let rec l1 = C (1, C (2, l1,),); let rec l2 = C (9, C (8, l2,),); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter^24 l1^25) l2^27)
//│ def inter = (fun xs⁰ -> case xs⁰ of {
//│ 	N => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ ((inter^5 ys¹) t⁰)])})
//│ def l1 = [C 1 [C 2 l1^16]]
//│ def l2 = [C 9 [C 8 l2^21]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^24]
//│ 	[inter^24 · inter^5]
//│ 		[inter^24 · inter^5 · inter^5]
//│ 			[inter^24 · inter^5 · inter^5 · inter^5]
//│ 				[inter^24 · inter^5 · inter^5 · inter^5 · inter^5]
//│ 					[inter^24 · inter^5 · inter^5 · inter^5 · inter^5 · inter^5] ---> [inter^24 · inter^5] (only one)
//│ [l1^25]
//│ 	[l1^25 · l1^16] ---> [l1^25] (only one)
//│ [l2^27]
//│ 	[l2^27 · l2^21] ---> [l2^27] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((inter₀ l1₀) l2₀)
//│ def inter₀ = 
//│ 	(fun xs⁵ -> case xs⁵ of {
//│ 		N => (fun ys¹⁰ -> ys¹⁰)
//│ 		| C h⁵ t⁵ => (fun ys¹¹ -> [C h⁵ ((inter₁ ys¹¹) t⁵)])})
//│ 	where
//│ 	def inter₁ = 
//│ 		(fun xs² -> case xs² of {
//│ 			N => (fun ys⁴ -> ys⁴)
//│ 			| C h² t² => (fun ys⁵ -> [C h² ((inter₂ ys⁵) t²)])})
//│ 		where
//│ 		def inter₂ = 
//│ 			(fun xs³ -> case xs³ of {
//│ 				N => (fun ys⁶ -> ys⁶)
//│ 				| C h³ t³ => (fun ys⁷ -> [C h³ ((inter₃ ys⁷) t³)])})
//│ 			where
//│ 			def inter₃ = 
//│ 				(fun xs¹ -> case xs¹ of {
//│ 					N => (fun ys² -> ys²)
//│ 					| C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₄ ys³) t¹)])})
//│ 				where
//│ 				def inter₄ = 
//│ 					(fun xs⁴ -> case xs⁴ of {
//│ 						N => (fun ys⁸ -> ys⁸)
//│ 						| C h⁴ t⁴ => (fun ys⁹ -> [C h⁴ ((inter₁ ys⁹) t⁴)])})
//│ def l1₀ = 
//│ 	[C 1 [C 2 l1₀]]
//│ def l2₀ = 
//│ 	[C 9 [C 8 l2₀]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 l1₀]] --->
//│ 	case xs⁵ of {N => (fun ys¹⁰ -> ys¹⁰) | C h⁵ t⁵ => (fun ys¹¹ -> [C h⁵ ((inter₁ ys¹¹) t⁵)])}
//│ 	case xs⁴ of {N => (fun ys⁸ -> ys⁸) | C h⁴ t⁴ => (fun ys⁹ -> [C h⁴ ((inter₁ ys⁹) t⁴)])}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C 2 l1₀] --->
//│ 	case xs³ of {N => (fun ys⁶ -> ys⁶) | C h³ t³ => (fun ys⁷ -> [C h³ ((inter₃ ys⁷) t³)])}
//│ [C 8 l2₀] --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₄ ys³) t¹)])}
//│ [C 9 [C 8 l2₀]] --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h² t² => (fun ys⁵ -> [C h² ((inter₂ ys⁵) t²)])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((inter₀ l1₀) l2₀)
//│ def inter₀ = 
//│ 	(fun xs⁵ -> xs⁵)
//│ 	where
//│ 	def inter₁ = 
//│ 		(fun xs² -> xs²)
//│ 		where
//│ 		def inter₂ = 
//│ 			(fun xs³ -> xs³)
//│ 			where
//│ 			def inter₃ = 
//│ 				(fun xs¹ -> xs¹)
//│ 				where
//│ 				def inter₄ = 
//│ 					(fun xs⁴ -> case xs⁴ of {
//│ 						N => (fun ys⁸ -> ys⁸)
//│ 						| C h⁴ t⁴ => (fun ys⁹ -> [C h⁴ ((inter₁ ys⁹) t⁴)])})
//│ def l1₀ = 
//│ 	let h⁵ = 1
//│ 	in let t⁵ = 	
//│ 		let h³ = 2
//│ 		in let t³ = l1₀
//│ 		in (fun ys⁷ -> [C h³ ((inter₃ ys⁷) t³)])
//│ 	in (fun ys¹¹ -> [C h⁵ ((inter₁ ys¹¹) t⁵)])
//│ def l2₀ = 
//│ 	let h² = 9
//│ 	in let t² = 	
//│ 		let h¹ = 8
//│ 		in let t¹ = l2₀
//│ 		in (fun ys³ -> [C h¹ ((inter₄ ys³) t¹)])
//│ 	in (fun ys⁵ -> [C h² ((inter₂ ys⁵) t²)])
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: type error 'ys¹¹ => C('h⁵, '159_callres) <: Destruct(N, C('h⁴, 't⁴))
//│ !!!!!!ERROR!!!!!!


// WRONG: push in cannot work still have binding error
// and wrong recursive knots
_LUMBERHACK_ERROR
fun f(xs) = if xs is
  X(x1) then if x1 is
    X(x2) then if x2 is
      X(x3) then ys => if ys is
        Y(y1) then if y1 is
          Y(y2) then f(x3, y2)
let rec xx = X(X(xx))
let rec yy = Y(Y(Y(yy)))
f(xx, yy)
//│ |_LUMBERHACK_ERROR|↵|#fun| |f|(|xs|)| |#=| |#if| |xs| |is|→|X|(|x1|)| |#then| |#if| |x1| |is|→|X|(|x2|)| |#then| |#if| |x2| |is|→|X|(|x3|)| |#then| |ys| |=>| |#if| |ys| |is|→|Y|(|y1|)| |#then| |#if| |y1| |is|→|Y|(|y2|)| |#then| |f|(|x3|,| |y2|)|←|←|←|←|←|↵|#let| |#rec| |xx| |#=| |X|(|X|(|xx|)|)|↵|#let| |#rec| |yy| |#=| |Y|(|Y|(|Y|(|yy|)|)|)|↵|f|(|xx|,| |yy|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun f = xs, => if xs is ‹(X (x1,)) then if x1 is ‹(X (x2,)) then if x2 is ‹(X (x3,)) then ys, => if ys is ‹(Y (y1,)) then if y1 is ‹(Y (y2,)) then f (x3, y2,)›››››; let rec xx = X (X (xx,),); let rec yy = Y (Y (Y (yy,),),); f (xx, yy,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((f^25 xx^26) yy^28)
//│ def f = (fun xs⁰ -> case xs⁰ of {
//│ 	X x1⁰ => case x1⁰ of {
//│ 		X x2⁰ => case x2⁰ of {
//│ 			X x3⁰ => (fun ys⁰ -> case ys⁰ of {
//│ 				Y y1⁰ => case y1⁰ of {
//│ 					Y y2⁰ => ((f^6 x3⁰) y2⁰)}})}}})
//│ def xx = [X [X xx^18]]
//│ def yy = [Y [Y [Y yy^21]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^25]
//│ 	[f^25 · f^6]
//│ 		[f^25 · f^6 · f^6]
//│ 			[f^25 · f^6 · f^6 · f^6] ---> [f^25 · f^6] (only one)
//│ [xx^26]
//│ 	[xx^26 · xx^18]
//│ 		[xx^26 · xx^18 · xx^18]
//│ 			[xx^26 · xx^18 · xx^18 · xx^18]
//│ 				[xx^26 · xx^18 · xx^18 · xx^18 · xx^18] ---> [xx^26 · xx^18] (only one)
//│ [yy^28]
//│ 	[yy^28 · yy^21]
//│ 		[yy^28 · yy^21 · yy^21] ---> [yy^28] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((f₀ xx₀) yy₀)
//│ def f₀ = 
//│ 	(fun xs³ -> case xs³ of {
//│ 		X x1³ => case x1³ of {
//│ 			X x2³ => case x2³ of {
//│ 				X x3³ => (fun ys³ -> case ys³ of {
//│ 					Y y1³ => case y1³ of {
//│ 						Y y2³ => ((f₁ x3³) y2³)}})}}})
//│ 	where
//│ 	def f₁ = 
//│ 		(fun xs² -> case xs² of {
//│ 			X x1² => case x1² of {
//│ 				X x2² => case x2² of {
//│ 					X x3² => (fun ys² -> case ys² of {
//│ 						Y y1² => case y1² of {
//│ 							Y y2² => ((f₂ x3²) y2²)}})}}})
//│ 		where
//│ 		def f₂ = 
//│ 			(fun xs¹ -> case xs¹ of {
//│ 				X x1¹ => case x1¹ of {
//│ 					X x2¹ => case x2¹ of {
//│ 						X x3¹ => (fun ys¹ -> case ys¹ of {
//│ 							Y y1¹ => case y1¹ of {
//│ 								Y y2¹ => ((f₁ x3¹) y2¹)}})}}})
//│ def xx₀ = 
//│ 	[X [X xx₁]]
//│ 	where
//│ 	def xx₁ = 
//│ 		[X [X xx₂]]
//│ 		where
//│ 		def xx₂ = 
//│ 			[X [X xx₃]]
//│ 			where
//│ 			def xx₃ = 
//│ 				[X [X xx₁]]
//│ def yy₀ = 
//│ 	[Y [Y [Y yy₁]]]
//│ 	where
//│ 	def yy₁ = 
//│ 		[Y [Y [Y yy₀]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [X [X xx₁]] --->
//│ 	case xs¹ of {X x1¹ => case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}})}}}
//│ [X [X xx₁]] --->
//│ 	case xs³ of {X x1³ => case x1³ of {X x2³ => case x2³ of {X x3³ => (fun ys³ -> case ys³ of {Y y1³ => case y1³ of {Y y2³ => ((f₁ x3³) y2³)}})}}}
//│ [X [X xx₂]] --->
//│ 	case x2³ of {X x3³ => (fun ys³ -> case ys³ of {Y y1³ => case y1³ of {Y y2³ => ((f₁ x3³) y2³)}})}
//│ 	case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}})}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [X [X xx₃]] --->
//│ 	case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}})}}
//│ [X xx₁] --->
//│ 	case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}})}}
//│ [X xx₁] --->
//│ 	case x1³ of {X x2³ => case x2³ of {X x3³ => (fun ys³ -> case ys³ of {Y y1³ => case y1³ of {Y y2³ => ((f₁ x3³) y2³)}})}}
//│ [X xx₂] --->
//│ 	case xs² of {X x1² => case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}})}}}
//│ [X xx₃] --->
//│ 	case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}})}
//│ [Y [Y [Y yy₀]]] --->
//│ 	case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}
//│ 	case y1² of {Y y2² => ((f₂ x3²) y2²)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [Y [Y [Y yy₁]]] --->
//│ 	case ys³ of {Y y1³ => case y1³ of {Y y2³ => ((f₁ x3³) y2³)}}
//│ 	case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}}
//│ 	case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [Y [Y yy₀]] --->
//│ 	case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}}
//│ 	case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [Y [Y yy₁]] --->
//│ 	case y1³ of {Y y2³ => ((f₁ x3³) y2³)}
//│ 	case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}
//│ 	case y1² of {Y y2² => ((f₂ x3²) y2²)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [Y yy₀] --->
//│ 	case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}
//│ 	case y1² of {Y y2² => ((f₂ x3²) y2²)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [Y yy₁] --->
//│ 	case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => ((f₁ x3¹) y2¹)}}
//│ 	case ys² of {Y y1² => case y1² of {Y y2² => ((f₂ x3²) y2²)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((f₀ xx₀) yy₀)
//│ def f₀ = 
//│ 	(fun xs³ -> xs³)
//│ 	where
//│ 	def f₁ = 
//│ 		(fun xs² -> xs²)
//│ 		where
//│ 		def f₂ = 
//│ 			(fun xs¹ -> xs¹)
//│ def xx₀ = 
//│ 	let x1³ = 	
//│ 		let x2³ = xx₁
//│ 		in x2³
//│ 	in x1³
//│ 	where
//│ 	def xx₁ = 
//│ 		let x3³ = 	
//│ 			let x1² = xx₂
//│ 			in x1²
//│ 		in (fun ys³ -> ys³)
//│ 		where
//│ 		def xx₂ = 
//│ 			let x2² = 	
//│ 				let x3² = xx₃
//│ 				in (fun ys² -> ys²)
//│ 			in x2²
//│ 			where
//│ 			def xx₃ = 
//│ 				let x1¹ = 	
//│ 					let x2¹ = xx₁
//│ 					in case x2¹ of {
//│ 						X x3¹ => (fun ys¹ -> ys¹)}
//│ 				in x1¹
//│ def yy₀ = 
//│ 	let y1³ = 	
//│ 		let y2³ = 	
//│ 			let y1² = yy₁
//│ 			in y1²
//│ 		in ((f₁ x3³) y2³)
//│ 	in y1³
//│ 	where
//│ 	def yy₁ = 
//│ 		let y2² = 	
//│ 			let y1¹ = 	
//│ 				let y2¹ = yy₀
//│ 				in ((f₁ x3¹) y2¹)
//│ 			in y1¹
//│ 		in ((f₂ x3²) y2²)
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: binding not found: Ident(false,x3,3)
//│ !!!!!!ERROR!!!!!!



// WRONG: still have binding error
_LUMBERHACK_ERROR
fun f(x) = if x is
  C(k) then f(x)
f(C(primitive))
//│ |_LUMBERHACK_ERROR|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|k|)| |#then| |f|(|x|)|←|↵|f|(|C|(|primitive|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun f = x, => if x is ‹(C (k,)) then f (x,)›; f (C (primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^7 [C primitive⁰])
//│ def f = (fun x⁰ -> case x⁰ of {
//│ 	C k⁰ => (f^2 x⁰)})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^7] (hopeless to continue)
//│ 	[f^7 · f^2] ---> [f^7] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ [C primitive⁰])
//│ def f₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C k¹ => (f₀ x¹)})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰] --->
//│ 	case x¹ of {C k¹ => (f₀ x¹)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ 
//│ 	let k¹ = primitive⁰
//│ 	in (f₀ x¹))
//│ def f₀ = 
//│ 	(fun x¹ -> x¹)
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: binding not found: Ident(false,x,1)
//│ !!!!!!ERROR!!!!!!


// WRONG: recursive strategy
_LUMBERHACK_ERROR
fun f(x) = if x is
  C(k) then f(C(x))
f(C(primitive))
//│ |_LUMBERHACK_ERROR|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|k|)| |#then| |f|(|C|(|x|)|)|←|↵|f|(|C|(|primitive|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun f = x, => if x is ‹(C (k,)) then f (C (x,),)›; f (C (primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^8 [C primitive⁰])
//│ def f = (fun x⁰ -> case x⁰ of {
//│ 	C k⁰ => (f^2 [C x⁰])})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^8] (hopeless to continue)
//│ 	[f^8 · f^2] ---> [f^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ [C primitive⁰])
//│ def f₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C k¹ => (f₀ [C x¹])})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰] --->
//│ 	case x¹ of {C k¹ => (f₀ [C x¹])}
//│ [C x¹] --->
//│ 	case x¹ of {C k¹ => (f₀ [C x¹])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!


// WRONG: branching, but no recursive strategy stackoverflow problem
// because the infinite rewriting cannot be started by `primitive`
fun f(x) = if x is
  N then f(N)
  _ then 0
f(primitive)
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |f|(|N|)|↵|_| |#then| |0|←|↵|f|(|primitive|)|
//│ Parsed: {fun f = x, => if x is ‹(N) then f (N,); (_) then 0›; f (primitive,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^8 primitive⁰)
//│ def f = (fun x⁰ -> case x⁰ of {
//│ 	N => (f^2 [N])
//│ 	| _ => 0})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^8] (hopeless to continue)
//│ 	[f^8 · f^2] ---> [f^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ primitive⁰)
//│ def f₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		N => (f₀ [N])
//│ 		| _ => 0})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N] --->
//│ 	case x¹ of {N => (f₀ [N]) | _ => 0}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ primitive⁰)
//│ def f₀ = 
//│ 	(fun x¹ -> x¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ primitive⁰
//│ <<<<<<< evaluate <<<<<<<

// WRONG: mutual recursive strategy
_LUMBERHACK_ERROR
fun f(x) = if x is
    C(a) then f(C(a))
fun g(y) = if y is
    D(b) then f(C(b))
f(C(A))
//│ |_LUMBERHACK_ERROR|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |f|(|C|(|a|)|)|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|D|(|b|)| |#then| |f|(|C|(|b|)|)|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun f = x, => if x is ‹(C (a,)) then f (C (a,),)›; fun g = y, => if y is ‹(D (b,)) then f (C (b,),)›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^15 [C [A]])
//│ def f = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => (f^2 [C a⁰])})
//│ def g = (fun y⁰ -> case y⁰ of {
//│ 	D b⁰ => (f^9 [C b⁰])})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^15] (hopeless to continue)
//│ 	[f^15 · f^2] ---> [f^15] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ [C [A]])
//│ def f₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C a¹ => (f₀ [C a¹])})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]] --->
//│ 	case x¹ of {C a¹ => (f₀ [C a¹])}
//│ [C a¹] --->
//│ 	case x¹ of {C a¹ => (f₀ [C a¹])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!
