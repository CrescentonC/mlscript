:NewParser
:ParseOnly


// NOTE: the `p` inside `C(p)` is untouched
// TODO don't rewrite dead code
let p = C(p)
fun c(x) = if C(x) is
    C(a) then a
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |a|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then a›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^8 p^9)
//│ def c = (fun x:8 -> case [C x:8] of {
//│ 	C a:9 => a:9})
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^8] ---> [c^8] (hopeless to continue)
//│ [p^9] ---> [p^9] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x:8] --->
//│ 	case [C x:8] of {C a:9 => a:9}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c p)
//│ def c = (fun x:8 -> 
//│ 	let a:9 = x:8
//│ 	in a:9)
//│ def p = [C p]
//│ <<<<<<< after fusion <<<<<<<


// NOTE: how to produce a finite rewrtten program?
_LUMBERHACK_ERROR
let p = Pair(A, B)
fun c(x) = if x is
    Pair(a, b) then c(Pair(b, a))
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^12 p^13)
//│ def c = (fun x:8 -> case x:8 of {
//│ 	Pair a:9 b:10 => (c^5 [Pair b:10 a:9])})
//│ def p = [Pair [A] [B]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^12] ---> [c^12] (hopeless to continue)
//│ [p^13] ---> [p^13] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Pair b:10 a:9] --->
//│ 	case x:8 of {Pair a:9 b:10 => (c [Pair b:10 a:9])}
//│ [Pair [A] [B]] --->
//│ 	case x:8 of {Pair a:9 b:10 => (c [Pair b:10 a:9])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!

// Just a more valid/reasonable version of the above
// TODO get a recursive knot even when using `primitive` (we get it without)
_LUMBERHACK_ERROR
let p = Wrap(3)
fun c(x) = if x is
    N then 0
    Wrap(a) then c(Wrap(primitive(a)))
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Wrap|(|3|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |0|↵|Wrap|(|a|)| |#then| |c|(|Wrap|(|primitive|(|a|)|)|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Wrap (3,); fun c = x, => if x is ‹(N) then 0; (Wrap (a,)) then c (Wrap (primitive (a,),),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^13 p^14)
//│ def c = (fun x:8 -> case x:8 of {
//│ 	N => 0
//│ 	| Wrap a:9 => (c^5 [Wrap (primitive:3 a:9)])})
//│ def p = [Wrap 3]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^13] ---> [c^13] (hopeless to continue)
//│ [p^14] ---> [p^14] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Wrap (primitive:3 a:9)] --->
//│ 	case x:8 of {N => 0 | Wrap a:9 => (c [Wrap (primitive:3 a:9)])}
//│ [Wrap 3] --->
//│ 	case x:8 of {N => 0 | Wrap a:9 => (c [Wrap (primitive:3 a:9)])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!

fun c(x) = if primitive(x) is
    True then 0
    False then c(primitive(x))
c(0)
//│ |#fun| |c|(|x|)| |#=| |#if| |primitive|(|x|)| |is|→|True| |#then| |0|↵|False| |#then| |c|(|primitive|(|x|)|)|←|↵|c|(|0|)|
//│ Parsed: {fun c = x, => if primitive (x,) is ‹(True) then 0; (False) then c (primitive (x,),)›; c (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^12 0)
//│ def c = (fun x:7 -> case (primitive:3 x:7) of {
//│ 	True => 0
//│ 	| False => (c^5 (primitive:3 x:7))})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^12] ---> [c^12] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c 0)
//│ def c = (fun x:7 -> case (primitive:3 x:7) of {
//│ 	True => 0
//│ 	| False => (c (primitive:3 x:7))})
//│ <<<<<<< after fusion <<<<<<<


// NOTE: only the first two element is handled
_LUMBERHACK_ERROR
fun map(f, ls) = if ls is
    C(h, t) then C(f(h), map(f, t))
    N then N
fun ff(x) = if x is
    K then T
    KK then TT
    KKKK then TTTT
let l = C(K, C(KK, C(KKKK, N)))
map(ff, l)
//│ |_LUMBERHACK_ERROR|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|ff|,| |l|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; let l = C (K, C (KK, C (KKKK, N,),),); map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((map^28 ff^29) l^31)
//│ def ff = (fun x:13 -> case x:13 of {
//│ 	K => [T]
//│ 	| KK => [TT]
//│ 	| KKKK => [TTTT]})
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun f:9 -> (fun ls:10 -> case ls:10 of {
//│ 	C h:11 t:12 => [C (f:9 h:11) ((map^5 f:9) t:12)]
//│ 	| N => [N]}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 't:12
//│ 	[-l^31 · +map^28 · +map^5 · +map^5 · +map^5 · +map^5]  --->  [-l^31 · +map^28 · +map^5 · +map^5 · +map^5]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^29] ---> [ff^29] (hopeless to continue)
//│ [l^31]
//│ [map^28]
//│ 	[map^28 · map^5]
//│ 		[map^28 · map^5 · map^5]
//│ 			[map^28 · map^5 · map^5 · map^5]
//│ 				[map^28 · map^5 · map^5 · map^5 · map^5] ---> [map^28 · map^5 · map^5 · map^5] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K] --->
//│ 	case x:13 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ [KK] --->
//│ 	case x:13 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ [KKKK] --->
//│ 	case x:13 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ [N] --->
//│ 	case ls:20 of {C h:21 t:22 => [C (f:19 h:21) ((map^28_map^5_map^5_map^5 f:19) t:22)] | N => [N]}
//│ [C [KKKK] [N]] --->
//│ 	case ls:24 of {C h:25 t:26 => [C (f:23 h:25) ((map^28_map^5_map^5_map^5 f:23) t:26)] | N => [N]}
//│ [C [KK] [C [KKKK] [N]]] --->
//│ 	case ls:32 of {C h:33 t:34 => [C (f:31 h:33) ((map^28_map^5_map^5 f:31) t:34)] | N => [N]}
//│ [C [K] [C [KK] [C [KKKK] [N]]]] --->
//│ 	case ls:28 of {C h:29 t:30 => [C (f:27 h:29) ((map^28_map^5 f:27) t:30)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((map^28 ff) l^31)
//│ def ff = (fun x:13 -> x:13)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def l^31 = 
//│ 	let h:29 = [T]
//│ 	in let t:30 = 	
//│ 		let h:33 = [TT]
//│ 		in let t:34 = 	
//│ 			let h:25 = [TTTT]
//│ 			in let t:26 = [N]
//│ 			in [C (f:23 h:25) ((map^28_map^5_map^5_map^5 f:23) t:26)]
//│ 		in [C (f:31 h:33) ((map^28_map^5_map^5 f:31) t:34)]
//│ 	in [C (f:27 h:29) ((map^28_map^5 f:27) t:30)]
//│ def map = (fun f:9 -> (fun ls:10 -> case ls:10 of {
//│ 	C h:11 t:12 => [C (f:9 h:11) ((map f:9) t:12)]
//│ 	| N => [N]}))
//│ def map^28 = (fun f:27 -> (fun ls:28 -> ls:28))
//│ def map^28_map^5 = (fun f:31 -> (fun ls:32 -> ls:32))
//│ def map^28_map^5_map^5 = (fun f:23 -> (fun ls:24 -> ls:24))
//│ def map^28_map^5_map^5_map^5 = (fun f:19 -> (fun ls:20 -> ls:20))
//│ <<<<<<< after fusion <<<<<<<


// NOTE: some program not be able to write?
_LUMBERHACK_ERROR
fun last(ls) = if ls is
    C(h, t) then if t is
        N then Some(h)
        C(hh, tt) then last(t)
        // C(hh, tt) then last(C(hh, tt))
    N then None
let p = C(1, C(2, N))
last(p)
//│ |_LUMBERHACK_ERROR|↵|#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |last|(|t|)|↵|/* C(hh, tt) then last(C(hh, tt))*/|←|↵|N| |#then| |None|←|↵|#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|last|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun last = ls, => if ls is ‹(C (h, t,)) then if t is ‹(N) then Some (h,); (C (hh, tt,)) then last (t,)›; (N) then None›; let p = C (1, C (2, N,),); last (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (last^17 p^18)
//│ def last = (fun ls:8 -> case ls:8 of {
//│ 	C h:9 t:10 => case t:10 of {
//│ 		N => [Some h:9]
//│ 		| C hh:11 tt:12 => (last^5 t:10)}
//│ 	| N => [None]})
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 't:10
//│ 	[-p^18 · +last^17 · +last^5 · +last^5 · +last^5]  --->  [-p^18 · +last^17 · +last^5 · +last^5]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^17]
//│ 	[last^17 · last^5]
//│ 		[last^17 · last^5 · last^5]
//│ 			[last^17 · last^5 · last^5 · last^5] ---> [last^17 · last^5 · last^5] (only one)
//│ [p^18]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N] --->
//│ 	case ls:27 of {C h:28 t:29 => case t:29 of {N => [Some h:28] | C hh:30 tt:31 => (last^17_last^5_last^5 t:29)} | N => [None]}
//│ 	case t:19 of {N => [Some h:18] | C hh:20 tt:21 => (last^17_last^5_last^5 t:19)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C 2 [N]] --->
//│ 	case ls:17 of {C h:18 t:19 => case t:19 of {N => [Some h:18] | C hh:20 tt:21 => (last^17_last^5_last^5 t:19)} | N => [None]}
//│ 	case t:24 of {N => [Some h:23] | C hh:25 tt:26 => (last^17_last^5 t:24)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C 1 [C 2 [N]]] --->
//│ 	case ls:22 of {C h:23 t:24 => case t:24 of {N => [Some h:23] | C hh:25 tt:26 => (last^17_last^5 t:24)} | N => [None]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (last^17 p^18)
//│ def last = (fun ls:8 -> case ls:8 of {
//│ 	C h:9 t:10 => case t:10 of {
//│ 		N => [Some h:9]
//│ 		| C hh:11 tt:12 => (last t:10)}
//│ 	| N => [None]})
//│ def last^17 = (fun ls:22 -> ls:22)
//│ def last^17_last^5 = (fun ls:17 -> ls:17)
//│ def last^17_last^5_last^5 = (fun ls:27 -> ls:27)
//│ def p = [C 1 [C 2 [N]]]
//│ def p^18 = 
//│ 	let h:23 = 1
//│ 	in let t:24 = 	
//│ 		let h:18 = 2
//│ 		in let t:19 = [None]
//│ 		in case t:19 of {
//│ 			N => [Some h:18]
//│ 			| C hh:20 tt:21 => (last^17_last^5_last^5 t:19)}
//│ 	in case t:24 of {
//│ 		N => [Some h:23]
//│ 		| C hh:25 tt:26 => (last^17_last^5 t:24)}
//│ <<<<<<< after fusion <<<<<<<

_LUMBERHACK_ERROR
let add = primitive
fun idxSum(ls) = if ls is
    N then acc => 0
    C(h, t) then acc => add(acc, idxSum(t)(add(acc, 1)))
fun rev(lss, a) = if lss is
    N then a
    C(hh, tt) then rev(tt, C(hh, a))
idxSum(rev(primitive, N))(0)
//│ |_LUMBERHACK_ERROR|↵|#let| |add| |#=| |primitive|↵|#fun| |idxSum|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc| |=>| |0|↵|C|(|h|,| |t|)| |#then| |acc| |=>| |add|(|acc|,| |idxSum|(|t|)|(|add|(|acc|,| |1|)|)|)|←|↵|#fun| |rev|(|lss|,| |a|)| |#=| |#if| |lss| |is|→|N| |#then| |a|↵|C|(|hh|,| |tt|)| |#then| |rev|(|tt|,| |C|(|hh|,| |a|)|)|←|↵|idxSum|(|rev|(|primitive|,| |N|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_ERROR; let add = primitive; fun idxSum = ls, => if ls is ‹(N) then acc, => 0; (C (h, t,)) then acc, => add (acc, idxSum (t,) (add (acc, 1,),),)›; fun rev = lss, a, => if lss is ‹(N) then a; (C (hh, tt,)) then rev (tt, C (hh, a,),)›; idxSum (rev (primitive, N,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((idxSum^33 ((rev^34 primitive:3) [N])) 0)
//│ def add = primitive:3
//│ def idxSum = (fun ls:9 -> case ls:9 of {
//│ 	N => (fun acc:10 -> 0)
//│ 	| C h:11 t:12 => (fun acc:13 -> ((add:4 acc:13) ((idxSum^8 t:12) ((add:4 acc:13) 1))))})
//│ def rev = (fun lss:14 -> (fun a:15 -> case lss:14 of {
//│ 	N => a:15
//│ 	| C hh:16 tt:17 => ((rev^23 tt:17) [C hh:16 a:15])}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('hh:16, 'a:15) <: 'ls:9
//│ 	[+rev^23 · +rev^23 · +rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]  --->  [+rev^23 · +rev^23 · -rev^34 · +idxSum^33 · +idxSum^8]
//│ 	[+rev^23 · +rev^23 · +rev^23 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]  --->  [+rev^23 · +rev^23 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8]
//│ NoProd <: 'lss:14
//│ 	[+rev^34 · +rev^23 · +rev^23]  --->  [+rev^34 · +rev^23]
//│ NoProd <: 'ls:9
//│ 	[+rev^34 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]  --->  [+rev^34 · -rev^34 · +idxSum^33 · +idxSum^8]
//│ 	[+rev^34 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]  --->  [+rev^34 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8]
//│ NoProd <: 't:12
//│ 	[+rev^34 · +rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]  --->  [+rev^34 · +rev^23 · -rev^34 · +idxSum^33 · +idxSum^8]
//│ 	[+rev^34 · +rev^23 · +rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8 · +idxSum^8]  --->  [+rev^34 · +rev^23 · +rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]
//│ 	[+rev^34 · +rev^23 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]  --->  [+rev^34 · +rev^23 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8]
//│ 	[+rev^34 · +rev^23 · +rev^23 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8 · +idxSum^8]  --->  [+rev^34 · +rev^23 · +rev^23 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [idxSum^33]
//│ 	[idxSum^33 · idxSum^8]
//│ 		[idxSum^33 · idxSum^8 · idxSum^8] ---> [idxSum^33 · idxSum^8] (only one)
//│ [rev^34]
//│ 	[rev^34 · rev^23]
//│ 		[rev^34 · rev^23 · rev^23] ---> [rev^34 · rev^23] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N] --->
//│ 	case ls:26 of {N => (fun acc:27 -> 0) | C h:28 t:29 => (fun acc:30 -> ((add:4 acc:30) ((idxSum^33_idxSum^8 t:29) ((add:4 acc:30) 1))))}
//│ 	case ls:31 of {N => (fun acc:32 -> 0) | C h:33 t:34 => (fun acc:35 -> ((add:4 acc:35) ((idxSum^33_idxSum^8 t:34) ((add:4 acc:35) 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C hh:24 a:23] --->
//│ 	case ls:26 of {N => (fun acc:27 -> 0) | C h:28 t:29 => (fun acc:30 -> ((add:4 acc:30) ((idxSum^33_idxSum^8 t:29) ((add:4 acc:30) 1))))}
//│ 	case ls:31 of {N => (fun acc:32 -> 0) | C h:33 t:34 => (fun acc:35 -> ((add:4 acc:35) ((idxSum^33_idxSum^8 t:34) ((add:4 acc:35) 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C hh:38 a:37] --->
//│ 	case ls:26 of {N => (fun acc:27 -> 0) | C h:28 t:29 => (fun acc:30 -> ((add:4 acc:30) ((idxSum^33_idxSum^8 t:29) ((add:4 acc:30) 1))))}
//│ 	case ls:31 of {N => (fun acc:32 -> 0) | C h:33 t:34 => (fun acc:35 -> ((add:4 acc:35) ((idxSum^33_idxSum^8 t:34) ((add:4 acc:35) 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((idxSum^33 ((rev^34 primitive:3) (fun acc:32 -> 0))) 0)
//│ def add = primitive:3
//│ def idxSum = (fun ls:9 -> case ls:9 of {
//│ 	N => (fun acc:10 -> 0)
//│ 	| C h:11 t:12 => (fun acc:13 -> ((add:4 acc:13) ((idxSum t:12) ((add:4 acc:13) 1))))})
//│ def idxSum^33 = (fun ls:31 -> ls:31)
//│ def idxSum^33_idxSum^8 = (fun ls:26 -> case ls:26 of {
//│ 	N => (fun acc:27 -> 0)
//│ 	| C h:28 t:29 => (fun acc:30 -> ((add:4 acc:30) ((idxSum^33_idxSum^8 t:29) ((add:4 acc:30) 1))))})
//│ def rev = (fun lss:14 -> (fun a:15 -> case lss:14 of {
//│ 	N => a:15
//│ 	| C hh:16 tt:17 => ((rev tt:17) [C hh:16 a:15])}))
//│ def rev^34 = (fun lss:36 -> (fun a:37 -> case lss:36 of {
//│ 	N => a:37
//│ 	| C hh:38 tt:39 => ((rev^34_rev^23 tt:39) 
//│ 		let h:33 = hh:38
//│ 		in let t:34 = a:37
//│ 		in (fun acc:35 -> ((add:4 acc:35) ((idxSum^33_idxSum^8 t:34) ((add:4 acc:35) 1)))))}))
//│ def rev^34_rev^23 = (fun lss:22 -> (fun a:23 -> case lss:22 of {
//│ 	N => a:23
//│ 	| C hh:24 tt:25 => ((rev^34_rev^23 tt:25) 
//│ 		let h:33 = hh:24
//│ 		in let t:34 = a:23
//│ 		in (fun acc:35 -> ((add:4 acc:35) ((idxSum^33_idxSum^8 t:34) ((add:4 acc:35) 1)))))}))
//│ <<<<<<< after fusion <<<<<<<


fun minuss(a) = if a is
    S(aa) then b => if b is
        S(bb) then minuss(aa, bb)
        Z then aa
    Z then n => Z
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |#if| |b| |is|→|S|(|bb|)| |#then| |minuss|(|aa|,| |bb|)|↵|Z| |#then| |aa|←|↵|Z| |#then| |n| |=>| |Z|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {fun minuss = a, => if a is ‹(S (aa,)) then b, => if b is ‹(S (bb,)) then minuss (aa, bb,); (Z) then aa›; (Z) then n, => Z›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((minuss^19 fst^20) snd^22)
//│ def fst = [S [S [Z]]]
//│ def minuss = (fun a:9 -> case a:9 of {
//│ 	S aa:10 => (fun b:11 -> case b:11 of {
//│ 		S bb:12 => ((minuss^3 aa:10) bb:12)
//│ 		| Z => aa:10})
//│ 	| Z => (fun n:13 -> [Z])})
//│ def snd = [Z]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 'aa:10
//│ 	[-fst^20 · +minuss^19 · +minuss^3 · +minuss^3 · +minuss^3]  --->  [-fst^20 · +minuss^19 · +minuss^3 · +minuss^3]
//│ NoProd <: 'b:11
//│ 	[-snd^22 · +minuss^19 · +minuss^3 · +minuss^3]  --->  [-snd^22 · +minuss^19 · +minuss^3]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fst^20]
//│ [minuss^19]
//│ 	[minuss^19 · minuss^3]
//│ 		[minuss^19 · minuss^3 · minuss^3] ---> [minuss^19 · minuss^3] (only one)
//│ [snd^22]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Z] --->
//│ 	case b:20 of {S bb:21 => ((minuss^19_minuss^3 aa:19) bb:21) | Z => aa:19}
//│ [Z] --->
//│ 	case a:23 of {S aa:24 => (fun b:25 -> case b:25 of {S bb:26 => ((minuss^19_minuss^3 aa:24) bb:26) | Z => aa:24}) | Z => (fun n:27 -> [Z])}
//│ [S [Z]] --->
//│ 	case a:23 of {S aa:24 => (fun b:25 -> case b:25 of {S bb:26 => ((minuss^19_minuss^3 aa:24) bb:26) | Z => aa:24}) | Z => (fun n:27 -> [Z])}
//│ [S [S [Z]]] --->
//│ 	case a:18 of {S aa:19 => (fun b:20 -> case b:20 of {S bb:21 => ((minuss^19_minuss^3 aa:19) bb:21) | Z => aa:19}) | Z => (fun n:22 -> [Z])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((minuss^19 fst^20) snd^22)
//│ def fst = [S [S [Z]]]
//│ def fst^20 = 
//│ 	let aa:19 = 	
//│ 		let aa:24 = (fun n:27 -> [Z])
//│ 		in (fun b:25 -> case b:25 of {
//│ 			S bb:26 => ((minuss^19_minuss^3 aa:24) bb:26)
//│ 			| Z => aa:24})
//│ 	in (fun b:20 -> b:20)
//│ def minuss = (fun a:9 -> case a:9 of {
//│ 	S aa:10 => (fun b:11 -> case b:11 of {
//│ 		S bb:12 => ((minuss aa:10) bb:12)
//│ 		| Z => aa:10})
//│ 	| Z => (fun n:13 -> [Z])})
//│ def minuss^19 = (fun a:18 -> a:18)
//│ def minuss^19_minuss^3 = (fun a:23 -> a:23)
//│ def snd = [Z]
//│ def snd^22 = aa:19
//│ <<<<<<< after fusion <<<<<<<

// FIXME: weird recursive
_LUMBERHACK_ERROR
fun minuss(a) = if a is
    S(aa) then b => checkb(b)(aa)
    Z then n => Z
fun checkb(b) = if b is
    S(bb) then aaa => minuss(aaa, bb)
    Z then aaa => aaa
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |_LUMBERHACK_ERROR|↵|#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |checkb|(|b|)|(|aa|)|↵|Z| |#then| |n| |=>| |Z|←|↵|#fun| |checkb|(|b|)| |#=| |#if| |b| |is|→|S|(|bb|)| |#then| |aaa| |=>| |minuss|(|aaa|,| |bb|)|↵|Z| |#then| |aaa| |=>| |aaa|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun minuss = a, => if a is ‹(S (aa,)) then b, => checkb (b,) (aa,); (Z) then n, => Z›; fun checkb = b, => if b is ‹(S (bb,)) then aaa, => minuss (aaa, bb,); (Z) then aaa, => aaa›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((minuss^27 fst^28) snd^30)
//│ def checkb = (fun b:14 -> case b:14 of {
//│ 	S bb:15 => (fun aaa:16 -> ((minuss^13 aaa:16) bb:15))
//│ 	| Z => (fun aaa:17 -> aaa:17)})
//│ def fst = [S [S [Z]]]
//│ def minuss = (fun a:10 -> case a:10 of {
//│ 	S aa:11 => (fun b:12 -> ((checkb^2 b:12) aa:11))
//│ 	| Z => (fun n:13 -> [Z])})
//│ def snd = [Z]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 'bb:15
//│ 	[-snd^30 · +minuss^27 · +checkb^2 · +minuss^13 · +checkb^2]  --->  [-snd^30 · +minuss^27 · +checkb^2]
//│ NoProd <: 'aa:11
//│ 	[-fst^28 · +minuss^27 · +checkb^2 · +minuss^13 · +checkb^2 · +minuss^13 · +checkb^2 · +minuss^13]  --->  [-fst^28 · +minuss^27 · +checkb^2 · +minuss^13 · +checkb^2 · +minuss^13]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fst^28]
//│ [minuss^27]
//│ 	[minuss^27 · checkb^2]
//│ 		[minuss^27 · checkb^2 · minuss^13]
//│ 			[minuss^27 · checkb^2 · minuss^13 · checkb^2] ---> [minuss^27 · checkb^2] (only one)
//│ [snd^30]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Z] --->
//│ 	case a:27 of {S aa:28 => (fun b:29 -> ((minuss^27_checkb^2 b:29) aa:28)) | Z => (fun n:30 -> [Z])}
//│ [S [Z]] --->
//│ 	case a:27 of {S aa:28 => (fun b:29 -> ((minuss^27_checkb^2 b:29) aa:28)) | Z => (fun n:30 -> [Z])}
//│ [S [S [Z]]] --->
//│ 	case a:31 of {S aa:32 => (fun b:33 -> ((minuss^27_checkb^2 b:33) aa:32)) | Z => (fun n:34 -> [Z])}
//│ [Z] --->
//│ 	case b:23 of {S bb:24 => (fun aaa:25 -> ((minuss^27_checkb^2_minuss^13 aaa:25) bb:24)) | Z => (fun aaa:26 -> aaa:26)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((minuss^27 fst^28) snd^30)
//│ def checkb = (fun b:14 -> case b:14 of {
//│ 	S bb:15 => (fun aaa:16 -> ((minuss aaa:16) bb:15))
//│ 	| Z => (fun aaa:17 -> aaa:17)})
//│ def fst = [S [S [Z]]]
//│ def fst^28 = 
//│ 	let aa:32 = 	
//│ 		let aa:28 = (fun n:30 -> [Z])
//│ 		in (fun b:29 -> ((minuss^27_checkb^2 b:29) aa:28))
//│ 	in (fun b:33 -> ((minuss^27_checkb^2 b:33) aa:32))
//│ def minuss = (fun a:10 -> case a:10 of {
//│ 	S aa:11 => (fun b:12 -> ((checkb b:12) aa:11))
//│ 	| Z => (fun n:13 -> [Z])})
//│ def minuss^27 = (fun a:31 -> a:31)
//│ def minuss^27_checkb^2 = (fun b:23 -> b:23)
//│ def minuss^27_checkb^2_minuss^13 = (fun a:27 -> a:27)
//│ def snd = [Z]
//│ def snd^30 = (fun aaa:26 -> aaa:26)
//│ <<<<<<< after fusion <<<<<<<


fun id(x) = if x is
    ID(b) then b
    C(a) then id(ID(C(a)))
let p = C(p)
fun c(y) = if y is
    C(aa) then c(aa)
c(id(p))
//│ |#fun| |id|(|x|)| |#=| |#if| |x| |is|→|ID|(|b|)| |#then| |b|↵|C|(|a|)| |#then| |id|(|ID|(|C|(|a|)|)|)|←|↵|#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |c|(|aa|)|←|↵|c|(|id|(|p|)|)|
//│ Parsed: {fun id = x, => if x is ‹(ID (b,)) then b; (C (a,)) then id (ID (C (a,),),)›; let p = C (p,); fun c = y, => if y is ‹(C (aa,)) then c (aa,)›; c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^18 (id^19 p^20))
//│ def c = (fun y:12 -> case y:12 of {
//│ 	C aa:13 => (c^13 aa:13)})
//│ def id = (fun x:9 -> case x:9 of {
//│ 	ID b:10 => b:10
//│ 	| C a:11 => (id^3 [ID [C a:11]])})
//│ def p = [C p^10]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('p:7) <: 'aa:13
//│ 	[-p^10 · -p^10 · -p^20 · +id^19 · +id^3 · -id^19 · +c^18 · +c^13]  --->  [-p^10 · -p^20 · +id^19 · +id^3 · -id^19 · +c^18]
//│ 	[-p^10 · -p^10 · -p^20 · +id^19 · +id^3 · -id^3 · -id^19 · +c^18 · +c^13]  --->  [-p^10 · -p^20 · +id^19 · +id^3 · -id^3 · -id^19 · +c^18]
//│ NoProd <: 'y:12
//│ 	[-p^20 · +id^19 · -id^19 · +c^18 · +c^13]  --->  [-p^20 · +id^19 · -id^19 · +c^18]
//│ 	[-p^20 · +id^19 · -id^3 · -id^19 · +c^18 · +c^13]  --->  [-p^20 · +id^19 · -id^3 · -id^19 · +c^18]
//│ NoProd <: 'aa:13
//│ 	[+id^3 · +id^3 · -id^19 · +c^18 · +c^13]  --->  [+id^3 · +id^3 · -id^19 · +c^18]
//│ 	[+id^3 · +id^3 · -id^3 · -id^19 · +c^18 · +c^13]  --->  [+id^3 · +id^3 · -id^3 · -id^19 · +c^18]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^18]
//│ 	[c^18 · c^13] ---> [c^18] (only one)
//│ [id^19]
//│ 	[id^19 · id^3] ---> [id^3] (hopeless to continue)
//│ [p^20]
//│ 	[p^20 · p^10]
//│ 		[p^20 · p^10 · p^10] ---> [p^20 · p^10] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a:11] --->
//│ 	case y:21 of {C aa:22 => (c^18 aa:22)}
//│ [ID [C a:11]] --->
//│ 	case x:9 of {ID b:10 => b:10 | C a:11 => (id [ID [C a:11]])}
//│ [C p^20_p^10] --->
//│ 	case x:18 of {ID b:19 => b:19 | C a:20 => (id [ID [C a:20]])}
//│ [C p^20_p^10] --->
//│ 	case y:21 of {C aa:22 => (c^18 aa:22)}
//│ [C a:20] --->
//│ 	case y:21 of {C aa:22 => (c^18 aa:22)}
//│ [ID [C a:20]] --->
//│ 	case x:9 of {ID b:10 => b:10 | C a:11 => (id [ID [C a:11]])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c^18 (id^19 p^20))
//│ def c = (fun y:12 -> case y:12 of {
//│ 	C aa:13 => (c aa:13)})
//│ def c^18 = (fun y:21 -> y:21)
//│ def id = (fun x:9 -> x:9)
//│ def id^19 = (fun x:18 -> x:18)
//│ def p = [C p]
//│ def p^20 = 
//│ 	let a:20 = p^20_p^10
//│ 	in (id 
//│ 		let b:10 = 	
//│ 			let aa:22 = a:20
//│ 			in (c^18 aa:22)
//│ 		in b:10)
//│ def p^20_p^10 = 
//│ 	let aa:22 = p^20_p^10
//│ 	in (c^18 aa:22)
//│ <<<<<<< after fusion <<<<<<<
