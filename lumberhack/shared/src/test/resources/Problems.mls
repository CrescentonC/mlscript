:NewParser
:ParseOnly


// WRONG: infinite rewrting how to produce a finite rewrtten program?
let p = Pair(A, B)
fun c(x) = if x is
  Pair(a, b) then c(Pair(b, a))
c(p)
//│ |#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^12(p^13)
//│ def c(x⁰) = case x⁰ of {
//│ 	Pair a⁰ b⁰ => c^5([Pair b⁰ a⁰])}
//│ def p = [Pair [A] [B]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^12]
//│ 	[c^12 · c^5]
//│ 		[c^12 · c^5 · c^5] ---> [c^12] (only one)
//│ [p^13] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		Pair a¹ b¹ => c_₁([Pair b¹ a¹])}
//│ 	where
//│ 	def c_₁(x²) = 
//│ 		case x² of {
//│ 			Pair a² b² => c_₀([Pair b² a²])}
//│ def p_₀ = 
//│ 	[Pair [A] [B]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Pair b¹ a¹]: 19 --->
//│ 	case x² of {Pair a² b² => c_₀([Pair b² a²])}: 29
//│ [Pair b² a²]: 27 --->
//│ 	case x¹ of {Pair a¹ b¹ => c_₁([Pair b¹ a¹])}: 21
//│ [Pair [A] [B]]: 33 --->
//│ 	case x¹ of {Pair a¹ b¹ => c_₁([Pair b¹ a¹])}: 21
//│ ------------------
//│ case x¹ of {Pair a¹ b¹ => c_₁([Pair b¹ a¹])}: 21 --->
//│ 	[Pair b² a²]: 27
//│ 	[Pair [A] [B]]: 33
//│ case x² of {Pair a² b² => c_₀([Pair b² a²])}: 29 --->
//│ 	[Pair b¹ a¹]: 19
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x³) = 
//│ 	case x³ of {
//│ 		Pair a¹ b¹ => c_₁([Pair b¹ a¹])}
//│ 	where
//│ 	def c_₁(x⁴) = 
//│ 		case x⁴ of {
//│ 			Pair a² b² => c_₀([Pair b² a²])}
//│ def p_₀ = 
//│ 	[Pair [A] [B]]
//│ <<<<<<< after fusion <<<<<<<

// Just a more valid/reasonable version of the above
// WRONG: recursive strategy
let p = Wrap(3)
fun c(x) = if x is
  Wrap(a) then if a > 0 then c(Wrap(a - 1)) else Wrap(0)
c(p)
//│ |#let| |p| |#=| |Wrap|(|3|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Wrap|(|a|)| |#then| |#if| |a| |>| |0| |#then| |c|(|Wrap|(|a| |-| |1|)|)| |#else| |Wrap|(|0|)|←|↵|c|(|p|)|
//│ Parsed: {let p = Wrap (3,); fun c = x, => if x is ‹(Wrap (a,)) then if (> (a,) (0,)) then c (Wrap (- (a,) (1,),),) else Wrap (0,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^22(p^23)
//│ def c(x⁰) = case x⁰ of {
//│ 	Wrap a⁰ => if (a⁰ > 0) then c^9([Wrap (a⁰ - 1)]) else [Wrap 0]}
//│ def p = [Wrap 3]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^22] (hopeless to continue)
//│ 	[c^22 · c^9] ---> [c^22] (using original def)
//│ [p^23] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		Wrap a¹ => if (a¹ > 0) then c_₀([Wrap (a¹ - 1)]) else [Wrap 0]}
//│ def p_₀ = 
//│ 	[Wrap 3]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Wrap 3]: 26 --->
//│ 	case x¹ of {Wrap a¹ => if (a¹ > 0) then c_₀([Wrap (a¹ - 1)]) else [Wrap 0]}: 44
//│ [Wrap (a¹ - 1)]: 39 --->
//│ 	case x¹ of {Wrap a¹ => if (a¹ > 0) then c_₀([Wrap (a¹ - 1)]) else [Wrap 0]}: 44
//│ ------------------
//│ case x¹ of {Wrap a¹ => if (a¹ > 0) then c_₀([Wrap (a¹ - 1)]) else [Wrap 0]}: 44 --->
//│ 	[Wrap 3]: 26
//│ 	[Wrap (a¹ - 1)]: 39
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x²) = 
//│ 	case x² of {
//│ 		Wrap a¹ => if (a¹ > 0) then c_₀([Wrap (a¹ - 1)]) else [Wrap 0]}
//│ def p_₀ = 
//│ 	[Wrap 3]
//│ <<<<<<< after fusion <<<<<<<



// WRONG: branching and conflict, but can be solved by rewriting into
// NOTE: some program not be able to write?
fun last(ls) = if ls is
  C(h, t) then if t is
    N then Some(h)
    C(hh, tt) then last(t)
  N then None
let p = C(1, C(2, N))
last(p)
//│ |#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |last|(|t|)|←|↵|N| |#then| |None|←|↵|#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|last|(|p|)|
//│ Parsed: {fun last = ls, => if ls is ‹(C (h, t,)) then if t is ‹(N) then Some (h,); (C (hh, tt,)) then last (t,)›; (N) then None›; let p = C (1, C (2, N,),); last (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ last^17(p^18)
//│ def last(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N  => [Some h⁰]
//│ 		| C hh⁰ tt⁰ => last^5(t⁰)}
//│ 	| N  => [None]}
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^17]
//│ 	[last^17 · last^5] ---> [last^17] (only one)
//│ [p^18] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ last_₀(p_₀)
//│ def last_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => case t¹ of {
//│ 			N  => [Some h¹]
//│ 			| C hh¹ tt¹ => last_₀(t¹)}
//│ 		| N  => [None]}
//│ def p_₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 33 --->
//│ 	DeadCodeCons
//│ 	case t¹ of {N  => [Some h¹] | C hh¹ tt¹ => last_₀(t¹)}: 27
//│ 	case ls¹ of {C h¹ t¹ => case t¹ of {N  => [Some h¹] | C hh¹ tt¹ => last_₀(t¹)} | N  => [None]}: 29
//│ [C 2 [N]]: 34 --->
//│ 	case t¹ of {N  => [Some h¹] | C hh¹ tt¹ => last_₀(t¹)}: 27
//│ 	case ls¹ of {C h¹ t¹ => case t¹ of {N  => [Some h¹] | C hh¹ tt¹ => last_₀(t¹)} | N  => [None]}: 29
//│ [C 1 [C 2 [N]]]: 35 --->
//│ 	case ls¹ of {C h¹ t¹ => case t¹ of {N  => [Some h¹] | C hh¹ tt¹ => last_₀(t¹)} | N  => [None]}: 29
//│ ------------------
//│ case t¹ of {N  => [Some h¹] | C hh¹ tt¹ => last_₀(t¹)}: 27 --->
//│ 	[N]: 33
//│ 	[C 2 [N]]: 34
//│ case ls¹ of {C h¹ t¹ => case t¹ of {N  => [Some h¹] | C hh¹ tt¹ => last_₀(t¹)} | N  => [None]}: 29 --->
//│ 	[N]: 33
//│ 	[C 2 [N]]: 34
//│ 	[C 1 [C 2 [N]]]: 35
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ last_₀(p_₀)
//│ def last_₀(ls²) = 
//│ 	case ls² of {
//│ 		C h¹ t¹ => case t¹ of {
//│ 			N  => [Some h¹]
//│ 			| C hh¹ tt¹ => last_₀(t¹)}
//│ 		| N  => [None]}
//│ def p_₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ <<<<<<< after fusion <<<<<<<

// WRONG: one consumer cannot be expanded fully?
fun idxSum(ls) = if ls is
  N then acc => 0
  C(h, t) then acc => acc + idxSum(t)(acc + 1)
fun rev(lss) = if lss is
  N then a => a
  C(hh, tt) then a => rev(tt, C(hh, a))
idxSum(rev(C(1, C(2, N)))(N))(0)
//│ |#fun| |idxSum|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc| |=>| |0|↵|C|(|h|,| |t|)| |#then| |acc| |=>| |acc| |+| |idxSum|(|t|)|(|acc| |+| |1|)|←|↵|#fun| |rev|(|lss|)| |#=| |#if| |lss| |is|→|N| |#then| |a| |=>| |a|↵|C|(|hh|,| |tt|)| |#then| |a| |=>| |rev|(|tt|,| |C|(|hh|,| |a|)|)|←|↵|idxSum|(|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|N|)|)|(|0|)|
//│ Parsed: {fun idxSum = ls, => if ls is ‹(N) then acc, => 0; (C (h, t,)) then acc, => + (acc,) (idxSum (t,) (+ (acc,) (1,),),)›; fun rev = lss, => if lss is ‹(N) then a, => a; (C (hh, tt,)) then a, => rev (tt, C (hh, a,),)›; idxSum (rev (C (1, C (2, N,),),) (N,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ idxSum^33(rev^34([C 1 [C 2 [N]]], [N]), 0)
//│ def idxSum(ls⁰) = case ls⁰ of {
//│ 	N  => (fun acc⁰ -> 0)
//│ 	| C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum^7(t⁰, (acc¹ + 1))))}
//│ def rev(lss⁰) = case lss⁰ of {
//│ 	N  => (fun a⁰ -> a⁰)
//│ 	| C hh⁰ tt⁰ => (fun a¹ -> rev^23(tt⁰, [C hh⁰ a¹]))}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [idxSum^33] (hopeless to continue)
//│ 	[idxSum^33 · idxSum^7] ---> [idxSum^33] (using original def)
//│ [rev^34]
//│ 	[rev^34 · rev^23] ---> [rev^34] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ idxSum_₀(rev_₀([C 1 [C 2 [N]]], [N]), 0)
//│ def idxSum_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		N  => (fun acc² -> 0)
//│ 		| C h¹ t¹ => (fun acc³ -> (acc³ + idxSum_₀(t¹, (acc³ + 1))))}
//│ def rev_₀(lss¹) = 
//│ 	case lss¹ of {
//│ 		N  => (fun a² -> a²)
//│ 		| C hh¹ tt¹ => (fun a³ -> rev_₀(tt¹, [C hh¹ a³]))}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ a³]: 54 --->
//│ 	case ls¹ of {N  => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + idxSum_₀(t¹, (acc³ + 1))))}: 76
//│ [N]: 82 --->
//│ 	case lss¹ of {N  => (fun a² -> a²) | C hh¹ tt¹ => (fun a³ -> rev_₀(tt¹, [C hh¹ a³]))}: 57
//│ [C 2 [N]]: 83 --->
//│ 	case lss¹ of {N  => (fun a² -> a²) | C hh¹ tt¹ => (fun a³ -> rev_₀(tt¹, [C hh¹ a³]))}: 57
//│ [C 1 [C 2 [N]]]: 84 --->
//│ 	case lss¹ of {N  => (fun a² -> a²) | C hh¹ tt¹ => (fun a³ -> rev_₀(tt¹, [C hh¹ a³]))}: 57
//│ [N]: 86 --->
//│ 	case ls¹ of {N  => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + idxSum_₀(t¹, (acc³ + 1))))}: 76
//│ ------------------
//│ case lss¹ of {N  => (fun a² -> a²) | C hh¹ tt¹ => (fun a³ -> rev_₀(tt¹, [C hh¹ a³]))}: 57 --->
//│ 	[N]: 82
//│ 	[C 2 [N]]: 83
//│ 	[C 1 [C 2 [N]]]: 84
//│ case ls¹ of {N  => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + idxSum_₀(t¹, (acc³ + 1))))}: 76 --->
//│ 	[C hh¹ a³]: 54
//│ 	[N]: 86
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C hh¹ a³]: 54 --->
//│ 	case ls¹ of {N  => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + idxSum_₀(t¹, (acc³ + 1))))}: 76
//│ [N]: 82 --->
//│ 	case lss¹ of {N  => (fun a² -> a²) | C hh¹ tt¹ => (fun a³ -> rev_₀(tt¹, [C hh¹ a³]))}: 57
//│ [C 2 [N]]: 83 --->
//│ 	case lss¹ of {N  => (fun a² -> a²) | C hh¹ tt¹ => (fun a³ -> rev_₀(tt¹, [C hh¹ a³]))}: 57
//│ [C 1 [C 2 [N]]]: 84 --->
//│ 	case lss¹ of {N  => (fun a² -> a²) | C hh¹ tt¹ => (fun a³ -> rev_₀(tt¹, [C hh¹ a³]))}: 57
//│ [N]: 86 --->
//│ 	case ls¹ of {N  => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + idxSum_₀(t¹, (acc³ + 1))))}: 76
//│ ------------------
//│ case lss¹ of {N  => (fun a² -> a²) | C hh¹ tt¹ => (fun a³ -> rev_₀(tt¹, [C hh¹ a³]))}: 57 --->
//│ 	[N]: 82
//│ 	[C 2 [N]]: 83
//│ 	[C 1 [C 2 [N]]]: 84
//│ case ls¹ of {N  => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + idxSum_₀(t¹, (acc³ + 1))))}: 76 --->
//│ 	[C hh¹ a³]: 54
//│ 	[N]: 86
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ idxSum_₀(rev_₀(
//│ 	let tt² = 	
//│ 		let tt³ = (fun a⁶ -> a⁶)
//│ 		in let hh³ = 2
//│ 		in (fun a⁵ -> rev_₀(tt³, 
//│ 			let t³ = a⁵
//│ 			in (fun acc⁵ -> (acc⁵ + idxSum_₀(t³, (acc⁵ + 1))))))
//│ 	in let hh² = 1
//│ 	in (fun a⁴ -> rev_₀(tt², 
//│ 		let t² = a⁴
//│ 		in (fun acc⁴ -> (acc⁴ + idxSum_₀(t², (acc⁴ + 1)))))), (fun acc⁶ -> 0)), 0)
//│ def idxSum_₀(ls²) = 
//│ 	ls²
//│ def rev_₀(lss²) = 
//│ 	lss²
//│ <<<<<<< after fusion <<<<<<<


// WRONG: still has variable extrusion
_LUMBERHACK_EVAL
fun minuss(a) = if a is
  S(aa) then b => if b is
    S(bb) then minuss(aa, bb)
    Z then aa
  Z then n => Z
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |_LUMBERHACK_EVAL|↵|#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |#if| |b| |is|→|S|(|bb|)| |#then| |minuss|(|aa|,| |bb|)|↵|Z| |#then| |aa|←|↵|Z| |#then| |n| |=>| |Z|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun minuss = a, => if a is ‹(S (aa,)) then b, => if b is ‹(S (bb,)) then minuss (aa, bb,); (Z) then aa›; (Z) then n, => Z›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ minuss^19(fst^20, snd^22)
//│ def fst = [S [S [Z]]]
//│ def minuss(a⁰) = case a⁰ of {
//│ 	S aa⁰ => (fun b⁰ -> case b⁰ of {
//│ 		S bb⁰ => minuss^3(aa⁰, bb⁰)
//│ 		| Z  => aa⁰})
//│ 	| Z  => (fun n⁰ -> [Z])}
//│ def snd = [Z]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [S [Z]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fst^20] (hopeless to continue)
//│ [minuss^19]
//│ 	[minuss^19 · minuss^3] ---> [minuss^19] (only one)
//│ [snd^22] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ minuss_₀(fst_₀, snd_₀)
//│ def fst_₀ = 
//│ 	[S [S [Z]]]
//│ def minuss_₀(a¹) = 
//│ 	case a¹ of {
//│ 		S aa¹ => (fun b¹ -> case b¹ of {
//│ 			S bb¹ => minuss_₀(aa¹, bb¹)
//│ 			| Z  => aa¹})
//│ 		| Z  => (fun n¹ -> [Z])}
//│ def snd_₀ = 
//│ 	[Z]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Z]: 24 --->
//│ 	DeadCodeCons
//│ 	case b¹ of {S bb¹ => minuss_₀(aa¹, bb¹) | Z  => aa¹}: 36
//│ [Z]: 25 --->
//│ 	NoCons
//│ 	case a¹ of {S aa¹ => (fun b¹ -> case b¹ of {S bb¹ => minuss_₀(aa¹, bb¹) | Z  => aa¹}) | Z  => (fun n¹ -> [Z])}: 40
//│ [S [Z]]: 26 --->
//│ 	NoCons
//│ 	case a¹ of {S aa¹ => (fun b¹ -> case b¹ of {S bb¹ => minuss_₀(aa¹, bb¹) | Z  => aa¹}) | Z  => (fun n¹ -> [Z])}: 40
//│ [S [S [Z]]]: 27 --->
//│ 	case a¹ of {S aa¹ => (fun b¹ -> case b¹ of {S bb¹ => minuss_₀(aa¹, bb¹) | Z  => aa¹}) | Z  => (fun n¹ -> [Z])}: 40
//│ ------------------
//│ case b¹ of {S bb¹ => minuss_₀(aa¹, bb¹) | Z  => aa¹}: 36 --->
//│ 	DeadCodeProd
//│ 	[Z]: 24
//│ case a¹ of {S aa¹ => (fun b¹ -> case b¹ of {S bb¹ => minuss_₀(aa¹, bb¹) | Z  => aa¹}) | Z  => (fun n¹ -> [Z])}: 40 --->
//│ 	[Z]: 25
//│ 	[S [Z]]: 26
//│ 	[S [S [Z]]]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ minuss_₀(fst_₀, snd_₀)
//│ def fst_₀ = 
//│ 	[S [S [Z]]]
//│ def minuss_₀(a²) = 
//│ 	case a² of {
//│ 		S aa¹ => (fun b² -> case b² of {
//│ 			S bb¹ => minuss_₀(aa¹, bb¹)
//│ 			| Z  => aa¹})
//│ 		| Z  => (fun n² -> [Z])}
//│ def snd_₀ = 
//│ 	[Z]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [S [Z]]
//│ <<<<<<< evaluate <<<<<<<


// WRONG:
_LUMBERHACK_EVAL
fun minuss(a) = if a is
  S(aa) then b => checkb(b)(aa)
  Z then n => Z
fun checkb(b) = if b is
  S(bb) then aaa => minuss(aaa, bb)
  Z then aaa => aaa
let fst = S(S(Z))
let snd = Z
minuss(fst)(snd)
//│ |_LUMBERHACK_EVAL|↵|#fun| |minuss|(|a|)| |#=| |#if| |a| |is|→|S|(|aa|)| |#then| |b| |=>| |checkb|(|b|)|(|aa|)|↵|Z| |#then| |n| |=>| |Z|←|↵|#fun| |checkb|(|b|)| |#=| |#if| |b| |is|→|S|(|bb|)| |#then| |aaa| |=>| |minuss|(|aaa|,| |bb|)|↵|Z| |#then| |aaa| |=>| |aaa|←|↵|#let| |fst| |#=| |S|(|S|(|Z|)|)|↵|#let| |snd| |#=| |Z|↵|minuss|(|fst|)|(|snd|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun minuss = a, => if a is ‹(S (aa,)) then b, => checkb (b,) (aa,); (Z) then n, => Z›; fun checkb = b, => if b is ‹(S (bb,)) then aaa, => minuss (aaa, bb,); (Z) then aaa, => aaa›; let fst = S (S (Z,),); let snd = Z; minuss (fst,) (snd,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ minuss^27(fst^28, snd^30)
//│ def checkb(b¹) = case b¹ of {
//│ 	S bb⁰ => (fun aaa⁰ -> minuss^13(aaa⁰, bb⁰))
//│ 	| Z  => (fun aaa¹ -> aaa¹)}
//│ def fst = [S [S [Z]]]
//│ def minuss(a⁰) = case a⁰ of {
//│ 	S aa⁰ => (fun b⁰ -> checkb^2(b⁰, aa⁰))
//│ 	| Z  => (fun n⁰ -> [Z])}
//│ def snd = [Z]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [S [Z]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fst^28] (hopeless to continue)
//│ [minuss^27]
//│ 	[minuss^27 · checkb^2]
//│ 		[minuss^27 · checkb^2 · minuss^13] ---> [minuss^27] (only one)
//│ [snd^30] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ minuss_₀(fst_₀, snd_₀)
//│ def fst_₀ = 
//│ 	[S [S [Z]]]
//│ def minuss_₀(a¹) = 
//│ 	case a¹ of {
//│ 		S aa¹ => (fun b² -> checkb_₀(b², aa¹))
//│ 		| Z  => (fun n¹ -> [Z])}
//│ 	where
//│ 	def checkb_₀(b³) = 
//│ 		case b³ of {
//│ 			S bb¹ => (fun aaa² -> minuss_₀(aaa², bb¹))
//│ 			| Z  => (fun aaa³ -> aaa³)}
//│ def snd_₀ = 
//│ 	[Z]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Z]: 43 --->
//│ 	DeadCodeCons
//│ 	case b³ of {S bb¹ => (fun aaa² -> minuss_₀(aaa², bb¹)) | Z  => (fun aaa³ -> aaa³)}: 53
//│ [Z]: 55 --->
//│ 	NoCons
//│ 	case a¹ of {S aa¹ => (fun b² -> checkb_₀(b², aa¹)) | Z  => (fun n¹ -> [Z])}: 41
//│ [S [Z]]: 56 --->
//│ 	NoCons
//│ 	case a¹ of {S aa¹ => (fun b² -> checkb_₀(b², aa¹)) | Z  => (fun n¹ -> [Z])}: 41
//│ [S [S [Z]]]: 57 --->
//│ 	case a¹ of {S aa¹ => (fun b² -> checkb_₀(b², aa¹)) | Z  => (fun n¹ -> [Z])}: 41
//│ ------------------
//│ case a¹ of {S aa¹ => (fun b² -> checkb_₀(b², aa¹)) | Z  => (fun n¹ -> [Z])}: 41 --->
//│ 	[Z]: 55
//│ 	[S [Z]]: 56
//│ 	[S [S [Z]]]: 57
//│ case b³ of {S bb¹ => (fun aaa² -> minuss_₀(aaa², bb¹)) | Z  => (fun aaa³ -> aaa³)}: 53 --->
//│ 	DeadCodeProd
//│ 	[Z]: 43
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ minuss_₀(fst_₀, snd_₀)
//│ def fst_₀ = 
//│ 	[S [S [Z]]]
//│ def minuss_₀(a²) = 
//│ 	case a² of {
//│ 		S aa¹ => (fun b⁴ -> checkb_₀(b⁴, aa¹))
//│ 		| Z  => (fun n² -> [Z])}
//│ 	where
//│ 	def checkb_₀(b⁵) = 
//│ 		case b⁵ of {
//│ 			S bb¹ => (fun aaa⁴ -> minuss_₀(aaa⁴, bb¹))
//│ 			| Z  => (fun aaa⁵ -> aaa⁵)}
//│ def snd_₀ = 
//│ 	[Z]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [S [Z]]
//│ <<<<<<< evaluate <<<<<<<

// WRONG:
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let rec l1 = C(1, C(2, l1))
let rec l2 = C(9, C(8, l2))
inter(l1)(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |#rec| |l1| |#=| |C|(|1|,| |C|(|2|,| |l1|)|)|↵|#let| |#rec| |l2| |#=| |C|(|9|,| |C|(|8|,| |l2|)|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let rec l1 = C (1, C (2, l1,),); let rec l2 = C (9, C (8, l2,),); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^24(l1^25, l2^27)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 l1^16]]
//│ def l2 = [C 9 [C 8 l2^21]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^24]
//│ 	[inter^24 · inter^5] ---> [inter^24] (only one)
//│ [l1^25]
//│ 	[l1^25 · l1^16] ---> [l1^25] (only one)
//│ [l2^27]
//│ 	[l2^27 · l2^21] ---> [l2^27] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ inter_₀(l1_₀, l2_₀)
//│ def inter_₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ inter_₀(ys³, t¹)])}
//│ def l1_₀ = 
//│ 	[C 1 [C 2 l1_₀]]
//│ def l2_₀ = 
//│ 	[C 9 [C 8 l2_₀]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 2 l1_₀]: 32 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter_₀(ys³, t¹)])}: 50
//│ [C 1 [C 2 l1_₀]]: 33 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter_₀(ys³, t¹)])}: 50
//│ [C 8 l2_₀]: 37 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter_₀(ys³, t¹)])}: 50
//│ [C 9 [C 8 l2_₀]]: 38 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter_₀(ys³, t¹)])}: 50
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ inter_₀(ys³, t¹)])}: 50 --->
//│ 	[C 2 l1_₀]: 32
//│ 	[C 1 [C 2 l1_₀]]: 33
//│ 	[C 8 l2_₀]: 37
//│ 	[C 9 [C 8 l2_₀]]: 38
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter_₀(l1_₀, l2_₀)
//│ def inter_₀(xs²) = 
//│ 	case xs² of {
//│ 		N  => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ inter_₀(ys⁵, t¹)])}
//│ def l1_₀ = 
//│ 	[C 1 [C 2 l1_₀]]
//│ def l2_₀ = 
//│ 	[C 9 [C 8 l2_₀]]
//│ <<<<<<< after fusion <<<<<<<


// WRONG: push in cannot work still have binding error
// and wrong recursive knots
fun f(xs) = if xs is
  X(x1) then if x1 is
    X(x2) then if x2 is
      X(x3) then ys => if ys is
        Y(y1) then if y1 is
          Y(y2) then f(x3, y2)
let rec xx = X(X(xx))
let rec yy = Y(Y(Y(yy)))
f(xx, yy)
//│ |#fun| |f|(|xs|)| |#=| |#if| |xs| |is|→|X|(|x1|)| |#then| |#if| |x1| |is|→|X|(|x2|)| |#then| |#if| |x2| |is|→|X|(|x3|)| |#then| |ys| |=>| |#if| |ys| |is|→|Y|(|y1|)| |#then| |#if| |y1| |is|→|Y|(|y2|)| |#then| |f|(|x3|,| |y2|)|←|←|←|←|←|↵|#let| |#rec| |xx| |#=| |X|(|X|(|xx|)|)|↵|#let| |#rec| |yy| |#=| |Y|(|Y|(|Y|(|yy|)|)|)|↵|f|(|xx|,| |yy|)|
//│ Parsed: {fun f = xs, => if xs is ‹(X (x1,)) then if x1 is ‹(X (x2,)) then if x2 is ‹(X (x3,)) then ys, => if ys is ‹(Y (y1,)) then if y1 is ‹(Y (y2,)) then f (x3, y2,)›››››; let rec xx = X (X (xx,),); let rec yy = Y (Y (Y (yy,),),); f (xx, yy,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^25(xx^26, yy^28)
//│ def f(xs⁰) = case xs⁰ of {
//│ 	X x1⁰ => case x1⁰ of {
//│ 		X x2⁰ => case x2⁰ of {
//│ 			X x3⁰ => (fun ys⁰ -> case ys⁰ of {
//│ 				Y y1⁰ => case y1⁰ of {
//│ 					Y y2⁰ => f^6(x3⁰, y2⁰)}})}}}
//│ def xx = [X [X xx^18]]
//│ def yy = [Y [Y [Y yy^21]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^25]
//│ 	[f^25 · f^6]
//│ 		[f^25 · f^6 · f^6] ---> [f^25] (only one)
//│ [xx^26]
//│ 	[xx^26 · xx^18]
//│ 		[xx^26 · xx^18 · xx^18]
//│ 			[xx^26 · xx^18 · xx^18 · xx^18] ---> [xx^26] (only one)
//│ [yy^28]
//│ 	[yy^28 · yy^21]
//│ 		[yy^28 · yy^21 · yy^21] ---> [yy^28] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀(xx_₀, yy_₀)
//│ def f_₀(xs²) = 
//│ 	case xs² of {
//│ 		X x1² => case x1² of {
//│ 			X x2² => case x2² of {
//│ 				X x3² => (fun ys² -> case ys² of {
//│ 					Y y1² => case y1² of {
//│ 						Y y2² => f_₁(x3², y2²)}})}}}
//│ 	where
//│ 	def f_₁(xs¹) = 
//│ 		case xs¹ of {
//│ 			X x1¹ => case x1¹ of {
//│ 				X x2¹ => case x2¹ of {
//│ 					X x3¹ => (fun ys¹ -> case ys¹ of {
//│ 						Y y1¹ => case y1¹ of {
//│ 							Y y2¹ => f_₀(x3¹, y2¹)}})}}}
//│ def xx_₀ = 
//│ 	[X [X xx_₁]]
//│ 	where
//│ 	def xx_₁ = 
//│ 		[X [X xx_₂]]
//│ 		where
//│ 		def xx_₂ = 
//│ 			[X [X xx_₀]]
//│ def yy_₀ = 
//│ 	[Y [Y [Y yy_₁]]]
//│ 	where
//│ 	def yy_₁ = 
//│ 		[Y [Y [Y yy_₀]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [X xx_₀]: 31 --->
//│ 	case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}})}: 56
//│ [X [X xx_₀]]: 32 --->
//│ 	case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}})}}: 57
//│ [X xx_₂]: 34 --->
//│ 	case xs¹ of {X x1¹ => case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}})}}}: 58
//│ [X [X xx_₂]]: 35 --->
//│ 	case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}})}: 73
//│ [Y yy_₁]: 37 --->
//│ 	case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}}: 54
//│ 	case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}}: 71
//│ [Y [Y yy_₁]]: 38 --->
//│ 	case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}: 53
//│ 	case y1² of {Y y2² => f_₁(x3², y2²)}: 70
//│ [Y [Y [Y yy_₁]]]: 39 --->
//│ 	case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}}: 54
//│ 	case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}}: 71
//│ [X xx_₁]: 41 --->
//│ 	case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}})}}: 74
//│ [X [X xx_₁]]: 42 --->
//│ 	case xs² of {X x1² => case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}})}}}: 75
//│ [Y yy_₀]: 78 --->
//│ 	case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}: 53
//│ 	case y1² of {Y y2² => f_₁(x3², y2²)}: 70
//│ [Y [Y yy_₀]]: 79 --->
//│ 	case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}}: 54
//│ 	case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}}: 71
//│ [Y [Y [Y yy_₀]]]: 80 --->
//│ 	case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}: 53
//│ 	case y1² of {Y y2² => f_₁(x3², y2²)}: 70
//│ ------------------
//│ case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}: 53 --->
//│ 	[Y [Y yy_₁]]: 38
//│ 	[Y yy_₀]: 78
//│ 	[Y [Y [Y yy_₀]]]: 80
//│ case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}}: 54 --->
//│ 	[Y yy_₁]: 37
//│ 	[Y [Y [Y yy_₁]]]: 39
//│ 	[Y [Y yy_₀]]: 79
//│ case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}})}: 56 --->
//│ 	[X xx_₀]: 31
//│ case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}})}}: 57 --->
//│ 	[X [X xx_₀]]: 32
//│ case xs¹ of {X x1¹ => case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}})}}}: 58 --->
//│ 	[X xx_₂]: 34
//│ case y1² of {Y y2² => f_₁(x3², y2²)}: 70 --->
//│ 	[Y [Y yy_₁]]: 38
//│ 	[Y yy_₀]: 78
//│ 	[Y [Y [Y yy_₀]]]: 80
//│ case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}}: 71 --->
//│ 	[Y yy_₁]: 37
//│ 	[Y [Y [Y yy_₁]]]: 39
//│ 	[Y [Y yy_₀]]: 79
//│ case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}})}: 73 --->
//│ 	[X [X xx_₂]]: 35
//│ case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}})}}: 74 --->
//│ 	[X xx_₁]: 41
//│ case xs² of {X x1² => case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}})}}}: 75 --->
//│ 	[X [X xx_₁]]: 42
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [X xx_₀]: 31 --->
//│ 	case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}})}: 56
//│ [X [X xx_₀]]: 32 --->
//│ 	case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}})}}: 57
//│ [X xx_₂]: 34 --->
//│ 	case xs¹ of {X x1¹ => case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}})}}}: 58
//│ [X [X xx_₂]]: 35 --->
//│ 	case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}})}: 73
//│ [X xx_₁]: 41 --->
//│ 	case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}})}}: 74
//│ [X [X xx_₁]]: 42 --->
//│ 	case xs² of {X x1² => case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}})}}}: 75
//│ ------------------
//│ case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}})}: 56 --->
//│ 	[X xx_₀]: 31
//│ case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}})}}: 57 --->
//│ 	[X [X xx_₀]]: 32
//│ case xs¹ of {X x1¹ => case x1¹ of {X x2¹ => case x2¹ of {X x3¹ => (fun ys¹ -> case ys¹ of {Y y1¹ => case y1¹ of {Y y2¹ => f_₀(x3¹, y2¹)}})}}}: 58 --->
//│ 	[X xx_₂]: 34
//│ case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}})}: 73 --->
//│ 	[X [X xx_₂]]: 35
//│ case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}})}}: 74 --->
//│ 	[X xx_₁]: 41
//│ case xs² of {X x1² => case x1² of {X x2² => case x2² of {X x3² => (fun ys² -> case ys² of {Y y1² => case y1² of {Y y2² => f_₁(x3², y2²)}})}}}: 75 --->
//│ 	[X [X xx_₁]]: 42
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀(xx_₀, yy_₀)
//│ def f_₀(xs³) = 
//│ 	xs³
//│ 	where
//│ 	def f_₁(xs⁴) = 
//│ 		xs⁴
//│ def xx_₀ = 
//│ 	let x1⁴ = 	
//│ 		let x2³ = xx_₁
//│ 		in x2³
//│ 	in x1⁴
//│ 	where
//│ 	def xx_₁ = 
//│ 		let x3³ = 	
//│ 			let x1³ = xx_₂
//│ 			in x1³
//│ 		in (fun ys³ -> case ys³ of {
//│ 			Y y1² => case y1² of {
//│ 				Y y2² => f_₁(x3³, y2²)}})
//│ 		where
//│ 		def xx_₂ = 
//│ 			let x2⁴ = 	
//│ 				let x3⁴ = xx_₀
//│ 				in (fun ys⁴ -> case ys⁴ of {
//│ 					Y y1¹ => case y1¹ of {
//│ 						Y y2¹ => f_₀(x3⁴, y2¹)}})
//│ 			in x2⁴
//│ def yy_₀ = 
//│ 	[Y [Y [Y yy_₁]]]
//│ 	where
//│ 	def yy_₁ = 
//│ 		[Y [Y [Y yy_₀]]]
//│ <<<<<<< after fusion <<<<<<<



// WRONG: still have binding error
// _LUMBERHACK_ERROR
fun f(x) = if x is
  C(k) then f(x)
f(C(primitive))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|k|)| |#then| |f|(|x|)|←|↵|f|(|C|(|primitive|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (k,)) then f (x,)›; f (C (primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^7([C primitive⁰])
//│ def f(x⁰) = case x⁰ of {
//│ 	C k⁰ => f^2(x⁰)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^7] (hopeless to continue)
//│ 	[f^7 · f^2] ---> [f^7] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([C primitive⁰])
//│ def f_₀(x¹) = 
//│ 	case x¹ of {
//│ 		C k¹ => f_₀(x¹)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰]: 19 --->
//│ 	case x¹ of {C k¹ => f_₀(x¹)}: 15
//│ ------------------
//│ case x¹ of {C k¹ => f_₀(x¹)}: 15 --->
//│ 	[C primitive⁰]: 19
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C primitive⁰]: 19 --->
//│ 	case x¹ of {C k¹ => f_₀(x¹)}: 15
//│ ------------------
//│ case x¹ of {C k¹ => f_₀(x¹)}: 15 --->
//│ 	[C primitive⁰]: 19
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀((fun x² -> f_₀(x²)))
//│ def f_₀(x³) = 
//│ 	x³(x³)
//│ <<<<<<< after fusion <<<<<<<

// NOTE: this way of pushing in var is local
fun f(x) = (if x is
  C(k) then x => f(x)
)(x)
f(C(primitive))
//│ |#fun| |f|(|x|)| |#=| |(|#if| |x| |is|→|C|(|k|)| |#then| |x| |=>| |f|(|x|)|←|↵|)|(|x|)|↵|f|(|C|(|primitive|)|)|
//│ Parsed: {fun f = x, => '(' if x is ‹(C (k,)) then x, => f (x,)›, ')' (x,); f (C (primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^10([C primitive⁰])
//│ def f(x⁰) = case x⁰ of {
//│ 	C k⁰ => (fun x¹ -> f^2(x¹))}(x⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^10]
//│ 	[f^10 · f^2] ---> [f^10] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([C primitive⁰])
//│ def f_₀(x²) = 
//│ 	case x² of {
//│ 		C k¹ => (fun x³ -> f_₀(x³))}(x²)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰]: 25 --->
//│ 	case x² of {C k¹ => (fun x³ -> f_₀(x³))}: 19
//│ ------------------
//│ case x² of {C k¹ => (fun x³ -> f_₀(x³))}: 19 --->
//│ 	[C primitive⁰]: 25
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C primitive⁰]: 25 --->
//│ 	case x² of {C k¹ => (fun x³ -> f_₀(x³))}: 19
//│ ------------------
//│ case x² of {C k¹ => (fun x³ -> f_₀(x³))}: 19 --->
//│ 	[C primitive⁰]: 25
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀((fun x⁴ -> f_₀(x⁴)))
//│ def f_₀(x⁵) = 
//│ 	x⁵(x⁵)
//│ <<<<<<< after fusion <<<<<<<



// CORRECT: after filtering out recursive strategies
fun f(x) = if x is
  C(k) then f(C(x))
f(C(primitive))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|k|)| |#then| |f|(|C|(|x|)|)|←|↵|f|(|C|(|primitive|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (k,)) then f (C (x,),)›; f (C (primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^8([C primitive⁰])
//│ def f(x⁰) = case x⁰ of {
//│ 	C k⁰ => f^2([C x⁰])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^8] (hopeless to continue)
//│ 	[f^8 · f^2] ---> [f^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([C primitive⁰])
//│ def f_₀(x¹) = 
//│ 	case x¹ of {
//│ 		C k¹ => f_₀([C x¹])}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x¹]: 15 --->
//│ 	DeadCodeCons
//│ 	case x¹ of {C k¹ => f_₀([C x¹])}: 17
//│ [C primitive⁰]: 21 --->
//│ 	DeadCodeCons
//│ 	case x¹ of {C k¹ => f_₀([C x¹])}: 17
//│ ------------------
//│ case x¹ of {C k¹ => f_₀([C x¹])}: 17 --->
//│ 	[C x¹]: 15
//│ 	[C primitive⁰]: 21
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀([C primitive⁰])
//│ def f_₀(x²) = 
//│ 	case x² of {
//│ 		C k¹ => f_₀([C x²])}
//│ <<<<<<< after fusion <<<<<<<


// // CORRECT: after the detection and elimination of multiple matches
// NOTE: no recursive strategy stackoverflow problem
// because the infinite rewriting cannot be started by `primitive`
fun f(x) = if x is
  N then f(N)
  _ then 0
f(primitive)
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |f|(|N|)|↵|_| |#then| |0|←|↵|f|(|primitive|)|
//│ Parsed: {fun f = x, => if x is ‹(N) then f (N,); (_) then 0›; f (primitive,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^8(primitive⁰)
//│ def f(x⁰) = case x⁰ of {
//│ 	N  => f^2([N])
//│ 	| _  => 0}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^8] (hopeless to continue)
//│ 	[f^8 · f^2] ---> [f^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀(primitive⁰)
//│ def f_₀(x¹) = 
//│ 	case x¹ of {
//│ 		N  => f_₀([N])
//│ 		| _  => 0}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 13 --->
//│ 	case x¹ of {N  => f_₀([N]) | _  => 0}: 16
//│ ------------------
//│ case x¹ of {N  => f_₀([N]) | _  => 0}: 16 --->
//│ 	[N]: 13
//│ 	NoProd
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀(primitive⁰)
//│ def f_₀(x²) = 
//│ 	case x² of {
//│ 		N  => f_₀([N])
//│ 		| _  => 0}
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: mutual recursive strategy can be filtered out
fun f(x) = if x is
    C(a) then f(C(a))
fun g(y) = if y is
    D(b) then f(C(b))
f(C(A))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |f|(|C|(|a|)|)|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|D|(|b|)| |#then| |f|(|C|(|b|)|)|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then f (C (a,),)›; fun g = y, => if y is ‹(D (b,)) then f (C (b,),)›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^15([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => f^2([C a⁰])}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => f^9([C b⁰])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^15] (hopeless to continue)
//│ 	[f^15 · f^2] ---> [f^15] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([C [A]])
//│ def f_₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => f_₀([C a¹])}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a¹]: 22 --->
//│ 	case x¹ of {C a¹ => f_₀([C a¹])}: 24
//│ [C [A]]: 28 --->
//│ 	case x¹ of {C a¹ => f_₀([C a¹])}: 24
//│ ------------------
//│ case x¹ of {C a¹ => f_₀([C a¹])}: 24 --->
//│ 	[C a¹]: 22
//│ 	[C [A]]: 28
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀([C [A]])
//│ def f_₀(x²) = 
//│ 	case x² of {
//│ 		C a¹ => f_₀([C a¹])}
//│ <<<<<<< after fusion <<<<<<<
