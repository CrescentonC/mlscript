:NewParser
:ParseOnly

// NOTE: should use more recursive search to find out the correct output
// let t = T(N, N)
// fun c(x) = if x is
//     T(l, r) then T(c(l), c(r))
//     N then NN
// c(t)
let t = T(T(N, N), T(N, N))
fun c(x) = if x is
    T(l, r) then T(c(l), c(r))
    N then NN
c(t)
//│ |#let| |t| |#=| |T|(|T|(|N|,| |N|)|,| |T|(|N|,| |N|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|l|,| |r|)| |#then| |T|(|c|(|l|)|,| |c|(|r|)|)|↵|N| |#then| |NN|←|↵|c|(|t|)|
//│ Parsed: {let t = T (T (N, N,), T (N, N,),); fun c = x, => if x is ‹(T (l, r,)) then T (c (l,), c (r,),); (N) then NN›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def t:1 = 7: [T 3: [T 1: [N] 2: [N]] 6: [T 4: [N] 5: [N]]]
//│ def c:2 = 18: fun x:3 -> 17: case 8: x:3 of {T l:4 r:5 -> 15: [T 11: (9: c:2 10: l:4) 14: (12: c:2 13: r:5)] | N -> 16: [NN]}
//│ 21: (19: c:2 20: t:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((t:1^20 ⋅ ɛ, T((ɛ, N()), (ɛ, N()))), (c:2^19 ⋅ c:2^12 ⋅ ɛ, 2'x)) :::: ((t:1^20 ⋅ ɛ, T((ɛ, N()), (ɛ, N()))), (c:2^19 ⋅ c:2^9 ⋅ ɛ, 2'x))
//│ ((t:1^20 ⋅ ɛ, N()), (c:2^19 ⋅ c:2^9 ⋅ c:2^12 ⋅ ɛ, 2'x)) :::: ((t:1^20 ⋅ ɛ, N()), (c:2^19 ⋅ c:2^9 ⋅ c:2^9 ⋅ ɛ, 2'x))
//│ ------- defInstance -------
//│ t:1^20 ⋅ ɛ ==> c:2^19 ⋅ c:2^9 ⋅ ɛ:
//│ 	3: [T [N] [N]]  <-->  17: case x:3 of {T l:4 r:5 -> [T (c:2 l:4) (c:2 r:5)] | N -> [NN]}
//│ t:1^20 ⋅ ɛ ==> c:2^19 ⋅ ɛ:
//│ 	7: [T [T [N] [N]] [T [N] [N]]]  <-->  17: case x:3 of {T l:4 r:5 -> [T (c:2 l:4) (c:2 r:5)] | N -> [NN]}
//│ t:1^20 ⋅ ɛ ==> c:2^19 ⋅ c:2^9 ⋅ c:2^9 ⋅ ɛ:
//│ 	1: [N]  <-->  17: case x:3 of {T l:4 r:5 -> [T (c:2 l:4) (c:2 r:5)] | N -> [NN]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def t:1 = [T [T [N] [N]] [T [N] [N]]]
//│ def c:2 = fun x:3 -> case x:3 of {T l:4 r:5 -> [T (c:2 l:4) (c:2 r:5)] | N -> [NN]}
//│ def c'2'19_c'2'9_c'2'9:9 = fun x:3 -> x:3
//│ def c'2'19_c'2'9:8 = fun x:3 -> x:3
//│ def t'1'20:7 = 
//│ 	let l:4 = 
//│ 		let l:4 = [NN] in 
//│ 		let r:5 = [N] in [T (c'2'19_c'2'9_c'2'9:9 l:4) (c'2'19_c'2'9_c'2'9:9 r:5)] 
//│ 	in 
//│ 	let r:5 = [T [N] [N]] in [T (c'2'19_c'2'9:8 l:4) (c'2'19_c'2'9:8 r:5)]
//│ def c'2'19:6 = fun x:3 -> x:3
//│ (c'2'19:6 t'1'20:7)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


// NOTE: the `p` inside `C(p)` is untouched
let p = C(p)
fun c(x) = if C(x) is
    C(a) then a
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |a|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then a›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 2: [C 1: p:1]
//│ def c:2 = 7: fun x:3 -> 6: case 4: [C 3: x:3] of {C a:4 -> 5: a:4}
//│ 10: (8: c:2 9: p:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ------- defInstance -------
//│ ɛ ==> ɛ:
//│ 	4: [C x:3]  <-->  6: case [C x:3] of {C a:4 -> a:4}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C p:1]
//│ def c:2 = fun x:3 -> case [C x:3] of {C a:4 -> a:4}
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:16 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:17]
//│ def p'1'9_p'1'1:7 = [C p'1'9_p'1'1_p'1'1:8]
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1:10 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:11]
//│ def p'1'9_p'1'1_p'1'1_p'1'1:9 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1:10]
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:12 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:13]
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:14 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:15]
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:15 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:16]
//│ def p'1'9:6 = [C p'1'9_p'1'1:7]
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:13 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:14]
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:17 = "RECURSE_TOO_LONG"
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:11 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:12]
//│ def c'2'8:5 = fun x:3 -> 
//│ 	let a:4 = x:3 in a:4
//│ def p'1'9_p'1'1_p'1'1:8 = [C p'1'9_p'1'1_p'1'1_p'1'1:9]
//│ (c'2'8:5 p'1'9:6)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


// NOTE: how to produce a finite rewrtten program?
let p = Pair(A, B)
fun c(x) = if x is
    Pair(a, b) then c(Pair(b, a))
c(p)
//│ |#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ /!!!\ Uncaught error: java.lang.StackOverflowError
//│ 	at: mlscript.lumberhack.Rewrite$.mlscript$lumberhack$Rewrite$$$_$rewriteExpr$1(Rewrite.scala:140)
//│ 	at: mlscript.lumberhack.Rewrite$.mlscript$lumberhack$Rewrite$$$_$rewriteExpr$1(Rewrite.scala:183)
//│ 	at: mlscript.lumberhack.Rewrite$.mlscript$lumberhack$Rewrite$$$_$rewriteExpr$1(Rewrite.scala:157)
//│ 	at: mlscript.lumberhack.Rewrite$.mlscript$lumberhack$Rewrite$$$_$rewriteExpr$1(Rewrite.scala:183)
//│ 	at: mlscript.lumberhack.Rewrite$.mlscript$lumberhack$Rewrite$$$_$rewriteExpr$1(Rewrite.scala:157)
//│ 	at: mlscript.lumberhack.Rewrite$.mlscript$lumberhack$Rewrite$$$_$rewriteExpr$1(Rewrite.scala:183)
//│ 	at: mlscript.lumberhack.Rewrite$.mlscript$lumberhack$Rewrite$$$_$rewriteExpr$1(Rewrite.scala:157)
//│ 	at: mlscript.lumberhack.Rewrite$.mlscript$lumberhack$Rewrite$$$_$rewriteExpr$1(Rewrite.scala:183)
//│ 	at: mlscript.lumberhack.Rewrite$.mlscript$lumberhack$Rewrite$$$_$rewriteExpr$1(Rewrite.scala:157)
//│ 	at: mlscript.lumberhack.Rewrite$.mlscript$lumberhack$Rewrite$$$_$rewriteExpr$1(Rewrite.scala:183)


// NOTE: only the first element is handled
fun map(f, ls) = if ls is
    C(h, t) then C(f(h), map(f, t))
    N then N
fun ff(x) = if x is
    K then T
    KK then TT
    KKKK then TTTT
let l = C(K, C(KK, C(KKKK, N)))
map(ff, l)
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|ff|,| |l|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; let l = C (K, C (KK, C (KKKK, N,),),); map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def map:1 = 14: fun f:4 -> 13: fun ls:5 -> 12: case 1: ls:5 of {C h:6 t:7 -> 10: [C 4: (2: f:4 3: h:6) 9: (7: (5: map:1 6: f:4) 8: t:7)] | N -> 11: [N]}
//│ def ff:2 = 20: fun x:8 -> 19: case 15: x:8 of {K -> 16: [T] | KK -> 17: [TT] | KKKK -> 18: [TTTT]}
//│ def l:3 = 27: [C 21: [K] 26: [C 22: [KK] 25: [C 23: [KKKK] 24: [N]]]]
//│ 32: (30: (28: map:1 29: ff:2) 31: l:3)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((ff:2^29 ⋅ ɛ, (ɛ, 11'x) => ((ɛ, 12'19_matchres))), (map:1^28 ⋅ map:1^5 ⋅ ɛ, 3'f)) :::: ((ff:2^29 ⋅ ɛ, (ɛ, 11'x) => ((ɛ, 12'19_matchres))), (map:1^28 ⋅ ɛ, 3'f))
//│ ------- defInstance -------
//│ l:3^31 ⋅ ɛ ==> ff:2^29 ⋅ ɛ:
//│ 	21: [K]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ map:1^28 ⋅ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ map:1^5 ⋅ ff:2^29 ⋅ ɛ:
//│ 	23: [KKKK]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ ɛ:
//│ 	27: [C [K] [C [KK] [C [KKKK] [N]]]]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ map:1^5 ⋅ ɛ:
//│ 	25: [C [KKKK] [N]]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ map:1^28 ⋅ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ ff:2^29 ⋅ ɛ:
//│ 	22: [KK]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ map:1^5 ⋅ map:1^5 ⋅ ɛ:
//│ 	24: [N]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ ɛ:
//│ 	26: [C [KK] [C [KKKK] [N]]]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def map:1 = fun f:4 -> fun ls:5 -> case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ def ff:2 = fun x:8 -> case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ def l:3 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def ff'2'29:10 = fun x:8 -> x:8
//│ def map'1'28_map'1'5_map'1'5:12 = fun f:4 -> fun ls:5 -> ls:5
//│ def map'1'28_map'1'5_map'1'5_map'1'5:13 = fun f:4 -> fun ls:5 -> ls:5
//│ def l'3'31:11 = 
//│ 	let h:6 = [T] in 
//│ 	let t:7 = 
//│ 		let h:6 = [KK] in 
//│ 		let t:7 = 
//│ 			let h:6 = [KKKK] in 
//│ 			let t:7 = [N] in [C (f:4 h:6) ((map'1'28_map'1'5_map'1'5_map'1'5:13 f:4) t:7)] 
//│ 		in [C (f:4 h:6) ((map'1'28_map'1'5_map'1'5:12 f:4) t:7)] 
//│ 	in [C (f:4 h:6) ((map'1'28:9 f:4) t:7)]
//│ def map'1'28:9 = fun f:4 -> fun ls:5 -> ls:5
//│ ((map'1'28:9 ff'2'29:10) l'3'31:11)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


// NOTE: some program not be able to write?
_LUMBERHACK_ERROR
fun last(ls) = if ls is
    C(h, t) then if t is
        N then Some(h)
        C(hh, tt) then last(t)
        // C(hh, tt) then last(C(hh, tt))
    N then None
let p = C(1, C(2, N))
last(p)
//│ |_LUMBERHACK_ERROR|↵|#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |last|(|t|)|↵|/* C(hh, tt) then last(C(hh, tt))*/|←|↵|N| |#then| |None|←|↵|#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|last|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun last = ls, => if ls is ‹(C (h, t,)) then if t is ‹(N) then Some (h,); (C (hh, tt,)) then last (t,)›; (N) then None›; let p = C (1, C (2, N,),); last (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def last:1 = 11: fun ls:3 -> 10: case 1: ls:3 of {C h:4 t:5 -> 8: case 2: t:5 of {N -> 4: [Some 3: h:4] | C hh:6 tt:7 -> 7: (5: last:1 6: t:5)} | N -> 9: [None]}
//│ def p:2 = 16: [C 12: 1 15: [C 13: 2 14: [N]]]
//│ 19: (17: last:1 18: p:2)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((last:1^5 ⋅ ɛ, None()), (ɛ, 9'10_matchres)) :::: ((ɛ, None()), (ɛ, 9'10_matchres))
//│ ((p:2^18 ⋅ ɛ, NoProd()), (last:1^17 ⋅ last:1^5 ⋅ ɛ, 3'h)) :::: ((p:2^18 ⋅ ɛ, NoProd()), (last:1^17 ⋅ ɛ, 3'h))
//│ ((last:1^5 ⋅ ɛ, Some((ɛ, 3'h))), (ɛ, 8'8_matchres)) :::: ((ɛ, Some((ɛ, 3'h))), (ɛ, 8'8_matchres))
//│ ------- defInstance -------
//│ p:2^18 ⋅ ɛ ==> last:1^17 ⋅ ɛ:
//│ 	15: [C 2 [N]]  <-->  8: case t:5 of {N -> [Some h:4] | C hh:6 tt:7 -> (last:1 t:5)}
//│ 	16: [C 1 [C 2 [N]]]  <-->  10: case ls:3 of {C h:4 t:5 -> case t:5 of {N -> [Some h:4] | C hh:6 tt:7 -> (last:1 t:5)} | N -> [None]}
//│ p:2^18 ⋅ ɛ ==> last:1^17 ⋅ last:1^5 ⋅ ɛ:
//│ 	14: [N]  <-->  8: case t:5 of {N -> [Some h:4] | C hh:6 tt:7 -> (last:1 t:5)}
//│ 	15: [C 2 [N]]  <-->  10: case ls:3 of {C h:4 t:5 -> case t:5 of {N -> [Some h:4] | C hh:6 tt:7 -> (last:1 t:5)} | N -> [None]}
//│ p:2^18 ⋅ ɛ ==> last:1^17 ⋅ last:1^5 ⋅ last:1^5 ⋅ ɛ:
//│ 	14: [N]  <-->  10: case ls:3 of {C h:4 t:5 -> case t:5 of {N -> [Some h:4] | C hh:6 tt:7 -> (last:1 t:5)} | N -> [None]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: Program reached and unexpected state.
//│ mlscript.utils.package$.lastWords(package.scala:183)
//│ mlscript.utils.package$.die(package.scala:182)
//│ mlscript.lumberhack.Rewrite$.$anonfun$2$$anonfun$1$$anonfun$1(Rewrite.scala:80)
//│ scala.collection.mutable.HashMap.updateWith(HashMap.scala:154)
//│ mlscript.lumberhack.Rewrite$.$anonfun$2$$anonfun$1(Rewrite.scala:82)
//│ scala.collection.immutable.Set$Set2.foreach(Set.scala:201)
//│ mlscript.lumberhack.Rewrite$.$anonfun$2(Rewrite.scala:82)
//│ scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)
//│ scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)
//│ scala.collection.immutable.Map$Map3.foreach(Map.scala:448)
//│ !!!!!!ERROR!!!!!!


