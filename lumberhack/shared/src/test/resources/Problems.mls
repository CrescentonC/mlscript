:NewParser
:ParseOnly


// NOTE: the `p` inside `C(p)` is untouched
// TODO don't rewrite dead code
let p = C(p)
fun c(x) = if C(x) is
    C(a) then a
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |a|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then a›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 2: [C 1: p:1]
//│ def c:2 = 7: fun x:3 -> 6: case 4: [C 3: x:3] of {C a:4 -> 5: a:4}
//│ 10: (8: c:2 9: p:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ------- defInstance -------
//│ ɛ ==> ɛ:
//│ 	4: [C x:3]  <-->  6: case [C x:3] of {C a:4 -> a:4}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C p:1]
//│ def c:2 = fun x:3 -> case [C x:3] of {C a:4 -> a:4}
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:16 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:17]
//│ def p'1'9_p'1'1:7 = [C p'1'9_p'1'1_p'1'1:8]
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1:10 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:11]
//│ def p'1'9_p'1'1_p'1'1_p'1'1:9 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1:10]
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:12 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:13]
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:14 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:15]
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:15 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:16]
//│ def p'1'9:6 = [C p'1'9_p'1'1:7]
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:13 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:14]
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:17 = "RECURSE_TOO_LONG"
//│ def p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:11 = [C p'1'9_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:12]
//│ def c'2'8:5 = fun x:3 -> 
//│ 	let a:4 = x:3 in a:4
//│ def p'1'9_p'1'1_p'1'1:8 = [C p'1'9_p'1'1_p'1'1_p'1'1:9]
//│ (c'2'8:5 p'1'9:6)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


// NOTE: how to produce a finite rewrtten program?
_LUMBERHACK_ERROR
let p = Pair(A, B)
fun c(x) = if x is
    Pair(a, b) then c(Pair(b, a))
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 3: [Pair 1: [A] 2: [B]]
//│ def c:2 = 11: fun x:3 -> 10: case 4: x:3 of {Pair a:4 b:5 -> 9: (5: c:2 8: [Pair 6: b:5 7: a:4])}
//│ 14: (12: c:2 13: p:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((p:1^13 ⋅ ɛ, B()), (c:2^12 ⋅ c:2^5 ⋅ c:2^5 ⋅ ɛ, 4'b)) :::: ((p:1^13 ⋅ ɛ, B()), (c:2^12 ⋅ ɛ, 4'b))
//│ ((p:1^13 ⋅ ɛ, A()), (c:2^12 ⋅ c:2^5 ⋅ c:2^5 ⋅ ɛ, 3'a)) :::: ((p:1^13 ⋅ ɛ, A()), (c:2^12 ⋅ ɛ, 3'a))
//│ ------- defInstance -------
//│ p:1^13 ⋅ ɛ ==> c:2^12 ⋅ ɛ:
//│ 	3: [Pair [A] [B]]  <-->  10: case x:3 of {Pair a:4 b:5 -> (c:2 [Pair b:5 a:4])}
//│ ɛ ==> c:2^5 ⋅ ɛ:
//│ 	8: [Pair b:5 a:4]  <-->  10: case x:3 of {Pair a:4 b:5 -> (c:2 [Pair b:5 a:4])}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!

// Just a more valid/reasonable version of the above
// TODO support nested patterns as in `Pair(0)`
// TODO get a recursive knot even when using `primitive` (we get it without)
_LUMBERHACK_ERROR
let p = Wrap(A)
fun c(x) = if x is
    N then 0
    Wrap(a) then c(Wrap(primitive(a)))
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Wrap|(|A|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |0|↵|Wrap|(|a|)| |#then| |c|(|Wrap|(|primitive|(|a|)|)|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Wrap (A,); fun c = x, => if x is ‹(N) then 0; (Wrap (a,)) then c (Wrap (primitive (a,),),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 2: [Wrap 1: [A]]
//│ def c:2 = 12: fun x:3 -> 11: case 3: x:3 of {N -> 4: 0 | Wrap a:4 -> 10: (5: c:2 9: [Wrap 8: (6: primitive:0 7: a:4)])}
//│ 15: (13: c:2 14: p:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ------- defInstance -------
//│ p:1^14 ⋅ ɛ ==> c:2^13 ⋅ ɛ:
//│ 	2: [Wrap [A]]  <-->  11: case x:3 of {N -> 0 | Wrap a:4 -> (c:2 [Wrap (primitive:0 a:4)])}
//│ ɛ ==> c:2^5 ⋅ ɛ:
//│ 	9: [Wrap (primitive:0 a:4)]  <-->  11: case x:3 of {N -> 0 | Wrap a:4 -> (c:2 [Wrap (primitive:0 a:4)])}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!

fun c(x) = if primitive(x) is
    True then 0
    False then c(primitive(x))
c(0)
//│ |#fun| |c|(|x|)| |#=| |#if| |primitive|(|x|)| |is|→|True| |#then| |0|↵|False| |#then| |c|(|primitive|(|x|)|)|←|↵|c|(|0|)|
//│ Parsed: {fun c = x, => if primitive (x,) is ‹(True) then 0; (False) then c (primitive (x,),)›; c (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def c:1 = 11: fun x:2 -> 10: case 3: (1: primitive:0 2: x:2) of {True -> 4: 0 | False -> 9: (5: c:1 8: (6: primitive:0 7: x:2))}
//│ 14: (12: c:1 13: 0)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ------- defInstance -------
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def c:1 = fun x:2 -> case (primitive:0 x:2) of {True -> 0 | False -> (c:1 (primitive:0 x:2))}
//│ def c'1'12_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5:10 = fun x:2 -> case (primitive:0 x:2) of {True -> 0 | False -> (c'1'12_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5:11 (primitive:0 x:2))}
//│ def c'1'12_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5:11 = fun x:2 -> case (primitive:0 x:2) of {True -> 0 | False -> (c'1'12_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5:12 (primitive:0 x:2))}
//│ def c'1'12_c'1'5_c'1'5_c'1'5:6 = fun x:2 -> case (primitive:0 x:2) of {True -> 0 | False -> (c'1'12_c'1'5_c'1'5_c'1'5_c'1'5:7 (primitive:0 x:2))}
//│ def c'1'12_c'1'5:4 = fun x:2 -> case (primitive:0 x:2) of {True -> 0 | False -> (c'1'12_c'1'5_c'1'5:5 (primitive:0 x:2))}
//│ def c'1'12_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5:9 = fun x:2 -> case (primitive:0 x:2) of {True -> 0 | False -> (c'1'12_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5:10 (primitive:0 x:2))}
//│ def c'1'12_c'1'5_c'1'5_c'1'5_c'1'5:7 = fun x:2 -> case (primitive:0 x:2) of {True -> 0 | False -> (c'1'12_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5:8 (primitive:0 x:2))}
//│ def c'1'12_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5:12 = fun x:2 -> case (primitive:0 x:2) of {True -> 0 | False -> (c'1'12_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5:13 (primitive:0 x:2))}
//│ def c'1'12_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5:14 = "RECURSE_TOO_LONG"
//│ def c'1'12_c'1'5_c'1'5:5 = fun x:2 -> case (primitive:0 x:2) of {True -> 0 | False -> (c'1'12_c'1'5_c'1'5_c'1'5:6 (primitive:0 x:2))}
//│ def c'1'12:3 = fun x:2 -> case (primitive:0 x:2) of {True -> 0 | False -> (c'1'12_c'1'5:4 (primitive:0 x:2))}
//│ def c'1'12_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5:13 = fun x:2 -> case (primitive:0 x:2) of {True -> 0 | False -> (c'1'12_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5:14 (primitive:0 x:2))}
//│ def c'1'12_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5:8 = fun x:2 -> case (primitive:0 x:2) of {True -> 0 | False -> (c'1'12_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5_c'1'5:9 (primitive:0 x:2))}
//│ (c'1'12:3 0)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


// NOTE: only the first element is handled
_LUMBERHACK_ERROR
fun map(f, ls) = if ls is
    C(h, t) then C(f(h), map(f, t))
    N then N
fun ff(x) = if x is
    K then T
    KK then TT
    KKKK then TTTT
let l = C(K, C(KK, C(KKKK, N)))
map(ff, l)
//│ |_LUMBERHACK_ERROR|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|ff|,| |l|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; let l = C (K, C (KK, C (KKKK, N,),),); map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def map:1 = 14: fun f:4 -> 13: fun ls:5 -> 12: case 1: ls:5 of {C h:6 t:7 -> 10: [C 4: (2: f:4 3: h:6) 9: (7: (5: map:1 6: f:4) 8: t:7)] | N -> 11: [N]}
//│ def ff:2 = 20: fun x:8 -> 19: case 15: x:8 of {K -> 16: [T] | KK -> 17: [TT] | KKKK -> 18: [TTTT]}
//│ def l:3 = 27: [C 21: [K] 26: [C 22: [KK] 25: [C 23: [KKKK] 24: [N]]]]
//│ 32: (30: (28: map:1 29: ff:2) 31: l:3)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((ff:2^29 ⋅ ɛ, (ɛ, 11'x) => ((ɛ, 12'19_matchres))), (map:1^28 ⋅ map:1^5 ⋅ map:1^5 ⋅ ɛ, 3'f)) :::: ((ff:2^29 ⋅ ɛ, (ɛ, 11'x) => ((ɛ, 12'19_matchres))), (map:1^28 ⋅ map:1^5 ⋅ ɛ, 3'f))
//│ ------- defInstance -------
//│ l:3^31 ⋅ ɛ ==> ff:2^29 ⋅ ɛ:
//│ 	21: [K]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ 	22: [KK]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ map:1^28 ⋅ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ map:1^5 ⋅ ff:2^29 ⋅ ɛ:
//│ 	23: [KKKK]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ map:1^28 ⋅ map:1^5 ⋅ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ ff:2^29 ⋅ ɛ:
//│ 	21: [K]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ ɛ:
//│ 	27: [C [K] [C [KK] [C [KKKK] [N]]]]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ map:1^5 ⋅ ɛ:
//│ 	25: [C [KKKK] [N]]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ map:1^28 ⋅ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ ff:2^29 ⋅ ɛ:
//│ 	22: [KK]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ 	23: [KKKK]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ map:1^5 ⋅ map:1^5 ⋅ ɛ:
//│ 	24: [N]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ ɛ:
//│ 	26: [C [KK] [C [KKKK] [N]]]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: 
//│ map:1^28 ⋅ l:3^31 ⋅ ɛ to `[KKKK]` 
//│ 	already has map:1^28 ⋅ map:1^5 ⋅ map:1^5 ⋅ ff:2^29 ⋅ ɛ to `case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}` 
//│ 	but here comes another match map:1^28 ⋅ map:1^5 ⋅ ff:2^29 ⋅ ɛ to `case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}`
//│ !!!!!!ERROR!!!!!!


// NOTE: some program not be able to write?
_LUMBERHACK_ERROR
fun last(ls) = if ls is
    C(h, t) then if t is
        N then Some(h)
        C(hh, tt) then last(t)
        // C(hh, tt) then last(C(hh, tt))
    N then None
let p = C(1, C(2, N))
last(p)
//│ |_LUMBERHACK_ERROR|↵|#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |last|(|t|)|↵|/* C(hh, tt) then last(C(hh, tt))*/|←|↵|N| |#then| |None|←|↵|#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|last|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun last = ls, => if ls is ‹(C (h, t,)) then if t is ‹(N) then Some (h,); (C (hh, tt,)) then last (t,)›; (N) then None›; let p = C (1, C (2, N,),); last (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def last:1 = 11: fun ls:3 -> 10: case 1: ls:3 of {C h:4 t:5 -> 8: case 2: t:5 of {N -> 4: [Some 3: h:4] | C hh:6 tt:7 -> 7: (5: last:1 6: t:5)} | N -> 9: [None]}
//│ def p:2 = 16: [C 12: 1 15: [C 13: 2 14: [N]]]
//│ 19: (17: last:1 18: p:2)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((last:1^5 ⋅ last:1^5 ⋅ ɛ, Some((ɛ, 3'h))), (ɛ, 7'7_callres)) :::: ((last:1^5 ⋅ ɛ, Some((ɛ, 3'h))), (ɛ, 7'7_callres))
//│ ((last:1^5 ⋅ last:1^5 ⋅ ɛ, None()), (ɛ, 7'7_callres)) :::: ((last:1^5 ⋅ ɛ, None()), (ɛ, 7'7_callres))
//│ ------- defInstance -------
//│ p:2^18 ⋅ ɛ ==> last:1^17 ⋅ ɛ:
//│ 	15: [C 2 [N]]  <-->  8: case t:5 of {N -> [Some h:4] | C hh:6 tt:7 -> (last:1 t:5)}
//│ 	16: [C 1 [C 2 [N]]]  <-->  10: case ls:3 of {C h:4 t:5 -> case t:5 of {N -> [Some h:4] | C hh:6 tt:7 -> (last:1 t:5)} | N -> [None]}
//│ p:2^18 ⋅ ɛ ==> last:1^17 ⋅ last:1^5 ⋅ ɛ:
//│ 	14: [N]  <-->  8: case t:5 of {N -> [Some h:4] | C hh:6 tt:7 -> (last:1 t:5)}
//│ 	15: [C 2 [N]]  <-->  10: case ls:3 of {C h:4 t:5 -> case t:5 of {N -> [Some h:4] | C hh:6 tt:7 -> (last:1 t:5)} | N -> [None]}
//│ p:2^18 ⋅ ɛ ==> last:1^17 ⋅ last:1^5 ⋅ last:1^5 ⋅ ɛ:
//│ 	14: [N]  <-->  10: case ls:3 of {C h:4 t:5 -> case t:5 of {N -> [Some h:4] | C hh:6 tt:7 -> (last:1 t:5)} | N -> [None]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: 
//│ p:2^18 ⋅ ɛ to `[C 2 [N]]` 
//│ 	already has last:1^17 ⋅ ɛ to `case t:5 of {N -> [Some h:4] | C hh:6 tt:7 -> (last:1 t:5)}` 
//│ 	but here comes another match last:1^17 ⋅ last:1^5 ⋅ ɛ to `case ls:3 of {C h:4 t:5 -> case t:5 of {N -> [Some h:4] | C hh:6 tt:7 -> (last:1 t:5)} | N -> [None]}`
//│ !!!!!!ERROR!!!!!!


