:NewParser
:ParseOnly
// one ctor matches to multiple dtors, or the reverse

// CORRECT:
fun f(c) = P(c(A), c(A))
f(a => if (if a is
  A then B) is
    B then 0)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|A|)|)|↵|f|(|a| |=>| |#if| |(|#if| |a| |is|→|A| |#then| |B|←|)| |is|→|B| |#then| |0|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (A,),); f (a, => if '(' if a is ‹(A) then B›, ')' is ‹(B) then 0›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9((fun a⁰ -> case case a⁰ of {
//│ 	A  => [B]} of {
//│ 	B  => 0}))
//│ def f(c⁰) = [P c⁰([A]) c⁰([A])]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^9] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀((fun a¹ -> case case a¹ of {
//│ 	A  => [B]} of {
//│ 	B  => 0}))
//│ def f_₀(c¹) = 
//│ 	[P c¹([A]) c¹([A])]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 18 --->
//│ 	case a¹ of {A  => [B]}: 28
//│ [A]: 21 --->
//│ 	case a¹ of {A  => [B]}: 28
//│ [B]: 27 --->
//│ 	case case a¹ of {A  => [B]} of {B  => 0}: 30
//│ ------------------
//│ case a¹ of {A  => [B]}: 28 --->
//│ 	[A]: 18
//│ 	[A]: 21
//│ case case a¹ of {A  => [B]} of {B  => 0}: 30 --->
//│ 	[B]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 18 --->
//│ 	case a¹ of {A  => [B]}: 28
//│ [A]: 21 --->
//│ 	case a¹ of {A  => [B]}: 28
//│ [B]: 27 --->
//│ 	case case a¹ of {A  => [B]} of {B  => 0}: 30
//│ ------------------
//│ case a¹ of {A  => [B]}: 28 --->
//│ 	[A]: 18
//│ 	[A]: 21
//│ case case a¹ of {A  => [B]} of {B  => 0}: 30 --->
//│ 	[B]: 27
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀((fun a² -> a²))
//│ def f_₀(c²) = 
//│ 	[P c²(0) c²(0)]
//│ <<<<<<< after fusion <<<<<<<


// CORRECT:
fun f(c) = P(c(A), c(B))
f(a => if a is
  A then B
  B then C)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>| |#if| |a| |is|→|A| |#then| |B|↵|B| |#then| |C|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => if a is ‹(A) then B; (B) then C›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9((fun a⁰ -> case a⁰ of {
//│ 	A  => [B]
//│ 	| B  => [C]}))
//│ def f(c⁰) = [P c⁰([A]) c⁰([B])]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^9] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀((fun a¹ -> case a¹ of {
//│ 	A  => [B]
//│ 	| B  => [C]}))
//│ def f_₀(c¹) = 
//│ 	[P c¹([A]) c¹([B])]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 17 --->
//│ 	case a¹ of {A  => [B] | B  => [C]}: 28
//│ [B]: 20 --->
//│ 	case a¹ of {A  => [B] | B  => [C]}: 28
//│ ------------------
//│ case a¹ of {A  => [B] | B  => [C]}: 28 --->
//│ 	[A]: 17
//│ 	[B]: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 17 --->
//│ 	case a¹ of {A  => [B] | B  => [C]}: 28
//│ [B]: 20 --->
//│ 	case a¹ of {A  => [B] | B  => [C]}: 28
//│ ------------------
//│ case a¹ of {A  => [B] | B  => [C]}: 28 --->
//│ 	[A]: 17
//│ 	[B]: 20
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀((fun a² -> a²))
//│ def f_₀(c²) = 
//│ 	[P c²([B]) c²([C])]
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
fun f(c) =
  let aa = A
  if aa is
    A then C
  P(c(A), c(aa))
f(a => if a is
  A then B)
//│ |#fun| |f|(|c|)| |#=|→|#let| |aa| |#=| |A|↵|#if| |aa| |is|→|A| |#then| |C|←|↵|P|(|c|(|A|)|,| |c|(|aa|)|)|←|↵|f|(|a| |=>| |#if| |a| |is|→|A| |#then| |B|←|)|
//│ Parsed: {fun f = c, => {let aa = A; if aa is ‹(A) then C›; P (c (A,), c (aa,),)}; f (a, => if a is ‹(A) then B›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^15((fun a⁰ -> case a⁰ of {
//│ 	A  => [B]}))
//│ def f(c⁰) = 
//│ 	let aa⁰ = [A]
//│ 	in case aa⁰ of {
//│ 	A  => [C]}
//│ 	[P c⁰([A]) c⁰(aa⁰)]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^15] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀((fun a¹ -> case a¹ of {
//│ 	A  => [B]}))
//│ def f_₀(c¹) = 
//│ 	let aa¹ = [A]
//│ 	in case aa¹ of {
//│ 	A  => [C]}
//│ 	[P c¹([A]) c¹(aa¹)]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 21 --->
//│ 	case aa¹ of {A  => [C]}: 24
//│ 	case a¹ of {A  => [B]}: 38
//│ [A]: 26 --->
//│ 	case a¹ of {A  => [B]}: 38
//│ ------------------
//│ case aa¹ of {A  => [C]}: 24 --->
//│ 	[A]: 21
//│ case a¹ of {A  => [B]}: 38 --->
//│ 	[A]: 21
//│ 	[A]: 26
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀((fun a² -> case a² of {
//│ 	A  => [B]}))
//│ def f_₀(c²) = 
//│ 	let aa² = [A]
//│ 	in case aa² of {
//│ 	A  => [C]}
//│ 	[P c²([A]) c²(aa²)]
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
fun f(c) = P(c(A), c(B))
f(a =>
  primitive(a)
  D(if a is
    A then B
    B then C))
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>|→|primitive|(|a|)|↵|D|(|#if| |a| |is|→|A| |#then| |B|↵|B| |#then| |C|←|)|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => {primitive (a,); D (if a is ‹(A) then B; (B) then C›,)},)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9((fun a⁰ -> 
//│ 	primitive⁰(a⁰)
//│ 	[D case a⁰ of {
//│ 		A  => [B]
//│ 		| B  => [C]}]))
//│ def f(c⁰) = [P c⁰([A]) c⁰([B])]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^9] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀((fun a¹ -> 
//│ 	primitive⁰(a¹)
//│ 	[D case a¹ of {
//│ 		A  => [B]
//│ 		| B  => [C]}]))
//│ def f_₀(c¹) = 
//│ 	[P c¹([A]) c¹([B])]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 22 --->
//│ 	NoCons
//│ 	case a¹ of {A  => [B] | B  => [C]}: 36
//│ [B]: 25 --->
//│ 	NoCons
//│ 	case a¹ of {A  => [B] | B  => [C]}: 36
//│ ------------------
//│ case a¹ of {A  => [B] | B  => [C]}: 36 --->
//│ 	[A]: 22
//│ 	[B]: 25
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀((fun a² -> 
//│ 	primitive⁰(a²)
//│ 	[D case a² of {
//│ 		A  => [B]
//│ 		| B  => [C]}]))
//│ def f_₀(c²) = 
//│ 	[P c²([A]) c²([B])]
//│ <<<<<<< after fusion <<<<<<<


// CORRECT:
fun f(c) = P(c(A), c(B))
f(a => if (if a is
  A then X
  B then Y) is
    X then 0
    Y then 1)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>| |#if| |(|#if| |a| |is|→|A| |#then| |X|↵|B| |#then| |Y|←|)| |is|→|X| |#then| |0|↵|Y| |#then| |1|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => if '(' if a is ‹(A) then X; (B) then Y›, ')' is ‹(X) then 0; (Y) then 1›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9((fun a⁰ -> case case a⁰ of {
//│ 	A  => [X]
//│ 	| B  => [Y]} of {
//│ 	X  => 0
//│ 	| Y  => 1}))
//│ def f(c⁰) = [P c⁰([A]) c⁰([B])]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^9] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀((fun a¹ -> case case a¹ of {
//│ 	A  => [X]
//│ 	| B  => [Y]} of {
//│ 	X  => 0
//│ 	| Y  => 1}))
//│ def f_₀(c¹) = 
//│ 	[P c¹([A]) c¹([B])]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 20 --->
//│ 	case a¹ of {A  => [X] | B  => [Y]}: 31
//│ [B]: 23 --->
//│ 	case a¹ of {A  => [X] | B  => [Y]}: 31
//│ [X]: 29 --->
//│ 	case case a¹ of {A  => [X] | B  => [Y]} of {X  => 0 | Y  => 1}: 34
//│ [Y]: 30 --->
//│ 	case case a¹ of {A  => [X] | B  => [Y]} of {X  => 0 | Y  => 1}: 34
//│ ------------------
//│ case a¹ of {A  => [X] | B  => [Y]}: 31 --->
//│ 	[A]: 20
//│ 	[B]: 23
//│ case case a¹ of {A  => [X] | B  => [Y]} of {X  => 0 | Y  => 1}: 34 --->
//│ 	[X]: 29
//│ 	[Y]: 30
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 20 --->
//│ 	case a¹ of {A  => [X] | B  => [Y]}: 31
//│ [B]: 23 --->
//│ 	case a¹ of {A  => [X] | B  => [Y]}: 31
//│ [X]: 29 --->
//│ 	case case a¹ of {A  => [X] | B  => [Y]} of {X  => 0 | Y  => 1}: 34
//│ [Y]: 30 --->
//│ 	case case a¹ of {A  => [X] | B  => [Y]} of {X  => 0 | Y  => 1}: 34
//│ ------------------
//│ case a¹ of {A  => [X] | B  => [Y]}: 31 --->
//│ 	[A]: 20
//│ 	[B]: 23
//│ case case a¹ of {A  => [X] | B  => [Y]} of {X  => 0 | Y  => 1}: 34 --->
//│ 	[X]: 29
//│ 	[Y]: 30
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀((fun a² -> a²))
//│ def f_₀(c²) = 
//│ 	[P c²(0) c²(1)]
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
// NOTE: as long as X or Y appears, it will do the fusion correctly
fun f(c) = P(c(A), c(B))
f(a => if (if a is
  A then X
  B then (if 1 > 2 then X else Y)) is
    X then 0
    Y then 1)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>| |#if| |(|#if| |a| |is|→|A| |#then| |X|↵|B| |#then| |(|#if| |1| |>| |2| |#then| |X| |#else| |Y|)|←|)| |is|→|X| |#then| |0|↵|Y| |#then| |1|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => if '(' if a is ‹(A) then X; (B) then '(' if (> (1,) (2,)) then X else Y, ')'›, ')' is ‹(X) then 0; (Y) then 1›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9((fun a⁰ -> case case a⁰ of {
//│ 	A  => [X]
//│ 	| B  => if (1 > 2) then [X] else [Y]} of {
//│ 	X  => 0
//│ 	| Y  => 1}))
//│ def f(c⁰) = [P c⁰([A]) c⁰([B])]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^9] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀((fun a¹ -> case case a¹ of {
//│ 	A  => [X]
//│ 	| B  => if (1 > 2) then [X] else [Y]} of {
//│ 	X  => 0
//│ 	| Y  => 1}))
//│ def f_₀(c¹) = 
//│ 	[P c¹([A]) c¹([B])]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 27 --->
//│ 	case a¹ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]}: 45
//│ [B]: 30 --->
//│ 	case a¹ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]}: 45
//│ [X]: 36 --->
//│ 	case case a¹ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 48
//│ [X]: 42 --->
//│ 	case case a¹ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 48
//│ [Y]: 43 --->
//│ 	case case a¹ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 48
//│ ------------------
//│ case a¹ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]}: 45 --->
//│ 	[A]: 27
//│ 	[B]: 30
//│ case case a¹ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 48 --->
//│ 	[X]: 36
//│ 	[X]: 42
//│ 	[Y]: 43
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 27 --->
//│ 	case a¹ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]}: 45
//│ [B]: 30 --->
//│ 	case a¹ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]}: 45
//│ [X]: 36 --->
//│ 	case case a¹ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 48
//│ [X]: 42 --->
//│ 	case case a¹ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 48
//│ [Y]: 43 --->
//│ 	case case a¹ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 48
//│ ------------------
//│ case a¹ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]}: 45 --->
//│ 	[A]: 27
//│ 	[B]: 30
//│ case case a¹ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 48 --->
//│ 	[X]: 36
//│ 	[X]: 42
//│ 	[Y]: 43
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀((fun a² -> a²(99)))
//│ def f_₀(c²) = 
//│ 	[P c²((fun _lh_dummy⁰ -> 0)) c²((fun _lh_dummy¹ -> if (1 > 2) then 0 else 1))]
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
// NOTE: but maybe can be further fused by the idea below
// NOTE: the outer match is "shadowed" by only one branch of the inner 
// maybe can try
// rewrite into the constructor, AND also + then use id strategy
// first, normal rewrite into ctor
// f(c) = P(c(X), c(primitive))
// f(a => if a is X then 0; Y then 1)
// ======> 
// second, rewrite into ctor with one of them being id strategy
// f(c) = P(c(0), c(if primitive is X then 0; Y then 1))
// f(a => a)
fun f(c) = P(c(A), c(B))
f(a => if (if a is
  A then X
  B then primitive) is // primitive: produce X or Y randomly
    X then 0
    Y then 1)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>| |#if| |(|#if| |a| |is|→|A| |#then| |X|↵|B| |#then| |primitive|←|)| |is| |/* primitive: produce X or Y randomly*/|→|X| |#then| |0|↵|Y| |#then| |1|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => if '(' if a is ‹(A) then X; (B) then primitive›, ')' is ‹(X) then 0; (Y) then 1›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9((fun a⁰ -> case case a⁰ of {
//│ 	A  => [X]
//│ 	| B  => primitive⁰} of {
//│ 	X  => 0
//│ 	| Y  => 1}))
//│ def f(c⁰) = [P c⁰([A]) c⁰([B])]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^9] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀((fun a¹ -> case case a¹ of {
//│ 	A  => [X]
//│ 	| B  => primitive⁰} of {
//│ 	X  => 0
//│ 	| Y  => 1}))
//│ def f_₀(c¹) = 
//│ 	[P c¹([A]) c¹([B])]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 20 --->
//│ 	case a¹ of {A  => [X] | B  => primitive⁰}: 31
//│ [B]: 23 --->
//│ 	case a¹ of {A  => [X] | B  => primitive⁰}: 31
//│ [X]: 29 --->
//│ 	case case a¹ of {A  => [X] | B  => primitive⁰} of {X  => 0 | Y  => 1}: 34
//│ ------------------
//│ case a¹ of {A  => [X] | B  => primitive⁰}: 31 --->
//│ 	[A]: 20
//│ 	[B]: 23
//│ case case a¹ of {A  => [X] | B  => primitive⁰} of {X  => 0 | Y  => 1}: 34 --->
//│ 	[X]: 29
//│ 	NoProd
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 20 --->
//│ 	case a¹ of {A  => [X] | B  => primitive⁰}: 31
//│ [B]: 23 --->
//│ 	case a¹ of {A  => [X] | B  => primitive⁰}: 31
//│ ------------------
//│ case a¹ of {A  => [X] | B  => primitive⁰}: 31 --->
//│ 	[A]: 20
//│ 	[B]: 23
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀((fun a² -> case a² of {
//│ 	X  => 0
//│ 	| Y  => 1}))
//│ def f_₀(c²) = 
//│ 	[P c²([X]) c²(primitive⁰)]
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
fun f(c) = P(c(X), c(primitive))
fun h(y) = if y is
  X then primitive
  Y then 2
fun g(x) =
  h(x)
  if x is
    X then 0
    Y then 1
f(a => g(a))
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|X|)|,| |c|(|primitive|)|)|↵|#fun| |h|(|y|)| |#=| |#if| |y| |is|→|X| |#then| |primitive|↵|Y| |#then| |2|←|↵|#fun| |g|(|x|)| |#=|→|h|(|x|)|↵|#if| |x| |is|→|X| |#then| |0|↵|Y| |#then| |1|←|←|↵|f|(|a| |=>| |g|(|a|)|)|
//│ Parsed: {fun f = c, => P (c (X,), c (primitive,),); fun h = y, => if y is ‹(X) then primitive; (Y) then 2›; fun g = x, => {h (x,); if x is ‹(X) then 0; (Y) then 1›}; f (a, => g (a,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^23((fun a⁰ -> g^24(a⁰)))
//│ def f(c⁰) = [P c⁰([X]) c⁰(primitive⁰)]
//│ def g(x⁰) = 
//│ 	h^14(x⁰)
//│ 	case x⁰ of {
//│ 		X  => 0
//│ 		| Y  => 1}
//│ def h(y⁰) = case y⁰ of {
//│ 	X  => primitive⁰
//│ 	| Y  => 2}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^23] (hopeless to continue)
//│ [g^24] (hopeless to continue)
//│ 	[g^24 · h^14] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀((fun a¹ -> g_₀(a¹)))
//│ def f_₀(c¹) = 
//│ 	[P c¹([X]) c¹(primitive⁰)]
//│ def g_₀(x¹) = 
//│ 	h_₀(x¹)
//│ 	case x¹ of {
//│ 		X  => 0
//│ 		| Y  => 1}
//│ 	where
//│ 	def h_₀(y¹) = 
//│ 		case y¹ of {
//│ 			X  => primitive⁰
//│ 			| Y  => 2}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [X]: 35 --->
//│ 	case y¹ of {X  => primitive⁰ | Y  => 2}: 32
//│ 	case x¹ of {X  => 0 | Y  => 1}: 48
//│ ------------------
//│ case y¹ of {X  => primitive⁰ | Y  => 2}: 32 --->
//│ 	[X]: 35
//│ 	NoProd
//│ case x¹ of {X  => 0 | Y  => 1}: 48 --->
//│ 	[X]: 35
//│ 	NoProd
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀((fun a² -> g_₀(a²)))
//│ def f_₀(c²) = 
//│ 	[P c²([X]) c²(primitive⁰)]
//│ def g_₀(x²) = 
//│ 	h_₀(x²)
//│ 	case x² of {
//│ 		X  => 0
//│ 		| Y  => 1}
//│ 	where
//│ 	def h_₀(y²) = 
//│ 		case y² of {
//│ 			X  => primitive⁰
//│ 			| Y  => 2}
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: after the detection and elimination of multiple matches
// NOTE: maybe we can try to rewrite into destructor? which is equivalent to copy the constructor
// f(cond) = cond
// g(y) = let y = K in y
// f(x => x)(C(K))
fun f(cond) = if cond is
    A then x => x 
    _ then x => g(x)
fun g(y) = if y is
    C(y) then y
f(A)(C(K))
//│ |#fun| |f|(|cond|)| |#=| |#if| |cond| |is|→|A| |#then| |x| |=>| |x| |↵|_| |#then| |x| |=>| |g|(|x|)|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|C|(|y|)| |#then| |y|←|↵|f|(|A|)|(|C|(|K|)|)|
//│ Parsed: {fun f = cond, => if cond is ‹(A) then x, => x; (_) then x, => g (x,)›; fun g = y, => if y is ‹(C (y,)) then y›; f (A,) (C (K,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^14([A], [C [K]])
//│ def f(cond⁰) = case cond⁰ of {
//│ 	A  => (fun x⁰ -> x⁰)
//│ 	| _  => (fun x¹ -> g^4(x¹))}
//│ def g(y⁰) = case y⁰ of {
//│ 	C y¹ => y¹}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^14] (hopeless to continue)
//│ 	[f^14 · g^4] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([A], [C [K]])
//│ def f_₀(cond¹) = 
//│ 	case cond¹ of {
//│ 		A  => (fun x² -> x²)
//│ 		| _  => (fun x³ -> g_₀(x³))}
//│ 	where
//│ 	def g_₀(y²) = 
//│ 		case y² of {
//│ 			C y³ => y³}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 34 --->
//│ 	case cond¹ of {A  => (fun x² -> x²) | _  => (fun x³ -> g_₀(x³))}: 27
//│ [C [K]]: 37 --->
//│ 	NoCons
//│ 	case y² of {C y³ => y³}: 31
//│ ------------------
//│ case cond¹ of {A  => (fun x² -> x²) | _  => (fun x³ -> g_₀(x³))}: 27 --->
//│ 	[A]: 34
//│ case y² of {C y³ => y³}: 31 --->
//│ 	[C [K]]: 37
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 34 --->
//│ 	case cond¹ of {A  => (fun x² -> x²) | _  => (fun x³ -> g_₀(x³))}: 27
//│ ------------------
//│ case cond¹ of {A  => (fun x² -> x²) | _  => (fun x³ -> g_₀(x³))}: 27 --->
//│ 	[A]: 34
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀((fun x⁴ -> x⁴), [C [K]])
//│ def f_₀(cond²) = 
//│ 	cond²
//│ 	where
//│ 	def g_₀(y⁴) = 
//│ 		case y⁴ of {
//│ 			C y³ => y³}
//│ <<<<<<< after fusion <<<<<<<


// WRONG: here, we duplicate the consumer at the current approach/lazy eval?
// fun c(x) = if x is
//   A then
//     primitive(X) // some complicated operations
//   B then
//     primitive(Y) // some complicated operations
// if 1 > 2 then c(A) else c(B)


// CORRECT: after the detection and elimination of multiple matches
// NOTE: rewrite into consumer for further fusion?
// f(x) = if primitive then x else g(x)
// g(y) = let a = A in a
// f(C(A))
fun f(x) = if primitive then x else g(x)
fun g(y) = if y is
    C(a) then a
f(C(A))
//│ |#fun| |f|(|x|)| |#=| |#if| |primitive| |#then| |x| |#else| |g|(|x|)|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|C|(|a|)| |#then| |a|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun f = x, => if (primitive) then x else g (x,); fun g = y, => if y is ‹(C (a,)) then a›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^12([C [A]])
//│ def f(x⁰) = if primitive⁰ then x⁰ else g^3(x⁰)
//│ def g(y⁰) = case y⁰ of {
//│ 	C a⁰ => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^12] (hopeless to continue)
//│ 	[f^12 · g^3] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([C [A]])
//│ def f_₀(x¹) = 
//│ 	if primitive⁰ then x¹ else g_₀(x¹)
//│ 	where
//│ 	def g_₀(y¹) = 
//│ 		case y¹ of {
//│ 			C a¹ => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 29 --->
//│ 	NoCons
//│ 	case y¹ of {C a¹ => a¹}: 18
//│ ------------------
//│ case y¹ of {C a¹ => a¹}: 18 --->
//│ 	[C [A]]: 29
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀([C [A]])
//│ def f_₀(x²) = 
//│ 	if primitive⁰ then x² else g_₀(x²)
//│ 	where
//│ 	def g_₀(y²) = 
//│ 		case y² of {
//│ 			C a¹ => a¹}
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
fun p(x) =
  if x == 0 then N
  else
    if x >= 2 then C(p(x - 1))
    else
      let temp = C(p(x + 1))
      f(temp)
      temp
fun f(z) = if z is
  C(b) then b
  N then 1
fun c(xx) = if xx is
  C(aa) then primitive(aa)
  N then N
c(p(0))
//│ |#fun| |p|(|x|)| |#=|→|#if| |x| |==| |0| |#then| |N|↵|#else|→|#if| |x| |>=| |2| |#then| |C|(|p|(|x| |-| |1|)|)|↵|#else|→|#let| |temp| |#=| |C|(|p|(|x| |+| |1|)|)|↵|f|(|temp|)|↵|temp|←|←|←|↵|#fun| |f|(|z|)| |#=| |#if| |z| |is|→|C|(|b|)| |#then| |b|↵|N| |#then| |1|←|↵|#fun| |c|(|xx|)| |#=| |#if| |xx| |is|→|C|(|aa|)| |#then| |primitive|(|aa|)|↵|N| |#then| |N|←|↵|c|(|p|(|0|)|)|
//│ Parsed: {fun p = x, => {if (== (x,) (0,)) then N else {if (>= (x,) (2,)) then C (p (- (x,) (1,),),) else {let temp = C (p (+ (x,) (1,),),); f (temp,); temp}}}; fun f = z, => if z is ‹(C (b,)) then b; (N) then 1›; fun c = xx, => if xx is ‹(C (aa,)) then primitive (aa,); (N) then N›; c (p (0,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^49(p^50(0))
//│ def c(xx⁰) = case xx⁰ of {
//│ 	C aa⁰ => primitive⁰(aa⁰)
//│ 	| N  => [N]}
//│ def f(z⁰) = case z⁰ of {
//│ 	C b⁰ => b⁰
//│ 	| N  => 1}
//│ def p(x⁰) = if (x⁰ == 0) then [N] else if (x⁰ >= 2) then [C p^12((x⁰ - 1))] else 
//│ 	let temp⁰ = [C p^20((x⁰ + 1))]
//│ 	in f^28(temp⁰)
//│ 	temp⁰
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^49] (hopeless to continue)
//│ [p^50] (hopeless to continue)
//│ 	[p^50 · f^28] (using original def)
//│ 	[p^50 · p^12] ---> [p^50] (using original def)
//│ 	[p^50 · p^20] ---> [p^50] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(p_₀(0))
//│ def c_₀(xx¹) = 
//│ 	case xx¹ of {
//│ 		C aa¹ => primitive⁰(aa¹)
//│ 		| N  => [N]}
//│ def p_₀(x¹) = 
//│ 	if (x¹ == 0) then [N] else if (x¹ >= 2) then [C p_₀((x¹ - 1))] else 
//│ 		let temp¹ = [C p_₀((x¹ + 1))]
//│ 		in f_₀(temp¹)
//│ 		temp¹
//│ 	where
//│ 	def f_₀(z¹) = 
//│ 		case z¹ of {
//│ 			C b¹ => b¹
//│ 			| N  => 1}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 71 --->
//│ 	DeadCodeCons
//│ 	NoCons
//│ 	case xx¹ of {C aa¹ => primitive⁰(aa¹) | N  => [N]}: 59
//│ [C p_₀((x¹ - 1))]: 84 --->
//│ 	DeadCodeCons
//│ 	NoCons
//│ 	case xx¹ of {C aa¹ => primitive⁰(aa¹) | N  => [N]}: 59
//│ [C p_₀((x¹ + 1))]: 92 --->
//│ 	DeadCodeCons
//│ 	NoCons
//│ 	case xx¹ of {C aa¹ => primitive⁰(aa¹) | N  => [N]}: 59
//│ 	case z¹ of {C b¹ => b¹ | N  => 1}: 64
//│ ------------------
//│ case xx¹ of {C aa¹ => primitive⁰(aa¹) | N  => [N]}: 59 --->
//│ 	[N]: 71
//│ 	[C p_₀((x¹ - 1))]: 84
//│ 	[C p_₀((x¹ + 1))]: 92
//│ case z¹ of {C b¹ => b¹ | N  => 1}: 64 --->
//│ 	[C p_₀((x¹ + 1))]: 92
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(p_₀(0))
//│ def c_₀(xx²) = 
//│ 	case xx² of {
//│ 		C aa¹ => primitive⁰(aa¹)
//│ 		| N  => [N]}
//│ def p_₀(x²) = 
//│ 	if (x² == 0) then [N] else if (x² >= 2) then [C p_₀((x² - 1))] else 
//│ 		let temp² = [C p_₀((x² + 1))]
//│ 		in f_₀(temp²)
//│ 		temp²
//│ 	where
//│ 	def f_₀(z²) = 
//│ 		case z² of {
//│ 			C b¹ => b¹
//│ 			| N  => 1}
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: after the detection and elimination of multiple matches
// NOTE: but maybe can be fused to this, by rewriting into the destructors
// f(xf) = if primitive then g(xf) else h(xf)
// g(xg) = G
// h(xh) = H
// f(C)
fun f(xf) = if primitive then g(xf) else h(xf)
fun g(xg) = if xg is
  C then G
fun h(xh) = if xh is
  C then H
f(C)
//│ |#fun| |f|(|xf|)| |#=| |#if| |primitive| |#then| |g|(|xf|)| |#else| |h|(|xf|)|↵|#fun| |g|(|xg|)| |#=| |#if| |xg| |is|→|C| |#then| |G|←|↵|#fun| |h|(|xh|)| |#=| |#if| |xh| |is|→|C| |#then| |H|←|↵|f|(|C|)|
//│ Parsed: {fun f = xf, => if (primitive) then g (xf,) else h (xf,); fun g = xg, => if xg is ‹(C) then G›; fun h = xh, => if xh is ‹(C) then H›; f (C,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^18([C])
//│ def f(xf⁰) = if primitive⁰ then g^2(xf⁰) else h^5(xf⁰)
//│ def g(xg⁰) = case xg⁰ of {
//│ 	C  => [G]}
//│ def h(xh⁰) = case xh⁰ of {
//│ 	C  => [H]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^18] (hopeless to continue)
//│ 	[f^18 · g^2] (using original def)
//│ 	[f^18 · h^5] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([C])
//│ def f_₀(xf¹) = 
//│ 	if primitive⁰ then g_₀(xf¹) else h_₀(xf¹)
//│ 	where
//│ 	def g_₀(xg¹) = 
//│ 		case xg¹ of {
//│ 			C  => [G]}
//│ 	def h_₀(xh¹) = 
//│ 		case xh¹ of {
//│ 			C  => [H]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C]: 39 --->
//│ 	case xg¹ of {C  => [G]}: 23
//│ 	case xh¹ of {C  => [H]}: 27
//│ ------------------
//│ case xg¹ of {C  => [G]}: 23 --->
//│ 	[C]: 39
//│ case xh¹ of {C  => [H]}: 27 --->
//│ 	[C]: 39
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀([C])
//│ def f_₀(xf²) = 
//│ 	if primitive⁰ then g_₀(xf²) else h_₀(xf²)
//│ 	where
//│ 	def g_₀(xg²) = 
//│ 		case xg² of {
//│ 			C  => [G]}
//│ 	def h_₀(xh²) = 
//│ 		case xh² of {
//│ 			C  => [H]}
//│ <<<<<<< after fusion <<<<<<<

// WRONG: wrong knots, because the knots are tied using only one
// of the many variables in this function definition
let rec t = T(X, T(Y, t, t), t)
fun f(x) = if x is
  T(a, l, r) then if r is
    T(b, ll, rr) then T(a, T(b, f(rr), f(ll)), f(l))
f(t)
//│ |#let| |#rec| |t| |#=| |T|(|X|,| |T|(|Y|,| |t|,| |t|)|,| |t|)|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|T|(|a|,| |l|,| |r|)| |#then| |#if| |r| |is|→|T|(|b|,| |ll|,| |rr|)| |#then| |T|(|a|,| |T|(|b|,| |f|(|rr|)|,| |f|(|ll|)|)|,| |f|(|l|)|)|←|←|↵|f|(|t|)|
//│ Parsed: {let rec t = T (X, T (Y, t, t,), t,); fun f = x, => if x is ‹(T (a, l, r,)) then if r is ‹(T (b, ll, rr,)) then T (a, T (b, f (rr,), f (ll,),), f (l,),)››; f (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^26(t^27)
//│ def f(x⁰) = case x⁰ of {
//│ 	T a⁰ l⁰ r⁰ => case r⁰ of {
//│ 		T b⁰ ll⁰ rr⁰ => [T a⁰ [T b⁰ f^12(rr⁰) f^15(ll⁰)] f^19(l⁰)]}}
//│ def t = [T [X] [T [Y] t^3 t^4] t^6]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^26] (hopeless to continue)
//│ 	[f^26 · f^12] ---> [f^26] (using original def)
//│ 	[f^26 · f^15] ---> [f^26] (using original def)
//│ 	[f^26 · f^19] ---> [f^26] (using original def)
//│ [t^27] (hopeless to continue)
//│ 	[t^27 · t^3] ---> [t^27] (using original def)
//│ 	[t^27 · t^4] ---> [t^27] (using original def)
//│ 	[t^27 · t^6] ---> [t^27] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀(t_₀)
//│ def f_₀(x¹) = 
//│ 	case x¹ of {
//│ 		T a¹ l¹ r¹ => case r¹ of {
//│ 			T b¹ ll¹ rr¹ => [T a¹ [T b¹ f_₀(rr¹) f_₀(ll¹)] f_₀(l¹)]}}
//│ def t_₀ = 
//│ 	[T [X] [T [Y] t_₀ t_₀] t_₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [T [Y] t_₀ t_₀]: 51 --->
//│ 	case x¹ of {T a¹ l¹ r¹ => case r¹ of {T b¹ ll¹ rr¹ => [T a¹ [T b¹ f_₀(rr¹) f_₀(ll¹)] f_₀(l¹)]}}: 45
//│ [T [X] [T [Y] t_₀ t_₀] t_₀]: 53 --->
//│ 	case r¹ of {T b¹ ll¹ rr¹ => [T a¹ [T b¹ f_₀(rr¹) f_₀(ll¹)] f_₀(l¹)]}: 44
//│ 	case x¹ of {T a¹ l¹ r¹ => case r¹ of {T b¹ ll¹ rr¹ => [T a¹ [T b¹ f_₀(rr¹) f_₀(ll¹)] f_₀(l¹)]}}: 45
//│ ------------------
//│ case r¹ of {T b¹ ll¹ rr¹ => [T a¹ [T b¹ f_₀(rr¹) f_₀(ll¹)] f_₀(l¹)]}: 44 --->
//│ 	[T [X] [T [Y] t_₀ t_₀] t_₀]: 53
//│ case x¹ of {T a¹ l¹ r¹ => case r¹ of {T b¹ ll¹ rr¹ => [T a¹ [T b¹ f_₀(rr¹) f_₀(ll¹)] f_₀(l¹)]}}: 45 --->
//│ 	[T [Y] t_₀ t_₀]: 51
//│ 	[T [X] [T [Y] t_₀ t_₀] t_₀]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀(t_₀)
//│ def f_₀(x²) = 
//│ 	case x² of {
//│ 		T a¹ l¹ r¹ => case r¹ of {
//│ 			T b¹ ll¹ rr¹ => [T a¹ [T b¹ f_₀(rr¹) f_₀(ll¹)] f_₀(l¹)]}}
//│ def t_₀ = 
//│ 	[T [X] [T [Y] t_₀ t_₀] t_₀]
//│ <<<<<<< after fusion <<<<<<<
