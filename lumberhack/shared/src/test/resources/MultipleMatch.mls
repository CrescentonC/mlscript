:NewParser
:ParseOnly
// one ctor matches to multiple dtors, or the reverse

// CORRECT:
fun f(c) = P(c(A), c(A))
f(a => if (if a is
  A then B) is
    B then 0)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|A|)|)|↵|f|(|a| |=>| |#if| |(|#if| |a| |is|→|A| |#then| |B|←|)| |is|→|B| |#then| |0|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (A,),); f (a, => if '(' if a is ‹(A) then B›, ')' is ‹(B) then 0›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9((fun a⁰ -> case case a⁰ of {
//│ 	A  => [B]} of {
//│ 	B  => 0}))
//│ def f(c⁰) = [P c⁰([A]) c⁰([A])]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 2 --->
//│ 	case a⁰ of {A  => [B]}: 12
//│ [A]: 5 --->
//│ 	case a⁰ of {A  => [B]}: 12
//│ [B]: 11 --->
//│ 	case case a⁰ of {A  => [B]} of {B  => 0}: 14
//│ ------------------
//│ case a⁰ of {A  => [B]}: 12 --->
//│ 	[A]: 2
//│ 	[A]: 5
//│ case case a⁰ of {A  => [B]} of {B  => 0}: 14 --->
//│ 	[B]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 2 --->
//│ 	case a⁰ of {A  => [B]}: 12
//│ [A]: 5 --->
//│ 	case a⁰ of {A  => [B]}: 12
//│ [B]: 11 --->
//│ 	case case a⁰ of {A  => [B]} of {B  => 0}: 14
//│ ------------------
//│ case a⁰ of {A  => [B]}: 12 --->
//│ 	[A]: 2
//│ 	[A]: 5
//│ case case a⁰ of {A  => [B]} of {B  => 0}: 14 --->
//│ 	[B]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f((fun a¹ -> a¹))
//│ def f(c¹) = [P c¹(0) c¹(0)]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ f -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f((fun a⁰ -> a⁰))
//│ def f(c⁰) = [P c⁰(0) c⁰(0)]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f((fun a⁰ -> a⁰))
//│ def f(c⁰) = [P c⁰(0) c⁰(0)]
//│ <<<<<<< after floating out <<<<<<<


// CORRECT:
fun f(c) = P(c(A), c(B))
f(a => if a is
  A then B
  B then C)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>| |#if| |a| |is|→|A| |#then| |B|↵|B| |#then| |C|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => if a is ‹(A) then B; (B) then C›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9((fun a⁰ -> case a⁰ of {
//│ 	A  => [B]
//│ 	| B  => [C]}))
//│ def f(c⁰) = [P c⁰([A]) c⁰([B])]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 2 --->
//│ 	case a⁰ of {A  => [B] | B  => [C]}: 13
//│ [B]: 5 --->
//│ 	case a⁰ of {A  => [B] | B  => [C]}: 13
//│ ------------------
//│ case a⁰ of {A  => [B] | B  => [C]}: 13 --->
//│ 	[A]: 2
//│ 	[B]: 5
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 2 --->
//│ 	case a⁰ of {A  => [B] | B  => [C]}: 13
//│ [B]: 5 --->
//│ 	case a⁰ of {A  => [B] | B  => [C]}: 13
//│ ------------------
//│ case a⁰ of {A  => [B] | B  => [C]}: 13 --->
//│ 	[A]: 2
//│ 	[B]: 5
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f((fun a¹ -> a¹))
//│ def f(c¹) = [P c¹([B]) c¹([C])]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ f -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f((fun a⁰ -> a⁰))
//│ def f(c⁰) = [P c⁰([B]) c⁰([C])]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f((fun a⁰ -> a⁰))
//│ def f(c⁰) = [P c⁰([B]) c⁰([C])]
//│ <<<<<<< after floating out <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
fun f(c) =
  let aa = A
  if aa is
    A then C
  P(c(A), c(aa))
f(a => if a is
  A then B)
//│ |#fun| |f|(|c|)| |#=|→|#let| |aa| |#=| |A|↵|#if| |aa| |is|→|A| |#then| |C|←|↵|P|(|c|(|A|)|,| |c|(|aa|)|)|←|↵|f|(|a| |=>| |#if| |a| |is|→|A| |#then| |B|←|)|
//│ Parsed: {fun f = c, => {let aa = A; if aa is ‹(A) then C›; P (c (A,), c (aa,),)}; f (a, => if a is ‹(A) then B›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^15((fun a⁰ -> case a⁰ of {
//│ 	A  => [B]}))
//│ def f(c⁰) = 
//│ 	let aa⁰ = [A]
//│ 	in case aa⁰ of {
//│ 	A  => [C]}
//│ 	[P c⁰([A]) c⁰(aa⁰)]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 1 --->
//│ 	case aa⁰ of {A  => [C]}: 4
//│ 	case a⁰ of {A  => [B]}: 18
//│ [A]: 6 --->
//│ 	case a⁰ of {A  => [B]}: 18
//│ ------------------
//│ case aa⁰ of {A  => [C]}: 4 --->
//│ 	[A]: 1
//│ case a⁰ of {A  => [B]}: 18 --->
//│ 	[A]: 1
//│ 	[A]: 6
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f((fun a¹ -> case a¹ of {
//│ 	A  => [B]}))
//│ def f(c¹) = 
//│ 	let aa¹ = [A]
//│ 	in case aa¹ of {
//│ 	A  => [C]}
//│ 	[P c¹([A]) c¹(aa¹)]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f((fun a⁰ -> case a⁰ of {
//│ 	A  => [B]}))
//│ def f(c⁰) = 
//│ 	let aa⁰ = [A]
//│ 	in case aa⁰ of {
//│ 	A  => [C]}
//│ 	[P c⁰([A]) c⁰(aa⁰)]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f((fun a⁰ -> case a⁰ of {
//│ 	A  => [B]}))
//│ def f(c⁰) = 
//│ 	let aa⁰ = [A]
//│ 	in case aa⁰ of {
//│ 	A  => [C]}
//│ 	[P c⁰([A]) c⁰(aa⁰)]
//│ <<<<<<< after floating out <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
fun f(c) = P(c(A), c(B))
f(a =>
  primitive(a)
  D(if a is
    A then B
    B then C))
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>|→|primitive|(|a|)|↵|D|(|#if| |a| |is|→|A| |#then| |B|↵|B| |#then| |C|←|)|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => {primitive (a,); D (if a is ‹(A) then B; (B) then C›,)},)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9((fun a⁰ -> 
//│ 	primitive⁰(a⁰)
//│ 	[D case a⁰ of {
//│ 		A  => [B]
//│ 		| B  => [C]}]))
//│ def f(c⁰) = [P c⁰([A]) c⁰([B])]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 2 --->
//│ 	NoCons
//│ 	case a⁰ of {A  => [B] | B  => [C]}: 16
//│ [B]: 5 --->
//│ 	NoCons
//│ 	case a⁰ of {A  => [B] | B  => [C]}: 16
//│ ------------------
//│ case a⁰ of {A  => [B] | B  => [C]}: 16 --->
//│ 	[A]: 2
//│ 	[B]: 5
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f((fun a¹ -> 
//│ 	primitive⁰(a¹)
//│ 	[D case a¹ of {
//│ 		A  => [B]
//│ 		| B  => [C]}]))
//│ def f(c¹) = [P c¹([A]) c¹([B])]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f((fun a⁰ -> 
//│ 	primitive⁰(a⁰)
//│ 	[D case a⁰ of {
//│ 		A  => [B]
//│ 		| B  => [C]}]))
//│ def f(c⁰) = [P c⁰([A]) c⁰([B])]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f((fun a⁰ -> 
//│ 	primitive⁰(a⁰)
//│ 	[D case a⁰ of {
//│ 		A  => [B]
//│ 		| B  => [C]}]))
//│ def f(c⁰) = [P c⁰([A]) c⁰([B])]
//│ <<<<<<< after floating out <<<<<<<


// CORRECT:
fun f(c) = P(c(A), c(B))
f(a => if (if a is
  A then X
  B then Y) is
    X then 0
    Y then 1)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>| |#if| |(|#if| |a| |is|→|A| |#then| |X|↵|B| |#then| |Y|←|)| |is|→|X| |#then| |0|↵|Y| |#then| |1|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => if '(' if a is ‹(A) then X; (B) then Y›, ')' is ‹(X) then 0; (Y) then 1›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9((fun a⁰ -> case case a⁰ of {
//│ 	A  => [X]
//│ 	| B  => [Y]} of {
//│ 	X  => 0
//│ 	| Y  => 1}))
//│ def f(c⁰) = [P c⁰([A]) c⁰([B])]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 2 --->
//│ 	case a⁰ of {A  => [X] | B  => [Y]}: 13
//│ [B]: 5 --->
//│ 	case a⁰ of {A  => [X] | B  => [Y]}: 13
//│ [X]: 11 --->
//│ 	case case a⁰ of {A  => [X] | B  => [Y]} of {X  => 0 | Y  => 1}: 16
//│ [Y]: 12 --->
//│ 	case case a⁰ of {A  => [X] | B  => [Y]} of {X  => 0 | Y  => 1}: 16
//│ ------------------
//│ case a⁰ of {A  => [X] | B  => [Y]}: 13 --->
//│ 	[A]: 2
//│ 	[B]: 5
//│ case case a⁰ of {A  => [X] | B  => [Y]} of {X  => 0 | Y  => 1}: 16 --->
//│ 	[X]: 11
//│ 	[Y]: 12
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 2 --->
//│ 	case a⁰ of {A  => [X] | B  => [Y]}: 13
//│ [B]: 5 --->
//│ 	case a⁰ of {A  => [X] | B  => [Y]}: 13
//│ [X]: 11 --->
//│ 	case case a⁰ of {A  => [X] | B  => [Y]} of {X  => 0 | Y  => 1}: 16
//│ [Y]: 12 --->
//│ 	case case a⁰ of {A  => [X] | B  => [Y]} of {X  => 0 | Y  => 1}: 16
//│ ------------------
//│ case a⁰ of {A  => [X] | B  => [Y]}: 13 --->
//│ 	[A]: 2
//│ 	[B]: 5
//│ case case a⁰ of {A  => [X] | B  => [Y]} of {X  => 0 | Y  => 1}: 16 --->
//│ 	[X]: 11
//│ 	[Y]: 12
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f((fun a¹ -> a¹))
//│ def f(c¹) = [P c¹(0) c¹(1)]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ f -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f((fun a⁰ -> a⁰))
//│ def f(c⁰) = [P c⁰(0) c⁰(1)]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f((fun a⁰ -> a⁰))
//│ def f(c⁰) = [P c⁰(0) c⁰(1)]
//│ <<<<<<< after floating out <<<<<<<

// CORRECT:
// NOTE: as long as X or Y appears, it will do the fusion correctly
fun f(c) = P(c(A), c(B))
f(a => if (if a is
  A then X
  B then (if 1 > 2 then X else Y)) is
    X then 0
    Y then 1)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>| |#if| |(|#if| |a| |is|→|A| |#then| |X|↵|B| |#then| |(|#if| |1| |>| |2| |#then| |X| |#else| |Y|)|←|)| |is|→|X| |#then| |0|↵|Y| |#then| |1|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => if '(' if a is ‹(A) then X; (B) then '(' if (> (1,) (2,)) then X else Y, ')'›, ')' is ‹(X) then 0; (Y) then 1›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9((fun a⁰ -> case case a⁰ of {
//│ 	A  => [X]
//│ 	| B  => if (1 > 2) then [X] else [Y]} of {
//│ 	X  => 0
//│ 	| Y  => 1}))
//│ def f(c⁰) = [P c⁰([A]) c⁰([B])]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 2 --->
//│ 	case a⁰ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]}: 20
//│ [B]: 5 --->
//│ 	case a⁰ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]}: 20
//│ [X]: 11 --->
//│ 	case case a⁰ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 23
//│ [X]: 17 --->
//│ 	case case a⁰ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 23
//│ [Y]: 18 --->
//│ 	case case a⁰ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 23
//│ ------------------
//│ case a⁰ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]}: 20 --->
//│ 	[A]: 2
//│ 	[B]: 5
//│ case case a⁰ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 23 --->
//│ 	[X]: 11
//│ 	[X]: 17
//│ 	[Y]: 18
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 2 --->
//│ 	case a⁰ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]}: 20
//│ [B]: 5 --->
//│ 	case a⁰ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]}: 20
//│ [X]: 11 --->
//│ 	case case a⁰ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 23
//│ [X]: 17 --->
//│ 	case case a⁰ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 23
//│ [Y]: 18 --->
//│ 	case case a⁰ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 23
//│ ------------------
//│ case a⁰ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]}: 20 --->
//│ 	[A]: 2
//│ 	[B]: 5
//│ case case a⁰ of {A  => [X] | B  => if (1 > 2) then [X] else [Y]} of {X  => 0 | Y  => 1}: 23 --->
//│ 	[X]: 11
//│ 	[X]: 17
//│ 	[Y]: 18
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f((fun a¹ -> a¹(99)))
//│ def f(c¹) = [P c¹((fun _lh_dummy⁰ -> 0)) c¹((fun _lh_dummy¹ -> if (1 > 2) then 0 else 1))]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ f -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f((fun a⁰ -> a⁰(99)))
//│ def f(c⁰) = [P c⁰((fun _lh_dummy⁰ -> 0)) c⁰((fun _lh_dummy¹ -> if (1 > 2) then 0 else 1))]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f((fun a⁰ -> a⁰(99)))
//│ def f(c⁰) = [P c⁰((fun _lh_dummy⁰ -> 0)) c⁰((fun _lh_dummy¹ -> if (1 > 2) then 0 else 1))]
//│ <<<<<<< after floating out <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
// NOTE: but maybe can be further fused by the idea below
// NOTE: the outer match is "shadowed" by only one branch of the inner 
// maybe can try
// rewrite into the constructor, AND also + then use id strategy
// first, normal rewrite into ctor
// f(c) = P(c(X), c(primitive))
// f(a => if a is X then 0; Y then 1)
// ======> 
// second, rewrite into ctor with one of them being id strategy
// f(c) = P(c(0), c(if primitive is X then 0; Y then 1))
// f(a => a)
fun f(c) = P(c(A), c(B))
f(a => if (if a is
  A then X
  B then primitive) is // primitive: produce X or Y randomly
    X then 0
    Y then 1)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>| |#if| |(|#if| |a| |is|→|A| |#then| |X|↵|B| |#then| |primitive|←|)| |is| |/* primitive: produce X or Y randomly*/|→|X| |#then| |0|↵|Y| |#then| |1|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => if '(' if a is ‹(A) then X; (B) then primitive›, ')' is ‹(X) then 0; (Y) then 1›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9((fun a⁰ -> case case a⁰ of {
//│ 	A  => [X]
//│ 	| B  => primitive⁰} of {
//│ 	X  => 0
//│ 	| Y  => 1}))
//│ def f(c⁰) = [P c⁰([A]) c⁰([B])]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 2 --->
//│ 	case a⁰ of {A  => [X] | B  => primitive⁰}: 13
//│ [B]: 5 --->
//│ 	case a⁰ of {A  => [X] | B  => primitive⁰}: 13
//│ [X]: 11 --->
//│ 	case case a⁰ of {A  => [X] | B  => primitive⁰} of {X  => 0 | Y  => 1}: 16
//│ ------------------
//│ case a⁰ of {A  => [X] | B  => primitive⁰}: 13 --->
//│ 	[A]: 2
//│ 	[B]: 5
//│ case case a⁰ of {A  => [X] | B  => primitive⁰} of {X  => 0 | Y  => 1}: 16 --->
//│ 	[X]: 11
//│ 	NoProd
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 2 --->
//│ 	case a⁰ of {A  => [X] | B  => primitive⁰}: 13
//│ [B]: 5 --->
//│ 	case a⁰ of {A  => [X] | B  => primitive⁰}: 13
//│ ------------------
//│ case a⁰ of {A  => [X] | B  => primitive⁰}: 13 --->
//│ 	[A]: 2
//│ 	[B]: 5
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f((fun a¹ -> case a¹ of {
//│ 	X  => 0
//│ 	| Y  => 1}))
//│ def f(c¹) = [P c¹([X]) c¹(primitive⁰)]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ f -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f((fun a⁰ -> case a⁰ of {
//│ 	X  => 0
//│ 	| Y  => 1}))
//│ def f(c⁰) = [P c⁰([X]) c⁰(primitive⁰)]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f((fun a⁰ -> case a⁰ of {
//│ 	X  => 0
//│ 	| Y  => 1}))
//│ def f(c⁰) = [P c⁰([X]) c⁰(primitive⁰)]
//│ <<<<<<< after floating out <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
fun f(c) = P(c(X), c(primitive))
fun h(y) = if y is
  X then primitive
  Y then 2
fun g(x) =
  h(x)
  if x is
    X then 0
    Y then 1
f(a => g(a))
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|X|)|,| |c|(|primitive|)|)|↵|#fun| |h|(|y|)| |#=| |#if| |y| |is|→|X| |#then| |primitive|↵|Y| |#then| |2|←|↵|#fun| |g|(|x|)| |#=|→|h|(|x|)|↵|#if| |x| |is|→|X| |#then| |0|↵|Y| |#then| |1|←|←|↵|f|(|a| |=>| |g|(|a|)|)|
//│ Parsed: {fun f = c, => P (c (X,), c (primitive,),); fun h = y, => if y is ‹(X) then primitive; (Y) then 2›; fun g = x, => {h (x,); if x is ‹(X) then 0; (Y) then 1›}; f (a, => g (a,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^23((fun a⁰ -> g^24(a⁰)))
//│ def f(c⁰) = [P c⁰([X]) c⁰(primitive⁰)]
//│ def g(x⁰) = 
//│ 	h^14(x⁰)
//│ 	case x⁰ of {
//│ 		X  => 0
//│ 		| Y  => 1}
//│ def h(y⁰) = case y⁰ of {
//│ 	X  => primitive⁰
//│ 	| Y  => 2}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [X]: 2 --->
//│ 	case y⁰ of {X  => primitive⁰ | Y  => 2}: 12
//│ 	case x⁰ of {X  => 0 | Y  => 1}: 20
//│ ------------------
//│ case y⁰ of {X  => primitive⁰ | Y  => 2}: 12 --->
//│ 	[X]: 2
//│ 	NoProd
//│ case x⁰ of {X  => 0 | Y  => 1}: 20 --->
//│ 	[X]: 2
//│ 	NoProd
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f((fun a¹ -> g(a¹)))
//│ def f(c¹) = [P c¹([X]) c¹(primitive⁰)]
//│ def g(x¹) = 
//│ 	h(x¹)
//│ 	case x¹ of {
//│ 		X  => 0
//│ 		| Y  => 1}
//│ def h(y¹) = case y¹ of {
//│ 	X  => primitive⁰
//│ 	| Y  => 2}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f((fun a⁰ -> g(a⁰)))
//│ def f(c⁰) = [P c⁰([X]) c⁰(primitive⁰)]
//│ def g(x⁰) = 
//│ 	h(x⁰)
//│ 	case x⁰ of {
//│ 		X  => 0
//│ 		| Y  => 1}
//│ def h(y⁰) = case y⁰ of {
//│ 	X  => primitive⁰
//│ 	| Y  => 2}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f((fun a⁰ -> g(a⁰)))
//│ def f(c⁰) = [P c⁰([X]) c⁰(primitive⁰)]
//│ def g(x⁰) = 
//│ 	h(x⁰)
//│ 	case x⁰ of {
//│ 		X  => 0
//│ 		| Y  => 1}
//│ def h(y⁰) = case y⁰ of {
//│ 	X  => primitive⁰
//│ 	| Y  => 2}
//│ <<<<<<< after floating out <<<<<<<


// CORRECT: after the detection and elimination of multiple matches
// NOTE: maybe we can try to rewrite into destructor? which is equivalent to copy the constructor
// f(cond) = cond
// g(y) = let y = K in y
// f(x => x)(C(K))
fun f(cond) = if cond is
    A then x => x 
    _ then x => g(x)
fun g(y) = if y is
    C(y) then y
f(A)(C(K))
//│ |#fun| |f|(|cond|)| |#=| |#if| |cond| |is|→|A| |#then| |x| |=>| |x| |↵|_| |#then| |x| |=>| |g|(|x|)|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|C|(|y|)| |#then| |y|←|↵|f|(|A|)|(|C|(|K|)|)|
//│ Parsed: {fun f = cond, => if cond is ‹(A) then x, => x; (_) then x, => g (x,)›; fun g = y, => if y is ‹(C (y,)) then y›; f (A,) (C (K,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^14([A], [C [K]])
//│ def f(cond⁰) = case cond⁰ of {
//│ 	A  => (fun x⁰ -> x⁰)
//│ 	| _  => (fun x¹ -> g^4(x¹))}
//│ def g(y⁰) = case y⁰ of {
//│ 	C y¹ => y¹}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 15 --->
//│ 	case cond⁰ of {A  => (fun x⁰ -> x⁰) | _  => (fun x¹ -> g(x¹))}: 8
//│ [C [K]]: 18 --->
//│ 	NoCons
//│ 	case y⁰ of {C y¹ => y¹}: 12
//│ ------------------
//│ case cond⁰ of {A  => (fun x⁰ -> x⁰) | _  => (fun x¹ -> g(x¹))}: 8 --->
//│ 	[A]: 15
//│ case y⁰ of {C y¹ => y¹}: 12 --->
//│ 	[C [K]]: 18
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 15 --->
//│ 	case cond⁰ of {A  => (fun x⁰ -> x⁰) | _  => (fun x¹ -> g(x¹))}: 8
//│ ------------------
//│ case cond⁰ of {A  => (fun x⁰ -> x⁰) | _  => (fun x¹ -> g(x¹))}: 8 --->
//│ 	[A]: 15
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f((fun x² -> x²), [C [K]])
//│ def f(cond¹) = cond¹
//│ def g(y²) = case y² of {
//│ 	C y¹ => y¹}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ f
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ [C [K]]
//│ def f(cond⁰) = cond⁰
//│ def g(y⁰) = case y⁰ of {
//│ 	C y¹ => y¹}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ [C [K]]
//│ def f(cond⁰) = cond⁰
//│ def g(y⁰) = case y⁰ of {
//│ 	C y¹ => y¹}
//│ <<<<<<< after floating out <<<<<<<


// WRONG: here, we duplicate the consumer at the current approach/lazy eval?
// fun c(x) = if x is
//   A then
//     primitive(X) // some complicated operations
//   B then
//     primitive(Y) // some complicated operations
// if 1 > 2 then c(A) else c(B)


// CORRECT: after the detection and elimination of multiple matches
// NOTE: rewrite into consumer for further fusion?
// f(x) = if primitive then x else g(x)
// g(y) = let a = A in a
// f(C(A))
fun f(x) = if primitive then x else g(x)
fun g(y) = if y is
    C(a) then a
f(C(A))
//│ |#fun| |f|(|x|)| |#=| |#if| |primitive| |#then| |x| |#else| |g|(|x|)|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|C|(|a|)| |#then| |a|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun f = x, => if (primitive) then x else g (x,); fun g = y, => if y is ‹(C (a,)) then a›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^12([C [A]])
//│ def f(x⁰) = if primitive⁰ then x⁰ else g^3(x⁰)
//│ def g(y⁰) = case y⁰ of {
//│ 	C a⁰ => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 14 --->
//│ 	NoCons
//│ 	case y⁰ of {C a⁰ => a⁰}: 10
//│ ------------------
//│ case y⁰ of {C a⁰ => a⁰}: 10 --->
//│ 	[C [A]]: 14
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C [A]])
//│ def f(x¹) = if primitive⁰ then x¹ else g(x¹)
//│ def g(y¹) = case y¹ of {
//│ 	C a⁰ => a⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f([C [A]])
//│ def f(x⁰) = if primitive⁰ then x⁰ else g(x⁰)
//│ def g(y⁰) = case y⁰ of {
//│ 	C a⁰ => a⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f([C [A]])
//│ def f(x⁰) = if primitive⁰ then x⁰ else g(x⁰)
//│ def g(y⁰) = case y⁰ of {
//│ 	C a⁰ => a⁰}
//│ <<<<<<< after floating out <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
fun p(x) =
  if x == 0 then N
  else
    if x >= 2 then C(p(x - 1))
    else
      let temp = C(p(x + 1))
      f(temp)
      temp
fun f(z) = if z is
  C(b) then b
  N then 1
fun c(xx) = if xx is
  C(aa) then primitive(aa)
  N then N
c(p(0))
//│ |#fun| |p|(|x|)| |#=|→|#if| |x| |==| |0| |#then| |N|↵|#else|→|#if| |x| |>=| |2| |#then| |C|(|p|(|x| |-| |1|)|)|↵|#else|→|#let| |temp| |#=| |C|(|p|(|x| |+| |1|)|)|↵|f|(|temp|)|↵|temp|←|←|←|↵|#fun| |f|(|z|)| |#=| |#if| |z| |is|→|C|(|b|)| |#then| |b|↵|N| |#then| |1|←|↵|#fun| |c|(|xx|)| |#=| |#if| |xx| |is|→|C|(|aa|)| |#then| |primitive|(|aa|)|↵|N| |#then| |N|←|↵|c|(|p|(|0|)|)|
//│ Parsed: {fun p = x, => {if (== (x,) (0,)) then N else {if (>= (x,) (2,)) then C (p (- (x,) (1,),),) else {let temp = C (p (+ (x,) (1,),),); f (temp,); temp}}}; fun f = z, => if z is ‹(C (b,)) then b; (N) then 1›; fun c = xx, => if xx is ‹(C (aa,)) then primitive (aa,); (N) then N›; c (p (0,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^49(p^50(0))
//│ def c(xx⁰) = case xx⁰ of {
//│ 	C aa⁰ => primitive⁰(aa⁰)
//│ 	| N  => [N]}
//│ def f(z⁰) = case z⁰ of {
//│ 	C b⁰ => b⁰
//│ 	| N  => 1}
//│ def p(x⁰) = if (x⁰ == 0) then [N] else if (x⁰ >= 2) then [C p^12((x⁰ - 1))] else 
//│ 	let temp⁰ = [C p^20((x⁰ + 1))]
//│ 	in f^28(temp⁰)
//│ 	temp⁰
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 6 --->
//│ 	NoCons
//│ 	DeadCodeCons
//│ 	case xx⁰ of {C aa⁰ => primitive⁰(aa⁰) | N  => [N]}: 47
//│ [C p((x⁰ - 1))]: 19 --->
//│ 	NoCons
//│ 	DeadCodeCons
//│ 	case xx⁰ of {C aa⁰ => primitive⁰(aa⁰) | N  => [N]}: 47
//│ [C p((x⁰ + 1))]: 27 --->
//│ 	DeadCodeCons
//│ 	NoCons
//│ 	case z⁰ of {C b⁰ => b⁰ | N  => 1}: 40
//│ 	case xx⁰ of {C aa⁰ => primitive⁰(aa⁰) | N  => [N]}: 47
//│ ------------------
//│ case z⁰ of {C b⁰ => b⁰ | N  => 1}: 40 --->
//│ 	[C p((x⁰ + 1))]: 27
//│ case xx⁰ of {C aa⁰ => primitive⁰(aa⁰) | N  => [N]}: 47 --->
//│ 	[N]: 6
//│ 	[C p((x⁰ - 1))]: 19
//│ 	[C p((x⁰ + 1))]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(p(0))
//│ def c(xx¹) = case xx¹ of {
//│ 	C aa⁰ => primitive⁰(aa⁰)
//│ 	| N  => [N]}
//│ def f(z¹) = case z¹ of {
//│ 	C b⁰ => b⁰
//│ 	| N  => 1}
//│ def p(x¹) = if (x¹ == 0) then [N] else if (x¹ >= 2) then [C p((x¹ - 1))] else 
//│ 	let temp¹ = [C p((x¹ + 1))]
//│ 	in f(temp¹)
//│ 	temp¹
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ c(p(0))
//│ def c(xx⁰) = case xx⁰ of {
//│ 	C aa⁰ => primitive⁰(aa⁰)
//│ 	| N  => [N]}
//│ def f(z⁰) = case z⁰ of {
//│ 	C b⁰ => b⁰
//│ 	| N  => 1}
//│ def p(x⁰) = if (x⁰ == 0) then [N] else if (x⁰ >= 2) then [C p((x⁰ - 1))] else 
//│ 	let temp⁰ = [C p((x⁰ + 1))]
//│ 	in f(temp⁰)
//│ 	temp⁰
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ c(p(0))
//│ def c(xx⁰) = case xx⁰ of {
//│ 	C aa⁰ => primitive⁰(aa⁰)
//│ 	| N  => [N]}
//│ def f(z⁰) = case z⁰ of {
//│ 	C b⁰ => b⁰
//│ 	| N  => 1}
//│ def p(x⁰) = if (x⁰ == 0) then [N] else if (x⁰ >= 2) then [C p((x⁰ - 1))] else 
//│ 	let temp⁰ = [C p((x⁰ + 1))]
//│ 	in f(temp⁰)
//│ 	temp⁰
//│ <<<<<<< after floating out <<<<<<<


// CORRECT: after the detection and elimination of multiple matches
// NOTE: but maybe can be fused to this, by rewriting into the destructors
// f(xf) = if primitive then g(xf) else h(xf)
// g(xg) = G
// h(xh) = H
// f(C)
fun f(xf) = if primitive then g(xf) else h(xf)
fun g(xg) = if xg is
  C then G
fun h(xh) = if xh is
  C then H
f(C)
//│ |#fun| |f|(|xf|)| |#=| |#if| |primitive| |#then| |g|(|xf|)| |#else| |h|(|xf|)|↵|#fun| |g|(|xg|)| |#=| |#if| |xg| |is|→|C| |#then| |G|←|↵|#fun| |h|(|xh|)| |#=| |#if| |xh| |is|→|C| |#then| |H|←|↵|f|(|C|)|
//│ Parsed: {fun f = xf, => if (primitive) then g (xf,) else h (xf,); fun g = xg, => if xg is ‹(C) then G›; fun h = xh, => if xh is ‹(C) then H›; f (C,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^18([C])
//│ def f(xf⁰) = if primitive⁰ then g^2(xf⁰) else h^5(xf⁰)
//│ def g(xg⁰) = case xg⁰ of {
//│ 	C  => [G]}
//│ def h(xh⁰) = case xh⁰ of {
//│ 	C  => [H]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C]: 19 --->
//│ 	case xg⁰ of {C  => [G]}: 12
//│ 	case xh⁰ of {C  => [H]}: 16
//│ ------------------
//│ case xg⁰ of {C  => [G]}: 12 --->
//│ 	[C]: 19
//│ case xh⁰ of {C  => [H]}: 16 --->
//│ 	[C]: 19
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C])
//│ def f(xf¹) = if primitive⁰ then g(xf¹) else h(xf¹)
//│ def g(xg¹) = case xg¹ of {
//│ 	C  => [G]}
//│ def h(xh¹) = case xh¹ of {
//│ 	C  => [H]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f([C])
//│ def f(xf⁰) = if primitive⁰ then g(xf⁰) else h(xf⁰)
//│ def g(xg⁰) = case xg⁰ of {
//│ 	C  => [G]}
//│ def h(xh⁰) = case xh⁰ of {
//│ 	C  => [H]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f([C])
//│ def f(xf⁰) = if primitive⁰ then g(xf⁰) else h(xf⁰)
//│ def g(xg⁰) = case xg⁰ of {
//│ 	C  => [G]}
//│ def h(xh⁰) = case xh⁰ of {
//│ 	C  => [H]}
//│ <<<<<<< after floating out <<<<<<<

// WRONG: wrong knots, because the knots are tied using only one
// of the many variables in this function definition
let rec t = T(X, T(Y, t, t), t)
fun f(x) = if x is
  T(a, l, r) then if r is
    T(b, ll, rr) then T(a, T(b, f(rr), f(ll)), f(l))
f(t)
//│ |#let| |#rec| |t| |#=| |T|(|X|,| |T|(|Y|,| |t|,| |t|)|,| |t|)|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|T|(|a|,| |l|,| |r|)| |#then| |#if| |r| |is|→|T|(|b|,| |ll|,| |rr|)| |#then| |T|(|a|,| |T|(|b|,| |f|(|rr|)|,| |f|(|ll|)|)|,| |f|(|l|)|)|←|←|↵|f|(|t|)|
//│ Parsed: {let rec t = T (X, T (Y, t, t,), t,); fun f = x, => if x is ‹(T (a, l, r,)) then if r is ‹(T (b, ll, rr,)) then T (a, T (b, f (rr,), f (ll,),), f (l,),)››; f (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^26(t^27)
//│ def f(x⁰) = case x⁰ of {
//│ 	T a⁰ l⁰ r⁰ => case r⁰ of {
//│ 		T b⁰ ll⁰ rr⁰ => [T a⁰ [T b⁰ f^12(rr⁰) f^15(ll⁰)] f^19(l⁰)]}}
//│ def t = [T [X] [T [Y] t^3 t^4] t^6]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [T [Y] t t]: 5 --->
//│ 	case x⁰ of {T a⁰ l⁰ r⁰ => case r⁰ of {T b⁰ ll⁰ rr⁰ => [T a⁰ [T b⁰ f(rr⁰) f(ll⁰)] f(l⁰)]}}: 24
//│ [T [X] [T [Y] t t] t]: 7 --->
//│ 	case r⁰ of {T b⁰ ll⁰ rr⁰ => [T a⁰ [T b⁰ f(rr⁰) f(ll⁰)] f(l⁰)]}: 23
//│ 	case x⁰ of {T a⁰ l⁰ r⁰ => case r⁰ of {T b⁰ ll⁰ rr⁰ => [T a⁰ [T b⁰ f(rr⁰) f(ll⁰)] f(l⁰)]}}: 24
//│ ------------------
//│ case r⁰ of {T b⁰ ll⁰ rr⁰ => [T a⁰ [T b⁰ f(rr⁰) f(ll⁰)] f(l⁰)]}: 23 --->
//│ 	[T [X] [T [Y] t t] t]: 7
//│ case x⁰ of {T a⁰ l⁰ r⁰ => case r⁰ of {T b⁰ ll⁰ rr⁰ => [T a⁰ [T b⁰ f(rr⁰) f(ll⁰)] f(l⁰)]}}: 24 --->
//│ 	[T [Y] t t]: 5
//│ 	[T [X] [T [Y] t t] t]: 7
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f(t)
//│ def f(x¹) = case x¹ of {
//│ 	T a⁰ l⁰ r⁰ => case r⁰ of {
//│ 		T b⁰ ll⁰ rr⁰ => [T a⁰ [T b⁰ f(rr⁰) f(ll⁰)] f(l⁰)]}}
//│ def t = [T [X] [T [Y] t t] t]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f(t)
//│ def f(x⁰) = case x⁰ of {
//│ 	T a⁰ l⁰ r⁰ => case r⁰ of {
//│ 		T b⁰ ll⁰ rr⁰ => [T a⁰ [T b⁰ f(rr⁰) f(ll⁰)] f(l⁰)]}}
//│ def t = [T [X] [T [Y] t t] t]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f(t)
//│ def f(x⁰) = case x⁰ of {
//│ 	T a⁰ l⁰ r⁰ => case r⁰ of {
//│ 		T b⁰ ll⁰ rr⁰ => [T a⁰ [T b⁰ f(rr⁰) f(ll⁰)] f(l⁰)]}}
//│ def t = [T [X] [T [Y] t t] t]
//│ <<<<<<< after floating out <<<<<<<
