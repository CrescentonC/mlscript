:NewParser
:ParseOnly
// one ctor matches to multiple dtors, or the reverse

// CORRECT:
fun f(c) = P(c(A), c(A))
f(a => if (if a is
  A then B) is
    B then 0)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|A|)|)|↵|f|(|a| |=>| |#if| |(|#if| |a| |is|→|A| |#then| |B|←|)| |is|→|B| |#then| |0|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (A,),); f (a, => if '(' if a is ‹(A) then B›, ')' is ‹(B) then 0›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^9 (fun a⁰ -> case case a⁰ of {
//│ 	A => [B]} of {
//│ 	B => 0}))
//│ def f = (fun c⁰ -> [P (c⁰ [A]) (c⁰ [A])])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^9] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ (fun a¹ -> case case a¹ of {
//│ 	A => [B]} of {
//│ 	B => 0}))
//│ def f₀ = 
//│ 	(fun c¹ -> [P (c¹ [A]) (c¹ [A])])
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 18 --->
//│ 	case a¹ of {A => [B]}: 28
//│ [A]: 21 --->
//│ 	case a¹ of {A => [B]}: 28
//│ [B]: 27 --->
//│ 	case case a¹ of {A => [B]} of {B => 0}: 30
//│ ------------------
//│ case a¹ of {A => [B]}: 28 --->
//│ 	[A]: 18
//│ 	[A]: 21
//│ case case a¹ of {A => [B]} of {B => 0}: 30 --->
//│ 	[B]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 18 --->
//│ 	case a¹ of {A => [B]}: 28
//│ [A]: 21 --->
//│ 	case a¹ of {A => [B]}: 28
//│ [B]: 27 --->
//│ 	case case a¹ of {A => [B]} of {B => 0}: 30
//│ ------------------
//│ case a¹ of {A => [B]}: 28 --->
//│ 	[A]: 18
//│ 	[A]: 21
//│ case case a¹ of {A => [B]} of {B => 0}: 30 --->
//│ 	[B]: 27
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ (fun a² -> a²))
//│ def f₀ = 
//│ 	(fun c² -> [P (c² 0) (c² 0)])
//│ <<<<<<< after fusion <<<<<<<


// CORRECT:
fun f(c) = P(c(A), c(B))
f(a => if a is
  A then B
  B then C)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>| |#if| |a| |is|→|A| |#then| |B|↵|B| |#then| |C|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => if a is ‹(A) then B; (B) then C›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^9 (fun a⁰ -> case a⁰ of {
//│ 	A => [B]
//│ 	| B => [C]}))
//│ def f = (fun c⁰ -> [P (c⁰ [A]) (c⁰ [B])])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^9] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ (fun a¹ -> case a¹ of {
//│ 	A => [B]
//│ 	| B => [C]}))
//│ def f₀ = 
//│ 	(fun c¹ -> [P (c¹ [A]) (c¹ [B])])
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 17 --->
//│ 	case a¹ of {A => [B] | B => [C]}: 28
//│ [B]: 20 --->
//│ 	case a¹ of {A => [B] | B => [C]}: 28
//│ ------------------
//│ case a¹ of {A => [B] | B => [C]}: 28 --->
//│ 	[A]: 17
//│ 	[B]: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 17 --->
//│ 	case a¹ of {A => [B] | B => [C]}: 28
//│ [B]: 20 --->
//│ 	case a¹ of {A => [B] | B => [C]}: 28
//│ ------------------
//│ case a¹ of {A => [B] | B => [C]}: 28 --->
//│ 	[A]: 17
//│ 	[B]: 20
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ (fun a² -> a²))
//│ def f₀ = 
//│ 	(fun c² -> [P (c² [B]) (c² [C])])
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
fun f(c) =
  let aa = A
  if aa is
    A then C
  P(c(A), c(aa))
f(a => if a is
  A then B)
//│ |#fun| |f|(|c|)| |#=|→|#let| |aa| |#=| |A|↵|#if| |aa| |is|→|A| |#then| |C|←|↵|P|(|c|(|A|)|,| |c|(|aa|)|)|←|↵|f|(|a| |=>| |#if| |a| |is|→|A| |#then| |B|←|)|
//│ Parsed: {fun f = c, => {let aa = A; if aa is ‹(A) then C›; P (c (A,), c (aa,),)}; f (a, => if a is ‹(A) then B›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^15 (fun a⁰ -> case a⁰ of {
//│ 	A => [B]}))
//│ def f = (fun c⁰ -> 
//│ 	let aa⁰ = [A]
//│ 	in case aa⁰ of {
//│ 	A => [C]}
//│ 	[P (c⁰ [A]) (c⁰ aa⁰)])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^15] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ (fun a¹ -> case a¹ of {
//│ 	A => [B]}))
//│ def f₀ = 
//│ 	(fun c¹ -> 
//│ 		let aa¹ = [A]
//│ 		in case aa¹ of {
//│ 		A => [C]}
//│ 		[P (c¹ [A]) (c¹ aa¹)])
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 21 --->
//│ 	case aa¹ of {A => [C]}: 24
//│ 	case a¹ of {A => [B]}: 38
//│ [A]: 26 --->
//│ 	case a¹ of {A => [B]}: 38
//│ ------------------
//│ case aa¹ of {A => [C]}: 24 --->
//│ 	[A]: 21
//│ case a¹ of {A => [B]}: 38 --->
//│ 	[A]: 21
//│ 	[A]: 26
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ (fun a² -> case a² of {
//│ 	A => [B]}))
//│ def f₀ = 
//│ 	(fun c² -> 
//│ 		let aa² = [A]
//│ 		in case aa² of {
//│ 		A => [C]}
//│ 		[P (c² [A]) (c² aa²)])
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
fun f(c) = P(c(A), c(B))
f(a =>
  primitive(a)
  D(if a is
    A then B
    B then C))
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>|→|primitive|(|a|)|↵|D|(|#if| |a| |is|→|A| |#then| |B|↵|B| |#then| |C|←|)|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => {primitive (a,); D (if a is ‹(A) then B; (B) then C›,)},)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^9 (fun a⁰ -> 
//│ 	(primitive⁰ a⁰)
//│ 	[D case a⁰ of {
//│ 		A => [B]
//│ 		| B => [C]}]))
//│ def f = (fun c⁰ -> [P (c⁰ [A]) (c⁰ [B])])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^9] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ (fun a¹ -> 
//│ 	(primitive⁰ a¹)
//│ 	[D case a¹ of {
//│ 		A => [B]
//│ 		| B => [C]}]))
//│ def f₀ = 
//│ 	(fun c¹ -> [P (c¹ [A]) (c¹ [B])])
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 22 --->
//│ 	NoCons
//│ 	case a¹ of {A => [B] | B => [C]}: 36
//│ [B]: 25 --->
//│ 	NoCons
//│ 	case a¹ of {A => [B] | B => [C]}: 36
//│ ------------------
//│ case a¹ of {A => [B] | B => [C]}: 36 --->
//│ 	[A]: 22
//│ 	[B]: 25
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ (fun a² -> 
//│ 	(primitive⁰ a²)
//│ 	[D case a² of {
//│ 		A => [B]
//│ 		| B => [C]}]))
//│ def f₀ = 
//│ 	(fun c² -> [P (c² [A]) (c² [B])])
//│ <<<<<<< after fusion <<<<<<<


// CORRECT:
fun f(c) = P(c(A), c(B))
f(a => if (if a is
  A then X
  B then Y) is
    X then 0
    Y then 1)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>| |#if| |(|#if| |a| |is|→|A| |#then| |X|↵|B| |#then| |Y|←|)| |is|→|X| |#then| |0|↵|Y| |#then| |1|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => if '(' if a is ‹(A) then X; (B) then Y›, ')' is ‹(X) then 0; (Y) then 1›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^9 (fun a⁰ -> case case a⁰ of {
//│ 	A => [X]
//│ 	| B => [Y]} of {
//│ 	X => 0
//│ 	| Y => 1}))
//│ def f = (fun c⁰ -> [P (c⁰ [A]) (c⁰ [B])])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^9] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ (fun a¹ -> case case a¹ of {
//│ 	A => [X]
//│ 	| B => [Y]} of {
//│ 	X => 0
//│ 	| Y => 1}))
//│ def f₀ = 
//│ 	(fun c¹ -> [P (c¹ [A]) (c¹ [B])])
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 20 --->
//│ 	case a¹ of {A => [X] | B => [Y]}: 31
//│ [B]: 23 --->
//│ 	case a¹ of {A => [X] | B => [Y]}: 31
//│ [X]: 29 --->
//│ 	case case a¹ of {A => [X] | B => [Y]} of {X => 0 | Y => 1}: 34
//│ [Y]: 30 --->
//│ 	case case a¹ of {A => [X] | B => [Y]} of {X => 0 | Y => 1}: 34
//│ ------------------
//│ case a¹ of {A => [X] | B => [Y]}: 31 --->
//│ 	[A]: 20
//│ 	[B]: 23
//│ case case a¹ of {A => [X] | B => [Y]} of {X => 0 | Y => 1}: 34 --->
//│ 	[X]: 29
//│ 	[Y]: 30
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 20 --->
//│ 	case a¹ of {A => [X] | B => [Y]}: 31
//│ [B]: 23 --->
//│ 	case a¹ of {A => [X] | B => [Y]}: 31
//│ [X]: 29 --->
//│ 	case case a¹ of {A => [X] | B => [Y]} of {X => 0 | Y => 1}: 34
//│ [Y]: 30 --->
//│ 	case case a¹ of {A => [X] | B => [Y]} of {X => 0 | Y => 1}: 34
//│ ------------------
//│ case a¹ of {A => [X] | B => [Y]}: 31 --->
//│ 	[A]: 20
//│ 	[B]: 23
//│ case case a¹ of {A => [X] | B => [Y]} of {X => 0 | Y => 1}: 34 --->
//│ 	[X]: 29
//│ 	[Y]: 30
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ (fun a² -> a²))
//│ def f₀ = 
//│ 	(fun c² -> [P (c² 0) (c² 1)])
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
// NOTE: as long as X or Y appears, it will do the fusion correctly
fun f(c) = P(c(A), c(B))
f(a => if (if a is
  A then X
  B then (if 1 > 2 then X else Y)) is
    X then 0
    Y then 1)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>| |#if| |(|#if| |a| |is|→|A| |#then| |X|↵|B| |#then| |(|#if| |1| |>| |2| |#then| |X| |#else| |Y|)|←|)| |is|→|X| |#then| |0|↵|Y| |#then| |1|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => if '(' if a is ‹(A) then X; (B) then '(' if (> (1,) (2,)) then X else Y, ')'›, ')' is ‹(X) then 0; (Y) then 1›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^9 (fun a⁰ -> case case a⁰ of {
//│ 	A => [X]
//│ 	| B => if (1 > 2) then [X] else [Y]} of {
//│ 	X => 0
//│ 	| Y => 1}))
//│ def f = (fun c⁰ -> [P (c⁰ [A]) (c⁰ [B])])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^9] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ (fun a¹ -> case case a¹ of {
//│ 	A => [X]
//│ 	| B => if (1 > 2) then [X] else [Y]} of {
//│ 	X => 0
//│ 	| Y => 1}))
//│ def f₀ = 
//│ 	(fun c¹ -> [P (c¹ [A]) (c¹ [B])])
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 27 --->
//│ 	case a¹ of {A => [X] | B => if (1 > 2) then [X] else [Y]}: 45
//│ [B]: 30 --->
//│ 	case a¹ of {A => [X] | B => if (1 > 2) then [X] else [Y]}: 45
//│ [X]: 36 --->
//│ 	case case a¹ of {A => [X] | B => if (1 > 2) then [X] else [Y]} of {X => 0 | Y => 1}: 48
//│ [X]: 42 --->
//│ 	case case a¹ of {A => [X] | B => if (1 > 2) then [X] else [Y]} of {X => 0 | Y => 1}: 48
//│ [Y]: 43 --->
//│ 	case case a¹ of {A => [X] | B => if (1 > 2) then [X] else [Y]} of {X => 0 | Y => 1}: 48
//│ ------------------
//│ case a¹ of {A => [X] | B => if (1 > 2) then [X] else [Y]}: 45 --->
//│ 	[A]: 27
//│ 	[B]: 30
//│ case case a¹ of {A => [X] | B => if (1 > 2) then [X] else [Y]} of {X => 0 | Y => 1}: 48 --->
//│ 	[X]: 36
//│ 	[X]: 42
//│ 	[Y]: 43
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 27 --->
//│ 	case a¹ of {A => [X] | B => if (1 > 2) then [X] else [Y]}: 45
//│ [B]: 30 --->
//│ 	case a¹ of {A => [X] | B => if (1 > 2) then [X] else [Y]}: 45
//│ [X]: 36 --->
//│ 	case case a¹ of {A => [X] | B => if (1 > 2) then [X] else [Y]} of {X => 0 | Y => 1}: 48
//│ [X]: 42 --->
//│ 	case case a¹ of {A => [X] | B => if (1 > 2) then [X] else [Y]} of {X => 0 | Y => 1}: 48
//│ [Y]: 43 --->
//│ 	case case a¹ of {A => [X] | B => if (1 > 2) then [X] else [Y]} of {X => 0 | Y => 1}: 48
//│ ------------------
//│ case a¹ of {A => [X] | B => if (1 > 2) then [X] else [Y]}: 45 --->
//│ 	[A]: 27
//│ 	[B]: 30
//│ case case a¹ of {A => [X] | B => if (1 > 2) then [X] else [Y]} of {X => 0 | Y => 1}: 48 --->
//│ 	[X]: 36
//│ 	[X]: 42
//│ 	[Y]: 43
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ (fun a² -> a²))
//│ def f₀ = 
//│ 	(fun c² -> [P (c² 0) (c² if (1 > 2) then 0 else 1)])
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
// NOTE: but maybe can be further fused by the idea below
// NOTE: the outer match is "shadowed" by only one branch of the inner 
// maybe can try
// rewrite into the constructor, AND also + then use id strategy
// first, normal rewrite into ctor
// f(c) = P(c(X), c(primitive))
// f(a => if a is X then 0; Y then 1)
// ======> 
// second, rewrite into ctor with one of them being id strategy
// f(c) = P(c(0), c(if primitive is X then 0; Y then 1))
// f(a => a)
fun f(c) = P(c(A), c(B))
f(a => if (if a is
  A then X
  B then primitive) is // primitive: produce X or Y randomly
    X then 0
    Y then 1)
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|A|)|,| |c|(|B|)|)|↵|f|(|a| |=>| |#if| |(|#if| |a| |is|→|A| |#then| |X|↵|B| |#then| |primitive|←|)| |is| |/* primitive: produce X or Y randomly*/|→|X| |#then| |0|↵|Y| |#then| |1|←|)|
//│ Parsed: {fun f = c, => P (c (A,), c (B,),); f (a, => if '(' if a is ‹(A) then X; (B) then primitive›, ')' is ‹(X) then 0; (Y) then 1›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^9 (fun a⁰ -> case case a⁰ of {
//│ 	A => [X]
//│ 	| B => primitive⁰} of {
//│ 	X => 0
//│ 	| Y => 1}))
//│ def f = (fun c⁰ -> [P (c⁰ [A]) (c⁰ [B])])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^9] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ (fun a¹ -> case case a¹ of {
//│ 	A => [X]
//│ 	| B => primitive⁰} of {
//│ 	X => 0
//│ 	| Y => 1}))
//│ def f₀ = 
//│ 	(fun c¹ -> [P (c¹ [A]) (c¹ [B])])
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 20 --->
//│ 	case a¹ of {A => [X] | B => primitive⁰}: 31
//│ [B]: 23 --->
//│ 	case a¹ of {A => [X] | B => primitive⁰}: 31
//│ [X]: 29 --->
//│ 	case case a¹ of {A => [X] | B => primitive⁰} of {X => 0 | Y => 1}: 34
//│ ------------------
//│ case a¹ of {A => [X] | B => primitive⁰}: 31 --->
//│ 	[A]: 20
//│ 	[B]: 23
//│ case case a¹ of {A => [X] | B => primitive⁰} of {X => 0 | Y => 1}: 34 --->
//│ 	[X]: 29
//│ 	NoProd
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 20 --->
//│ 	case a¹ of {A => [X] | B => primitive⁰}: 31
//│ [B]: 23 --->
//│ 	case a¹ of {A => [X] | B => primitive⁰}: 31
//│ ------------------
//│ case a¹ of {A => [X] | B => primitive⁰}: 31 --->
//│ 	[A]: 20
//│ 	[B]: 23
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ (fun a² -> case a² of {
//│ 	X => 0
//│ 	| Y => 1}))
//│ def f₀ = 
//│ 	(fun c² -> [P (c² [X]) (c² primitive⁰)])
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
fun f(c) = P(c(X), c(primitive))
fun h(y) = if y is
  X then primitive
  Y then 2
fun g(x) =
  h(x)
  if x is
    X then 0
    Y then 1
f(a => g(a))
//│ |#fun| |f|(|c|)| |#=| |P|(|c|(|X|)|,| |c|(|primitive|)|)|↵|#fun| |h|(|y|)| |#=| |#if| |y| |is|→|X| |#then| |primitive|↵|Y| |#then| |2|←|↵|#fun| |g|(|x|)| |#=|→|h|(|x|)|↵|#if| |x| |is|→|X| |#then| |0|↵|Y| |#then| |1|←|←|↵|f|(|a| |=>| |g|(|a|)|)|
//│ Parsed: {fun f = c, => P (c (X,), c (primitive,),); fun h = y, => if y is ‹(X) then primitive; (Y) then 2›; fun g = x, => {h (x,); if x is ‹(X) then 0; (Y) then 1›}; f (a, => g (a,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^23 (fun a⁰ -> (g^24 a⁰)))
//│ def f = (fun c⁰ -> [P (c⁰ [X]) (c⁰ primitive⁰)])
//│ def g = (fun x⁰ -> 
//│ 	(h^14 x⁰)
//│ 	case x⁰ of {
//│ 		X => 0
//│ 		| Y => 1})
//│ def h = (fun y⁰ -> case y⁰ of {
//│ 	X => primitive⁰
//│ 	| Y => 2})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^23] (hopeless to continue)
//│ [g^24] (hopeless to continue)
//│ 	[g^24 · h^14] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ (fun a¹ -> (g₀ a¹)))
//│ def f₀ = 
//│ 	(fun c¹ -> [P (c¹ [X]) (c¹ primitive⁰)])
//│ def g₀ = 
//│ 	(fun x¹ -> 
//│ 		(h₀ x¹)
//│ 		case x¹ of {
//│ 			X => 0
//│ 			| Y => 1})
//│ 	where
//│ 	def h₀ = 
//│ 		(fun y¹ -> case y¹ of {
//│ 			X => primitive⁰
//│ 			| Y => 2})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [X]: 35 --->
//│ 	case y¹ of {X => primitive⁰ | Y => 2}: 32
//│ 	case x¹ of {X => 0 | Y => 1}: 48
//│ ------------------
//│ case y¹ of {X => primitive⁰ | Y => 2}: 32 --->
//│ 	[X]: 35
//│ 	NoProd
//│ case x¹ of {X => 0 | Y => 1}: 48 --->
//│ 	[X]: 35
//│ 	NoProd
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ (fun a² -> (g₀ a²)))
//│ def f₀ = 
//│ 	(fun c² -> [P (c² [X]) (c² primitive⁰)])
//│ def g₀ = 
//│ 	(fun x² -> 
//│ 		(h₀ x²)
//│ 		case x² of {
//│ 			X => 0
//│ 			| Y => 1})
//│ 	where
//│ 	def h₀ = 
//│ 		(fun y² -> case y² of {
//│ 			X => primitive⁰
//│ 			| Y => 2})
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: after the detection and elimination of multiple matches
// NOTE: maybe we can try to rewrite into destructor? which is equivalent to copy the constructor
// f(cond) = cond
// g(y) = let y = K in y
// f(x => x)(C(K))
fun f(cond) = if cond is
    A then x => x 
    _ then x => g(x)
fun g(y) = if y is
    C(y) then y
f(A)(C(K))
//│ |#fun| |f|(|cond|)| |#=| |#if| |cond| |is|→|A| |#then| |x| |=>| |x| |↵|_| |#then| |x| |=>| |g|(|x|)|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|C|(|y|)| |#then| |y|←|↵|f|(|A|)|(|C|(|K|)|)|
//│ Parsed: {fun f = cond, => if cond is ‹(A) then x, => x; (_) then x, => g (x,)›; fun g = y, => if y is ‹(C (y,)) then y›; f (A,) (C (K,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((f^14 [A]) [C [K]])
//│ def f = (fun cond⁰ -> case cond⁰ of {
//│ 	A => (fun x⁰ -> x⁰)
//│ 	| _ => (fun x¹ -> (g^4 x¹))})
//│ def g = (fun y⁰ -> case y⁰ of {
//│ 	C y¹ => y¹})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^14] (hopeless to continue)
//│ 	[f^14 · g^4] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((f₀ [A]) [C [K]])
//│ def f₀ = 
//│ 	(fun cond¹ -> case cond¹ of {
//│ 		A => (fun x² -> x²)
//│ 		| _ => (fun x³ -> (g₀ x³))})
//│ 	where
//│ 	def g₀ = 
//│ 		(fun y² -> case y² of {
//│ 			C y³ => y³})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 34 --->
//│ 	case cond¹ of {A => (fun x² -> x²) | _ => (fun x³ -> (g₀ x³))}: 27
//│ [C [K]]: 37 --->
//│ 	NoCons
//│ 	case y² of {C y³ => y³}: 31
//│ ------------------
//│ case cond¹ of {A => (fun x² -> x²) | _ => (fun x³ -> (g₀ x³))}: 27 --->
//│ 	[A]: 34
//│ case y² of {C y³ => y³}: 31 --->
//│ 	[C [K]]: 37
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 34 --->
//│ 	case cond¹ of {A => (fun x² -> x²) | _ => (fun x³ -> (g₀ x³))}: 27
//│ ------------------
//│ case cond¹ of {A => (fun x² -> x²) | _ => (fun x³ -> (g₀ x³))}: 27 --->
//│ 	[A]: 34
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((f₀ (fun x⁴ -> x⁴)) [C [K]])
//│ def f₀ = 
//│ 	(fun cond² -> cond²)
//│ 	where
//│ 	def g₀ = 
//│ 		(fun y⁴ -> case y⁴ of {
//│ 			C y³ => y³})
//│ <<<<<<< after fusion <<<<<<<


// WRONG: here, we duplicate the consumer at the current approach/lazy eval?
// fun c(x) = if x is
//   A then
//     primitive(X) // some complicated operations
//   B then
//     primitive(Y) // some complicated operations
// if 1 > 2 then c(A) else c(B)


// CORRECT: after the detection and elimination of multiple matches
// NOTE: rewrite into consumer for further fusion?
// f(x) = if primitive then x else g(x)
// g(y) = let a = A in a
// f(C(A))
fun f(x) = if primitive then x else g(x)
fun g(y) = if y is
    C(a) then a
f(C(A))
//│ |#fun| |f|(|x|)| |#=| |#if| |primitive| |#then| |x| |#else| |g|(|x|)|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|C|(|a|)| |#then| |a|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun f = x, => if (primitive) then x else g (x,); fun g = y, => if y is ‹(C (a,)) then a›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^12 [C [A]])
//│ def f = (fun x⁰ -> if primitive⁰ then x⁰ else (g^3 x⁰))
//│ def g = (fun y⁰ -> case y⁰ of {
//│ 	C a⁰ => a⁰})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^12] (hopeless to continue)
//│ 	[f^12 · g^3] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ [C [A]])
//│ def f₀ = 
//│ 	(fun x¹ -> if primitive⁰ then x¹ else (g₀ x¹))
//│ 	where
//│ 	def g₀ = 
//│ 		(fun y¹ -> case y¹ of {
//│ 			C a¹ => a¹})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 29 --->
//│ 	NoCons
//│ 	case y¹ of {C a¹ => a¹}: 18
//│ ------------------
//│ case y¹ of {C a¹ => a¹}: 18 --->
//│ 	[C [A]]: 29
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ [C [A]])
//│ def f₀ = 
//│ 	(fun x² -> if primitive⁰ then x² else (g₀ x²))
//│ 	where
//│ 	def g₀ = 
//│ 		(fun y² -> case y² of {
//│ 			C a¹ => a¹})
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: after the detection and elimination of multiple matches
fun p(x) =
  if x == 0 then N
  else
    if x >= 2 then C(p(x - 1))
    else
      let temp = C(p(x + 1))
      f(temp)
      temp
fun f(z) = if z is
  C(b) then b
  N then 1
fun c(xx) = if xx is
  C(aa) then primitive(aa)
  N then N
c(p(0))
//│ |#fun| |p|(|x|)| |#=|→|#if| |x| |==| |0| |#then| |N|↵|#else|→|#if| |x| |>=| |2| |#then| |C|(|p|(|x| |-| |1|)|)|↵|#else|→|#let| |temp| |#=| |C|(|p|(|x| |+| |1|)|)|↵|f|(|temp|)|↵|temp|←|←|←|↵|#fun| |f|(|z|)| |#=| |#if| |z| |is|→|C|(|b|)| |#then| |b|↵|N| |#then| |1|←|↵|#fun| |c|(|xx|)| |#=| |#if| |xx| |is|→|C|(|aa|)| |#then| |primitive|(|aa|)|↵|N| |#then| |N|←|↵|c|(|p|(|0|)|)|
//│ Parsed: {fun p = x, => {if (== (x,) (0,)) then N else {if (>= (x,) (2,)) then C (p (- (x,) (1,),),) else {let temp = C (p (+ (x,) (1,),),); f (temp,); temp}}}; fun f = z, => if z is ‹(C (b,)) then b; (N) then 1›; fun c = xx, => if xx is ‹(C (aa,)) then primitive (aa,); (N) then N›; c (p (0,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^49 (p^50 0))
//│ def c = (fun xx⁰ -> case xx⁰ of {
//│ 	C aa⁰ => (primitive⁰ aa⁰)
//│ 	| N => [N]})
//│ def f = (fun z⁰ -> case z⁰ of {
//│ 	C b⁰ => b⁰
//│ 	| N => 1})
//│ def p = (fun x⁰ -> if (x⁰ == 0) then [N] else if (x⁰ >= 2) then [C (p^12 (x⁰ - 1))] else 
//│ 	let temp⁰ = [C (p^20 (x⁰ + 1))]
//│ 	in (f^28 temp⁰)
//│ 	temp⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^49] (hopeless to continue)
//│ [p^50]
//│ 	[p^50 · f^28] (hopeless to continue)
//│ 	[p^50 · p^12] (hopeless to continue)
//│ 		[p^50 · p^12 · f^28] (using original def)
//│ 		[p^50 · p^12 · p^12] ---> [p^50 · p^12] (using original def)
//│ 		[p^50 · p^12 · p^20] ---> [p^50 · p^12] (using original def)
//│ 	[p^50 · p^20]
//│ 		[p^50 · p^20 · f^28] (hopeless to continue)
//│ 		[p^50 · p^20 · p^12] (hopeless to continue)
//│ 			[p^50 · p^20 · p^12 · f^28] (using original def)
//│ 			[p^50 · p^20 · p^12 · p^12] ---> [p^50 · p^20 · p^12] (using original def)
//│ 			[p^50 · p^20 · p^12 · p^20] ---> [p^50 · p^20 · p^12] (using original def)
//│ 		[p^50 · p^20 · p^20] ---> [p^50 · p^20] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ (p₀ 0))
//│ def c₀ = 
//│ 	(fun xx¹ -> case xx¹ of {
//│ 		C aa¹ => (primitive⁰ aa¹)
//│ 		| N => [N]})
//│ def p₀ = 
//│ 	(fun x³ -> if (x³ == 0) then [N] else if (x³ >= 2) then [C (p₁ (x³ - 1))] else 
//│ 		let temp³ = [C (p₂ (x³ + 1))]
//│ 		in (f₀ temp³)
//│ 		temp³)
//│ 	where
//│ 	def f₀ = 
//│ 		(fun z¹ -> case z¹ of {
//│ 			C b¹ => b¹
//│ 			| N => 1})
//│ 	def p₁ = 
//│ 		(fun x¹ -> if (x¹ == 0) then [N] else if (x¹ >= 2) then [C (p₁ (x¹ - 1))] else 
//│ 			let temp¹ = [C (p₁ (x¹ + 1))]
//│ 			in (f₁ temp¹)
//│ 			temp¹)
//│ 		where
//│ 		def f₁ = 
//│ 			(fun z⁴ -> case z⁴ of {
//│ 				C b⁴ => b⁴
//│ 				| N => 1})
//│ 	def p₂ = 
//│ 		(fun x² -> if (x² == 0) then [N] else if (x² >= 2) then [C (p₃ (x² - 1))] else 
//│ 			let temp² = [C (p₂ (x² + 1))]
//│ 			in (f₂ temp²)
//│ 			temp²)
//│ 		where
//│ 		def f₂ = 
//│ 			(fun z³ -> case z³ of {
//│ 				C b³ => b³
//│ 				| N => 1})
//│ 		def p₃ = 
//│ 			(fun x⁴ -> if (x⁴ == 0) then [N] else if (x⁴ >= 2) then [C (p₃ (x⁴ - 1))] else 
//│ 				let temp⁴ = [C (p₃ (x⁴ + 1))]
//│ 				in (f₃ temp⁴)
//│ 				temp⁴)
//│ 			where
//│ 			def f₃ = 
//│ 				(fun z² -> case z² of {
//│ 					C b² => b²
//│ 					| N => 1})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C (p₁ (x¹ + 1))]: 107 --->
//│ 	NoCons
//│ 	case z⁴ of {C b⁴ => b⁴ | N => 1}: 79
//│ [C (p₂ (x² + 1))]: 143 --->
//│ 	NoCons
//│ 	case z³ of {C b³ => b³ | N => 1}: 74
//│ [N]: 158 --->
//│ 	case xx¹ of {C aa¹ => (primitive⁰ aa¹) | N => [N]}: 59
//│ [C (p₁ (x³ - 1))]: 171 --->
//│ 	case xx¹ of {C aa¹ => (primitive⁰ aa¹) | N => [N]}: 59
//│ [C (p₂ (x³ + 1))]: 179 --->
//│ 	case xx¹ of {C aa¹ => (primitive⁰ aa¹) | N => [N]}: 59
//│ 	case z¹ of {C b¹ => b¹ | N => 1}: 64
//│ [C (p₃ (x⁴ + 1))]: 215 --->
//│ 	NoCons
//│ 	case z² of {C b² => b² | N => 1}: 69
//│ ------------------
//│ case xx¹ of {C aa¹ => (primitive⁰ aa¹) | N => [N]}: 59 --->
//│ 	[N]: 158
//│ 	[C (p₁ (x³ - 1))]: 171
//│ 	[C (p₂ (x³ + 1))]: 179
//│ case z¹ of {C b¹ => b¹ | N => 1}: 64 --->
//│ 	[C (p₂ (x³ + 1))]: 179
//│ case z² of {C b² => b² | N => 1}: 69 --->
//│ 	[C (p₃ (x⁴ + 1))]: 215
//│ case z³ of {C b³ => b³ | N => 1}: 74 --->
//│ 	[C (p₂ (x² + 1))]: 143
//│ case z⁴ of {C b⁴ => b⁴ | N => 1}: 79 --->
//│ 	[C (p₁ (x¹ + 1))]: 107
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ (p₀ 0))
//│ def c₀ = 
//│ 	(fun xx² -> case xx² of {
//│ 		C aa¹ => (primitive⁰ aa¹)
//│ 		| N => [N]})
//│ def p₀ = 
//│ 	(fun x⁸ -> if (x⁸ == 0) then [N] else if (x⁸ >= 2) then [C (p₁ (x⁸ - 1))] else 
//│ 		let temp⁸ = [C (p₂ (x⁸ + 1))]
//│ 		in (f₀ temp⁸)
//│ 		temp⁸)
//│ 	where
//│ 	def f₀ = 
//│ 		(fun z⁷ -> case z⁷ of {
//│ 			C b¹ => b¹
//│ 			| N => 1})
//│ 	def p₁ = 
//│ 		(fun x⁷ -> if (x⁷ == 0) then [N] else if (x⁷ >= 2) then [C (p₁ (x⁷ - 1))] else 
//│ 			let temp⁷ = [C (p₁ (x⁷ + 1))]
//│ 			in (f₁ temp⁷)
//│ 			temp⁷)
//│ 		where
//│ 		def f₁ = 
//│ 			(fun z⁵ -> case z⁵ of {
//│ 				C b⁴ => b⁴
//│ 				| N => 1})
//│ 	def p₂ = 
//│ 		(fun x⁶ -> if (x⁶ == 0) then [N] else if (x⁶ >= 2) then [C (p₃ (x⁶ - 1))] else 
//│ 			let temp⁶ = [C (p₂ (x⁶ + 1))]
//│ 			in (f₂ temp⁶)
//│ 			temp⁶)
//│ 		where
//│ 		def f₂ = 
//│ 			(fun z⁸ -> case z⁸ of {
//│ 				C b³ => b³
//│ 				| N => 1})
//│ 		def p₃ = 
//│ 			(fun x⁵ -> if (x⁵ == 0) then [N] else if (x⁵ >= 2) then [C (p₃ (x⁵ - 1))] else 
//│ 				let temp⁵ = [C (p₃ (x⁵ + 1))]
//│ 				in (f₃ temp⁵)
//│ 				temp⁵)
//│ 			where
//│ 			def f₃ = 
//│ 				(fun z⁶ -> case z⁶ of {
//│ 					C b² => b²
//│ 					| N => 1})
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: after the detection and elimination of multiple matches
// NOTE: but maybe can be fused to this, by rewriting into the destructors
// f(xf) = if primitive then g(xf) else h(xf)
// g(xg) = G
// h(xh) = H
// f(C)
fun f(xf) = if primitive then g(xf) else h(xf)
fun g(xg) = if xg is
  C then G
fun h(xh) = if xh is
  C then H
f(C)
//│ |#fun| |f|(|xf|)| |#=| |#if| |primitive| |#then| |g|(|xf|)| |#else| |h|(|xf|)|↵|#fun| |g|(|xg|)| |#=| |#if| |xg| |is|→|C| |#then| |G|←|↵|#fun| |h|(|xh|)| |#=| |#if| |xh| |is|→|C| |#then| |H|←|↵|f|(|C|)|
//│ Parsed: {fun f = xf, => if (primitive) then g (xf,) else h (xf,); fun g = xg, => if xg is ‹(C) then G›; fun h = xh, => if xh is ‹(C) then H›; f (C,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^18 [C])
//│ def f = (fun xf⁰ -> if primitive⁰ then (g^2 xf⁰) else (h^5 xf⁰))
//│ def g = (fun xg⁰ -> case xg⁰ of {
//│ 	C => [G]})
//│ def h = (fun xh⁰ -> case xh⁰ of {
//│ 	C => [H]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^18] (hopeless to continue)
//│ 	[f^18 · g^2] (using original def)
//│ 	[f^18 · h^5] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ [C])
//│ def f₀ = 
//│ 	(fun xf¹ -> if primitive⁰ then (g₀ xf¹) else (h₀ xf¹))
//│ 	where
//│ 	def g₀ = 
//│ 		(fun xg¹ -> case xg¹ of {
//│ 			C => [G]})
//│ 	def h₀ = 
//│ 		(fun xh¹ -> case xh¹ of {
//│ 			C => [H]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C]: 39 --->
//│ 	case xg¹ of {C => [G]}: 23
//│ 	case xh¹ of {C => [H]}: 27
//│ ------------------
//│ case xg¹ of {C => [G]}: 23 --->
//│ 	[C]: 39
//│ case xh¹ of {C => [H]}: 27 --->
//│ 	[C]: 39
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ [C])
//│ def f₀ = 
//│ 	(fun xf² -> if primitive⁰ then (g₀ xf²) else (h₀ xf²))
//│ 	where
//│ 	def g₀ = 
//│ 		(fun xg² -> case xg² of {
//│ 			C => [G]})
//│ 	def h₀ = 
//│ 		(fun xh² -> case xh² of {
//│ 			C => [H]})
//│ <<<<<<< after fusion <<<<<<<

// WRONG: wrong knots, because the knots are tied using only one
// of the many variables in this function definition
let rec t = T(X, T(Y, t, t), t)
fun f(x) = if x is
  T(a, l, r) then if r is
    T(b, ll, rr) then T(a, T(b, f(rr), f(ll)), f(l))
f(t)
//│ |#let| |#rec| |t| |#=| |T|(|X|,| |T|(|Y|,| |t|,| |t|)|,| |t|)|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|T|(|a|,| |l|,| |r|)| |#then| |#if| |r| |is|→|T|(|b|,| |ll|,| |rr|)| |#then| |T|(|a|,| |T|(|b|,| |f|(|rr|)|,| |f|(|ll|)|)|,| |f|(|l|)|)|←|←|↵|f|(|t|)|
//│ Parsed: {let rec t = T (X, T (Y, t, t,), t,); fun f = x, => if x is ‹(T (a, l, r,)) then if r is ‹(T (b, ll, rr,)) then T (a, T (b, f (rr,), f (ll,),), f (l,),)››; f (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^26 t^27)
//│ def f = (fun x⁰ -> case x⁰ of {
//│ 	T a⁰ l⁰ r⁰ => case r⁰ of {
//│ 		T b⁰ ll⁰ rr⁰ => [T a⁰ [T b⁰ (f^12 rr⁰) (f^15 ll⁰)] (f^19 l⁰)]}})
//│ def t = [T [X] [T [Y] t^3 t^4] t^6]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^26]
//│ 	[f^26 · f^12] ---> [f^26] (only one)
//│ 	[f^26 · f^15] ---> [f^26] (only one)
//│ 	[f^26 · f^19] ---> [f^26] (only one)
//│ [t^27]
//│ 	[t^27 · t^3] ---> [t^27] (only one)
//│ 	[t^27 · t^4] ---> [t^27] (only one)
//│ 	[t^27 · t^6] (hopeless to continue)
//│ 		[t^27 · t^6 · t^3] ---> [t^27 · t^6] (using original def)
//│ 		[t^27 · t^6 · t^4] ---> [t^27 · t^6] (using original def)
//│ 		[t^27 · t^6 · t^6] ---> [t^27 · t^6] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ t₀)
//│ def f₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		T a¹ l¹ r¹ => case r¹ of {
//│ 			T b¹ ll¹ rr¹ => [T a¹ [T b¹ (f₀ rr¹) (f₀ ll¹)] (f₀ l¹)]}})
//│ def t₀ = 
//│ 	[T [X] [T [Y] t₀ t₀] t₁]
//│ 	where
//│ 	def t₁ = 
//│ 		[T [X] [T [Y] t₁ t₁] t₁]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [T [Y] t₁ t₁]: 51 --->
//│ 	case x¹ of {T a¹ l¹ r¹ => case r¹ of {T b¹ ll¹ rr¹ => [T a¹ [T b¹ (f₀ rr¹) (f₀ ll¹)] (f₀ l¹)]}}: 45
//│ [T [X] [T [Y] t₁ t₁] t₁]: 53 --->
//│ 	case r¹ of {T b¹ ll¹ rr¹ => [T a¹ [T b¹ (f₀ rr¹) (f₀ ll¹)] (f₀ l¹)]}: 44
//│ 	case x¹ of {T a¹ l¹ r¹ => case r¹ of {T b¹ ll¹ rr¹ => [T a¹ [T b¹ (f₀ rr¹) (f₀ ll¹)] (f₀ l¹)]}}: 45
//│ [T [Y] t₀ t₀]: 58 --->
//│ 	case x¹ of {T a¹ l¹ r¹ => case r¹ of {T b¹ ll¹ rr¹ => [T a¹ [T b¹ (f₀ rr¹) (f₀ ll¹)] (f₀ l¹)]}}: 45
//│ [T [X] [T [Y] t₀ t₀] t₁]: 60 --->
//│ 	case r¹ of {T b¹ ll¹ rr¹ => [T a¹ [T b¹ (f₀ rr¹) (f₀ ll¹)] (f₀ l¹)]}: 44
//│ 	case x¹ of {T a¹ l¹ r¹ => case r¹ of {T b¹ ll¹ rr¹ => [T a¹ [T b¹ (f₀ rr¹) (f₀ ll¹)] (f₀ l¹)]}}: 45
//│ ------------------
//│ case r¹ of {T b¹ ll¹ rr¹ => [T a¹ [T b¹ (f₀ rr¹) (f₀ ll¹)] (f₀ l¹)]}: 44 --->
//│ 	[T [X] [T [Y] t₁ t₁] t₁]: 53
//│ 	[T [X] [T [Y] t₀ t₀] t₁]: 60
//│ case x¹ of {T a¹ l¹ r¹ => case r¹ of {T b¹ ll¹ rr¹ => [T a¹ [T b¹ (f₀ rr¹) (f₀ ll¹)] (f₀ l¹)]}}: 45 --->
//│ 	[T [Y] t₁ t₁]: 51
//│ 	[T [X] [T [Y] t₁ t₁] t₁]: 53
//│ 	[T [Y] t₀ t₀]: 58
//│ 	[T [X] [T [Y] t₀ t₀] t₁]: 60
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ t₀)
//│ def f₀ = 
//│ 	(fun x² -> case x² of {
//│ 		T a¹ l¹ r¹ => case r¹ of {
//│ 			T b¹ ll¹ rr¹ => [T a¹ [T b¹ (f₀ rr¹) (f₀ ll¹)] (f₀ l¹)]}})
//│ def t₀ = 
//│ 	[T [X] [T [Y] t₀ t₀] t₁]
//│ 	where
//│ 	def t₁ = 
//│ 		[T [X] [T [Y] t₁ t₁] t₁]
//│ <<<<<<< after fusion <<<<<<<
