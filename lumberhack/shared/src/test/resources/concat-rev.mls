:NewParser
:ParseOnly

_LUMBERHACK_EVAL
fun concat(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(C(1, C(2, C(3, N))))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^26([C 1 [C 2 [C 3 [N]]]])
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat^4(t⁰, ys⁰)]}
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^14(rev^15(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 3 [C 2 [C 1 [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ concat(t⁰, ys⁰)]: 9 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 20 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [C h¹ [N]]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 23 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 30 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ [C 3 [N]]: 31 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ [C 2 [C 3 [N]]]: 32 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ [C 1 [C 2 [C 3 [N]]]]: 33 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ ------------------
//│ case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10 --->
//│ 	[C h⁰ concat(t⁰, ys⁰)]: 9
//│ 	[N]: 20
//│ 	[C h¹ [N]]: 21
//│ 	[N]: 23
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24 --->
//│ 	[N]: 30
//│ 	[C 3 [N]]: 31
//│ 	[C 2 [C 3 [N]]]: 32
//│ 	[C 1 [C 2 [C 3 [N]]]]: 33
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 30 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ [C 3 [N]]: 31 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ [C 2 [C 3 [N]]]: 32 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ [C 1 [C 2 [C 3 [N]]]]: 33 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ ------------------
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24 --->
//│ 	[N]: 30
//│ 	[C 3 [N]]: 31
//│ 	[C 2 [C 3 [N]]]: 32
//│ 	[C 1 [C 2 [C 3 [N]]]]: 33
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(
//│ 	let t² = 	
//│ 		let t³ = 	
//│ 			let t⁴ = (fun _lh_dummy³ -> [N])
//│ 			in let h⁴ = 3
//│ 			in (fun _lh_dummy² -> concat(rev(t⁴), [C h⁴ [N]]))
//│ 		in let h³ = 2
//│ 		in (fun _lh_dummy¹ -> concat(rev(t³), [C h³ [N]]))
//│ 	in let h² = 1
//│ 	in (fun _lh_dummy⁰ -> concat(rev(t²), [C h² [N]])))
//│ def concat(xs¹, ys¹) = case xs¹ of {
//│ 	N  => ys¹
//│ 	| C h⁰ t⁰ => [C h⁰ concat(t⁰, ys¹)]}
//│ def rev(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 3 [C 2 [C 1 [N]]]]
//│ <<<<<<< evaluate <<<<<<<

// NOTE: global way to push in variables
_LUMBERHACK_EVAL
fun concat(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(C(1, C(2, C(3, N))))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^27([C 1 [C 2 [C 3 [N]]]])
//│ def concat(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat^5(t⁰, ys¹)])}
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^15(rev^16(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 3 [C 2 [C 1 [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ concat(t⁰, ys¹)]: 10 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [N]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [C h¹ [N]]: 22 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [N]: 24 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [N]: 31 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 3 [N]]: 32 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 2 [C 3 [N]]]: 33 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 1 [C 2 [C 3 [N]]]]: 34 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12 --->
//│ 	[C h⁰ concat(t⁰, ys¹)]: 10
//│ 	[N]: 21
//│ 	[C h¹ [N]]: 22
//│ 	[N]: 24
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25 --->
//│ 	[N]: 31
//│ 	[C 3 [N]]: 32
//│ 	[C 2 [C 3 [N]]]: 33
//│ 	[C 1 [C 2 [C 3 [N]]]]: 34
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 31 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 3 [N]]: 32 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 2 [C 3 [N]]]: 33 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 1 [C 2 [C 3 [N]]]]: 34 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ ------------------
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25 --->
//│ 	[N]: 31
//│ 	[C 3 [N]]: 32
//│ 	[C 2 [C 3 [N]]]: 33
//│ 	[C 1 [C 2 [C 3 [N]]]]: 34
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(
//│ 	let t² = 	
//│ 		let t³ = 	
//│ 			let t⁴ = (fun _lh_dummy³ -> [N])
//│ 			in let h⁴ = 3
//│ 			in (fun _lh_dummy² -> concat(rev(t⁴), [C h⁴ [N]]))
//│ 		in let h³ = 2
//│ 		in (fun _lh_dummy¹ -> concat(rev(t³), [C h³ [N]]))
//│ 	in let h² = 1
//│ 	in (fun _lh_dummy⁰ -> concat(rev(t²), [C h² [N]])))
//│ def concat(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ concat(t⁰, ys³)])}
//│ def rev(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 3 [C 2 [C 1 [N]]]]
//│ <<<<<<< evaluate <<<<<<<


// NOTE: if there is no concrete list provided as input, no fusion will be done
fun concat(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(primitive)
//│ |#fun| |concat|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|primitive|)|
//│ Parsed: {fun concat = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (primitive,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^26(primitive⁰)
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat^4(t⁰, ys⁰)]}
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^14(rev^15(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ concat(t⁰, ys⁰)]: 9 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 20 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [C h¹ [N]]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 23 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ ------------------
//│ case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10 --->
//│ 	[C h⁰ concat(t⁰, ys⁰)]: 9
//│ 	[N]: 20
//│ 	[C h¹ [N]]: 21
//│ 	[N]: 23
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(primitive⁰)
//│ def concat(xs¹, ys¹) = case xs¹ of {
//│ 	N  => ys¹
//│ 	| C h⁰ t⁰ => [C h⁰ concat(t⁰, ys¹)]}
//│ def rev(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => concat(rev(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<


// NOTE: if there is no concrete list provided as input, no fusion will be done
fun concat(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev
//│ |#fun| |concat|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|
//│ Parsed: {fun concat = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^26
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat^4(t⁰, ys⁰)]}
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^14(rev^15(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ concat(t⁰, ys⁰)]: 9 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 20 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [C h¹ [N]]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 23 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ ------------------
//│ case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10 --->
//│ 	[C h⁰ concat(t⁰, ys⁰)]: 9
//│ 	[N]: 20
//│ 	[C h¹ [N]]: 21
//│ 	[N]: 23
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev
//│ def concat(xs¹, ys¹) = case xs¹ of {
//│ 	N  => ys¹
//│ 	| C h⁰ t⁰ => [C h⁰ concat(t⁰, ys¹)]}
//│ def rev(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => concat(rev(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<
