:NewParser
:ParseOnly

_LUMBERHACK_EVAL
fun concat(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(C(1, C(2, C(3, N))))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (rev^26 [C 1 [C 2 [C 3 [N]]]])
//│ def concat = (fun xs⁰ -> (fun ys⁰ -> case xs⁰ of {
//│ 	N => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ ((concat^4 t⁰) ys⁰)]}))
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	C h¹ t¹ => ((concat^14 (rev^15 t¹)) [C h¹ [N]])
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 3 [C 2 [C 1 [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^26]
//│ 	[rev^26 · concat^14] (hopeless to continue)
//│ 		[rev^26 · concat^14 · concat^4] ---> [rev^26 · concat^14] (using original def)
//│ 	[rev^26 · rev^15] ---> [rev^26] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (rev₀ [C 1 [C 2 [C 3 [N]]]])
//│ def rev₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]])
//│ 		| N => [N]})
//│ 	where
//│ 	def concat₀ = 
//│ 		(fun xs¹ -> (fun ys¹ -> case xs¹ of {
//│ 			N => ys¹
//│ 			| C h² t² => [C h² ((concat₀ t²) ys¹)]}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h² ((concat₀ t²) ys¹)]: 43 --->
//│ 	'lumberhackTopLevelResult
//│ 	case xs¹ of {N => ys¹ | C h² t² => [C h² ((concat₀ t²) ys¹)]}: 44
//│ [N]: 54 --->
//│ 	case xs¹ of {N => ys¹ | C h² t² => [C h² ((concat₀ t²) ys¹)]}: 44
//│ [C h³ [N]]: 55 --->
//│ 	'lumberhackTopLevelResult
//│ 	case xs¹ of {N => ys¹ | C h² t² => [C h² ((concat₀ t²) ys¹)]}: 44
//│ [N]: 57 --->
//│ 	'lumberhackTopLevelResult
//│ 	case xs¹ of {N => ys¹ | C h² t² => [C h² ((concat₀ t²) ys¹)]}: 44
//│ [N]: 64 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58
//│ [C 3 [N]]: 65 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58
//│ [C 2 [C 3 [N]]]: 66 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58
//│ [C 1 [C 2 [C 3 [N]]]]: 67 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58
//│ ------------------
//│ case xs¹ of {N => ys¹ | C h² t² => [C h² ((concat₀ t²) ys¹)]}: 44 --->
//│ 	[C h² ((concat₀ t²) ys¹)]: 43
//│ 	[N]: 54
//│ 	[C h³ [N]]: 55
//│ 	[N]: 57
//│ case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58 --->
//│ 	[N]: 64
//│ 	[C 3 [N]]: 65
//│ 	[C 2 [C 3 [N]]]: 66
//│ 	[C 1 [C 2 [C 3 [N]]]]: 67
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 64 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58
//│ [C 3 [N]]: 65 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58
//│ [C 2 [C 3 [N]]]: 66 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58
//│ [C 1 [C 2 [C 3 [N]]]]: 67 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58
//│ ------------------
//│ case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58 --->
//│ 	[N]: 64
//│ 	[C 3 [N]]: 65
//│ 	[C 2 [C 3 [N]]]: 66
//│ 	[C 1 [C 2 [C 3 [N]]]]: 67
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (rev₀ 
//│ 	let h⁴ = 1
//│ 	in let t⁴ = 	
//│ 		let h⁵ = 2
//│ 		in let t⁵ = 	
//│ 			let h⁶ = 3
//│ 			in let t⁶ = [N]
//│ 			in ((concat₀ (rev₀ t⁶)) [C h⁶ [N]])
//│ 		in ((concat₀ (rev₀ t⁵)) [C h⁵ [N]])
//│ 	in ((concat₀ (rev₀ t⁴)) [C h⁴ [N]]))
//│ def rev₀ = 
//│ 	(fun ls² -> ls²)
//│ 	where
//│ 	def concat₀ = 
//│ 		(fun xs² -> (fun ys² -> case xs² of {
//│ 			N => ys²
//│ 			| C h² t² => [C h² ((concat₀ t²) ys²)]}))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 3 [C 2 [C 1 [N]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [concat₀^17] (hopeless to continue)
//│ 	[concat₀^17 · concat₀^43] ---> [concat₀^17] (using original def)
//│ [concat₀^28] (hopeless to continue)
//│ 	[concat₀^28 · concat₀^43] ---> [concat₀^28] (using original def)
//│ [concat₀^6] (hopeless to continue)
//│ 	[concat₀^6 · concat₀^43] ---> [concat₀^6] (using original def)
//│ [rev₀^18] (hopeless to continue)
//│ [rev₀^1] (hopeless to continue)
//│ [rev₀^29] (hopeless to continue)
//│ [rev₀^7] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (rev₀₁ 
//│ 	let h⁷ = 1
//│ 	in let t⁷ = 	
//│ 		let h⁸ = 2
//│ 		in let t⁸ = 	
//│ 			let h⁹ = 3
//│ 			in let t⁹ = [N]
//│ 			in ((concat₀₂ (rev₀₃ t⁹)) [C h⁹ [N]])
//│ 		in ((concat₀₀ (rev₀₀ t⁸)) [C h⁸ [N]])
//│ 	in ((concat₀₁ (rev₀₂ t⁷)) [C h⁷ [N]]))
//│ def concat₀₀ = 
//│ 	(fun xs³ -> (fun ys³ -> case xs³ of {
//│ 		N => ys³
//│ 		| C h⁶ t⁶ => [C h⁶ ((concat₀₀ t⁶) ys³)]}))
//│ def concat₀₁ = 
//│ 	(fun xs¹ -> (fun ys¹ -> case xs¹ of {
//│ 		N => ys¹
//│ 		| C h⁴ t⁴ => [C h⁴ ((concat₀₁ t⁴) ys¹)]}))
//│ def concat₀₂ = 
//│ 	(fun xs² -> (fun ys² -> case xs² of {
//│ 		N => ys²
//│ 		| C h⁵ t⁵ => [C h⁵ ((concat₀₂ t⁵) ys²)]}))
//│ def rev₀₀ = 
//│ 	(fun ls³ -> ls³)
//│ def rev₀₁ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ def rev₀₂ = 
//│ 	(fun ls¹ -> ls¹)
//│ def rev₀₃ = 
//│ 	(fun ls² -> ls²)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁵ ((concat₀₂ t⁵) ys²)]: 74 --->
//│ 	case xs³ of {N => ys³ | C h⁶ t⁶ => [C h⁶ ((concat₀₀ t⁶) ys³)]}: 91
//│ [C h⁶ ((concat₀₀ t⁶) ys³)]: 90 --->
//│ 	case xs¹ of {N => ys¹ | C h⁴ t⁴ => [C h⁴ ((concat₀₁ t⁴) ys¹)]}: 63
//│ [N]: 102 --->
//│ 	case xs² of {N => ys² | C h⁵ t⁵ => [C h⁵ ((concat₀₂ t⁵) ys²)]}: 75
//│ [N]: 109 --->
//│ 	case xs³ of {N => ys³ | C h⁶ t⁶ => [C h⁶ ((concat₀₀ t⁶) ys³)]}: 91
//│ [C h⁹ [N]]: 110 --->
//│ 	case xs³ of {N => ys³ | C h⁶ t⁶ => [C h⁶ ((concat₀₀ t⁶) ys³)]}: 91
//│ [N]: 120 --->
//│ 	case xs¹ of {N => ys¹ | C h⁴ t⁴ => [C h⁴ ((concat₀₁ t⁴) ys¹)]}: 63
//│ [C h⁸ [N]]: 121 --->
//│ 	case xs¹ of {N => ys¹ | C h⁴ t⁴ => [C h⁴ ((concat₀₁ t⁴) ys¹)]}: 63
//│ ------------------
//│ case xs¹ of {N => ys¹ | C h⁴ t⁴ => [C h⁴ ((concat₀₁ t⁴) ys¹)]}: 63 --->
//│ 	[C h⁶ ((concat₀₀ t⁶) ys³)]: 90
//│ 	[N]: 120
//│ 	[C h⁸ [N]]: 121
//│ case xs² of {N => ys² | C h⁵ t⁵ => [C h⁵ ((concat₀₂ t⁵) ys²)]}: 75 --->
//│ 	[N]: 102
//│ case xs³ of {N => ys³ | C h⁶ t⁶ => [C h⁶ ((concat₀₀ t⁶) ys³)]}: 91 --->
//│ 	[C h⁵ ((concat₀₂ t⁵) ys²)]: 74
//│ 	[N]: 109
//│ 	[C h⁹ [N]]: 110
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h⁵ ((concat₀₂ t⁵) ys²)]: 74 --->
//│ 	case xs³ of {N => ys³ | C h⁶ t⁶ => [C h⁶ ((concat₀₀ t⁶) ys³)]}: 91
//│ [C h⁶ ((concat₀₀ t⁶) ys³)]: 90 --->
//│ 	case xs¹ of {N => ys¹ | C h⁴ t⁴ => [C h⁴ ((concat₀₁ t⁴) ys¹)]}: 63
//│ [N]: 102 --->
//│ 	case xs² of {N => ys² | C h⁵ t⁵ => [C h⁵ ((concat₀₂ t⁵) ys²)]}: 75
//│ [N]: 109 --->
//│ 	case xs³ of {N => ys³ | C h⁶ t⁶ => [C h⁶ ((concat₀₀ t⁶) ys³)]}: 91
//│ [C h⁹ [N]]: 110 --->
//│ 	case xs³ of {N => ys³ | C h⁶ t⁶ => [C h⁶ ((concat₀₀ t⁶) ys³)]}: 91
//│ [N]: 120 --->
//│ 	case xs¹ of {N => ys¹ | C h⁴ t⁴ => [C h⁴ ((concat₀₁ t⁴) ys¹)]}: 63
//│ [C h⁸ [N]]: 121 --->
//│ 	case xs¹ of {N => ys¹ | C h⁴ t⁴ => [C h⁴ ((concat₀₁ t⁴) ys¹)]}: 63
//│ ------------------
//│ case xs¹ of {N => ys¹ | C h⁴ t⁴ => [C h⁴ ((concat₀₁ t⁴) ys¹)]}: 63 --->
//│ 	[C h⁶ ((concat₀₀ t⁶) ys³)]: 90
//│ 	[N]: 120
//│ 	[C h⁸ [N]]: 121
//│ case xs² of {N => ys² | C h⁵ t⁵ => [C h⁵ ((concat₀₂ t⁵) ys²)]}: 75 --->
//│ 	[N]: 102
//│ case xs³ of {N => ys³ | C h⁶ t⁶ => [C h⁶ ((concat₀₀ t⁶) ys³)]}: 91 --->
//│ 	[C h⁵ ((concat₀₂ t⁵) ys²)]: 74
//│ 	[N]: 109
//│ 	[C h⁹ [N]]: 110
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (rev₀₁ 
//│ 	let h⁷ = 1
//│ 	in let t⁷ = 	
//│ 		let h⁸ = 2
//│ 		in let t⁸ = 	
//│ 			let h⁹ = 3
//│ 			in let t⁹ = (fun ys⁴ -> ys⁴)
//│ 			in ((concat₀₂ (rev₀₃ t⁹)) 
//│ 				let h¹⁰ = h⁹
//│ 				in let t¹⁰ = (fun ys⁷ -> ys⁷)
//│ 				in (fun ys⁵ -> 
//│ 					let h¹¹ = h¹⁰
//│ 					in let t¹¹ = ((concat₀₀ t¹⁰) ys⁵)
//│ 					in (fun ys⁶ -> [C h¹¹ ((concat₀₁ t¹¹) ys⁶)])))
//│ 		in ((concat₀₀ (rev₀₀ t⁸)) 
//│ 			let h¹² = h⁸
//│ 			in let t¹² = (fun ys⁹ -> ys⁹)
//│ 			in (fun ys⁸ -> [C h¹² ((concat₀₁ t¹²) ys⁸)]))
//│ 	in ((concat₀₁ (rev₀₂ t⁷)) [C h⁷ [N]]))
//│ def concat₀₀ = 
//│ 	(fun xs⁴ -> (fun ys¹⁰ -> (xs⁴ ys¹⁰)))
//│ def concat₀₁ = 
//│ 	(fun xs⁶ -> (fun ys¹² -> (xs⁶ ys¹²)))
//│ def concat₀₂ = 
//│ 	(fun xs⁵ -> (fun ys¹¹ -> (xs⁵ ys¹¹)))
//│ def rev₀₀ = 
//│ 	(fun ls⁷ -> ls⁷)
//│ def rev₀₁ = 
//│ 	(fun ls⁸ -> ls⁸)
//│ def rev₀₂ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ def rev₀₃ = 
//│ 	(fun ls⁵ -> ls⁵)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 3 [C 2 [C 1 [N]]]]
//│ <<<<<<< evaluate <<<<<<<


_LUMBERHACK_EVAL
fun concat(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(C(1, C(2, C(3, N))))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (rev^27 [C 1 [C 2 [C 3 [N]]]])
//│ def concat = (fun xs⁰ -> case xs⁰ of {
//│ 	N => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ ((concat^5 t⁰) ys¹)])})
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	C h¹ t¹ => ((concat^15 (rev^16 t¹)) [C h¹ [N]])
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 3 [C 2 [C 1 [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^27]
//│ 	[rev^27 · concat^15] (hopeless to continue)
//│ 		[rev^27 · concat^15 · concat^5] ---> [rev^27 · concat^15] (using original def)
//│ 	[rev^27 · rev^16] ---> [rev^27] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (rev₀ [C 1 [C 2 [C 3 [N]]]])
//│ def rev₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]])
//│ 		| N => [N]})
//│ 	where
//│ 	def concat₀ = 
//│ 		(fun xs¹ -> case xs¹ of {
//│ 			N => (fun ys² -> ys²)
//│ 			| C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h² ((concat₀ t²) ys³)]: 45 --->
//│ 	'lumberhackTopLevelResult
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])}: 47
//│ [N]: 56 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])}: 47
//│ [C h³ [N]]: 57 --->
//│ 	'lumberhackTopLevelResult
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])}: 47
//│ [N]: 59 --->
//│ 	'lumberhackTopLevelResult
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])}: 47
//│ [N]: 66 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 60
//│ [C 3 [N]]: 67 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 60
//│ [C 2 [C 3 [N]]]: 68 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 60
//│ [C 1 [C 2 [C 3 [N]]]]: 69 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 60
//│ ------------------
//│ case xs¹ of {N => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])}: 47 --->
//│ 	[C h² ((concat₀ t²) ys³)]: 45
//│ 	[N]: 56
//│ 	[C h³ [N]]: 57
//│ 	[N]: 59
//│ case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 60 --->
//│ 	[N]: 66
//│ 	[C 3 [N]]: 67
//│ 	[C 2 [C 3 [N]]]: 68
//│ 	[C 1 [C 2 [C 3 [N]]]]: 69
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 66 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 60
//│ [C 3 [N]]: 67 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 60
//│ [C 2 [C 3 [N]]]: 68 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 60
//│ [C 1 [C 2 [C 3 [N]]]]: 69 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 60
//│ ------------------
//│ case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 60 --->
//│ 	[N]: 66
//│ 	[C 3 [N]]: 67
//│ 	[C 2 [C 3 [N]]]: 68
//│ 	[C 1 [C 2 [C 3 [N]]]]: 69
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (rev₀ 
//│ 	let h⁴ = 1
//│ 	in let t⁴ = 	
//│ 		let h⁵ = 2
//│ 		in let t⁵ = 	
//│ 			let h⁶ = 3
//│ 			in let t⁶ = [N]
//│ 			in ((concat₀ (rev₀ t⁶)) [C h⁶ [N]])
//│ 		in ((concat₀ (rev₀ t⁵)) [C h⁵ [N]])
//│ 	in ((concat₀ (rev₀ t⁴)) [C h⁴ [N]]))
//│ def rev₀ = 
//│ 	(fun ls² -> ls²)
//│ 	where
//│ 	def concat₀ = 
//│ 		(fun xs² -> case xs² of {
//│ 			N => (fun ys⁴ -> ys⁴)
//│ 			| C h² t² => (fun ys⁵ -> [C h² ((concat₀ t²) ys⁵)])})
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 3 [C 2 [C 1 [N]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [concat₀^17]
//│ 	[concat₀^17 · concat₀^44] ---> [concat₀^17] (only one)
//│ [concat₀^28]
//│ 	[concat₀^28 · concat₀^44] ---> [concat₀^28] (only one)
//│ [concat₀^6]
//│ 	[concat₀^6 · concat₀^44] ---> [concat₀^6] (only one)
//│ [rev₀^18] (hopeless to continue)
//│ [rev₀^1] (hopeless to continue)
//│ [rev₀^29] (hopeless to continue)
//│ [rev₀^7] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (rev₀₁ 
//│ 	let h⁷ = 1
//│ 	in let t⁷ = 	
//│ 		let h⁸ = 2
//│ 		in let t⁸ = 	
//│ 			let h⁹ = 3
//│ 			in let t⁹ = [N]
//│ 			in ((concat₀₂ (rev₀₃ t⁹)) [C h⁹ [N]])
//│ 		in ((concat₀₀ (rev₀₀ t⁸)) [C h⁸ [N]])
//│ 	in ((concat₀₁ (rev₀₂ t⁷)) [C h⁷ [N]]))
//│ def concat₀₀ = 
//│ 	(fun xs³ -> case xs³ of {
//│ 		N => (fun ys⁶ -> ys⁶)
//│ 		| C h⁶ t⁶ => (fun ys⁷ -> [C h⁶ ((concat₀₀ t⁶) ys⁷)])})
//│ def concat₀₁ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		N => (fun ys² -> ys²)
//│ 		| C h⁴ t⁴ => (fun ys³ -> [C h⁴ ((concat₀₁ t⁴) ys³)])})
//│ def concat₀₂ = 
//│ 	(fun xs² -> case xs² of {
//│ 		N => (fun ys⁴ -> ys⁴)
//│ 		| C h⁵ t⁵ => (fun ys⁵ -> [C h⁵ ((concat₀₂ t⁵) ys⁵)])})
//│ def rev₀₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ def rev₀₁ = 
//│ 	(fun ls² -> ls²)
//│ def rev₀₂ = 
//│ 	(fun ls¹ -> ls¹)
//│ def rev₀₃ = 
//│ 	(fun ls³ -> ls³)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁵ ((concat₀₂ t⁵) ys⁵)]: 77 --->
//│ 	case xs³ of {N => (fun ys⁶ -> ys⁶) | C h⁶ t⁶ => (fun ys⁷ -> [C h⁶ ((concat₀₀ t⁶) ys⁷)])}: 98
//│ [C h⁶ ((concat₀₀ t⁶) ys⁷)]: 96 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h⁴ t⁴ => (fun ys³ -> [C h⁴ ((concat₀₁ t⁴) ys³)])}: 66
//│ [N]: 106 --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁵ t⁵ => (fun ys⁵ -> [C h⁵ ((concat₀₂ t⁵) ys⁵)])}: 79
//│ [N]: 113 --->
//│ 	case xs³ of {N => (fun ys⁶ -> ys⁶) | C h⁶ t⁶ => (fun ys⁷ -> [C h⁶ ((concat₀₀ t⁶) ys⁷)])}: 98
//│ [C h⁹ [N]]: 114 --->
//│ 	case xs³ of {N => (fun ys⁶ -> ys⁶) | C h⁶ t⁶ => (fun ys⁷ -> [C h⁶ ((concat₀₀ t⁶) ys⁷)])}: 98
//│ [N]: 124 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h⁴ t⁴ => (fun ys³ -> [C h⁴ ((concat₀₁ t⁴) ys³)])}: 66
//│ [C h⁸ [N]]: 125 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h⁴ t⁴ => (fun ys³ -> [C h⁴ ((concat₀₁ t⁴) ys³)])}: 66
//│ ------------------
//│ case xs¹ of {N => (fun ys² -> ys²) | C h⁴ t⁴ => (fun ys³ -> [C h⁴ ((concat₀₁ t⁴) ys³)])}: 66 --->
//│ 	[C h⁶ ((concat₀₀ t⁶) ys⁷)]: 96
//│ 	[N]: 124
//│ 	[C h⁸ [N]]: 125
//│ case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁵ t⁵ => (fun ys⁵ -> [C h⁵ ((concat₀₂ t⁵) ys⁵)])}: 79 --->
//│ 	[N]: 106
//│ case xs³ of {N => (fun ys⁶ -> ys⁶) | C h⁶ t⁶ => (fun ys⁷ -> [C h⁶ ((concat₀₀ t⁶) ys⁷)])}: 98 --->
//│ 	[C h⁵ ((concat₀₂ t⁵) ys⁵)]: 77
//│ 	[N]: 113
//│ 	[C h⁹ [N]]: 114
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h⁵ ((concat₀₂ t⁵) ys⁵)]: 77 --->
//│ 	case xs³ of {N => (fun ys⁶ -> ys⁶) | C h⁶ t⁶ => (fun ys⁷ -> [C h⁶ ((concat₀₀ t⁶) ys⁷)])}: 98
//│ [C h⁶ ((concat₀₀ t⁶) ys⁷)]: 96 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h⁴ t⁴ => (fun ys³ -> [C h⁴ ((concat₀₁ t⁴) ys³)])}: 66
//│ [N]: 106 --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁵ t⁵ => (fun ys⁵ -> [C h⁵ ((concat₀₂ t⁵) ys⁵)])}: 79
//│ [N]: 113 --->
//│ 	case xs³ of {N => (fun ys⁶ -> ys⁶) | C h⁶ t⁶ => (fun ys⁷ -> [C h⁶ ((concat₀₀ t⁶) ys⁷)])}: 98
//│ [C h⁹ [N]]: 114 --->
//│ 	case xs³ of {N => (fun ys⁶ -> ys⁶) | C h⁶ t⁶ => (fun ys⁷ -> [C h⁶ ((concat₀₀ t⁶) ys⁷)])}: 98
//│ [N]: 124 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h⁴ t⁴ => (fun ys³ -> [C h⁴ ((concat₀₁ t⁴) ys³)])}: 66
//│ [C h⁸ [N]]: 125 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h⁴ t⁴ => (fun ys³ -> [C h⁴ ((concat₀₁ t⁴) ys³)])}: 66
//│ ------------------
//│ case xs¹ of {N => (fun ys² -> ys²) | C h⁴ t⁴ => (fun ys³ -> [C h⁴ ((concat₀₁ t⁴) ys³)])}: 66 --->
//│ 	[C h⁶ ((concat₀₀ t⁶) ys⁷)]: 96
//│ 	[N]: 124
//│ 	[C h⁸ [N]]: 125
//│ case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁵ t⁵ => (fun ys⁵ -> [C h⁵ ((concat₀₂ t⁵) ys⁵)])}: 79 --->
//│ 	[N]: 106
//│ case xs³ of {N => (fun ys⁶ -> ys⁶) | C h⁶ t⁶ => (fun ys⁷ -> [C h⁶ ((concat₀₀ t⁶) ys⁷)])}: 98 --->
//│ 	[C h⁵ ((concat₀₂ t⁵) ys⁵)]: 77
//│ 	[N]: 113
//│ 	[C h⁹ [N]]: 114
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (rev₀₁ 
//│ 	let h⁷ = 1
//│ 	in let t⁷ = 	
//│ 		let h⁸ = 2
//│ 		in let t⁸ = 	
//│ 			let h⁹ = 3
//│ 			in let t⁹ = (fun ys⁸ -> ys⁸)
//│ 			in ((concat₀₂ (rev₀₃ t⁹)) 
//│ 				let h¹⁰ = h⁹
//│ 				in let t¹⁰ = (fun ys¹¹ -> ys¹¹)
//│ 				in (fun ys⁹ -> 
//│ 					let h¹¹ = h¹⁰
//│ 					in let t¹¹ = ((concat₀₀ t¹⁰) ys⁹)
//│ 					in (fun ys¹⁰ -> [C h¹¹ ((concat₀₁ t¹¹) ys¹⁰)])))
//│ 		in ((concat₀₀ (rev₀₀ t⁸)) 
//│ 			let h¹² = h⁸
//│ 			in let t¹² = (fun ys¹³ -> ys¹³)
//│ 			in (fun ys¹² -> [C h¹² ((concat₀₁ t¹²) ys¹²)]))
//│ 	in ((concat₀₁ (rev₀₂ t⁷)) [C h⁷ [N]]))
//│ def concat₀₀ = 
//│ 	(fun xs⁴ -> xs⁴)
//│ def concat₀₁ = 
//│ 	(fun xs⁶ -> xs⁶)
//│ def concat₀₂ = 
//│ 	(fun xs⁵ -> xs⁵)
//│ def rev₀₀ = 
//│ 	(fun ls⁷ -> ls⁷)
//│ def rev₀₁ = 
//│ 	(fun ls⁸ -> ls⁸)
//│ def rev₀₂ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ def rev₀₃ = 
//│ 	(fun ls⁵ -> ls⁵)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 3 [C 2 [C 1 [N]]]]
//│ <<<<<<< evaluate <<<<<<<


// NOTE: if there is no concrete list provided as input, no fusion will be done
_LUMBERHACK_EVAL
fun concat(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(primitive)
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|primitive|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (primitive,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (rev^26 primitive⁰)
//│ def concat = (fun xs⁰ -> (fun ys⁰ -> case xs⁰ of {
//│ 	N => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ ((concat^4 t⁰) ys⁰)]}))
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	C h¹ t¹ => ((concat^14 (rev^15 t¹)) [C h¹ [N]])
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ case primitive⁰ of {
//│ 	C h¹ t¹ => ((concat (rev t¹)) [C h¹ [N]])
//│ 	| N => [N]}
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^26] (hopeless to continue)
//│ 	[rev^26 · concat^14] (using original def)
//│ 		[rev^26 · concat^14 · concat^4] ---> [rev^26 · concat^14] (using original def)
//│ 	[rev^26 · rev^15] ---> [rev^26] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (rev₀ primitive⁰)
//│ def rev₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]])
//│ 		| N => [N]})
//│ 	where
//│ 	def concat₀ = 
//│ 		(fun xs¹ -> (fun ys¹ -> case xs¹ of {
//│ 			N => ys¹
//│ 			| C h² t² => [C h² ((concat₀ t²) ys¹)]}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h² ((concat₀ t²) ys¹)]: 37 --->
//│ 	'lumberhackTopLevelResult
//│ 	case xs¹ of {N => ys¹ | C h² t² => [C h² ((concat₀ t²) ys¹)]}: 38
//│ [N]: 48 --->
//│ 	case xs¹ of {N => ys¹ | C h² t² => [C h² ((concat₀ t²) ys¹)]}: 38
//│ [C h³ [N]]: 49 --->
//│ 	'lumberhackTopLevelResult
//│ 	case xs¹ of {N => ys¹ | C h² t² => [C h² ((concat₀ t²) ys¹)]}: 38
//│ [N]: 51 --->
//│ 	'lumberhackTopLevelResult
//│ 	case xs¹ of {N => ys¹ | C h² t² => [C h² ((concat₀ t²) ys¹)]}: 38
//│ ------------------
//│ case xs¹ of {N => ys¹ | C h² t² => [C h² ((concat₀ t²) ys¹)]}: 38 --->
//│ 	[C h² ((concat₀ t²) ys¹)]: 37
//│ 	[N]: 48
//│ 	[C h³ [N]]: 49
//│ 	[N]: 51
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (rev₀ primitive⁰)
//│ def rev₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]])
//│ 		| N => [N]})
//│ 	where
//│ 	def concat₀ = 
//│ 		(fun xs² -> (fun ys² -> case xs² of {
//│ 			N => ys²
//│ 			| C h² t² => [C h² ((concat₀ t²) ys²)]}))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ case primitive⁰ of {
//│ 	C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]])
//│ 	| N => [N]}
//│ <<<<<<< evaluate <<<<<<<
