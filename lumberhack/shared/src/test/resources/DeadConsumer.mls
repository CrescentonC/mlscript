:NewParser
:ParseOnly

:d
:lhGenOCaml
fun f(x) =
  if True then lazy(f(x)) else lazy(f(C)) // adding lazy to make ocam repl terminate
fun g(x) = if x is                        //  but f never checks its argument, so x has no upper bound
  D then x
  C then x
f(g(D))                                   // D gets fused and becomes x => x, g get fused and becomes x(x), so type of g'(x => x) is not compatible with C
//│ |#fun| |f|(|x|)| |#=|→|#if| |True| |#then| |lazy|(|f|(|x|)|)| |#else| |lazy|(|f|(|C|)|)| |/* adding lazy to make ocam repl terminate*/|←|↵|#fun| |g|(|x|)| |#=| |#if| |x| |is| |/*  but f never checks its argument, so x has no upper bound*/|→|D| |#then| |x|↵|C| |#then| |x|←|↵|f|(|g|(|D|)|)| |/* D gets fused and becomes x => x, g get fused and becomes x(x), so type of g'(x => x) is not compatible with C*/|
//│ Parsed: {fun f = x, => {if (True) then lazy (f (x,),) else lazy (f (C,),)}; fun g = x, => if x is ‹(D) then x; (C) then x›; f (g (D,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^19(g^20([D]))
//│ def f(x⁰) = if [True] then lazy⁰(f^3(x⁰)) else lazy⁰(f^8([C]))
//│ def g(x¹) = case x¹ of {
//│ 	D  => x¹
//│ 	| C  => x¹}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f x_0 =
//│ 		  (if true then
//│ 		    (lazy (f x_0))
//│ 		  else
//│ 		    (lazy (f (`C))));;
//│ 		let rec g x_1 =
//│ 		  (match x_1 with
//│ 		    | `D -> 
//│ 		      x_1
//│ 		    | `C -> 
//│ 		      x_1);;
//│ 		(f (g (`D)))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		        val f : [> `C ] -> ('a lazy_t as 'a) = <fun>
//│ 		[ok]
//│ 		            val g : ([< `C | `D ] as 'a) -> 'a = <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [D]: 21 --->
//│ 	DeadCodeCons
//│ 	case x¹ of {D  => x¹ | C  => x¹}: 17
//│ ------------------
//│ case x¹ of {D  => x¹ | C  => x¹}: 17 --->
//│ 	[D]: 21
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f(g([D]))
//│ def f(x²) = if [True] then lazy⁰(f(x²)) else lazy⁰(f([C]))
//│ def g(x³) = case x³ of {
//│ 	D  => x³
//│ 	| C  => x³}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f(g([D]))
//│ def f(x⁰) = if [True] then lazy⁰(f(x⁰)) else lazy⁰(f([C]))
//│ def g(x¹) = case x¹ of {
//│ 	D  => x¹
//│ 	| C  => x¹}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f(g([D]))
//│ def f(x⁰) = if [True] then lazy⁰(f(x⁰)) else lazy⁰(f([C]))
//│ def g(x¹) = case x¹ of {
//│ 	D  => x¹
//│ 	| C  => x¹}
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ f :: 'f <: [] ::: true
//│ g :: 'g <: [] ::: true
//│ [D] :: D ::: true
//│ g([D]) :: '4_callres <: [] ::: true
//│ f(g([D])) :: '5_callres <: [] ::: true
//│ [True] :: True ::: true
//│ f :: 'f <: [] ::: true
//│ x :: 'x⁰ <: [] ::: true
//│ f(x) :: '10_callres <: [] ::: true
//│ lazy(f(x)) :: '10_callres <: [] ::: true
//│ f :: 'f <: [] ::: true
//│ [C] :: C ::: true
//│ f([C]) :: '15_callres <: [] ::: true
//│ lazy(f([C])) :: '15_callres <: [] ::: true
//│ if [True] then lazy(f(x)) else lazy(f([C])) :: '17_ifres <: [] ::: true
//│ (fun x -> if [True] then lazy(f(x)) else lazy(f([C]))) :: 'x⁰ => '17_ifres ::: true
//│ x :: 'x¹ <: [] ::: true
//│ x :: 'x¹ <: [] ::: true
//│ x :: 'x¹ <: [] ::: true
//│ case x of {D  => x | C  => x} :: '22_matchres <: [] ::: true
//│ (fun x -> case x of {D  => x | C  => x}) :: 'x¹ => '22_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec f x_0 =
//│   (if true then
//│     (lazy (f x_0))
//│   else
//│     (lazy (f (`C))));;
//│ let rec g x_1 =
//│   (match x_1 with
//│     | `D -> 
//│       x_1
//│     | `C -> 
//│       x_1);;
//│ (f (g (`D)))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│   - : 'a lazy_t as 'a = <lazy>
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
