:NewParser
:ParseOnly


fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
last(C(1, C(2, N)))
//│ |#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; last (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (last^14 [C 1 [C 2 [N]]])
//│ def last = (fun xs⁰ -> case xs⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		C hh⁰ tt⁰ => (last^3 [C hh⁰ tt⁰])
//│ 		| N => [Some h⁰]}
//│ 	| N => [None]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^14]
//│ 	[last^14 · last^3] ---> [last^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (last₀ [C 1 [C 2 [N]]])
//│ def last₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		C h¹ t¹ => case t¹ of {
//│ 			C hh¹ tt¹ => (last₀ [C hh¹ tt¹])
//│ 			| N => [Some h¹]}
//│ 		| N => [None]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 26 --->
//│ 	case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h¹]} | N => [None]}: 32
//│ [N]: 37 --->
//│ 	case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h¹]}: 30
//│ [C 2 [N]]: 38 --->
//│ 	case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h¹]}: 30
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h¹]} | N => [None]}: 32
//│ ------------------
//│ case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h¹]}: 30 --->
//│ 	[N]: 37
//│ 	[C 2 [N]]: 38
//│ case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h¹]} | N => [None]}: 32 --->
//│ 	[C hh¹ tt¹]: 26
//│ 	[C 1 [C 2 [N]]]: 39
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C hh¹ tt¹]: 26 --->
//│ 	case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h¹]} | N => [None]}: 32
//│ [N]: 37 --->
//│ 	case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h¹]}: 30
//│ [C 2 [N]]: 38 --->
//│ 	case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h¹]}: 30
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h¹]} | N => [None]}: 32
//│ ------------------
//│ case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h¹]}: 30 --->
//│ 	[N]: 37
//│ 	[C 2 [N]]: 38
//│ case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h¹]} | N => [None]}: 32 --->
//│ 	[C hh¹ tt¹]: 26
//│ 	[C 1 [C 2 [N]]]: 39
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (last₀ 
//│ 	let h² = 1
//│ 	in let t² = 	
//│ 		let hh² = 2
//│ 		in let tt² = (fun h⁵ -> [Some h⁵])
//│ 		in (fun h³ -> (last₀ 
//│ 			let h⁴ = hh²
//│ 			in let t³ = tt²
//│ 			in (t³ h⁴)))
//│ 	in (t² h²))
//│ def last₀ = 
//│ 	(fun xs² -> xs²)
//│ <<<<<<< after fusion <<<<<<<

fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
last(primitive)
//│ |#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|primitive|)|
//│ Parsed: {fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; last (primitive,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (last^14 primitive⁰)
//│ def last = (fun xs⁰ -> case xs⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		C hh⁰ tt⁰ => (last^3 [C hh⁰ tt⁰])
//│ 		| N => [Some h⁰]}
//│ 	| N => [None]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^14] (hopeless to continue)
//│ 	[last^14 · last^3] ---> [last^14] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (last₀ primitive⁰)
//│ def last₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		C h¹ t¹ => case t¹ of {
//│ 			C hh¹ tt¹ => (last₀ [C hh¹ tt¹])
//│ 			| N => [Some h¹]}
//│ 		| N => [None]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 22 --->
//│ 	case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h¹]} | N => [None]}: 28
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h¹]} | N => [None]}: 28 --->
//│ 	[C hh¹ tt¹]: 22
//│ 	NoProd
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (last₀ primitive⁰)
//│ def last₀ = 
//│ 	(fun xs² -> case xs² of {
//│ 		C h¹ t¹ => case t¹ of {
//│ 			C hh¹ tt¹ => (last₀ [C hh¹ tt¹])
//│ 			| N => [Some h¹]}
//│ 		| N => [None]})
//│ <<<<<<< after fusion <<<<<<<


// NOTE: map is unrolled twice, and some call-pattern specialization can be done
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
last(map(primitive, primitive))
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|map|(|primitive|,| |primitive|)|)|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; last (map (primitive, primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (last^28 ((map^29 primitive⁰) primitive⁰))
//│ def last = (fun xs⁰ -> case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => (last^17 [C hh⁰ tt⁰])
//│ 		| N => [Some h¹]}
//│ 	| N => [None]})
//│ def map = (fun ls⁰ -> (fun f⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C (f⁰ h⁰) ((map^5 t⁰) f⁰)]
//│ 	| N => [N]}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^28]
//│ 	[last^28 · last^17] ---> [last^28] (only one)
//│ [map^29]
//│ 	[map^29 · map^5]
//│ 		[map^29 · map^5 · map^5] ---> [map^29 · map^5] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (last₀ ((map₀ primitive⁰) primitive⁰))
//│ def last₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		C h² t² => case t² of {
//│ 			C hh¹ tt¹ => (last₀ [C hh¹ tt¹])
//│ 			| N => [Some h²]}
//│ 		| N => [None]})
//│ def map₀ = 
//│ 	(fun ls² -> (fun f² -> case ls² of {
//│ 		C h⁴ t⁴ => [C (f² h⁴) ((map₁ t⁴) f²)]
//│ 		| N => [N]}))
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls¹ -> (fun f¹ -> case ls¹ of {
//│ 			C h³ t³ => [C (f¹ h³) ((map₁ t³) f¹)]
//│ 			| N => [N]}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 40 --->
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h²]} | N => [None]}: 46
//│ [C (f¹ h³) ((map₁ t³) f¹)]: 57 --->
//│ 	case t² of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h²]}: 44
//│ [N]: 58 --->
//│ 	case t² of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h²]}: 44
//│ [C (f² h⁴) ((map₁ t⁴) f²)]: 71 --->
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h²]} | N => [None]}: 46
//│ [N]: 72 --->
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h²]} | N => [None]}: 46
//│ ------------------
//│ case t² of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h²]}: 44 --->
//│ 	[C (f¹ h³) ((map₁ t³) f¹)]: 57
//│ 	[N]: 58
//│ case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h²]} | N => [None]}: 46 --->
//│ 	[C hh¹ tt¹]: 40
//│ 	[C (f² h⁴) ((map₁ t⁴) f²)]: 71
//│ 	[N]: 72
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C hh¹ tt¹]: 40 --->
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h²]} | N => [None]}: 46
//│ [C (f¹ h³) ((map₁ t³) f¹)]: 57 --->
//│ 	case t² of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h²]}: 44
//│ [N]: 58 --->
//│ 	case t² of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h²]}: 44
//│ [C (f² h⁴) ((map₁ t⁴) f²)]: 71 --->
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h²]} | N => [None]}: 46
//│ [N]: 72 --->
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h²]} | N => [None]}: 46
//│ ------------------
//│ case t² of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h²]}: 44 --->
//│ 	[C (f¹ h³) ((map₁ t³) f¹)]: 57
//│ 	[N]: 58
//│ case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N => [Some h²]} | N => [None]}: 46 --->
//│ 	[C hh¹ tt¹]: 40
//│ 	[C (f² h⁴) ((map₁ t⁴) f²)]: 71
//│ 	[N]: 72
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (last₀ ((map₀ primitive⁰) primitive⁰))
//│ def last₀ = 
//│ 	(fun xs² -> xs²)
//│ def map₀ = 
//│ 	(fun ls⁴ -> (fun f⁴ -> case ls⁴ of {
//│ 		C h⁴ t⁴ => 
//│ 			let h⁸ = (f⁴ h⁴)
//│ 			in let t⁶ = ((map₁ t⁴) f⁴)
//│ 			in (t⁶ h⁸)
//│ 		| N => [None]}))
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls³ -> (fun f³ -> case ls³ of {
//│ 			C h³ t³ => 
//│ 				let hh² = (f³ h³)
//│ 				in let tt² = ((map₁ t³) f³)
//│ 				in (fun h⁵ -> (last₀ 
//│ 					let h⁶ = hh²
//│ 					in let t⁵ = tt²
//│ 					in (t⁵ h⁶)))
//│ 			| N => (fun h⁷ -> [Some h⁷])}))
//│ <<<<<<< after fusion <<<<<<<
