:NewParser
:ParseOnly


fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
last(C(1, C(2, N)))
//│ |#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; last (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (last^14 [C 1 [C 2 [N]]])
//│ def last = (fun xs⁰ -> case xs⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		C hh⁰ tt⁰ => (last^3 [C hh⁰ tt⁰])
//│ 		| N  => [Some h⁰]}
//│ 	| N  => [None]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^14]
//│ 	[last^14 · last^3] ---> [last^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (last₀ [C 1 [C 2 [N]]])
//│ def last₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		C h¹ t¹ => case t¹ of {
//│ 			C hh¹ tt¹ => (last₀ [C hh¹ tt¹])
//│ 			| N  => [Some h¹]}
//│ 		| N  => [None]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 26 --->
//│ 	case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h¹]} | N  => [None]}: 32
//│ [N]: 37 --->
//│ 	case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h¹]}: 30
//│ [C 2 [N]]: 38 --->
//│ 	case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h¹]}: 30
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h¹]} | N  => [None]}: 32
//│ ------------------
//│ case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h¹]}: 30 --->
//│ 	[N]: 37
//│ 	[C 2 [N]]: 38
//│ case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h¹]} | N  => [None]}: 32 --->
//│ 	[C hh¹ tt¹]: 26
//│ 	[C 1 [C 2 [N]]]: 39
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C hh¹ tt¹]: 26 --->
//│ 	case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h¹]} | N  => [None]}: 32
//│ [N]: 37 --->
//│ 	case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h¹]}: 30
//│ [C 2 [N]]: 38 --->
//│ 	case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h¹]}: 30
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h¹]} | N  => [None]}: 32
//│ ------------------
//│ case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h¹]}: 30 --->
//│ 	[N]: 37
//│ 	[C 2 [N]]: 38
//│ case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h¹]} | N  => [None]}: 32 --->
//│ 	[C hh¹ tt¹]: 26
//│ 	[C 1 [C 2 [N]]]: 39
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (last₀ 
//│ 	let h² = 1
//│ 	in let t² = 	
//│ 		let hh² = 2
//│ 		in let tt² = (fun h⁵ -> [Some h⁵])
//│ 		in (fun h³ -> (last₀ 
//│ 			let h⁴ = hh²
//│ 			in let t³ = tt²
//│ 			in (t³ h⁴)))
//│ 	in (t² h²))
//│ def last₀ = 
//│ 	(fun xs² -> xs²)
//│ <<<<<<< after fusion <<<<<<<

fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
last(primitive)
//│ |#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|primitive|)|
//│ Parsed: {fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; last (primitive,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (last^14 primitive⁰)
//│ def last = (fun xs⁰ -> case xs⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		C hh⁰ tt⁰ => (last^3 [C hh⁰ tt⁰])
//│ 		| N  => [Some h⁰]}
//│ 	| N  => [None]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^14]
//│ 	[last^14 · last^3] ---> [last^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (last₀ primitive⁰)
//│ def last₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		C h¹ t¹ => case t¹ of {
//│ 			C hh¹ tt¹ => (last₀ [C hh¹ tt¹])
//│ 			| N  => [Some h¹]}
//│ 		| N  => [None]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 22 --->
//│ 	case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h¹]} | N  => [None]}: 28
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => case t¹ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h¹]} | N  => [None]}: 28 --->
//│ 	[C hh¹ tt¹]: 22
//│ 	NoProd
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (last₀ primitive⁰)
//│ def last₀ = 
//│ 	(fun xs² -> case xs² of {
//│ 		C h¹ t¹ => case t¹ of {
//│ 			C hh¹ tt¹ => (last₀ [C hh¹ tt¹])
//│ 			| N  => [Some h¹]}
//│ 		| N  => [None]})
//│ <<<<<<< after fusion <<<<<<<


// NOTE: map is unrolled twice, and some call-pattern specialization can be done
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
last(map(primitive, primitive))
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|map|(|primitive|,| |primitive|)|)|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; last (map (primitive, primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (last^28 ((map^29 primitive⁰) primitive⁰))
//│ def last = (fun xs⁰ -> case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => (last^17 [C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]})
//│ def map = (fun ls⁰ -> (fun f⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C (f⁰ h⁰) ((map^5 t⁰) f⁰)]
//│ 	| N  => [N]}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^28]
//│ 	[last^28 · last^17] ---> [last^28] (only one)
//│ [map^29]
//│ 	[map^29 · map^5] ---> [map^29] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (last₀ ((map₀ primitive⁰) primitive⁰))
//│ def last₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		C h³ t³ => case t³ of {
//│ 			C hh¹ tt¹ => (last₀ [C hh¹ tt¹])
//│ 			| N  => [Some h³]}
//│ 		| N  => [None]})
//│ def map₀ = 
//│ 	(fun ls¹ -> (fun f¹ -> case ls¹ of {
//│ 		C h² t² => [C (f¹ h²) ((map₀ t²) f¹)]
//│ 		| N  => [N]}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C (f¹ h²) ((map₀ t²) f¹)]: 44 --->
//│ 	case t³ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h³]}: 58
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 60
//│ [N]: 45 --->
//│ 	case t³ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h³]}: 58
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 60
//│ [C hh¹ tt¹]: 54 --->
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 60
//│ ------------------
//│ case t³ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h³]}: 58 --->
//│ 	[C (f¹ h²) ((map₀ t²) f¹)]: 44
//│ 	[N]: 45
//│ case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => (last₀ [C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 60 --->
//│ 	[C (f¹ h²) ((map₀ t²) f¹)]: 44
//│ 	[N]: 45
//│ 	[C hh¹ tt¹]: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (last₀ ((map₀ primitive⁰) primitive⁰))
//│ def last₀ = 
//│ 	(fun xs² -> case xs² of {
//│ 		C h³ t³ => case t³ of {
//│ 			C hh¹ tt¹ => (last₀ [C hh¹ tt¹])
//│ 			| N  => [Some h³]}
//│ 		| N  => [None]})
//│ def map₀ = 
//│ 	(fun ls² -> (fun f² -> case ls² of {
//│ 		C h² t² => [C (f² h²) ((map₀ t²) f²)]
//│ 		| N  => [N]}))
//│ <<<<<<< after fusion <<<<<<<
