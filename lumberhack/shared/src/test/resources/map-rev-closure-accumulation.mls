:NewParser
:ParseOnly

// NOTE: single rev
_LUMBERHACK_EVAL
fun rev(ys, a) = if ys is
  C(h, t) then rev(t, C(h, a))
  N then a
rev(C(1, C(2, N)), N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ys|,| |a|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a|←|↵|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|,| |N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ys, a, => if ys is ‹(C (h, t,)) then rev (t, C (h, a,),); (N) then a›; rev (C (1, C (2, N,),), N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^13([C 1 [C 2 [N]]], [N])
//│ def rev(ys⁰, a⁰) = case ys⁰ of {
//│ 	C h⁰ t⁰ => rev^2(t⁰, [C h⁰ a⁰])
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^13] (hopeless to continue)
//│ 	[rev^13 · rev^2] ---> [rev^13] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀([C 1 [C 2 [N]]], [N])
//│ def rev_₀(ys¹, a¹) = 
//│ 	case ys¹ of {
//│ 		C h¹ t¹ => rev_₀(t¹, [C h¹ a¹])
//│ 		| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 37 --->
//│ 	case ys¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 31
//│ [C 2 [N]]: 38 --->
//│ 	case ys¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 31
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case ys¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 31
//│ ------------------
//│ case ys¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 31 --->
//│ 	[N]: 37
//│ 	[C 2 [N]]: 38
//│ 	[C 1 [C 2 [N]]]: 39
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 37 --->
//│ 	case ys¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 31
//│ [C 2 [N]]: 38 --->
//│ 	case ys¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 31
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case ys¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 31
//│ ------------------
//│ case ys¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 31 --->
//│ 	[N]: 37
//│ 	[C 2 [N]]: 38
//│ 	[C 1 [C 2 [N]]]: 39
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(
//│ 	let t² = 	
//│ 		let t³ = (fun a⁴ -> a⁴)
//│ 		in let h³ = 2
//│ 		in (fun a³ -> rev_₀(t³, [C h³ a³]))
//│ 	in let h² = 1
//│ 	in (fun a² -> rev_₀(t², [C h² a²])), [N])
//│ def rev_₀(ys², a⁵) = 
//│ 	ys²(a⁵)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<

// NOTE: single rev, paper style of pushing in
_LUMBERHACK_EVAL
fun rev(ys) = if ys is
  C(h, t) then a => rev(t, C(h, a))
  N then a => a
rev(C(1, C(2, N)))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ys, => if ys is ‹(C (h, t,)) then a, => rev (t, C (h, a,),); (N) then a, => a›; rev (C (1, C (2, N,),),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^14([C 1 [C 2 [N]]], [N])
//│ def rev(ys⁰) = case ys⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev^2(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14] (hopeless to continue)
//│ 	[rev^14 · rev^2] ---> [rev^14] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀([C 1 [C 2 [N]]], [N])
//│ def rev_₀(ys¹) = 
//│ 	case ys¹ of {
//│ 		C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²]))
//│ 		| N  => (fun a³ -> a³)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 39 --->
//│ 	case ys¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ [C 2 [N]]: 40 --->
//│ 	case ys¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ [C 1 [C 2 [N]]]: 41 --->
//│ 	case ys¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ ------------------
//│ case ys¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34 --->
//│ 	[N]: 39
//│ 	[C 2 [N]]: 40
//│ 	[C 1 [C 2 [N]]]: 41
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 39 --->
//│ 	case ys¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ [C 2 [N]]: 40 --->
//│ 	case ys¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ [C 1 [C 2 [N]]]: 41 --->
//│ 	case ys¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ ------------------
//│ case ys¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34 --->
//│ 	[N]: 39
//│ 	[C 2 [N]]: 40
//│ 	[C 1 [C 2 [N]]]: 41
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(
//│ 	let t² = 	
//│ 		let t³ = (fun a⁶ -> a⁶)
//│ 		in let h³ = 2
//│ 		in (fun a⁵ -> rev_₀(t³, [C h³ a⁵]))
//│ 	in let h² = 1
//│ 	in (fun a⁴ -> rev_₀(t², [C h² a⁴])), [N])
//│ def rev_₀(ys²) = 
//│ 	ys²
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<

// NOTE: map rev on primitive
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun rev(ys, a) = if ys is
  C(h, t) then rev(t, C(h, a))
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
map(rev(primitive, N), ff)
//│ |#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|ys|,| |a|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|map|(|rev|(|primitive|,| |N|)|,| |ff|)|
//│ Parsed: {fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun rev = ys, a, => if ys is ‹(C (h, t,)) then rev (t, C (h, a,),); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; map (rev (primitive, N,), ff,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^32(rev^33(primitive⁰, [N]), ff^39)
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ def rev(ys⁰, a⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => rev^16(t¹, [C h¹ a⁰])
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^39] (hopeless to continue)
//│ [map^32] (hopeless to continue)
//│ 	[map^32 · map^5] ---> [map^32] (using original def)
//│ [rev^33] (hopeless to continue)
//│ 	[rev^33 · rev^16] ---> [rev^33] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map_₀(rev_₀(primitive⁰, [N]), ff_₀)
//│ def ff_₀(x¹) = 
//│ 	case x¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def map_₀(xs¹, f¹) = 
//│ 	case xs¹ of {
//│ 		C h² t² => [C f¹(h²) map_₀(t², f¹)]
//│ 		| N  => [N]}
//│ def rev_₀(ys¹, a¹) = 
//│ 	case ys¹ of {
//│ 		C h³ t³ => rev_₀(t³, [C h³ a¹])
//│ 		| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h³ a¹]: 66 --->
//│ 	case xs¹ of {C h² t² => [C f¹(h²) map_₀(t², f¹)] | N  => [N]}: 57
//│ [N]: 76 --->
//│ 	case xs¹ of {C h² t² => [C f¹(h²) map_₀(t², f¹)] | N  => [N]}: 57
//│ ------------------
//│ case xs¹ of {C h² t² => [C f¹(h²) map_₀(t², f¹)] | N  => [N]}: 57 --->
//│ 	[C h³ a¹]: 66
//│ 	[N]: 76
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h³ a¹]: 66 --->
//│ 	case xs¹ of {C h² t² => [C f¹(h²) map_₀(t², f¹)] | N  => [N]}: 57
//│ [N]: 76 --->
//│ 	case xs¹ of {C h² t² => [C f¹(h²) map_₀(t², f¹)] | N  => [N]}: 57
//│ ------------------
//│ case xs¹ of {C h² t² => [C f¹(h²) map_₀(t², f¹)] | N  => [N]}: 57 --->
//│ 	[C h³ a¹]: 66
//│ 	[N]: 76
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map_₀(rev_₀(primitive⁰, (fun f² -> [N])), ff_₀)
//│ def ff_₀(x²) = 
//│ 	case x² of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def map_₀(xs², f³) = 
//│ 	xs²(f³)
//│ def rev_₀(ys², a²) = 
//│ 	case ys² of {
//│ 		C h³ t³ => rev_₀(t³, 
//│ 			let t⁴ = a²
//│ 			in let h⁴ = h³
//│ 			in (fun f⁴ -> [C f⁴(h⁴) map_₀(t⁴, f⁴)]))
//│ 		| N  => a²}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: map rev on primitive, paper style of pushing in
fun map(xs) = if xs is
  C(h, t) then f => C(f(h), map(t, f))
  N then f => N
fun rev(ys, a) = if ys is
  C(h, t) then rev(t, C(h, a))
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
map(rev(primitive, N), ff)
//│ |#fun| |map|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#fun| |rev|(|ys|,| |a|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|map|(|rev|(|primitive|,| |N|)|,| |ff|)|
//│ Parsed: {fun map = xs, => if xs is ‹(C (h, t,)) then f, => C (f (h,), map (t, f,),); (N) then f, => N›; fun rev = ys, a, => if ys is ‹(C (h, t,)) then rev (t, C (h, a,),); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; map (rev (primitive, N,), ff,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^33(rev^34(primitive⁰, [N]), ff^40)
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map^5(t⁰, f⁰)])
//│ 	| N  => (fun f¹ -> [N])}
//│ def rev(ys⁰, a⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => rev^17(t¹, [C h¹ a⁰])
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^40] (hopeless to continue)
//│ [map^33] (hopeless to continue)
//│ 	[map^33 · map^5] ---> [map^33] (using original def)
//│ [rev^34] (hopeless to continue)
//│ 	[rev^34 · rev^17] ---> [rev^34] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map_₀(rev_₀(primitive⁰, [N]), ff_₀)
//│ def ff_₀(x¹) = 
//│ 	case x¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def map_₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		C h² t² => (fun f² -> [C f²(h²) map_₀(t², f²)])
//│ 		| N  => (fun f³ -> [N])}
//│ def rev_₀(ys¹, a¹) = 
//│ 	case ys¹ of {
//│ 		C h³ t³ => rev_₀(t³, [C h³ a¹])
//│ 		| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h³ a¹]: 68 --->
//│ 	case xs¹ of {C h² t² => (fun f² -> [C f²(h²) map_₀(t², f²)]) | N  => (fun f³ -> [N])}: 60
//│ [N]: 78 --->
//│ 	case xs¹ of {C h² t² => (fun f² -> [C f²(h²) map_₀(t², f²)]) | N  => (fun f³ -> [N])}: 60
//│ ------------------
//│ case xs¹ of {C h² t² => (fun f² -> [C f²(h²) map_₀(t², f²)]) | N  => (fun f³ -> [N])}: 60 --->
//│ 	[C h³ a¹]: 68
//│ 	[N]: 78
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h³ a¹]: 68 --->
//│ 	case xs¹ of {C h² t² => (fun f² -> [C f²(h²) map_₀(t², f²)]) | N  => (fun f³ -> [N])}: 60
//│ [N]: 78 --->
//│ 	case xs¹ of {C h² t² => (fun f² -> [C f²(h²) map_₀(t², f²)]) | N  => (fun f³ -> [N])}: 60
//│ ------------------
//│ case xs¹ of {C h² t² => (fun f² -> [C f²(h²) map_₀(t², f²)]) | N  => (fun f³ -> [N])}: 60 --->
//│ 	[C h³ a¹]: 68
//│ 	[N]: 78
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map_₀(rev_₀(primitive⁰, (fun f⁴ -> [N])), ff_₀)
//│ def ff_₀(x²) = 
//│ 	case x² of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def map_₀(xs²) = 
//│ 	xs²
//│ def rev_₀(ys², a²) = 
//│ 	case ys² of {
//│ 		C h³ t³ => rev_₀(t³, 
//│ 			let t⁴ = a²
//│ 			in let h⁴ = h³
//│ 			in (fun f⁵ -> [C f⁵(h⁴) map_₀(t⁴, f⁵)]))
//│ 		| N  => a²}
//│ <<<<<<< after fusion <<<<<<<


// NOTE: rev map on primitive
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun rev(a, ys) = if ys is
  C(h, t) then rev(C(h, a), t)
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
rev(N, map(primitive, ff))
//│ |#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|rev|(|N|,| |map|(|primitive|,| |ff|)|)|
//│ Parsed: {fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun rev = a, ys, => if ys is ‹(C (h, t,)) then rev (C (h, a,), t,); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; rev (N, map (primitive, ff,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^32([N], map^35(primitive⁰, ff^38))
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => rev^16([C h¹ a⁰], t¹)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^38] (hopeless to continue)
//│ [map^35] (hopeless to continue)
//│ 	[map^35 · map^5] ---> [map^35] (using original def)
//│ [rev^32] (hopeless to continue)
//│ 	[rev^32 · rev^16] ---> [rev^32] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀([N], map_₀(primitive⁰, ff_₀))
//│ def ff_₀(x¹) = 
//│ 	case x¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def map_₀(xs¹, f¹) = 
//│ 	case xs¹ of {
//│ 		C h³ t³ => [C f¹(h³) map_₀(t³, f¹)]
//│ 		| N  => [N]}
//│ def rev_₀(a¹, ys¹) = 
//│ 	case ys¹ of {
//│ 		C h² t² => rev_₀([C h² a¹], t²)
//│ 		| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f¹(h³) map_₀(t³, f¹)]: 62 --->
//│ 	case ys¹ of {C h² t² => rev_₀([C h² a¹], t²) | N  => a¹}: 50
//│ [N]: 63 --->
//│ 	case ys¹ of {C h² t² => rev_₀([C h² a¹], t²) | N  => a¹}: 50
//│ ------------------
//│ case ys¹ of {C h² t² => rev_₀([C h² a¹], t²) | N  => a¹}: 50 --->
//│ 	[C f¹(h³) map_₀(t³, f¹)]: 62
//│ 	[N]: 63
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f¹(h³) map_₀(t³, f¹)]: 62 --->
//│ 	case ys¹ of {C h² t² => rev_₀([C h² a¹], t²) | N  => a¹}: 50
//│ [N]: 63 --->
//│ 	case ys¹ of {C h² t² => rev_₀([C h² a¹], t²) | N  => a¹}: 50
//│ ------------------
//│ case ys¹ of {C h² t² => rev_₀([C h² a¹], t²) | N  => a¹}: 50 --->
//│ 	[C f¹(h³) map_₀(t³, f¹)]: 62
//│ 	[N]: 63
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀([N], map_₀(primitive⁰, ff_₀))
//│ def ff_₀(x²) = 
//│ 	case x² of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def map_₀(xs², f²) = 
//│ 	case xs² of {
//│ 		C h³ t³ => 
//│ 			let t⁴ = map_₀(t³, f²)
//│ 			in let h⁴ = f²(h³)
//│ 			in (fun a³ -> rev_₀([C h⁴ a³], t⁴))
//│ 		| N  => (fun a⁴ -> a⁴)}
//│ def rev_₀(a², ys²) = 
//│ 	ys²(a²)
//│ <<<<<<< after fusion <<<<<<<


// NOTE: rev map on primitive, paper style pushing in
fun map(xs) = if xs is
  C(h, t) then f => C(f(h), map(t, f))
  N then f => N
fun rev(ys) = if ys is
  C(h, t) then a => rev(t, C(h, a))
  N then a => a
fun ff(x) = if x is
  A then AA
  B then BB
rev(map(primitive, ff), N)
//│ |#fun| |map|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#fun| |rev|(|ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|rev|(|map|(|primitive|,| |ff|)|,| |N|)|
//│ Parsed: {fun map = xs, => if xs is ‹(C (h, t,)) then f, => C (f (h,), map (t, f,),); (N) then f, => N›; fun rev = ys, => if ys is ‹(C (h, t,)) then a, => rev (t, C (h, a,),); (N) then a, => a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; rev (map (primitive, ff,), N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^34(map^35(primitive⁰, ff^38), [N])
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map^5(t⁰, f⁰)])
//│ 	| N  => (fun f¹ -> [N])}
//│ def rev(ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => (fun a⁰ -> rev^17(t¹, [C h¹ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^38] (hopeless to continue)
//│ [map^35] (hopeless to continue)
//│ 	[map^35 · map^5] ---> [map^35] (using original def)
//│ [rev^34] (hopeless to continue)
//│ 	[rev^34 · rev^17] ---> [rev^34] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀(map_₀(primitive⁰, ff_₀), [N])
//│ def ff_₀(x¹) = 
//│ 	case x¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def map_₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		C h³ t³ => (fun f² -> [C f²(h³) map_₀(t³, f²)])
//│ 		| N  => (fun f³ -> [N])}
//│ def rev_₀(ys¹) = 
//│ 	case ys¹ of {
//│ 		C h² t² => (fun a² -> rev_₀(t², [C h² a²]))
//│ 		| N  => (fun a³ -> a³)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f²(h³) map_₀(t³, f²)]: 70 --->
//│ 	case ys¹ of {C h² t² => (fun a² -> rev_₀(t², [C h² a²])) | N  => (fun a³ -> a³)}: 59
//│ [N]: 72 --->
//│ 	case ys¹ of {C h² t² => (fun a² -> rev_₀(t², [C h² a²])) | N  => (fun a³ -> a³)}: 59
//│ ------------------
//│ case ys¹ of {C h² t² => (fun a² -> rev_₀(t², [C h² a²])) | N  => (fun a³ -> a³)}: 59 --->
//│ 	[C f²(h³) map_₀(t³, f²)]: 70
//│ 	[N]: 72
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f²(h³) map_₀(t³, f²)]: 70 --->
//│ 	case ys¹ of {C h² t² => (fun a² -> rev_₀(t², [C h² a²])) | N  => (fun a³ -> a³)}: 59
//│ [N]: 72 --->
//│ 	case ys¹ of {C h² t² => (fun a² -> rev_₀(t², [C h² a²])) | N  => (fun a³ -> a³)}: 59
//│ ------------------
//│ case ys¹ of {C h² t² => (fun a² -> rev_₀(t², [C h² a²])) | N  => (fun a³ -> a³)}: 59 --->
//│ 	[C f²(h³) map_₀(t³, f²)]: 70
//│ 	[N]: 72
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(map_₀(primitive⁰, ff_₀), [N])
//│ def ff_₀(x²) = 
//│ 	case x² of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def map_₀(xs²) = 
//│ 	case xs² of {
//│ 		C h³ t³ => (fun f⁴ -> 
//│ 			let t⁴ = map_₀(t³, f⁴)
//│ 			in let h⁴ = f⁴(h³)
//│ 			in (fun a⁴ -> rev_₀(t⁴, [C h⁴ a⁴])))
//│ 		| N  => (fun f⁵ -> (fun a⁵ -> a⁵))}
//│ def rev_₀(ys²) = 
//│ 	ys²
//│ <<<<<<< after fusion <<<<<<<
