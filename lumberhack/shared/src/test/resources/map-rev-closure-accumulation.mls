:NewParser
:ParseOnly

// NOTE: single rev
_LUMBERHACK_EVAL
fun rev(ys, a) = if ys is
  C(h, t) then rev(t, C(h, a))
  N then a
rev(C(1, C(2, N)), N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ys|,| |a|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a|←|↵|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|,| |N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ys, a, => if ys is ‹(C (h, t,)) then rev (t, C (h, a,),); (N) then a›; rev (C (1, C (2, N,),), N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^13([C 1 [C 2 [N]]], [N])
//│ def rev(ys⁰, a⁰) = case ys⁰ of {
//│ 	C h⁰ t⁰ => rev^2(t⁰, [C h⁰ a⁰])
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 16 --->
//│ 	case ys⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ [C 2 [N]]: 17 --->
//│ 	case ys⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ [C 1 [C 2 [N]]]: 18 --->
//│ 	case ys⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ ------------------
//│ case ys⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10 --->
//│ 	[N]: 16
//│ 	[C 2 [N]]: 17
//│ 	[C 1 [C 2 [N]]]: 18
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 16 --->
//│ 	case ys⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ [C 2 [N]]: 17 --->
//│ 	case ys⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ [C 1 [C 2 [N]]]: 18 --->
//│ 	case ys⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ ------------------
//│ case ys⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10 --->
//│ 	[N]: 16
//│ 	[C 2 [N]]: 17
//│ 	[C 1 [C 2 [N]]]: 18
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(
//│ 	let t¹ = 	
//│ 		let t² = (fun a³ -> a³)
//│ 		in let h² = 2
//│ 		in (fun a² -> rev(t², [C h² a²]))
//│ 	in let h¹ = 1
//│ 	in (fun a¹ -> rev(t¹, [C h¹ a¹])), [N])
//│ def rev(ys¹, a⁴) = ys¹(a⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun a⁰ -> a⁰)
//│ 		in let h⁰ = 2
//│ 		in (fun a¹ -> t¹([C h⁰ a¹]))
//│ 	in let h¹ = 1
//│ 	in (fun a² -> t⁰([C h¹ a²]))([N])
//│ def rev(ys⁰, a³) = ys⁰(a³)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun a⁰ -> a⁰)
//│ 		in let h⁰ = 2
//│ 		in (fun a¹ -> t¹([C h⁰ a¹]))
//│ 	in let h¹ = 1
//│ 	in (fun a² -> t⁰([C h¹ a²]))([N])
//│ def rev(ys⁰, a³) = ys⁰(a³)
//│ <<<<<<< after floating out <<<<<<<

// NOTE: single rev, paper style of pushing in
_LUMBERHACK_EVAL
fun rev(ys) = if ys is
  C(h, t) then a => rev(t, C(h, a))
  N then a => a
rev(C(1, C(2, N)))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ys, => if ys is ‹(C (h, t,)) then a, => rev (t, C (h, a,),); (N) then a, => a›; rev (C (1, C (2, N,),),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^14([C 1 [C 2 [N]]], [N])
//│ def rev(ys⁰) = case ys⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev^2(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 17 --->
//│ 	case ys⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [C 2 [N]]: 18 --->
//│ 	case ys⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [C 1 [C 2 [N]]]: 19 --->
//│ 	case ys⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ ------------------
//│ case ys⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12 --->
//│ 	[N]: 17
//│ 	[C 2 [N]]: 18
//│ 	[C 1 [C 2 [N]]]: 19
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 17 --->
//│ 	case ys⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [C 2 [N]]: 18 --->
//│ 	case ys⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [C 1 [C 2 [N]]]: 19 --->
//│ 	case ys⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ ------------------
//│ case ys⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12 --->
//│ 	[N]: 17
//│ 	[C 2 [N]]: 18
//│ 	[C 1 [C 2 [N]]]: 19
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(
//│ 	let t¹ = 	
//│ 		let t² = (fun a⁴ -> a⁴)
//│ 		in let h² = 2
//│ 		in (fun a³ -> rev(t², [C h² a³]))
//│ 	in let h¹ = 1
//│ 	in (fun a² -> rev(t¹, [C h¹ a²])), [N])
//│ def rev(ys¹) = ys¹
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ let t⁰ = 	
//│ 	let t¹ = (fun a⁰ -> a⁰)
//│ 	in let h⁰ = 2
//│ 	in (fun a¹ -> t¹([C h⁰ a¹]))
//│ in let h¹ = 1
//│ in t⁰([C h¹ [N]])
//│ def rev(ys⁰) = ys⁰
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ let t⁰ = 	
//│ 	let t¹ = (fun a⁰ -> a⁰)
//│ 	in let h⁰ = 2
//│ 	in (fun a¹ -> t¹([C h⁰ a¹]))
//│ in let h¹ = 1
//│ in t⁰([C h¹ [N]])
//│ def rev(ys⁰) = ys⁰
//│ <<<<<<< after floating out <<<<<<<

// NOTE: map rev on primitive
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun rev(ys, a) = if ys is
  C(h, t) then rev(t, C(h, a))
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
map(rev(primitive, N), ff)
//│ |#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|ys|,| |a|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|map|(|rev|(|primitive|,| |N|)|,| |ff|)|
//│ Parsed: {fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun rev = ys, a, => if ys is ‹(C (h, t,)) then rev (t, C (h, a,),); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; map (rev (primitive, N,), ff,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^32(rev^33(primitive⁰, [N]), ff^39)
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ def rev(ys⁰, a⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => rev^16(t¹, [C h¹ a⁰])
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ a⁰]: 21 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [N]: 36 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12 --->
//│ 	[C h¹ a⁰]: 21
//│ 	[N]: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a⁰]: 21 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [N]: 36 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12 --->
//│ 	[C h¹ a⁰]: 21
//│ 	[N]: 36
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(rev(primitive⁰, (fun f¹ -> [N])), ff)
//│ def ff(x¹) = case x¹ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs¹, f²) = xs¹(f²)
//│ def rev(ys¹, a¹) = case ys¹ of {
//│ 	C h¹ t¹ => rev(t¹, 
//│ 		let t² = a¹
//│ 		in let h² = h¹
//│ 		in (fun f³ -> [C f³(h²) map(t², f³)]))
//│ 	| N  => a¹}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ rev -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ rev(primitive⁰, (fun f⁰ -> [N]), ff)
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f¹) = xs⁰(f¹)
//│ def rev(ys⁰, a⁰) = case ys⁰ of {
//│ 	C h⁰ t⁰ => rev(t⁰, 
//│ 		let t¹ = a⁰
//│ 		in let h¹ = h⁰
//│ 		in (fun f² -> [C f²(h¹) t¹(f²)]))
//│ 	| N  => a⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ rev(primitive⁰, (fun f⁰ -> [N]), ff)
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f¹) = xs⁰(f¹)
//│ def rev(ys⁰, a⁰) = case ys⁰ of {
//│ 	C h⁰ t⁰ => rev(t⁰, 
//│ 		let t¹ = a⁰
//│ 		in let h¹ = h⁰
//│ 		in (fun f² -> [C f²(h¹) t¹(f²)]))
//│ 	| N  => a⁰}
//│ <<<<<<< after floating out <<<<<<<

// NOTE: map rev on primitive, paper style of pushing in
fun map(xs) = if xs is
  C(h, t) then f => C(f(h), map(t, f))
  N then f => N
fun rev(ys, a) = if ys is
  C(h, t) then rev(t, C(h, a))
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
map(rev(primitive, N), ff)
//│ |#fun| |map|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#fun| |rev|(|ys|,| |a|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|map|(|rev|(|primitive|,| |N|)|,| |ff|)|
//│ Parsed: {fun map = xs, => if xs is ‹(C (h, t,)) then f, => C (f (h,), map (t, f,),); (N) then f, => N›; fun rev = ys, a, => if ys is ‹(C (h, t,)) then rev (t, C (h, a,),); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; map (rev (primitive, N,), ff,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^33(rev^34(primitive⁰, [N]), ff^40)
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map^5(t⁰, f⁰)])
//│ 	| N  => (fun f¹ -> [N])}
//│ def rev(ys⁰, a⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => rev^17(t¹, [C h¹ a⁰])
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ a⁰]: 22 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14
//│ [N]: 37 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14 --->
//│ 	[C h¹ a⁰]: 22
//│ 	[N]: 37
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a⁰]: 22 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14
//│ [N]: 37 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14 --->
//│ 	[C h¹ a⁰]: 22
//│ 	[N]: 37
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(rev(primitive⁰, (fun f² -> [N])), ff)
//│ def ff(x¹) = case x¹ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs¹) = xs¹
//│ def rev(ys¹, a¹) = case ys¹ of {
//│ 	C h¹ t¹ => rev(t¹, 
//│ 		let t² = a¹
//│ 		in let h² = h¹
//│ 		in (fun f³ -> [C f³(h²) map(t², f³)]))
//│ 	| N  => a¹}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ rev -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ rev(primitive⁰, (fun f⁰ -> [N]), ff)
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰) = xs⁰
//│ def rev(ys⁰, a⁰) = case ys⁰ of {
//│ 	C h⁰ t⁰ => rev(t⁰, 
//│ 		let t¹ = a⁰
//│ 		in let h¹ = h⁰
//│ 		in (fun f¹ -> [C f¹(h¹) t¹(f¹)]))
//│ 	| N  => a⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ rev(primitive⁰, (fun f⁰ -> [N]), ff)
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰) = xs⁰
//│ def rev(ys⁰, a⁰) = case ys⁰ of {
//│ 	C h⁰ t⁰ => rev(t⁰, 
//│ 		let t¹ = a⁰
//│ 		in let h¹ = h⁰
//│ 		in (fun f¹ -> [C f¹(h¹) t¹(f¹)]))
//│ 	| N  => a⁰}
//│ <<<<<<< after floating out <<<<<<<


// NOTE: rev map on primitive
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun rev(a, ys) = if ys is
  C(h, t) then rev(C(h, a), t)
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
rev(N, map(primitive, ff))
//│ |#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|rev|(|N|,| |map|(|primitive|,| |ff|)|)|
//│ Parsed: {fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun rev = a, ys, => if ys is ‹(C (h, t,)) then rev (C (h, a,), t,); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; rev (N, map (primitive, ff,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^32([N], map^35(primitive⁰, ff^38))
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => rev^16([C h¹ a⁰], t¹)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ [N]: 11 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ ------------------
//│ case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ [N]: 11 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ ------------------
//│ case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev([N], map(primitive⁰, ff))
//│ def ff(x¹) = case x¹ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs¹, f¹) = case xs¹ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t² = map(t⁰, f¹)
//│ 		in let h² = f¹(h⁰)
//│ 		in (fun a¹ -> rev([C h² a¹], t²))
//│ 	| N  => (fun a² -> a²)}
//│ def rev(a³, ys¹) = ys¹(a³)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ map -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ map(primitive⁰, ff, [N])
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t¹ = map(t⁰, f⁰)
//│ 		in let h¹ = f⁰(h⁰)
//│ 		in (fun a⁰ -> t¹([C h¹ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ def rev(a², ys⁰) = ys⁰(a²)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ map(primitive⁰, ff, [N])
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f⁰, _lh_popOutId_0⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t¹ = map(t⁰, f⁰)
//│ 		in let h¹ = f⁰(h⁰)
//│ 		in t¹([C h¹ _lh_popOutId_0⁰])
//│ 	| N  => _lh_popOutId_0⁰}
//│ def rev(a⁰, ys⁰) = ys⁰(a⁰)
//│ <<<<<<< after floating out <<<<<<<


// NOTE: rev map on primitive, paper style pushing in
fun map(xs) = if xs is
  C(h, t) then f => C(f(h), map(t, f))
  N then f => N
fun rev(ys) = if ys is
  C(h, t) then a => rev(t, C(h, a))
  N then a => a
fun ff(x) = if x is
  A then AA
  B then BB
rev(map(primitive, ff), N)
//│ |#fun| |map|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#fun| |rev|(|ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|rev|(|map|(|primitive|,| |ff|)|,| |N|)|
//│ Parsed: {fun map = xs, => if xs is ‹(C (h, t,)) then f, => C (f (h,), map (t, f,),); (N) then f, => N›; fun rev = ys, => if ys is ‹(C (h, t,)) then a, => rev (t, C (h, a,),); (N) then a, => a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; rev (map (primitive, ff,), N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^34(map^35(primitive⁰, ff^38), [N])
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map^5(t⁰, f⁰)])
//│ 	| N  => (fun f¹ -> [N])}
//│ def rev(ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => (fun a⁰ -> rev^17(t¹, [C h¹ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case ys⁰ of {C h¹ t¹ => (fun a⁰ -> rev(t¹, [C h¹ a⁰])) | N  => (fun a¹ -> a¹)}: 27
//│ [N]: 12 --->
//│ 	case ys⁰ of {C h¹ t¹ => (fun a⁰ -> rev(t¹, [C h¹ a⁰])) | N  => (fun a¹ -> a¹)}: 27
//│ ------------------
//│ case ys⁰ of {C h¹ t¹ => (fun a⁰ -> rev(t¹, [C h¹ a⁰])) | N  => (fun a¹ -> a¹)}: 27 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 12
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case ys⁰ of {C h¹ t¹ => (fun a⁰ -> rev(t¹, [C h¹ a⁰])) | N  => (fun a¹ -> a¹)}: 27
//│ [N]: 12 --->
//│ 	case ys⁰ of {C h¹ t¹ => (fun a⁰ -> rev(t¹, [C h¹ a⁰])) | N  => (fun a¹ -> a¹)}: 27
//│ ------------------
//│ case ys⁰ of {C h¹ t¹ => (fun a⁰ -> rev(t¹, [C h¹ a⁰])) | N  => (fun a¹ -> a¹)}: 27 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 12
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(map(primitive⁰, ff), [N])
//│ def ff(x¹) = case x¹ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs¹) = case xs¹ of {
//│ 	C h⁰ t⁰ => (fun f² -> 
//│ 		let t² = map(t⁰, f²)
//│ 		in let h² = f²(h⁰)
//│ 		in (fun a² -> rev(t², [C h² a²])))
//│ 	| N  => (fun f³ -> (fun a³ -> a³))}
//│ def rev(ys¹) = ys¹
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ map -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ map(primitive⁰, ff, [N])
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> 
//│ 		let t¹ = map(t⁰, f⁰)
//│ 		in let h¹ = f⁰(h⁰)
//│ 		in (fun a⁰ -> t¹([C h¹ a⁰])))
//│ 	| N  => (fun f¹ -> (fun a¹ -> a¹))}
//│ def rev(ys⁰) = ys⁰
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ map(primitive⁰, ff, [N])
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, _lh_popOutId_0⁰, _lh_popOutId_1⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t¹ = map(t⁰, _lh_popOutId_0⁰)
//│ 		in let h¹ = _lh_popOutId_0⁰(h⁰)
//│ 		in t¹([C h¹ _lh_popOutId_1⁰])
//│ 	| N  => _lh_popOutId_1⁰}
//│ def rev(ys⁰) = ys⁰
//│ <<<<<<< after floating out <<<<<<<
