:NewParser
:ParseOnly



// problematic with primId
:lhInHaskell
:lhGenOCaml
wheels1 ps = 1:(zipWith (\a b -> a + b) (wheels2 ps) ps)
wheels2 ps = 1:(zipWith (\a b -> a + b) (wheels2 ps) ps)
wheels1 $ primId [1]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ wheels1_₀^725(primId⁰([LH_C 1 [LH_N]]))
//│ def wheels1_₀(_lh_wheels1_arg1¹) = [LH_C 1 zipWith_₁^646((fun a⁷ -> (fun b⁴ -> (a⁷ + b⁴))), wheels2_₀^655(_lh_wheels1_arg1¹), _lh_wheels1_arg1¹)]
//│ def wheels2_₀(_lh_wheels2_arg1¹) = [LH_C 1 zipWith_₀^708((fun a⁸ -> (fun b⁵ -> (a⁸ + b⁵))), wheels2_₀^717(_lh_wheels2_arg1¹), _lh_wheels2_arg1¹)]
//│ def zipWith_₀(f¹², xs⁹, ys⁹) = case xs⁹ of {
//│ 	LH_C hx⁸ tx⁸ => case ys⁹ of {
//│ 		LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀^670(f¹², tx⁸, ty⁸)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ def zipWith_₁(f¹³, xs¹⁰, ys¹⁰) = case xs¹⁰ of {
//│ 	LH_C hx⁹ tx⁹ => case ys¹⁰ of {
//│ 		LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁^692(f¹³, tx⁹, ty⁹)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec wheels1__d0 _lh_wheels1_arg1_1 =
//│ 		  (`LH_C(1, (((zipWith__d1 (fun a_7 b_4 -> 
//│ 		    (a_7 + b_4))) (wheels2__d0 _lh_wheels1_arg1_1)) _lh_wheels1_arg1_1)))
//│ 		and wheels2__d0 _lh_wheels2_arg1_1 =
//│ 		  (`LH_C(1, (((zipWith__d0 (fun a_8 b_5 -> 
//│ 		    (a_8 + b_5))) (wheels2__d0 _lh_wheels2_arg1_1)) _lh_wheels2_arg1_1)))
//│ 		and zipWith__d0 f_1_2 xs_9 ys_9 =
//│ 		  (match xs_9 with
//│ 		    | `LH_C(hx_8, tx_8) -> 
//│ 		      (match ys_9 with
//│ 		        | `LH_C(hy_8, ty_8) -> 
//│ 		          (`LH_C(((f_1_2 hx_8) hy_8), (((zipWith__d0 f_1_2) tx_8) ty_8)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and zipWith__d1 f_1_3 xs_1_0 ys_1_0 =
//│ 		  (match xs_1_0 with
//│ 		    | `LH_C(hx_9, tx_9) -> 
//│ 		      (match ys_1_0 with
//│ 		        | `LH_C(hy_9, ty_9) -> 
//│ 		          (`LH_C(((f_1_3 hx_9) hy_9), (((zipWith__d1 f_1_3) tx_9) ty_9)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		(wheels1__d0 (`LH_C(1, (`LH_N))))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)]: 677 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 681
//│ 	case xs¹⁰ of {LH_C hx⁹ tx⁹ => case ys¹⁰ of {LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁(f¹³, tx⁹, ty⁹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 703
//│ [LH_N]: 678 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 681
//│ 	case xs¹⁰ of {LH_C hx⁹ tx⁹ => case ys¹⁰ of {LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁(f¹³, tx⁹, ty⁹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 703
//│ [LH_N]: 680 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 681
//│ 	case xs¹⁰ of {LH_C hx⁹ tx⁹ => case ys¹⁰ of {LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁(f¹³, tx⁹, ty⁹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 703
//│ [LH_C 1 zipWith_₀((fun a⁸ -> (fun b⁵ -> (a⁸ + b⁵))), wheels2_₀(_lh_wheels2_arg1¹), _lh_wheels2_arg1¹)]: 723 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 681
//│ 	case xs¹⁰ of {LH_C hx⁹ tx⁹ => case ys¹⁰ of {LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁(f¹³, tx⁹, ty⁹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 703
//│ ------------------
//│ case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 681 --->
//│ 	[LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)]: 677
//│ 	[LH_N]: 678
//│ 	[LH_N]: 680
//│ 	[LH_C 1 zipWith_₀((fun a⁸ -> (fun b⁵ -> (a⁸ + b⁵))), wheels2_₀(_lh_wheels2_arg1¹), _lh_wheels2_arg1¹)]: 723
//│ case xs¹⁰ of {LH_C hx⁹ tx⁹ => case ys¹⁰ of {LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁(f¹³, tx⁹, ty⁹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 703 --->
//│ 	[LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)]: 677
//│ 	[LH_N]: 678
//│ 	[LH_N]: 680
//│ 	[LH_C 1 zipWith_₀((fun a⁸ -> (fun b⁵ -> (a⁸ + b⁵))), wheels2_₀(_lh_wheels2_arg1¹), _lh_wheels2_arg1¹)]: 723
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ wheels1_₀(primId⁰([LH_C 1 [LH_N]]))
//│ def wheels1_₀(_lh_wheels1_arg1²) = [LH_C 1 zipWith_₁((fun a⁹ -> (fun b⁶ -> (a⁹ + b⁶))), wheels2_₀(_lh_wheels1_arg1²), _lh_wheels1_arg1²)]
//│ def wheels2_₀(_lh_wheels2_arg1²) = [LH_C 1 zipWith_₀((fun a¹⁰ -> (fun b⁷ -> (a¹⁰ + b⁷))), wheels2_₀(_lh_wheels2_arg1²), _lh_wheels2_arg1²)]
//│ def zipWith_₀(f¹⁴, xs¹¹, ys¹¹) = case xs¹¹ of {
//│ 	LH_C hx⁸ tx⁸ => case ys¹¹ of {
//│ 		LH_C hy⁸ ty⁸ => [LH_C f¹⁴(hx⁸, hy⁸) zipWith_₀(f¹⁴, tx⁸, ty⁸)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ def zipWith_₁(f¹⁵, xs¹², ys¹²) = case xs¹² of {
//│ 	LH_C hx⁹ tx⁹ => case ys¹² of {
//│ 		LH_C hy⁹ ty⁹ => [LH_C f¹⁵(hx⁹, hy⁹) zipWith_₁(f¹⁵, tx⁹, ty⁹)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec wheels1__d0 _lh_wheels1_arg1_0 =
//│   (`LH_C(1, (((zipWith__d1 (fun a_0 b_0 -> 
//│     (a_0 + b_0))) (wheels2__d0 _lh_wheels1_arg1_0)) _lh_wheels1_arg1_0)))
//│ and wheels2__d0 _lh_wheels2_arg1_0 =
//│   (`LH_C(1, (((zipWith__d0 (fun a_1 b_1 -> 
//│     (a_1 + b_1))) (wheels2__d0 _lh_wheels2_arg1_0)) _lh_wheels2_arg1_0)))
//│ and zipWith__d0 f_0 xs_0 ys_0 =
//│   (match xs_0 with
//│     | `LH_C(hx_0, tx_0) -> 
//│       (match ys_0 with
//│         | `LH_C(hy_0, ty_0) -> 
//│           (`LH_C(((f_0 hx_0) hy_0), (((zipWith__d0 f_0) tx_0) ty_0)))
//│         | `LH_N -> 
//│           (`LH_N))
//│     | `LH_N -> 
//│       (`LH_N))
//│ and zipWith__d1 f_1 xs_1 ys_1 =
//│   (match xs_1 with
//│     | `LH_C(hx_1, tx_1) -> 
//│       (match ys_1 with
//│         | `LH_C(hy_1, ty_1) -> 
//│           (`LH_C(((f_1 hx_1) hy_1), (((zipWith__d1 f_1) tx_1) ty_1)))
//│         | `LH_N -> 
//│           (`LH_N))
//│     | `LH_N -> 
//│       (`LH_N));;
//│ (wheels1__d0 (`LH_C(1, (`LH_N))))
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


// NOTE: will not trigger!
:lhInHaskell
:lhGenOCaml
wheels1 ps = 1:(zipWith (\a b -> a + b) (wheels2 ps) ps)
wheels2 ps = 1:(zipWith (\a b -> a + b) (wheels2 ps) ps)
wheels1 [1]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ wheels1_₀^723([LH_C 1 [LH_N]])
//│ def wheels1_₀(_lh_wheels1_arg1¹) = [LH_C 1 zipWith_₁^644((fun a⁷ -> (fun b⁴ -> (a⁷ + b⁴))), wheels2_₀^653(_lh_wheels1_arg1¹), _lh_wheels1_arg1¹)]
//│ def wheels2_₀(_lh_wheels2_arg1¹) = [LH_C 1 zipWith_₀^706((fun a⁸ -> (fun b⁵ -> (a⁸ + b⁵))), wheels2_₀^715(_lh_wheels2_arg1¹), _lh_wheels2_arg1¹)]
//│ def zipWith_₀(f¹², xs⁹, ys⁹) = case xs⁹ of {
//│ 	LH_C hx⁸ tx⁸ => case ys⁹ of {
//│ 		LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀^668(f¹², tx⁸, ty⁸)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ def zipWith_₁(f¹³, xs¹⁰, ys¹⁰) = case xs¹⁰ of {
//│ 	LH_C hx⁹ tx⁹ => case ys¹⁰ of {
//│ 		LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁^690(f¹³, tx⁹, ty⁹)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec wheels1__d0 _lh_wheels1_arg1_1 =
//│ 		  (`LH_C(1, (((zipWith__d1 (fun a_7 b_4 -> 
//│ 		    (a_7 + b_4))) (wheels2__d0 _lh_wheels1_arg1_1)) _lh_wheels1_arg1_1)))
//│ 		and wheels2__d0 _lh_wheels2_arg1_1 =
//│ 		  (`LH_C(1, (((zipWith__d0 (fun a_8 b_5 -> 
//│ 		    (a_8 + b_5))) (wheels2__d0 _lh_wheels2_arg1_1)) _lh_wheels2_arg1_1)))
//│ 		and zipWith__d0 f_1_2 xs_9 ys_9 =
//│ 		  (match xs_9 with
//│ 		    | `LH_C(hx_8, tx_8) -> 
//│ 		      (match ys_9 with
//│ 		        | `LH_C(hy_8, ty_8) -> 
//│ 		          (`LH_C(((f_1_2 hx_8) hy_8), (((zipWith__d0 f_1_2) tx_8) ty_8)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and zipWith__d1 f_1_3 xs_1_0 ys_1_0 =
//│ 		  (match xs_1_0 with
//│ 		    | `LH_C(hx_9, tx_9) -> 
//│ 		      (match ys_1_0 with
//│ 		        | `LH_C(hy_9, ty_9) -> 
//│ 		          (`LH_C(((f_1_3 hx_9) hy_9), (((zipWith__d1 f_1_3) tx_9) ty_9)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		(wheels1__d0 (`LH_C(1, (`LH_N))))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)]: 675 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 679
//│ 	case xs¹⁰ of {LH_C hx⁹ tx⁹ => case ys¹⁰ of {LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁(f¹³, tx⁹, ty⁹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 701
//│ [LH_N]: 676 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 679
//│ 	case xs¹⁰ of {LH_C hx⁹ tx⁹ => case ys¹⁰ of {LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁(f¹³, tx⁹, ty⁹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 701
//│ [LH_N]: 678 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 679
//│ 	case xs¹⁰ of {LH_C hx⁹ tx⁹ => case ys¹⁰ of {LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁(f¹³, tx⁹, ty⁹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 701
//│ [LH_C 1 zipWith_₀((fun a⁸ -> (fun b⁵ -> (a⁸ + b⁵))), wheels2_₀(_lh_wheels2_arg1¹), _lh_wheels2_arg1¹)]: 721 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 679
//│ 	case xs¹⁰ of {LH_C hx⁹ tx⁹ => case ys¹⁰ of {LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁(f¹³, tx⁹, ty⁹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 701
//│ [LH_N]: 725 --->
//│ 	case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)] | LH_N  => [LH_N]}: 677
//│ 	case ys¹⁰ of {LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁(f¹³, tx⁹, ty⁹)] | LH_N  => [LH_N]}: 699
//│ [LH_C 1 [LH_N]]: 726 --->
//│ 	case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)] | LH_N  => [LH_N]}: 677
//│ 	case ys¹⁰ of {LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁(f¹³, tx⁹, ty⁹)] | LH_N  => [LH_N]}: 699
//│ ------------------
//│ case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)] | LH_N  => [LH_N]}: 677 --->
//│ 	[LH_N]: 725
//│ 	[LH_C 1 [LH_N]]: 726
//│ case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 679 --->
//│ 	[LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)]: 675
//│ 	[LH_N]: 676
//│ 	[LH_N]: 678
//│ 	[LH_C 1 zipWith_₀((fun a⁸ -> (fun b⁵ -> (a⁸ + b⁵))), wheels2_₀(_lh_wheels2_arg1¹), _lh_wheels2_arg1¹)]: 721
//│ case ys¹⁰ of {LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁(f¹³, tx⁹, ty⁹)] | LH_N  => [LH_N]}: 699 --->
//│ 	[LH_N]: 725
//│ 	[LH_C 1 [LH_N]]: 726
//│ case xs¹⁰ of {LH_C hx⁹ tx⁹ => case ys¹⁰ of {LH_C hy⁹ ty⁹ => [LH_C f¹³(hx⁹, hy⁹) zipWith_₁(f¹³, tx⁹, ty⁹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 701 --->
//│ 	[LH_C f¹²(hx⁸, hy⁸) zipWith_₀(f¹², tx⁸, ty⁸)]: 675
//│ 	[LH_N]: 676
//│ 	[LH_N]: 678
//│ 	[LH_C 1 zipWith_₀((fun a⁸ -> (fun b⁵ -> (a⁸ + b⁵))), wheels2_₀(_lh_wheels2_arg1¹), _lh_wheels2_arg1¹)]: 721
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ wheels1_₀([LH_C 1 [LH_N]])
//│ def wheels1_₀(_lh_wheels1_arg1²) = [LH_C 1 zipWith_₁((fun a⁹ -> (fun b⁶ -> (a⁹ + b⁶))), wheels2_₀(_lh_wheels1_arg1²), _lh_wheels1_arg1²)]
//│ def wheels2_₀(_lh_wheels2_arg1²) = [LH_C 1 zipWith_₀((fun a¹⁰ -> (fun b⁷ -> (a¹⁰ + b⁷))), wheels2_₀(_lh_wheels2_arg1²), _lh_wheels2_arg1²)]
//│ def zipWith_₀(f¹⁴, xs¹¹, ys¹¹) = case xs¹¹ of {
//│ 	LH_C hx⁸ tx⁸ => case ys¹¹ of {
//│ 		LH_C hy⁸ ty⁸ => [LH_C f¹⁴(hx⁸, hy⁸) zipWith_₀(f¹⁴, tx⁸, ty⁸)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ def zipWith_₁(f¹⁵, xs¹², ys¹²) = case xs¹² of {
//│ 	LH_C hx⁹ tx⁹ => case ys¹² of {
//│ 		LH_C hy⁹ ty⁹ => [LH_C f¹⁵(hx⁹, hy⁹) zipWith_₁(f¹⁵, tx⁹, ty⁹)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec wheels1__d0 _lh_wheels1_arg1_0 =
//│   (`LH_C(1, (((zipWith__d1 (fun a_0 b_0 -> 
//│     (a_0 + b_0))) (wheels2__d0 _lh_wheels1_arg1_0)) _lh_wheels1_arg1_0)))
//│ and wheels2__d0 _lh_wheels2_arg1_0 =
//│   (`LH_C(1, (((zipWith__d0 (fun a_1 b_1 -> 
//│     (a_1 + b_1))) (wheels2__d0 _lh_wheels2_arg1_0)) _lh_wheels2_arg1_0)))
//│ and zipWith__d0 f_0 xs_0 ys_0 =
//│   (match xs_0 with
//│     | `LH_C(hx_0, tx_0) -> 
//│       (match ys_0 with
//│         | `LH_C(hy_0, ty_0) -> 
//│           (`LH_C(((f_0 hx_0) hy_0), (((zipWith__d0 f_0) tx_0) ty_0)))
//│         | `LH_N -> 
//│           (`LH_N))
//│     | `LH_N -> 
//│       (`LH_N))
//│ and zipWith__d1 f_1 xs_1 ys_1 =
//│   (match xs_1 with
//│     | `LH_C(hx_1, tx_1) -> 
//│       (match ys_1 with
//│         | `LH_C(hy_1, ty_1) -> 
//│           (`LH_C(((f_1 hx_1) hy_1), (((zipWith__d1 f_1) tx_1) ty_1)))
//│         | `LH_N -> 
//│           (`LH_N))
//│     | `LH_N -> 
//│       (`LH_N));;
//│ (wheels1__d0 (`LH_C(1, (`LH_N))))
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<



// NOTE: this specific unrolling will cause many iterations
// :lhInHaskell
// f (Wheel ns) p = Wheel [10]
// wheels1 ps = (( (Wheel [1])):(zipWith f (wheels2 ps) ps))
// wheels2 ps = (( (Wheel [1])):(zipWith f (wheels2 ps) ps))
// wheels1 $ primId [1]


// a bit smaller
// :lhInHaskell
// nextSize (Wheel ns) p = Wheel ( ([o | o <- [100]]))
// wheels ps = (( (Wheel [1])):(zipWith nextSize (wheels ps) ps))
// wheels $ primId [1..]


// WRONG: with this the above program will run for many iterations, not sure if it will terminate or not
// seems that the problem is with `wheels`
// wheels [1..]
// :lhInHaskell
// :lhGenOCaml
// append_lz xs ys = case xs of {
//   (x:xs) -> lazy (x:(append_lz xs ys));
//   [] -> ys
// }
// squares ps = map_lz (\p -> p * p) ps
// min a b = if a > b then b else a
// noFactor s ps qs n = if (s<=2) then True else notDivBy ps qs n
// notDivBy xs ys n = case (force ys) of {
//   (q:qs) -> if (q > n)
//             then True
//             else case (force xs) of {
//               (p:ps) -> (((n `mod` p) > 0) && (notDivBy ps qs n))
//             }
// }
// nextSize (Wheel s ns) p = Wheel (s*p) [n' | o <- [0,s..((p-1)*s)], n <- ns, n' <- [n + o], (n' `mod` p) > 0]
// wheels ps = lazy ((Wheel 1 [1]):(zipWith_lz_lz nextSize (wheels ps) ps))
