:NewParser
:ParseOnly



// problematic with primId
:lhInHaskell
:lhGenOCaml
wheels1 ps = 1:(zipWith (\a b -> a + b) (wheels2 ps) ps)
wheels2 ps = 1:(zipWith (\a b -> a + b) (wheels2 ps) ps)
wheels1 $ primId [1]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ wheels1_lh^59(primId⁰([LH_C 1 [LH_N]]))
//│ def wheels1_lh(_lh_wheels1_arg1⁰) = [LH_C 1 zipWith_lh^24((fun a⁰ -> (fun b⁰ -> (a⁰ + b⁰))), wheels2_lh^33(_lh_wheels1_arg1⁰), _lh_wheels1_arg1⁰)]
//│ def wheels2_lh(_lh_wheels2_arg1⁰) = [LH_C 1 zipWith_lh^42((fun a¹ -> (fun b¹ -> (a¹ + b¹))), wheels2_lh^51(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]
//│ def zipWith_lh(f⁰, xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh^8(f⁰, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec zipWith_lh f_0 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(hx_0, tx_0) -> 
//│ 		      (match ys_0 with
//│ 		        | `LH_C(hy_0, ty_0) -> 
//│ 		          (`LH_C(((f_0 hx_0) hy_0), (((zipWith_lh f_0) tx_0) ty_0)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec wheels2_lh _lh_wheels2_arg1_0 =
//│ 		  (`LH_C(1, (((zipWith_lh (fun a_1 b_1 -> 
//│ 		    (a_1 + b_1))) (wheels2_lh _lh_wheels2_arg1_0)) _lh_wheels2_arg1_0)));;
//│ 		let rec wheels1_lh _lh_wheels1_arg1_0 =
//│ 		  (`LH_C(1, (((zipWith_lh (fun a_0 b_0 -> 
//│ 		    (a_0 + b_0))) (wheels2_lh _lh_wheels1_arg1_0)) _lh_wheels1_arg1_0)));;
//│ 		(wheels1_lh (`LH_C(1, (`LH_N))))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)]: 15 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ [LH_N]: 16 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ [LH_N]: 18 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ [LH_C 1 zipWith_lh((fun a¹ -> (fun b¹ -> (a¹ + b¹))), wheels2_lh(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]: 57 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ ------------------
//│ case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19 --->
//│ 	[LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)]: 15
//│ 	[LH_N]: 16
//│ 	[LH_N]: 18
//│ 	[LH_C 1 zipWith_lh((fun a¹ -> (fun b¹ -> (a¹ + b¹))), wheels2_lh(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]: 57
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ wheels1_lh(primId⁰([LH_C 1 [LH_N]]))
//│ def wheels1_lh(_lh_wheels1_arg1¹) = [LH_C 1 zipWith_lh((fun a² -> (fun b² -> (a² + b²))), wheels2_lh(_lh_wheels1_arg1¹), _lh_wheels1_arg1¹)]
//│ def wheels2_lh(_lh_wheels2_arg1¹) = [LH_C 1 zipWith_lh((fun a³ -> (fun b³ -> (a³ + b³))), wheels2_lh(_lh_wheels2_arg1¹), _lh_wheels2_arg1¹)]
//│ def zipWith_lh(f¹, xs¹, ys¹) = case xs¹ of {
//│ 	LH_C hx⁰ tx⁰ => case ys¹ of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f¹(hx⁰, hy⁰) zipWith_lh(f¹, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec zipWith_lh f_0 xs_0 ys_0 =
//│   (match xs_0 with
//│     | `LH_C(hx_0, tx_0) -> 
//│       (match ys_0 with
//│         | `LH_C(hy_0, ty_0) -> 
//│           (`LH_C(((f_0 hx_0) hy_0), (((zipWith_lh f_0) tx_0) ty_0)))
//│         | `LH_N -> 
//│           (`LH_N))
//│     | `LH_N -> 
//│       (`LH_N));;
//│ let rec wheels2_lh _lh_wheels2_arg1_0 =
//│   (`LH_C(1, (((zipWith_lh (fun a_1 b_1 -> 
//│     (a_1 + b_1))) (wheels2_lh _lh_wheels2_arg1_0)) _lh_wheels2_arg1_0)));;
//│ let rec wheels1_lh _lh_wheels1_arg1_0 =
//│   (`LH_C(1, (((zipWith_lh (fun a_0 b_0 -> 
//│     (a_0 + b_0))) (wheels2_lh _lh_wheels1_arg1_0)) _lh_wheels1_arg1_0)));;
//│ (wheels1_lh (`LH_C(1, (`LH_N))))
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


// NOTE: will not trigger!
:lhInHaskell
:lhGenOCaml
wheels1 ps = 1:(zipWith (\a b -> a + b) (wheels2 ps) ps)
wheels2 ps = 1:(zipWith (\a b -> a + b) (wheels2 ps) ps)
wheels1 [1]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ wheels1_lh^59([LH_C 1 [LH_N]])
//│ def wheels1_lh(_lh_wheels1_arg1⁰) = [LH_C 1 zipWith_lh^24((fun a⁰ -> (fun b⁰ -> (a⁰ + b⁰))), wheels2_lh^33(_lh_wheels1_arg1⁰), _lh_wheels1_arg1⁰)]
//│ def wheels2_lh(_lh_wheels2_arg1⁰) = [LH_C 1 zipWith_lh^42((fun a¹ -> (fun b¹ -> (a¹ + b¹))), wheels2_lh^51(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]
//│ def zipWith_lh(f⁰, xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh^8(f⁰, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec zipWith_lh f_0 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(hx_0, tx_0) -> 
//│ 		      (match ys_0 with
//│ 		        | `LH_C(hy_0, ty_0) -> 
//│ 		          (`LH_C(((f_0 hx_0) hy_0), (((zipWith_lh f_0) tx_0) ty_0)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec wheels2_lh _lh_wheels2_arg1_0 =
//│ 		  (`LH_C(1, (((zipWith_lh (fun a_1 b_1 -> 
//│ 		    (a_1 + b_1))) (wheels2_lh _lh_wheels2_arg1_0)) _lh_wheels2_arg1_0)));;
//│ 		let rec wheels1_lh _lh_wheels1_arg1_0 =
//│ 		  (`LH_C(1, (((zipWith_lh (fun a_0 b_0 -> 
//│ 		    (a_0 + b_0))) (wheels2_lh _lh_wheels1_arg1_0)) _lh_wheels1_arg1_0)));;
//│ 		(wheels1_lh (`LH_C(1, (`LH_N))))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)]: 15 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ [LH_N]: 16 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ [LH_N]: 18 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ [LH_C 1 zipWith_lh((fun a¹ -> (fun b¹ -> (a¹ + b¹))), wheels2_lh(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]: 57 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ [LH_N]: 61 --->
//│ 	case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]}: 17
//│ [LH_C 1 [LH_N]]: 62 --->
//│ 	case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]}: 17
//│ ------------------
//│ case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]}: 17 --->
//│ 	[LH_N]: 61
//│ 	[LH_C 1 [LH_N]]: 62
//│ case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19 --->
//│ 	[LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)]: 15
//│ 	[LH_N]: 16
//│ 	[LH_N]: 18
//│ 	[LH_C 1 zipWith_lh((fun a¹ -> (fun b¹ -> (a¹ + b¹))), wheels2_lh(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]: 57
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_N]: 61 --->
//│ 	case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]}: 17
//│ [LH_C 1 [LH_N]]: 62 --->
//│ 	case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]}: 17
//│ ------------------
//│ case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]}: 17 --->
//│ 	[LH_N]: 61
//│ 	[LH_C 1 [LH_N]]: 62
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ wheels1_lh(
//│ 	let ty¹ = (fun f² -> (fun hx² -> (fun tx² -> [LH_N])))
//│ 	in let hy¹ = 1
//│ 	in (fun f¹ -> (fun hx¹ -> (fun tx¹ -> [LH_C f¹(hx¹, hy¹) zipWith_lh(f¹, tx¹, ty¹)]))))
//│ def wheels1_lh(_lh_wheels1_arg1¹) = [LH_C 1 zipWith_lh((fun a² -> (fun b² -> (a² + b²))), wheels2_lh(_lh_wheels1_arg1¹), _lh_wheels1_arg1¹)]
//│ def wheels2_lh(_lh_wheels2_arg1¹) = [LH_C 1 zipWith_lh((fun a³ -> (fun b³ -> (a³ + b³))), wheels2_lh(_lh_wheels2_arg1¹), _lh_wheels2_arg1¹)]
//│ def zipWith_lh(f³, xs¹, ys¹) = case xs¹ of {
//│ 	LH_C hx⁰ tx⁰ => ys¹(f³, hx⁰, tx⁰)
//│ 	| LH_N  => [LH_N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec zipWith_lh f_2 xs_0 ys_0 =
//│   (match xs_0 with
//│     | `LH_C(hx_2, tx_2) -> 
//│       (((ys_0 f_2) hx_2) tx_2)
//│     | `LH_N -> 
//│       (`LH_N));;
//│ let rec wheels2_lh _lh_wheels2_arg1_0 =
//│   (`LH_C(1, (((zipWith_lh (fun a_1 b_1 -> 
//│     (a_1 + b_1))) (wheels2_lh _lh_wheels2_arg1_0)) _lh_wheels2_arg1_0)));;
//│ let rec wheels1_lh _lh_wheels1_arg1_0 =
//│   (`LH_C(1, (((zipWith_lh (fun a_0 b_0 -> 
//│     (a_0 + b_0))) (wheels2_lh _lh_wheels1_arg1_0)) _lh_wheels1_arg1_0)));;
//│ (wheels1_lh (let rec ty_0 = (fun f_0 hx_0 tx_0 -> 
//│   (`LH_N)) in
//│   (let rec hy_0 = 1 in
//│     (fun f_1 hx_1 tx_1 -> 
//│       (`LH_C(((f_1 hx_1) hy_0), (((zipWith_lh f_1) tx_1) ty_0)))))))
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<



// NOTE: this specific unrolling will cause many iterations
// :lhInHaskell
// f (Wheel ns) p = Wheel [10]
// wheels1 ps = (( (Wheel [1])):(zipWith f (wheels2 ps) ps))
// wheels2 ps = (( (Wheel [1])):(zipWith f (wheels2 ps) ps))
// wheels1 $ primId [1]


// a bit smaller
// :lhInHaskell
// nextSize (Wheel ns) p = Wheel ( ([o | o <- [100]]))
// wheels ps = (( (Wheel [1])):(zipWith nextSize (wheels ps) ps))
// wheels $ primId [1..]


// WRONG: with this the above program will run for many iterations, not sure if it will terminate or not
// seems that the problem is with `wheels`
// wheels [1..]
// :lhInHaskell
// :lhGenOCaml
// append_lz xs ys = case xs of {
//   (x:xs) -> lazy (x:(append_lz xs ys));
//   [] -> ys
// }
// squares ps = map_lz (\p -> p * p) ps
// min a b = if a > b then b else a
// noFactor s ps qs n = if (s<=2) then True else notDivBy ps qs n
// notDivBy xs ys n = case (force ys) of {
//   (q:qs) -> if (q > n)
//             then True
//             else case (force xs) of {
//               (p:ps) -> (((n `mod` p) > 0) && (notDivBy ps qs n))
//             }
// }
// nextSize (Wheel s ns) p = Wheel (s*p) [n' | o <- [0,s..((p-1)*s)], n <- ns, n' <- [n + o], (n' `mod` p) > 0]
// wheels ps = lazy ((Wheel 1 [1]):(zipWith_lz_lz nextSize (wheels ps) ps))
