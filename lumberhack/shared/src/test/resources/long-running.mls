:NewParser
:ParseOnly



// problematic with primId
:lhInHaskell
:lhGenOCaml
wheels1 ps = 1:(zipWith (\a b -> a + b) (wheels2 ps) ps)
wheels2 ps = 1:(zipWith (\a b -> a + b) (wheels2 ps) ps)
wheels1 $ primId [1]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ wheels1_lh_₁^81(primId⁰([LH_C 1 [LH_N]]))
//│ def wheels1_lh_₁(_lh_wheels1_arg1⁰) = [LH_C 1 zipWith_lh_₁^64((fun a¹ -> (fun b¹ -> (a¹ + b¹))), wheels2_lh_₁^73(_lh_wheels1_arg1⁰), _lh_wheels1_arg1⁰)]
//│ def wheels2_lh_₁(_lh_wheels2_arg1⁰) = [LH_C 1 zipWith_lh_₂^24((fun a⁰ -> (fun b⁰ -> (a⁰ + b⁰))), wheels2_lh_₁^33(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]
//│ def zipWith_lh_₁(f¹, xs¹, ys¹) = case xs¹ of {
//│ 	LH_C hx¹ tx¹ => case ys¹ of {
//│ 		LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁^48(f¹, tx¹, ty¹)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ def zipWith_lh_₂(f⁰, xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂^8(f⁰, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec zipWith_lh__d2 f_0 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(hx_0, tx_0) -> 
//│ 		      (match ys_0 with
//│ 		        | `LH_C(hy_0, ty_0) -> 
//│ 		          (`LH_C(((f_0 hx_0) hy_0), (((zipWith_lh__d2 f_0) tx_0) ty_0)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec wheels2_lh__d1 _lh_wheels2_arg1_0 =
//│ 		  (`LH_C(1, (((zipWith_lh__d2 (fun a_0 b_0 -> 
//│ 		    (a_0 + b_0))) (wheels2_lh__d1 _lh_wheels2_arg1_0)) _lh_wheels2_arg1_0)));;
//│ 		let rec zipWith_lh__d1 f_1 xs_1 ys_1 =
//│ 		  (match xs_1 with
//│ 		    | `LH_C(hx_1, tx_1) -> 
//│ 		      (match ys_1 with
//│ 		        | `LH_C(hy_1, ty_1) -> 
//│ 		          (`LH_C(((f_1 hx_1) hy_1), (((zipWith_lh__d1 f_1) tx_1) ty_1)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec wheels1_lh__d1 _lh_wheels1_arg1_0 =
//│ 		  (`LH_C(1, (((zipWith_lh__d1 (fun a_1 b_1 -> 
//│ 		    (a_1 + b_1))) (wheels2_lh__d1 _lh_wheels1_arg1_0)) _lh_wheels1_arg1_0)));;
//│ 		(wheels1_lh__d1 (`LH_C(1, (`LH_N))))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)]: 15 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ 	case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 59
//│ [LH_N]: 16 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ 	case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 59
//│ [LH_N]: 18 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ 	case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 59
//│ [LH_C 1 zipWith_lh_₂((fun a⁰ -> (fun b⁰ -> (a⁰ + b⁰))), wheels2_lh_₁(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]: 39 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ 	case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 59
//│ ------------------
//│ case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19 --->
//│ 	[LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)]: 15
//│ 	[LH_N]: 16
//│ 	[LH_N]: 18
//│ 	[LH_C 1 zipWith_lh_₂((fun a⁰ -> (fun b⁰ -> (a⁰ + b⁰))), wheels2_lh_₁(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]: 39
//│ case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 59 --->
//│ 	[LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)]: 15
//│ 	[LH_N]: 16
//│ 	[LH_N]: 18
//│ 	[LH_C 1 zipWith_lh_₂((fun a⁰ -> (fun b⁰ -> (a⁰ + b⁰))), wheels2_lh_₁(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]: 39
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ wheels1_lh_₁(primId⁰([LH_C 1 [LH_N]]))
//│ def wheels1_lh_₁(_lh_wheels1_arg1¹) = [LH_C 1 zipWith_lh_₁((fun a³ -> (fun b³ -> (a³ + b³))), wheels2_lh_₁(_lh_wheels1_arg1¹), _lh_wheels1_arg1¹)]
//│ def wheels2_lh_₁(_lh_wheels2_arg1¹) = [LH_C 1 zipWith_lh_₂((fun a² -> (fun b² -> (a² + b²))), wheels2_lh_₁(_lh_wheels2_arg1¹), _lh_wheels2_arg1¹)]
//│ def zipWith_lh_₁(f³, xs³, ys³) = case xs³ of {
//│ 	LH_C hx¹ tx¹ => case ys³ of {
//│ 		LH_C hy¹ ty¹ => [LH_C f³(hx¹, hy¹) zipWith_lh_₁(f³, tx¹, ty¹)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ def zipWith_lh_₂(f², xs², ys²) = case xs² of {
//│ 	LH_C hx⁰ tx⁰ => case ys² of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f²(hx⁰, hy⁰) zipWith_lh_₂(f², tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ wheels1_lh_₁(primId⁰([LH_C 1 [LH_N]]))
//│ def wheels1_lh_₁(_lh_wheels1_arg1⁰) = [LH_C 1 zipWith_lh_₁((fun a¹ -> (fun b¹ -> (a¹ + b¹))), wheels2_lh_₁(_lh_wheels1_arg1⁰), _lh_wheels1_arg1⁰)]
//│ def wheels2_lh_₁(_lh_wheels2_arg1⁰) = [LH_C 1 zipWith_lh_₂((fun a⁰ -> (fun b⁰ -> (a⁰ + b⁰))), wheels2_lh_₁(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]
//│ def zipWith_lh_₁(f¹, xs¹, ys¹) = case xs¹ of {
//│ 	LH_C hx¹ tx¹ => case ys¹ of {
//│ 		LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ def zipWith_lh_₂(f⁰, xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ wheels1_lh_₁(primId⁰([LH_C 1 [LH_N]]))
//│ def wheels1_lh_₁(_lh_wheels1_arg1⁰) = [LH_C 1 zipWith_lh_₁((fun a¹ -> (fun b¹ -> (a¹ + b¹))), wheels2_lh_₁(_lh_wheels1_arg1⁰), _lh_wheels1_arg1⁰)]
//│ def wheels2_lh_₁(_lh_wheels2_arg1⁰) = [LH_C 1 zipWith_lh_₂((fun a⁰ -> (fun b⁰ -> (a⁰ + b⁰))), wheels2_lh_₁(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]
//│ def zipWith_lh_₁(f¹, xs¹, ys¹) = case xs¹ of {
//│ 	LH_C hx¹ tx¹ => case ys¹ of {
//│ 		LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ def zipWith_lh_₂(f⁰, xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec zipWith_lh__d2 f_0 xs_0 ys_0 =
//│   (match xs_0 with
//│     | `LH_C(hx_0, tx_0) -> 
//│       (match ys_0 with
//│         | `LH_C(hy_0, ty_0) -> 
//│           (`LH_C(((f_0 hx_0) hy_0), (((zipWith_lh__d2 f_0) tx_0) ty_0)))
//│         | `LH_N -> 
//│           (`LH_N))
//│     | `LH_N -> 
//│       (`LH_N));;
//│ let rec wheels2_lh__d1 _lh_wheels2_arg1_0 =
//│   (`LH_C(1, (((zipWith_lh__d2 (fun a_0 b_0 -> 
//│     (a_0 + b_0))) (wheels2_lh__d1 _lh_wheels2_arg1_0)) _lh_wheels2_arg1_0)));;
//│ let rec zipWith_lh__d1 f_1 xs_1 ys_1 =
//│   (match xs_1 with
//│     | `LH_C(hx_1, tx_1) -> 
//│       (match ys_1 with
//│         | `LH_C(hy_1, ty_1) -> 
//│           (`LH_C(((f_1 hx_1) hy_1), (((zipWith_lh__d1 f_1) tx_1) ty_1)))
//│         | `LH_N -> 
//│           (`LH_N))
//│     | `LH_N -> 
//│       (`LH_N));;
//│ let rec wheels1_lh__d1 _lh_wheels1_arg1_0 =
//│   (`LH_C(1, (((zipWith_lh__d1 (fun a_1 b_1 -> 
//│     (a_1 + b_1))) (wheels2_lh__d1 _lh_wheels1_arg1_0)) _lh_wheels1_arg1_0)));;
//│ (wheels1_lh__d1 (`LH_C(1, (`LH_N))))
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


// NOTE: will not trigger!
:lhInHaskell
:lhGenOCaml
wheels1 ps = 1:(zipWith (\a b -> a + b) (wheels2 ps) ps)
wheels2 ps = 1:(zipWith (\a b -> a + b) (wheels2 ps) ps)
wheels1 [1]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ wheels1_lh_₁^81([LH_C 1 [LH_N]])
//│ def wheels1_lh_₁(_lh_wheels1_arg1⁰) = [LH_C 1 zipWith_lh_₁^64((fun a¹ -> (fun b¹ -> (a¹ + b¹))), wheels2_lh_₁^73(_lh_wheels1_arg1⁰), _lh_wheels1_arg1⁰)]
//│ def wheels2_lh_₁(_lh_wheels2_arg1⁰) = [LH_C 1 zipWith_lh_₂^24((fun a⁰ -> (fun b⁰ -> (a⁰ + b⁰))), wheels2_lh_₁^33(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]
//│ def zipWith_lh_₁(f¹, xs¹, ys¹) = case xs¹ of {
//│ 	LH_C hx¹ tx¹ => case ys¹ of {
//│ 		LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁^48(f¹, tx¹, ty¹)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ def zipWith_lh_₂(f⁰, xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂^8(f⁰, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec zipWith_lh__d2 f_0 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(hx_0, tx_0) -> 
//│ 		      (match ys_0 with
//│ 		        | `LH_C(hy_0, ty_0) -> 
//│ 		          (`LH_C(((f_0 hx_0) hy_0), (((zipWith_lh__d2 f_0) tx_0) ty_0)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec wheels2_lh__d1 _lh_wheels2_arg1_0 =
//│ 		  (`LH_C(1, (((zipWith_lh__d2 (fun a_0 b_0 -> 
//│ 		    (a_0 + b_0))) (wheels2_lh__d1 _lh_wheels2_arg1_0)) _lh_wheels2_arg1_0)));;
//│ 		let rec zipWith_lh__d1 f_1 xs_1 ys_1 =
//│ 		  (match xs_1 with
//│ 		    | `LH_C(hx_1, tx_1) -> 
//│ 		      (match ys_1 with
//│ 		        | `LH_C(hy_1, ty_1) -> 
//│ 		          (`LH_C(((f_1 hx_1) hy_1), (((zipWith_lh__d1 f_1) tx_1) ty_1)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec wheels1_lh__d1 _lh_wheels1_arg1_0 =
//│ 		  (`LH_C(1, (((zipWith_lh__d1 (fun a_1 b_1 -> 
//│ 		    (a_1 + b_1))) (wheels2_lh__d1 _lh_wheels1_arg1_0)) _lh_wheels1_arg1_0)));;
//│ 		(wheels1_lh__d1 (`LH_C(1, (`LH_N))))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)]: 15 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ 	case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 59
//│ [LH_N]: 16 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ 	case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 59
//│ [LH_N]: 18 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ 	case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 59
//│ [LH_C 1 zipWith_lh_₂((fun a⁰ -> (fun b⁰ -> (a⁰ + b⁰))), wheels2_lh_₁(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]: 39 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19
//│ 	case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 59
//│ [LH_N]: 83 --->
//│ 	case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]}: 17
//│ 	case ys¹ of {LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)] | LH_N  => [LH_N]}: 57
//│ [LH_C 1 [LH_N]]: 84 --->
//│ 	case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]}: 17
//│ 	case ys¹ of {LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)] | LH_N  => [LH_N]}: 57
//│ ------------------
//│ case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]}: 17 --->
//│ 	[LH_N]: 83
//│ 	[LH_C 1 [LH_N]]: 84
//│ case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 19 --->
//│ 	[LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)]: 15
//│ 	[LH_N]: 16
//│ 	[LH_N]: 18
//│ 	[LH_C 1 zipWith_lh_₂((fun a⁰ -> (fun b⁰ -> (a⁰ + b⁰))), wheels2_lh_₁(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]: 39
//│ case ys¹ of {LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)] | LH_N  => [LH_N]}: 57 --->
//│ 	[LH_N]: 83
//│ 	[LH_C 1 [LH_N]]: 84
//│ case xs¹ of {LH_C hx¹ tx¹ => case ys¹ of {LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 59 --->
//│ 	[LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)]: 15
//│ 	[LH_N]: 16
//│ 	[LH_N]: 18
//│ 	[LH_C 1 zipWith_lh_₂((fun a⁰ -> (fun b⁰ -> (a⁰ + b⁰))), wheels2_lh_₁(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]: 39
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ wheels1_lh_₁([LH_C 1 [LH_N]])
//│ def wheels1_lh_₁(_lh_wheels1_arg1¹) = [LH_C 1 zipWith_lh_₁((fun a³ -> (fun b³ -> (a³ + b³))), wheels2_lh_₁(_lh_wheels1_arg1¹), _lh_wheels1_arg1¹)]
//│ def wheels2_lh_₁(_lh_wheels2_arg1¹) = [LH_C 1 zipWith_lh_₂((fun a² -> (fun b² -> (a² + b²))), wheels2_lh_₁(_lh_wheels2_arg1¹), _lh_wheels2_arg1¹)]
//│ def zipWith_lh_₁(f³, xs³, ys³) = case xs³ of {
//│ 	LH_C hx¹ tx¹ => case ys³ of {
//│ 		LH_C hy¹ ty¹ => [LH_C f³(hx¹, hy¹) zipWith_lh_₁(f³, tx¹, ty¹)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ def zipWith_lh_₂(f², xs², ys²) = case xs² of {
//│ 	LH_C hx⁰ tx⁰ => case ys² of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f²(hx⁰, hy⁰) zipWith_lh_₂(f², tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ wheels1_lh_₁([LH_C 1 [LH_N]])
//│ def wheels1_lh_₁(_lh_wheels1_arg1⁰) = [LH_C 1 zipWith_lh_₁((fun a¹ -> (fun b¹ -> (a¹ + b¹))), wheels2_lh_₁(_lh_wheels1_arg1⁰), _lh_wheels1_arg1⁰)]
//│ def wheels2_lh_₁(_lh_wheels2_arg1⁰) = [LH_C 1 zipWith_lh_₂((fun a⁰ -> (fun b⁰ -> (a⁰ + b⁰))), wheels2_lh_₁(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]
//│ def zipWith_lh_₁(f¹, xs¹, ys¹) = case xs¹ of {
//│ 	LH_C hx¹ tx¹ => case ys¹ of {
//│ 		LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ def zipWith_lh_₂(f⁰, xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ wheels1_lh_₁([LH_C 1 [LH_N]])
//│ def wheels1_lh_₁(_lh_wheels1_arg1⁰) = [LH_C 1 zipWith_lh_₁((fun a¹ -> (fun b¹ -> (a¹ + b¹))), wheels2_lh_₁(_lh_wheels1_arg1⁰), _lh_wheels1_arg1⁰)]
//│ def wheels2_lh_₁(_lh_wheels2_arg1⁰) = [LH_C 1 zipWith_lh_₂((fun a⁰ -> (fun b⁰ -> (a⁰ + b⁰))), wheels2_lh_₁(_lh_wheels2_arg1⁰), _lh_wheels2_arg1⁰)]
//│ def zipWith_lh_₁(f¹, xs¹, ys¹) = case xs¹ of {
//│ 	LH_C hx¹ tx¹ => case ys¹ of {
//│ 		LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₁(f¹, tx¹, ty¹)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ def zipWith_lh_₂(f⁰, xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₂(f⁰, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec zipWith_lh__d2 f_0 xs_0 ys_0 =
//│   (match xs_0 with
//│     | `LH_C(hx_0, tx_0) -> 
//│       (match ys_0 with
//│         | `LH_C(hy_0, ty_0) -> 
//│           (`LH_C(((f_0 hx_0) hy_0), (((zipWith_lh__d2 f_0) tx_0) ty_0)))
//│         | `LH_N -> 
//│           (`LH_N))
//│     | `LH_N -> 
//│       (`LH_N));;
//│ let rec wheels2_lh__d1 _lh_wheels2_arg1_0 =
//│   (`LH_C(1, (((zipWith_lh__d2 (fun a_0 b_0 -> 
//│     (a_0 + b_0))) (wheels2_lh__d1 _lh_wheels2_arg1_0)) _lh_wheels2_arg1_0)));;
//│ let rec zipWith_lh__d1 f_1 xs_1 ys_1 =
//│   (match xs_1 with
//│     | `LH_C(hx_1, tx_1) -> 
//│       (match ys_1 with
//│         | `LH_C(hy_1, ty_1) -> 
//│           (`LH_C(((f_1 hx_1) hy_1), (((zipWith_lh__d1 f_1) tx_1) ty_1)))
//│         | `LH_N -> 
//│           (`LH_N))
//│     | `LH_N -> 
//│       (`LH_N));;
//│ let rec wheels1_lh__d1 _lh_wheels1_arg1_0 =
//│   (`LH_C(1, (((zipWith_lh__d1 (fun a_1 b_1 -> 
//│     (a_1 + b_1))) (wheels2_lh__d1 _lh_wheels1_arg1_0)) _lh_wheels1_arg1_0)));;
//│ (wheels1_lh__d1 (`LH_C(1, (`LH_N))))
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<



// NOTE: this specific unrolling will cause many iterations
// :lhInHaskell
// f (Wheel ns) p = Wheel [10]
// wheels1 ps = (( (Wheel [1])):(zipWith f (wheels2 ps) ps))
// wheels2 ps = (( (Wheel [1])):(zipWith f (wheels2 ps) ps))
// wheels1 $ primId [1]


// a bit smaller
// :lhInHaskell
// nextSize (Wheel ns) p = Wheel ( ([o | o <- [100]]))
// wheels ps = (( (Wheel [1])):(zipWith nextSize (wheels ps) ps))
// wheels $ primId [1..]


// WRONG: with this the above program will run for many iterations, not sure if it will terminate or not
// seems that the problem is with `wheels`
// wheels [1..]
// :lhInHaskell
// :lhGenOCaml
// append_lz xs ys = case xs of {
//   (x:xs) -> lazy (x:(append_lz xs ys));
//   [] -> ys
// }
// squares ps = map_lz (\p -> p * p) ps
// min a b = if a > b then b else a
// noFactor s ps qs n = if (s<=2) then True else notDivBy ps qs n
// notDivBy xs ys n = case (force ys) of {
//   (q:qs) -> if (q > n)
//             then True
//             else case (force xs) of {
//               (p:ps) -> (((n `mod` p) > 0) && (notDivBy ps qs n))
//             }
// }
// nextSize (Wheel s ns) p = Wheel (s*p) [n' | o <- [0,s..((p-1)*s)], n <- ns, n' <- [n + o], (n' `mod` p) > 0]
// wheels ps = lazy ((Wheel 1 [1]):(zipWith_lz_lz nextSize (wheels ps) ps))
