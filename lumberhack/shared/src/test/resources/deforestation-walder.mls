:NewParser
:ParseOnly

// CORRECT: need bubbling out and inlining of square to be exactly same as wadler's out
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun upto(a, b) = if a > b then N else C(a, upto(a + 1, b))
fun sum(ls) = summ(0, ls)
fun summ(acc, ls) = if ls is
  N then acc
  C(h, t) then summ(acc + h, t)
fun main(n) = sum(map(x => x * x, upto(1, n)))
main
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |upto|(|a|,| |b|)| |#=| |#if| |a| |>| |b| |#then| |N| |#else| |C|(|a|,| |upto|(|a| |+| |1|,| |b|)|)|↵|#fun| |sum|(|ls|)| |#=| |summ|(|0|,| |ls|)|↵|#fun| |summ|(|acc|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc|↵|C|(|h|,| |t|)| |#then| |summ|(|acc| |+| |h|,| |t|)|←|↵|#fun| |main|(|n|)| |#=| |sum|(|map|(|x| |=>| |x| |*| |x|,| |upto|(|1|,| |n|)|)|)|↵|main|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun upto = a, b, => if (> (a,) (b,)) then N else C (a, upto (+ (a,) (1,), b,),); fun sum = ls, => summ (0, ls,); fun summ = acc, ls, => if ls is ‹(N) then acc; (C (h, t,)) then summ (+ (acc,) (h,), t,)›; fun main = n, => sum (map (x, => * (x,) (x,), upto (1, n,),),); main}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^72
//│ def main(n⁰) = sum^55(map^56((fun x⁰ -> (x⁰ * x⁰)), upto^64(1, n⁰)))
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def sum(ls¹) = summ^35(0, ls¹)
//│ def summ(acc⁰, ls²) = case ls² of {
//│ 	N  => acc⁰
//│ 	| C h¹ t¹ => summ^43((acc⁰ + h¹), t¹)}
//│ def upto(a⁰, b⁰) = if (a⁰ > b⁰) then [N] else [C a⁰ upto^22((a⁰ + 1), b⁰)]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(f⁰, t⁰)]: 10 --->
//│ 	case ls² of {N  => acc⁰ | C h¹ t¹ => summ((acc⁰ + h¹), t¹)}: 52
//│ [N]: 11 --->
//│ 	case ls² of {N  => acc⁰ | C h¹ t¹ => summ((acc⁰ + h¹), t¹)}: 52
//│ [N]: 20 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ [C a⁰ upto((a⁰ + 1), b⁰)]: 31 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 20
//│ 	[C a⁰ upto((a⁰ + 1), b⁰)]: 31
//│ case ls² of {N  => acc⁰ | C h¹ t¹ => summ((acc⁰ + h¹), t¹)}: 52 --->
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h⁰) map(f⁰, t⁰)]: 10 --->
//│ 	case ls² of {N  => acc⁰ | C h¹ t¹ => summ((acc⁰ + h¹), t¹)}: 52
//│ [N]: 11 --->
//│ 	case ls² of {N  => acc⁰ | C h¹ t¹ => summ((acc⁰ + h¹), t¹)}: 52
//│ [N]: 20 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ [C a⁰ upto((a⁰ + 1), b⁰)]: 31 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 20
//│ 	[C a⁰ upto((a⁰ + 1), b⁰)]: 31
//│ case ls² of {N  => acc⁰ | C h¹ t¹ => summ((acc⁰ + h¹), t¹)}: 52 --->
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main
//│ def main(n¹) = sum(map((fun x¹ -> (x¹ * x¹)), upto(1, n¹)))
//│ def map(f¹, ls³) = ls³(f¹)
//│ def sum(ls⁴) = summ(0, ls⁴)
//│ def summ(acc³, ls⁵) = ls⁵(acc³)
//│ def upto(a¹, b¹) = if (a¹ > b¹) then (fun f² -> (fun acc¹ -> acc¹)) else 
//│ 	let t² = upto((a¹ + 1), b¹)
//│ 	in let h² = a¹
//│ 	in (fun f³ -> 
//│ 		let t³ = map(f³, t²)
//│ 		in let h³ = f³(h²)
//│ 		in (fun acc² -> summ((acc² + h³), t³)))
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: slightly different from actual example in wadler's paper: the sum is no longer tail recursive
// our approach (after bubbling out of parameters and inlining of square):
// upto₀ a b f = if a > b then 0 else f(a) + upto₀(a + 1, b, f)
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun upto(a, b) = if a > b then N else C(a, upto(a + 1, b))
fun sum(ls) = if ls is
  C(h, t) then h + sum(t)
  N then 0
fun main(n) = sum(map(x => x * x, upto(1, n)))
main
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |upto|(|a|,| |b|)| |#=| |#if| |a| |>| |b| |#then| |N| |#else| |C|(|a|,| |upto|(|a| |+| |1|,| |b|)|)|↵|#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |h| |+| |sum|(|t|)|↵|N| |#then| |0|←|↵|#fun| |main|(|n|)| |#=| |sum|(|map|(|x| |=>| |x| |*| |x|,| |upto|(|1|,| |n|)|)|)|↵|main|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun upto = a, b, => if (> (a,) (b,)) then N else C (a, upto (+ (a,) (1,), b,),); fun sum = ls, => if ls is ‹(C (h, t,)) then + (h,) (sum (t,),); (N) then 0›; fun main = n, => sum (map (x, => * (x,) (x,), upto (1, n,),),); main}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^63
//│ def main(n⁰) = sum^46(map^47((fun x⁰ -> (x⁰ * x⁰)), upto^55(1, n⁰)))
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def sum(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => (h¹ + sum^39(t¹))
//│ 	| N  => 0}
//│ def upto(a⁰, b⁰) = if (a⁰ > b⁰) then [N] else [C a⁰ upto^22((a⁰ + 1), b⁰)]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(f⁰, t⁰)]: 10 --->
//│ 	case ls¹ of {C h¹ t¹ => (h¹ + sum(t¹)) | N  => 0}: 44
//│ [N]: 11 --->
//│ 	case ls¹ of {C h¹ t¹ => (h¹ + sum(t¹)) | N  => 0}: 44
//│ [N]: 20 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ [C a⁰ upto((a⁰ + 1), b⁰)]: 31 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 20
//│ 	[C a⁰ upto((a⁰ + 1), b⁰)]: 31
//│ case ls¹ of {C h¹ t¹ => (h¹ + sum(t¹)) | N  => 0}: 44 --->
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h⁰) map(f⁰, t⁰)]: 10 --->
//│ 	case ls¹ of {C h¹ t¹ => (h¹ + sum(t¹)) | N  => 0}: 44
//│ [N]: 11 --->
//│ 	case ls¹ of {C h¹ t¹ => (h¹ + sum(t¹)) | N  => 0}: 44
//│ [N]: 20 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ [C a⁰ upto((a⁰ + 1), b⁰)]: 31 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 20
//│ 	[C a⁰ upto((a⁰ + 1), b⁰)]: 31
//│ case ls¹ of {C h¹ t¹ => (h¹ + sum(t¹)) | N  => 0}: 44 --->
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main
//│ def main(n¹) = sum(map((fun x¹ -> (x¹ * x¹)), upto(1, n¹)))
//│ def map(f¹, ls²) = ls²(f¹)
//│ def sum(ls³) = ls³(99)
//│ def upto(a¹, b¹) = if (a¹ > b¹) then (fun f² -> (fun _lh_dummy⁰ -> 0)) else 
//│ 	let t² = upto((a¹ + 1), b¹)
//│ 	in let h² = a¹
//│ 	in (fun f³ -> 
//│ 		let t³ = map(f³, t²)
//│ 		in let h³ = f³(h²)
//│ 		in (fun _lh_dummy¹ -> (h³ + sum(t³))))
//│ <<<<<<< after fusion <<<<<<<

// WRONG: cannot fuse at all if there is no concrete input
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun main(x, y, z) = append(append(x, y), z)
main
//│ |#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |main|(|x|,| |y|,| |z|)| |#=| |append|(|append|(|x|,| |y|)|,| |z|)|↵|main|
//│ Parsed: {fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun main = x, y, z, => append (append (x, y,), z,); main}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^25
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def main(x⁰, y⁰, z⁰) = append^13(append^14(x⁰, y⁰), z⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ append(t⁰, ys⁰)]: 8 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10 --->
//│ 	NoProd
//│ 	[C h⁰ append(t⁰, ys⁰)]: 8
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main
//│ def append(xs¹, ys¹) = case xs¹ of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys¹)]
//│ 	| N  => ys¹}
//│ def main(x¹, y¹, z¹) = append(append(x¹, y¹), z¹)
//│ <<<<<<< after fusion <<<<<<<


// WRONG: cannot fuse if noprod flow into y
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun idList(ls) = if ls is
  C(h, t) then C(h, t)
  N then N
fun append2(xs, ys) = if xs is
  C(h, t) then C(h, append2(t, ys))
  N then idList(ys)
fun main(x, y, z) = append(append2(x, y), z)
main
//│ |#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |idList|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |t|)|↵|N| |#then| |N|←|↵|#fun| |append2|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append2|(|t|,| |ys|)|)|↵|N| |#then| |idList|(|ys|)|←|↵|#fun| |main|(|x|,| |y|,| |z|)| |#=| |append|(|append2|(|x|,| |y|)|,| |z|)|↵|main|
//│ Parsed: {fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun idList = ls, => if ls is ‹(C (h, t,)) then C (h, t,); (N) then N›; fun append2 = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append2 (t, ys,),); (N) then idList (ys,)›; fun main = x, y, z, => append (append2 (x, y,), z,); main}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^46
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def append2(xs¹, ys¹) = case xs¹ of {
//│ 	C h² t² => [C h² append2^22(t², ys¹)]
//│ 	| N  => idList^28(ys¹)}
//│ def idList(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => [C h¹ t¹]
//│ 	| N  => [N]}
//│ def main(x⁰, y⁰, z⁰) = append^34(append2^35(x⁰, y⁰), z⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ t¹]: 16 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [N]: 17 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [C h² append2(t², ys¹)]: 27 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10 --->
//│ 	NoProd
//│ 	[C h¹ t¹]: 16
//│ 	[N]: 17
//│ 	[C h² append2(t², ys¹)]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main
//│ def append(xs², ys²) = case xs² of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys²)]
//│ 	| N  => ys²}
//│ def append2(xs³, ys³) = case xs³ of {
//│ 	C h² t² => [C h² append2(t², ys³)]
//│ 	| N  => idList(ys³)}
//│ def idList(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => [C h¹ t¹]
//│ 	| N  => [N]}
//│ def main(x¹, y¹, z¹) = append(append2(x¹, y¹), z¹)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: will fuse if idList is recursive (this idea can be generalized to other
// data structure? an id to traverse the data to expose its structure)
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun idList(ls) = if ls is
  C(h, t) then C(h, idList(t))
  N then N
fun append2(xs, ys) = if xs is
  C(h, t) then C(h, append2(t, ys))
  N then idList(ys)
fun main(x, y, z) = append(append2(x, y), z)
main
//│ |#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |idList|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |idList|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |append2|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append2|(|t|,| |ys|)|)|↵|N| |#then| |idList|(|ys|)|←|↵|#fun| |main|(|x|,| |y|,| |z|)| |#=| |append|(|append2|(|x|,| |y|)|,| |z|)|↵|main|
//│ Parsed: {fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun idList = ls, => if ls is ‹(C (h, t,)) then C (h, idList (t,),); (N) then N›; fun append2 = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append2 (t, ys,),); (N) then idList (ys,)›; fun main = x, y, z, => append (append2 (x, y,), z,); main}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^48
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def append2(xs¹, ys¹) = case xs¹ of {
//│ 	C h² t² => [C h² append2^24(t², ys¹)]
//│ 	| N  => idList^30(ys¹)}
//│ def idList(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => [C h¹ idList^15(t¹)]
//│ 	| N  => [N]}
//│ def main(x⁰, y⁰, z⁰) = append^36(append2^37(x⁰, y⁰), z⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ idList(t¹)]: 18 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [N]: 19 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [C h² append2(t², ys¹)]: 29 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10 --->
//│ 	[C h¹ idList(t¹)]: 18
//│ 	[N]: 19
//│ 	[C h² append2(t², ys¹)]: 29
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ idList(t¹)]: 18 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [N]: 19 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [C h² append2(t², ys¹)]: 29 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10 --->
//│ 	[C h¹ idList(t¹)]: 18
//│ 	[N]: 19
//│ 	[C h² append2(t², ys¹)]: 29
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main
//│ def append(xs², ys²) = xs²(ys²)
//│ def append2(xs³, ys⁵) = case xs³ of {
//│ 	C h² t² => 
//│ 		let t⁴ = append2(t², ys⁵)
//│ 		in let h⁴ = h²
//│ 		in (fun ys⁶ -> [C h⁴ append(t⁴, ys⁶)])
//│ 	| N  => idList(ys⁵)}
//│ def idList(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => 
//│ 		let t³ = idList(t¹)
//│ 		in let h³ = h¹
//│ 		in (fun ys³ -> [C h³ append(t³, ys³)])
//│ 	| N  => (fun ys⁴ -> ys⁴)}
//│ def main(x¹, y¹, z¹) = append(append2(x¹, y¹), z¹)
//│ <<<<<<< after fusion <<<<<<<



// CORRECT: NOTE: provide all lists using map, then it will fuse to be like
// fun map0(ls, f) = if ls is
//    C(h, t) then ys3 => ys4 => C(f(h), map0(t, f)(ys3)(ys4))
//    N then ys => ys
// fun map1(ls, f) = if ls is
//    C(h, t) then ys5 => C(f(h), map1(t, f)(ys5))
//    N then ys => ys
// fun map2 = map      // normal map
// (map0(x, f)(map1(x, f)))(map2(x, f))
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun main(x, y, z) = append(append(map(x, primitive), map(y, primitive)), map(z, primitive))
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
main
//│ |#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |main|(|x|,| |y|,| |z|)| |#=| |append|(|append|(|map|(|x|,| |primitive|)|,| |map|(|y|,| |primitive|)|)|,| |map|(|z|,| |primitive|)|)|↵|#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|main|
//│ Parsed: {fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun main = x, y, z, => append (append (map (x, primitive,), map (y, primitive,),), map (z, primitive,),); fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; main}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^51
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def main(x⁰, y⁰, z⁰) = append^13(append^14(map^15(x⁰, primitive⁰), map^21(y⁰, primitive⁰)), map^28(z⁰, primitive⁰))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => [C f⁰(h¹) map^41(t¹, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ append(t⁰, ys⁰)]: 8 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [C f⁰(h¹) map(t¹, f⁰)]: 46 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [N]: 47 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10 --->
//│ 	[C h⁰ append(t⁰, ys⁰)]: 8
//│ 	[C f⁰(h¹) map(t¹, f⁰)]: 46
//│ 	[N]: 47
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main
//│ def append(xs¹, ys¹) = case xs¹ of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys¹)]
//│ 	| N  => ys¹}
//│ def main(x¹, y¹, z¹) = append(append(map(x¹, primitive⁰), map(y¹, primitive⁰)), map(z¹, primitive⁰))
//│ def map(ls¹, f¹) = case ls¹ of {
//│ 	C h¹ t¹ => [C f¹(h¹) map(t¹, f¹)]
//│ 	| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: will fuse
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun main(x, y) = append(append(x, N), y)
main
//│ |#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |main|(|x|,| |y|)| |#=| |append|(|append|(|x|,| |N|)|,| |y|)|↵|main|
//│ Parsed: {fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun main = x, y, => append (append (x, N,), y,); main}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^24
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def main(x⁰, y⁰) = append^13(append^14(x⁰, [N]), y⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ append(t⁰, ys⁰)]: 8 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [N]: 17 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10 --->
//│ 	NoProd
//│ 	[C h⁰ append(t⁰, ys⁰)]: 8
//│ 	[N]: 17
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main
//│ def append(xs¹, ys¹) = case xs¹ of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys¹)]
//│ 	| N  => ys¹}
//│ def main(x¹, y¹) = append(append(x¹, [N]), y¹)
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: will fuse
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys // <--------- this `ys` contains no known information if not provided
fun main(x, y) = append(append(x, C(1, C(2, N))), y)
main
//│ |#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys| |/* <--------- this `ys` contains no known information if not provided*/|←|↵|#fun| |main|(|x|,| |y|)| |#=| |append|(|append|(|x|,| |C|(|1|,| |C|(|2|,| |N|)|)|)|,| |y|)|↵|main|
//│ Parsed: {fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun main = x, y, => append (append (x, C (1, C (2, N,),),), y,); main}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^28
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def main(x⁰, y⁰) = append^13(append^14(x⁰, [C 1 [C 2 [N]]]), y⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ append(t⁰, ys⁰)]: 8 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [N]: 19 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [C 2 [N]]: 20 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [C 1 [C 2 [N]]]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10 --->
//│ 	NoProd
//│ 	[C h⁰ append(t⁰, ys⁰)]: 8
//│ 	[N]: 19
//│ 	[C 2 [N]]: 20
//│ 	[C 1 [C 2 [N]]]: 21
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main
//│ def append(xs¹, ys¹) = case xs¹ of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys¹)]
//│ 	| N  => ys¹}
//│ def main(x¹, y¹) = append(append(x¹, [C 1 [C 2 [N]]]), y¹)
//│ <<<<<<< after fusion <<<<<<<



// CORRECT: same amount of fusion done
fun flip(t) = if t is
  T(l, r) then T(flip(l), flip(r))
  N(v) then N(v)
fun ff(t) = flip(flip(t))
ff
//│ |#fun| |flip|(|t|)| |#=| |#if| |t| |is|→|T|(|l|,| |r|)| |#then| |T|(|flip|(|l|)|,| |flip|(|r|)|)|↵|N|(|v|)| |#then| |N|(|v|)|←|↵|#fun| |ff|(|t|)| |#=| |flip|(|flip|(|t|)|)|↵|ff|
//│ Parsed: {fun flip = t, => if t is ‹(T (l, r,)) then T (flip (l,), flip (r,),); (N (v,)) then N (v,)›; fun ff = t, => flip (flip (t,),); ff}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ff^19
//│ def ff(t¹) = flip^13(flip^14(t¹))
//│ def flip(t⁰) = case t⁰ of {
//│ 	T l⁰ r⁰ => [T flip^2(l⁰) flip^5(r⁰)]
//│ 	| N v⁰ => [N v⁰]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [T flip(l⁰) flip(r⁰)]: 8 --->
//│ 	NoCons
//│ 	case t⁰ of {T l⁰ r⁰ => [T flip(l⁰) flip(r⁰)] | N v⁰ => [N v⁰]}: 11
//│ [N v⁰]: 10 --->
//│ 	NoCons
//│ 	case t⁰ of {T l⁰ r⁰ => [T flip(l⁰) flip(r⁰)] | N v⁰ => [N v⁰]}: 11
//│ ------------------
//│ case t⁰ of {T l⁰ r⁰ => [T flip(l⁰) flip(r⁰)] | N v⁰ => [N v⁰]}: 11 --->
//│ 	NoProd
//│ 	[T flip(l⁰) flip(r⁰)]: 8
//│ 	[N v⁰]: 10
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ff
//│ def ff(t³) = flip(flip(t³))
//│ def flip(t²) = case t² of {
//│ 	T l⁰ r⁰ => [T flip(l⁰) flip(r⁰)]
//│ 	| N v⁰ => [N v⁰]}
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
fun squaretr(t) = if t is
  N(v) then N(v * v)
  T(l, r) then T(squaretr(l), squaretr(r))
fun sumtr(t) = if t is
  N(v) then v
  T(l, r) then sumtr(l) + sumtr(r)
fun main(t) = sumtr(squaretr(t))
main
//│ |#fun| |squaretr|(|t|)| |#=| |#if| |t| |is|→|N|(|v|)| |#then| |N|(|v| |*| |v|)|↵|T|(|l|,| |r|)| |#then| |T|(|squaretr|(|l|)|,| |squaretr|(|r|)|)|←|↵|#fun| |sumtr|(|t|)| |#=| |#if| |t| |is|→|N|(|v|)| |#then| |v|↵|T|(|l|,| |r|)| |#then| |sumtr|(|l|)| |+| |sumtr|(|r|)|←|↵|#fun| |main|(|t|)| |#=| |sumtr|(|squaretr|(|t|)|)|↵|main|
//│ Parsed: {fun squaretr = t, => if t is ‹(N (v,)) then N (* (v,) (v,),); (T (l, r,)) then T (squaretr (l,), squaretr (r,),)›; fun sumtr = t, => if t is ‹(N (v,)) then v; (T (l, r,)) then + (sumtr (l,),) (sumtr (r,),)›; fun main = t, => sumtr (squaretr (t,),); main}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^36
//│ def main(t²) = sumtr^30(squaretr^31(t²))
//│ def squaretr(t⁰) = case t⁰ of {
//│ 	N v⁰ => [N (v⁰ * v⁰)]
//│ 	| T l⁰ r⁰ => [T squaretr^8(l⁰) squaretr^11(r⁰)]}
//│ def sumtr(t¹) = case t¹ of {
//│ 	N v¹ => v¹
//│ 	| T l¹ r¹ => (sumtr^20(l¹) + sumtr^24(r¹))}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N (v⁰ * v⁰)]: 7 --->
//│ 	case t¹ of {N v¹ => v¹ | T l¹ r¹ => (sumtr(l¹) + sumtr(r¹))}: 28
//│ [T squaretr(l⁰) squaretr(r⁰)]: 14 --->
//│ 	case t¹ of {N v¹ => v¹ | T l¹ r¹ => (sumtr(l¹) + sumtr(r¹))}: 28
//│ ------------------
//│ case t¹ of {N v¹ => v¹ | T l¹ r¹ => (sumtr(l¹) + sumtr(r¹))}: 28 --->
//│ 	[N (v⁰ * v⁰)]: 7
//│ 	[T squaretr(l⁰) squaretr(r⁰)]: 14
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N (v⁰ * v⁰)]: 7 --->
//│ 	case t¹ of {N v¹ => v¹ | T l¹ r¹ => (sumtr(l¹) + sumtr(r¹))}: 28
//│ [T squaretr(l⁰) squaretr(r⁰)]: 14 --->
//│ 	case t¹ of {N v¹ => v¹ | T l¹ r¹ => (sumtr(l¹) + sumtr(r¹))}: 28
//│ ------------------
//│ case t¹ of {N v¹ => v¹ | T l¹ r¹ => (sumtr(l¹) + sumtr(r¹))}: 28 --->
//│ 	[N (v⁰ * v⁰)]: 7
//│ 	[T squaretr(l⁰) squaretr(r⁰)]: 14
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main
//│ def main(t⁵) = sumtr(squaretr(t⁵))
//│ def squaretr(t³) = case t³ of {
//│ 	N v⁰ => 
//│ 		let v² = (v⁰ * v⁰)
//│ 		in (fun _lh_dummy⁰ -> v²)
//│ 	| T l⁰ r⁰ => 
//│ 		let r² = squaretr(r⁰)
//│ 		in let l² = squaretr(l⁰)
//│ 		in (fun _lh_dummy¹ -> (sumtr(l²) + sumtr(r²)))}
//│ def sumtr(t⁴) = t⁴(99)
//│ <<<<<<< after fusion <<<<<<<
