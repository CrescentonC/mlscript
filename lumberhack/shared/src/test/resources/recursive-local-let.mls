:NewParser
:ParseOnly

// this will be stackoverflow
_LUMBERHACK_EVAL_LUMBERHACK_ERROR
let p =
  let k = k
  k
p
//│ |_LUMBERHACK_EVAL_LUMBERHACK_ERROR|↵|#let| |p| |#=|→|#let| |k| |#=| |k|↵|k|←|↵|p|
//│ Parsed: {_LUMBERHACK_EVAL_LUMBERHACK_ERROR; let p = {let k = k; k}; p}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ p^4
//│ def p = 
//│ 	let k⁰ = k⁰
//│ 	in k⁰
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!

// this will be scope error instead of stackoverflow
_LUMBERHACK_EVAL_LUMBERHACK_ERROR
let p =
  let k = k
  x => D(k)
p(0)
//│ |_LUMBERHACK_EVAL_LUMBERHACK_ERROR|↵|#let| |p| |#=|→|#let| |k| |#=| |k|↵|x| |=>| |D|(|k|)|←|↵|p|(|0|)|
//│ Parsed: {_LUMBERHACK_EVAL_LUMBERHACK_ERROR; let p = {let k = k; x, => D (k,)}; p (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ p^6(0)
//│ def p = 
//│ 	let k⁰ = k⁰
//│ 	in (fun x⁰ -> [D k⁰])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: k⁰ not in ctx
//│ !!!!!!ERROR!!!!!!

// this will be type error
_LUMBERHACK_ERROR
fun f(x) = if x is
  A then 
    let t = f(t)
    B
f(A)
//│ |_LUMBERHACK_ERROR|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |→|#let| |t| |#=| |f|(|t|)|↵|B|←|←|↵|f|(|A|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun f = x, => if x is ‹(A) then {let t = f (t,); B}›; f (A,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9([A])
//│ def f(x⁰) = case x⁰ of {
//│ 	A  => 
//│ 		let t⁰ = f^2(t⁰)
//│ 		in [B]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^9] (hopeless to continue)
//│ 	[f^9 · f^2] ---> [f^9] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([A])
//│ def f_₀(x¹) = 
//│ 	case x¹ of {
//│ 		A  => 
//│ 			let t¹ = f_₀(t¹)
//│ 			in [B]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀([A])
//│ def f_₀(x²) = 
//│ 	case x² of {
//│ 		A  => 
//│ 			let t² = f_₀(t²)
//│ 			in [B]}
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: type error HashSet(MkCtor(B,List()), Destruct(List(Destructor(A,List()))))
//│ !!!!!!ERROR!!!!!!
