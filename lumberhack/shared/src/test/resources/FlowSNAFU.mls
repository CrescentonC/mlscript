:NewParser
:ParseOnly


:lhEval
// NOTE: sometimes the output program will be correct without adding Obj.magic
fun f(a, ret) = if a is
  A then b =>
    if b is
      B then ret
  AA then b => End2
f(A, ReturnValue, B)
//│ |#fun| |f|(|a|,| |ret|)| |#=| |#if| |a| |is|→|A| |#then| |b| |=>|→|#if| |b| |is|→|B| |#then| |ret|←|←|↵|AA| |#then| |b| |=>| |End2|←|↵|f|(|A|,| |ReturnValue|,| |B|)|
//│ Parsed: {fun f = a, ret, => if a is ‹(A) then b, => {if b is ‹(B) then ret›}; (AA) then b, => End2›; f (A, ReturnValue, B,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^11([A], [ReturnValue], [B])
//│ def f(a⁰, ret⁰) = case a⁰ of {
//│ 	A  => (fun b⁰ -> case b⁰ of {
//│ 		B  => ret⁰})
//│ 	| AA  => (fun b¹ -> [End2])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [ReturnValue]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^11] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([A], [ReturnValue], [B])
//│ def f_₀(a¹, ret¹) = 
//│ 	case a¹ of {
//│ 		A  => (fun b² -> case b² of {
//│ 			B  => ret¹})
//│ 		| AA  => (fun b³ -> [End2])}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 29 --->
//│ 	case a¹ of {A  => (fun b² -> case b² of {B  => ret¹}) | AA  => (fun b³ -> [End2])}: 25
//│ [B]: 33 --->
//│ 	DeadCodeCons
//│ 	case b² of {B  => ret¹}: 21
//│ ------------------
//│ case b² of {B  => ret¹}: 21 --->
//│ 	[B]: 33
//│ case a¹ of {A  => (fun b² -> case b² of {B  => ret¹}) | AA  => (fun b³ -> [End2])}: 25 --->
//│ 	[A]: 29
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 29 --->
//│ 	case a¹ of {A  => (fun b² -> case b² of {B  => ret¹}) | AA  => (fun b³ -> [End2])}: 25
//│ ------------------
//│ case a¹ of {A  => (fun b² -> case b² of {B  => ret¹}) | AA  => (fun b³ -> [End2])}: 25 --->
//│ 	[A]: 29
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀((fun ret² -> (fun b⁴ -> case b⁴ of {
//│ 	B  => ret²})), [ReturnValue], [B])
//│ def f_₀(a², ret³) = 
//│ 	a²(ret³)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [ReturnValue]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f_₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀_₀((fun ret³ -> (fun b¹ -> case b¹ of {
//│ 	B  => ret³})), [ReturnValue], [B])
//│ def f_₀_₀(a¹, ret²) = 
//│ 	a¹(ret²)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [B]: 31 --->
//│ 	case b¹ of {B  => ret³}: 25
//│ ------------------
//│ case b¹ of {B  => ret³}: 25 --->
//│ 	[B]: 31
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [B]: 31 --->
//│ 	case b¹ of {B  => ret³}: 25
//│ ------------------
//│ case b¹ of {B  => ret³}: 25 --->
//│ 	[B]: 31
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀_₀((fun ret⁴ -> (fun b² -> b²(ret⁴))), [ReturnValue], (fun ret⁵ -> ret⁵))
//│ def f_₀_₀(a², ret⁶) = 
//│ 	a²(ret⁶)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [ReturnValue]
//│ <<<<<<< evaluate <<<<<<<

// NOTE: mlscript thinks this is ok, but not ocaml
:lhError
:lhGenOCaml
:d
fun f(a) = if True then C(0) else C(x => x)
f(0)
// // will need to be:
// ignore(f(0))
//│ |#fun| |f|(|a|)| |#=| |#if| |True| |#then| |C|(|0|)| |#else| |C|(|x| |=>| |x|)|↵|f|(|0|)|↵|/* // will need to be:*/|↵|/* ignore(f(0))*/|
//│ Parsed: {fun f = a, => if (True) then C (0,) else C (x, => x,); f (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9(0)
//│ def f(a⁰) = if [True] then [C 0] else [C (fun x⁰ -> x⁰)]
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f a_0 =
//│ 		  (if true then
//│ 		    (`C(0))
//│ 		  else
//│ 		    (`C((fun x_0 -> 
//│ 		      x_0))));;
//│ 		(f 0)
//│ 		....... ocaml repl result .......
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception:           Lines 5-6, characters 7-11:
//│ 5 | .......((fun x_0 -> 
//│ 6 |       x_0))....
//│ Error: This expression should not be a function, the expected type is int
//│ !!!!!!ERROR!!!!!!

// fun f(a) = if True then C(0) else Object.magic(C(x => x))
// f(0)



// TODO: investigate why the expander doesn't dup dropWhile, which causes its outer layer not to fuse
// reproduced as below
// ```
// fun c(x) = if x is
//   C(a) then c(a)
//   N then N
// c(C(C(C(N))))
// ```
// the fusion process if the `NoCons` does not block the fusion
// and the dropWhile gets duplicated as needed
// fun dropWhile(ls) = (if ls is
//   N then () => C(N)
//   C(t) then () => if True then dropWhile(t) else C(t))()
// dropWhile(C(N))
// -----------
// dropWhile'(ls) = ls ()
// dropWhile'(
//   let t = N
//   in () => if True then dropWhile(t) else C(t)
// )
// -----------
// dropWhile''(ls) = ls()
// dropWhile'(ls) = ls()
// dropWhile'(
//   let t = () => C(N)
//   in () => if True then dropWhile''(t) else C(t)
// )
:lhGenOCaml
:d
fun dropWhile(ls) = if ls is
  N then C(N)
  C(t) then if True then dropWhile(t) else C(t)
dropWhile(C(N))
//│ |#fun| |dropWhile|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |C|(|N|)|↵|C|(|t|)| |#then| |#if| |True| |#then| |dropWhile|(|t|)| |#else| |C|(|t|)|←|↵|dropWhile|(|C|(|N|)|)|
//│ Parsed: {fun dropWhile = ls, => if ls is ‹(N) then C (N,); (C (t,)) then if (True) then dropWhile (t,) else C (t,)›; dropWhile (C (N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ dropWhile^13([C [N]])
//│ def dropWhile(ls⁰) = case ls⁰ of {
//│ 	N  => [C [N]]
//│ 	| C t⁰ => if [True] then dropWhile^5(t⁰) else [C t⁰]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec dropWhile ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`C((`N)))
//│ 		    | `C(t_0) -> 
//│ 		      (if true then
//│ 		        (dropWhile t_0)
//│ 		      else
//│ 		        (`C(t_0))));;
//│ 		(dropWhile (`C((`N))))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		                val dropWhile : ([< `C of 'a | `N > `N ] as 'a) -> [> `C of 'a ] = <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [dropWhile^13] (hopeless to continue)
//│ 	[dropWhile^13 · dropWhile^5] ---> [dropWhile^13] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ dropWhile_₀([C [N]])
//│ def dropWhile_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		N  => [C [N]]
//│ 		| C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 30 --->
//│ 	NoCons
//│ 	case ls¹ of {N  => [C [N]] | C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}: 27
//│ [C [N]]: 31 --->
//│ 	case ls¹ of {N  => [C [N]] | C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}: 27
//│ ------------------
//│ case ls¹ of {N  => [C [N]] | C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}: 27 --->
//│ 	[N]: 30
//│ 	[C [N]]: 31
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ dropWhile_₀([C [N]])
//│ def dropWhile_₀(ls²) = 
//│ 	case ls² of {
//│ 		N  => [C [N]]
//│ 		| C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ dropWhile_₀ :: 'dropWhile_₀ <: [] ::: true
//│ [N] :: N ::: true
//│ [C [N]] :: C(N) ::: true
//│ dropWhile_₀([C [N]]) :: '4_callres <: [] ::: true
//│ ls :: 'ls⁰ <: [] ::: true
//│ [N] :: N ::: true
//│ [C [N]] :: C(N) ::: true
//│ [True] :: True ::: true
//│ dropWhile_₀ :: 'dropWhile_₀ <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ dropWhile_₀(t) :: '11_callres <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ [C t] :: C('t⁰) ::: true
//│ if [True] then dropWhile_₀(t) else [C t] :: '14_ifres <: [] ::: true
//│ case ls of {N  => [C [N]] | C t => if [True] then dropWhile_₀(t) else [C t]} :: '15_matchres <: [] ::: true
//│ (fun ls -> case ls of {N  => [C [N]] | C t => if [True] then dropWhile_₀(t) else [C t]}) :: 'ls⁰ => '15_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec dropWhile__d0 ls_0 =
//│   (match ls_0 with
//│     | `N -> 
//│       (`C((`N)))
//│     | `C(t_0) -> 
//│       (if true then
//│         (dropWhile__d0 t_0)
//│       else
//│         (`C(t_0))));;
//│ (dropWhile__d0 (`C((`N))))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│   - : [> `C of [ `C of 'a | `N ] as 'a ] = `C `N
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
:d
fun dropWhile(ls) = if ls is
  N then C(N)
  C(t) then if True then dropWhile(t) else C(t)
(x => 2)(dropWhile(C(N)))
//│ |#fun| |dropWhile|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |C|(|N|)|↵|C|(|t|)| |#then| |#if| |True| |#then| |dropWhile|(|t|)| |#else| |C|(|t|)|←|↵|(|x| |=>| |2|)|(|dropWhile|(|C|(|N|)|)|)|
//│ Parsed: {fun dropWhile = ls, => if ls is ‹(N) then C (N,); (C (t,)) then if (True) then dropWhile (t,) else C (t,)›; '(' x, => 2, ')' (dropWhile (C (N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (fun x⁰ -> 2)(dropWhile^15([C [N]]))
//│ def dropWhile(ls⁰) = case ls⁰ of {
//│ 	N  => [C [N]]
//│ 	| C t⁰ => if [True] then dropWhile^5(t⁰) else [C t⁰]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec dropWhile ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`C((`N)))
//│ 		    | `C(t_0) -> 
//│ 		      (if true then
//│ 		        (dropWhile t_0)
//│ 		      else
//│ 		        (`C(t_0))));;
//│ 		((fun x_0 -> 
//│ 		  2) (dropWhile (`C((`N)))))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		                val dropWhile : ([< `C of 'a | `N > `N ] as 'a) -> [> `C of 'a ] = <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [dropWhile^15] (hopeless to continue)
//│ 	[dropWhile^15 · dropWhile^5] ---> [dropWhile^15] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (fun x¹ -> 2)(dropWhile_₀([C [N]]))
//│ def dropWhile_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		N  => [C [N]]
//│ 		| C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 35 --->
//│ 	DeadCodeCons
//│ 	case ls¹ of {N  => [C [N]] | C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}: 30
//│ [C [N]]: 36 --->
//│ 	case ls¹ of {N  => [C [N]] | C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}: 30
//│ ------------------
//│ case ls¹ of {N  => [C [N]] | C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}: 30 --->
//│ 	[N]: 35
//│ 	[C [N]]: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (fun x² -> 2)(dropWhile_₀([C [N]]))
//│ def dropWhile_₀(ls²) = 
//│ 	case ls² of {
//│ 		N  => [C [N]]
//│ 		| C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ 2 :: Int ::: false
//│ (fun x -> 2) :: 'x⁰ => Int ::: true
//│ dropWhile_₀ :: 'dropWhile_₀ <: [] ::: true
//│ [N] :: N ::: true
//│ [C [N]] :: C(N) ::: true
//│ dropWhile_₀([C [N]]) :: '6_callres <: [] ::: true
//│ (fun x -> 2)(dropWhile_₀([C [N]])) :: '7_callres <: [] ::: true
//│ ls :: 'ls⁰ <: [] ::: true
//│ [N] :: N ::: true
//│ [C [N]] :: C(N) ::: true
//│ [True] :: True ::: true
//│ dropWhile_₀ :: 'dropWhile_₀ <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ dropWhile_₀(t) :: '14_callres <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ [C t] :: C('t⁰) ::: true
//│ if [True] then dropWhile_₀(t) else [C t] :: '17_ifres <: [] ::: true
//│ case ls of {N  => [C [N]] | C t => if [True] then dropWhile_₀(t) else [C t]} :: '18_matchres <: [] ::: true
//│ (fun ls -> case ls of {N  => [C [N]] | C t => if [True] then dropWhile_₀(t) else [C t]}) :: 'ls⁰ => '18_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec dropWhile__d0 ls_0 =
//│   (match ls_0 with
//│     | `N -> 
//│       (`C((`N)))
//│     | `C(t_0) -> 
//│       (if true then
//│         (dropWhile__d0 t_0)
//│       else
//│         (`C(t_0))));;
//│ ((fun x_0 -> 
//│   2) (dropWhile__d0 (`C((`N)))))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│     - : int = 2
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
:d
fun dropWhile(ls) = if ls is
  N then N
  C(t) then if True then dropWhile(t) else C(t)
fun f(x) = Pair(f(C(N)), f(x))
f(dropWhile(C(N)))
//│ |#fun| |dropWhile|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|t|)| |#then| |#if| |True| |#then| |dropWhile|(|t|)| |#else| |C|(|t|)|←|↵|#fun| |f|(|x|)| |#=| |Pair|(|f|(|C|(|N|)|)|,| |f|(|x|)|)|↵|f|(|dropWhile|(|C|(|N|)|)|)|
//│ Parsed: {fun dropWhile = ls, => if ls is ‹(N) then N; (C (t,)) then if (True) then dropWhile (t,) else C (t,)›; fun f = x, => Pair (f (C (N,),), f (x,),); f (dropWhile (C (N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^21(dropWhile^22([C [N]]))
//│ def dropWhile(ls⁰) = case ls⁰ of {
//│ 	N  => [N]
//│ 	| C t⁰ => if [True] then dropWhile^4(t⁰) else [C t⁰]}
//│ def f(x⁰) = [Pair f^12([C [N]]) f^16(x⁰)]
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f x_0 =
//│ 		  (`Pair((f (`C((`N)))), (f x_0)));;
//│ 		let rec dropWhile ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | `C(t_0) -> 
//│ 		      (if true then
//│ 		        (dropWhile t_0)
//│ 		      else
//│ 		        (`C(t_0))));;
//│ 		(f (dropWhile (`C((`N)))))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		  val f : [> `C of [> `N ] ] -> ([> `Pair of 'a * 'a ] as 'a) = <fun>
//│ 		[ok]
//│ 		                  val dropWhile : ([< `C of 'a | `N ] as 'a) -> [> `C of 'a | `N ] = <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [dropWhile^22] (hopeless to continue)
//│ 	[dropWhile^22 · dropWhile^4] ---> [dropWhile^22] (using original def)
//│ [f^21] (hopeless to continue)
//│ 	[f^21 · f^12] ---> [f^21] (using original def)
//│ 	[f^21 · f^16] ---> [f^21] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀(dropWhile_₀([C [N]]))
//│ def dropWhile_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		N  => [N]
//│ 		| C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}
//│ def f_₀(x¹) = 
//│ 	[Pair f_₀([C [N]]) f_₀(x¹)]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 49 --->
//│ 	DeadCodeCons
//│ 	case ls¹ of {N  => [N] | C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}: 36
//│ [C [N]]: 50 --->
//│ 	case ls¹ of {N  => [N] | C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}: 36
//│ ------------------
//│ case ls¹ of {N  => [N] | C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}: 36 --->
//│ 	[N]: 49
//│ 	[C [N]]: 50
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀(dropWhile_₀([C [N]]))
//│ def dropWhile_₀(ls²) = 
//│ 	case ls² of {
//│ 		N  => [N]
//│ 		| C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}
//│ def f_₀(x²) = 
//│ 	[Pair f_₀([C [N]]) f_₀(x²)]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ f_₀ :: 'f_₀ <: [] ::: true
//│ dropWhile_₀ :: 'dropWhile_₀ <: [] ::: true
//│ [N] :: N ::: true
//│ [C [N]] :: C(N) ::: true
//│ dropWhile_₀([C [N]]) :: '5_callres <: [] ::: true
//│ f_₀(dropWhile_₀([C [N]])) :: '6_callres <: [] ::: true
//│ ls :: 'ls⁰ <: [] ::: true
//│ [N] :: N ::: true
//│ [True] :: True ::: true
//│ dropWhile_₀ :: 'dropWhile_₀ <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ dropWhile_₀(t) :: '12_callres <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ [C t] :: C('t⁰) ::: true
//│ if [True] then dropWhile_₀(t) else [C t] :: '15_ifres <: [] ::: true
//│ case ls of {N  => [N] | C t => if [True] then dropWhile_₀(t) else [C t]} :: '16_matchres <: [] ::: true
//│ (fun ls -> case ls of {N  => [N] | C t => if [True] then dropWhile_₀(t) else [C t]}) :: 'ls⁰ => '16_matchres ::: true
//│ f_₀ :: 'f_₀ <: [] ::: true
//│ [N] :: N ::: true
//│ [C [N]] :: C(N) ::: true
//│ f_₀([C [N]]) :: '21_callres <: [] ::: true
//│ f_₀ :: 'f_₀ <: [] ::: true
//│ x :: 'x⁰ <: [] ::: true
//│ f_₀(x) :: '24_callres <: [] ::: true
//│ [Pair f_₀([C [N]]) f_₀(x)] :: Pair('21_callres, '24_callres) ::: true
//│ (fun x -> [Pair f_₀([C [N]]) f_₀(x)]) :: 'x⁰ => Pair('21_callres, '24_callres) ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec dropWhile__d0 ls_0 =
//│   (match ls_0 with
//│     | `N -> 
//│       (`N)
//│     | `C(t_0) -> 
//│       (if true then
//│         (dropWhile__d0 t_0)
//│       else
//│         (`C(t_0))));;
//│ let rec f__d0 x_0 =
//│   (`Pair((f__d0 (`C((`N)))), (f__d0 x_0)));;
//│ (f__d0 (dropWhile__d0 (`C((`N)))))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│   Stack overflow during evaluation (looping recursion?).
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
:d
fun dropWhile(ls) = if ls is
  N then N
  C(t) then if True then dropWhile(t) else C(t)
fun f(x) =
  let x = f(C(N))
  if x is
    C(a) then N
    N then f(x)
f(dropWhile(C(N)))
//│ |#fun| |dropWhile|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|t|)| |#then| |#if| |True| |#then| |dropWhile|(|t|)| |#else| |C|(|t|)|←|↵|#fun| |f|(|x|)| |#=|→|#let| |x| |#=| |f|(|C|(|N|)|)|↵|#if| |x| |is|→|C|(|a|)| |#then| |N|↵|N| |#then| |f|(|x|)|←|←|↵|f|(|dropWhile|(|C|(|N|)|)|)|
//│ Parsed: {fun dropWhile = ls, => if ls is ‹(N) then N; (C (t,)) then if (True) then dropWhile (t,) else C (t,)›; fun f = x, => {let x = f (C (N,),); if x is ‹(C (a,)) then N; (N) then f (x,)›}; f (dropWhile (C (N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^24(dropWhile^25([C [N]]))
//│ def dropWhile(ls⁰) = case ls⁰ of {
//│ 	N  => [N]
//│ 	| C t⁰ => if [True] then dropWhile^4(t⁰) else [C t⁰]}
//│ def f(x⁰) = 
//│ 	let x¹ = f^12([C [N]])
//│ 	in case x¹ of {
//│ 		C a⁰ => [N]
//│ 		| N  => f^18(x¹)}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f x_0 =
//│ 		  (let rec x_1 = (f (`C((`N)))) in
//│ 		    (match x_1 with
//│ 		      | `C(a_0) -> 
//│ 		        (`N)
//│ 		      | `N -> 
//│ 		        (f x_1)));;
//│ 		let rec dropWhile ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | `C(t_0) -> 
//│ 		      (if true then
//│ 		        (dropWhile t_0)
//│ 		      else
//│ 		        (`C(t_0))));;
//│ 		(f (dropWhile (`C((`N)))))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		            val f : [ `C of [> `N ] as 'a | `N ] -> [ `C of 'a | `N ] = <fun>
//│ 		[ok]
//│ 		                  val dropWhile : ([< `C of 'a | `N ] as 'a) -> [> `C of 'a | `N ] = <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [dropWhile^25] (hopeless to continue)
//│ 	[dropWhile^25 · dropWhile^4] ---> [dropWhile^25] (using original def)
//│ [f^24] (hopeless to continue)
//│ 	[f^24 · f^12] ---> [f^24] (using original def)
//│ 	[f^24 · f^18] ---> [f^24] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀(dropWhile_₀([C [N]]))
//│ def dropWhile_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		N  => [N]
//│ 		| C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}
//│ def f_₀(x²) = 
//│ 	let x³ = f_₀([C [N]])
//│ 	in case x³ of {
//│ 		C a¹ => [N]
//│ 		| N  => f_₀(x³)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 35 --->
//│ 	DeadCodeCons
//│ 	NoCons
//│ 	case x³ of {C a¹ => [N] | N  => f_₀(x³)}: 39
//│ [N]: 55 --->
//│ 	DeadCodeCons
//│ 	case ls¹ of {N  => [N] | C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}: 51
//│ [C [N]]: 56 --->
//│ 	case ls¹ of {N  => [N] | C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}: 51
//│ ------------------
//│ case x³ of {C a¹ => [N] | N  => f_₀(x³)}: 39 --->
//│ 	[N]: 35
//│ case ls¹ of {N  => [N] | C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}: 51 --->
//│ 	[N]: 55
//│ 	[C [N]]: 56
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀(dropWhile_₀([C [N]]))
//│ def dropWhile_₀(ls²) = 
//│ 	case ls² of {
//│ 		N  => [N]
//│ 		| C t¹ => if [True] then dropWhile_₀(t¹) else [C t¹]}
//│ def f_₀(x⁴) = 
//│ 	let x⁵ = f_₀([C [N]])
//│ 	in case x⁵ of {
//│ 		C a¹ => [N]
//│ 		| N  => f_₀(x⁵)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ f_₀ :: 'f_₀ <: [] ::: true
//│ dropWhile_₀ :: 'dropWhile_₀ <: [] ::: true
//│ [N] :: N ::: true
//│ [C [N]] :: C(N) ::: true
//│ dropWhile_₀([C [N]]) :: '5_callres <: [] ::: true
//│ f_₀(dropWhile_₀([C [N]])) :: '6_callres <: [] ::: true
//│ f_₀ :: 'f_₀ <: [] ::: true
//│ [N] :: N ::: true
//│ [C [N]] :: C(N) ::: true
//│ f_₀([C [N]]) :: '10_callres <: [] ::: true
//│ x :: 'x¹ <: [] ::: true
//│ [N] :: N ::: true
//│ f_₀ :: 'f_₀ <: [] ::: true
//│ x :: 'x¹ <: [] ::: true
//│ f_₀(x) :: '15_callres <: [] ::: true
//│ case x of {C a => [N] | N  => f_₀(x)} :: '16_matchres <: [] ::: true
//│ let x = f_₀([C [N]])
//│ in case x of {C a => [N] | N  => f_₀(x)} :: '16_matchres <: [] ::: true
//│ (fun x -> let x = f_₀([C [N]])
//│ in case x of {C a => [N] | N  => f_₀(x)}) :: 'x⁰ => '16_matchres ::: true
//│ ls :: 'ls⁰ <: [] ::: true
//│ [N] :: N ::: true
//│ [True] :: True ::: true
//│ dropWhile_₀ :: 'dropWhile_₀ <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ dropWhile_₀(t) :: '24_callres <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ [C t] :: C('t⁰) ::: true
//│ if [True] then dropWhile_₀(t) else [C t] :: '27_ifres <: [] ::: true
//│ case ls of {N  => [N] | C t => if [True] then dropWhile_₀(t) else [C t]} :: '28_matchres <: [] ::: true
//│ (fun ls -> case ls of {N  => [N] | C t => if [True] then dropWhile_₀(t) else [C t]}) :: 'ls⁰ => '28_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec dropWhile__d0 ls_0 =
//│   (match ls_0 with
//│     | `N -> 
//│       (`N)
//│     | `C(t_0) -> 
//│       (if true then
//│         (dropWhile__d0 t_0)
//│       else
//│         (`C(t_0))));;
//│ let rec f__d0 x_0 =
//│   (let rec x_1 = (f__d0 (`C((`N)))) in
//│     (match x_1 with
//│       | `C(a_0) -> 
//│         (`N)
//│       | `N -> 
//│         (f__d0 x_1)));;
//│ (f__d0 (dropWhile__d0 (`C((`N)))))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│   Stack overflow during evaluation (looping recursion?).
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
:lhNoIter
:d
fun break(ls) = if ls is
  N then
    let fst = N
    let snd = N
    C(fst, words1(snd))
  C(h,t) then
    let fst = N
    let snd = C(h,t)
    C(fst, words1(snd))
fun dropWhile(p, ls) = if ls is
  N then N
  C(h,t) then if p(h) then dropWhile(p, t) else C(h,t)
fun words0(ls) =
  let mident = dropWhile(x => False, ls)
  if mident is
    N then N
    _ then break(mident)
fun words1(ls) =
  let mident = dropWhile(x => False, ls)
  if mident is
    N then N
    _ then break(mident)
(x => 2)(words0)
//│ |#fun| |break|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then|→|#let| |fst| |#=| |N|↵|#let| |snd| |#=| |N|↵|C|(|fst|,| |words1|(|snd|)|)|←|↵|C|(|h|,|t|)| |#then|→|#let| |fst| |#=| |N|↵|#let| |snd| |#=| |C|(|h|,|t|)|↵|C|(|fst|,| |words1|(|snd|)|)|←|←|↵|#fun| |dropWhile|(|p|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|h|,|t|)| |#then| |#if| |p|(|h|)| |#then| |dropWhile|(|p|,| |t|)| |#else| |C|(|h|,|t|)|←|↵|#fun| |words0|(|ls|)| |#=|→|#let| |mident| |#=| |dropWhile|(|x| |=>| |False|,| |ls|)|↵|#if| |mident| |is|→|N| |#then| |N|↵|_| |#then| |break|(|mident|)|←|←|↵|#fun| |words1|(|ls|)| |#=|→|#let| |mident| |#=| |dropWhile|(|x| |=>| |False|,| |ls|)|↵|#if| |mident| |is|→|N| |#then| |N|↵|_| |#then| |break|(|mident|)|←|←|↵|(|x| |=>| |2|)|(|words0|)|
//│ Parsed: {fun break = ls, => if ls is ‹(N) then {let fst = N; let snd = N; C (fst, words1 (snd,),)}; (C (h, t,)) then {let fst = N; let snd = C (h, t,); C (fst, words1 (snd,),)}›; fun dropWhile = p, ls, => if ls is ‹(N) then N; (C (h, t,)) then if (p (h,)) then dropWhile (p, t,) else C (h, t,)›; fun words0 = ls, => {let mident = dropWhile (x, => False, ls,); if mident is ‹(N) then N; (_) then break (mident,)›}; fun words1 = ls, => {let mident = dropWhile (x, => False, ls,); if mident is ‹(N) then N; (_) then break (mident,)›}; '(' x, => 2, ')' (words0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (fun x² -> 2)(words0^71)
//│ def break(ls⁰) = case ls⁰ of {
//│ 	N  => 
//│ 		let fst⁰ = [N]
//│ 		in let snd⁰ = [N]
//│ 		in [C fst⁰ words1^5(snd⁰)]
//│ 	| C h⁰ t⁰ => 
//│ 		let fst¹ = [N]
//│ 		in let snd¹ = [C h⁰ t⁰]
//│ 		in [C fst¹ words1^16(snd¹)]}
//│ def dropWhile(p⁰, ls¹) = case ls¹ of {
//│ 	N  => [N]
//│ 	| C h¹ t¹ => if p⁰(h¹) then dropWhile^29(p⁰, t¹) else [C h¹ t¹]}
//│ def words0(ls²) = 
//│ 	let mident⁰ = dropWhile^41((fun x⁰ -> [False]), ls²)
//│ 	in case mident⁰ of {
//│ 		N  => [N]
//│ 		| _  => break^49(mident⁰)}
//│ def words1(ls³) = 
//│ 	let mident¹ = dropWhile^55((fun x¹ -> [False]), ls³)
//│ 	in case mident¹ of {
//│ 		N  => [N]
//│ 		| _  => break^63(mident¹)}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec dropWhile p_0 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (if (p_0 h_1) then
//│ 		        ((dropWhile p_0) t_1)
//│ 		      else
//│ 		        (`C(h_1, t_1))));;
//│ 		let rec break ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (let rec fst_0 = (`N) in
//│ 		        (let rec snd_0 = (`N) in
//│ 		          (`C(fst_0, (words1 snd_0)))))
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (let rec fst_1 = (`N) in
//│ 		        (let rec snd_1 = (`C(h_0, t_0)) in
//│ 		          (`C(fst_1, (words1 snd_1))))))
//│ 		and
//│ 		words1 ls_3 =
//│ 		  (let rec mident_1 = ((dropWhile (fun x_1 -> 
//│ 		    false)) ls_3) in
//│ 		    (match mident_1 with
//│ 		      | `N -> 
//│ 		        (`N)
//│ 		      | _ -> 
//│ 		        (break mident_1)));;
//│ 		let rec words0 ls_2 =
//│ 		  (let rec mident_0 = ((dropWhile (fun x_0 -> 
//│ 		    false)) ls_2) in
//│ 		    (match mident_0 with
//│ 		      | `N -> 
//│ 		        (`N)
//│ 		      | _ -> 
//│ 		        (break mident_0)));;
//│ 		((fun x_2 -> 
//│ 		  2) words0)
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		                val dropWhile :
//│ 		  ('a -> bool) -> ([< `C of 'a * 'b | `N ] as 'b) -> [> `C of 'a * 'b | `N ] =
//│ 		  <fun>
//│ 		[ok]
//│ 		                                      val break :
//│ 		  [ `C of 'a * ([ `C of 'a * 'b | `N ] as 'b) | `N ] ->
//│ 		  ([> `C of [> `N ] * 'c | `N ] as 'c) = <fun>
//│ 		val words1 :
//│ 		  ([ `C of 'b * 'a | `N ] as 'a) -> ([> `C of [> `N ] * 'c | `N ] as 'c) =
//│ 		  <fun>
//│ 		[ok]
//│ 		                val words0 :
//│ 		  ([ `C of 'b * 'a | `N ] as 'a) -> ([> `C of [> `N ] * 'c | `N ] as 'c) =
//│ 		  <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [words0^71] (hopeless to continue)
//│ 	[words0^71 · break^49] (using original def)
//│ 		[words0^71 · break^49 · words1^16] (using original def)
//│ 			[words0^71 · break^49 · words1^16 · break^63] ---> [words0^71 · break^49] (using original def)
//│ 			[words0^71 · break^49 · words1^16 · dropWhile^55] (using original def)
//│ 				[words0^71 · break^49 · words1^16 · dropWhile^55 · dropWhile^29] ---> [words0^71 · break^49 · words1^16 · dropWhile^55] (using original def)
//│ 		[words0^71 · break^49 · words1^5] (using original def)
//│ 			[words0^71 · break^49 · words1^5 · break^63] ---> [words0^71 · break^49] (using original def)
//│ 			[words0^71 · break^49 · words1^5 · dropWhile^55] (using original def)
//│ 				[words0^71 · break^49 · words1^5 · dropWhile^55 · dropWhile^29] ---> [words0^71 · break^49 · words1^5 · dropWhile^55] (using original def)
//│ 	[words0^71 · dropWhile^41] (using original def)
//│ 		[words0^71 · dropWhile^41 · dropWhile^29] ---> [words0^71 · dropWhile^41] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (fun x⁶ -> 2)(words0_₀)
//│ def words0_₀(ls⁴) = 
//│ 	let mident² = dropWhile_₂((fun x³ -> [False]), ls⁴)
//│ 	in case mident² of {
//│ 		N  => [N]
//│ 		| _  => break_₀(mident²)}
//│ 	where
//│ 	def break_₀(ls⁸) = 
//│ 		case ls⁸ of {
//│ 			N  => 
//│ 				let fst² = [N]
//│ 				in let snd² = [N]
//│ 				in [C fst² words1_₁(snd²)]
//│ 			| C h⁴ t⁴ => 
//│ 				let fst³ = [N]
//│ 				in let snd³ = [C h⁴ t⁴]
//│ 				in [C fst³ words1_₀(snd³)]}
//│ 		where
//│ 		def words1_₀(ls¹⁰) = 
//│ 			let mident⁴ = dropWhile_₀((fun x⁵ -> [False]), ls¹⁰)
//│ 			in case mident⁴ of {
//│ 				N  => [N]
//│ 				| _  => break_₀(mident⁴)}
//│ 			where
//│ 			def dropWhile_₀(p³, ls⁹) = 
//│ 				case ls⁹ of {
//│ 					N  => [N]
//│ 					| C h⁵ t⁵ => if p³(h⁵) then dropWhile_₀(p³, t⁵) else [C h⁵ t⁵]}
//│ 		def words1_₁(ls⁵) = 
//│ 			let mident³ = dropWhile_₁((fun x⁴ -> [False]), ls⁵)
//│ 			in case mident³ of {
//│ 				N  => [N]
//│ 				| _  => break_₀(mident³)}
//│ 			where
//│ 			def dropWhile_₁(p¹, ls⁶) = 
//│ 				case ls⁶ of {
//│ 					N  => [N]
//│ 					| C h² t² => if p¹(h²) then dropWhile_₁(p¹, t²) else [C h² t²]}
//│ 	def dropWhile_₂(p², ls⁷) = 
//│ 		case ls⁷ of {
//│ 			N  => [N]
//│ 			| C h³ t³ => if p²(h³) then dropWhile_₂(p², t³) else [C h³ t³]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 102 --->
//│ 	case mident³ of {N  => [N] | _  => break_₀(mident³)}: 98
//│ 	case ls⁸ of {N  => let fst² = [N]
//│ in let snd² = [N]
//│ in [C fst² words1_₁(snd²)] | C h⁴ t⁴ => let fst³ = [N]
//│ in let snd³ = [C h⁴ t⁴]
//│ in [C fst³ words1_₀(snd³)]}: 156
//│ [C h² t²]: 113 --->
//│ 	case mident³ of {N  => [N] | _  => break_₀(mident³)}: 98
//│ 	case ls⁸ of {N  => let fst² = [N]
//│ in let snd² = [N]
//│ in [C fst² words1_₁(snd²)] | C h⁴ t⁴ => let fst³ = [N]
//│ in let snd³ = [C h⁴ t⁴]
//│ in [C fst³ words1_₀(snd³)]}: 156
//│ [N]: 119 --->
//│ 	case mident² of {N  => [N] | _  => break_₀(mident²)}: 84
//│ 	case ls⁸ of {N  => let fst² = [N]
//│ in let snd² = [N]
//│ in [C fst² words1_₁(snd²)] | C h⁴ t⁴ => let fst³ = [N]
//│ in let snd³ = [C h⁴ t⁴]
//│ in [C fst³ words1_₀(snd³)]}: 156
//│ [C h³ t³]: 130 --->
//│ 	case mident² of {N  => [N] | _  => break_₀(mident²)}: 84
//│ 	case ls⁸ of {N  => let fst² = [N]
//│ in let snd² = [N]
//│ in [C fst² words1_₁(snd²)] | C h⁴ t⁴ => let fst³ = [N]
//│ in let snd³ = [C h⁴ t⁴]
//│ in [C fst³ words1_₀(snd³)]}: 156
//│ [N]: 137 --->
//│ 	case ls⁶ of {N  => [N] | C h² t² => if p¹(h²) then dropWhile_₁(p¹, t²) else [C h² t²]}: 115
//│ [C h⁴ t⁴]: 148 --->
//│ 	case ls⁹ of {N  => [N] | C h⁵ t⁵ => if p³(h⁵) then dropWhile_₀(p³, t⁵) else [C h⁵ t⁵]}: 172
//│ [N]: 159 --->
//│ 	case ls⁸ of {N  => let fst² = [N]
//│ in let snd² = [N]
//│ in [C fst² words1_₁(snd²)] | C h⁴ t⁴ => let fst³ = [N]
//│ in let snd³ = [C h⁴ t⁴]
//│ in [C fst³ words1_₀(snd³)]}: 156
//│ 	case mident⁴ of {N  => [N] | _  => break_₀(mident⁴)}: 186
//│ [C h⁵ t⁵]: 170 --->
//│ 	case ls⁸ of {N  => let fst² = [N]
//│ in let snd² = [N]
//│ in [C fst² words1_₁(snd²)] | C h⁴ t⁴ => let fst³ = [N]
//│ in let snd³ = [C h⁴ t⁴]
//│ in [C fst³ words1_₀(snd³)]}: 156
//│ 	case mident⁴ of {N  => [N] | _  => break_₀(mident⁴)}: 186
//│ ------------------
//│ case mident² of {N  => [N] | _  => break_₀(mident²)}: 84 --->
//│ 	[N]: 119
//│ 	[C h³ t³]: 130
//│ case mident³ of {N  => [N] | _  => break_₀(mident³)}: 98 --->
//│ 	[N]: 102
//│ 	[C h² t²]: 113
//│ case ls⁶ of {N  => [N] | C h² t² => if p¹(h²) then dropWhile_₁(p¹, t²) else [C h² t²]}: 115 --->
//│ 	DeadCodeProd
//│ 	[N]: 137
//│ case ls⁸ of {N  => let fst² = [N]
//│ in let snd² = [N]
//│ in [C fst² words1_₁(snd²)] | C h⁴ t⁴ => let fst³ = [N]
//│ in let snd³ = [C h⁴ t⁴]
//│ in [C fst³ words1_₀(snd³)]}: 156 --->
//│ 	[N]: 102
//│ 	[C h² t²]: 113
//│ 	[N]: 119
//│ 	[C h³ t³]: 130
//│ 	[N]: 159
//│ 	[C h⁵ t⁵]: 170
//│ case ls⁹ of {N  => [N] | C h⁵ t⁵ => if p³(h⁵) then dropWhile_₀(p³, t⁵) else [C h⁵ t⁵]}: 172 --->
//│ 	DeadCodeProd
//│ 	[C h⁴ t⁴]: 148
//│ case mident⁴ of {N  => [N] | _  => break_₀(mident⁴)}: 186 --->
//│ 	[N]: 159
//│ 	[C h⁵ t⁵]: 170
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (fun x⁷ -> 2)(words0_₀)
//│ def words0_₀(ls¹⁴) = 
//│ 	let mident⁵ = dropWhile_₂((fun x⁸ -> [False]), ls¹⁴)
//│ 	in case mident⁵ of {
//│ 		N  => [N]
//│ 		| _  => break_₀(mident⁵)}
//│ 	where
//│ 	def break_₀(ls¹³) = 
//│ 		case ls¹³ of {
//│ 			N  => 
//│ 				let fst⁴ = [N]
//│ 				in let snd⁴ = [N]
//│ 				in [C fst⁴ words1_₁(snd⁴)]
//│ 			| C h⁴ t⁴ => 
//│ 				let fst⁵ = [N]
//│ 				in let snd⁵ = [C h⁴ t⁴]
//│ 				in [C fst⁵ words1_₀(snd⁵)]}
//│ 		where
//│ 		def words1_₀(ls¹⁶) = 
//│ 			let mident⁷ = dropWhile_₀((fun x¹⁰ -> [False]), ls¹⁶)
//│ 			in case mident⁷ of {
//│ 				N  => [N]
//│ 				| _  => break_₀(mident⁷)}
//│ 			where
//│ 			def dropWhile_₀(p⁵, ls¹²) = 
//│ 				case ls¹² of {
//│ 					N  => [N]
//│ 					| C h⁵ t⁵ => if p⁵(h⁵) then dropWhile_₀(p⁵, t⁵) else [C h⁵ t⁵]}
//│ 		def words1_₁(ls¹⁵) = 
//│ 			let mident⁶ = dropWhile_₁((fun x⁹ -> [False]), ls¹⁵)
//│ 			in case mident⁶ of {
//│ 				N  => [N]
//│ 				| _  => break_₀(mident⁶)}
//│ 			where
//│ 			def dropWhile_₁(p⁶, ls¹⁷) = 
//│ 				case ls¹⁷ of {
//│ 					N  => [N]
//│ 					| C h² t² => if p⁶(h²) then dropWhile_₁(p⁶, t²) else [C h² t²]}
//│ 	def dropWhile_₂(p⁴, ls¹¹) = 
//│ 		case ls¹¹ of {
//│ 			N  => [N]
//│ 			| C h³ t³ => if p⁴(h³) then dropWhile_₂(p⁴, t³) else [C h³ t³]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ 2 :: Int ::: false
//│ (fun x -> 2) :: 'x⁰ => Int ::: true
//│ words0_₀ :: 'words0_₀ <: [] ::: true
//│ (fun x -> 2)(words0_₀) :: '4_callres <: [] ::: true
//│ ls :: 'ls⁰ <: [] ::: true
//│ [N] :: N ::: true
//│ p :: 'p⁰ <: [] ::: true
//│ h :: 'h⁰ <: [] ::: true
//│ p(h) :: '9_callres <: [] ::: true
//│ dropWhile_₂ :: 'dropWhile_₂ <: [] ::: true
//│ p :: 'p⁰ <: [] ::: true
//│ dropWhile_₂(p) :: '12_callres <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ dropWhile_₂(p, t) :: '14_callres <: [] ::: true
//│ h :: 'h⁰ <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ [C h t] :: C('h⁰, 't⁰) ::: true
//│ if p(h) then dropWhile_₂(p, t) else [C h t] :: '18_ifres <: [] ::: true
//│ case ls of {N  => [N] | C h t => if p(h) then dropWhile_₂(p, t) else [C h t]} :: '19_matchres <: [] ::: true
//│ (fun ls -> case ls of {N  => [N] | C h t => if p(h) then dropWhile_₂(p, t) else [C h t]}) :: 'ls⁰ => '19_matchres ::: true
//│ (fun p -> (fun ls -> case ls of {N  => [N] | C h t => if p(h) then dropWhile_₂(p, t) else [C h t]})) :: 'p⁰ => 'ls⁰ => '19_matchres ::: true
//│ ls :: 'ls¹ <: [] ::: true
//│ [N] :: N ::: true
//│ p :: 'p¹ <: [] ::: true
//│ h :: 'h¹ <: [] ::: true
//│ p(h) :: '26_callres <: [] ::: true
//│ dropWhile_₀ :: 'dropWhile_₀ <: [] ::: true
//│ p :: 'p¹ <: [] ::: true
//│ dropWhile_₀(p) :: '29_callres <: [] ::: true
//│ t :: 't¹ <: [] ::: true
//│ dropWhile_₀(p, t) :: '31_callres <: [] ::: true
//│ h :: 'h¹ <: [] ::: true
//│ t :: 't¹ <: [] ::: true
//│ [C h t] :: C('h¹, 't¹) ::: true
//│ if p(h) then dropWhile_₀(p, t) else [C h t] :: '35_ifres <: [] ::: true
//│ case ls of {N  => [N] | C h t => if p(h) then dropWhile_₀(p, t) else [C h t]} :: '36_matchres <: [] ::: true
//│ (fun ls -> case ls of {N  => [N] | C h t => if p(h) then dropWhile_₀(p, t) else [C h t]}) :: 'ls¹ => '36_matchres ::: true
//│ (fun p -> (fun ls -> case ls of {N  => [N] | C h t => if p(h) then dropWhile_₀(p, t) else [C h t]})) :: 'p¹ => 'ls¹ => '36_matchres ::: true
//│ ls :: 'ls² <: [] ::: true
//│ [N] :: N ::: true
//│ [N] :: N ::: true
//│ fst :: 'fst⁰ <: [] ::: true
//│ words1_₁ :: 'words1_₁ <: [] ::: true
//│ snd :: 'snd⁰ <: [] ::: true
//│ words1_₁(snd) :: '45_callres <: [] ::: true
//│ [C fst words1_₁(snd)] :: C('fst⁰, '45_callres) ::: true
//│ let snd = [N]
//│ in [C fst words1_₁(snd)] :: C('fst⁰, '45_callres) ::: true
//│ let fst = [N]
//│ in let snd = [N]
//│ in [C fst words1_₁(snd)] :: C('fst⁰, '45_callres) ::: true
//│ [N] :: N ::: true
//│ h :: 'h² <: [] ::: true
//│ t :: 't² <: [] ::: true
//│ [C h t] :: C('h², 't²) ::: true
//│ fst :: 'fst¹ <: [] ::: true
//│ words1_₀ :: 'words1_₀ <: [] ::: true
//│ snd :: 'snd¹ <: [] ::: true
//│ words1_₀(snd) :: '56_callres <: [] ::: true
//│ [C fst words1_₀(snd)] :: C('fst¹, '56_callres) ::: true
//│ let snd = [C h t]
//│ in [C fst words1_₀(snd)] :: C('fst¹, '56_callres) ::: true
//│ let fst = [N]
//│ in let snd = [C h t]
//│ in [C fst words1_₀(snd)] :: C('fst¹, '56_callres) ::: true
//│ case ls of {N  => let fst = [N]
//│ in let snd = [N]
//│ in [C fst words1_₁(snd)] | C h t => let fst = [N]
//│ in let snd = [C h t]
//│ in [C fst words1_₀(snd)]} :: '60_matchres <: [] ::: true
//│ (fun ls -> case ls of {N  => let fst = [N]
//│ in let snd = [N]
//│ in [C fst words1_₁(snd)] | C h t => let fst = [N]
//│ in let snd = [C h t]
//│ in [C fst words1_₀(snd)]}) :: 'ls² => '60_matchres ::: true
//│ dropWhile_₂ :: 'dropWhile_₂ <: [] ::: true
//│ [False] :: False ::: true
//│ (fun x -> [False]) :: 'x¹ => False ::: true
//│ dropWhile_₂((fun x -> [False])) :: '65_callres <: [] ::: true
//│ ls :: 'ls³ <: [] ::: true
//│ dropWhile_₂((fun x -> [False]), ls) :: '67_callres <: [] ::: true
//│ mident :: 'mident⁰ <: [] ::: true
//│ [N] :: N ::: true
//│ break_₀ :: 'break_₀ <: [] ::: true
//│ mident :: 'mident⁰ <: [] ::: true
//│ break_₀(mident) :: '72_callres <: [] ::: true
//│ case mident of {N  => [N] | _  => break_₀(mident)} :: '73_matchres <: [] ::: true
//│ let mident = dropWhile_₂((fun x -> [False]), ls)
//│ in case mident of {N  => [N] | _  => break_₀(mident)} :: '73_matchres <: [] ::: true
//│ (fun ls -> let mident = dropWhile_₂((fun x -> [False]), ls)
//│ in case mident of {N  => [N] | _  => break_₀(mident)}) :: 'ls³ => '73_matchres ::: true
//│ dropWhile_₁ :: 'dropWhile_₁ <: [] ::: true
//│ [False] :: False ::: true
//│ (fun x -> [False]) :: 'x² => False ::: true
//│ dropWhile_₁((fun x -> [False])) :: '79_callres <: [] ::: true
//│ ls :: 'ls⁴ <: [] ::: true
//│ dropWhile_₁((fun x -> [False]), ls) :: '81_callres <: [] ::: true
//│ mident :: 'mident¹ <: [] ::: true
//│ [N] :: N ::: true
//│ break_₀ :: 'break_₀ <: [] ::: true
//│ mident :: 'mident¹ <: [] ::: true
//│ break_₀(mident) :: '86_callres <: [] ::: true
//│ case mident of {N  => [N] | _  => break_₀(mident)} :: '87_matchres <: [] ::: true
//│ let mident = dropWhile_₁((fun x -> [False]), ls)
//│ in case mident of {N  => [N] | _  => break_₀(mident)} :: '87_matchres <: [] ::: true
//│ (fun ls -> let mident = dropWhile_₁((fun x -> [False]), ls)
//│ in case mident of {N  => [N] | _  => break_₀(mident)}) :: 'ls⁴ => '87_matchres ::: true
//│ dropWhile_₀ :: 'dropWhile_₀ <: [] ::: true
//│ [False] :: False ::: true
//│ (fun x -> [False]) :: 'x³ => False ::: true
//│ dropWhile_₀((fun x -> [False])) :: '93_callres <: [] ::: true
//│ ls :: 'ls⁵ <: [] ::: true
//│ dropWhile_₀((fun x -> [False]), ls) :: '95_callres <: [] ::: true
//│ mident :: 'mident² <: [] ::: true
//│ [N] :: N ::: true
//│ break_₀ :: 'break_₀ <: [] ::: true
//│ mident :: 'mident² <: [] ::: true
//│ break_₀(mident) :: '100_callres <: [] ::: true
//│ case mident of {N  => [N] | _  => break_₀(mident)} :: '101_matchres <: [] ::: true
//│ let mident = dropWhile_₀((fun x -> [False]), ls)
//│ in case mident of {N  => [N] | _  => break_₀(mident)} :: '101_matchres <: [] ::: true
//│ (fun ls -> let mident = dropWhile_₀((fun x -> [False]), ls)
//│ in case mident of {N  => [N] | _  => break_₀(mident)}) :: 'ls⁵ => '101_matchres ::: true
//│ ls :: 'ls⁶ <: [] ::: true
//│ [N] :: N ::: true
//│ p :: 'p² <: [] ::: true
//│ h :: 'h³ <: [] ::: true
//│ p(h) :: '108_callres <: [] ::: true
//│ dropWhile_₁ :: 'dropWhile_₁ <: [] ::: true
//│ p :: 'p² <: [] ::: true
//│ dropWhile_₁(p) :: '111_callres <: [] ::: true
//│ t :: 't³ <: [] ::: true
//│ dropWhile_₁(p, t) :: '113_callres <: [] ::: true
//│ h :: 'h³ <: [] ::: true
//│ t :: 't³ <: [] ::: true
//│ [C h t] :: C('h³, 't³) ::: true
//│ if p(h) then dropWhile_₁(p, t) else [C h t] :: '117_ifres <: [] ::: true
//│ case ls of {N  => [N] | C h t => if p(h) then dropWhile_₁(p, t) else [C h t]} :: '118_matchres <: [] ::: true
//│ (fun ls -> case ls of {N  => [N] | C h t => if p(h) then dropWhile_₁(p, t) else [C h t]}) :: 'ls⁶ => '118_matchres ::: true
//│ (fun p -> (fun ls -> case ls of {N  => [N] | C h t => if p(h) then dropWhile_₁(p, t) else [C h t]})) :: 'p² => 'ls⁶ => '118_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec dropWhile__d2 p_0 ls_0 =
//│   (match ls_0 with
//│     | `N -> 
//│       (`N)
//│     | `C(h_0, t_0) -> 
//│       (if (p_0 h_0) then
//│         ((dropWhile__d2 p_0) t_0)
//│       else
//│         (`C(h_0, t_0))));;
//│ let rec dropWhile__d1 p_2 ls_6 =
//│   (match ls_6 with
//│     | `N -> 
//│       (`N)
//│     | `C(h_3, t_3) -> 
//│       (if (p_2 h_3) then
//│         ((dropWhile__d1 p_2) t_3)
//│       else
//│         (`C(h_3, t_3))));;
//│ let rec dropWhile__d0 p_1 ls_1 =
//│   (match ls_1 with
//│     | `N -> 
//│       (`N)
//│     | `C(h_1, t_1) -> 
//│       (if (p_1 h_1) then
//│         ((dropWhile__d0 p_1) t_1)
//│       else
//│         (`C(h_1, t_1))));;
//│ let rec break__d0 ls_2 =
//│   (match ls_2 with
//│     | `N -> 
//│       (let rec fst_0 = (`N) in
//│         (let rec snd_0 = (`N) in
//│           (`C(fst_0, (words1__d1 snd_0)))))
//│     | `C(h_2, t_2) -> 
//│       (let rec fst_1 = (`N) in
//│         (let rec snd_1 = (`C(h_2, t_2)) in
//│           (`C(fst_1, (words1__d0 snd_1))))))
//│ and
//│ words1__d0 ls_5 =
//│   (let rec mident_2 = ((dropWhile__d0 (fun x_3 -> 
//│     false)) ls_5) in
//│     (match mident_2 with
//│       | `N -> 
//│         (`N)
//│       | _ -> 
//│         (break__d0 mident_2)))
//│ and
//│ words1__d1 ls_4 =
//│   (let rec mident_1 = ((dropWhile__d1 (fun x_2 -> 
//│     false)) ls_4) in
//│     (match mident_1 with
//│       | `N -> 
//│         (`N)
//│       | _ -> 
//│         (break__d0 mident_1)));;
//│ let rec words0__d0 ls_3 =
//│   (let rec mident_0 = ((dropWhile__d2 (fun x_1 -> 
//│     false)) ls_3) in
//│     (match mident_0 with
//│       | `N -> 
//│         (`N)
//│       | _ -> 
//│         (break__d0 mident_0)));;
//│ ((fun x_0 -> 
//│   2) words0__d0)
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│     - : int = 2
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
:lhNoIter
:d
fun f(x) = if x is
  C(t) then if True then f(t) else x // NOTE: or `else x`, but two branches must exist
fun break(x) = break(f(C(x)))
(x => 2)(x => break(f(x)))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|t|)| |#then| |#if| |True| |#then| |f|(|t|)| |#else| |x| |/* NOTE: or `else x`, but two branches must exist*/|←|↵|#fun| |break|(|x|)| |#=| |break|(|f|(|C|(|x|)|)|)|↵|(|x| |=>| |2|)|(|x| |=>| |break|(|f|(|x|)|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (t,)) then if (True) then f (t,) else x›; fun break = x, => break (f (C (x,),),); '(' x, => 2, ')' (x, => break (f (x,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (fun x² -> 2)((fun x³ -> break^19(f^20(x³))))
//│ def break(x¹) = break^10(f^11([C x¹]))
//│ def f(x⁰) = case x⁰ of {
//│ 	C t⁰ => if [True] then f^3(t⁰) else x⁰}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f x_0 =
//│ 		  (match x_0 with
//│ 		    | `C(t_0) -> 
//│ 		      (if true then
//│ 		        (f t_0)
//│ 		      else
//│ 		        x_0));;
//│ 		let rec break x_1 =
//│ 		  (break (f (`C(x_1))));;
//│ 		((fun x_2 -> 
//│ 		  2) (fun x_3 -> 
//│ 		  (break (f x_3))))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		            val f : ([< `C of 'a ] as 'a) -> 'a = <fun>
//│ 		[ok]
//│ 		    val break : ([ `C of 'a ] as 'a) -> 'b = <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [break^19] (hopeless to continue)
//│ 	[break^19 · break^10] ---> [break^19] (using original def)
//│ 	[break^19 · f^11] (using original def)
//│ 		[break^19 · f^11 · f^3] ---> [break^19 · f^11] (using original def)
//│ [f^20] (hopeless to continue)
//│ 	[f^20 · f^3] ---> [f^20] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (fun x⁷ -> 2)((fun x⁸ -> break_₀(f_₁(x⁸))))
//│ def break_₀(x⁴) = 
//│ 	break_₀(f_₀([C x⁴]))
//│ 	where
//│ 	def f_₀(x⁵) = 
//│ 		case x⁵ of {
//│ 			C t¹ => if [True] then f_₀(t¹) else x⁵}
//│ def f_₁(x⁶) = 
//│ 	case x⁶ of {
//│ 		C t² => if [True] then f_₁(t²) else x⁶}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x⁴]: 29 --->
//│ 	case x⁵ of {C t¹ => if [True] then f_₀(t¹) else x⁵}: 40
//│ ------------------
//│ case x⁵ of {C t¹ => if [True] then f_₀(t¹) else x⁵}: 40 --->
//│ 	DeadCodeProd
//│ 	[C x⁴]: 29
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (fun x⁹ -> 2)((fun x¹⁰ -> break_₀(f_₁(x¹⁰))))
//│ def break_₀(x¹¹) = 
//│ 	break_₀(f_₀([C x¹¹]))
//│ 	where
//│ 	def f_₀(x¹²) = 
//│ 		case x¹² of {
//│ 			C t¹ => if [True] then f_₀(t¹) else x¹²}
//│ def f_₁(x¹³) = 
//│ 	case x¹³ of {
//│ 		C t² => if [True] then f_₁(t²) else x¹³}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ 2 :: Int ::: false
//│ (fun x -> 2) :: 'x⁰ => Int ::: true
//│ break_₀ :: 'break_₀ <: [] ::: true
//│ f_₁ :: 'f_₁ <: [] ::: true
//│ x :: 'x¹ <: [] ::: true
//│ f_₁(x) :: '6_callres <: [] ::: true
//│ break_₀(f_₁(x)) :: '7_callres <: [] ::: true
//│ (fun x -> break_₀(f_₁(x))) :: 'x¹ => '7_callres ::: true
//│ (fun x -> 2)((fun x -> break_₀(f_₁(x)))) :: '9_callres <: [] ::: true
//│ break_₀ :: 'break_₀ <: [] ::: true
//│ f_₀ :: 'f_₀ <: [] ::: true
//│ x :: 'x² <: [] ::: true
//│ [C x] :: C('x²) ::: true
//│ f_₀([C x]) :: '14_callres <: [] ::: true
//│ break_₀(f_₀([C x])) :: '15_callres <: [] ::: true
//│ (fun x -> break_₀(f_₀([C x]))) :: 'x² => '15_callres ::: true
//│ x :: 'x³ <: [] ::: true
//│ [True] :: True ::: true
//│ f_₀ :: 'f_₀ <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ f_₀(t) :: '21_callres <: [] ::: true
//│ x :: 'x³ <: [] ::: true
//│ if [True] then f_₀(t) else x :: '23_ifres <: [] ::: true
//│ case x of {C t => if [True] then f_₀(t) else x} :: '24_matchres <: [] ::: true
//│ (fun x -> case x of {C t => if [True] then f_₀(t) else x}) :: 'x³ => '24_matchres ::: true
//│ x :: 'x⁴ <: [] ::: true
//│ [True] :: True ::: true
//│ f_₁ :: 'f_₁ <: [] ::: true
//│ t :: 't¹ <: [] ::: true
//│ f_₁(t) :: '30_callres <: [] ::: true
//│ x :: 'x⁴ <: [] ::: true
//│ if [True] then f_₁(t) else x :: '32_ifres <: [] ::: true
//│ case x of {C t => if [True] then f_₁(t) else x} :: '33_matchres <: [] ::: true
//│ (fun x -> case x of {C t => if [True] then f_₁(t) else x}) :: 'x⁴ => '33_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec f__d0 x_3 =
//│   (match x_3 with
//│     | `C(t_0) -> 
//│       (if true then
//│         (f__d0 t_0)
//│       else
//│         x_3));;
//│ let rec f__d1 x_4 =
//│   (match x_4 with
//│     | `C(t_1) -> 
//│       (if true then
//│         (f__d1 t_1)
//│       else
//│         x_4));;
//│ let rec break__d0 x_2 =
//│   (break__d0 (f__d0 (`C(x_2))));;
//│ ((fun x_0 -> 
//│   2) (fun x_1 -> 
//│   (break__d0 (f__d1 x_1))))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│       - : int = 2
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

// prodType recurses in a way that will return a type of `[C of 'a] as 'a`
// two uses of the consumer `f`:
// for one branch the input is not constraint with any prodStrat, so it is ignored with no clash;
// for the other branch the input is `g(t)` which produces a `C(t)`, and it will be fused
// and our type system does not catch this?
:lhGenOCaml
:d
fun prodType(x) = if x is
  C(t) then if True then t else prodType(t)
fun f(x) = if x is
  C(t) then if True then f(t) else f(g(t))
fun g(t) = C(t)
(x => 2)(x => f(prodType(x)))
//│ |#fun| |prodType|(|x|)| |#=| |#if| |x| |is|→|C|(|t|)| |#then| |#if| |True| |#then| |t| |#else| |prodType|(|t|)|←|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|t|)| |#then| |#if| |True| |#then| |f|(|t|)| |#else| |f|(|g|(|t|)|)|←|↵|#fun| |g|(|t|)| |#=| |C|(|t|)|↵|(|x| |=>| |2|)|(|x| |=>| |f|(|prodType|(|x|)|)|)|
//│ Parsed: {fun prodType = x, => if x is ‹(C (t,)) then if (True) then t else prodType (t,)›; fun f = x, => if x is ‹(C (t,)) then if (True) then f (t,) else f (g (t,),)›; fun g = t, => C (t,); '(' x, => 2, ')' (x, => f (prodType (x,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (fun x² -> 2)((fun x³ -> f^28(prodType^29(x³))))
//│ def f(x¹) = case x¹ of {
//│ 	C t¹ => if [True] then f^12(t¹) else f^15(g^16(t¹))}
//│ def g(t²) = [C t²]
//│ def prodType(x⁰) = case x⁰ of {
//│ 	C t⁰ => if [True] then t⁰ else prodType^4(t⁰)}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec g t_2 =
//│ 		  (`C(t_2));;
//│ 		let rec prodType x_0 =
//│ 		  (match x_0 with
//│ 		    | `C(t_0) -> 
//│ 		      (if true then
//│ 		        t_0
//│ 		      else
//│ 		        (prodType t_0)));;
//│ 		let rec f x_1 =
//│ 		  (match x_1 with
//│ 		    | `C(t_1) -> 
//│ 		      (if true then
//│ 		        (f t_1)
//│ 		      else
//│ 		        (f (g t_1))));;
//│ 		((fun x_2 -> 
//│ 		  2) (fun x_3 -> 
//│ 		  (f (prodType x_3))))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		  val g : 'a -> [> `C of 'a ] = <fun>
//│ 		[ok]
//│ 		              val prodType : ([< `C of 'a ] as 'a) -> 'a = <fun>
//│ 		[ok]
//│ 		              val f : ([ `C of 'a ] as 'a) -> 'b = <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^28] (hopeless to continue)
//│ 	[f^28 · f^12] ---> [f^28] (using original def)
//│ 	[f^28 · f^15] ---> [f^28] (using original def)
//│ 	[f^28 · g^16] (using original def)
//│ [prodType^29] (hopeless to continue)
//│ 	[prodType^29 · prodType^4] ---> [prodType^29] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (fun x⁶ -> 2)((fun x⁷ -> f_₀(prodType_₀(x⁷))))
//│ def f_₀(x⁴) = 
//│ 	case x⁴ of {
//│ 		C t⁴ => if [True] then f_₀(t⁴) else f_₀(g_₀(t⁴))}
//│ 	where
//│ 	def g_₀(t³) = 
//│ 		[C t³]
//│ def prodType_₀(x⁵) = 
//│ 	case x⁵ of {
//│ 		C t⁵ => if [True] then t⁵ else prodType_₀(t⁵)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C t³]: 36 --->
//│ 	case x⁴ of {C t⁴ => if [True] then f_₀(t⁴) else f_₀(g_₀(t⁴))}: 49
//│ ------------------
//│ case x⁴ of {C t⁴ => if [True] then f_₀(t⁴) else f_₀(g_₀(t⁴))}: 49 --->
//│ 	DeadCodeProd
//│ 	[C t³]: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (fun x⁸ -> 2)((fun x⁹ -> f_₀(prodType_₀(x⁹))))
//│ def f_₀(x¹⁰) = 
//│ 	case x¹⁰ of {
//│ 		C t⁴ => if [True] then f_₀(t⁴) else f_₀(g_₀(t⁴))}
//│ 	where
//│ 	def g_₀(t⁶) = 
//│ 		[C t⁶]
//│ def prodType_₀(x¹¹) = 
//│ 	case x¹¹ of {
//│ 		C t⁵ => if [True] then t⁵ else prodType_₀(t⁵)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ 2 :: Int ::: false
//│ (fun x -> 2) :: 'x⁰ => Int ::: true
//│ f_₀ :: 'f_₀ <: [] ::: true
//│ prodType_₀ :: 'prodType_₀ <: [] ::: true
//│ x :: 'x¹ <: [] ::: true
//│ prodType_₀(x) :: '6_callres <: [] ::: true
//│ f_₀(prodType_₀(x)) :: '7_callres <: [] ::: true
//│ (fun x -> f_₀(prodType_₀(x))) :: 'x¹ => '7_callres ::: true
//│ (fun x -> 2)((fun x -> f_₀(prodType_₀(x)))) :: '9_callres <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ [C t] :: C('t⁰) ::: true
//│ (fun t -> [C t]) :: 't⁰ => C('t⁰) ::: true
//│ x :: 'x² <: [] ::: true
//│ [True] :: True ::: true
//│ f_₀ :: 'f_₀ <: [] ::: true
//│ t :: 't¹ <: [] ::: true
//│ f_₀(t) :: '17_callres <: [] ::: true
//│ f_₀ :: 'f_₀ <: [] ::: true
//│ g_₀ :: 'g_₀ <: [] ::: true
//│ t :: 't¹ <: [] ::: true
//│ g_₀(t) :: '21_callres <: [] ::: true
//│ f_₀(g_₀(t)) :: '22_callres <: [] ::: true
//│ if [True] then f_₀(t) else f_₀(g_₀(t)) :: '23_ifres <: [] ::: true
//│ case x of {C t => if [True] then f_₀(t) else f_₀(g_₀(t))} :: '24_matchres <: [] ::: true
//│ (fun x -> case x of {C t => if [True] then f_₀(t) else f_₀(g_₀(t))}) :: 'x² => '24_matchres ::: true
//│ x :: 'x³ <: [] ::: true
//│ [True] :: True ::: true
//│ t :: 't² <: [] ::: true
//│ prodType_₀ :: 'prodType_₀ <: [] ::: true
//│ t :: 't² <: [] ::: true
//│ prodType_₀(t) :: '31_callres <: [] ::: true
//│ if [True] then t else prodType_₀(t) :: '32_ifres <: [] ::: true
//│ case x of {C t => if [True] then t else prodType_₀(t)} :: '33_matchres <: [] ::: true
//│ (fun x -> case x of {C t => if [True] then t else prodType_₀(t)}) :: 'x³ => '33_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec g__d0 t_0 =
//│   (`C(t_0));;
//│ let rec prodType__d0 x_3 =
//│   (match x_3 with
//│     | `C(t_2) -> 
//│       (if true then
//│         t_2
//│       else
//│         (prodType__d0 t_2)));;
//│ let rec f__d0 x_2 =
//│   (match x_2 with
//│     | `C(t_1) -> 
//│       (if true then
//│         (f__d0 t_1)
//│       else
//│         (f__d0 (g__d0 t_1))));;
//│ ((fun x_0 -> 
//│   2) (fun x_1 -> 
//│   (f__d0 (prodType__d0 x_1))))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│       - : int = 2
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
:d
:lhLessExpansion
fun break(ls) = if ls is
  N then P(N, N)
  C(h, t) then if h == 1 then P(N, C(h, t)) else if (break(t)) is
    P(fst, snd) then P(C(h, fst), snd)
fun line(ls) = if break(ls) is
  P(fst, snd) then
    C(
      fst,
      if snd is
        C(h, t) then line(t)
        N then N
    )
fun head(ls) = if ls is
  C(h, t) then h
  N then error
(head(line(primId(C(2,C(2,C(1,C(2,N))))))))
//│ |#fun| |break|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |P|(|N|,| |N|)|↵|C|(|h|,| |t|)| |#then| |#if| |h| |==| |1| |#then| |P|(|N|,| |C|(|h|,| |t|)|)| |#else| |#if| |(|break|(|t|)|)| |is|→|P|(|fst|,| |snd|)| |#then| |P|(|C|(|h|,| |fst|)|,| |snd|)|←|←|↵|#fun| |line|(|ls|)| |#=| |#if| |break|(|ls|)| |is|→|P|(|fst|,| |snd|)| |#then|→|C|(|→|fst|,|↵|#if| |snd| |is|→|C|(|h|,| |t|)| |#then| |line|(|t|)|↵|N| |#then| |N|←|←|↵|)|←|←|↵|#fun| |head|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |h|↵|N| |#then| |error|←|↵|(|head|(|line|(|primId|(|C|(|2|,|C|(|2|,|C|(|1|,|C|(|2|,|N|)|)|)|)|)|)|)|)|
//│ Parsed: {fun break = ls, => if ls is ‹(N) then P (N, N,); (C (h, t,)) then if (== (h,) (1,)) then P (N, C (h, t,),) else if '(' break (t,), ')' is ‹(P (fst, snd,)) then P (C (h, fst,), snd,)››; fun line = ls, => if break (ls,) is ‹(P (fst, snd,)) then {C (fst, if snd is ‹(C (h, t,)) then line (t,); (N) then N›,)}›; fun head = ls, => if ls is ‹(C (h, t,)) then h; (N) then error›; '(' head (line (primId (C (2, C (2, C (1, C (2, N,),),),),),),), ')'}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ head^45(line^46(primId⁰([C 2 [C 2 [C 1 [C 2 [N]]]]])))
//│ def break(ls⁰) = case ls⁰ of {
//│ 	N  => [P [N] [N]]
//│ 	| C h⁰ t⁰ => if (h⁰ == 1) then [P [N] [C h⁰ t⁰]] else case break^15(t⁰) of {
//│ 		P fst⁰ snd⁰ => [P [C h⁰ fst⁰] snd⁰]}}
//│ def head(ls²) = case ls² of {
//│ 	C h² t² => h²
//│ 	| N  => error⁰}
//│ def line(ls¹) = case break^27(ls¹) of {
//│ 	P fst¹ snd¹ => [C fst¹ case snd¹ of {
//│ 		C h¹ t¹ => line^32(t¹)
//│ 		| N  => [N]}]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec break ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`P((`N), (`N)))
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (h_0 = 1) then
//│ 		        (`P((`N), (`C(h_0, t_0))))
//│ 		      else
//│ 		        (match (break t_0) with
//│ 		          | `P(fst_0, snd_0) -> 
//│ 		            (`P((`C(h_0, fst_0)), snd_0)))));;
//│ 		let rec head ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `C(h_2, t_2) -> 
//│ 		      h_2
//│ 		    | `N -> 
//│ 		      (failwith "error"));;
//│ 		let rec line ls_1 =
//│ 		  (match (break ls_1) with
//│ 		    | `P(fst_1, snd_1) -> 
//│ 		      (`C(fst_1, (match snd_1 with
//│ 		        | `C(h_1, t_1) -> 
//│ 		          (line t_1)
//│ 		        | `N -> 
//│ 		          (`N)))));;
//│ 		(head (line (`C(2, (`C(2, (`C(1, (`C(2, (`N)))))))))))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		                    val break :
//│ 		  ([< `C of int * 'a | `N ] as 'a) ->
//│ 		  [ `P of ([> `C of int * 'b | `N ] as 'b) * [> `C of int * 'a | `N ] ] =
//│ 		  <fun>
//│ 		[ok]
//│ 		            val head : [< `C of 'a * 'b | `N ] -> 'a = <fun>
//│ 		[ok]
//│ 		                val line :
//│ 		  ([< `C of int * 'a | `N ] as 'a) ->
//│ 		  ([> `C of ([> `C of int * 'c | `N ] as 'c) * 'b | `N ] as 'b) = <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [head^45] (hopeless to continue)
//│ [line^46] (hopeless to continue)
//│ 	[line^46 · break^27] (using original def)
//│ 		[line^46 · break^27 · break^15] ---> [line^46 · break^27] (using original def)
//│ 	[line^46 · line^32] ---> [line^46] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ head_₀(line_₀(primId⁰([C 2 [C 2 [C 1 [C 2 [N]]]]])))
//│ def head_₀(ls⁵) = 
//│ 	case ls⁵ of {
//│ 		C h⁵ t⁵ => h⁵
//│ 		| N  => error⁰}
//│ def line_₀(ls⁴) = 
//│ 	case break_₀(ls⁴) of {
//│ 		P fst³ snd³ => [C fst³ case snd³ of {
//│ 			C h⁴ t⁴ => line_₀(t⁴)
//│ 			| N  => [N]}]}
//│ 	where
//│ 	def break_₀(ls³) = 
//│ 		case ls³ of {
//│ 			N  => [P [N] [N]]
//│ 			| C h³ t³ => if (h³ == 1) then [P [N] [C h³ t³]] else case break_₀(t³) of {
//│ 				P fst² snd² => [P [C h³ fst²] snd²]}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 62 --->
//│ 	case snd³ of {C h⁴ t⁴ => line_₀(t⁴) | N  => [N]}: 95
//│ [P [N] [N]]: 63 --->
//│ 	case break_₀(t³) of {P fst² snd² => [P [C h³ fst²] snd²]}: 82
//│ 	case break_₀(ls⁴) of {P fst³ snd³ => [C fst³ case snd³ of {C h⁴ t⁴ => line_₀(t⁴) | N  => [N]}]}: 97
//│ [C h³ t³]: 72 --->
//│ 	case snd³ of {C h⁴ t⁴ => line_₀(t⁴) | N  => [N]}: 95
//│ [P [N] [C h³ t³]]: 73 --->
//│ 	case break_₀(t³) of {P fst² snd² => [P [C h³ fst²] snd²]}: 82
//│ 	case break_₀(ls⁴) of {P fst³ snd³ => [C fst³ case snd³ of {C h⁴ t⁴ => line_₀(t⁴) | N  => [N]}]}: 97
//│ [P [C h³ fst²] snd²]: 81 --->
//│ 	case break_₀(t³) of {P fst² snd² => [P [C h³ fst²] snd²]}: 82
//│ 	case break_₀(ls⁴) of {P fst³ snd³ => [C fst³ case snd³ of {C h⁴ t⁴ => line_₀(t⁴) | N  => [N]}]}: 97
//│ [C fst³ case snd³ of {C h⁴ t⁴ => line_₀(t⁴) | N  => [N]}]: 96 --->
//│ 	DeadCodeCons
//│ 	case ls⁵ of {C h⁵ t⁵ => h⁵ | N  => error⁰}: 102
//│ ------------------
//│ case break_₀(t³) of {P fst² snd² => [P [C h³ fst²] snd²]}: 82 --->
//│ 	[P [N] [N]]: 63
//│ 	[P [N] [C h³ t³]]: 73
//│ 	[P [C h³ fst²] snd²]: 81
//│ case snd³ of {C h⁴ t⁴ => line_₀(t⁴) | N  => [N]}: 95 --->
//│ 	[N]: 62
//│ 	[C h³ t³]: 72
//│ case break_₀(ls⁴) of {P fst³ snd³ => [C fst³ case snd³ of {C h⁴ t⁴ => line_₀(t⁴) | N  => [N]}]}: 97 --->
//│ 	[P [N] [N]]: 63
//│ 	[P [N] [C h³ t³]]: 73
//│ 	[P [C h³ fst²] snd²]: 81
//│ case ls⁵ of {C h⁵ t⁵ => h⁵ | N  => error⁰}: 102 --->
//│ 	[C fst³ case snd³ of {C h⁴ t⁴ => line_₀(t⁴) | N  => [N]}]: 96
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 62 --->
//│ 	case snd³ of {C h⁴ t⁴ => line_₀(t⁴) | N  => [N]}: 95
//│ [C h³ t³]: 72 --->
//│ 	case snd³ of {C h⁴ t⁴ => line_₀(t⁴) | N  => [N]}: 95
//│ ------------------
//│ case snd³ of {C h⁴ t⁴ => line_₀(t⁴) | N  => [N]}: 95 --->
//│ 	[N]: 62
//│ 	[C h³ t³]: 72
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ head_₀(line_₀(primId⁰([C 2 [C 2 [C 1 [C 2 [N]]]]])))
//│ def head_₀(ls⁸) = 
//│ 	case ls⁸ of {
//│ 		C h⁵ t⁵ => h⁵
//│ 		| N  => error⁰}
//│ def line_₀(ls⁷) = 
//│ 	case break_₀(ls⁷) of {
//│ 		P fst³ snd³ => [C fst³ snd³(99)]}
//│ 	where
//│ 	def break_₀(ls⁶) = 
//│ 		case ls⁶ of {
//│ 			N  => [P [N] (fun _lh_dummy⁰ -> [N])]
//│ 			| C h³ t³ => if (h³ == 1) then [P [N] 
//│ 				let t⁶ = t³
//│ 				in (fun _lh_dummy¹ -> line_₀(t⁶))] else case break_₀(t³) of {
//│ 				P fst² snd² => [P [C h³ fst²] snd²]}}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ head_₀ :: 'head_₀ <: ['14_callres => '15_callres] ::: false
//│ line_₀ :: 'line_₀ <: ['13_callres => '14_callres | 't¹ => '30_callres] ::: false
//│ primId :: NoProd ::: true
//│ 2 :: Int ::: false
//│ 2 :: Int ::: false
//│ 1 :: Int ::: false
//│ 2 :: Int ::: false
//│ [N] :: N ::: true
//│ [C 2 [N]] :: C(Int, N) ::: true
//│ [C 1 [C 2 [N]]] :: C(Int, C(Int, N)) ::: true
//│ [C 2 [C 1 [C 2 [N]]]] :: C(Int, C(Int, C(Int, N))) ::: true
//│ [C 2 [C 2 [C 1 [C 2 [N]]]]] :: C(Int, C(Int, C(Int, C(Int, N)))) ::: true
//│ primId([C 2 [C 2 [C 1 [C 2 [N]]]]]) :: '13_callres <: ['ls¹] ::: false
//│ line_₀(primId([C 2 [C 2 [C 1 [C 2 [N]]]]])) :: '14_callres <: ['ls²] ::: false
//│ head_₀(line_₀(primId([C 2 [C 2 [C 1 [C 2 [N]]]]]))) :: '15_callres <: [NoCons] ::: false
//│ ls :: 'ls⁰ <: [Destruct(N, C('h⁰, 't⁰))] ::: false
//│ [N] :: N ::: true
//│ [N] :: N ::: true
//│ (fun _lh_dummy -> [N]) :: '_lh_dummy⁰ => N ::: true
//│ [P [N] (fun _lh_dummy -> [N])] :: P(N, '_lh_dummy⁰ => N) ::: true
//│ == :: Destruct(Int) => Destruct(Int) => Sum[True, False] ::: true
//│ h :: 'h⁰ <: [DeadCodeCons | NoCons | Destruct(Int)] ::: false
//│ ==(h) :: '23_callres <: [Int => '25_callres] ::: false
//│ 1 :: Int ::: false
//│ (h == 1) :: '25_callres <: [Destruct(True, False)] ::: false
//│ [N] :: N ::: true
//│ t :: 't⁰ <: ['t¹ | 'ls⁰] ::: false
//│ line_₀ :: 'line_₀ <: ['13_callres => '14_callres | 't¹ => '30_callres] ::: false
//│ t :: 't¹ <: ['ls¹] ::: false
//│ line_₀(t) :: '30_callres <: ['52_callres] ::: true
//│ (fun _lh_dummy -> line_₀(t)) :: '_lh_dummy¹ => '30_callres ::: true
//│ let t = t
//│ in (fun _lh_dummy -> line_₀(t)) :: '_lh_dummy¹ => '30_callres ::: true
//│ [P [N] let t = t
//│ in (fun _lh_dummy -> line_₀(t))] :: P(N, '_lh_dummy¹ => '30_callres) ::: true
//│ break_₀ :: 'break_₀ <: ['t⁰ => '36_callres | 'ls¹ => '48_callres] ::: false
//│ t :: 't⁰ <: ['t¹ | 'ls⁰] ::: false
//│ break_₀(t) :: '36_callres <: [Destruct(P('fst⁰, 'snd⁰))] ::: false
//│ h :: 'h⁰ <: [DeadCodeCons | NoCons | Destruct(Int)] ::: false
//│ fst :: 'fst⁰ <: [DeadCodeCons | NoCons] ::: false
//│ [C h fst] :: C('h⁰, 'fst⁰) ::: true
//│ snd :: 'snd⁰ <: ['snd¹] ::: false
//│ [P [C h fst] snd] :: P(C('h⁰, 'fst⁰), 'snd⁰) ::: true
//│ case break_₀(t) of {P fst snd => [P [C h fst] snd]} :: '42_matchres <: ['43_ifres] ::: false
//│ if (h == 1) then [P [N] let t = t
//│ in (fun _lh_dummy -> line_₀(t))] else case break_₀(t) of {P fst snd => [P [C h fst] snd]} :: '43_ifres <: ['44_matchres] ::: false
//│ case ls of {N  => [P [N] (fun _lh_dummy -> [N])] | C h t => if (h == 1) then [P [N] let t = t
//│ in (fun _lh_dummy -> line_₀(t))] else case break_₀(t) of {P fst snd => [P [C h fst] snd]}} :: '44_matchres <: ['36_callres | '48_callres] ::: false
//│ (fun ls -> case ls of {N  => [P [N] (fun _lh_dummy -> [N])] | C h t => if (h == 1) then [P [N] let t = t
//│ in (fun _lh_dummy -> line_₀(t))] else case break_₀(t) of {P fst snd => [P [C h fst] snd]}}) :: 'ls⁰ => '44_matchres ::: true
//│ break_₀ :: 'break_₀ <: ['t⁰ => '36_callres | 'ls¹ => '48_callres] ::: false
//│ ls :: 'ls¹ <: ['ls⁰] ::: false
//│ break_₀(ls) :: '48_callres <: [Destruct(P('fst¹, 'snd¹))] ::: false
//│ fst :: 'fst¹ <: [DeadCodeCons | 'h¹] ::: false
//│ snd :: 'snd¹ <: [Int => '52_callres] ::: false
//│ 99 :: Int ::: false
//│ snd(99) :: '52_callres <: [DeadCodeCons | 't²] ::: true
//│ [C fst snd(99)] :: C('fst¹, '52_callres) ::: true
//│ case break_₀(ls) of {P fst snd => [C fst snd(99)]} :: '54_matchres <: ['14_callres | '30_callres] ::: false
//│ (fun ls -> case break_₀(ls) of {P fst snd => [C fst snd(99)]}) :: 'ls¹ => '54_matchres ::: true
//│ ls :: 'ls² <: [Destruct(C('h¹, 't²), N)] ::: false
//│ h :: 'h¹ <: ['59_matchres] ::: false
//│ error :: '_lh_rigid_error_var <: [DeadCodeCons] ::: true
//│ case ls of {C h t => h | N  => error} :: '59_matchres <: ['15_callres] ::: false
//│ (fun ls -> case ls of {C h t => h | N  => error}) :: 'ls² => '59_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec break__d0 ls_0 =
//│   (match ls_0 with
//│     | `N -> 
//│       (`P((`N), (fun _lh_dummy_0 -> 
//│         (`N))))
//│     | `C(h_0, t_0) -> 
//│       (if (h_0 = 1) then
//│         (`P((`N), (let rec t_1 = t_0 in
//│           (fun _lh_dummy_1 -> 
//│             (line__d0 t_1)))))
//│       else
//│         (match (break__d0 t_0) with
//│           | `P(fst_0, snd_0) -> 
//│             (`P((`C(h_0, fst_0)), snd_0)))))
//│ and
//│ line__d0 ls_1 =
//│   (match (break__d0 ls_1) with
//│     | `P(fst_1, snd_1) -> 
//│       (`C(fst_1, (snd_1 99))));;
//│ let rec head__d0 ls_2 =
//│   (match ls_2 with
//│     | `C(h_1, t_2) -> 
//│       h_1
//│     | `N -> 
//│       (failwith "error"));;
//│ (head__d0 (line__d0 (`C(2, (`C(2, (`C(1, (`C(2, (`N)))))))))))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│   - : [> `C of int * 'a | `N ] as 'a = `C (2, `C (2, `N))
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
