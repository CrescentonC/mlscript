:NewParser
:ParseOnly



// CORRECT:
let p = C(1, C(2, N))
fun e(z) = if z is
  C(aaa, bbb) then bbb
  N then 7
fun d(y) = if y is
  C(aa, bb) then e(bb)
  N then 5
fun c(x) = if x is
  C(a, b) then d(b)
  N then 3
c(p)
//│ |#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#fun| |e|(|z|)| |#=| |#if| |z| |is|→|C|(|aaa|,| |bbb|)| |#then| |bbb|↵|N| |#then| |7|←|↵|#fun| |d|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|,| |bb|)| |#then| |e|(|bb|)|↵|N| |#then| |5|←|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|,| |b|)| |#then| |d|(|b|)|↵|N| |#then| |3|←|↵|c|(|p|)|
//│ Parsed: {let p = C (1, C (2, N,),); fun e = z, => if z is ‹(C (aaa, bbb,)) then bbb; (N) then 7›; fun d = y, => if y is ‹(C (aa, bb,)) then e (bb,); (N) then 5›; fun c = x, => if x is ‹(C (a, b,)) then d (b,); (N) then 3›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^25(p^26)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ b⁰ => d^19(b⁰)
//│ 	| N  => 3}
//│ def d(y⁰) = case y⁰ of {
//│ 	C aa⁰ bb⁰ => e^12(bb⁰)
//│ 	| N  => 5}
//│ def e(z⁰) = case z⁰ of {
//│ 	C aaa⁰ bbb⁰ => bbb⁰
//│ 	| N  => 7}
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 3 --->
//│ 	case z⁰ of {C aaa⁰ bbb⁰ => bbb⁰ | N  => 7}: 9
//│ [C 2 [N]]: 4 --->
//│ 	case y⁰ of {C aa⁰ bb⁰ => e(bb⁰) | N  => 5}: 16
//│ [C 1 [C 2 [N]]]: 5 --->
//│ 	case x⁰ of {C a⁰ b⁰ => d(b⁰) | N  => 3}: 23
//│ ------------------
//│ case z⁰ of {C aaa⁰ bbb⁰ => bbb⁰ | N  => 7}: 9 --->
//│ 	[N]: 3
//│ case y⁰ of {C aa⁰ bb⁰ => e(bb⁰) | N  => 5}: 16 --->
//│ 	[C 2 [N]]: 4
//│ case x⁰ of {C a⁰ b⁰ => d(b⁰) | N  => 3}: 23 --->
//│ 	[C 1 [C 2 [N]]]: 5
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 3 --->
//│ 	case z⁰ of {C aaa⁰ bbb⁰ => bbb⁰ | N  => 7}: 9
//│ [C 2 [N]]: 4 --->
//│ 	case y⁰ of {C aa⁰ bb⁰ => e(bb⁰) | N  => 5}: 16
//│ [C 1 [C 2 [N]]]: 5 --->
//│ 	case x⁰ of {C a⁰ b⁰ => d(b⁰) | N  => 3}: 23
//│ ------------------
//│ case z⁰ of {C aaa⁰ bbb⁰ => bbb⁰ | N  => 7}: 9 --->
//│ 	[N]: 3
//│ case y⁰ of {C aa⁰ bb⁰ => e(bb⁰) | N  => 5}: 16 --->
//│ 	[C 2 [N]]: 4
//│ case x⁰ of {C a⁰ b⁰ => d(b⁰) | N  => 3}: 23 --->
//│ 	[C 1 [C 2 [N]]]: 5
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(p)
//│ def c(x¹) = x¹(99)
//│ def d(y¹) = y¹(99)
//│ def e(z¹) = z¹
//│ def p = 
//│ 	let b¹ = 	
//│ 		let bb¹ = 7
//│ 		in let aa¹ = 2
//│ 		in (fun _lh_dummy¹ -> e(bb¹))
//│ 	in let a¹ = 1
//│ 	in (fun _lh_dummy⁰ -> d(b¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ e, c, d
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ p -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ p(99)
//│ def c(x⁰) = x⁰(99)
//│ def d(y⁰) = y⁰(99)
//│ def e(z⁰) = z⁰
//│ def p = 
//│ 	let b⁰ = 	
//│ 		let bb⁰ = 7
//│ 		in let aa⁰ = 2
//│ 		in (fun _lh_dummy⁰ -> bb⁰)
//│ 	in let a⁰ = 1
//│ 	in (fun _lh_dummy¹ -> b⁰(99))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ p(99)
//│ def c(x⁰) = x⁰(99)
//│ def d(y⁰) = y⁰(99)
//│ def e(z⁰) = z⁰
//│ def p(_lh_dummy⁰) = 
//│ 	let b⁰ = 	
//│ 		let bb⁰ = 7
//│ 		in let aa⁰ = 2
//│ 		in (fun _lh_dummy¹ -> bb⁰)
//│ 	in let a⁰ = 1
//│ 	in b⁰(99)
//│ <<<<<<< after floating out <<<<<<<



// CORRECT:
fun sum(ls) = if ls is
  C(h, t) then S(N, sum(t))
fun mapa(lsa) = if lsa is
  C(ha, ta) then C(primitive(ha), mapa(ta))
fun mapb(lsb) = if lsb is
  C(hb, tb) then C(primitive(hb), mapb(tb))
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),)›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),)›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),)›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ sum^29(mapa^30(mapb^31(primitive⁰)))
//│ def mapa(lsa⁰) = case lsa⁰ of {
//│ 	C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa^13(ta⁰)]}
//│ def mapb(lsb⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => [C primitive⁰(hb⁰) mapb^23(tb⁰)]}
//│ def sum(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [S [N] sum^3(t⁰)]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰(ha⁰) mapa(ta⁰)]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)]}: 7
//│ [C primitive⁰(hb⁰) mapb(tb⁰)]: 26 --->
//│ 	case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)]}: 17
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)]}: 7 --->
//│ 	[C primitive⁰(ha⁰) mapa(ta⁰)]: 16
//│ case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)]}: 17 --->
//│ 	[C primitive⁰(hb⁰) mapb(tb⁰)]: 26
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C primitive⁰(ha⁰) mapa(ta⁰)]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)]}: 7
//│ [C primitive⁰(hb⁰) mapb(tb⁰)]: 26 --->
//│ 	case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)]}: 17
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)]}: 7 --->
//│ 	[C primitive⁰(ha⁰) mapa(ta⁰)]: 16
//│ case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)]}: 17 --->
//│ 	[C primitive⁰(hb⁰) mapb(tb⁰)]: 26
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ sum(mapa(mapb(primitive⁰)))
//│ def mapa(lsa¹) = lsa¹(99)
//│ def mapb(lsb¹) = case lsb¹ of {
//│ 	C hb⁰ tb⁰ => 
//│ 		let ta¹ = mapb(tb⁰)
//│ 		in let ha¹ = primitive⁰(hb⁰)
//│ 		in (fun _lh_dummy¹ -> 
//│ 			let t¹ = mapa(ta¹)
//│ 			in let h¹ = primitive⁰(ha¹)
//│ 			in (fun _lh_dummy⁰ -> [S [N] sum(t¹)]))}
//│ def sum(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ sum, mapa
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ mapb -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ mapb(primitive⁰, 99, 99)
//│ def mapa(lsa⁰) = lsa⁰(99)
//│ def mapb(lsb⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => 
//│ 		let ta⁰ = mapb(tb⁰)
//│ 		in let ha⁰ = primitive⁰(hb⁰)
//│ 		in (fun _lh_dummy⁰ -> 
//│ 			let t⁰ = ta⁰(99)
//│ 			in let h⁰ = primitive⁰(ha⁰)
//│ 			in (fun _lh_dummy¹ -> [S [N] t⁰(99)]))}
//│ def sum(ls⁰) = ls⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ mapb(primitive⁰, 99, 99)
//│ def mapa(lsa⁰) = lsa⁰(99)
//│ def mapb(lsb⁰, _lh_popOutId_0⁰, _lh_popOutId_1⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => 
//│ 		let ta⁰ = mapb(tb⁰)
//│ 		in let ha⁰ = primitive⁰(hb⁰)
//│ 		in let t⁰ = ta⁰(99)
//│ 		in let h⁰ = primitive⁰(ha⁰)
//│ 		in [S [N] t⁰(99)]}
//│ def sum(ls⁰) = ls⁰(99)
//│ <<<<<<< after floating out <<<<<<<

// CORRECT:
if C(A, B(C)) is
  C(a, b) then D(b)
//│ |#if| |C|(|A|,| |B|(|C|)|)| |is|→|C|(|a|,| |b|)| |#then| |D|(|b|)|←|
//│ Parsed: {if C (A, B (C,),) is ‹(C (a, b,)) then D (b,)›}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a⁰ b⁰ => [D b⁰]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A] [B [C]]]: 4 --->
//│ 	case [C [A] [B [C]]] of {C a⁰ b⁰ => [D b⁰]}: 7
//│ ------------------
//│ case [C [A] [B [C]]] of {C a⁰ b⁰ => [D b⁰]}: 7 --->
//│ 	[C [A] [B [C]]]: 4
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [A] [B [C]]]: 4 --->
//│ 	case [C [A] [B [C]]] of {C a⁰ b⁰ => [D b⁰]}: 7
//│ ------------------
//│ case [C [A] [B [C]]] of {C a⁰ b⁰ => [D b⁰]}: 7 --->
//│ 	[C [A] [B [C]]]: 4
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ let b¹ = [B [C]]
//│ in let a¹ = [A]
//│ in [D b¹]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ let b⁰ = [B [C]]
//│ in let a⁰ = [A]
//│ in [D b⁰]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ let b⁰ = [B [C]]
//│ in let a⁰ = [A]
//│ in [D b⁰]
//│ <<<<<<< after floating out <<<<<<<
//│




// def p:6^18 =
//      ... p:6^1 ~> p:6^18.p:6^1 ...

// def p:6^18.p:6^1 =
//      ... p:6^1 ~> p:6^18 ...

// def ca:7^17
//      ... 



// CORRECT: every element is handled
fun ff(x) = if x is
  K then T
  KK then TT
  KKKK then TTTT
fun map(ls) = if ls is
  C(h, t) then C(ff(h), map(t))
  N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|ff|(|h|)|,| |map|(|t|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; fun map = ls, => if ls is ‹(C (h, t,)) then C (ff (h,), map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^25(l^26)
//│ def ff(x⁰) = case x⁰ of {
//│ 	K  => [T]
//│ 	| KK  => [TT]
//│ 	| KKKK  => [TTTT]}
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C ff^8(h⁰) map^11(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 18 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 5
//│ [KK]: 19 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 5
//│ [KKKK]: 20 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 5
//│ [N]: 21 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C ff(h⁰) map(t⁰)] | N  => [N]}: 16
//│ [C [KKKK] [N]]: 22 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C ff(h⁰) map(t⁰)] | N  => [N]}: 16
//│ [C [KK] [C [KKKK] [N]]]: 23 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C ff(h⁰) map(t⁰)] | N  => [N]}: 16
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 24 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C ff(h⁰) map(t⁰)] | N  => [N]}: 16
//│ ------------------
//│ case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 5 --->
//│ 	[K]: 18
//│ 	[KK]: 19
//│ 	[KKKK]: 20
//│ case ls⁰ of {C h⁰ t⁰ => [C ff(h⁰) map(t⁰)] | N  => [N]}: 16 --->
//│ 	[N]: 21
//│ 	[C [KKKK] [N]]: 22
//│ 	[C [KK] [C [KKKK] [N]]]: 23
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 24
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 18 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 5
//│ [KK]: 19 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 5
//│ [KKKK]: 20 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 5
//│ [N]: 21 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C ff(h⁰) map(t⁰)] | N  => [N]}: 16
//│ [C [KKKK] [N]]: 22 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C ff(h⁰) map(t⁰)] | N  => [N]}: 16
//│ [C [KK] [C [KKKK] [N]]]: 23 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C ff(h⁰) map(t⁰)] | N  => [N]}: 16
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 24 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C ff(h⁰) map(t⁰)] | N  => [N]}: 16
//│ ------------------
//│ case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 5 --->
//│ 	[K]: 18
//│ 	[KK]: 19
//│ 	[KKKK]: 20
//│ case ls⁰ of {C h⁰ t⁰ => [C ff(h⁰) map(t⁰)] | N  => [N]}: 16 --->
//│ 	[N]: 21
//│ 	[C [KKKK] [N]]: 22
//│ 	[C [KK] [C [KKKK] [N]]]: 23
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 24
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(l)
//│ def ff(x¹) = x¹
//│ def l = 
//│ 	let t¹ = 	
//│ 		let t² = 	
//│ 			let t³ = (fun _lh_dummy³ -> [N])
//│ 			in let h³ = [TTTT]
//│ 			in (fun _lh_dummy² -> [C ff(h³) map(t³)])
//│ 		in let h² = [TT]
//│ 		in (fun _lh_dummy¹ -> [C ff(h²) map(t²)])
//│ 	in let h¹ = [T]
//│ 	in (fun _lh_dummy⁰ -> [C ff(h¹) map(t¹)])
//│ def map(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map, ff
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ l -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ l(99)
//│ def ff(x⁰) = x⁰
//│ def l = 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun _lh_dummy⁰ -> [N])
//│ 			in let h⁰ = [TTTT]
//│ 			in (fun _lh_dummy¹ -> [C h⁰ t²(99)])
//│ 		in let h¹ = [TT]
//│ 		in (fun _lh_dummy² -> [C h¹ t¹(99)])
//│ 	in let h² = [T]
//│ 	in (fun _lh_dummy³ -> [C h² t⁰(99)])
//│ def map(ls⁰) = ls⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ l(99)
//│ def ff(x⁰) = x⁰
//│ def l(_lh_dummy⁰) = 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun _lh_dummy¹ -> [N])
//│ 			in let h⁰ = [TTTT]
//│ 			in (fun _lh_dummy² -> [C h⁰ t²(99)])
//│ 		in let h¹ = [TT]
//│ 		in (fun _lh_dummy³ -> [C h¹ t¹(99)])
//│ 	in let h² = [T]
//│ 	in [C h² t⁰(99)]
//│ def map(ls⁰) = ls⁰(99)
//│ <<<<<<< after floating out <<<<<<<


// CORRECT: every element is handled
fun map(ls) = if ls is
  C(h, t) then C(
    (if h is
      K then T
      KK then TT
      KKKK then TTTT
    ),
    map(t)
  )
  N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›, ')', map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^21(l^22)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C case h⁰ of {
//│ 		K  => [T]
//│ 		| KK  => [TT]
//│ 		| KKKK  => [TTTT]} map^7(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 14 --->
//│ 	case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6
//│ [KK]: 15 --->
//│ 	case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6
//│ [KKKK]: 16 --->
//│ 	case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6
//│ [N]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ [C [KKKK] [N]]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ [C [KK] [C [KKKK] [N]]]: 19 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 20 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ ------------------
//│ case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6 --->
//│ 	[K]: 14
//│ 	[KK]: 15
//│ 	[KKKK]: 16
//│ case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 17
//│ 	[C [KKKK] [N]]: 18
//│ 	[C [KK] [C [KKKK] [N]]]: 19
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 14 --->
//│ 	case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6
//│ [KK]: 15 --->
//│ 	case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6
//│ [KKKK]: 16 --->
//│ 	case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6
//│ [N]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ [C [KKKK] [N]]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ [C [KK] [C [KKKK] [N]]]: 19 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 20 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ ------------------
//│ case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6 --->
//│ 	[K]: 14
//│ 	[KK]: 15
//│ 	[KKKK]: 16
//│ case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 17
//│ 	[C [KKKK] [N]]: 18
//│ 	[C [KK] [C [KKKK] [N]]]: 19
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 20
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(l)
//│ def l = 
//│ 	let t¹ = 	
//│ 		let t² = 	
//│ 			let t³ = (fun _lh_dummy³ -> [N])
//│ 			in let h³ = [TTTT]
//│ 			in (fun _lh_dummy² -> [C h³ map(t³)])
//│ 		in let h² = [TT]
//│ 		in (fun _lh_dummy¹ -> [C h² map(t²)])
//│ 	in let h¹ = [T]
//│ 	in (fun _lh_dummy⁰ -> [C h¹ map(t¹)])
//│ def map(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ l -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ l(99)
//│ def l = 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun _lh_dummy⁰ -> [N])
//│ 			in let h⁰ = [TTTT]
//│ 			in (fun _lh_dummy¹ -> [C h⁰ t²(99)])
//│ 		in let h¹ = [TT]
//│ 		in (fun _lh_dummy² -> [C h¹ t¹(99)])
//│ 	in let h² = [T]
//│ 	in (fun _lh_dummy³ -> [C h² t⁰(99)])
//│ def map(ls⁰) = ls⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ l(99)
//│ def l(_lh_dummy⁰) = 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun _lh_dummy¹ -> [N])
//│ 			in let h⁰ = [TTTT]
//│ 			in (fun _lh_dummy² -> [C h⁰ t²(99)])
//│ 		in let h¹ = [TT]
//│ 		in (fun _lh_dummy³ -> [C h¹ t¹(99)])
//│ 	in let h² = [T]
//│ 	in [C h² t⁰(99)]
//│ def map(ls⁰) = ls⁰(99)
//│ <<<<<<< after floating out <<<<<<<

// CORRECT:
fun sum(ls) = if ls is
  C(h, t) then S(N, sum(t))
  N then N
fun mapa(lsa) = if lsa is
  C(ha, ta) then C(primitive(ha), mapa(ta))
  N then N
fun mapb(lsb) = if lsb is
  C(hb, tb) then C(primitive(hb), mapb(tb))
  N then N
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|↵|N| |#then| |N|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|↵|N| |#then| |N|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),); (N) then N›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),); (N) then N›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),); (N) then N›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ sum^32(mapa^33(mapb^34(primitive⁰)))
//│ def mapa(lsa⁰) = case lsa⁰ of {
//│ 	C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa^14(ta⁰)]
//│ 	| N  => [N]}
//│ def mapb(lsb⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => [C primitive⁰(hb⁰) mapb^25(tb⁰)]
//│ 	| N  => [N]}
//│ def sum(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [S [N] sum^3(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰(ha⁰) mapa(ta⁰)]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)] | N  => [N]}: 8
//│ [N]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)] | N  => [N]}: 8
//│ [C primitive⁰(hb⁰) mapb(tb⁰)]: 28 --->
//│ 	case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)] | N  => [N]}: 19
//│ [N]: 29 --->
//│ 	case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)] | N  => [N]}: 19
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)] | N  => [N]}: 8 --->
//│ 	[C primitive⁰(ha⁰) mapa(ta⁰)]: 17
//│ 	[N]: 18
//│ case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)] | N  => [N]}: 19 --->
//│ 	[C primitive⁰(hb⁰) mapb(tb⁰)]: 28
//│ 	[N]: 29
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C primitive⁰(ha⁰) mapa(ta⁰)]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)] | N  => [N]}: 8
//│ [N]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)] | N  => [N]}: 8
//│ [C primitive⁰(hb⁰) mapb(tb⁰)]: 28 --->
//│ 	case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)] | N  => [N]}: 19
//│ [N]: 29 --->
//│ 	case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)] | N  => [N]}: 19
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)] | N  => [N]}: 8 --->
//│ 	[C primitive⁰(ha⁰) mapa(ta⁰)]: 17
//│ 	[N]: 18
//│ case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)] | N  => [N]}: 19 --->
//│ 	[C primitive⁰(hb⁰) mapb(tb⁰)]: 28
//│ 	[N]: 29
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ sum(mapa(mapb(primitive⁰)))
//│ def mapa(lsa¹) = lsa¹(99)
//│ def mapb(lsb¹) = case lsb¹ of {
//│ 	C hb⁰ tb⁰ => 
//│ 		let ta¹ = mapb(tb⁰)
//│ 		in let ha¹ = primitive⁰(hb⁰)
//│ 		in (fun _lh_dummy¹ -> 
//│ 			let t¹ = mapa(ta¹)
//│ 			in let h¹ = primitive⁰(ha¹)
//│ 			in (fun _lh_dummy⁰ -> [S [N] sum(t¹)]))
//│ 	| N  => (fun _lh_dummy³ -> (fun _lh_dummy² -> [N]))}
//│ def sum(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ sum, mapa
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ mapb -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ mapb(primitive⁰, 99, 99)
//│ def mapa(lsa⁰) = lsa⁰(99)
//│ def mapb(lsb⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => 
//│ 		let ta⁰ = mapb(tb⁰)
//│ 		in let ha⁰ = primitive⁰(hb⁰)
//│ 		in (fun _lh_dummy⁰ -> 
//│ 			let t⁰ = ta⁰(99)
//│ 			in let h⁰ = primitive⁰(ha⁰)
//│ 			in (fun _lh_dummy¹ -> [S [N] t⁰(99)]))
//│ 	| N  => (fun _lh_dummy² -> (fun _lh_dummy³ -> [N]))}
//│ def sum(ls⁰) = ls⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ mapb(primitive⁰, 99, 99)
//│ def mapa(lsa⁰) = lsa⁰(99)
//│ def mapb(lsb⁰, _lh_popOutId_0⁰, _lh_popOutId_1⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => 
//│ 		let ta⁰ = mapb(tb⁰)
//│ 		in let ha⁰ = primitive⁰(hb⁰)
//│ 		in let t⁰ = ta⁰(99)
//│ 		in let h⁰ = primitive⁰(ha⁰)
//│ 		in [S [N] t⁰(99)]
//│ 	| N  => [N]}
//│ def sum(ls⁰) = ls⁰(99)
//│ <<<<<<< after floating out <<<<<<<




// CORRECT:
let p = C(N)
fun c(x) = if C(x) is
  C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|N|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (N,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^10(p^11)
//│ def c(x⁰) = case [C x⁰] of {
//│ 	C a⁰ => c^5(a⁰)}
//│ def p = [C [N]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x⁰]: 4 --->
//│ 	case [C x⁰] of {C a⁰ => c(a⁰)}: 8
//│ ------------------
//│ case [C x⁰] of {C a⁰ => c(a⁰)}: 8 --->
//│ 	[C x⁰]: 4
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C x⁰]: 4 --->
//│ 	case [C x⁰] of {C a⁰ => c(a⁰)}: 8
//│ ------------------
//│ case [C x⁰] of {C a⁰ => c(a⁰)}: 8 --->
//│ 	[C x⁰]: 4
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(p)
//│ def c(x¹) = 
//│ 	let a¹ = x¹
//│ 	in (fun _lh_dummy⁰ -> c(a¹))(99)
//│ def p = [C [N]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ recursive consumer: c
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ c(p)
//│ def c(x⁰) = 
//│ 	let a⁰ = x⁰
//│ 	in (fun _lh_dummy⁰ -> c(a⁰))(99)
//│ def p = [C [N]]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ c(p)
//│ def c(x⁰) = 
//│ 	let a⁰ = x⁰
//│ 	in (fun _lh_dummy⁰ -> c(a⁰))(99)
//│ def p = [C [N]]
//│ <<<<<<< after floating out <<<<<<<


// let rec p = C(p)
// let q = p
// fun c(x) = if x is
//     C(a) then a
// fun c2(z) = if z is
//     C(b) then c2(b)
// let main = c(q)
// c2(main)



// CORRECT:
_LUMBERHACK_EVAL
let t = T(K, T(N, L, L), T(N, L, L))
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |_LUMBERHACK_EVAL|↵|#let| |t| |#=| |T|(|K|,| |T|(|N|,| |L|,| |L|)|,| |T|(|N|,| |L|,| |L|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {_LUMBERHACK_EVAL; let t = T (K, T (N, L, L,), T (N, L, L,),); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^26(t^27)
//│ def c(x⁰) = case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K  => [KK]
//│ 		| N  => [NN]} c^16(l⁰) c^19(r⁰)]
//│ 	| L  => [LL]}
//│ def t = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 1 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 15
//│ [N]: 2 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 15
//│ [L]: 3 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24
//│ [L]: 4 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24
//│ [T [N] [L] [L]]: 5 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24
//│ [N]: 6 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 15
//│ [L]: 7 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24
//│ [L]: 8 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24
//│ [T [N] [L] [L]]: 9 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24
//│ [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 10 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24
//│ ------------------
//│ case n⁰ of {K  => [KK] | N  => [NN]}: 15 --->
//│ 	[K]: 1
//│ 	[N]: 2
//│ 	[N]: 6
//│ case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24 --->
//│ 	[L]: 3
//│ 	[L]: 4
//│ 	[T [N] [L] [L]]: 5
//│ 	[L]: 7
//│ 	[L]: 8
//│ 	[T [N] [L] [L]]: 9
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 10
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 1 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 15
//│ [N]: 2 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 15
//│ [L]: 3 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24
//│ [L]: 4 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24
//│ [T [N] [L] [L]]: 5 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24
//│ [N]: 6 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 15
//│ [L]: 7 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24
//│ [L]: 8 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24
//│ [T [N] [L] [L]]: 9 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24
//│ [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 10 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24
//│ ------------------
//│ case n⁰ of {K  => [KK] | N  => [NN]}: 15 --->
//│ 	[K]: 1
//│ 	[N]: 2
//│ 	[N]: 6
//│ case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 24 --->
//│ 	[L]: 3
//│ 	[L]: 4
//│ 	[T [N] [L] [L]]: 5
//│ 	[L]: 7
//│ 	[L]: 8
//│ 	[T [N] [L] [L]]: 9
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 10
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(t)
//│ def c(x¹) = x¹(99)
//│ def t = 
//│ 	let r¹ = 	
//│ 		let r³ = (fun _lh_dummy⁶ -> [LL])
//│ 		in let l³ = (fun _lh_dummy⁵ -> [LL])
//│ 		in let n³ = [NN]
//│ 		in (fun _lh_dummy⁴ -> [T n³ c(l³) c(r³)])
//│ 	in let l¹ = 	
//│ 		let r² = (fun _lh_dummy³ -> [LL])
//│ 		in let l² = (fun _lh_dummy² -> [LL])
//│ 		in let n² = [NN]
//│ 		in (fun _lh_dummy¹ -> [T n² c(l²) c(r²)])
//│ 	in let n¹ = [KK]
//│ 	in (fun _lh_dummy⁰ -> [T n¹ c(l¹) c(r¹)])
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ c
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ t -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ t(99)
//│ def c(x⁰) = x⁰(99)
//│ def t = 
//│ 	let r⁰ = 	
//│ 		let r¹ = (fun _lh_dummy⁰ -> [LL])
//│ 		in let l⁰ = (fun _lh_dummy¹ -> [LL])
//│ 		in let n⁰ = [NN]
//│ 		in (fun _lh_dummy² -> [T n⁰ l⁰(99) r¹(99)])
//│ 	in let l¹ = 	
//│ 		let r² = (fun _lh_dummy³ -> [LL])
//│ 		in let l² = (fun _lh_dummy⁴ -> [LL])
//│ 		in let n¹ = [NN]
//│ 		in (fun _lh_dummy⁵ -> [T n¹ l²(99) r²(99)])
//│ 	in let n² = [KK]
//│ 	in (fun _lh_dummy⁶ -> [T n² l¹(99) r⁰(99)])
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ t(99)
//│ def c(x⁰) = x⁰(99)
//│ def t(_lh_dummy⁰) = 
//│ 	let r⁰ = 	
//│ 		let r¹ = (fun _lh_dummy¹ -> [LL])
//│ 		in let l⁰ = (fun _lh_dummy² -> [LL])
//│ 		in let n⁰ = [NN]
//│ 		in (fun _lh_dummy³ -> [T n⁰ l⁰(99) r¹(99)])
//│ 	in let l¹ = 	
//│ 		let r² = (fun _lh_dummy⁴ -> [LL])
//│ 		in let l² = (fun _lh_dummy⁵ -> [LL])
//│ 		in let n¹ = [NN]
//│ 		in (fun _lh_dummy⁶ -> [T n¹ l²(99) r²(99)])
//│ 	in let n² = [KK]
//│ 	in [T n² l¹(99) r⁰(99)]
//│ <<<<<<< after floating out <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |_LUMBERHACK_EVAL|↵|#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {_LUMBERHACK_EVAL; let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^28(t^29)
//│ def aa = [T [N] [L] [L]]
//│ def bb = [T [N] [L] [L]]
//│ def c(x⁰) = case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K  => [KK]
//│ 		| N  => [NN]} c^18(l⁰) c^21(r⁰)]
//│ 	| L  => [LL]}
//│ def t = [T [K] aa^10 bb^11]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 1 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 17
//│ [L]: 2 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [L]: 3 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [T [N] [L] [L]]: 4 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [N]: 5 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 17
//│ [L]: 6 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [L]: 7 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [T [N] [L] [L]]: 8 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [K]: 9 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 17
//│ [T [K] aa bb]: 12 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ ------------------
//│ case n⁰ of {K  => [KK] | N  => [NN]}: 17 --->
//│ 	[N]: 1
//│ 	[N]: 5
//│ 	[K]: 9
//│ case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26 --->
//│ 	[L]: 2
//│ 	[L]: 3
//│ 	[T [N] [L] [L]]: 4
//│ 	[L]: 6
//│ 	[L]: 7
//│ 	[T [N] [L] [L]]: 8
//│ 	[T [K] aa bb]: 12
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 1 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 17
//│ [L]: 2 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [L]: 3 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [T [N] [L] [L]]: 4 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [N]: 5 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 17
//│ [L]: 6 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [L]: 7 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [T [N] [L] [L]]: 8 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [K]: 9 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 17
//│ [T [K] aa bb]: 12 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ ------------------
//│ case n⁰ of {K  => [KK] | N  => [NN]}: 17 --->
//│ 	[N]: 1
//│ 	[N]: 5
//│ 	[K]: 9
//│ case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26 --->
//│ 	[L]: 2
//│ 	[L]: 3
//│ 	[T [N] [L] [L]]: 4
//│ 	[L]: 6
//│ 	[L]: 7
//│ 	[T [N] [L] [L]]: 8
//│ 	[T [K] aa bb]: 12
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(t)
//│ def aa = 
//│ 	let r¹ = (fun _lh_dummy² -> [LL])
//│ 	in let l¹ = (fun _lh_dummy¹ -> [LL])
//│ 	in let n¹ = [NN]
//│ 	in (fun _lh_dummy⁰ -> [T n¹ c(l¹) c(r¹)])
//│ def bb = 
//│ 	let r² = (fun _lh_dummy⁵ -> [LL])
//│ 	in let l² = (fun _lh_dummy⁴ -> [LL])
//│ 	in let n² = [NN]
//│ 	in (fun _lh_dummy³ -> [T n² c(l²) c(r²)])
//│ def c(x¹) = x¹(99)
//│ def t = 
//│ 	let r³ = bb
//│ 	in let l³ = aa
//│ 	in let n³ = [KK]
//│ 	in (fun _lh_dummy⁶ -> [T n³ c(l³) c(r³)])
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ c
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ aa -> 0
//│ bb -> 0
//│ t -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ t(99)
//│ def aa = 
//│ 	let r⁰ = (fun _lh_dummy⁰ -> [LL])
//│ 	in let l⁰ = (fun _lh_dummy¹ -> [LL])
//│ 	in let n⁰ = [NN]
//│ 	in (fun _lh_dummy² -> [T n⁰ l⁰(99) r⁰(99)])
//│ def bb = 
//│ 	let r¹ = (fun _lh_dummy³ -> [LL])
//│ 	in let l¹ = (fun _lh_dummy⁴ -> [LL])
//│ 	in let n¹ = [NN]
//│ 	in (fun _lh_dummy⁵ -> [T n¹ l¹(99) r¹(99)])
//│ def c(x⁰) = x⁰(99)
//│ def t = 
//│ 	let r² = bb
//│ 	in let l² = aa
//│ 	in let n² = [KK]
//│ 	in (fun _lh_dummy⁶ -> [T n² l²(99) r²(99)])
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ t(99)
//│ def aa = 
//│ 	let r⁰ = (fun _lh_dummy⁰ -> [LL])
//│ 	in let l⁰ = (fun _lh_dummy¹ -> [LL])
//│ 	in let n⁰ = [NN]
//│ 	in (fun _lh_dummy² -> [T n⁰ l⁰(99) r⁰(99)])
//│ def bb = 
//│ 	let r¹ = (fun _lh_dummy³ -> [LL])
//│ 	in let l¹ = (fun _lh_dummy⁴ -> [LL])
//│ 	in let n¹ = [NN]
//│ 	in (fun _lh_dummy⁵ -> [T n¹ l¹(99) r¹(99)])
//│ def c(x⁰) = x⁰(99)
//│ def t(_lh_dummy⁶) = 
//│ 	let r² = bb
//│ 	in let l² = aa
//│ 	in let n² = [KK]
//│ 	in [T n² l²(99) r²(99)]
//│ <<<<<<< after floating out <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
fun map(ls) = if ls is
  C(h, t) then f => C(f(h), map(t)(f))
  N then f => N
let l = C(K, N)
map(l)(
  x => if x is
    K then T
)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#let| |l| |#=| |C|(|K|,| |N|)|↵|map|(|l|)|(|→|x| |=>| |#if| |x| |is|→|K| |#then| |T|←|←|↵|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, => if ls is ‹(C (h, t,)) then f, => C (f (h,), map (t,) (f,),); (N) then f, => N›; let l = C (K, N,); map (l,) (x, => if x is ‹(K) then T›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^19(l^20, (fun x⁰ -> case x⁰ of {
//│ 	K  => [T]}))
//│ def l = [C [K] [N]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map^5(t⁰, f⁰)])
//│ 	| N  => (fun f¹ -> [N])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [T] [N]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 16 --->
//│ 	case x⁰ of {K  => [T]}: 24
//│ [N]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14
//│ [C [K] [N]]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14 --->
//│ 	[N]: 17
//│ 	[C [K] [N]]: 18
//│ case x⁰ of {K  => [T]}: 24 --->
//│ 	DeadCodeProd
//│ 	[K]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14
//│ [C [K] [N]]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14 --->
//│ 	[N]: 17
//│ 	[C [K] [N]]: 18
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(l, (fun x¹ -> case x¹ of {
//│ 	K  => [T]}))
//│ def l = 
//│ 	let t¹ = (fun f³ -> [N])
//│ 	in let h¹ = [K]
//│ 	in (fun f² -> [C f²(h¹) map(t¹, f²)])
//│ def map(ls¹) = ls¹
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [T] [N]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ l -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ l((fun x⁰ -> case x⁰ of {
//│ 	K  => [T]}))
//│ def l = 
//│ 	let t⁰ = (fun f⁰ -> [N])
//│ 	in let h⁰ = [K]
//│ 	in (fun f¹ -> [C f¹(h⁰) t⁰(f¹)])
//│ def map(ls⁰) = ls⁰
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ l((fun x⁰ -> case x⁰ of {
//│ 	K  => [T]}))
//│ def l(f⁰) = 
//│ 	let t⁰ = (fun f¹ -> [N])
//│ 	in let h⁰ = [K]
//│ 	in [C f⁰(h⁰) t⁰(f⁰)]
//│ def map(ls⁰) = ls⁰
//│ <<<<<<< after floating out <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
fun last(ys) = if ys is
  N then x => x
  C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
  N then None
  C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastDrive^22([C 1 [C 2 [N]]])
//│ def last(ys⁰) = case ys⁰ of {
//│ 	N  => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> last^4(t⁰, h⁰))}
//│ def lastDrive(xs⁰) = case xs⁰ of {
//│ 	N  => [None]
//│ 	| C hh⁰ tt⁰ => [Some last^14(tt⁰, hh⁰)]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [Some 2]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 25 --->
//│ 	case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 10
//│ [C 2 [N]]: 26 --->
//│ 	case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 10
//│ [C 1 [C 2 [N]]]: 27 --->
//│ 	case xs⁰ of {N  => [None] | C hh⁰ tt⁰ => [Some last(tt⁰, hh⁰)]}: 20
//│ ------------------
//│ case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 10 --->
//│ 	[N]: 25
//│ 	[C 2 [N]]: 26
//│ case xs⁰ of {N  => [None] | C hh⁰ tt⁰ => [Some last(tt⁰, hh⁰)]}: 20 --->
//│ 	[C 1 [C 2 [N]]]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 25 --->
//│ 	case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 10
//│ [C 2 [N]]: 26 --->
//│ 	case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 10
//│ [C 1 [C 2 [N]]]: 27 --->
//│ 	case xs⁰ of {N  => [None] | C hh⁰ tt⁰ => [Some last(tt⁰, hh⁰)]}: 20
//│ ------------------
//│ case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 10 --->
//│ 	[N]: 25
//│ 	[C 2 [N]]: 26
//│ case xs⁰ of {N  => [None] | C hh⁰ tt⁰ => [Some last(tt⁰, hh⁰)]}: 20 --->
//│ 	[C 1 [C 2 [N]]]: 27
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastDrive(
//│ 	let tt¹ = 	
//│ 		let t¹ = (fun x³ -> x³)
//│ 		in let h¹ = 2
//│ 		in (fun x² -> last(t¹, h¹))
//│ 	in let hh¹ = 1
//│ 	in (fun _lh_dummy⁰ -> [Some last(tt¹, hh¹)]))
//│ def last(ys¹) = ys¹
//│ def lastDrive(xs¹) = xs¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 2]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ last, lastDrive
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let tt⁰ = 	
//│ 		let t⁰ = (fun x⁰ -> x⁰)
//│ 		in let h⁰ = 2
//│ 		in (fun x¹ -> t⁰(h⁰))
//│ 	in let hh⁰ = 1
//│ 	in (fun _lh_dummy⁰ -> [Some tt⁰(hh⁰)])(99)
//│ def last(ys⁰) = ys⁰
//│ def lastDrive(xs⁰) = xs⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let tt⁰ = 	
//│ 		let t⁰ = (fun x⁰ -> x⁰)
//│ 		in let h⁰ = 2
//│ 		in (fun x¹ -> t⁰(h⁰))
//│ 	in let hh⁰ = 1
//│ 	in (fun _lh_dummy⁰ -> [Some tt⁰(hh⁰)])(99)
//│ def last(ys⁰) = ys⁰
//│ def lastDrive(xs⁰) = xs⁰(99)
//│ <<<<<<< after floating out <<<<<<<

// CORRECT: with expanding termination
let p = C(p)
fun c(x) = if C(x) is
  C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^10(p^11)
//│ def c(x⁰) = case [C x⁰] of {
//│ 	C a⁰ => c^5(a⁰)}
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x⁰]: 4 --->
//│ 	case [C x⁰] of {C a⁰ => c(a⁰)}: 8
//│ ------------------
//│ case [C x⁰] of {C a⁰ => c(a⁰)}: 8 --->
//│ 	[C x⁰]: 4
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C x⁰]: 4 --->
//│ 	case [C x⁰] of {C a⁰ => c(a⁰)}: 8
//│ ------------------
//│ case [C x⁰] of {C a⁰ => c(a⁰)}: 8 --->
//│ 	[C x⁰]: 4
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(p)
//│ def c(x¹) = 
//│ 	let a¹ = x¹
//│ 	in (fun _lh_dummy⁰ -> c(a¹))(99)
//│ def p = [C p]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ recursive consumer: c
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ c(p)
//│ def c(x⁰) = 
//│ 	let a⁰ = x⁰
//│ 	in (fun _lh_dummy⁰ -> c(a⁰))(99)
//│ def p = [C p]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ c(p)
//│ def c(x⁰) = 
//│ 	let a⁰ = x⁰
//│ 	in (fun _lh_dummy⁰ -> c(a⁰))(99)
//│ def p = [C p]
//│ <<<<<<< after floating out <<<<<<<



// CORRECT: although multiple matches
// top level definitions as producers can be duplicated
fun c1(x1) = if x1 is
  A then AA
  B then BB
fun c2(x2) = if x2 is
  A then AAA
  B then BBB
let a = A
c1(a)
c2(a)
c2(B)
//│ |#fun| |c1|(|x1|)| |#=| |#if| |x1| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|#fun| |c2|(|x2|)| |#=| |#if| |x2| |is|→|A| |#then| |AAA|↵|B| |#then| |BBB|←|↵|#let| |a| |#=| |A|↵|c1|(|a|)|↵|c2|(|a|)|↵|c2|(|B|)|
//│ Parsed: {fun c1 = x1, => if x1 is ‹(A) then AA; (B) then BB›; fun c2 = x2, => if x2 is ‹(A) then AAA; (B) then BBB›; let a = A; c1 (a,); c2 (a,); c2 (B,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c1^12(a^13)
//│ c2^15(a^16)
//│ c2^18([B])
//│ def a = [A]
//│ def c1(x1⁰) = case x1⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def c2(x2⁰) = case x2⁰ of {
//│ 	A  => [AAA]
//│ 	| B  => [BBB]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 11 --->
//│ 	case x1⁰ of {A  => [AA] | B  => [BB]}: 4
//│ 	case x2⁰ of {A  => [AAA] | B  => [BBB]}: 9
//│ [B]: 19 --->
//│ 	case x2⁰ of {A  => [AAA] | B  => [BBB]}: 9
//│ ------------------
//│ case x1⁰ of {A  => [AA] | B  => [BB]}: 4 --->
//│ 	[A]: 11
//│ case x2⁰ of {A  => [AAA] | B  => [BBB]}: 9 --->
//│ 	[A]: 11
//│ 	[B]: 19
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c1(a)
//│ c2(a)
//│ c2([B])
//│ def a = [A]
//│ def c1(x1¹) = case x1¹ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def c2(x2¹) = case x2¹ of {
//│ 	A  => [AAA]
//│ 	| B  => [BBB]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ c1(a)
//│ c2(a)
//│ c2([B])
//│ def a = [A]
//│ def c1(x1⁰) = case x1⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def c2(x2⁰) = case x2⁰ of {
//│ 	A  => [AAA]
//│ 	| B  => [BBB]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ c1(a)
//│ c2(a)
//│ c2([B])
//│ def a = [A]
//│ def c1(x1⁰) = case x1⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def c2(x2⁰) = case x2⁰ of {
//│ 	A  => [AAA]
//│ 	| B  => [BBB]}
//│ <<<<<<< after floating out <<<<<<<





// CORRECT:
fun last(ys) = if ys is
  N then x => x
  C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
  N then None
  C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastDrive^22([C 1 [C 2 [N]]])
//│ def last(ys⁰) = case ys⁰ of {
//│ 	N  => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> last^4(t⁰, h⁰))}
//│ def lastDrive(xs⁰) = case xs⁰ of {
//│ 	N  => [None]
//│ 	| C hh⁰ tt⁰ => [Some last^14(tt⁰, hh⁰)]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 25 --->
//│ 	case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 10
//│ [C 2 [N]]: 26 --->
//│ 	case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 10
//│ [C 1 [C 2 [N]]]: 27 --->
//│ 	case xs⁰ of {N  => [None] | C hh⁰ tt⁰ => [Some last(tt⁰, hh⁰)]}: 20
//│ ------------------
//│ case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 10 --->
//│ 	[N]: 25
//│ 	[C 2 [N]]: 26
//│ case xs⁰ of {N  => [None] | C hh⁰ tt⁰ => [Some last(tt⁰, hh⁰)]}: 20 --->
//│ 	[C 1 [C 2 [N]]]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 25 --->
//│ 	case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 10
//│ [C 2 [N]]: 26 --->
//│ 	case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 10
//│ [C 1 [C 2 [N]]]: 27 --->
//│ 	case xs⁰ of {N  => [None] | C hh⁰ tt⁰ => [Some last(tt⁰, hh⁰)]}: 20
//│ ------------------
//│ case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 10 --->
//│ 	[N]: 25
//│ 	[C 2 [N]]: 26
//│ case xs⁰ of {N  => [None] | C hh⁰ tt⁰ => [Some last(tt⁰, hh⁰)]}: 20 --->
//│ 	[C 1 [C 2 [N]]]: 27
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastDrive(
//│ 	let tt¹ = 	
//│ 		let t¹ = (fun x³ -> x³)
//│ 		in let h¹ = 2
//│ 		in (fun x² -> last(t¹, h¹))
//│ 	in let hh¹ = 1
//│ 	in (fun _lh_dummy⁰ -> [Some last(tt¹, hh¹)]))
//│ def last(ys¹) = ys¹
//│ def lastDrive(xs¹) = xs¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ last, lastDrive
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let tt⁰ = 	
//│ 		let t⁰ = (fun x⁰ -> x⁰)
//│ 		in let h⁰ = 2
//│ 		in (fun x¹ -> t⁰(h⁰))
//│ 	in let hh⁰ = 1
//│ 	in (fun _lh_dummy⁰ -> [Some tt⁰(hh⁰)])(99)
//│ def last(ys⁰) = ys⁰
//│ def lastDrive(xs⁰) = xs⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let tt⁰ = 	
//│ 		let t⁰ = (fun x⁰ -> x⁰)
//│ 		in let h⁰ = 2
//│ 		in (fun x¹ -> t⁰(h⁰))
//│ 	in let hh⁰ = 1
//│ 	in (fun _lh_dummy⁰ -> [Some tt⁰(hh⁰)])(99)
//│ def last(ys⁰) = ys⁰
//│ def lastDrive(xs⁰) = xs⁰(99)
//│ <<<<<<< after floating out <<<<<<<

// CORRECT: the time of unrolling is correct
fun id(k) = k
fun id1(x) = id(x)
fun id2(y) = y
fun id3(z) = z
let rec p = C(C(C(id7(C(C(id1(p)))))))
fun c(xx) = if xx is
  C(a) then c(a)
fun id4(k) = k
fun id5(j) = j
fun id6(l) = l
fun id7(i) = i
id6(id4)(c)(id5(id2)(id3(p)))
//│ |#fun| |id|(|k|)| |#=| |k|↵|#fun| |id1|(|x|)| |#=| |id|(|x|)|↵|#fun| |id2|(|y|)| |#=| |y|↵|#fun| |id3|(|z|)| |#=| |z|↵|#let| |#rec| |p| |#=| |C|(|C|(|C|(|id7|(|C|(|C|(|id1|(|p|)|)|)|)|)|)|)|↵|#fun| |c|(|xx|)| |#=| |#if| |xx| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id4|(|k|)| |#=| |k|↵|#fun| |id5|(|j|)| |#=| |j|↵|#fun| |id6|(|l|)| |#=| |l|↵|#fun| |id7|(|i|)| |#=| |i|↵|id6|(|id4|)|(|c|)|(|id5|(|id2|)|(|id3|(|p|)|)|)|
//│ Parsed: {fun id = k, => k; fun id1 = x, => id (x,); fun id2 = y, => y; fun id3 = z, => z; let rec p = C (C (C (id7 (C (C (id1 (p,),),),),),),); fun c = xx, => if xx is ‹(C (a,)) then c (a,)›; fun id4 = k, => k; fun id5 = j, => j; fun id6 = l, => l; fun id7 = i, => i; id6 (id4,) (c,) (id5 (id2,) (id3 (p,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ id6^35(id4^36, c^38, id5^40(id2^41, id3^43(p^44)))
//│ def c(xx⁰) = case xx⁰ of {
//│ 	C a⁰ => c^22(a⁰)}
//│ def id(k⁰) = k⁰
//│ def id1(x⁰) = id^3(x⁰)
//│ def id2(y⁰) = y⁰
//│ def id3(z⁰) = z⁰
//│ def id4(k¹) = k¹
//│ def id5(j⁰) = j⁰
//│ def id6(l⁰) = l⁰
//│ def id7(i⁰) = i⁰
//│ def p = [C [C [C id7^11([C [C id1^12(p^13)]])]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C id1(p)]: 15 --->
//│ 	case xx⁰ of {C a⁰ => c(a⁰)}: 25
//│ [C [C id1(p)]]: 16 --->
//│ 	case xx⁰ of {C a⁰ => c(a⁰)}: 25
//│ [C id7([C [C id1(p)]])]: 18 --->
//│ 	case xx⁰ of {C a⁰ => c(a⁰)}: 25
//│ [C [C id7([C [C id1(p)]])]]: 19 --->
//│ 	case xx⁰ of {C a⁰ => c(a⁰)}: 25
//│ [C [C [C id7([C [C id1(p)]])]]]: 20 --->
//│ 	case xx⁰ of {C a⁰ => c(a⁰)}: 25
//│ ------------------
//│ case xx⁰ of {C a⁰ => c(a⁰)}: 25 --->
//│ 	[C id1(p)]: 15
//│ 	[C [C id1(p)]]: 16
//│ 	[C id7([C [C id1(p)]])]: 18
//│ 	[C [C id7([C [C id1(p)]])]]: 19
//│ 	[C [C [C id7([C [C id1(p)]])]]]: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C id1(p)]: 15 --->
//│ 	case xx⁰ of {C a⁰ => c(a⁰)}: 25
//│ [C [C id1(p)]]: 16 --->
//│ 	case xx⁰ of {C a⁰ => c(a⁰)}: 25
//│ [C id7([C [C id1(p)]])]: 18 --->
//│ 	case xx⁰ of {C a⁰ => c(a⁰)}: 25
//│ [C [C id7([C [C id1(p)]])]]: 19 --->
//│ 	case xx⁰ of {C a⁰ => c(a⁰)}: 25
//│ [C [C [C id7([C [C id1(p)]])]]]: 20 --->
//│ 	case xx⁰ of {C a⁰ => c(a⁰)}: 25
//│ ------------------
//│ case xx⁰ of {C a⁰ => c(a⁰)}: 25 --->
//│ 	[C id1(p)]: 15
//│ 	[C [C id1(p)]]: 16
//│ 	[C id7([C [C id1(p)]])]: 18
//│ 	[C [C id7([C [C id1(p)]])]]: 19
//│ 	[C [C [C id7([C [C id1(p)]])]]]: 20
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ id6(id4, c, id5(id2, id3(p)))
//│ def c(xx¹) = xx¹(99)
//│ def id(k³) = k³
//│ def id1(x¹) = id(x¹)
//│ def id2(y¹) = y¹
//│ def id3(z¹) = z¹
//│ def id4(k²) = k²
//│ def id5(j¹) = j¹
//│ def id6(l¹) = l¹
//│ def id7(i¹) = i¹
//│ def p = 
//│ 	let a¹ = 	
//│ 		let a² = 	
//│ 			let a³ = id7(
//│ 				let a⁴ = 	
//│ 					let a⁵ = id1(p)
//│ 					in (fun _lh_dummy⁴ -> c(a⁵))
//│ 				in (fun _lh_dummy³ -> c(a⁴)))
//│ 			in (fun _lh_dummy² -> c(a³))
//│ 		in (fun _lh_dummy¹ -> c(a²))
//│ 	in (fun _lh_dummy⁰ -> c(a¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ c
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ p -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ id6(id4, c, id5(id2, id3(p)))
//│ def c(xx⁰) = xx⁰(99)
//│ def id(k¹) = k¹
//│ def id1(x⁰) = id(x⁰)
//│ def id2(y⁰) = y⁰
//│ def id3(z⁰) = z⁰
//│ def id4(k⁰) = k⁰
//│ def id5(j⁰) = j⁰
//│ def id6(l⁰) = l⁰
//│ def id7(i⁰) = i⁰
//│ def p = 
//│ 	let a⁰ = 	
//│ 		let a¹ = 	
//│ 			let a² = id7(
//│ 				let a³ = 	
//│ 					let a⁴ = id1(p)
//│ 					in (fun _lh_dummy⁰ -> a⁴(99))
//│ 				in (fun _lh_dummy¹ -> a³(99)))
//│ 			in (fun _lh_dummy² -> a²(99))
//│ 		in (fun _lh_dummy³ -> a¹(99))
//│ 	in (fun _lh_dummy⁴ -> a⁰(99))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ id6(id4, c, id5(id2, id3(p)))
//│ def c(xx⁰) = xx⁰(99)
//│ def id(k¹) = k¹
//│ def id1(x⁰) = id(x⁰)
//│ def id2(y⁰) = y⁰
//│ def id3(z⁰) = z⁰
//│ def id4(k⁰) = k⁰
//│ def id5(j⁰) = j⁰
//│ def id6(l⁰) = l⁰
//│ def id7(i⁰) = i⁰
//│ def p = 
//│ 	let a⁰ = 	
//│ 		let a¹ = 	
//│ 			let a² = id7(
//│ 				let a³ = 	
//│ 					let a⁴ = id1(p)
//│ 					in (fun _lh_dummy⁰ -> a⁴(99))
//│ 				in (fun _lh_dummy¹ -> a³(99)))
//│ 			in (fun _lh_dummy² -> a²(99))
//│ 		in (fun _lh_dummy³ -> a¹(99))
//│ 	in (fun _lh_dummy⁴ -> a⁰(99))
//│ <<<<<<< after floating out <<<<<<<

// CORRECT:
fun id(x) = if x is
  ID(b) then b
  C(a) then id(ID(C(a)))
let p = C(p)
fun c(y) = if y is
  C(aa) then c(aa)
c(id(p))
//│ |#fun| |id|(|x|)| |#=| |#if| |x| |is|→|ID|(|b|)| |#then| |b|↵|C|(|a|)| |#then| |id|(|ID|(|C|(|a|)|)|)|←|↵|#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |c|(|aa|)|←|↵|c|(|id|(|p|)|)|
//│ Parsed: {fun id = x, => if x is ‹(ID (b,)) then b; (C (a,)) then id (ID (C (a,),),)›; let p = C (p,); fun c = y, => if y is ‹(C (aa,)) then c (aa,)›; c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^18(id^19(p^20))
//│ def c(y⁰) = case y⁰ of {
//│ 	C aa⁰ => c^13(aa⁰)}
//│ def id(x⁰) = case x⁰ of {
//│ 	ID b⁰ => b⁰
//│ 	| C a⁰ => id^3([ID [C a⁰]])}
//│ def p = [C p^10]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a⁰]: 5 --->
//│ 	case y⁰ of {C aa⁰ => c(aa⁰)}: 16
//│ [ID [C a⁰]]: 6 --->
//│ 	case x⁰ of {ID b⁰ => b⁰ | C a⁰ => id([ID [C a⁰]])}: 8
//│ [C p]: 11 --->
//│ 	case x⁰ of {ID b⁰ => b⁰ | C a⁰ => id([ID [C a⁰]])}: 8
//│ 	case y⁰ of {C aa⁰ => c(aa⁰)}: 16
//│ ------------------
//│ case x⁰ of {ID b⁰ => b⁰ | C a⁰ => id([ID [C a⁰]])}: 8 --->
//│ 	[ID [C a⁰]]: 6
//│ 	[C p]: 11
//│ case y⁰ of {C aa⁰ => c(aa⁰)}: 16 --->
//│ 	[C a⁰]: 5
//│ 	[C p]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(id(p))
//│ def c(y¹) = case y¹ of {
//│ 	C aa⁰ => c(aa⁰)}
//│ def id(x¹) = case x¹ of {
//│ 	ID b⁰ => b⁰
//│ 	| C a⁰ => id([ID [C a⁰]])}
//│ def p = [C p]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ c(id(p))
//│ def c(y⁰) = case y⁰ of {
//│ 	C aa⁰ => c(aa⁰)}
//│ def id(x⁰) = case x⁰ of {
//│ 	ID b⁰ => b⁰
//│ 	| C a⁰ => id([ID [C a⁰]])}
//│ def p = [C p]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ c(id(p))
//│ def c(y⁰) = case y⁰ of {
//│ 	C aa⁰ => c(aa⁰)}
//│ def id(x⁰) = case x⁰ of {
//│ 	ID b⁰ => b⁰
//│ 	| C a⁰ => id([ID [C a⁰]])}
//│ def p = [C p]
//│ <<<<<<< after floating out <<<<<<<


// CORRECT: unlike the rev rev case, TODO: why?
fun map(ls) = if ls is
  C(h, t) then C(
    (if h is
      A then AA
      B then BB
    ),
    map(t)
  )
  N then N
fun len(ls) = if ls is
  C(h, t) then 1 + len(t)
  N then 0
len(map(C(A, C(B, N))))
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#fun| |len|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |1| |+| |len|(|t|)|↵|N| |#then| |0|←|↵|len|(|map|(|C|(|A|,| |C|(|B|,| |N|)|)|)|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(A) then AA; (B) then BB›, ')', map (t,),); (N) then N›; fun len = ls, => if ls is ‹(C (h, t,)) then + (1,) (len (t,),); (N) then 0›; len (map (C (A, C (B, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ len^24(map^25([C [A] [C [B] [N]]]))
//│ def len(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => (1 + len^17(t¹))
//│ 	| N  => 0}
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C case h⁰ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]} map^6(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C case h⁰ of {A  => [AA] | B  => [BB]} map(t⁰)]: 9 --->
//│ 	case ls¹ of {C h¹ t¹ => (1 + len(t¹)) | N  => 0}: 22
//│ [N]: 10 --->
//│ 	case ls¹ of {C h¹ t¹ => (1 + len(t¹)) | N  => 0}: 22
//│ [A]: 26 --->
//│ 	case h⁰ of {A  => [AA] | B  => [BB]}: 5
//│ [B]: 27 --->
//│ 	case h⁰ of {A  => [AA] | B  => [BB]}: 5
//│ [N]: 28 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {A  => [AA] | B  => [BB]} map(t⁰)] | N  => [N]}: 11
//│ [C [B] [N]]: 29 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {A  => [AA] | B  => [BB]} map(t⁰)] | N  => [N]}: 11
//│ [C [A] [C [B] [N]]]: 30 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {A  => [AA] | B  => [BB]} map(t⁰)] | N  => [N]}: 11
//│ ------------------
//│ case h⁰ of {A  => [AA] | B  => [BB]}: 5 --->
//│ 	[A]: 26
//│ 	[B]: 27
//│ case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {A  => [AA] | B  => [BB]} map(t⁰)] | N  => [N]}: 11 --->
//│ 	[N]: 28
//│ 	[C [B] [N]]: 29
//│ 	[C [A] [C [B] [N]]]: 30
//│ case ls¹ of {C h¹ t¹ => (1 + len(t¹)) | N  => 0}: 22 --->
//│ 	[C case h⁰ of {A  => [AA] | B  => [BB]} map(t⁰)]: 9
//│ 	[N]: 10
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C case h⁰ of {A  => [AA] | B  => [BB]} map(t⁰)]: 9 --->
//│ 	case ls¹ of {C h¹ t¹ => (1 + len(t¹)) | N  => 0}: 22
//│ [N]: 10 --->
//│ 	case ls¹ of {C h¹ t¹ => (1 + len(t¹)) | N  => 0}: 22
//│ [A]: 26 --->
//│ 	case h⁰ of {A  => [AA] | B  => [BB]}: 5
//│ [B]: 27 --->
//│ 	case h⁰ of {A  => [AA] | B  => [BB]}: 5
//│ [N]: 28 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {A  => [AA] | B  => [BB]} map(t⁰)] | N  => [N]}: 11
//│ [C [B] [N]]: 29 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {A  => [AA] | B  => [BB]} map(t⁰)] | N  => [N]}: 11
//│ [C [A] [C [B] [N]]]: 30 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {A  => [AA] | B  => [BB]} map(t⁰)] | N  => [N]}: 11
//│ ------------------
//│ case h⁰ of {A  => [AA] | B  => [BB]}: 5 --->
//│ 	[A]: 26
//│ 	[B]: 27
//│ case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {A  => [AA] | B  => [BB]} map(t⁰)] | N  => [N]}: 11 --->
//│ 	[N]: 28
//│ 	[C [B] [N]]: 29
//│ 	[C [A] [C [B] [N]]]: 30
//│ case ls¹ of {C h¹ t¹ => (1 + len(t¹)) | N  => 0}: 22 --->
//│ 	[C case h⁰ of {A  => [AA] | B  => [BB]} map(t⁰)]: 9
//│ 	[N]: 10
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ len(map(
//│ 	let t² = 	
//│ 		let t⁴ = (fun _lh_dummy⁵ -> (fun _lh_dummy⁴ -> 0))
//│ 		in let h⁴ = [BB]
//│ 		in (fun _lh_dummy³ -> 
//│ 			let t⁵ = map(t⁴)
//│ 			in let h⁵ = h⁴
//│ 			in (fun _lh_dummy² -> (1 + len(t⁵))))
//│ 	in let h² = [AA]
//│ 	in (fun _lh_dummy¹ -> 
//│ 		let t³ = map(t²)
//│ 		in let h³ = h²
//│ 		in (fun _lh_dummy⁰ -> (1 + len(t³))))))
//│ def len(ls³) = ls³(99)
//│ def map(ls²) = ls²(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map, len
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun _lh_dummy⁰ -> (fun _lh_dummy¹ -> 0))
//│ 		in let h⁰ = [BB]
//│ 		in (fun _lh_dummy² -> 
//│ 			let t² = t¹(99)
//│ 			in let h¹ = h⁰
//│ 			in (fun _lh_dummy³ -> (1 + t²(99))))
//│ 	in let h² = [AA]
//│ 	in (fun _lh_dummy⁴ -> 
//│ 		let t³ = t⁰(99)
//│ 		in let h³ = h²
//│ 		in (fun _lh_dummy⁵ -> (1 + t³(99))))(99, 99)
//│ def len(ls¹) = ls¹(99)
//│ def map(ls⁰) = ls⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun _lh_dummy⁰ -> (fun _lh_dummy¹ -> 0))
//│ 		in let h⁰ = [BB]
//│ 		in (fun _lh_dummy² -> 
//│ 			let t² = t¹(99)
//│ 			in let h¹ = h⁰
//│ 			in (fun _lh_dummy³ -> (1 + t²(99))))
//│ 	in let h² = [AA]
//│ 	in (fun _lh_dummy⁴ -> 
//│ 		let t³ = t⁰(99)
//│ 		in let h³ = h²
//│ 		in (fun _lh_dummy⁵ -> (1 + t³(99))))(99, 99)
//│ def len(ls¹) = ls¹(99)
//│ def map(ls⁰) = ls⁰(99)
//│ <<<<<<< after floating out <<<<<<<

// CORRECT: multiple match, but correct
fun f(x) = if x is
  C(a) then f
f(C(A))(C(B))(C(D))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |f|←|↵|f|(|C|(|A|)|)|(|C|(|B|)|)|(|C|(|D|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then f›; f (C (A,),) (C (B,),) (C (D,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^5([C [A]], [C [B]], [C [D]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => f^2}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 7 --->
//│ 	case x⁰ of {C a⁰ => f}: 3
//│ [C [B]]: 10 --->
//│ 	case x⁰ of {C a⁰ => f}: 3
//│ [C [D]]: 13 --->
//│ 	case x⁰ of {C a⁰ => f}: 3
//│ ------------------
//│ case x⁰ of {C a⁰ => f}: 3 --->
//│ 	NoProd
//│ 	[C [A]]: 7
//│ 	[C [B]]: 10
//│ 	[C [D]]: 13
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C [A]], [C [B]], [C [D]])
//│ def f(x¹) = case x¹ of {
//│ 	C a⁰ => f}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f([C [A]], [C [B]], [C [D]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => f}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f([C [A]], [C [B]], [C [D]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => f}
//│ <<<<<<< after floating out <<<<<<<

// CORRECT:
let aa = T(N, t, t)
let t = T(K, aa, aa)
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |t|,| |t|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |aa|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, t, t,); let t = T (K, aa, aa,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^24(t^25)
//│ def aa = [T [N] t^2 t^3]
//│ def c(x⁰) = case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K  => [KK]
//│ 		| N  => [NN]} c^14(l⁰) c^17(r⁰)]
//│ 	| L  => [LL]}
//│ def t = [T [K] aa^6 aa^7]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 1 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 13
//│ [T [N] t t]: 4 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 22
//│ [K]: 5 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 13
//│ [T [K] aa aa]: 8 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 22
//│ ------------------
//│ case n⁰ of {K  => [KK] | N  => [NN]}: 13 --->
//│ 	[N]: 1
//│ 	[K]: 5
//│ case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 22 --->
//│ 	[T [N] t t]: 4
//│ 	[T [K] aa aa]: 8
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 1 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 13
//│ [T [N] t t]: 4 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 22
//│ [K]: 5 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 13
//│ [T [K] aa aa]: 8 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 22
//│ ------------------
//│ case n⁰ of {K  => [KK] | N  => [NN]}: 13 --->
//│ 	[N]: 1
//│ 	[K]: 5
//│ case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 22 --->
//│ 	[T [N] t t]: 4
//│ 	[T [K] aa aa]: 8
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(t)
//│ def aa = 
//│ 	let r¹ = t
//│ 	in let l¹ = t
//│ 	in let n¹ = [NN]
//│ 	in (fun _lh_dummy⁰ -> [T n¹ c(l¹) c(r¹)])
//│ def c(x¹) = x¹(99)
//│ def t = 
//│ 	let r² = aa
//│ 	in let l² = aa
//│ 	in let n² = [KK]
//│ 	in (fun _lh_dummy¹ -> [T n² c(l²) c(r²)])
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ c
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ aa -> 0
//│ t -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ t(99)
//│ def aa = 
//│ 	let r⁰ = t
//│ 	in let l⁰ = t
//│ 	in let n⁰ = [NN]
//│ 	in (fun _lh_dummy⁰ -> [T n⁰ l⁰(99) r⁰(99)])
//│ def c(x⁰) = x⁰(99)
//│ def t = 
//│ 	let r¹ = aa
//│ 	in let l¹ = aa
//│ 	in let n¹ = [KK]
//│ 	in (fun _lh_dummy¹ -> [T n¹ l¹(99) r¹(99)])
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ t(99)
//│ def aa = 
//│ 	let r⁰ = t
//│ 	in let l⁰ = t
//│ 	in let n⁰ = [NN]
//│ 	in (fun _lh_dummy⁰ -> [T n⁰ l⁰(99) r⁰(99)])
//│ def c(x⁰) = x⁰(99)
//│ def t = 
//│ 	let r¹ = aa
//│ 	in let l¹ = aa
//│ 	in let n¹ = [KK]
//│ 	in (fun _lh_dummy¹ -> [T n¹ l¹(99) r¹(99)])
//│ <<<<<<< after floating out <<<<<<<


// CORRECT: but explode on branches
fun filter(ls) = if ls is
  C(h, t) then if h > 1 is
    True then C(h, filter(t))
    False then filter(t)
  N then N
filter(C(1, C(2, C(3, N))))
//│ |#fun| |filter|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |>| |1| |is|→|True| |#then| |C|(|h|,| |filter|(|t|)|)|↵|False| |#then| |filter|(|t|)|←|↵|N| |#then| |N|←|↵|filter|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {fun filter = ls, => if ls is ‹(C (h, t,)) then if > (h,) (1,) is ‹(True) then C (h, filter (t,),); (False) then filter (t,)›; (N) then N›; filter (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ filter^19([C 1 [C 2 [C 3 [N]]]])
//│ def filter(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case (h⁰ > 1) of {
//│ 		True  => [C h⁰ filter^8(t⁰)]
//│ 		| False  => filter^12(t⁰)}
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 23 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case (h⁰ > 1) of {True  => [C h⁰ filter(t⁰)] | False  => filter(t⁰)} | N  => [N]}: 17
//│ [C 3 [N]]: 24 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case (h⁰ > 1) of {True  => [C h⁰ filter(t⁰)] | False  => filter(t⁰)} | N  => [N]}: 17
//│ [C 2 [C 3 [N]]]: 25 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case (h⁰ > 1) of {True  => [C h⁰ filter(t⁰)] | False  => filter(t⁰)} | N  => [N]}: 17
//│ [C 1 [C 2 [C 3 [N]]]]: 26 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case (h⁰ > 1) of {True  => [C h⁰ filter(t⁰)] | False  => filter(t⁰)} | N  => [N]}: 17
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => case (h⁰ > 1) of {True  => [C h⁰ filter(t⁰)] | False  => filter(t⁰)} | N  => [N]}: 17 --->
//│ 	[N]: 23
//│ 	[C 3 [N]]: 24
//│ 	[C 2 [C 3 [N]]]: 25
//│ 	[C 1 [C 2 [C 3 [N]]]]: 26
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 23 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case (h⁰ > 1) of {True  => [C h⁰ filter(t⁰)] | False  => filter(t⁰)} | N  => [N]}: 17
//│ [C 3 [N]]: 24 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case (h⁰ > 1) of {True  => [C h⁰ filter(t⁰)] | False  => filter(t⁰)} | N  => [N]}: 17
//│ [C 2 [C 3 [N]]]: 25 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case (h⁰ > 1) of {True  => [C h⁰ filter(t⁰)] | False  => filter(t⁰)} | N  => [N]}: 17
//│ [C 1 [C 2 [C 3 [N]]]]: 26 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case (h⁰ > 1) of {True  => [C h⁰ filter(t⁰)] | False  => filter(t⁰)} | N  => [N]}: 17
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => case (h⁰ > 1) of {True  => [C h⁰ filter(t⁰)] | False  => filter(t⁰)} | N  => [N]}: 17 --->
//│ 	[N]: 23
//│ 	[C 3 [N]]: 24
//│ 	[C 2 [C 3 [N]]]: 25
//│ 	[C 1 [C 2 [C 3 [N]]]]: 26
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ filter(
//│ 	let t¹ = 	
//│ 		let t² = 	
//│ 			let t³ = (fun _lh_dummy³ -> [N])
//│ 			in let h³ = 3
//│ 			in (fun _lh_dummy² -> case (h³ > 1) of {
//│ 				True  => [C h³ filter(t³)]
//│ 				| False  => filter(t³)})
//│ 		in let h² = 2
//│ 		in (fun _lh_dummy¹ -> case (h² > 1) of {
//│ 			True  => [C h² filter(t²)]
//│ 			| False  => filter(t²)})
//│ 	in let h¹ = 1
//│ 	in (fun _lh_dummy⁰ -> case (h¹ > 1) of {
//│ 		True  => [C h¹ filter(t¹)]
//│ 		| False  => filter(t¹)}))
//│ def filter(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ filter
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun _lh_dummy⁰ -> [N])
//│ 			in let h⁰ = 3
//│ 			in (fun _lh_dummy¹ -> case (h⁰ > 1) of {
//│ 				True  => [C h⁰ t²(99)]
//│ 				| False  => t²(99)})
//│ 		in let h¹ = 2
//│ 		in (fun _lh_dummy² -> case (h¹ > 1) of {
//│ 			True  => [C h¹ t¹(99)]
//│ 			| False  => t¹(99)})
//│ 	in let h² = 1
//│ 	in (fun _lh_dummy³ -> case (h² > 1) of {
//│ 		True  => [C h² t⁰(99)]
//│ 		| False  => t⁰(99)})(99)
//│ def filter(ls⁰) = ls⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun _lh_dummy⁰ -> [N])
//│ 			in let h⁰ = 3
//│ 			in (fun _lh_dummy¹ -> case (h⁰ > 1) of {
//│ 				True  => [C h⁰ t²(99)]
//│ 				| False  => t²(99)})
//│ 		in let h¹ = 2
//│ 		in (fun _lh_dummy² -> case (h¹ > 1) of {
//│ 			True  => [C h¹ t¹(99)]
//│ 			| False  => t¹(99)})
//│ 	in let h² = 1
//│ 	in (fun _lh_dummy³ -> case (h² > 1) of {
//│ 		True  => [C h² t⁰(99)]
//│ 		| False  => t⁰(99)})(99)
//│ def filter(ls⁰) = ls⁰(99)
//│ <<<<<<< after floating out <<<<<<<


// CORRECT: top level defs used multiple times are fine
// but top level producers used multiple times may result in duplicated computation
let p = C(p)
let pp = C(C(pp))
fun c(x) = if x is
  C(a) then if a is
    C(b) then c(b)
    N then a
  N then x
P(c(pp), c(p))
//│ |#let| |p| |#=| |C|(|p|)|↵|#let| |pp| |#=| |C|(|C|(|pp|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |c|(|b|)|↵|N| |#then| |a|←|↵|N| |#then| |x|←|↵|P|(|c|(|pp|)|,| |c|(|p|)|)|
//│ Parsed: {let p = C (p,); let pp = C (C (pp,),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then c (b,); (N) then a›; (N) then x›; P (c (pp,), c (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ [P c^16(pp^17) c^19(p^20)]
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => c^8(b⁰)
//│ 		| N  => a⁰}
//│ 	| N  => x⁰}
//│ def p = [C p^1]
//│ def pp = [C [C pp^3]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p]: 2 --->
//│ 	NoCons
//│ 	case a⁰ of {C b⁰ => c(b⁰) | N  => a⁰}: 12
//│ 	case x⁰ of {C a⁰ => case a⁰ of {C b⁰ => c(b⁰) | N  => a⁰} | N  => x⁰}: 14
//│ [C pp]: 4 --->
//│ 	NoCons
//│ 	case a⁰ of {C b⁰ => c(b⁰) | N  => a⁰}: 12
//│ [C [C pp]]: 5 --->
//│ 	NoCons
//│ 	case x⁰ of {C a⁰ => case a⁰ of {C b⁰ => c(b⁰) | N  => a⁰} | N  => x⁰}: 14
//│ ------------------
//│ case a⁰ of {C b⁰ => c(b⁰) | N  => a⁰}: 12 --->
//│ 	[C p]: 2
//│ 	[C pp]: 4
//│ case x⁰ of {C a⁰ => case a⁰ of {C b⁰ => c(b⁰) | N  => a⁰} | N  => x⁰}: 14 --->
//│ 	[C p]: 2
//│ 	[C [C pp]]: 5
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ [P c(pp) c(p)]
//│ def c(x¹) = case x¹ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => c(b⁰)
//│ 		| N  => a⁰}
//│ 	| N  => x¹}
//│ def p = [C p]
//│ def pp = [C [C pp]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ [P c(pp) c(p)]
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => c(b⁰)
//│ 		| N  => a⁰}
//│ 	| N  => x⁰}
//│ def p = [C p]
//│ def pp = [C [C pp]]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ [P c(pp) c(p)]
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => c(b⁰)
//│ 		| N  => a⁰}
//│ 	| N  => x⁰}
//│ def p = [C p]
//│ def pp = [C [C pp]]
//│ <<<<<<< after floating out <<<<<<<


// CORRECT:
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  N then a => a
  C(h, t) then a => rev(t, C(h, a))
fun rev2(ls2) = if ls2 is
  N then a2 => a2
  C(h2, t2) then a2 => rev2(t2, C(h2, a2))
rev2(rev(C(1, C(2, N)))(N))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a| |=>| |a|↵|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|,| |C|(|h|,| |a|)|)|←|↵|#fun| |rev2|(|ls2|)| |#=| |#if| |ls2| |is|→|N| |#then| |a2| |=>| |a2|↵|C|(|h2|,| |t2|)| |#then| |a2| |=>| |rev2|(|t2|,| |C|(|h2|,| |a2|)|)|←|↵|rev2|(|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|N|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(N) then a, => a; (C (h, t,)) then a, => rev (t, C (h, a,),)›; fun rev2 = ls2, => if ls2 is ‹(N) then a2, => a2; (C (h2, t2,)) then a2, => rev2 (t2, C (h2, a2,),)›; rev2 (rev (C (1, C (2, N,),),) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev2^27(rev^28([C 1 [C 2 [N]]], [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	N  => (fun a⁰ -> a⁰)
//│ 	| C h⁰ t⁰ => (fun a¹ -> rev^4(t⁰, [C h⁰ a¹]))}
//│ def rev2(ls2⁰) = case ls2⁰ of {
//│ 	N  => (fun a2⁰ -> a2⁰)
//│ 	| C h2⁰ t2⁰ => (fun a2¹ -> rev2^17(t2⁰, [C h2⁰ a2¹]))}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ a¹]: 9 --->
//│ 	case ls2⁰ of {N  => (fun a2⁰ -> a2⁰) | C h2⁰ t2⁰ => (fun a2¹ -> rev2(t2⁰, [C h2⁰ a2¹]))}: 25
//│ [N]: 31 --->
//│ 	case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [C 2 [N]]: 32 --->
//│ 	case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [C 1 [C 2 [N]]]: 33 --->
//│ 	case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [N]: 35 --->
//│ 	case ls2⁰ of {N  => (fun a2⁰ -> a2⁰) | C h2⁰ t2⁰ => (fun a2¹ -> rev2(t2⁰, [C h2⁰ a2¹]))}: 25
//│ ------------------
//│ case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12 --->
//│ 	[N]: 31
//│ 	[C 2 [N]]: 32
//│ 	[C 1 [C 2 [N]]]: 33
//│ case ls2⁰ of {N  => (fun a2⁰ -> a2⁰) | C h2⁰ t2⁰ => (fun a2¹ -> rev2(t2⁰, [C h2⁰ a2¹]))}: 25 --->
//│ 	[C h⁰ a¹]: 9
//│ 	[N]: 35
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h⁰ a¹]: 9 --->
//│ 	case ls2⁰ of {N  => (fun a2⁰ -> a2⁰) | C h2⁰ t2⁰ => (fun a2¹ -> rev2(t2⁰, [C h2⁰ a2¹]))}: 25
//│ [N]: 31 --->
//│ 	case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [C 2 [N]]: 32 --->
//│ 	case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [C 1 [C 2 [N]]]: 33 --->
//│ 	case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [N]: 35 --->
//│ 	case ls2⁰ of {N  => (fun a2⁰ -> a2⁰) | C h2⁰ t2⁰ => (fun a2¹ -> rev2(t2⁰, [C h2⁰ a2¹]))}: 25
//│ ------------------
//│ case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12 --->
//│ 	[N]: 31
//│ 	[C 2 [N]]: 32
//│ 	[C 1 [C 2 [N]]]: 33
//│ case ls2⁰ of {N  => (fun a2⁰ -> a2⁰) | C h2⁰ t2⁰ => (fun a2¹ -> rev2(t2⁰, [C h2⁰ a2¹]))}: 25 --->
//│ 	[C h⁰ a¹]: 9
//│ 	[N]: 35
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev2(rev(
//│ 	let t¹ = 	
//│ 		let t² = (fun a⁴ -> a⁴)
//│ 		in let h² = 2
//│ 		in (fun a³ -> rev(t², 
//│ 			let t2² = a³
//│ 			in let h2² = h²
//│ 			in (fun a2³ -> rev2(t2², [C h2² a2³]))))
//│ 	in let h¹ = 1
//│ 	in (fun a² -> rev(t¹, 
//│ 		let t2¹ = a²
//│ 		in let h2¹ = h¹
//│ 		in (fun a2² -> rev2(t2¹, [C h2¹ a2²])))), (fun a2⁴ -> a2⁴)), [N])
//│ def rev(ls¹) = ls¹
//│ def rev2(ls2¹) = ls2¹
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev, rev2
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ let t⁰ = 	
//│ 	let t¹ = (fun a⁰ -> a⁰)
//│ 	in let h⁰ = 2
//│ 	in (fun a¹ -> t¹(
//│ 		let t2⁰ = a¹
//│ 		in let h2⁰ = h⁰
//│ 		in (fun a2⁰ -> t2⁰([C h2⁰ a2⁰]))))
//│ in let h¹ = 1
//│ in t⁰(
//│ 	let t2¹ = (fun a2¹ -> a2¹)
//│ 	in let h2¹ = h¹
//│ 	in (fun a2² -> t2¹([C h2¹ a2²])), [N])
//│ def rev(ls⁰) = ls⁰
//│ def rev2(ls2⁰) = ls2⁰
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ let t⁰ = 	
//│ 	let t¹ = (fun a⁰ -> a⁰)
//│ 	in let h⁰ = 2
//│ 	in (fun a¹ -> t¹(
//│ 		let t2⁰ = a¹
//│ 		in let h2⁰ = h⁰
//│ 		in (fun a2⁰ -> t2⁰([C h2⁰ a2⁰]))))
//│ in let h¹ = 1
//│ in t⁰(
//│ 	let t2¹ = (fun a2¹ -> a2¹)
//│ 	in let h2¹ = h¹
//│ 	in (fun a2² -> t2¹([C h2¹ a2²])), [N])
//│ def rev(ls⁰) = ls⁰
//│ def rev2(ls2⁰) = ls2⁰
//│ <<<<<<< after floating out <<<<<<<


// CORRECT: rev actually works (despite the fact that there are some match clash),
// and duplicated usage of toplevel things are alright
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
rev(C(A, C(B, N)))(N)
rev(rev(C(A, C(B, N)))(N))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|rev|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|N|)|↵|rev|(|rev|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|N|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; rev (C (A, C (B, N,),),) (N,); rev (rev (C (A, C (B, N,),),) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^14([C [A] [C [B] [N]]], [N])
//│ rev^23(rev^24([C [A] [C [B] [N]]], [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev^2(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [B] [C [A] [N]]]
//│ [C [A] [C [B] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ a⁰]: 7 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [N]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [C [B] [N]]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [C [A] [C [B] [N]]]: 19 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [N]: 21 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [N]: 27 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [C [B] [N]]: 28 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [C [A] [C [B] [N]]]: 29 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [N]: 31 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [N]: 34 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12 --->
//│ 	[C h⁰ a⁰]: 7
//│ 	[N]: 17
//│ 	[C [B] [N]]: 18
//│ 	[C [A] [C [B] [N]]]: 19
//│ 	[N]: 21
//│ 	[N]: 27
//│ 	[C [B] [N]]: 28
//│ 	[C [A] [C [B] [N]]]: 29
//│ 	[N]: 31
//│ 	[N]: 34
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev([C [A] [C [B] [N]]], [N])
//│ rev(rev([C [A] [C [B] [N]]], [N]), [N])
//│ def rev(ls¹) = case ls¹ of {
//│ 	C h⁰ t⁰ => (fun a² -> rev(t⁰, [C h⁰ a²]))
//│ 	| N  => (fun a³ -> a³)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [B] [C [A] [N]]]
//│ [C [A] [C [B] [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ rev([C [A] [C [B] [N]]], [N])
//│ rev(rev([C [A] [C [B] [N]]], [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ rev([C [A] [C [B] [N]]], [N])
//│ rev(rev([C [A] [C [B] [N]]], [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<< after floating out <<<<<<<

// CORRECT: using primitive is also correct
fun rev(ls) = if ls is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
rev(rev(primitive)(N))(N)
//│ |#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|rev|(|rev|(|primitive|)|(|N|)|)|(|N|)|
//│ Parsed: {fun rev = ls, => if ls is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; rev (rev (primitive,) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^14(rev^15(primitive⁰, [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev^2(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ a⁰]: 7 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [N]: 18 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ [N]: 21 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 12 --->
//│ 	[C h⁰ a⁰]: 7
//│ 	NoProd
//│ 	[N]: 18
//│ 	[N]: 21
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(rev(primitive⁰, [N]), [N])
//│ def rev(ls¹) = case ls¹ of {
//│ 	C h⁰ t⁰ => (fun a² -> rev(t⁰, [C h⁰ a²]))
//│ 	| N  => (fun a³ -> a³)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ rev(rev(primitive⁰, [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ rev(rev(primitive⁰, [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<< after floating out <<<<<<<

// CORRECT: even normal rev can be optimized?
// NOTE: may be only out of luck: we choose 
_LUMBERHACK_EVAL
fun concat(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(C(1, C(2, N)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^27([C 1 [C 2 [N]]])
//│ def concat(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat^5(t⁰, ys¹)])}
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^15(rev^16(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ concat(t⁰, ys¹)]: 10 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [N]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [C h¹ [N]]: 22 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [N]: 24 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [N]: 30 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 2 [N]]: 31 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 1 [C 2 [N]]]: 32 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12 --->
//│ 	[C h⁰ concat(t⁰, ys¹)]: 10
//│ 	[N]: 21
//│ 	[C h¹ [N]]: 22
//│ 	[N]: 24
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25 --->
//│ 	[N]: 30
//│ 	[C 2 [N]]: 31
//│ 	[C 1 [C 2 [N]]]: 32
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 30 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 2 [N]]: 31 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 1 [C 2 [N]]]: 32 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ ------------------
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25 --->
//│ 	[N]: 30
//│ 	[C 2 [N]]: 31
//│ 	[C 1 [C 2 [N]]]: 32
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(
//│ 	let t² = 	
//│ 		let t³ = (fun _lh_dummy² -> [N])
//│ 		in let h³ = 2
//│ 		in (fun _lh_dummy¹ -> concat(rev(t³), [C h³ [N]]))
//│ 	in let h² = 1
//│ 	in (fun _lh_dummy⁰ -> concat(rev(t²), [C h² [N]])))
//│ def concat(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ concat(t⁰, ys³)])}
//│ def rev(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun _lh_dummy⁰ -> [N])
//│ 		in let h⁰ = 2
//│ 		in (fun _lh_dummy¹ -> concat(t¹(99), [C h⁰ [N]]))
//│ 	in let h¹ = 1
//│ 	in (fun _lh_dummy² -> concat(t⁰(99), [C h¹ [N]]))(99)
//│ def concat(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h² t² => (fun ys¹ -> [C h² concat(t², ys¹)])}
//│ def rev(ls⁰) = ls⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun _lh_dummy⁰ -> [N])
//│ 		in let h⁰ = 2
//│ 		in (fun _lh_dummy¹ -> concat(t¹(99), [C h⁰ [N]]))
//│ 	in let h¹ = 1
//│ 	in (fun _lh_dummy² -> concat(t⁰(99), [C h¹ [N]]))(99)
//│ def concat(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h² t² => (fun ys¹ -> [C h² concat(t², ys¹)])}
//│ def rev(ls⁰) = ls⁰(99)
//│ <<<<<<< after floating out <<<<<<<


// CORRECT: but will be WRONG: if strategy-filtering is strict, since y is a destination of [C 1 N]
fun f(x) = if A(x) is
  A(y) then if x is
    C(h, t) then t
f(C(1, N))
//│ |#fun| |f|(|x|)| |#=| |#if| |A|(|x|)| |is|→|A|(|y|)| |#then| |#if| |x| |is|→|C|(|h|,| |t|)| |#then| |t|←|←|↵|f|(|C|(|1|,| |N|)|)|
//│ Parsed: {fun f = x, => if A (x,) is ‹(A (y,)) then if x is ‹(C (h, t,)) then t››; f (C (1, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^8([C 1 [N]])
//│ def f(x⁰) = case [A x⁰] of {
//│ 	A y⁰ => case x⁰ of {
//│ 		C h⁰ t⁰ => t⁰}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A x⁰]: 2 --->
//│ 	case [A x⁰] of {A y⁰ => case x⁰ of {C h⁰ t⁰ => t⁰}}: 6
//│ [C 1 [N]]: 11 --->
//│ 	DeadCodeCons
//│ 	case x⁰ of {C h⁰ t⁰ => t⁰}: 5
//│ ------------------
//│ case x⁰ of {C h⁰ t⁰ => t⁰}: 5 --->
//│ 	[C 1 [N]]: 11
//│ case [A x⁰] of {A y⁰ => case x⁰ of {C h⁰ t⁰ => t⁰}}: 6 --->
//│ 	[A x⁰]: 2
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A x⁰]: 2 --->
//│ 	case [A x⁰] of {A y⁰ => case x⁰ of {C h⁰ t⁰ => t⁰}}: 6
//│ ------------------
//│ case [A x⁰] of {A y⁰ => case x⁰ of {C h⁰ t⁰ => t⁰}}: 6 --->
//│ 	[A x⁰]: 2
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C 1 [N]])
//│ def f(x¹) = 
//│ 	let y¹ = x¹
//│ 	in (fun x² -> case x² of {
//│ 		C h⁰ t⁰ => t⁰})(x¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ f
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let y⁰ = [C 1 [N]]
//│ 	in (fun x⁰ -> case x⁰ of {
//│ 		C h⁰ t⁰ => t⁰})([C 1 [N]])
//│ def f(x¹) = 
//│ 	let y¹ = x¹
//│ 	in (fun x² -> case x² of {
//│ 		C h¹ t¹ => t¹})(x¹)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let y⁰ = [C 1 [N]]
//│ 	in (fun x⁰ -> case x⁰ of {
//│ 		C h⁰ t⁰ => t⁰})([C 1 [N]])
//│ def f(x¹) = 
//│ 	let y¹ = x¹
//│ 	in (fun x² -> case x² of {
//│ 		C h¹ t¹ => t¹})(x¹)
//│ <<<<<<< after floating out <<<<<<<

// CORRECT: after using `last(C(hh, tt))` instead of `last(t)` and pushing in of parameters
_LUMBERHACK_EVAL
fun last(ls) = if ls is
  C(h, t) then
    (
      if t is
        N then h => Some(h)
        C(hh, tt) then h => last(C(hh, tt))
    )(h)
  N then None
last(C(1, C(2, C(3, N))))
//│ |_LUMBERHACK_EVAL|↵|#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then|→|(|→|#if| |t| |is|→|N| |#then| |h| |=>| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |h| |=>| |last|(|C|(|hh|,| |tt|)|)|←|←|↵|)|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun last = ls, => if ls is ‹(C (h, t,)) then {'(' if t is ‹(N) then h, => Some (h,); (C (hh, tt,)) then h, => last (C (hh, tt,),)›, ')' (h,)}; (N) then None›; last (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ last^18([C 1 [C 2 [C 3 [N]]]])
//│ def last(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N  => (fun h¹ -> [Some h¹])
//│ 		| C hh⁰ tt⁰ => (fun h² -> last^6([C hh⁰ tt⁰]))}(h⁰)
//│ 	| N  => [None]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [Some 3]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh⁰ tt⁰]: 9 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case t⁰ of {N  => (fun h¹ -> [Some h¹]) | C hh⁰ tt⁰ => (fun h² -> last([C hh⁰ tt⁰]))}(h⁰) | N  => [None]}: 16
//│ [N]: 22 --->
//│ 	case t⁰ of {N  => (fun h¹ -> [Some h¹]) | C hh⁰ tt⁰ => (fun h² -> last([C hh⁰ tt⁰]))}: 12
//│ [C 3 [N]]: 23 --->
//│ 	case t⁰ of {N  => (fun h¹ -> [Some h¹]) | C hh⁰ tt⁰ => (fun h² -> last([C hh⁰ tt⁰]))}: 12
//│ [C 2 [C 3 [N]]]: 24 --->
//│ 	case t⁰ of {N  => (fun h¹ -> [Some h¹]) | C hh⁰ tt⁰ => (fun h² -> last([C hh⁰ tt⁰]))}: 12
//│ [C 1 [C 2 [C 3 [N]]]]: 25 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case t⁰ of {N  => (fun h¹ -> [Some h¹]) | C hh⁰ tt⁰ => (fun h² -> last([C hh⁰ tt⁰]))}(h⁰) | N  => [None]}: 16
//│ ------------------
//│ case t⁰ of {N  => (fun h¹ -> [Some h¹]) | C hh⁰ tt⁰ => (fun h² -> last([C hh⁰ tt⁰]))}: 12 --->
//│ 	[N]: 22
//│ 	[C 3 [N]]: 23
//│ 	[C 2 [C 3 [N]]]: 24
//│ case ls⁰ of {C h⁰ t⁰ => case t⁰ of {N  => (fun h¹ -> [Some h¹]) | C hh⁰ tt⁰ => (fun h² -> last([C hh⁰ tt⁰]))}(h⁰) | N  => [None]}: 16 --->
//│ 	[C hh⁰ tt⁰]: 9
//│ 	[C 1 [C 2 [C 3 [N]]]]: 25
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 22 --->
//│ 	case t⁰ of {N  => (fun h¹ -> [Some h¹]) | C hh⁰ tt⁰ => (fun h² -> last([C hh⁰ tt⁰]))}: 12
//│ [C 3 [N]]: 23 --->
//│ 	case t⁰ of {N  => (fun h¹ -> [Some h¹]) | C hh⁰ tt⁰ => (fun h² -> last([C hh⁰ tt⁰]))}: 12
//│ [C 2 [C 3 [N]]]: 24 --->
//│ 	case t⁰ of {N  => (fun h¹ -> [Some h¹]) | C hh⁰ tt⁰ => (fun h² -> last([C hh⁰ tt⁰]))}: 12
//│ ------------------
//│ case t⁰ of {N  => (fun h¹ -> [Some h¹]) | C hh⁰ tt⁰ => (fun h² -> last([C hh⁰ tt⁰]))}: 12 --->
//│ 	[N]: 22
//│ 	[C 3 [N]]: 23
//│ 	[C 2 [C 3 [N]]]: 24
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ last([C 1 
//│ 	let tt¹ = 	
//│ 		let tt² = (fun h⁵ -> [Some h⁵])
//│ 		in let hh² = 3
//│ 		in (fun h⁴ -> last([C hh² tt²]))
//│ 	in let hh¹ = 2
//│ 	in (fun h³ -> last([C hh¹ tt¹]))])
//│ def last(ls¹) = case ls¹ of {
//│ 	C h⁰ t⁰ => t⁰(h⁰)
//│ 	| N  => [None]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 3]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ last
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ case [C 1 
//│ 	let tt⁰ = 	
//│ 		let tt¹ = (fun h⁰ -> [Some h⁰])
//│ 		in let hh⁰ = 3
//│ 		in (fun h¹ -> case [C hh⁰ tt¹] of {
//│ 			C h² t⁰ => t⁰(h²)
//│ 			| N  => [None]})
//│ 	in let hh¹ = 2
//│ 	in (fun h³ -> case [C hh¹ tt⁰] of {
//│ 		C h⁴ t¹ => t¹(h⁴)
//│ 		| N  => [None]})] of {
//│ 	C h⁵ t² => t²(h⁵)
//│ 	| N  => [None]}
//│ def last(ls⁰) = case ls⁰ of {
//│ 	C h⁶ t³ => t³(h⁶)
//│ 	| N  => [None]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ case [C 1 
//│ 	let tt⁰ = 	
//│ 		let tt¹ = (fun h⁰ -> [Some h⁰])
//│ 		in let hh⁰ = 3
//│ 		in (fun h¹ -> case [C hh⁰ tt¹] of {
//│ 			C h² t⁰ => t⁰(h²)
//│ 			| N  => [None]})
//│ 	in let hh¹ = 2
//│ 	in (fun h³ -> case [C hh¹ tt⁰] of {
//│ 		C h⁴ t¹ => t¹(h⁴)
//│ 		| N  => [None]})] of {
//│ 	C h⁵ t² => t²(h⁵)
//│ 	| N  => [None]}
//│ def last(ls⁰) = case ls⁰ of {
//│ 	C h⁶ t³ => t³(h⁶)
//│ 	| N  => [None]}
//│ <<<<<<< after floating out <<<<<<<


fun f(x) = if primitive(x) then A(x) else B(x + 1)
fun g(scrut, y) = if scrut is
  A(n) then y + n + 1
  B(m) then y + m
g(f(1), 2)
//│ |#fun| |f|(|x|)| |#=| |#if| |primitive|(|x|)| |#then| |A|(|x|)| |#else| |B|(|x| |+| |1|)|↵|#fun| |g|(|scrut|,| |y|)| |#=| |#if| |scrut| |is|→|A|(|n|)| |#then| |y| |+| |n| |+| |1|↵|B|(|m|)| |#then| |y| |+| |m|←|↵|g|(|f|(|1|)|,| |2|)|
//│ Parsed: {fun f = x, => if (primitive (x,)) then A (x,) else B (+ (x,) (1,),); fun g = scrut, y, => if scrut is ‹(A (n,)) then + (+ (y,) (n,),) (1,); (B (m,)) then + (y,) (m,)›; g (f (1,), 2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ g^32(f^33(1), 2)
//│ def f(x⁰) = if primitive⁰(x⁰) then [A x⁰] else [B (x⁰ + 1)]
//│ def g(scrut⁰, y⁰) = case scrut⁰ of {
//│ 	A n⁰ => ((y⁰ + n⁰) + 1)
//│ 	| B m⁰ => (y⁰ + m⁰)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A x⁰]: 5 --->
//│ 	case scrut⁰ of {A n⁰ => ((y⁰ + n⁰) + 1) | B m⁰ => (y⁰ + m⁰)}: 29
//│ [B (x⁰ + 1)]: 11 --->
//│ 	case scrut⁰ of {A n⁰ => ((y⁰ + n⁰) + 1) | B m⁰ => (y⁰ + m⁰)}: 29
//│ ------------------
//│ case scrut⁰ of {A n⁰ => ((y⁰ + n⁰) + 1) | B m⁰ => (y⁰ + m⁰)}: 29 --->
//│ 	[A x⁰]: 5
//│ 	[B (x⁰ + 1)]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A x⁰]: 5 --->
//│ 	case scrut⁰ of {A n⁰ => ((y⁰ + n⁰) + 1) | B m⁰ => (y⁰ + m⁰)}: 29
//│ [B (x⁰ + 1)]: 11 --->
//│ 	case scrut⁰ of {A n⁰ => ((y⁰ + n⁰) + 1) | B m⁰ => (y⁰ + m⁰)}: 29
//│ ------------------
//│ case scrut⁰ of {A n⁰ => ((y⁰ + n⁰) + 1) | B m⁰ => (y⁰ + m⁰)}: 29 --->
//│ 	[A x⁰]: 5
//│ 	[B (x⁰ + 1)]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ g(f(1), 2)
//│ def f(x¹) = if primitive⁰(x¹) then 
//│ 	let n¹ = x¹
//│ 	in (fun y¹ -> ((y¹ + n¹) + 1)) else 
//│ 	let m¹ = (x¹ + 1)
//│ 	in (fun y² -> (y² + m¹))
//│ def g(scrut¹, y³) = scrut¹(y³)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ g
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ f -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f(1, 2)
//│ def f(x⁰) = if primitive⁰(x⁰) then 
//│ 	let n⁰ = x⁰
//│ 	in (fun y⁰ -> ((y⁰ + n⁰) + 1)) else 
//│ 	let m⁰ = (x⁰ + 1)
//│ 	in (fun y¹ -> (y¹ + m⁰))
//│ def g(scrut⁰, y²) = scrut⁰(y²)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f(1, 2)
//│ def f(x⁰, _lh_popOutId_0⁰) = if primitive⁰(x⁰) then 
//│ 	let n⁰ = x⁰
//│ 	in ((_lh_popOutId_0⁰ + n⁰) + 1) else 
//│ 	let m⁰ = (x⁰ + 1)
//│ 	in (_lh_popOutId_0⁰ + m⁰)
//│ def g(scrut⁰, y⁰) = scrut⁰(y⁰)
//│ <<<<<<< after floating out <<<<<<<


:lhInHaskell
ack m n = case m of
          Z -> S n
          S m' -> case n of
                    Z -> ack m' (S Z)
                    S n' -> ack m' (ack m n')
ack (S (S (S Z))) (S (S Z))
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ack_lh_₁^30([S [S [S [Z]]]], [S [S [Z]]])
//│ def ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_arg2⁰) = 
//│ 	let _lh_matchIdent⁰ = _lh_ack_arg1⁰
//│ 	in case _lh_matchIdent⁰ of {
//│ 		Z  => [S _lh_ack_arg2⁰]
//│ 		| S _lh_ack_S_0⁰ => 
//│ 			let _lh_matchIdent¹ = _lh_ack_arg2⁰
//│ 			in case _lh_matchIdent¹ of {
//│ 				Z  => ack_lh_₁^7(_lh_ack_S_0⁰, [S [Z]])
//│ 				| S _lh_ack_S_0¹ => ack_lh_₁^13(_lh_ack_S_0⁰, ack_lh_₁^16(_lh_ack_arg1⁰, _lh_ack_S_0¹))
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S _lh_ack_arg2⁰]: 4 --->
//│ 	NoCons
//│ 	case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰}: 23
//│ [Z]: 10 --->
//│ 	NoCons
//│ 	case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰}: 23
//│ [S [Z]]: 11 --->
//│ 	NoCons
//│ 	case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰}: 23
//│ [Z]: 31 --->
//│ 	case _lh_matchIdent⁰ of {Z  => [S _lh_ack_arg2⁰] | S _lh_ack_S_0⁰ => let _lh_matchIdent¹ = _lh_ack_arg2⁰
//│ in case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰} | _  => error⁰}: 26
//│ [S [Z]]: 32 --->
//│ 	case _lh_matchIdent⁰ of {Z  => [S _lh_ack_arg2⁰] | S _lh_ack_S_0⁰ => let _lh_matchIdent¹ = _lh_ack_arg2⁰
//│ in case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰} | _  => error⁰}: 26
//│ [S [S [Z]]]: 33 --->
//│ 	case _lh_matchIdent⁰ of {Z  => [S _lh_ack_arg2⁰] | S _lh_ack_S_0⁰ => let _lh_matchIdent¹ = _lh_ack_arg2⁰
//│ in case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰} | _  => error⁰}: 26
//│ [S [S [S [Z]]]]: 34 --->
//│ 	case _lh_matchIdent⁰ of {Z  => [S _lh_ack_arg2⁰] | S _lh_ack_S_0⁰ => let _lh_matchIdent¹ = _lh_ack_arg2⁰
//│ in case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰} | _  => error⁰}: 26
//│ [Z]: 36 --->
//│ 	NoCons
//│ 	case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰}: 23
//│ [S [Z]]: 37 --->
//│ 	NoCons
//│ 	case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰}: 23
//│ [S [S [Z]]]: 38 --->
//│ 	NoCons
//│ 	case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰}: 23
//│ ------------------
//│ case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰}: 23 --->
//│ 	[S _lh_ack_arg2⁰]: 4
//│ 	[Z]: 10
//│ 	[S [Z]]: 11
//│ 	[Z]: 36
//│ 	[S [Z]]: 37
//│ 	[S [S [Z]]]: 38
//│ case _lh_matchIdent⁰ of {Z  => [S _lh_ack_arg2⁰] | S _lh_ack_S_0⁰ => let _lh_matchIdent¹ = _lh_ack_arg2⁰
//│ in case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰} | _  => error⁰}: 26 --->
//│ 	[Z]: 31
//│ 	[S [Z]]: 32
//│ 	[S [S [Z]]]: 33
//│ 	[S [S [S [Z]]]]: 34
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Z]: 31 --->
//│ 	case _lh_matchIdent⁰ of {Z  => [S _lh_ack_arg2⁰] | S _lh_ack_S_0⁰ => let _lh_matchIdent¹ = _lh_ack_arg2⁰
//│ in case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰} | _  => error⁰}: 26
//│ [S [Z]]: 32 --->
//│ 	case _lh_matchIdent⁰ of {Z  => [S _lh_ack_arg2⁰] | S _lh_ack_S_0⁰ => let _lh_matchIdent¹ = _lh_ack_arg2⁰
//│ in case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰} | _  => error⁰}: 26
//│ [S [S [Z]]]: 33 --->
//│ 	case _lh_matchIdent⁰ of {Z  => [S _lh_ack_arg2⁰] | S _lh_ack_S_0⁰ => let _lh_matchIdent¹ = _lh_ack_arg2⁰
//│ in case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰} | _  => error⁰}: 26
//│ [S [S [S [Z]]]]: 34 --->
//│ 	case _lh_matchIdent⁰ of {Z  => [S _lh_ack_arg2⁰] | S _lh_ack_S_0⁰ => let _lh_matchIdent¹ = _lh_ack_arg2⁰
//│ in case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰} | _  => error⁰}: 26
//│ ------------------
//│ case _lh_matchIdent⁰ of {Z  => [S _lh_ack_arg2⁰] | S _lh_ack_S_0⁰ => let _lh_matchIdent¹ = _lh_ack_arg2⁰
//│ in case _lh_matchIdent¹ of {Z  => ack_lh_₁(_lh_ack_S_0⁰, [S [Z]]) | S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁰, ack_lh_₁(_lh_ack_arg1⁰, _lh_ack_S_0¹)) | _  => error⁰} | _  => error⁰}: 26 --->
//│ 	[Z]: 31
//│ 	[S [Z]]: 32
//│ 	[S [S [Z]]]: 33
//│ 	[S [S [S [Z]]]]: 34
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ack_lh_₁(
//│ 	let _lh_ack_S_0² = 	
//│ 		let _lh_ack_S_0³ = 	
//│ 			let _lh_ack_S_0⁴ = (fun _lh_ack_arg2⁴ -> (fun _lh_ack_arg1⁴ -> [S _lh_ack_arg2⁴]))
//│ 			in (fun _lh_ack_arg2³ -> (fun _lh_ack_arg1³ -> 
//│ 				let _lh_matchIdent⁴ = _lh_ack_arg2³
//│ 				in case _lh_matchIdent⁴ of {
//│ 					Z  => ack_lh_₁(_lh_ack_S_0⁴, [S [Z]])
//│ 					| S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0⁴, ack_lh_₁(_lh_ack_arg1³, _lh_ack_S_0¹))
//│ 					| _  => error⁰}))
//│ 		in (fun _lh_ack_arg2² -> (fun _lh_ack_arg1² -> 
//│ 			let _lh_matchIdent³ = _lh_ack_arg2²
//│ 			in case _lh_matchIdent³ of {
//│ 				Z  => ack_lh_₁(_lh_ack_S_0³, [S [Z]])
//│ 				| S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0³, ack_lh_₁(_lh_ack_arg1², _lh_ack_S_0¹))
//│ 				| _  => error⁰}))
//│ 	in (fun _lh_ack_arg2¹ -> (fun _lh_ack_arg1¹ -> 
//│ 		let _lh_matchIdent² = _lh_ack_arg2¹
//│ 		in case _lh_matchIdent² of {
//│ 			Z  => ack_lh_₁(_lh_ack_S_0², [S [Z]])
//│ 			| S _lh_ack_S_0¹ => ack_lh_₁(_lh_ack_S_0², ack_lh_₁(_lh_ack_arg1¹, _lh_ack_S_0¹))
//│ 			| _  => error⁰})), [S [S [Z]]])
//│ def ack_lh_₁(_lh_ack_arg1⁵, _lh_ack_arg2⁵) = 
//│ 	let _lh_matchIdent⁵ = _lh_ack_arg1⁵
//│ 	in _lh_matchIdent⁵(_lh_ack_arg2⁵, _lh_ack_arg1⁵)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ ack_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ let _lh_matchIdent⁰ = 	
//│ 	let _lh_ack_S_0⁰ = 	
//│ 		let _lh_ack_S_0¹ = 	
//│ 			let _lh_ack_S_0² = (fun _lh_ack_arg2⁰ -> (fun _lh_ack_arg1⁰ -> [S _lh_ack_arg2⁰]))
//│ 			in (fun _lh_ack_arg2¹ -> (fun _lh_ack_arg1¹ -> 
//│ 				let _lh_matchIdent¹ = _lh_ack_arg2¹
//│ 				in case _lh_matchIdent¹ of {
//│ 					Z  => 
//│ 						let _lh_matchIdent² = _lh_ack_S_0²
//│ 						in _lh_matchIdent²([S [Z]], _lh_ack_S_0²)
//│ 					| S _lh_ack_S_0³ => 
//│ 						let _lh_matchIdent³ = _lh_ack_S_0²
//│ 						in _lh_matchIdent³(
//│ 							let _lh_matchIdent⁴ = _lh_ack_arg1¹
//│ 							in _lh_matchIdent⁴(_lh_ack_S_0³, _lh_ack_arg1¹), _lh_ack_S_0²)
//│ 					| _  => error⁰}))
//│ 		in (fun _lh_ack_arg2² -> (fun _lh_ack_arg1² -> 
//│ 			let _lh_matchIdent⁵ = _lh_ack_arg2²
//│ 			in case _lh_matchIdent⁵ of {
//│ 				Z  => 
//│ 					let _lh_matchIdent⁶ = _lh_ack_S_0¹
//│ 					in _lh_matchIdent⁶([S [Z]], _lh_ack_S_0¹)
//│ 				| S _lh_ack_S_0⁴ => 
//│ 					let _lh_matchIdent⁷ = _lh_ack_S_0¹
//│ 					in _lh_matchIdent⁷(
//│ 						let _lh_matchIdent⁸ = _lh_ack_arg1²
//│ 						in _lh_matchIdent⁸(_lh_ack_S_0⁴, _lh_ack_arg1²), _lh_ack_S_0¹)
//│ 				| _  => error⁰}))
//│ 	in (fun _lh_ack_arg2³ -> (fun _lh_ack_arg1³ -> 
//│ 		let _lh_matchIdent⁹ = _lh_ack_arg2³
//│ 		in case _lh_matchIdent⁹ of {
//│ 			Z  => 
//│ 				let _lh_matchIdent¹⁰ = _lh_ack_S_0⁰
//│ 				in _lh_matchIdent¹⁰([S [Z]], _lh_ack_S_0⁰)
//│ 			| S _lh_ack_S_0⁵ => 
//│ 				let _lh_matchIdent¹¹ = _lh_ack_S_0⁰
//│ 				in _lh_matchIdent¹¹(
//│ 					let _lh_matchIdent¹² = _lh_ack_arg1³
//│ 					in _lh_matchIdent¹²(_lh_ack_S_0⁵, _lh_ack_arg1³), _lh_ack_S_0⁰)
//│ 			| _  => error⁰}))
//│ in _lh_matchIdent⁰([S [S [Z]]], 
//│ 	let _lh_ack_S_0⁶ = 	
//│ 		let _lh_ack_S_0⁷ = 	
//│ 			let _lh_ack_S_0⁸ = (fun _lh_ack_arg2⁴ -> (fun _lh_ack_arg1⁴ -> [S _lh_ack_arg2⁴]))
//│ 			in (fun _lh_ack_arg2⁵ -> (fun _lh_ack_arg1⁵ -> 
//│ 				let _lh_matchIdent¹³ = _lh_ack_arg2⁵
//│ 				in case _lh_matchIdent¹³ of {
//│ 					Z  => 
//│ 						let _lh_matchIdent¹⁴ = _lh_ack_S_0⁸
//│ 						in _lh_matchIdent¹⁴([S [Z]], _lh_ack_S_0⁸)
//│ 					| S _lh_ack_S_0⁹ => 
//│ 						let _lh_matchIdent¹⁵ = _lh_ack_S_0⁸
//│ 						in _lh_matchIdent¹⁵(
//│ 							let _lh_matchIdent¹⁶ = _lh_ack_arg1⁵
//│ 							in _lh_matchIdent¹⁶(_lh_ack_S_0⁹, _lh_ack_arg1⁵), _lh_ack_S_0⁸)
//│ 					| _  => error⁰}))
//│ 		in (fun _lh_ack_arg2⁶ -> (fun _lh_ack_arg1⁶ -> 
//│ 			let _lh_matchIdent¹⁷ = _lh_ack_arg2⁶
//│ 			in case _lh_matchIdent¹⁷ of {
//│ 				Z  => 
//│ 					let _lh_matchIdent¹⁸ = _lh_ack_S_0⁷
//│ 					in _lh_matchIdent¹⁸([S [Z]], _lh_ack_S_0⁷)
//│ 				| S _lh_ack_S_0¹⁰ => 
//│ 					let _lh_matchIdent¹⁹ = _lh_ack_S_0⁷
//│ 					in _lh_matchIdent¹⁹(
//│ 						let _lh_matchIdent²⁰ = _lh_ack_arg1⁶
//│ 						in _lh_matchIdent²⁰(_lh_ack_S_0¹⁰, _lh_ack_arg1⁶), _lh_ack_S_0⁷)
//│ 				| _  => error⁰}))
//│ 	in (fun _lh_ack_arg2⁷ -> (fun _lh_ack_arg1⁷ -> 
//│ 		let _lh_matchIdent²¹ = _lh_ack_arg2⁷
//│ 		in case _lh_matchIdent²¹ of {
//│ 			Z  => 
//│ 				let _lh_matchIdent²² = _lh_ack_S_0⁶
//│ 				in _lh_matchIdent²²([S [Z]], _lh_ack_S_0⁶)
//│ 			| S _lh_ack_S_0¹¹ => 
//│ 				let _lh_matchIdent²³ = _lh_ack_S_0⁶
//│ 				in _lh_matchIdent²³(
//│ 					let _lh_matchIdent²⁴ = _lh_ack_arg1⁷
//│ 					in _lh_matchIdent²⁴(_lh_ack_S_0¹¹, _lh_ack_arg1⁷), _lh_ack_S_0⁶)
//│ 			| _  => error⁰})))
//│ def ack_lh_₁(_lh_ack_arg1⁸, _lh_ack_arg2⁸) = 
//│ 	let _lh_matchIdent²⁵ = _lh_ack_arg1⁸
//│ 	in _lh_matchIdent²⁵(_lh_ack_arg2⁸, _lh_ack_arg1⁸)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ let _lh_matchIdent⁰ = 	
//│ 	let _lh_ack_S_0⁰ = 	
//│ 		let _lh_ack_S_0¹ = 	
//│ 			let _lh_ack_S_0² = (fun _lh_ack_arg2⁰ -> (fun _lh_ack_arg1⁰ -> [S _lh_ack_arg2⁰]))
//│ 			in (fun _lh_ack_arg2¹ -> (fun _lh_ack_arg1¹ -> 
//│ 				let _lh_matchIdent¹ = _lh_ack_arg2¹
//│ 				in case _lh_matchIdent¹ of {
//│ 					Z  => 
//│ 						let _lh_matchIdent² = _lh_ack_S_0²
//│ 						in _lh_matchIdent²([S [Z]], _lh_ack_S_0²)
//│ 					| S _lh_ack_S_0³ => 
//│ 						let _lh_matchIdent³ = _lh_ack_S_0²
//│ 						in _lh_matchIdent³(
//│ 							let _lh_matchIdent⁴ = _lh_ack_arg1¹
//│ 							in _lh_matchIdent⁴(_lh_ack_S_0³, _lh_ack_arg1¹), _lh_ack_S_0²)
//│ 					| _  => error⁰}))
//│ 		in (fun _lh_ack_arg2² -> (fun _lh_ack_arg1² -> 
//│ 			let _lh_matchIdent⁵ = _lh_ack_arg2²
//│ 			in case _lh_matchIdent⁵ of {
//│ 				Z  => 
//│ 					let _lh_matchIdent⁶ = _lh_ack_S_0¹
//│ 					in _lh_matchIdent⁶([S [Z]], _lh_ack_S_0¹)
//│ 				| S _lh_ack_S_0⁴ => 
//│ 					let _lh_matchIdent⁷ = _lh_ack_S_0¹
//│ 					in _lh_matchIdent⁷(
//│ 						let _lh_matchIdent⁸ = _lh_ack_arg1²
//│ 						in _lh_matchIdent⁸(_lh_ack_S_0⁴, _lh_ack_arg1²), _lh_ack_S_0¹)
//│ 				| _  => error⁰}))
//│ 	in (fun _lh_ack_arg2³ -> (fun _lh_ack_arg1³ -> 
//│ 		let _lh_matchIdent⁹ = _lh_ack_arg2³
//│ 		in case _lh_matchIdent⁹ of {
//│ 			Z  => 
//│ 				let _lh_matchIdent¹⁰ = _lh_ack_S_0⁰
//│ 				in _lh_matchIdent¹⁰([S [Z]], _lh_ack_S_0⁰)
//│ 			| S _lh_ack_S_0⁵ => 
//│ 				let _lh_matchIdent¹¹ = _lh_ack_S_0⁰
//│ 				in _lh_matchIdent¹¹(
//│ 					let _lh_matchIdent¹² = _lh_ack_arg1³
//│ 					in _lh_matchIdent¹²(_lh_ack_S_0⁵, _lh_ack_arg1³), _lh_ack_S_0⁰)
//│ 			| _  => error⁰}))
//│ in _lh_matchIdent⁰([S [S [Z]]], 
//│ 	let _lh_ack_S_0⁶ = 	
//│ 		let _lh_ack_S_0⁷ = 	
//│ 			let _lh_ack_S_0⁸ = (fun _lh_ack_arg2⁴ -> (fun _lh_ack_arg1⁴ -> [S _lh_ack_arg2⁴]))
//│ 			in (fun _lh_ack_arg2⁵ -> (fun _lh_ack_arg1⁵ -> 
//│ 				let _lh_matchIdent¹³ = _lh_ack_arg2⁵
//│ 				in case _lh_matchIdent¹³ of {
//│ 					Z  => 
//│ 						let _lh_matchIdent¹⁴ = _lh_ack_S_0⁸
//│ 						in _lh_matchIdent¹⁴([S [Z]], _lh_ack_S_0⁸)
//│ 					| S _lh_ack_S_0⁹ => 
//│ 						let _lh_matchIdent¹⁵ = _lh_ack_S_0⁸
//│ 						in _lh_matchIdent¹⁵(
//│ 							let _lh_matchIdent¹⁶ = _lh_ack_arg1⁵
//│ 							in _lh_matchIdent¹⁶(_lh_ack_S_0⁹, _lh_ack_arg1⁵), _lh_ack_S_0⁸)
//│ 					| _  => error⁰}))
//│ 		in (fun _lh_ack_arg2⁶ -> (fun _lh_ack_arg1⁶ -> 
//│ 			let _lh_matchIdent¹⁷ = _lh_ack_arg2⁶
//│ 			in case _lh_matchIdent¹⁷ of {
//│ 				Z  => 
//│ 					let _lh_matchIdent¹⁸ = _lh_ack_S_0⁷
//│ 					in _lh_matchIdent¹⁸([S [Z]], _lh_ack_S_0⁷)
//│ 				| S _lh_ack_S_0¹⁰ => 
//│ 					let _lh_matchIdent¹⁹ = _lh_ack_S_0⁷
//│ 					in _lh_matchIdent¹⁹(
//│ 						let _lh_matchIdent²⁰ = _lh_ack_arg1⁶
//│ 						in _lh_matchIdent²⁰(_lh_ack_S_0¹⁰, _lh_ack_arg1⁶), _lh_ack_S_0⁷)
//│ 				| _  => error⁰}))
//│ 	in (fun _lh_ack_arg2⁷ -> (fun _lh_ack_arg1⁷ -> 
//│ 		let _lh_matchIdent²¹ = _lh_ack_arg2⁷
//│ 		in case _lh_matchIdent²¹ of {
//│ 			Z  => 
//│ 				let _lh_matchIdent²² = _lh_ack_S_0⁶
//│ 				in _lh_matchIdent²²([S [Z]], _lh_ack_S_0⁶)
//│ 			| S _lh_ack_S_0¹¹ => 
//│ 				let _lh_matchIdent²³ = _lh_ack_S_0⁶
//│ 				in _lh_matchIdent²³(
//│ 					let _lh_matchIdent²⁴ = _lh_ack_arg1⁷
//│ 					in _lh_matchIdent²⁴(_lh_ack_S_0¹¹, _lh_ack_arg1⁷), _lh_ack_S_0⁶)
//│ 			| _  => error⁰})))
//│ def ack_lh_₁(_lh_ack_arg1⁸, _lh_ack_arg2⁸) = 
//│ 	let _lh_matchIdent²⁵ = _lh_ack_arg1⁸
//│ 	in _lh_matchIdent²⁵(_lh_ack_arg2⁸, _lh_ack_arg1⁸)
//│ <<<<<<< after floating out <<<<<<<

:lhInHaskell
:lhEval
test n = foldl (\a b -> a + b) 0 [1..n]
test $ primId 10
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ test_lh_₁^56(primId⁰(10))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^24((a⁰ + 1), b⁰)] else [LH_N]
//│ def foldl_lh_₁(f⁰, i⁰, ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => foldl_lh_₁^2(f⁰, f⁰(i⁰, h⁰), t⁰)
//│ 	| LH_N  => i⁰}
//│ def test_lh_₁(_lh_test_arg1⁰) = foldl_lh_₁^38((fun a¹ -> (fun b¹ -> (a¹ + b¹))), 0, enumFromTo_lh_₁^49(1, _lh_test_arg1⁰))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 55
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 33 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => foldl_lh_₁(f⁰, f⁰(i⁰, h⁰), t⁰) | LH_N  => i⁰}: 14
//│ [LH_N]: 34 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => foldl_lh_₁(f⁰, f⁰(i⁰, h⁰), t⁰) | LH_N  => i⁰}: 14
//│ ------------------
//│ case ls⁰ of {LH_C h⁰ t⁰ => foldl_lh_₁(f⁰, f⁰(i⁰, h⁰), t⁰) | LH_N  => i⁰}: 14 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 33
//│ 	[LH_N]: 34
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 33 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => foldl_lh_₁(f⁰, f⁰(i⁰, h⁰), t⁰) | LH_N  => i⁰}: 14
//│ [LH_N]: 34 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => foldl_lh_₁(f⁰, f⁰(i⁰, h⁰), t⁰) | LH_N  => i⁰}: 14
//│ ------------------
//│ case ls⁰ of {LH_C h⁰ t⁰ => foldl_lh_₁(f⁰, f⁰(i⁰, h⁰), t⁰) | LH_N  => i⁰}: 14 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 33
//│ 	[LH_N]: 34
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ test_lh_₁(primId⁰(10))
//│ def enumFromTo_lh_₁(a², b²) = if (a² <= b²) then 
//│ 	let t¹ = enumFromTo_lh_₁((a² + 1), b²)
//│ 	in let h¹ = a²
//│ 	in (fun f² -> (fun i² -> foldl_lh_₁(f², f²(i², h¹), t¹))) else (fun f³ -> (fun i³ -> i³))
//│ def foldl_lh_₁(f¹, i¹, ls¹) = ls¹(f¹, i¹)
//│ def test_lh_₁(_lh_test_arg1¹) = foldl_lh_₁((fun a³ -> (fun b³ -> (a³ + b³))), 0, enumFromTo_lh_₁(1, _lh_test_arg1¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 55
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ foldl_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₁ -> 4
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ test_lh_₁(primId⁰(10))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let t⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let h⁰ = a⁰
//│ 	in (fun f¹ -> (fun i¹ -> t⁰(f¹, f¹(i¹, h⁰)))) else (fun f² -> (fun i² -> i²))
//│ def foldl_lh_₁(f⁰, i⁰, ls⁰) = ls⁰(f⁰, i⁰)
//│ def test_lh_₁(_lh_test_arg1⁰) = enumFromTo_lh_₁(1, _lh_test_arg1⁰, (fun a¹ -> (fun b¹ -> (a¹ + b¹))), 0)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ test_lh_₁(primId⁰(10))
//│ def enumFromTo_lh_₁(a⁰, b⁰, _lh_popOutId_0⁰, _lh_popOutId_1⁰) = if (a⁰ <= b⁰) then 
//│ 	let t⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let h⁰ = a⁰
//│ 	in t⁰(_lh_popOutId_0⁰, _lh_popOutId_0⁰(_lh_popOutId_1⁰, h⁰)) else _lh_popOutId_1⁰
//│ def foldl_lh_₁(f⁰, i⁰, ls⁰) = ls⁰(f⁰, i⁰)
//│ def test_lh_₁(_lh_test_arg1⁰) = enumFromTo_lh_₁(1, _lh_test_arg1⁰, (fun a¹ -> (fun b¹ -> (a¹ + b¹))), 0)
//│ <<<<<<< after floating out <<<<<<<

:lhInHaskell
:lhEval
:lhGenDistill
test n = sum $ zipWith (\a b -> a * b) (primId [1..n]) (primId [n..(2*n)])
test $ primId 10
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ test_lh_₁^115(primId⁰(10))
//│ def enumFromTo_lh_₁(a², b¹) = if (a² <= b¹) then [LH_C a² enumFromTo_lh_₁^69((a² + 1), b¹)] else [LH_N]
//│ def enumFromTo_lh_₂(a¹, b⁰) = if (a¹ <= b⁰) then [LH_C a¹ enumFromTo_lh_₂^49((a¹ + 1), b⁰)] else [LH_N]
//│ def sumAux_lh_₁(ls⁰, a⁰) = case ls⁰ of {
//│ 	LH_N  => a⁰
//│ 	| LH_C h⁰ t⁰ => sumAux_lh_₁^3(t⁰, (a⁰ + h⁰))}
//│ def sum_lh_₁(ls¹) = sumAux_lh_₁^37(ls¹, 0)
//│ def test_lh_₁(_lh_test_arg1⁰) = sum_lh_₁^83(zipWith_lh_₁^84((fun a³ -> (fun b² -> (a³ * b²))), primId⁰(enumFromTo_lh_₂^94(1, _lh_test_arg1⁰)), primId⁰(enumFromTo_lh_₁^102(_lh_test_arg1⁰, (2 * _lh_test_arg1⁰)))))
//│ def zipWith_lh_₁(f⁰, xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₁^22(f⁰, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized distiller gen ----------
//│ 		main = (test_lh__d1 10);
//│ 		enumFromTo_lh__d1 a_2 b_1 =
//│ 		  (case (le a_2 b_1) of True -> ((LH_C(a_2, ((enumFromTo_lh__d1 (plus a_2 1)) b_1)))) | False -> ((LH_N)));
//│ 		enumFromTo_lh__d2 a_1 b_0 =
//│ 		  (case (le a_1 b_0) of True -> ((LH_C(a_1, ((enumFromTo_lh__d2 (plus a_1 1)) b_0)))) | False -> ((LH_N)));
//│ 		sumAux_lh__d1 ls_0 a_0 =
//│ 		  (case ls_0 of LH_N -> a_0 | LH_C(h_0, t_0) -> ((sumAux_lh__d1 t_0) (plus a_0 h_0)));
//│ 		sum_lh__d1 ls_1 =
//│ 		  ((sumAux_lh__d1 ls_1) 0);
//│ 		test_lh__d1 _lh_test_arg1_0 =
//│ 		  (sum_lh__d1 (((zipWith_lh__d1 (\a_3 b_2 -> (mul a_3 b_2))) ((enumFromTo_lh__d2 1) _lh_test_arg1_0)) ((enumFromTo_lh__d1 _lh_test_arg1_0) (mul 2 _lh_test_arg1_0))));
//│ 		zipWith_lh__d1 f_0 xs_0 ys_0 =
//│ 		  (case xs_0 of LH_C(hx_0, tx_0) -> (case ys_0 of LH_C(hy_0, ty_0) -> (LH_C(((f_0 hx_0) hy_0), (((zipWith_lh__d1 f_0) tx_0) ty_0))) | LH_N -> (LH_N)) | LH_N -> (LH_N))
//│ 		---------- unoptimized distiller gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 880
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₁(f⁰, tx⁰, ty⁰)]: 29 --->
//│ 	case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12
//│ [LH_N]: 30 --->
//│ 	case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12
//│ [LH_N]: 32 --->
//│ 	case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12
//│ ------------------
//│ case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12 --->
//│ 	[LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₁(f⁰, tx⁰, ty⁰)]: 29
//│ 	[LH_N]: 30
//│ 	[LH_N]: 32
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₁(f⁰, tx⁰, ty⁰)]: 29 --->
//│ 	case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12
//│ [LH_N]: 30 --->
//│ 	case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12
//│ [LH_N]: 32 --->
//│ 	case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12
//│ ------------------
//│ case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12 --->
//│ 	[LH_C f⁰(hx⁰, hy⁰) zipWith_lh_₁(f⁰, tx⁰, ty⁰)]: 29
//│ 	[LH_N]: 30
//│ 	[LH_N]: 32
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ test_lh_₁(primId⁰(10))
//│ def enumFromTo_lh_₁(a⁶, b⁵) = if (a⁶ <= b⁵) then [LH_C a⁶ enumFromTo_lh_₁((a⁶ + 1), b⁵)] else [LH_N]
//│ def enumFromTo_lh_₂(a⁵, b⁴) = if (a⁵ <= b⁴) then [LH_C a⁵ enumFromTo_lh_₂((a⁵ + 1), b⁴)] else [LH_N]
//│ def sumAux_lh_₁(ls³, a⁷) = ls³(a⁷)
//│ def sum_lh_₁(ls²) = sumAux_lh_₁(ls², 0)
//│ def test_lh_₁(_lh_test_arg1¹) = sum_lh_₁(zipWith_lh_₁((fun a⁴ -> (fun b³ -> (a⁴ * b³))), primId⁰(enumFromTo_lh_₂(1, _lh_test_arg1¹)), primId⁰(enumFromTo_lh_₁(_lh_test_arg1¹, (2 * _lh_test_arg1¹)))))
//│ def zipWith_lh_₁(f¹, xs¹, ys¹) = case xs¹ of {
//│ 	LH_C hx⁰ tx⁰ => case ys¹ of {
//│ 		LH_C hy⁰ ty⁰ => 
//│ 			let t¹ = zipWith_lh_₁(f¹, tx⁰, ty⁰)
//│ 			in let h¹ = f¹(hx⁰, hy⁰)
//│ 			in (fun a⁸ -> sumAux_lh_₁(t¹, (a⁸ + h¹)))
//│ 		| LH_N  => (fun a⁹ -> a⁹)}
//│ 	| LH_N  => (fun a¹⁰ -> a¹⁰)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 880
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ sumAux_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ zipWith_lh_₁ -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ test_lh_₁(primId⁰(10))
//│ def enumFromTo_lh_₁(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo_lh_₁((a² + 1), b²)] else [LH_N]
//│ def enumFromTo_lh_₂(a¹, b¹) = if (a¹ <= b¹) then [LH_C a¹ enumFromTo_lh_₂((a¹ + 1), b¹)] else [LH_N]
//│ def sumAux_lh_₁(ls¹, a³) = ls¹(a³)
//│ def sum_lh_₁(ls⁰) = ls⁰(0)
//│ def test_lh_₁(_lh_test_arg1⁰) = sum_lh_₁(zipWith_lh_₁((fun a⁰ -> (fun b⁰ -> (a⁰ * b⁰))), primId⁰(enumFromTo_lh_₂(1, _lh_test_arg1⁰)), primId⁰(enumFromTo_lh_₁(_lh_test_arg1⁰, (2 * _lh_test_arg1⁰)))))
//│ def zipWith_lh_₁(f⁰, xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => 
//│ 			let t⁰ = zipWith_lh_₁(f⁰, tx⁰, ty⁰)
//│ 			in let h⁰ = f⁰(hx⁰, hy⁰)
//│ 			in (fun a⁴ -> t⁰((a⁴ + h⁰)))
//│ 		| LH_N  => (fun a⁵ -> a⁵)}
//│ 	| LH_N  => (fun a⁶ -> a⁶)}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ test_lh_₁(primId⁰(10))
//│ def enumFromTo_lh_₁(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo_lh_₁((a² + 1), b²)] else [LH_N]
//│ def enumFromTo_lh_₂(a¹, b¹) = if (a¹ <= b¹) then [LH_C a¹ enumFromTo_lh_₂((a¹ + 1), b¹)] else [LH_N]
//│ def sumAux_lh_₁(ls¹, a³) = ls¹(a³)
//│ def sum_lh_₁(ls⁰) = ls⁰(0)
//│ def test_lh_₁(_lh_test_arg1⁰) = sum_lh_₁(zipWith_lh_₁((fun a⁰ -> (fun b⁰ -> (a⁰ * b⁰))), primId⁰(enumFromTo_lh_₂(1, _lh_test_arg1⁰)), primId⁰(enumFromTo_lh_₁(_lh_test_arg1⁰, (2 * _lh_test_arg1⁰)))))
//│ def zipWith_lh_₁(f⁰, xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => 
//│ 			let t⁰ = zipWith_lh_₁(f⁰, tx⁰, ty⁰)
//│ 			in let h⁰ = f⁰(hx⁰, hy⁰)
//│ 			in (fun a⁴ -> t⁰((a⁴ + h⁰)))
//│ 		| LH_N  => (fun a⁵ -> a⁵)}
//│ 	| LH_N  => (fun a⁶ -> a⁶)}
//│ <<<<<<< after floating out <<<<<<<

:lhInHaskell
:lhEval
fact r Z = S Z
fact r (S a) = mmul (S a) (r (mmin (S a) (S Z)))
pplus Z b = b
pplus (S a) b = S (pplus a b)
mmul Z b = Z
mmul (S a) b = pplus b (mmul a b)
mmin a b = case b of {
  Z -> a;
  (S bb) -> case a of {
    Z -> Z;
    (S aa) -> mmin aa bb
  }
}
let mainFact = (\x -> fact (\y -> x x y)) (\x -> fact (\y -> x x y)) in mainFact (primId (S (S (S Z))))
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ let mainFact⁰ = (fun x⁰ -> fact_lh_₁^135((fun y⁰ -> x⁰(x⁰, y⁰))))((fun x¹ -> fact_lh_₂^144((fun y¹ -> x¹(x¹, y¹)))))
//│ in mainFact⁰(primId⁰([S [S [S [Z]]]]))
//│ def fact_lh_₁(_lh_fact_arg1¹, _lh_fact_arg2¹) = case _lh_fact_arg2¹ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_fact_S_0¹ => mmul_lh_₁^117([S _lh_fact_S_0¹], _lh_fact_arg1¹(mmin_lh_₁^122([S _lh_fact_S_0¹], [S [Z]])))
//│ 	| _  => error⁰}
//│ def fact_lh_₂(_lh_fact_arg1⁰, _lh_fact_arg2⁰) = case _lh_fact_arg2⁰ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_fact_S_0⁰ => mmul_lh_₂^96([S _lh_fact_S_0⁰], _lh_fact_arg1⁰(mmin_lh_₂^101([S _lh_fact_S_0⁰], [S [Z]])))
//│ 	| _  => error⁰}
//│ def mmin_lh_₁(_lh_mmin_arg1¹, _lh_mmin_arg2¹) = 
//│ 	let _lh_matchIdent² = _lh_mmin_arg2¹
//│ 	in case _lh_matchIdent² of {
//│ 		Z  => _lh_mmin_arg1¹
//│ 		| S _lh_mmin_S_0² => 
//│ 			let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ 			in case _lh_matchIdent³ of {
//│ 				Z  => [Z]
//│ 				| S _lh_mmin_S_0³ => mmin_lh_₁^65(_lh_mmin_S_0³, _lh_mmin_S_0²)
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ def mmin_lh_₂(_lh_mmin_arg1⁰, _lh_mmin_arg2⁰) = 
//│ 	let _lh_matchIdent⁰ = _lh_mmin_arg2⁰
//│ 	in case _lh_matchIdent⁰ of {
//│ 		Z  => _lh_mmin_arg1⁰
//│ 		| S _lh_mmin_S_0⁰ => 
//│ 			let _lh_matchIdent¹ = _lh_mmin_arg1⁰
//│ 			in case _lh_matchIdent¹ of {
//│ 				Z  => [Z]
//│ 				| S _lh_mmin_S_0¹ => mmin_lh_₂^31(_lh_mmin_S_0¹, _lh_mmin_S_0⁰)
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ def mmul_lh_₁(_lh_mmul_arg1¹, _lh_mmul_arg2¹) = case _lh_mmul_arg1¹ of {
//│ 	Z  => [Z]
//│ 	| S _lh_mmul_S_0¹ => pplus_lh_₁^80(_lh_mmul_arg2¹, mmul_lh_₁^83(_lh_mmul_S_0¹, _lh_mmul_arg2¹))
//│ 	| _  => error⁰}
//│ def mmul_lh_₂(_lh_mmul_arg1⁰, _lh_mmul_arg2⁰) = case _lh_mmul_arg1⁰ of {
//│ 	Z  => [Z]
//│ 	| S _lh_mmul_S_0⁰ => pplus_lh_₂^46(_lh_mmul_arg2⁰, mmul_lh_₂^49(_lh_mmul_S_0⁰, _lh_mmul_arg2⁰))
//│ 	| _  => error⁰}
//│ def pplus_lh_₁(_lh_pplus_arg1¹, _lh_pplus_arg2¹) = case _lh_pplus_arg1¹ of {
//│ 	Z  => _lh_pplus_arg2¹
//│ 	| S _lh_pplus_S_0¹ => [S pplus_lh_₁^15(_lh_pplus_S_0¹, _lh_pplus_arg2¹)]
//│ 	| _  => error⁰}
//│ def pplus_lh_₂(_lh_pplus_arg1⁰, _lh_pplus_arg2⁰) = case _lh_pplus_arg1⁰ of {
//│ 	Z  => _lh_pplus_arg2⁰
//│ 	| S _lh_pplus_S_0⁰ => [S pplus_lh_₂^3(_lh_pplus_S_0⁰, _lh_pplus_arg2⁰)]
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [S [S [S [S [S [S [Z]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S pplus_lh_₂(_lh_pplus_S_0⁰, _lh_pplus_arg2⁰)]: 8 --->
//│ 	case _lh_pplus_arg1⁰ of {Z  => _lh_pplus_arg2⁰ | S _lh_pplus_S_0⁰ => [S pplus_lh_₂(_lh_pplus_S_0⁰, _lh_pplus_arg2⁰)] | _  => error⁰}: 10
//│ 	case _lh_pplus_arg1¹ of {Z  => _lh_pplus_arg2¹ | S _lh_pplus_S_0¹ => [S pplus_lh_₁(_lh_pplus_S_0¹, _lh_pplus_arg2¹)] | _  => error⁰}: 22
//│ [Z]: 30 --->
//│ 	case _lh_fact_arg2⁰ of {Z  => [S [Z]] | S _lh_fact_S_0⁰ => mmul_lh_₂([S _lh_fact_S_0⁰], _lh_fact_arg1⁰(mmin_lh_₂([S _lh_fact_S_0⁰], [S [Z]]))) | _  => error⁰}: 111
//│ [Z]: 45 --->
//│ 	case _lh_pplus_arg1⁰ of {Z  => _lh_pplus_arg2⁰ | S _lh_pplus_S_0⁰ => [S pplus_lh_₂(_lh_pplus_S_0⁰, _lh_pplus_arg2⁰)] | _  => error⁰}: 10
//│ 	case _lh_pplus_arg1¹ of {Z  => _lh_pplus_arg2¹ | S _lh_pplus_S_0¹ => [S pplus_lh_₁(_lh_pplus_S_0¹, _lh_pplus_arg2¹)] | _  => error⁰}: 22
//│ [Z]: 64 --->
//│ 	case _lh_fact_arg2⁰ of {Z  => [S [Z]] | S _lh_fact_S_0⁰ => mmul_lh_₂([S _lh_fact_S_0⁰], _lh_fact_arg1⁰(mmin_lh_₂([S _lh_fact_S_0⁰], [S [Z]]))) | _  => error⁰}: 111
//│ [Z]: 94 --->
//│ 	case _lh_pplus_arg1⁰ of {Z  => _lh_pplus_arg2⁰ | S _lh_pplus_S_0⁰ => [S pplus_lh_₂(_lh_pplus_S_0⁰, _lh_pplus_arg2⁰)] | _  => error⁰}: 10
//│ 	case _lh_pplus_arg1¹ of {Z  => _lh_pplus_arg2¹ | S _lh_pplus_S_0¹ => [S pplus_lh_₁(_lh_pplus_S_0¹, _lh_pplus_arg2¹)] | _  => error⁰}: 22
//│ [S [Z]]: 95 --->
//│ 	case _lh_pplus_arg1⁰ of {Z  => _lh_pplus_arg2⁰ | S _lh_pplus_S_0⁰ => [S pplus_lh_₂(_lh_pplus_S_0⁰, _lh_pplus_arg2⁰)] | _  => error⁰}: 10
//│ 	case _lh_pplus_arg1¹ of {Z  => _lh_pplus_arg2¹ | S _lh_pplus_S_0¹ => [S pplus_lh_₁(_lh_pplus_S_0¹, _lh_pplus_arg2¹)] | _  => error⁰}: 22
//│ [S _lh_fact_S_0⁰]: 98 --->
//│ 	case _lh_mmul_arg1⁰ of {Z  => [Z] | S _lh_mmul_S_0⁰ => pplus_lh_₂(_lh_mmul_arg2⁰, mmul_lh_₂(_lh_mmul_S_0⁰, _lh_mmul_arg2⁰)) | _  => error⁰}: 56
//│ [S _lh_fact_S_0⁰]: 103 --->
//│ 	case _lh_matchIdent¹ of {Z  => [Z] | S _lh_mmin_S_0¹ => mmin_lh_₂(_lh_mmin_S_0¹, _lh_mmin_S_0⁰) | _  => error⁰}: 37
//│ 	case _lh_fact_arg2⁰ of {Z  => [S [Z]] | S _lh_fact_S_0⁰ => mmul_lh_₂([S _lh_fact_S_0⁰], _lh_fact_arg1⁰(mmin_lh_₂([S _lh_fact_S_0⁰], [S [Z]]))) | _  => error⁰}: 111
//│ [Z]: 105 --->
//│ 	case _lh_matchIdent⁰ of {Z  => _lh_mmin_arg1⁰ | S _lh_mmin_S_0⁰ => let _lh_matchIdent¹ = _lh_mmin_arg1⁰
//│ in case _lh_matchIdent¹ of {Z  => [Z] | S _lh_mmin_S_0¹ => mmin_lh_₂(_lh_mmin_S_0¹, _lh_mmin_S_0⁰) | _  => error⁰} | _  => error⁰}: 40
//│ [S [Z]]: 106 --->
//│ 	case _lh_matchIdent⁰ of {Z  => _lh_mmin_arg1⁰ | S _lh_mmin_S_0⁰ => let _lh_matchIdent¹ = _lh_mmin_arg1⁰
//│ in case _lh_matchIdent¹ of {Z  => [Z] | S _lh_mmin_S_0¹ => mmin_lh_₂(_lh_mmin_S_0¹, _lh_mmin_S_0⁰) | _  => error⁰} | _  => error⁰}: 40
//│ [S _lh_fact_S_0¹]: 119 --->
//│ 	case _lh_mmul_arg1¹ of {Z  => [Z] | S _lh_mmul_S_0¹ => pplus_lh_₁(_lh_mmul_arg2¹, mmul_lh_₁(_lh_mmul_S_0¹, _lh_mmul_arg2¹)) | _  => error⁰}: 90
//│ [S _lh_fact_S_0¹]: 124 --->
//│ 	case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰}: 71
//│ 	case _lh_fact_arg2⁰ of {Z  => [S [Z]] | S _lh_fact_S_0⁰ => mmul_lh_₂([S _lh_fact_S_0⁰], _lh_fact_arg1⁰(mmin_lh_₂([S _lh_fact_S_0⁰], [S [Z]]))) | _  => error⁰}: 111
//│ [Z]: 126 --->
//│ 	case _lh_matchIdent² of {Z  => _lh_mmin_arg1¹ | S _lh_mmin_S_0² => let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ in case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰} | _  => error⁰}: 74
//│ [S [Z]]: 127 --->
//│ 	case _lh_matchIdent² of {Z  => _lh_mmin_arg1¹ | S _lh_mmin_S_0² => let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ in case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰} | _  => error⁰}: 74
//│ ------------------
//│ case _lh_pplus_arg1⁰ of {Z  => _lh_pplus_arg2⁰ | S _lh_pplus_S_0⁰ => [S pplus_lh_₂(_lh_pplus_S_0⁰, _lh_pplus_arg2⁰)] | _  => error⁰}: 10 --->
//│ 	[S pplus_lh_₂(_lh_pplus_S_0⁰, _lh_pplus_arg2⁰)]: 8
//│ 	[Z]: 45
//│ 	[Z]: 94
//│ 	[S [Z]]: 95
//│ case _lh_pplus_arg1¹ of {Z  => _lh_pplus_arg2¹ | S _lh_pplus_S_0¹ => [S pplus_lh_₁(_lh_pplus_S_0¹, _lh_pplus_arg2¹)] | _  => error⁰}: 22 --->
//│ 	[S pplus_lh_₂(_lh_pplus_S_0⁰, _lh_pplus_arg2⁰)]: 8
//│ 	[Z]: 45
//│ 	[Z]: 94
//│ 	[S [Z]]: 95
//│ case _lh_matchIdent¹ of {Z  => [Z] | S _lh_mmin_S_0¹ => mmin_lh_₂(_lh_mmin_S_0¹, _lh_mmin_S_0⁰) | _  => error⁰}: 37 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0⁰]: 103
//│ case _lh_matchIdent⁰ of {Z  => _lh_mmin_arg1⁰ | S _lh_mmin_S_0⁰ => let _lh_matchIdent¹ = _lh_mmin_arg1⁰
//│ in case _lh_matchIdent¹ of {Z  => [Z] | S _lh_mmin_S_0¹ => mmin_lh_₂(_lh_mmin_S_0¹, _lh_mmin_S_0⁰) | _  => error⁰} | _  => error⁰}: 40 --->
//│ 	[Z]: 105
//│ 	[S [Z]]: 106
//│ case _lh_mmul_arg1⁰ of {Z  => [Z] | S _lh_mmul_S_0⁰ => pplus_lh_₂(_lh_mmul_arg2⁰, mmul_lh_₂(_lh_mmul_S_0⁰, _lh_mmul_arg2⁰)) | _  => error⁰}: 56 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0⁰]: 98
//│ case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰}: 71 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0¹]: 124
//│ case _lh_matchIdent² of {Z  => _lh_mmin_arg1¹ | S _lh_mmin_S_0² => let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ in case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰} | _  => error⁰}: 74 --->
//│ 	[Z]: 126
//│ 	[S [Z]]: 127
//│ case _lh_mmul_arg1¹ of {Z  => [Z] | S _lh_mmul_S_0¹ => pplus_lh_₁(_lh_mmul_arg2¹, mmul_lh_₁(_lh_mmul_S_0¹, _lh_mmul_arg2¹)) | _  => error⁰}: 90 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0¹]: 119
//│ case _lh_fact_arg2⁰ of {Z  => [S [Z]] | S _lh_fact_S_0⁰ => mmul_lh_₂([S _lh_fact_S_0⁰], _lh_fact_arg1⁰(mmin_lh_₂([S _lh_fact_S_0⁰], [S [Z]]))) | _  => error⁰}: 111 --->
//│ 	NoProd
//│ 	[Z]: 30
//│ 	[Z]: 64
//│ 	[S _lh_fact_S_0⁰]: 103
//│ 	[S _lh_fact_S_0¹]: 124
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Z]: 105 --->
//│ 	case _lh_matchIdent⁰ of {Z  => _lh_mmin_arg1⁰ | S _lh_mmin_S_0⁰ => let _lh_matchIdent¹ = _lh_mmin_arg1⁰
//│ in case _lh_matchIdent¹ of {Z  => [Z] | S _lh_mmin_S_0¹ => mmin_lh_₂(_lh_mmin_S_0¹, _lh_mmin_S_0⁰) | _  => error⁰} | _  => error⁰}: 40
//│ [S [Z]]: 106 --->
//│ 	case _lh_matchIdent⁰ of {Z  => _lh_mmin_arg1⁰ | S _lh_mmin_S_0⁰ => let _lh_matchIdent¹ = _lh_mmin_arg1⁰
//│ in case _lh_matchIdent¹ of {Z  => [Z] | S _lh_mmin_S_0¹ => mmin_lh_₂(_lh_mmin_S_0¹, _lh_mmin_S_0⁰) | _  => error⁰} | _  => error⁰}: 40
//│ [Z]: 126 --->
//│ 	case _lh_matchIdent² of {Z  => _lh_mmin_arg1¹ | S _lh_mmin_S_0² => let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ in case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰} | _  => error⁰}: 74
//│ [S [Z]]: 127 --->
//│ 	case _lh_matchIdent² of {Z  => _lh_mmin_arg1¹ | S _lh_mmin_S_0² => let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ in case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰} | _  => error⁰}: 74
//│ ------------------
//│ case _lh_matchIdent⁰ of {Z  => _lh_mmin_arg1⁰ | S _lh_mmin_S_0⁰ => let _lh_matchIdent¹ = _lh_mmin_arg1⁰
//│ in case _lh_matchIdent¹ of {Z  => [Z] | S _lh_mmin_S_0¹ => mmin_lh_₂(_lh_mmin_S_0¹, _lh_mmin_S_0⁰) | _  => error⁰} | _  => error⁰}: 40 --->
//│ 	[Z]: 105
//│ 	[S [Z]]: 106
//│ case _lh_matchIdent² of {Z  => _lh_mmin_arg1¹ | S _lh_mmin_S_0² => let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ in case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰} | _  => error⁰}: 74 --->
//│ 	[Z]: 126
//│ 	[S [Z]]: 127
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ let mainFact¹ = (fun x² -> fact_lh_₁((fun y² -> x²(x², y²))))((fun x³ -> fact_lh_₂((fun y³ -> x³(x³, y³)))))
//│ in mainFact¹(primId⁰([S [S [S [Z]]]]))
//│ def fact_lh_₁(_lh_fact_arg1³, _lh_fact_arg2³) = case _lh_fact_arg2³ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_fact_S_0¹ => mmul_lh_₁([S _lh_fact_S_0¹], _lh_fact_arg1³(mmin_lh_₁([S _lh_fact_S_0¹], 
//│ 		let _lh_mmin_S_0⁵ = (fun _lh_mmin_arg1⁷ -> _lh_mmin_arg1⁷)
//│ 		in (fun _lh_mmin_arg1⁶ -> 
//│ 			let _lh_matchIdent⁷ = _lh_mmin_arg1⁶
//│ 			in case _lh_matchIdent⁷ of {
//│ 				Z  => [Z]
//│ 				| S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0⁵)
//│ 				| _  => error⁰}))))
//│ 	| _  => error⁰}
//│ def fact_lh_₂(_lh_fact_arg1², _lh_fact_arg2²) = case _lh_fact_arg2² of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_fact_S_0⁰ => mmul_lh_₂([S _lh_fact_S_0⁰], _lh_fact_arg1²(mmin_lh_₂([S _lh_fact_S_0⁰], 
//│ 		let _lh_mmin_S_0⁴ = (fun _lh_mmin_arg1³ -> _lh_mmin_arg1³)
//│ 		in (fun _lh_mmin_arg1² -> 
//│ 			let _lh_matchIdent⁴ = _lh_mmin_arg1²
//│ 			in case _lh_matchIdent⁴ of {
//│ 				Z  => [Z]
//│ 				| S _lh_mmin_S_0¹ => mmin_lh_₂(_lh_mmin_S_0¹, _lh_mmin_S_0⁴)
//│ 				| _  => error⁰}))))
//│ 	| _  => error⁰}
//│ def mmin_lh_₁(_lh_mmin_arg1⁴, _lh_mmin_arg2²) = 
//│ 	let _lh_matchIdent⁵ = _lh_mmin_arg2²
//│ 	in _lh_matchIdent⁵(_lh_mmin_arg1⁴)
//│ def mmin_lh_₂(_lh_mmin_arg1⁵, _lh_mmin_arg2³) = 
//│ 	let _lh_matchIdent⁶ = _lh_mmin_arg2³
//│ 	in _lh_matchIdent⁶(_lh_mmin_arg1⁵)
//│ def mmul_lh_₁(_lh_mmul_arg1³, _lh_mmul_arg2³) = case _lh_mmul_arg1³ of {
//│ 	Z  => [Z]
//│ 	| S _lh_mmul_S_0¹ => pplus_lh_₁(_lh_mmul_arg2³, mmul_lh_₁(_lh_mmul_S_0¹, _lh_mmul_arg2³))
//│ 	| _  => error⁰}
//│ def mmul_lh_₂(_lh_mmul_arg1², _lh_mmul_arg2²) = case _lh_mmul_arg1² of {
//│ 	Z  => [Z]
//│ 	| S _lh_mmul_S_0⁰ => pplus_lh_₂(_lh_mmul_arg2², mmul_lh_₂(_lh_mmul_S_0⁰, _lh_mmul_arg2²))
//│ 	| _  => error⁰}
//│ def pplus_lh_₁(_lh_pplus_arg1², _lh_pplus_arg2²) = case _lh_pplus_arg1² of {
//│ 	Z  => _lh_pplus_arg2²
//│ 	| S _lh_pplus_S_0¹ => [S pplus_lh_₁(_lh_pplus_S_0¹, _lh_pplus_arg2²)]
//│ 	| _  => error⁰}
//│ def pplus_lh_₂(_lh_pplus_arg1³, _lh_pplus_arg2³) = case _lh_pplus_arg1³ of {
//│ 	Z  => _lh_pplus_arg2³
//│ 	| S _lh_pplus_S_0⁰ => [S pplus_lh_₂(_lh_pplus_S_0⁰, _lh_pplus_arg2³)]
//│ 	| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [S [S [S [S [S [S [Z]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ mmin_lh_₂, mmin_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ fact_lh_₂ -> 1
//│ fact_lh_₁ -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ let mainFact⁰ = (fun x⁰ -> fact_lh_₁((fun y⁰ -> x⁰(x⁰, y⁰))))((fun x¹ -> fact_lh_₂((fun y¹ -> x¹(x¹, y¹)))))
//│ in mainFact⁰(primId⁰([S [S [S [Z]]]]))
//│ def fact_lh_₁(_lh_fact_arg1¹, _lh_fact_arg2¹) = case _lh_fact_arg2¹ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_fact_S_0¹ => mmul_lh_₁([S _lh_fact_S_0¹], _lh_fact_arg1¹(
//│ 		let _lh_matchIdent⁵ = 	
//│ 			let _lh_mmin_S_0² = (fun _lh_mmin_arg1⁴ -> _lh_mmin_arg1⁴)
//│ 			in (fun _lh_mmin_arg1⁵ -> 
//│ 				let _lh_matchIdent⁶ = _lh_mmin_arg1⁵
//│ 				in case _lh_matchIdent⁶ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0³ => 
//│ 						let _lh_matchIdent⁷ = _lh_mmin_S_0²
//│ 						in _lh_matchIdent⁷(_lh_mmin_S_0³)
//│ 					| _  => error⁰})
//│ 		in _lh_matchIdent⁵([S _lh_fact_S_0¹])))
//│ 	| _  => error⁰}
//│ def fact_lh_₂(_lh_fact_arg1⁰, _lh_fact_arg2⁰) = case _lh_fact_arg2⁰ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_fact_S_0⁰ => mmul_lh_₂([S _lh_fact_S_0⁰], _lh_fact_arg1⁰(
//│ 		let _lh_matchIdent⁰ = 	
//│ 			let _lh_mmin_S_0⁰ = (fun _lh_mmin_arg1⁰ -> _lh_mmin_arg1⁰)
//│ 			in (fun _lh_mmin_arg1¹ -> 
//│ 				let _lh_matchIdent¹ = _lh_mmin_arg1¹
//│ 				in case _lh_matchIdent¹ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0¹ => 
//│ 						let _lh_matchIdent² = _lh_mmin_S_0⁰
//│ 						in _lh_matchIdent²(_lh_mmin_S_0¹)
//│ 					| _  => error⁰})
//│ 		in _lh_matchIdent⁰([S _lh_fact_S_0⁰])))
//│ 	| _  => error⁰}
//│ def mmin_lh_₁(_lh_mmin_arg1², _lh_mmin_arg2⁰) = 
//│ 	let _lh_matchIdent³ = _lh_mmin_arg2⁰
//│ 	in _lh_matchIdent³(_lh_mmin_arg1²)
//│ def mmin_lh_₂(_lh_mmin_arg1³, _lh_mmin_arg2¹) = 
//│ 	let _lh_matchIdent⁴ = _lh_mmin_arg2¹
//│ 	in _lh_matchIdent⁴(_lh_mmin_arg1³)
//│ def mmul_lh_₁(_lh_mmul_arg1¹, _lh_mmul_arg2¹) = case _lh_mmul_arg1¹ of {
//│ 	Z  => [Z]
//│ 	| S _lh_mmul_S_0¹ => pplus_lh_₁(_lh_mmul_arg2¹, mmul_lh_₁(_lh_mmul_S_0¹, _lh_mmul_arg2¹))
//│ 	| _  => error⁰}
//│ def mmul_lh_₂(_lh_mmul_arg1⁰, _lh_mmul_arg2⁰) = case _lh_mmul_arg1⁰ of {
//│ 	Z  => [Z]
//│ 	| S _lh_mmul_S_0⁰ => pplus_lh_₂(_lh_mmul_arg2⁰, mmul_lh_₂(_lh_mmul_S_0⁰, _lh_mmul_arg2⁰))
//│ 	| _  => error⁰}
//│ def pplus_lh_₁(_lh_pplus_arg1⁰, _lh_pplus_arg2⁰) = case _lh_pplus_arg1⁰ of {
//│ 	Z  => _lh_pplus_arg2⁰
//│ 	| S _lh_pplus_S_0⁰ => [S pplus_lh_₁(_lh_pplus_S_0⁰, _lh_pplus_arg2⁰)]
//│ 	| _  => error⁰}
//│ def pplus_lh_₂(_lh_pplus_arg1¹, _lh_pplus_arg2¹) = case _lh_pplus_arg1¹ of {
//│ 	Z  => _lh_pplus_arg2¹
//│ 	| S _lh_pplus_S_0¹ => [S pplus_lh_₂(_lh_pplus_S_0¹, _lh_pplus_arg2¹)]
//│ 	| _  => error⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ let mainFact⁰ = (fun x⁰ -> fact_lh_₁((fun y⁰ -> x⁰(x⁰, y⁰))))((fun x¹ -> fact_lh_₂((fun y¹ -> x¹(x¹, y¹)))))
//│ in mainFact⁰(primId⁰([S [S [S [Z]]]]))
//│ def fact_lh_₁(_lh_fact_arg1¹, _lh_fact_arg2¹) = case _lh_fact_arg2¹ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_fact_S_0¹ => mmul_lh_₁([S _lh_fact_S_0¹], _lh_fact_arg1¹(
//│ 		let _lh_matchIdent⁵ = 	
//│ 			let _lh_mmin_S_0² = (fun _lh_mmin_arg1⁴ -> _lh_mmin_arg1⁴)
//│ 			in (fun _lh_mmin_arg1⁵ -> 
//│ 				let _lh_matchIdent⁶ = _lh_mmin_arg1⁵
//│ 				in case _lh_matchIdent⁶ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0³ => 
//│ 						let _lh_matchIdent⁷ = _lh_mmin_S_0²
//│ 						in _lh_matchIdent⁷(_lh_mmin_S_0³)
//│ 					| _  => error⁰})
//│ 		in _lh_matchIdent⁵([S _lh_fact_S_0¹])))
//│ 	| _  => error⁰}
//│ def fact_lh_₂(_lh_fact_arg1⁰, _lh_fact_arg2⁰) = case _lh_fact_arg2⁰ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_fact_S_0⁰ => mmul_lh_₂([S _lh_fact_S_0⁰], _lh_fact_arg1⁰(
//│ 		let _lh_matchIdent⁰ = 	
//│ 			let _lh_mmin_S_0⁰ = (fun _lh_mmin_arg1⁰ -> _lh_mmin_arg1⁰)
//│ 			in (fun _lh_mmin_arg1¹ -> 
//│ 				let _lh_matchIdent¹ = _lh_mmin_arg1¹
//│ 				in case _lh_matchIdent¹ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0¹ => 
//│ 						let _lh_matchIdent² = _lh_mmin_S_0⁰
//│ 						in _lh_matchIdent²(_lh_mmin_S_0¹)
//│ 					| _  => error⁰})
//│ 		in _lh_matchIdent⁰([S _lh_fact_S_0⁰])))
//│ 	| _  => error⁰}
//│ def mmin_lh_₁(_lh_mmin_arg1², _lh_mmin_arg2⁰) = 
//│ 	let _lh_matchIdent³ = _lh_mmin_arg2⁰
//│ 	in _lh_matchIdent³(_lh_mmin_arg1²)
//│ def mmin_lh_₂(_lh_mmin_arg1³, _lh_mmin_arg2¹) = 
//│ 	let _lh_matchIdent⁴ = _lh_mmin_arg2¹
//│ 	in _lh_matchIdent⁴(_lh_mmin_arg1³)
//│ def mmul_lh_₁(_lh_mmul_arg1¹, _lh_mmul_arg2¹) = case _lh_mmul_arg1¹ of {
//│ 	Z  => [Z]
//│ 	| S _lh_mmul_S_0¹ => pplus_lh_₁(_lh_mmul_arg2¹, mmul_lh_₁(_lh_mmul_S_0¹, _lh_mmul_arg2¹))
//│ 	| _  => error⁰}
//│ def mmul_lh_₂(_lh_mmul_arg1⁰, _lh_mmul_arg2⁰) = case _lh_mmul_arg1⁰ of {
//│ 	Z  => [Z]
//│ 	| S _lh_mmul_S_0⁰ => pplus_lh_₂(_lh_mmul_arg2⁰, mmul_lh_₂(_lh_mmul_S_0⁰, _lh_mmul_arg2⁰))
//│ 	| _  => error⁰}
//│ def pplus_lh_₁(_lh_pplus_arg1⁰, _lh_pplus_arg2⁰) = case _lh_pplus_arg1⁰ of {
//│ 	Z  => _lh_pplus_arg2⁰
//│ 	| S _lh_pplus_S_0⁰ => [S pplus_lh_₁(_lh_pplus_S_0⁰, _lh_pplus_arg2⁰)]
//│ 	| _  => error⁰}
//│ def pplus_lh_₂(_lh_pplus_arg1¹, _lh_pplus_arg2¹) = case _lh_pplus_arg1¹ of {
//│ 	Z  => _lh_pplus_arg2¹
//│ 	| S _lh_pplus_S_0¹ => [S pplus_lh_₂(_lh_pplus_S_0¹, _lh_pplus_arg2¹)]
//│ 	| _  => error⁰}
//│ <<<<<<< after floating out <<<<<<<
