:NewParser
:ParseOnly

let rec p = C(p)
fun c(x) = if x is
    C(a) then c(a)
c(p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 2: [C 1: p:1]
//│ def c:2 = 8: fun x:3 -> 7: case 3: x:3 of {C a:4 -> 6: (4: c:2 5: a:4)}
//│ 11: (9: c:2 10: p:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((p:1^10 ⋅ p:1^1 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (c:2^9 ⋅ c:2^4 ⋅ ɛ, 2'x)) :::: ((p:1^10 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (c:2^9 ⋅ ɛ, 2'x))
//│ ------- defInstance -------
//│ p:1^10 ⋅ ɛ ==> c:2^9 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  7: case x:3 of {C a:4 -> (c:2 a:4)}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C p:1]
//│ def c:2 = fun x:3 -> case x:3 of {C a:4 -> (c:2 a:4)}
//│ def p'1'10:6 = 
//│ 	let a:4 = p'1'10:6 in (c'2'9:5 a:4)
//│ def c'2'9:5 = fun x:3 -> x:3
//│ (c'2'9:5 p'1'10:6)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<



let p = C(1, C(2, N))
fun e(z) = if z is
    C(aaa, bbb) then bbb
    N then 7
fun d(y) = if y is
    C(aa, bb) then e(bb)
    N then 5
fun c(x) = if x is
    C(a, b) then d(b)
    N then 3
c(p)
//│ |#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#fun| |e|(|z|)| |#=| |#if| |z| |is|→|C|(|aaa|,| |bbb|)| |#then| |bbb|↵|N| |#then| |7|←|↵|#fun| |d|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|,| |bb|)| |#then| |e|(|bb|)|↵|N| |#then| |5|←|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|,| |b|)| |#then| |d|(|b|)|↵|N| |#then| |3|←|↵|c|(|p|)|
//│ Parsed: {let p = C (1, C (2, N,),); fun e = z, => if z is ‹(C (aaa, bbb,)) then bbb; (N) then 7›; fun d = y, => if y is ‹(C (aa, bb,)) then e (bb,); (N) then 5›; fun c = x, => if x is ‹(C (a, b,)) then d (b,); (N) then 3›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 5: [C 1: 1 4: [C 2: 2 3: [N]]]
//│ def e:2 = 10: fun z:5 -> 9: case 6: z:5 of {C aaa:6 bbb:7 -> 7: bbb:7 | N -> 8: 7}
//│ def d:3 = 17: fun y:8 -> 16: case 11: y:8 of {C aa:9 bb:10 -> 14: (12: e:2 13: bb:10) | N -> 15: 5}
//│ def c:4 = 24: fun x:11 -> 23: case 18: x:11 of {C a:12 b:13 -> 21: (19: d:3 20: b:13) | N -> 22: 3}
//│ 27: (25: c:4 26: p:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ------- defInstance -------
//│ p:1^26 ⋅ ɛ ==> c:4^25 ⋅ ɛ:
//│ 	5: [C 1 [C 2 [N]]]  <-->  23: case x:11 of {C a:12 b:13 -> (d:3 b:13) | N -> 3}
//│ p:1^26 ⋅ ɛ ==> c:4^25 ⋅ d:3^19 ⋅ e:2^12 ⋅ ɛ:
//│ 	3: [N]  <-->  9: case z:5 of {C aaa:6 bbb:7 -> bbb:7 | N -> 7}
//│ p:1^26 ⋅ ɛ ==> c:4^25 ⋅ d:3^19 ⋅ ɛ:
//│ 	4: [C 2 [N]]  <-->  16: case y:8 of {C aa:9 bb:10 -> (e:2 bb:10) | N -> 5}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C 1 [C 2 [N]]]
//│ def e:2 = fun z:5 -> case z:5 of {C aaa:6 bbb:7 -> bbb:7 | N -> 7}
//│ def d:3 = fun y:8 -> case y:8 of {C aa:9 bb:10 -> (e:2 bb:10) | N -> 5}
//│ def c:4 = fun x:11 -> case x:11 of {C a:12 b:13 -> (d:3 b:13) | N -> 3}
//│ def c'4'25_d'3'19:16 = fun y:8 -> y:8
//│ def c'4'25:14 = fun x:11 -> x:11
//│ def p'1'26:15 = 
//│ 	let a:12 = 1 in 
//│ 	let b:13 = 
//│ 		let aa:9 = 2 in 
//│ 		let bb:10 = 7 in (c'4'25_d'3'19_e'2'12:17 bb:10) 
//│ 	in (c'4'25_d'3'19:16 b:13)
//│ def c'4'25_d'3'19_e'2'12:17 = fun z:5 -> z:5
//│ (c'4'25:14 p'1'26:15)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


let rec p = C(C(p))
fun c(x) = if x is
    C(a) then if a is
        C(b) then if b is
            C(y) then c(y)
c(p)
//│ |#let| |#rec| |p| |#=| |C|(|C|(|p|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |#if| |b| |is|→|C|(|y|)| |#then| |c|(|y|)|←|←|←|↵|c|(|p|)|
//│ Parsed: {let rec p = C (C (p,),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then if b is ‹(C (y,)) then c (y,)›››; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 3: [C 2: [C 1: p:1]]
//│ def c:2 = 13: fun x:3 -> 12: case 4: x:3 of {C a:4 -> 11: case 5: a:4 of {C b:5 -> 10: case 6: b:5 of {C y:6 -> 9: (7: c:2 8: y:6)}}}
//│ 16: (14: c:2 15: p:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ (
//│   (p:1^15 ⋅ p:1^1 ⋅ p:1^1 ⋅ p:1^1 ⋅ ɛ, C((ɛ, C((p:1^1 ⋅ ɛ, 0'p))))),
//│   (c:2^14 ⋅ c:2^7 ⋅ c:2^7 ⋅ ɛ, 2'x)
//│ ) :::: ((p:1^15 ⋅ ɛ, C((ɛ, C((p:1^1 ⋅ ɛ, 0'p))))), (c:2^14 ⋅ ɛ, 2'x))
//│ ------- defInstance -------
//│ p:1^15 ⋅ ɛ ==> c:2^14 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  11: case a:4 of {C b:5 -> case b:5 of {C y:6 -> (c:2 y:6)}}
//│ 	3: [C [C p:1]]  <-->  12: case x:3 of {C a:4 -> case a:4 of {C b:5 -> case b:5 of {C y:6 -> (c:2 y:6)}}}
//│ p:1^15 ⋅ p:1^1 ⋅ ɛ ==> c:2^14 ⋅ c:2^7 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  12: case x:3 of {C a:4 -> case a:4 of {C b:5 -> case b:5 of {C y:6 -> (c:2 y:6)}}}
//│ p:1^15 ⋅ p:1^1 ⋅ ɛ ==> c:2^14 ⋅ ɛ:
//│ 	3: [C [C p:1]]  <-->  10: case b:5 of {C y:6 -> (c:2 y:6)}
//│ p:1^15 ⋅ p:1^1 ⋅ p:1^1 ⋅ ɛ ==> c:2^14 ⋅ c:2^7 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  10: case b:5 of {C y:6 -> (c:2 y:6)}
//│ 	3: [C [C p:1]]  <-->  11: case a:4 of {C b:5 -> case b:5 of {C y:6 -> (c:2 y:6)}}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C [C p:1]]
//│ def c:2 = fun x:3 -> case x:3 of {C a:4 -> case a:4 of {C b:5 -> case b:5 of {C y:6 -> (c:2 y:6)}}}
//│ def p'1'15:8 = 
//│ 	let a:4 = 
//│ 		let b:5 = p'1'15_p'1'1:9 in b:5 
//│ 	in a:4
//│ def p'1'15_p'1'1:9 = 
//│ 	let y:6 = 
//│ 		let a:4 = p'1'15_p'1'1_p'1'1:11 in a:4 
//│ 	in (c'2'14_c'2'7:10 y:6)
//│ def c'2'14:7 = fun x:3 -> x:3
//│ def p'1'15_p'1'1_p'1'1:11 = 
//│ 	let b:5 = 
//│ 		let y:6 = p'1'15:8 in (c'2'14:7 y:6) 
//│ 	in b:5
//│ def c'2'14_c'2'7:10 = fun x:3 -> x:3
//│ (c'2'14:7 p'1'15:8)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<



let rec p = C(C(C(id(p))))
fun c(x) = if x is
    C(a) then if a is
        C(b) then c(b)
fun id2(z) = z
fun id(y) = id2(y)
fun id3(d) = d
c(id3(p))
//│ |#let| |#rec| |p| |#=| |C|(|C|(|C|(|id|(|p|)|)|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |c|(|b|)|←|←|↵|#fun| |id2|(|z|)| |#=| |z|↵|#fun| |id|(|y|)| |#=| |id2|(|y|)|↵|#fun| |id3|(|d|)| |#=| |d|↵|c|(|id3|(|p|)|)|
//│ Parsed: {let rec p = C (C (C (id (p,),),),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then c (b,)››; fun id2 = z, => z; fun id = y, => id2 (y,); fun id3 = d, => d; c (id3 (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 6: [C 5: [C 4: [C 3: (1: id:4 2: p:1)]]]
//│ def c:2 = 14: fun x:6 -> 13: case 7: x:6 of {C a:7 -> 12: case 8: a:7 of {C b:8 -> 11: (9: c:2 10: b:8)}}
//│ def id2:3 = 16: fun z:9 -> 15: z:9
//│ def id:4 = 20: fun y:10 -> 19: (17: id2:3 18: y:10)
//│ def id3:5 = 22: fun d:11 -> 21: d:11
//│ 27: (23: c:2 26: (24: id3:5 25: p:1))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ (
//│   (p:1^25 ⋅ p:1^2 ⋅ p:1^2 ⋅ ɛ, C((ɛ, C((ɛ, C((ɛ, 5'3_callres))))))),
//│   (c:2^23 ⋅ c:2^9 ⋅ c:2^9 ⋅ c:2^9 ⋅ ɛ, 6'x)
//│ ) :::: ((p:1^25 ⋅ ɛ, C((ɛ, C((ɛ, C((ɛ, 5'3_callres))))))), (c:2^23 ⋅ ɛ, 6'x))
//│ ------- defInstance -------
//│ p:1^25 ⋅ ɛ ==> c:2^23 ⋅ c:2^9 ⋅ ɛ:
//│ 	4: [C (id:4 p:1)]  <-->  13: case x:6 of {C a:7 -> case a:7 of {C b:8 -> (c:2 b:8)}}
//│ p:1^25 ⋅ p:1^2 ⋅ ɛ ==> c:2^23 ⋅ c:2^9 ⋅ c:2^9 ⋅ ɛ:
//│ 	4: [C (id:4 p:1)]  <-->  12: case a:7 of {C b:8 -> (c:2 b:8)}
//│ 	5: [C [C (id:4 p:1)]]  <-->  13: case x:6 of {C a:7 -> case a:7 of {C b:8 -> (c:2 b:8)}}
//│ p:1^25 ⋅ ɛ ==> c:2^23 ⋅ ɛ:
//│ 	5: [C [C (id:4 p:1)]]  <-->  12: case a:7 of {C b:8 -> (c:2 b:8)}
//│ 	6: [C [C [C (id:4 p:1)]]]  <-->  13: case x:6 of {C a:7 -> case a:7 of {C b:8 -> (c:2 b:8)}}
//│ p:1^25 ⋅ p:1^2 ⋅ ɛ ==> c:2^23 ⋅ c:2^9 ⋅ ɛ:
//│ 	6: [C [C [C (id:4 p:1)]]]  <-->  12: case a:7 of {C b:8 -> (c:2 b:8)}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C [C [C (id:4 p:1)]]]
//│ def c:2 = fun x:6 -> case x:6 of {C a:7 -> case a:7 of {C b:8 -> (c:2 b:8)}}
//│ def id2:3 = fun z:9 -> z:9
//│ def id:4 = fun y:10 -> (id2:3 y:10)
//│ def id3:5 = fun d:11 -> d:11
//│ def p'1'25_id'4'1_id2'3'17:17 = fun z:9 -> z:9
//│ def c'2'23_c'2'9_c'2'9:19 = fun x:6 -> x:6
//│ def p'1'25_p'1'2_id'4'1_id2'3'17:21 = fun z:9 -> z:9
//│ def p'1'25_id'4'1:16 = fun y:10 -> (p'1'25_id'4'1_id2'3'17:17 y:10)
//│ def p'1'25_p'1'2_id'4'1:20 = fun y:10 -> (p'1'25_p'1'2_id'4'1_id2'3'17:21 y:10)
//│ def c'2'23_c'2'9:15 = fun x:6 -> x:6
//│ def p'1'25:14 = 
//│ 	let a:7 = 
//│ 		let b:8 = 
//│ 			let a:7 = (p'1'25_id'4'1:16 p'1'25_p'1'2:18) in a:7 
//│ 		in (c'2'23_c'2'9:15 b:8) 
//│ 	in a:7
//│ def c'2'23:12 = fun x:6 -> x:6
//│ def p'1'25_p'1'2:18 = 
//│ 	let b:8 = 
//│ 		let a:7 = 
//│ 			let b:8 = (p'1'25_p'1'2_id'4'1:20 p'1'25:14) in (c'2'23:12 b:8) 
//│ 		in a:7 
//│ 	in (c'2'23_c'2'9_c'2'9:19 b:8)
//│ def id3'5'24:13 = fun d:11 -> d:11
//│ (c'2'23:12 (id3'5'24:13 p'1'25:14))
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


let rec p = C(C(p))
fun c(x) = if x is
    C(a) then c(a)
fun id2(yy) = yy
fun id(y) = id2(y)
c(id(p))
//│ |#let| |#rec| |p| |#=| |C|(|C|(|p|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id2|(|yy|)| |#=| |yy|↵|#fun| |id|(|y|)| |#=| |id2|(|y|)|↵|c|(|id|(|p|)|)|
//│ Parsed: {let rec p = C (C (p,),); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun id2 = yy, => yy; fun id = y, => id2 (y,); c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 3: [C 2: [C 1: p:1]]
//│ def c:2 = 9: fun x:5 -> 8: case 4: x:5 of {C a:6 -> 7: (5: c:2 6: a:6)}
//│ def id2:3 = 11: fun yy:7 -> 10: yy:7
//│ def id:4 = 15: fun y:8 -> 14: (12: id2:3 13: y:8)
//│ 20: (16: c:2 19: (17: id:4 18: p:1))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((p:1^18 ⋅ p:1^1 ⋅ ɛ, C((ɛ, C((p:1^1 ⋅ ɛ, 0'p))))), (c:2^16 ⋅ c:2^5 ⋅ c:2^5 ⋅ ɛ, 4'x)) :::: ((p:1^18 ⋅ ɛ, C((ɛ, C((p:1^1 ⋅ ɛ, 0'p))))), (c:2^16 ⋅ ɛ, 4'x))
//│ ------- defInstance -------
//│ p:1^18 ⋅ ɛ ==> c:2^16 ⋅ ɛ:
//│ 	3: [C [C p:1]]  <-->  8: case x:5 of {C a:6 -> (c:2 a:6)}
//│ p:1^18 ⋅ ɛ ==> c:2^16 ⋅ c:2^5 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  8: case x:5 of {C a:6 -> (c:2 a:6)}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C [C p:1]]
//│ def c:2 = fun x:5 -> case x:5 of {C a:6 -> (c:2 a:6)}
//│ def id2:3 = fun yy:7 -> yy:7
//│ def id:4 = fun y:8 -> (id2:3 y:8)
//│ def id'4'17_id2'3'12:11 = fun yy:7 -> yy:7
//│ def c'2'16:9 = fun x:5 -> x:5
//│ def p'1'18:12 = 
//│ 	let a:6 = 
//│ 		let a:6 = p'1'18:12 in (c'2'16:9 a:6) 
//│ 	in (c'2'16_c'2'5:13 a:6)
//│ def c'2'16_c'2'5:13 = fun x:5 -> x:5
//│ def id'4'17:10 = fun y:8 -> (id'4'17_id2'3'12:11 y:8)
//│ (c'2'16:9 (id'4'17:10 p'1'18:12))
//│ <<<<<<<<<< Rewritten <<<<<<<<<<

fun sum(ls) = if ls is
    C(h, t) then S(N, sum(t))
fun mapa(lsa) = if lsa is
    C(ha, ta) then C(primitive(ha), mapa(ta))
fun mapb(lsb) = if lsb is
    C(hb, tb) then C(primitive(hb), mapb(tb))
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),)›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),)›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),)›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def sum:1 = 8: fun ls:4 -> 7: case 1: ls:4 of {C h:5 t:6 -> 6: [S 2: [N] 5: (3: sum:1 4: t:6)]}
//│ def mapa:2 = 18: fun lsa:7 -> 17: case 9: lsa:7 of {C ha:8 ta:9 -> 16: [C 12: (10: primitive:0 11: ha:8) 15: (13: mapa:2 14: ta:9)]}
//│ def mapb:3 = 28: fun lsb:10 -> 27: case 19: lsb:10 of {C hb:11 tb:12 -> 26: [C 22: (20: primitive:0 21: hb:11) 25: (23: mapb:3 24: tb:12)]}
//│ 35: (29: sum:1 34: (30: mapa:2 33: (31: mapb:3 32: primitive:0)))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ (
//│   (mapa:2^30 ⋅ mapa:2^13 ⋅ ɛ, C((ɛ, 11'12_callres), (ɛ, 12'15_callres))),
//│   (sum:1^29 ⋅ sum:1^3 ⋅ ɛ, 3'ls)
//│ ) :::: ((mapa:2^30 ⋅ ɛ, C((ɛ, 11'12_callres), (ɛ, 12'15_callres))), (sum:1^29 ⋅ ɛ, 3'ls))
//│ (
//│   (mapb:3^31 ⋅ mapb:3^23 ⋅ ɛ, C((ɛ, 17'22_callres), (ɛ, 18'25_callres))),
//│   (mapa:2^30 ⋅ mapa:2^13 ⋅ ɛ, 8'lsa)
//│ ) :::: ((mapb:3^31 ⋅ ɛ, C((ɛ, 17'22_callres), (ɛ, 18'25_callres))), (mapa:2^30 ⋅ ɛ, 8'lsa))
//│ ------- defInstance -------
//│ mapa:2^30 ⋅ ɛ ==> sum:1^29 ⋅ ɛ:
//│ 	16: [C (primitive:0 ha:8) (mapa:2 ta:9)]  <-->  7: case ls:4 of {C h:5 t:6 -> [S [N] (sum:1 t:6)]}
//│ mapb:3^31 ⋅ ɛ ==> mapa:2^30 ⋅ ɛ:
//│ 	26: [C (primitive:0 hb:11) (mapb:3 tb:12)]  <-->  17: case lsa:7 of {C ha:8 ta:9 -> [C (primitive:0 ha:8) (mapa:2 ta:9)]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def sum:1 = fun ls:4 -> case ls:4 of {C h:5 t:6 -> [S [N] (sum:1 t:6)]}
//│ def mapa:2 = fun lsa:7 -> case lsa:7 of {C ha:8 ta:9 -> [C (primitive:0 ha:8) (mapa:2 ta:9)]}
//│ def mapb:3 = fun lsb:10 -> case lsb:10 of {C hb:11 tb:12 -> [C (primitive:0 hb:11) (mapb:3 tb:12)]}
//│ def mapa'2'30:14 = fun lsa:7 -> lsa:7
//│ def sum'1'29:13 = fun ls:4 -> ls:4
//│ def mapb'3'31:15 = fun lsb:10 -> case lsb:10 of {C hb:11 tb:12 -> 
//│ 	let ha:8 = (primitive:0 hb:11) in 
//│ 	let ta:9 = (mapb'3'31:15 tb:12) in 
//│ 	let h:5 = (primitive:0 ha:8) in 
//│ 	let t:6 = (mapa'2'30:14 ta:9) in [S [N] (sum'1'29:13 t:6)]}
//│ (sum'1'29:13 (mapa'2'30:14 (mapb'3'31:15 primitive:0)))
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


if C(A, B(C)) is
    C(a, b) then D(b)
//│ |#if| |C|(|A|,| |B|(|C|)|)| |is|→|C|(|a|,| |b|)| |#then| |D|(|b|)|←|
//│ Parsed: {if C (A, B (C,),) is ‹(C (a, b,)) then D (b,)›}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ 7: case 4: [C 1: [A] 3: [B 2: [C]]] of {C a:1 b:2 -> 6: [D 5: b:2]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ------- defInstance -------
//│ ɛ ==> ɛ:
//│ 	4: [C [A] [B [C]]]  <-->  7: case [C [A] [B [C]]] of {C a:1 b:2 -> [D b:2]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ 
//│ 	let a:1 = [A] in 
//│ 	let b:2 = [B [C]] in [D b:2]
//│ <<<<<<<<<< Rewritten <<<<<<<<<<
//│


fun id(k) = k
fun id1(x) = id(x)
fun id2(y) = y
fun id3(z) = z
let rec p = C(C(C(id7(C(C(id1(p)))))))
fun c(xx) = if xx is
    C(a) then c(a)
fun id4(k) = k
fun id5(j) = j
fun id6(l) = l
fun id7(i) = i
id6(id4)(c)(id5(id2)(id3(p)))
//│ |#fun| |id|(|k|)| |#=| |k|↵|#fun| |id1|(|x|)| |#=| |id|(|x|)|↵|#fun| |id2|(|y|)| |#=| |y|↵|#fun| |id3|(|z|)| |#=| |z|↵|#let| |#rec| |p| |#=| |C|(|C|(|C|(|id7|(|C|(|C|(|id1|(|p|)|)|)|)|)|)|)|↵|#fun| |c|(|xx|)| |#=| |#if| |xx| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id4|(|k|)| |#=| |k|↵|#fun| |id5|(|j|)| |#=| |j|↵|#fun| |id6|(|l|)| |#=| |l|↵|#fun| |id7|(|i|)| |#=| |i|↵|id6|(|id4|)|(|c|)|(|id5|(|id2|)|(|id3|(|p|)|)|)|
//│ Parsed: {fun id = k, => k; fun id1 = x, => id (x,); fun id2 = y, => y; fun id3 = z, => z; let rec p = C (C (C (id7 (C (C (id1 (p,),),),),),),); fun c = xx, => if xx is ‹(C (a,)) then c (a,)›; fun id4 = k, => k; fun id5 = j, => j; fun id6 = l, => l; fun id7 = i, => i; id6 (id4,) (c,) (id5 (id2,) (id3 (p,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def id:1 = 2: fun k:11 -> 1: k:11
//│ def id1:2 = 6: fun x:12 -> 5: (3: id:1 4: x:12)
//│ def id2:3 = 8: fun y:13 -> 7: y:13
//│ def id3:4 = 10: fun z:14 -> 9: z:14
//│ def p:5 = 20: [C 19: [C 18: [C 17: (11: id7:10 16: [C 15: [C 14: (12: id1:2 13: p:5)]])]]]
//│ def c:6 = 26: fun xx:15 -> 25: case 21: xx:15 of {C a:16 -> 24: (22: c:6 23: a:16)}
//│ def id4:7 = 28: fun k:17 -> 27: k:17
//│ def id5:8 = 30: fun j:18 -> 29: j:18
//│ def id6:9 = 32: fun l:19 -> 31: l:19
//│ def id7:10 = 34: fun i:20 -> 33: i:20
//│ 47: (39: (37: (35: id6:9 36: id4:7) 38: c:6) 46: (42: (40: id5:8 41: id2:3) 45: (43: id3:4 44: p:5)))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ (
//│   (p:5^44 ⋅ p:5^13 ⋅ ɛ, C((ɛ, C((ɛ, C((ɛ, 16'17_callres))))))),
//│   (c:6^38 ⋅ c:6^22 ⋅ c:6^22 ⋅ c:6^22 ⋅ c:6^22 ⋅ c:6^22 ⋅ ɛ, 17'xx)
//│ ) :::: ((p:5^44 ⋅ ɛ, C((ɛ, C((ɛ, C((ɛ, 16'17_callres))))))), (c:6^38 ⋅ ɛ, 17'xx))
//│ ------- defInstance -------
//│ p:5^44 ⋅ ɛ ==> c:6^38 ⋅ ɛ:
//│ 	20: [C [C [C (id7:10 [C [C (id1:2 p:5)]])]]]  <-->  25: case xx:15 of {C a:16 -> (c:6 a:16)}
//│ p:5^44 ⋅ ɛ ==> c:6^38 ⋅ c:6^22 ⋅ c:6^22 ⋅ ɛ:
//│ 	18: [C (id7:10 [C [C (id1:2 p:5)]])]  <-->  25: case xx:15 of {C a:16 -> (c:6 a:16)}
//│ p:5^44 ⋅ ɛ ==> c:6^38 ⋅ c:6^22 ⋅ c:6^22 ⋅ c:6^22 ⋅ c:6^22 ⋅ ɛ:
//│ 	15: [C (id1:2 p:5)]  <-->  25: case xx:15 of {C a:16 -> (c:6 a:16)}
//│ p:5^44 ⋅ ɛ ==> c:6^38 ⋅ c:6^22 ⋅ c:6^22 ⋅ c:6^22 ⋅ ɛ:
//│ 	16: [C [C (id1:2 p:5)]]  <-->  25: case xx:15 of {C a:16 -> (c:6 a:16)}
//│ p:5^44 ⋅ ɛ ==> c:6^38 ⋅ c:6^22 ⋅ ɛ:
//│ 	19: [C [C (id7:10 [C [C (id1:2 p:5)]])]]  <-->  25: case xx:15 of {C a:16 -> (c:6 a:16)}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def id:1 = fun k:11 -> k:11
//│ def id1:2 = fun x:12 -> (id:1 x:12)
//│ def id2:3 = fun y:13 -> y:13
//│ def id3:4 = fun z:14 -> z:14
//│ def p:5 = [C [C [C (id7:10 [C [C (id1:2 p:5)]])]]]
//│ def c:6 = fun xx:15 -> case xx:15 of {C a:16 -> (c:6 a:16)}
//│ def id4:7 = fun k:17 -> k:17
//│ def id5:8 = fun j:18 -> j:18
//│ def id6:9 = fun l:19 -> l:19
//│ def id7:10 = fun i:20 -> i:20
//│ def id4'7'36:22 = fun k:17 -> k:17
//│ def p'5'44:27 = 
//│ 	let a:16 = 
//│ 		let a:16 = 
//│ 			let a:16 = (p'5'44_id7'10'11:31 
//│ 				let a:16 = 
//│ 					let a:16 = (p'5'44_id1'2'12:33 p'5'44:27) in (c'6'38:23 a:16) 
//│ 				in (c'6'38_c'6'22_c'6'22_c'6'22_c'6'22:32 a:16)) 
//│ 			in (c'6'38_c'6'22_c'6'22_c'6'22:30 a:16) 
//│ 		in (c'6'38_c'6'22_c'6'22:29 a:16) 
//│ 	in (c'6'38_c'6'22:28 a:16)
//│ def c'6'38_c'6'22_c'6'22:29 = fun xx:15 -> xx:15
//│ def c'6'38_c'6'22:28 = fun xx:15 -> xx:15
//│ def p'5'44_id7'10'11:31 = fun i:20 -> i:20
//│ def p'5'44_id1'2'12_id'1'3:34 = fun k:11 -> k:11
//│ def c'6'38_c'6'22_c'6'22_c'6'22_c'6'22:32 = fun xx:15 -> xx:15
//│ def c'6'38_c'6'22_c'6'22_c'6'22:30 = fun xx:15 -> xx:15
//│ def id5'8'40:24 = fun j:18 -> j:18
//│ def id3'4'43:26 = fun z:14 -> z:14
//│ def id2'3'41:25 = fun y:13 -> y:13
//│ def c'6'38:23 = fun xx:15 -> xx:15
//│ def id6'9'35:21 = fun l:19 -> l:19
//│ def p'5'44_id1'2'12:33 = fun x:12 -> (p'5'44_id1'2'12_id'1'3:34 x:12)
//│ (((id6'9'35:21 id4'7'36:22) c'6'38:23) ((id5'8'40:24 id2'3'41:25) (id3'4'43:26 p'5'44:27)))
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


let rec p = C(C(C(p)))
fun ca(x) = if x is
    C(a) then cb(a)
fun cb(x) = if x is
    C(b) then ca(b)
ca(p)
//│ |#let| |#rec| |p| |#=| |C|(|C|(|C|(|p|)|)|)|↵|#fun| |ca|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |cb|(|a|)|←|↵|#fun| |cb|(|x|)| |#=| |#if| |x| |is|→|C|(|b|)| |#then| |ca|(|b|)|←|↵|ca|(|p|)|
//│ Parsed: {let rec p = C (C (C (p,),),); fun ca = x, => if x is ‹(C (a,)) then cb (a,)›; fun cb = x, => if x is ‹(C (b,)) then ca (b,)›; ca (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 4: [C 3: [C 2: [C 1: p:1]]]
//│ def ca:2 = 10: fun x:4 -> 9: case 5: x:4 of {C a:5 -> 8: (6: cb:3 7: a:5)}
//│ def cb:3 = 16: fun x:6 -> 15: case 11: x:6 of {C b:7 -> 14: (12: ca:2 13: b:7)}
//│ 19: (17: ca:2 18: p:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ (
//│   (p:1^18 ⋅ p:1^1 ⋅ p:1^1 ⋅ ɛ, C((ɛ, C((ɛ, C((p:1^1 ⋅ ɛ, 0'p))))))),
//│   (ca:2^17 ⋅ cb:3^6 ⋅ ca:2^12 ⋅ cb:3^6 ⋅ ca:2^12 ⋅ cb:3^6 ⋅ ca:2^12 ⋅ ɛ, 3'x)
//│ ) :::: ((p:1^18 ⋅ ɛ, C((ɛ, C((ɛ, C((p:1^1 ⋅ ɛ, 0'p))))))), (ca:2^17 ⋅ ɛ, 3'x))
//│ ------- defInstance -------
//│ p:1^18 ⋅ ɛ ==> ca:2^17 ⋅ ɛ:
//│ 	4: [C [C [C p:1]]]  <-->  9: case x:4 of {C a:5 -> (cb:3 a:5)}
//│ p:1^18 ⋅ p:1^1 ⋅ ɛ ==> ca:2^17 ⋅ cb:3^6 ⋅ ca:2^12 ⋅ cb:3^6 ⋅ ca:2^12 ⋅ ɛ:
//│ 	3: [C [C p:1]]  <-->  9: case x:4 of {C a:5 -> (cb:3 a:5)}
//│ p:1^18 ⋅ p:1^1 ⋅ ɛ ==> ca:2^17 ⋅ cb:3^6 ⋅ ca:2^12 ⋅ cb:3^6 ⋅ ɛ:
//│ 	4: [C [C [C p:1]]]  <-->  15: case x:6 of {C b:7 -> (ca:2 b:7)}
//│ p:1^18 ⋅ p:1^1 ⋅ ɛ ==> ca:2^17 ⋅ cb:3^6 ⋅ ca:2^12 ⋅ cb:3^6 ⋅ ca:2^12 ⋅ cb:3^6 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  15: case x:6 of {C b:7 -> (ca:2 b:7)}
//│ p:1^18 ⋅ ɛ ==> ca:2^17 ⋅ cb:3^6 ⋅ ca:2^12 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  9: case x:4 of {C a:5 -> (cb:3 a:5)}
//│ p:1^18 ⋅ ɛ ==> ca:2^17 ⋅ cb:3^6 ⋅ ɛ:
//│ 	3: [C [C p:1]]  <-->  15: case x:6 of {C b:7 -> (ca:2 b:7)}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C [C [C p:1]]]
//│ def ca:2 = fun x:4 -> case x:4 of {C a:5 -> (cb:3 a:5)}
//│ def cb:3 = fun x:6 -> case x:6 of {C b:7 -> (ca:2 b:7)}
//│ def ca'2'17_cb'3'6_ca'2'12_cb'3'6:12 = fun x:6 -> x:6
//│ def ca'2'17_cb'3'6_ca'2'12_cb'3'6_ca'2'12:14 = fun x:4 -> x:4
//│ def p'1'18_p'1'1:13 = 
//│ 	let b:7 = 
//│ 		let a:5 = 
//│ 			let b:7 = p'1'18:9 in (ca'2'17:8 b:7) 
//│ 		in (ca'2'17_cb'3'6_ca'2'12_cb'3'6_ca'2'12_cb'3'6:15 a:5) 
//│ 	in (ca'2'17_cb'3'6_ca'2'12_cb'3'6_ca'2'12:14 b:7)
//│ def ca'2'17_cb'3'6_ca'2'12:11 = fun x:4 -> x:4
//│ def ca'2'17:8 = fun x:4 -> x:4
//│ def ca'2'17_cb'3'6:10 = fun x:6 -> x:6
//│ def ca'2'17_cb'3'6_ca'2'12_cb'3'6_ca'2'12_cb'3'6:15 = fun x:6 -> x:6
//│ def p'1'18:9 = 
//│ 	let a:5 = 
//│ 		let b:7 = 
//│ 			let a:5 = p'1'18_p'1'1:13 in (ca'2'17_cb'3'6_ca'2'12_cb'3'6:12 a:5) 
//│ 		in (ca'2'17_cb'3'6_ca'2'12:11 b:7) 
//│ 	in (ca'2'17_cb'3'6:10 a:5)
//│ (ca'2'17:8 p'1'18:9)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


fun c1(x1) = if x1 is
    C(a) then c2(a)
fun c2(x2) = if x2 is
    C(b) then c1(b)
let p1 = C(C(C(p2)))
let p2 = C(p1)
c1(p1)
//│ |#fun| |c1|(|x1|)| |#=| |#if| |x1| |is|→|C|(|a|)| |#then| |c2|(|a|)|←|↵|#fun| |c2|(|x2|)| |#=| |#if| |x2| |is|→|C|(|b|)| |#then| |c1|(|b|)|←|↵|#let| |p1| |#=| |C|(|C|(|C|(|p2|)|)|)|↵|#let| |p2| |#=| |C|(|p1|)|↵|c1|(|p1|)|
//│ Parsed: {fun c1 = x1, => if x1 is ‹(C (a,)) then c2 (a,)›; fun c2 = x2, => if x2 is ‹(C (b,)) then c1 (b,)›; let p1 = C (C (C (p2,),),); let p2 = C (p1,); c1 (p1,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def c1:1 = 6: fun x1:5 -> 5: case 1: x1:5 of {C a:6 -> 4: (2: c2:2 3: a:6)}
//│ def c2:2 = 12: fun x2:7 -> 11: case 7: x2:7 of {C b:8 -> 10: (8: c1:1 9: b:8)}
//│ def p1:3 = 16: [C 15: [C 14: [C 13: p2:4]]]
//│ def p2:4 = 18: [C 17: p1:3]
//│ 21: (19: c1:1 20: p1:3)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ (
//│   (p1:3^20 ⋅ p2:4^13 ⋅ p1:3^17 ⋅ ɛ, C((ɛ, C((ɛ, C((p2:4^13 ⋅ ɛ, 3'p2))))))),
//│   (c1:1^19 ⋅ c2:2^2 ⋅ c1:1^8 ⋅ c2:2^2 ⋅ c1:1^8 ⋅ ɛ, 4'x1)
//│ ) :::: ((p1:3^20 ⋅ ɛ, C((ɛ, C((ɛ, C((p2:4^13 ⋅ ɛ, 3'p2))))))), (c1:1^19 ⋅ ɛ, 4'x1))
//│ ------- defInstance -------
//│ p1:3^20 ⋅ ɛ ==> c1:1^19 ⋅ ɛ:
//│ 	16: [C [C [C p2:4]]]  <-->  5: case x1:5 of {C a:6 -> (c2:2 a:6)}
//│ p1:3^20 ⋅ p2:4^13 ⋅ ɛ ==> c1:1^19 ⋅ c2:2^2 ⋅ c1:1^8 ⋅ c2:2^2 ⋅ ɛ:
//│ 	18: [C p1:3]  <-->  11: case x2:7 of {C b:8 -> (c1:1 b:8)}
//│ p1:3^20 ⋅ ɛ ==> c1:1^19 ⋅ c2:2^2 ⋅ c1:1^8 ⋅ ɛ:
//│ 	14: [C p2:4]  <-->  5: case x1:5 of {C a:6 -> (c2:2 a:6)}
//│ p1:3^20 ⋅ ɛ ==> c1:1^19 ⋅ c2:2^2 ⋅ ɛ:
//│ 	15: [C [C p2:4]]  <-->  11: case x2:7 of {C b:8 -> (c1:1 b:8)}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def c1:1 = fun x1:5 -> case x1:5 of {C a:6 -> (c2:2 a:6)}
//│ def c2:2 = fun x2:7 -> case x2:7 of {C b:8 -> (c1:1 b:8)}
//│ def p1:3 = [C [C [C p2:4]]]
//│ def p2:4 = [C p1:3]
//│ def c1'1'19_c2'2'2_c1'1'8_c2'2'2:13 = fun x2:7 -> x2:7
//│ def c1'1'19_c2'2'2_c1'1'8:12 = fun x1:5 -> x1:5
//│ def c1'1'19:9 = fun x1:5 -> x1:5
//│ def p1'3'20_p2'4'13:14 = 
//│ 	let b:8 = p1'3'20:10 in (c1'1'19:9 b:8)
//│ def c1'1'19_c2'2'2:11 = fun x2:7 -> x2:7
//│ def p1'3'20:10 = 
//│ 	let a:6 = 
//│ 		let b:8 = 
//│ 			let a:6 = p1'3'20_p2'4'13:14 in (c1'1'19_c2'2'2_c1'1'8_c2'2'2:13 a:6) 
//│ 		in (c1'1'19_c2'2'2_c1'1'8:12 b:8) 
//│ 	in (c1'1'19_c2'2'2:11 a:6)
//│ (c1'1'19:9 p1'3'20:10)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


fun ff(x) = if x is
    K then T
    KK then TT
    KKKK then TTTT
fun map(ls) = if ls is
    C(h, t) then C(ff(h), map(t))
    N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|ff|(|h|)|,| |map|(|t|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; fun map = ls, => if ls is ‹(C (h, t,)) then C (ff (h,), map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def ff:1 = 6: fun x:4 -> 5: case 1: x:4 of {K -> 2: [T] | KK -> 3: [TT] | KKKK -> 4: [TTTT]}
//│ def map:2 = 17: fun ls:5 -> 16: case 7: ls:5 of {C h:6 t:7 -> 14: [C 10: (8: ff:1 9: h:6) 13: (11: map:2 12: t:7)] | N -> 15: [N]}
//│ def l:3 = 24: [C 18: [K] 23: [C 19: [KK] 22: [C 20: [KKKK] 21: [N]]]]
//│ 27: (25: map:2 26: l:3)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ------- defInstance -------
//│ l:3^26 ⋅ ɛ ==> map:2^25 ⋅ ff:1^8 ⋅ ɛ:
//│ 	18: [K]  <-->  5: case x:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ l:3^26 ⋅ ɛ ==> map:2^25 ⋅ map:2^11 ⋅ ff:1^8 ⋅ ɛ:
//│ 	19: [KK]  <-->  5: case x:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ l:3^26 ⋅ ɛ ==> map:2^25 ⋅ map:2^11 ⋅ ɛ:
//│ 	23: [C [KK] [C [KKKK] [N]]]  <-->  16: case ls:5 of {C h:6 t:7 -> [C (ff:1 h:6) (map:2 t:7)] | N -> [N]}
//│ l:3^26 ⋅ ɛ ==> map:2^25 ⋅ map:2^11 ⋅ map:2^11 ⋅ ɛ:
//│ 	22: [C [KKKK] [N]]  <-->  16: case ls:5 of {C h:6 t:7 -> [C (ff:1 h:6) (map:2 t:7)] | N -> [N]}
//│ l:3^26 ⋅ ɛ ==> map:2^25 ⋅ ɛ:
//│ 	24: [C [K] [C [KK] [C [KKKK] [N]]]]  <-->  16: case ls:5 of {C h:6 t:7 -> [C (ff:1 h:6) (map:2 t:7)] | N -> [N]}
//│ l:3^26 ⋅ ɛ ==> map:2^25 ⋅ map:2^11 ⋅ map:2^11 ⋅ map:2^11 ⋅ ɛ:
//│ 	21: [N]  <-->  16: case ls:5 of {C h:6 t:7 -> [C (ff:1 h:6) (map:2 t:7)] | N -> [N]}
//│ l:3^26 ⋅ ɛ ==> map:2^25 ⋅ map:2^11 ⋅ map:2^11 ⋅ ff:1^8 ⋅ ɛ:
//│ 	20: [KKKK]  <-->  5: case x:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def ff:1 = fun x:4 -> case x:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ def map:2 = fun ls:5 -> case ls:5 of {C h:6 t:7 -> [C (ff:1 h:6) (map:2 t:7)] | N -> [N]}
//│ def l:3 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def l'3'26:9 = 
//│ 	let h:6 = [T] in 
//│ 	let t:7 = 
//│ 		let h:6 = [TT] in 
//│ 		let t:7 = 
//│ 			let h:6 = [TTTT] in 
//│ 			let t:7 = [N] in [C (map'2'25_map'2'11_map'2'11_ff'1'8:14 h:6) (map'2'25_map'2'11_map'2'11_map'2'11:15 t:7)] 
//│ 		in [C (map'2'25_map'2'11_ff'1'8:12 h:6) (map'2'25_map'2'11_map'2'11:13 t:7)] 
//│ 	in [C (map'2'25_ff'1'8:10 h:6) (map'2'25_map'2'11:11 t:7)]
//│ def map'2'25_ff'1'8:10 = fun x:4 -> x:4
//│ def map'2'25:8 = fun ls:5 -> ls:5
//│ def map'2'25_map'2'11_ff'1'8:12 = fun x:4 -> x:4
//│ def map'2'25_map'2'11_map'2'11_ff'1'8:14 = fun x:4 -> x:4
//│ def map'2'25_map'2'11_map'2'11_map'2'11:15 = fun ls:5 -> ls:5
//│ def map'2'25_map'2'11:11 = fun ls:5 -> ls:5
//│ def map'2'25_map'2'11_map'2'11:13 = fun ls:5 -> ls:5
//│ (map'2'25:8 l'3'26:9)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


fun map(ls) = if ls is
    C(h, t) then C(
        (if h is
            K then T
            KK then TT
            KKKK then TTTT
        ),
        map(t)
    )
    N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›, ')', map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def map:1 = 13: fun ls:3 -> 12: case 1: ls:3 of {C h:4 t:5 -> 10: [C 6: case 2: h:4 of {K -> 3: [T] | KK -> 4: [TT] | KKKK -> 5: [TTTT]} 9: (7: map:1 8: t:5)] | N -> 11: [N]}
//│ def l:2 = 20: [C 14: [K] 19: [C 15: [KK] 18: [C 16: [KKKK] 17: [N]]]]
//│ 23: (21: map:1 22: l:2)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ------- defInstance -------
//│ l:2^22 ⋅ ɛ ==> map:1^21 ⋅ ɛ:
//│ 	14: [K]  <-->  6: case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ 	20: [C [K] [C [KK] [C [KKKK] [N]]]]  <-->  12: case ls:3 of {C h:4 t:5 -> [C case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]} (map:1 t:5)] | N -> [N]}
//│ l:2^22 ⋅ ɛ ==> map:1^21 ⋅ map:1^7 ⋅ map:1^7 ⋅ map:1^7 ⋅ ɛ:
//│ 	17: [N]  <-->  12: case ls:3 of {C h:4 t:5 -> [C case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]} (map:1 t:5)] | N -> [N]}
//│ l:2^22 ⋅ ɛ ==> map:1^21 ⋅ map:1^7 ⋅ map:1^7 ⋅ ɛ:
//│ 	16: [KKKK]  <-->  6: case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ 	18: [C [KKKK] [N]]  <-->  12: case ls:3 of {C h:4 t:5 -> [C case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]} (map:1 t:5)] | N -> [N]}
//│ l:2^22 ⋅ ɛ ==> map:1^21 ⋅ map:1^7 ⋅ ɛ:
//│ 	15: [KK]  <-->  6: case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ 	19: [C [KK] [C [KKKK] [N]]]  <-->  12: case ls:3 of {C h:4 t:5 -> [C case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]} (map:1 t:5)] | N -> [N]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def map:1 = fun ls:3 -> case ls:3 of {C h:4 t:5 -> [C case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]} (map:1 t:5)] | N -> [N]}
//│ def l:2 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map'1'21_map'1'7:8 = fun ls:3 -> ls:3
//│ def map'1'21:6 = fun ls:3 -> ls:3
//│ def map'1'21_map'1'7_map'1'7_map'1'7:10 = fun ls:3 -> ls:3
//│ def l'2'22:7 = 
//│ 	let h:4 = [T] in 
//│ 	let t:5 = 
//│ 		let h:4 = [TT] in 
//│ 		let t:5 = 
//│ 			let h:4 = [TTTT] in 
//│ 			let t:5 = [N] in [C h:4 (map'1'21_map'1'7_map'1'7_map'1'7:10 t:5)] 
//│ 		in [C h:4 (map'1'21_map'1'7_map'1'7:9 t:5)] 
//│ 	in [C h:4 (map'1'21_map'1'7:8 t:5)]
//│ def map'1'21_map'1'7_map'1'7:9 = fun ls:3 -> ls:3
//│ (map'1'21:6 l'2'22:7)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


fun sum(ls) = if ls is
    C(h, t) then S(N, sum(t))
    N then N
fun mapa(lsa) = if lsa is
    C(ha, ta) then C(primitive(ha), mapa(ta))
    N then N
fun mapb(lsb) = if lsb is
    C(hb, tb) then C(primitive(hb), mapb(tb))
    N then N
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|↵|N| |#then| |N|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|↵|N| |#then| |N|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),); (N) then N›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),); (N) then N›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),); (N) then N›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def sum:1 = 9: fun ls:4 -> 8: case 1: ls:4 of {C h:5 t:6 -> 6: [S 2: [N] 5: (3: sum:1 4: t:6)] | N -> 7: [N]}
//│ def mapa:2 = 20: fun lsa:7 -> 19: case 10: lsa:7 of {C ha:8 ta:9 -> 17: [C 13: (11: primitive:0 12: ha:8) 16: (14: mapa:2 15: ta:9)] | N -> 18: [N]}
//│ def mapb:3 = 31: fun lsb:10 -> 30: case 21: lsb:10 of {C hb:11 tb:12 -> 28: [C 24: (22: primitive:0 23: hb:11) 27: (25: mapb:3 26: tb:12)] | N -> 29: [N]}
//│ 38: (32: sum:1 37: (33: mapa:2 36: (34: mapb:3 35: primitive:0)))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ (
//│   (mapa:2^33 ⋅ mapa:2^14 ⋅ ɛ, C((ɛ, 11'13_callres), (ɛ, 12'16_callres))),
//│   (sum:1^32 ⋅ sum:1^3 ⋅ ɛ, 3'ls)
//│ ) :::: ((mapa:2^33 ⋅ ɛ, C((ɛ, 11'13_callres), (ɛ, 12'16_callres))), (sum:1^32 ⋅ ɛ, 3'ls))
//│ (
//│   (mapb:3^34 ⋅ mapb:3^25 ⋅ ɛ, C((ɛ, 17'24_callres), (ɛ, 18'27_callres))),
//│   (mapa:2^33 ⋅ mapa:2^14 ⋅ ɛ, 8'lsa)
//│ ) :::: ((mapb:3^34 ⋅ ɛ, C((ɛ, 17'24_callres), (ɛ, 18'27_callres))), (mapa:2^33 ⋅ ɛ, 8'lsa))
//│ ((mapa:2^33 ⋅ mapa:2^14 ⋅ ɛ, N()), (sum:1^32 ⋅ sum:1^3 ⋅ ɛ, 3'ls)) :::: ((mapa:2^33 ⋅ ɛ, N()), (sum:1^32 ⋅ ɛ, 3'ls))
//│ ((mapb:3^34 ⋅ mapb:3^25 ⋅ ɛ, N()), (mapa:2^33 ⋅ mapa:2^14 ⋅ ɛ, 8'lsa)) :::: ((mapb:3^34 ⋅ ɛ, N()), (mapa:2^33 ⋅ ɛ, 8'lsa))
//│ ------- defInstance -------
//│ mapa:2^33 ⋅ ɛ ==> sum:1^32 ⋅ ɛ:
//│ 	17: [C (primitive:0 ha:8) (mapa:2 ta:9)]  <-->  8: case ls:4 of {C h:5 t:6 -> [S [N] (sum:1 t:6)] | N -> [N]}
//│ 	18: [N]  <-->  8: case ls:4 of {C h:5 t:6 -> [S [N] (sum:1 t:6)] | N -> [N]}
//│ mapb:3^34 ⋅ ɛ ==> mapa:2^33 ⋅ ɛ:
//│ 	28: [C (primitive:0 hb:11) (mapb:3 tb:12)]  <-->  19: case lsa:7 of {C ha:8 ta:9 -> [C (primitive:0 ha:8) (mapa:2 ta:9)] | N -> [N]}
//│ 	29: [N]  <-->  19: case lsa:7 of {C ha:8 ta:9 -> [C (primitive:0 ha:8) (mapa:2 ta:9)] | N -> [N]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def sum:1 = fun ls:4 -> case ls:4 of {C h:5 t:6 -> [S [N] (sum:1 t:6)] | N -> [N]}
//│ def mapa:2 = fun lsa:7 -> case lsa:7 of {C ha:8 ta:9 -> [C (primitive:0 ha:8) (mapa:2 ta:9)] | N -> [N]}
//│ def mapb:3 = fun lsb:10 -> case lsb:10 of {C hb:11 tb:12 -> [C (primitive:0 hb:11) (mapb:3 tb:12)] | N -> [N]}
//│ def sum'1'32:13 = fun ls:4 -> ls:4
//│ def mapa'2'33:14 = fun lsa:7 -> lsa:7
//│ def mapb'3'34:15 = fun lsb:10 -> case lsb:10 of {C hb:11 tb:12 -> 
//│ 	let ha:8 = (primitive:0 hb:11) in 
//│ 	let ta:9 = (mapb'3'34:15 tb:12) in 
//│ 	let h:5 = (primitive:0 ha:8) in 
//│ 	let t:6 = (mapa'2'33:14 ta:9) in [S [N] (sum'1'32:13 t:6)] | N -> [N]}
//│ (sum'1'32:13 (mapa'2'33:14 (mapb'3'34:15 primitive:0)))
//│ <<<<<<<<<< Rewritten <<<<<<<<<<



let rec p = C(p)
fun c(x) = if x is
    C(a) then c(a)
fun main(cc) = cc(p)
main(c)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|cc|)| |#=| |cc|(|p|)|↵|main|(|c|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = cc, => cc (p,); main (c,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 2: [C 1: p:1]
//│ def c:2 = 8: fun x:4 -> 7: case 3: x:4 of {C a:5 -> 6: (4: c:2 5: a:5)}
//│ def main:3 = 12: fun cc:6 -> 11: (9: cc:6 10: p:1)
//│ 15: (13: main:3 14: c:2)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((main:3^13 ⋅ p:1^10 ⋅ p:1^1 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (c:2^14 ⋅ c:2^4 ⋅ ɛ, 3'x)) :::: ((main:3^13 ⋅ p:1^10 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (c:2^14 ⋅ ɛ, 3'x))
//│ ------- defInstance -------
//│ main:3^13 ⋅ p:1^10 ⋅ ɛ ==> c:2^14 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  7: case x:4 of {C a:5 -> (c:2 a:5)}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C p:1]
//│ def c:2 = fun x:4 -> case x:4 of {C a:5 -> (c:2 a:5)}
//│ def main:3 = fun cc:6 -> (cc:6 p:1)
//│ def c'2'14:9 = fun x:4 -> x:4
//│ def main'3'13:7 = fun cc:6 -> (cc:6 main'3'13_p'1'10:8)
//│ def main'3'13_p'1'10:8 = 
//│ 	let a:5 = main'3'13_p'1'10:8 in (c'2'14:9 a:5)
//│ (main'3'13:7 c'2'14:9)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


// this path seems also to be sensible
let rec p = C(p)
fun c(x) = if x is
    C(a) then c(a)
fun main(pp) = if pp is
    C(b) then if b is
        C(d) then c(d)
main(p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|pp|)| |#=| |#if| |pp| |is|→|C|(|b|)| |#then| |#if| |b| |is|→|C|(|d|)| |#then| |c|(|d|)|←|←|↵|main|(|p|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = pp, => if pp is ‹(C (b,)) then if b is ‹(C (d,)) then c (d,)››; main (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 2: [C 1: p:1]
//│ def c:2 = 8: fun x:4 -> 7: case 3: x:4 of {C a:5 -> 6: (4: c:2 5: a:5)}
//│ def main:3 = 16: fun pp:6 -> 15: case 9: pp:6 of {C b:7 -> 14: case 10: b:7 of {C d:8 -> 13: (11: c:2 12: d:8)}}
//│ 19: (17: main:3 18: p:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((p:1^18 ⋅ p:1^1 ⋅ p:1^1 ⋅ p:1^1 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (main:3^17 ⋅ c:2^11 ⋅ c:2^4 ⋅ ɛ, 3'x)) :::: ((p:1^18 ⋅ p:1^1 ⋅ p:1^1 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (main:3^17 ⋅ c:2^11 ⋅ ɛ, 3'x))
//│ ------- defInstance -------
//│ p:1^18 ⋅ ɛ ==> main:3^17 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  15: case pp:6 of {C b:7 -> case b:7 of {C d:8 -> (c:2 d:8)}}
//│ p:1^18 ⋅ p:1^1 ⋅ ɛ ==> main:3^17 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  14: case b:7 of {C d:8 -> (c:2 d:8)}
//│ p:1^18 ⋅ p:1^1 ⋅ p:1^1 ⋅ ɛ ==> main:3^17 ⋅ c:2^11 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  7: case x:4 of {C a:5 -> (c:2 a:5)}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C p:1]
//│ def c:2 = fun x:4 -> case x:4 of {C a:5 -> (c:2 a:5)}
//│ def main:3 = fun pp:6 -> case pp:6 of {C b:7 -> case b:7 of {C d:8 -> (c:2 d:8)}}
//│ def p'1'18_p'1'1_p'1'1:13 = 
//│ 	let a:5 = p'1'18_p'1'1_p'1'1:13 in (main'3'17_c'2'11:12 a:5)
//│ def p'1'18_p'1'1:11 = 
//│ 	let d:8 = p'1'18_p'1'1_p'1'1:13 in (main'3'17_c'2'11:12 d:8)
//│ def main'3'17:9 = fun pp:6 -> pp:6
//│ def p'1'18:10 = 
//│ 	let b:7 = p'1'18_p'1'1:11 in b:7
//│ def main'3'17_c'2'11:12 = fun x:4 -> x:4
//│ (main'3'17:9 p'1'18:10)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


let rec p = C(p)
let c(x) = if x is
    C(a) then c(a)
fun main(cc, pp) = cc(pp)
main(c, p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#let| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|cc|,| |pp|)| |#=| |cc|(|pp|)|↵|main|(|c|,| |p|)|
//│ Parsed: {let rec p = C (p,); let c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = cc, pp, => cc (pp,); main (c, p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 2: [C 1: p:1]
//│ def c:2 = 8: fun x:4 -> 7: case 3: x:4 of {C a:5 -> 6: (4: c:2 5: a:5)}
//│ def main:3 = 13: fun cc:6 -> 12: fun pp:7 -> 11: (9: cc:6 10: pp:7)
//│ 18: (16: (14: main:3 15: c:2) 17: p:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((p:1^17 ⋅ p:1^1 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (c:2^15 ⋅ c:2^4 ⋅ ɛ, 3'x)) :::: ((p:1^17 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (c:2^15 ⋅ ɛ, 3'x))
//│ ------- defInstance -------
//│ p:1^17 ⋅ ɛ ==> c:2^15 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  7: case x:4 of {C a:5 -> (c:2 a:5)}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C p:1]
//│ def c:2 = fun x:4 -> case x:4 of {C a:5 -> (c:2 a:5)}
//│ def main:3 = fun cc:6 -> fun pp:7 -> (cc:6 pp:7)
//│ def p'1'17:10 = 
//│ 	let a:5 = p'1'17:10 in (c'2'15:9 a:5)
//│ def main'3'14:8 = fun cc:6 -> fun pp:7 -> (cc:6 pp:7)
//│ def c'2'15:9 = fun x:4 -> x:4
//│ ((main'3'14:8 c'2'15:9) p'1'17:10)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


fun cons(y) = if y is
    C(aa) then cons(aa)
fun a(x) = b(x)
fun b(x) = c(x)
fun c(x) = d(cons, x)
fun d(cc, x) = cc(x)
let p = C(p)
a(p)
//│ |#fun| |cons|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |cons|(|aa|)|←|↵|#fun| |a|(|x|)| |#=| |b|(|x|)|↵|#fun| |b|(|x|)| |#=| |c|(|x|)|↵|#fun| |c|(|x|)| |#=| |d|(|cons|,| |x|)|↵|#fun| |d|(|cc|,| |x|)| |#=| |cc|(|x|)|↵|#let| |p| |#=| |C|(|p|)|↵|a|(|p|)|
//│ Parsed: {fun cons = y, => if y is ‹(C (aa,)) then cons (aa,)›; fun a = x, => b (x,); fun b = x, => c (x,); fun c = x, => d (cons, x,); fun d = cc, x, => cc (x,); let p = C (p,); a (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def cons:1 = 6: fun y:7 -> 5: case 1: y:7 of {C aa:8 -> 4: (2: cons:1 3: aa:8)}
//│ def a:2 = 10: fun x:9 -> 9: (7: b:3 8: x:9)
//│ def b:3 = 14: fun x:10 -> 13: (11: c:4 12: x:10)
//│ def c:4 = 20: fun x:11 -> 19: (17: (15: d:5 16: cons:1) 18: x:11)
//│ def d:5 = 25: fun cc:12 -> 24: fun x:13 -> 23: (21: cc:12 22: x:13)
//│ def p:6 = 27: [C 26: p:6]
//│ 30: (28: a:2 29: p:6)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ (
//│   (p:6^29 ⋅ p:6^26 ⋅ ɛ, C((p:6^26 ⋅ ɛ, 5'p))),
//│   (a:2^28 ⋅ b:3^7 ⋅ c:4^11 ⋅ cons:1^16 ⋅ cons:1^2 ⋅ ɛ, 6'y)
//│ ) :::: ((p:6^29 ⋅ ɛ, C((p:6^26 ⋅ ɛ, 5'p))), (a:2^28 ⋅ b:3^7 ⋅ c:4^11 ⋅ cons:1^16 ⋅ ɛ, 6'y))
//│ ------- defInstance -------
//│ p:6^29 ⋅ ɛ ==> a:2^28 ⋅ b:3^7 ⋅ c:4^11 ⋅ cons:1^16 ⋅ ɛ:
//│ 	27: [C p:6]  <-->  5: case y:7 of {C aa:8 -> (cons:1 aa:8)}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def cons:1 = fun y:7 -> case y:7 of {C aa:8 -> (cons:1 aa:8)}
//│ def a:2 = fun x:9 -> (b:3 x:9)
//│ def b:3 = fun x:10 -> (c:4 x:10)
//│ def c:4 = fun x:11 -> ((d:5 cons:1) x:11)
//│ def d:5 = fun cc:12 -> fun x:13 -> (cc:12 x:13)
//│ def p:6 = [C p:6]
//│ def a'2'28_b'3'7_c'4'11_d'5'15:17 = fun cc:12 -> fun x:13 -> (cc:12 x:13)
//│ def a'2'28_b'3'7:15 = fun x:10 -> (a'2'28_b'3'7_c'4'11:16 x:10)
//│ def a'2'28_b'3'7_c'4'11_cons'1'16:18 = fun y:7 -> y:7
//│ def a'2'28_b'3'7_c'4'11:16 = fun x:11 -> ((a'2'28_b'3'7_c'4'11_d'5'15:17 a'2'28_b'3'7_c'4'11_cons'1'16:18) x:11)
//│ def a'2'28:14 = fun x:9 -> (a'2'28_b'3'7:15 x:9)
//│ def p'6'29:19 = 
//│ 	let aa:8 = p'6'29:19 in (a'2'28_b'3'7_c'4'11_cons'1'16:18 aa:8)
//│ (a'2'28:14 p'6'29:19)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


// NOTE: the name would be better to be the complete path
let p = C(N)
fun c(x) = if C(x) is
    C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|N|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (N,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 2: [C 1: [N]]
//│ def c:2 = 9: fun x:3 -> 8: case 4: [C 3: x:3] of {C a:4 -> 7: (5: c:2 6: a:4)}
//│ 12: (10: c:2 11: p:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((p:1^11 ⋅ ɛ, C((ɛ, N()))), (c:2^10 ⋅ c:2^5 ⋅ ɛ, 2'x)) :::: ((p:1^11 ⋅ ɛ, C((ɛ, N()))), (c:2^10 ⋅ ɛ, 2'x))
//│ ------- defInstance -------
//│ ɛ ==> ɛ:
//│ 	4: [C x:3]  <-->  8: case [C x:3] of {C a:4 -> (c:2 a:4)}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C [N]]
//│ def c:2 = fun x:3 -> case [C x:3] of {C a:4 -> (c:2 a:4)}
//│ def p'1'11:7 = [C [N]]
//│ def c'2'5:6 = fun x:3 -> 
//│ 	let a:4 = x:3 in (c'2'5:6 a:4)
//│ def c'2'10:5 = fun x:3 -> 
//│ 	let a:4 = x:3 in (c'2'5:6 a:4)
//│ (c'2'10:5 p'1'11:7)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


// NOTE: the name would be better to be the complete path
let rec p = C(p)
let q = p
fun c(x) = if x is
    C(a) then a
fun c2(z) = if z is
    C(b) then c2(b)
let main = c(q)
c2(main)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#let| |q| |#=| |p|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |a|←|↵|#fun| |c2|(|z|)| |#=| |#if| |z| |is|→|C|(|b|)| |#then| |c2|(|b|)|←|↵|#let| |main| |#=| |c|(|q|)|↵|c2|(|main|)|
//│ Parsed: {let rec p = C (p,); let q = p; fun c = x, => if x is ‹(C (a,)) then a›; fun c2 = z, => if z is ‹(C (b,)) then c2 (b,)›; let main = c (q,); c2 (main,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 2: [C 1: p:1]
//│ def q:2 = 3: p:1
//│ def c:3 = 7: fun x:6 -> 6: case 4: x:6 of {C a:7 -> 5: a:7}
//│ def c2:4 = 13: fun z:8 -> 12: case 8: z:8 of {C b:9 -> 11: (9: c2:4 10: b:9)}
//│ def main:5 = 16: (14: c:3 15: q:2)
//│ 19: (17: c2:4 18: main:5)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((main:5^18 ⋅ q:2^15 ⋅ p:1^3 ⋅ p:1^1 ⋅ p:1^1 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (c2:4^17 ⋅ c2:4^9 ⋅ ɛ, 8'z)) :::: ((main:5^18 ⋅ q:2^15 ⋅ p:1^3 ⋅ p:1^1 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (c2:4^17 ⋅ ɛ, 8'z))
//│ ------- defInstance -------
//│ main:5^18 ⋅ q:2^15 ⋅ p:1^3 ⋅ p:1^1 ⋅ ɛ ==> c2:4^17 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  12: case z:8 of {C b:9 -> (c2:4 b:9)}
//│ q:2^15 ⋅ p:1^3 ⋅ ɛ ==> c:3^14 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  6: case x:6 of {C a:7 -> a:7}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C p:1]
//│ def q:2 = p:1
//│ def c:3 = fun x:6 -> case x:6 of {C a:7 -> a:7}
//│ def c2:4 = fun z:8 -> case z:8 of {C b:9 -> (c2:4 b:9)}
//│ def main:5 = (c:3 q:2)
//│ def main'5'18_q'2'15:13 = main'5'18_q'2'15_p'1'3:14
//│ def main'5'18_c'3'14:12 = fun x:6 -> x:6
//│ def c2'4'17:10 = fun z:8 -> z:8
//│ def main'5'18_q'2'15_p'1'3:14 = 
//│ 	let a:7 = main'5'18_q'2'15_p'1'3_p'1'1:15 in a:7
//│ def main'5'18_q'2'15_p'1'3_p'1'1:15 = 
//│ 	let b:9 = main'5'18_q'2'15_p'1'3_p'1'1:15 in (c2'4'17:10 b:9)
//│ def main'5'18:11 = (main'5'18_c'3'14:12 main'5'18_q'2'15:13)
//│ (c2'4'17:10 main'5'18:11)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


// NOTE: the name would be better to be the complete path
let rec p = C(p)
fun c(x) = if x is
    C(a) then a
fun c1(xx) = if xx is
    C(aa) then aa
fun c2(z) = if z is
    C(b) then c2(b)
let main = c(p)
fun id(y) = c1(C(y))
c2(id(main))
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |a|←|↵|#fun| |c1|(|xx|)| |#=| |#if| |xx| |is|→|C|(|aa|)| |#then| |aa|←|↵|#fun| |c2|(|z|)| |#=| |#if| |z| |is|→|C|(|b|)| |#then| |c2|(|b|)|←|↵|#let| |main| |#=| |c|(|p|)|↵|#fun| |id|(|y|)| |#=| |c1|(|C|(|y|)|)|↵|c2|(|id|(|main|)|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then a›; fun c1 = xx, => if xx is ‹(C (aa,)) then aa›; fun c2 = z, => if z is ‹(C (b,)) then c2 (b,)›; let main = c (p,); fun id = y, => c1 (C (y,),); c2 (id (main,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 2: [C 1: p:1]
//│ def c:2 = 6: fun x:7 -> 5: case 3: x:7 of {C a:8 -> 4: a:8}
//│ def c1:3 = 10: fun xx:9 -> 9: case 7: xx:9 of {C aa:10 -> 8: aa:10}
//│ def c2:4 = 16: fun z:11 -> 15: case 11: z:11 of {C b:12 -> 14: (12: c2:4 13: b:12)}
//│ def main:5 = 19: (17: c:2 18: p:1)
//│ def id:6 = 24: fun y:13 -> 23: (20: c1:3 22: [C 21: y:13])
//│ 29: (25: c2:4 28: (26: id:6 27: main:5))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((main:5^27 ⋅ p:1^18 ⋅ p:1^1 ⋅ p:1^1 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (c2:4^25 ⋅ c2:4^12 ⋅ ɛ, 12'z)) :::: ((main:5^27 ⋅ p:1^18 ⋅ p:1^1 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (c2:4^25 ⋅ ɛ, 12'z))
//│ ------- defInstance -------
//│ main:5^27 ⋅ p:1^18 ⋅ p:1^1 ⋅ ɛ ==> c2:4^25 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  15: case z:11 of {C b:12 -> (c2:4 b:12)}
//│ ɛ ==> c1:3^20 ⋅ ɛ:
//│ 	22: [C y:13]  <-->  9: case xx:9 of {C aa:10 -> aa:10}
//│ p:1^18 ⋅ ɛ ==> c:2^17 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  5: case x:7 of {C a:8 -> a:8}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C p:1]
//│ def c:2 = fun x:7 -> case x:7 of {C a:8 -> a:8}
//│ def c1:3 = fun xx:9 -> case xx:9 of {C aa:10 -> aa:10}
//│ def c2:4 = fun z:11 -> case z:11 of {C b:12 -> (c2:4 b:12)}
//│ def main:5 = (c:2 p:1)
//│ def id:6 = fun y:13 -> (c1:3 [C y:13])
//│ def id'6'26:15 = fun y:13 -> (id'6'26_c1'3'20:16 
//│ 	let aa:10 = y:13 in aa:10)
//│ def c2'4'25:14 = fun z:11 -> z:11
//│ def id'6'26_c1'3'20:16 = fun xx:9 -> xx:9
//│ def main'5'27_c'2'17:18 = fun x:7 -> x:7
//│ def main'5'27_p'1'18:19 = 
//│ 	let a:8 = main'5'27_p'1'18_p'1'1:20 in a:8
//│ def main'5'27:17 = (main'5'27_c'2'17:18 main'5'27_p'1'18:19)
//│ def main'5'27_p'1'18_p'1'1:20 = 
//│ 	let b:12 = main'5'27_p'1'18_p'1'1:20 in (c2'4'25:14 b:12)
//│ (c2'4'25:14 (id'6'26:15 main'5'27:17))
//│ <<<<<<<<<< Rewritten <<<<<<<<<<
