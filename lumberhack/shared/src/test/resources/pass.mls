:NewParser
:ParseOnly



// CORRECT:
let p = C(1, C(2, N))
fun e(z) = if z is
  C(aaa, bbb) then bbb
  N then 7
fun d(y) = if y is
  C(aa, bb) then e(bb)
  N then 5
fun c(x) = if x is
  C(a, b) then d(b)
  N then 3
c(p)
//│ |#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#fun| |e|(|z|)| |#=| |#if| |z| |is|→|C|(|aaa|,| |bbb|)| |#then| |bbb|↵|N| |#then| |7|←|↵|#fun| |d|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|,| |bb|)| |#then| |e|(|bb|)|↵|N| |#then| |5|←|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|,| |b|)| |#then| |d|(|b|)|↵|N| |#then| |3|←|↵|c|(|p|)|
//│ Parsed: {let p = C (1, C (2, N,),); fun e = z, => if z is ‹(C (aaa, bbb,)) then bbb; (N) then 7›; fun d = y, => if y is ‹(C (aa, bb,)) then e (bb,); (N) then 5›; fun c = x, => if x is ‹(C (a, b,)) then d (b,); (N) then 3›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^25(p^26)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ b⁰ => d^19(b⁰)
//│ 	| N  => 3}
//│ def d(y⁰) = case y⁰ of {
//│ 	C aa⁰ bb⁰ => e^12(bb⁰)
//│ 	| N  => 5}
//│ def e(z⁰) = case z⁰ of {
//│ 	C aaa⁰ bbb⁰ => bbb⁰
//│ 	| N  => 7}
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^25] (hopeless to continue)
//│ 	[c^25 · d^19] (using original def)
//│ 		[c^25 · d^19 · e^12] (using original def)
//│ [p^26] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ b¹ => d_₀(b¹)
//│ 		| N  => 3}
//│ 	where
//│ 	def d_₀(y¹) = 
//│ 		case y¹ of {
//│ 			C aa¹ bb¹ => e_₀(bb¹)
//│ 			| N  => 5}
//│ 		where
//│ 		def e_₀(z¹) = 
//│ 			case z¹ of {
//│ 				C aaa¹ bbb¹ => bbb¹
//│ 				| N  => 7}
//│ def p_₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 37 --->
//│ 	case z¹ of {C aaa¹ bbb¹ => bbb¹ | N  => 7}: 43
//│ [C 2 [N]]: 38 --->
//│ 	case y¹ of {C aa¹ bb¹ => e_₀(bb¹) | N  => 5}: 50
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case x¹ of {C a¹ b¹ => d_₀(b¹) | N  => 3}: 33
//│ ------------------
//│ case x¹ of {C a¹ b¹ => d_₀(b¹) | N  => 3}: 33 --->
//│ 	[C 1 [C 2 [N]]]: 39
//│ case z¹ of {C aaa¹ bbb¹ => bbb¹ | N  => 7}: 43 --->
//│ 	[N]: 37
//│ case y¹ of {C aa¹ bb¹ => e_₀(bb¹) | N  => 5}: 50 --->
//│ 	[C 2 [N]]: 38
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 37 --->
//│ 	case z¹ of {C aaa¹ bbb¹ => bbb¹ | N  => 7}: 43
//│ [C 2 [N]]: 38 --->
//│ 	case y¹ of {C aa¹ bb¹ => e_₀(bb¹) | N  => 5}: 50
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case x¹ of {C a¹ b¹ => d_₀(b¹) | N  => 3}: 33
//│ ------------------
//│ case x¹ of {C a¹ b¹ => d_₀(b¹) | N  => 3}: 33 --->
//│ 	[C 1 [C 2 [N]]]: 39
//│ case z¹ of {C aaa¹ bbb¹ => bbb¹ | N  => 7}: 43 --->
//│ 	[N]: 37
//│ case y¹ of {C aa¹ bb¹ => e_₀(bb¹) | N  => 5}: 50 --->
//│ 	[C 2 [N]]: 38
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x²) = 
//│ 	x²(99)
//│ 	where
//│ 	def d_₀(y²) = 
//│ 		y²(99)
//│ 		where
//│ 		def e_₀(z²) = 
//│ 			z²
//│ def p_₀ = 
//│ 	let b² = 	
//│ 		let bb² = 7
//│ 		in (fun _lh_dummy¹ -> e_₀(bb²))
//│ 	in (fun _lh_dummy⁰ -> d_₀(b²))
//│ <<<<<<< after fusion <<<<<<<



// CORRECT:
fun sum(ls) = if ls is
  C(h, t) then S(N, sum(t))
fun mapa(lsa) = if lsa is
  C(ha, ta) then C(primitive(ha), mapa(ta))
fun mapb(lsb) = if lsb is
  C(hb, tb) then C(primitive(hb), mapb(tb))
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),)›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),)›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),)›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ sum^29(mapa^30(mapb^31(primitive⁰)))
//│ def mapa(lsa⁰) = case lsa⁰ of {
//│ 	C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa^13(ta⁰)]}
//│ def mapb(lsb⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => [C primitive⁰(hb⁰) mapb^23(tb⁰)]}
//│ def sum(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [S [N] sum^3(t⁰)]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa^30] (hopeless to continue)
//│ 	[mapa^30 · mapa^13] ---> [mapa^30] (using original def)
//│ [mapb^31] (hopeless to continue)
//│ 	[mapb^31 · mapb^23] ---> [mapb^31] (using original def)
//│ [sum^29] (hopeless to continue)
//│ 	[sum^29 · sum^3] ---> [sum^29] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ sum_₀(mapa_₀(mapb_₀(primitive⁰)))
//│ def mapa_₀(lsa¹) = 
//│ 	case lsa¹ of {
//│ 		C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)]}
//│ def mapb_₀(lsb¹) = 
//│ 	case lsb¹ of {
//│ 		C hb¹ tb¹ => [C primitive⁰(hb¹) mapb_₀(tb¹)]}
//│ def sum_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => [S [N] sum_₀(t¹)]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰(hb¹) mapb_₀(tb¹)]: 51 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)]}: 62
//│ [C primitive⁰(ha¹) mapa_₀(ta¹)]: 61 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)]}: 42
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)]}: 42 --->
//│ 	[C primitive⁰(ha¹) mapa_₀(ta¹)]: 61
//│ case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)]}: 62 --->
//│ 	[C primitive⁰(hb¹) mapb_₀(tb¹)]: 51
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C primitive⁰(hb¹) mapb_₀(tb¹)]: 51 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)]}: 62
//│ [C primitive⁰(ha¹) mapa_₀(ta¹)]: 61 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)]}: 42
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)]}: 42 --->
//│ 	[C primitive⁰(ha¹) mapa_₀(ta¹)]: 61
//│ case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)]}: 62 --->
//│ 	[C primitive⁰(hb¹) mapb_₀(tb¹)]: 51
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ sum_₀(mapa_₀(mapb_₀(primitive⁰)))
//│ def mapa_₀(lsa²) = 
//│ 	lsa²(99)
//│ def mapb_₀(lsb²) = 
//│ 	case lsb² of {
//│ 		C hb¹ tb¹ => 
//│ 			let ta² = mapb_₀(tb¹)
//│ 			in let ha² = primitive⁰(hb¹)
//│ 			in (fun _lh_dummy¹ -> 
//│ 				let t² = mapa_₀(ta²)
//│ 				in (fun _lh_dummy⁰ -> [S [N] sum_₀(t²)]))}
//│ def sum_₀(ls²) = 
//│ 	ls²(99)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
if C(A, B(C)) is
  C(a, b) then D(b)
//│ |#if| |C|(|A|,| |B|(|C|)|)| |is|→|C|(|a|,| |b|)| |#then| |D|(|b|)|←|
//│ Parsed: {if C (A, B (C,),) is ‹(C (a, b,)) then D (b,)›}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a⁰ b⁰ => [D b⁰]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a¹ b¹ => [D b¹]}
//│ 
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A] [B [C]]]: 11 --->
//│ 	case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14
//│ ------------------
//│ case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14 --->
//│ 	[C [A] [B [C]]]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [A] [B [C]]]: 11 --->
//│ 	case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14
//│ ------------------
//│ case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14 --->
//│ 	[C [A] [B [C]]]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let b² = [B [C]]
//│ 	in [D b²]
//│ 
//│ <<<<<<< after fusion <<<<<<<
//│




// def p:6^18 =
//      ... p:6^1 ~> p:6^18.p:6^1 ...

// def p:6^18.p:6^1 =
//      ... p:6^1 ~> p:6^18 ...

// def ca:7^17
//      ... 



// CORRECT: every element is handled
fun ff(x) = if x is
  K then T
  KK then TT
  KKKK then TTTT
fun map(ls) = if ls is
  C(h, t) then C(ff(h), map(t))
  N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|ff|(|h|)|,| |map|(|t|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; fun map = ls, => if ls is ‹(C (h, t,)) then C (ff (h,), map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^25(l^26)
//│ def ff(x⁰) = case x⁰ of {
//│ 	K  => [T]
//│ 	| KK  => [TT]
//│ 	| KKKK  => [TTTT]}
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C ff^8(h⁰) map^11(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^26] (hopeless to continue)
//│ [map^25] (hopeless to continue)
//│ 	[map^25 · ff^8] (using original def)
//│ 	[map^25 · map^11] ---> [map^25] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map_₀(l_₀)
//│ def l_₀ = 
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)]
//│ 		| N  => [N]}
//│ 	where
//│ 	def ff_₀(x¹) = 
//│ 		case x¹ of {
//│ 			K  => [T]
//│ 			| KK  => [TT]
//│ 			| KKKK  => [TTTT]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 39 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [KK]: 40 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [KKKK]: 41 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [N]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ [C [KKKK] [N]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ [C [KK] [C [KKKK] [N]]]: 44 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 45 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37 --->
//│ 	[N]: 42
//│ 	[C [KKKK] [N]]: 43
//│ 	[C [KK] [C [KKKK] [N]]]: 44
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 45
//│ case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50 --->
//│ 	[K]: 39
//│ 	[KK]: 40
//│ 	[KKKK]: 41
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 39 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [KK]: 40 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [KKKK]: 41 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [N]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ [C [KKKK] [N]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ [C [KK] [C [KKKK] [N]]]: 44 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 45 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37 --->
//│ 	[N]: 42
//│ 	[C [KKKK] [N]]: 43
//│ 	[C [KK] [C [KKKK] [N]]]: 44
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 45
//│ case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50 --->
//│ 	[K]: 39
//│ 	[KK]: 40
//│ 	[KKKK]: 41
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map_₀(l_₀)
//│ def l_₀ = 
//│ 	let t² = 	
//│ 		let t³ = 	
//│ 			let t⁴ = (fun _lh_dummy³ -> [N])
//│ 			in let h⁴ = [TTTT]
//│ 			in (fun _lh_dummy² -> [C ff_₀(h⁴) map_₀(t⁴)])
//│ 		in let h³ = [TT]
//│ 		in (fun _lh_dummy¹ -> [C ff_₀(h³) map_₀(t³)])
//│ 	in let h² = [T]
//│ 	in (fun _lh_dummy⁰ -> [C ff_₀(h²) map_₀(t²)])
//│ def map_₀(ls²) = 
//│ 	ls²(99)
//│ 	where
//│ 	def ff_₀(x²) = 
//│ 		x²
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: every element is handled
fun map(ls) = if ls is
  C(h, t) then C(
    (if h is
      K then T
      KK then TT
      KKKK then TTTT
    ),
    map(t)
  )
  N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›, ')', map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^21(l^22)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C case h⁰ of {
//│ 		K  => [T]
//│ 		| KK  => [TT]
//│ 		| KKKK  => [TTTT]} map^7(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^22] (hopeless to continue)
//│ [map^21] (hopeless to continue)
//│ 	[map^21 · map^7] ---> [map^21] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map_₀(l_₀)
//│ def l_₀ = 
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => [C case h¹ of {
//│ 			K  => [T]
//│ 			| KK  => [TT]
//│ 			| KKKK  => [TTTT]} map_₀(t¹)]
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 37 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [KK]: 38 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [KKKK]: 39 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [N]: 40 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ [C [KKKK] [N]]: 41 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ [C [KK] [C [KKKK] [N]]]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ ------------------
//│ case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29 --->
//│ 	[K]: 37
//│ 	[KK]: 38
//│ 	[KKKK]: 39
//│ case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35 --->
//│ 	[N]: 40
//│ 	[C [KKKK] [N]]: 41
//│ 	[C [KK] [C [KKKK] [N]]]: 42
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 43
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 37 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [KK]: 38 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [KKKK]: 39 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [N]: 40 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ [C [KKKK] [N]]: 41 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ [C [KK] [C [KKKK] [N]]]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ ------------------
//│ case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29 --->
//│ 	[K]: 37
//│ 	[KK]: 38
//│ 	[KKKK]: 39
//│ case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35 --->
//│ 	[N]: 40
//│ 	[C [KKKK] [N]]: 41
//│ 	[C [KK] [C [KKKK] [N]]]: 42
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 43
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map_₀(l_₀)
//│ def l_₀ = 
//│ 	let t² = 	
//│ 		let t³ = 	
//│ 			let t⁴ = (fun _lh_dummy³ -> [N])
//│ 			in let h⁴ = [TTTT]
//│ 			in (fun _lh_dummy² -> [C h⁴ map_₀(t⁴)])
//│ 		in let h³ = [TT]
//│ 		in (fun _lh_dummy¹ -> [C h³ map_₀(t³)])
//│ 	in let h² = [T]
//│ 	in (fun _lh_dummy⁰ -> [C h² map_₀(t²)])
//│ def map_₀(ls²) = 
//│ 	ls²(99)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
fun sum(ls) = if ls is
  C(h, t) then S(N, sum(t))
  N then N
fun mapa(lsa) = if lsa is
  C(ha, ta) then C(primitive(ha), mapa(ta))
  N then N
fun mapb(lsb) = if lsb is
  C(hb, tb) then C(primitive(hb), mapb(tb))
  N then N
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|↵|N| |#then| |N|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|↵|N| |#then| |N|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),); (N) then N›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),); (N) then N›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),); (N) then N›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ sum^32(mapa^33(mapb^34(primitive⁰)))
//│ def mapa(lsa⁰) = case lsa⁰ of {
//│ 	C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa^14(ta⁰)]
//│ 	| N  => [N]}
//│ def mapb(lsb⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => [C primitive⁰(hb⁰) mapb^25(tb⁰)]
//│ 	| N  => [N]}
//│ def sum(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [S [N] sum^3(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa^33] (hopeless to continue)
//│ 	[mapa^33 · mapa^14] ---> [mapa^33] (using original def)
//│ [mapb^34] (hopeless to continue)
//│ 	[mapb^34 · mapb^25] ---> [mapb^34] (using original def)
//│ [sum^32] (hopeless to continue)
//│ 	[sum^32 · sum^3] ---> [sum^32] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ sum_₀(mapa_₀(mapb_₀(primitive⁰)))
//│ def mapa_₀(lsa¹) = 
//│ 	case lsa¹ of {
//│ 		C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)]
//│ 		| N  => [N]}
//│ def mapb_₀(lsb¹) = 
//│ 	case lsb¹ of {
//│ 		C hb¹ tb¹ => [C primitive⁰(hb¹) mapb_₀(tb¹)]
//│ 		| N  => [N]}
//│ def sum_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => [S [N] sum_₀(t¹)]
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰(ha¹) mapa_₀(ta¹)]: 55 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)] | N  => [N]}: 46
//│ [N]: 56 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)] | N  => [N]}: 46
//│ [C primitive⁰(hb¹) mapb_₀(tb¹)]: 66 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)] | N  => [N]}: 57
//│ [N]: 67 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)] | N  => [N]}: 57
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)] | N  => [N]}: 46 --->
//│ 	[C primitive⁰(ha¹) mapa_₀(ta¹)]: 55
//│ 	[N]: 56
//│ case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)] | N  => [N]}: 57 --->
//│ 	[C primitive⁰(hb¹) mapb_₀(tb¹)]: 66
//│ 	[N]: 67
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C primitive⁰(ha¹) mapa_₀(ta¹)]: 55 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)] | N  => [N]}: 46
//│ [N]: 56 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)] | N  => [N]}: 46
//│ [C primitive⁰(hb¹) mapb_₀(tb¹)]: 66 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)] | N  => [N]}: 57
//│ [N]: 67 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)] | N  => [N]}: 57
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)] | N  => [N]}: 46 --->
//│ 	[C primitive⁰(ha¹) mapa_₀(ta¹)]: 55
//│ 	[N]: 56
//│ case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)] | N  => [N]}: 57 --->
//│ 	[C primitive⁰(hb¹) mapb_₀(tb¹)]: 66
//│ 	[N]: 67
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ sum_₀(mapa_₀(mapb_₀(primitive⁰)))
//│ def mapa_₀(lsa²) = 
//│ 	lsa²(99)
//│ def mapb_₀(lsb²) = 
//│ 	case lsb² of {
//│ 		C hb¹ tb¹ => 
//│ 			let ta² = mapb_₀(tb¹)
//│ 			in let ha² = primitive⁰(hb¹)
//│ 			in (fun _lh_dummy¹ -> 
//│ 				let t² = mapa_₀(ta²)
//│ 				in (fun _lh_dummy⁰ -> [S [N] sum_₀(t²)]))
//│ 		| N  => (fun _lh_dummy³ -> (fun _lh_dummy² -> [N]))}
//│ def sum_₀(ls²) = 
//│ 	ls²(99)
//│ <<<<<<< after fusion <<<<<<<




// CORRECT:
let p = C(N)
fun c(x) = if C(x) is
  C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|N|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (N,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^10(p^11)
//│ def c(x⁰) = case [C x⁰] of {
//│ 	C a⁰ => c^5(a⁰)}
//│ def p = [C [N]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^10] (hopeless to continue)
//│ 	[c^10 · c^5] ---> [c^10] (using original def)
//│ [p^11] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x¹) = 
//│ 	case [C x¹] of {
//│ 		C a¹ => c_₀(a¹)}
//│ def p_₀ = 
//│ 	[C [N]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => c_₀(a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => c_₀(a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => c_₀(a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => c_₀(a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x²) = 
//│ 	
//│ 		let a² = x²
//│ 		in (fun _lh_dummy⁰ -> c_₀(a²))(99)
//│ def p_₀ = 
//│ 	[C [N]]
//│ <<<<<<< after fusion <<<<<<<


// let rec p = C(p)
// let q = p
// fun c(x) = if x is
//     C(a) then a
// fun c2(z) = if z is
//     C(b) then c2(b)
// let main = c(q)
// c2(main)



// CORRECT:
_LUMBERHACK_EVAL
let t = T(K, T(N, L, L), T(N, L, L))
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |_LUMBERHACK_EVAL|↵|#let| |t| |#=| |T|(|K|,| |T|(|N|,| |L|,| |L|)|,| |T|(|N|,| |L|,| |L|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {_LUMBERHACK_EVAL; let t = T (K, T (N, L, L,), T (N, L, L,),); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^26(t^27)
//│ def c(x⁰) = case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K  => [KK]
//│ 		| N  => [NN]} c^16(l⁰) c^19(r⁰)]
//│ 	| L  => [LL]}
//│ def t = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^26] (hopeless to continue)
//│ 	[c^26 · c^16] ---> [c^26] (using original def)
//│ 	[c^26 · c^19] ---> [c^26] (using original def)
//│ [t^27] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(t_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		T n¹ l¹ r¹ => [T case n¹ of {
//│ 			K  => [KK]
//│ 			| N  => [NN]} c_₀(l¹) c_₀(r¹)]
//│ 		| L  => [LL]}
//│ def t_₀ = 
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 44 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [N]: 45 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [L]: 46 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [L]: 47 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [T [N] [L] [L]]: 48 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [N]: 49 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [L]: 50 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [L]: 51 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [T [N] [L] [L]]: 52 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 33 --->
//│ 	[K]: 44
//│ 	[N]: 45
//│ 	[N]: 49
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42 --->
//│ 	[L]: 46
//│ 	[L]: 47
//│ 	[T [N] [L] [L]]: 48
//│ 	[L]: 50
//│ 	[L]: 51
//│ 	[T [N] [L] [L]]: 52
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 44 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [N]: 45 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [L]: 46 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [L]: 47 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [T [N] [L] [L]]: 48 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [N]: 49 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [L]: 50 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [L]: 51 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [T [N] [L] [L]]: 52 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 33 --->
//│ 	[K]: 44
//│ 	[N]: 45
//│ 	[N]: 49
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42 --->
//│ 	[L]: 46
//│ 	[L]: 47
//│ 	[T [N] [L] [L]]: 48
//│ 	[L]: 50
//│ 	[L]: 51
//│ 	[T [N] [L] [L]]: 52
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(t_₀)
//│ def c_₀(x²) = 
//│ 	x²(99)
//│ def t_₀ = 
//│ 	let r² = 	
//│ 		let r⁴ = (fun _lh_dummy⁶ -> [LL])
//│ 		in let l⁴ = (fun _lh_dummy⁵ -> [LL])
//│ 		in let n⁴ = [NN]
//│ 		in (fun _lh_dummy⁴ -> [T n⁴ c_₀(l⁴) c_₀(r⁴)])
//│ 	in let l² = 	
//│ 		let r³ = (fun _lh_dummy³ -> [LL])
//│ 		in let l³ = (fun _lh_dummy² -> [LL])
//│ 		in let n³ = [NN]
//│ 		in (fun _lh_dummy¹ -> [T n³ c_₀(l³) c_₀(r³)])
//│ 	in let n² = [KK]
//│ 	in (fun _lh_dummy⁰ -> [T n² c_₀(l²) c_₀(r²)])
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |_LUMBERHACK_EVAL|↵|#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {_LUMBERHACK_EVAL; let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^28(t^29)
//│ def aa = [T [N] [L] [L]]
//│ def bb = [T [N] [L] [L]]
//│ def c(x⁰) = case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K  => [KK]
//│ 		| N  => [NN]} c^18(l⁰) c^21(r⁰)]
//│ 	| L  => [LL]}
//│ def t = [T [K] aa^10 bb^11]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^28] (hopeless to continue)
//│ 	[c^28 · c^18] ---> [c^28] (using original def)
//│ 	[c^28 · c^21] ---> [c^28] (using original def)
//│ [t^29] (hopeless to continue)
//│ 	[t^29 · aa^10] (using original def)
//│ 	[t^29 · bb^11] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(t_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		T n¹ l¹ r¹ => [T case n¹ of {
//│ 			K  => [KK]
//│ 			| N  => [NN]} c_₀(l¹) c_₀(r¹)]
//│ 		| L  => [LL]}
//│ def t_₀ = 
//│ 	[T [K] aa_₀ bb_₀]
//│ 	where
//│ 	def aa_₀ = 
//│ 		[T [N] [L] [L]]
//│ 	def bb_₀ = 
//│ 		[T [N] [L] [L]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 31 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [L]: 32 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [L]: 33 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [T [N] [L] [L]]: 34 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [K]: 50 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [T [K] aa_₀ bb_₀]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [N]: 54 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [L]: 55 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [L]: 56 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [T [N] [L] [L]]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 39 --->
//│ 	[N]: 31
//│ 	[K]: 50
//│ 	[N]: 54
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48 --->
//│ 	[L]: 32
//│ 	[L]: 33
//│ 	[T [N] [L] [L]]: 34
//│ 	[T [K] aa_₀ bb_₀]: 53
//│ 	[L]: 55
//│ 	[L]: 56
//│ 	[T [N] [L] [L]]: 57
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 31 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [L]: 32 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [L]: 33 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [T [N] [L] [L]]: 34 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [K]: 50 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [T [K] aa_₀ bb_₀]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [N]: 54 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [L]: 55 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [L]: 56 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [T [N] [L] [L]]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 39 --->
//│ 	[N]: 31
//│ 	[K]: 50
//│ 	[N]: 54
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48 --->
//│ 	[L]: 32
//│ 	[L]: 33
//│ 	[T [N] [L] [L]]: 34
//│ 	[T [K] aa_₀ bb_₀]: 53
//│ 	[L]: 55
//│ 	[L]: 56
//│ 	[T [N] [L] [L]]: 57
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(t_₀)
//│ def c_₀(x²) = 
//│ 	x²(99)
//│ def t_₀ = 
//│ 	let r³ = bb_₀
//│ 	in let l³ = aa_₀
//│ 	in let n³ = [KK]
//│ 	in (fun _lh_dummy³ -> [T n³ c_₀(l³) c_₀(r³)])
//│ 	where
//│ 	def aa_₀ = 
//│ 		let r⁴ = (fun _lh_dummy⁶ -> [LL])
//│ 		in let l⁴ = (fun _lh_dummy⁵ -> [LL])
//│ 		in let n⁴ = [NN]
//│ 		in (fun _lh_dummy⁴ -> [T n⁴ c_₀(l⁴) c_₀(r⁴)])
//│ 	def bb_₀ = 
//│ 		let r² = (fun _lh_dummy² -> [LL])
//│ 		in let l² = (fun _lh_dummy¹ -> [LL])
//│ 		in let n² = [NN]
//│ 		in (fun _lh_dummy⁰ -> [T n² c_₀(l²) c_₀(r²)])
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
fun map(ls) = if ls is
  C(h, t) then f => C(f(h), map(t)(f))
  N then f => N
let l = C(K, N)
map(l)(
  x => if x is
    K then T
)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#let| |l| |#=| |C|(|K|,| |N|)|↵|map|(|l|)|(|→|x| |=>| |#if| |x| |is|→|K| |#then| |T|←|←|↵|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, => if ls is ‹(C (h, t,)) then f, => C (f (h,), map (t,) (f,),); (N) then f, => N›; let l = C (K, N,); map (l,) (x, => if x is ‹(K) then T›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^19(l^20, (fun x⁰ -> case x⁰ of {
//│ 	K  => [T]}))
//│ def l = [C [K] [N]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map^5(t⁰, f⁰)])
//│ 	| N  => (fun f¹ -> [N])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [T] [N]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^20] (hopeless to continue)
//│ [map^19] (hopeless to continue)
//│ 	[map^19 · map^5] ---> [map^19] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map_₀(l_₀, (fun x¹ -> case x¹ of {
//│ 	K  => [T]}))
//│ def l_₀ = 
//│ 	[C [K] [N]]
//│ def map_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => (fun f² -> [C f²(h¹) map_₀(t¹, f²)])
//│ 		| N  => (fun f³ -> [N])}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 27 --->
//│ 	case x¹ of {K  => [T]}: 50
//│ [N]: 28 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map_₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43
//│ [C [K] [N]]: 29 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map_₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map_₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43 --->
//│ 	[N]: 28
//│ 	[C [K] [N]]: 29
//│ case x¹ of {K  => [T]}: 50 --->
//│ 	DeadCodeProd
//│ 	[K]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 28 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map_₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43
//│ [C [K] [N]]: 29 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map_₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map_₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43 --->
//│ 	[N]: 28
//│ 	[C [K] [N]]: 29
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map_₀(l_₀, (fun x² -> case x² of {
//│ 	K  => [T]}))
//│ def l_₀ = 
//│ 	let t² = (fun f⁵ -> [N])
//│ 	in let h² = [K]
//│ 	in (fun f⁴ -> [C f⁴(h²) map_₀(t², f⁴)])
//│ def map_₀(ls²) = 
//│ 	ls²
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [T] [N]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
fun last(ys) = if ys is
  N then x => x
  C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
  N then None
  C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastDrive^22([C 1 [C 2 [N]]])
//│ def last(ys⁰) = case ys⁰ of {
//│ 	N  => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> last^4(t⁰, h⁰))}
//│ def lastDrive(xs⁰) = case xs⁰ of {
//│ 	N  => [None]
//│ 	| C hh⁰ tt⁰ => [Some last^14(tt⁰, hh⁰)]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [Some 2]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive^22] (hopeless to continue)
//│ 	[lastDrive^22 · last^14] (using original def)
//│ 		[lastDrive^22 · last^14 · last^4] ---> [lastDrive^22 · last^14] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastDrive_₀([C 1 [C 2 [N]]])
//│ def lastDrive_₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => [None]
//│ 		| C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}
//│ 	where
//│ 	def last_₀(ys¹) = 
//│ 		case ys¹ of {
//│ 			N  => (fun x² -> x²)
//│ 			| C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastDrive_₀(
//│ 	let tt² = 	
//│ 		let t² = (fun x⁵ -> x⁵)
//│ 		in let h² = 2
//│ 		in (fun x⁴ -> last_₀(t², h²))
//│ 	in let hh² = 1
//│ 	in (fun _lh_dummy⁰ -> [Some last_₀(tt², hh²)]))
//│ def lastDrive_₀(xs²) = 
//│ 	xs²(99)
//│ 	where
//│ 	def last_₀(ys²) = 
//│ 		ys²
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 2]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT: with expanding termination
let p = C(p)
fun c(x) = if C(x) is
  C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^10(p^11)
//│ def c(x⁰) = case [C x⁰] of {
//│ 	C a⁰ => c^5(a⁰)}
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^10] (hopeless to continue)
//│ 	[c^10 · c^5] ---> [c^10] (using original def)
//│ [p^11] (hopeless to continue)
//│ 	[p^11 · p^1] ---> [p^11] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x¹) = 
//│ 	case [C x¹] of {
//│ 		C a¹ => c_₀(a¹)}
//│ def p_₀ = 
//│ 	[C p_₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => c_₀(a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => c_₀(a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => c_₀(a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => c_₀(a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x²) = 
//│ 	
//│ 		let a² = x²
//│ 		in (fun _lh_dummy⁰ -> c_₀(a²))(99)
//│ def p_₀ = 
//│ 	[C p_₀]
//│ <<<<<<< after fusion <<<<<<<



// CORRECT: although multiple matches
// top level definitions as producers can be duplicated
fun c1(x1) = if x1 is
  A then AA
  B then BB
fun c2(x2) = if x2 is
  A then AAA
  B then BBB
let a = A
c1(a)
c2(a)
c2(B)
//│ |#fun| |c1|(|x1|)| |#=| |#if| |x1| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|#fun| |c2|(|x2|)| |#=| |#if| |x2| |is|→|A| |#then| |AAA|↵|B| |#then| |BBB|←|↵|#let| |a| |#=| |A|↵|c1|(|a|)|↵|c2|(|a|)|↵|c2|(|B|)|
//│ Parsed: {fun c1 = x1, => if x1 is ‹(A) then AA; (B) then BB›; fun c2 = x2, => if x2 is ‹(A) then AAA; (B) then BBB›; let a = A; c1 (a,); c2 (a,); c2 (B,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c1^12(a^13)
//│ c2^15(a^16)
//│ c2^18([B])
//│ def a = [A]
//│ def c1(x1⁰) = case x1⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def c2(x2⁰) = case x2⁰ of {
//│ 	A  => [AAA]
//│ 	| B  => [BBB]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [a^13] (hopeless to continue)
//│ [a^16] (hopeless to continue)
//│ [c1^12] (hopeless to continue)
//│ [c2^15] (hopeless to continue)
//│ [c2^18] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c1_₀(a_₀)
//│ c2_₀(a_₁)
//│ c2_₁([B])
//│ def a_₀ = 
//│ 	[A]
//│ def a_₁ = 
//│ 	[A]
//│ def c1_₀(x1¹) = 
//│ 	case x1¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def c2_₀(x2¹) = 
//│ 	case x2¹ of {
//│ 		A  => [AAA]
//│ 		| B  => [BBB]}
//│ def c2_₁(x2²) = 
//│ 	case x2² of {
//│ 		A  => [AAA]
//│ 		| B  => [BBB]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 21 --->
//│ 	case x1¹ of {A  => [AA] | B  => [BB]}: 25
//│ [A]: 27 --->
//│ 	case x2¹ of {A  => [AAA] | B  => [BBB]}: 31
//│ [B]: 45 --->
//│ 	case x2² of {A  => [AAA] | B  => [BBB]}: 36
//│ ------------------
//│ case x1¹ of {A  => [AA] | B  => [BB]}: 25 --->
//│ 	[A]: 21
//│ case x2¹ of {A  => [AAA] | B  => [BBB]}: 31 --->
//│ 	[A]: 27
//│ case x2² of {A  => [AAA] | B  => [BBB]}: 36 --->
//│ 	[B]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 21 --->
//│ 	case x1¹ of {A  => [AA] | B  => [BB]}: 25
//│ [A]: 27 --->
//│ 	case x2¹ of {A  => [AAA] | B  => [BBB]}: 31
//│ [B]: 45 --->
//│ 	case x2² of {A  => [AAA] | B  => [BBB]}: 36
//│ ------------------
//│ case x1¹ of {A  => [AA] | B  => [BB]}: 25 --->
//│ 	[A]: 21
//│ case x2¹ of {A  => [AAA] | B  => [BBB]}: 31 --->
//│ 	[A]: 27
//│ case x2² of {A  => [AAA] | B  => [BBB]}: 36 --->
//│ 	[B]: 45
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c1_₀(a_₀)
//│ c2_₀(a_₁)
//│ c2_₁([BBB])
//│ def a_₀ = 
//│ 	[AA]
//│ def a_₁ = 
//│ 	[AAA]
//│ def c1_₀(x1²) = 
//│ 	x1²
//│ def c2_₀(x2⁴) = 
//│ 	x2⁴
//│ def c2_₁(x2³) = 
//│ 	x2³
//│ <<<<<<< after fusion <<<<<<<





// CORRECT:
fun last(ys) = if ys is
  N then x => x
  C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
  N then None
  C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastDrive^22([C 1 [C 2 [N]]])
//│ def last(ys⁰) = case ys⁰ of {
//│ 	N  => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> last^4(t⁰, h⁰))}
//│ def lastDrive(xs⁰) = case xs⁰ of {
//│ 	N  => [None]
//│ 	| C hh⁰ tt⁰ => [Some last^14(tt⁰, hh⁰)]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive^22] (hopeless to continue)
//│ 	[lastDrive^22 · last^14] (using original def)
//│ 		[lastDrive^22 · last^14 · last^4] ---> [lastDrive^22 · last^14] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastDrive_₀([C 1 [C 2 [N]]])
//│ def lastDrive_₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => [None]
//│ 		| C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}
//│ 	where
//│ 	def last_₀(ys¹) = 
//│ 		case ys¹ of {
//│ 			N  => (fun x² -> x²)
//│ 			| C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastDrive_₀(
//│ 	let tt² = 	
//│ 		let t² = (fun x⁵ -> x⁵)
//│ 		in let h² = 2
//│ 		in (fun x⁴ -> last_₀(t², h²))
//│ 	in let hh² = 1
//│ 	in (fun _lh_dummy⁰ -> [Some last_₀(tt², hh²)]))
//│ def lastDrive_₀(xs²) = 
//│ 	xs²(99)
//│ 	where
//│ 	def last_₀(ys²) = 
//│ 		ys²
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: the time of unrolling is correct
fun id(k) = k
fun id1(x) = id(x)
fun id2(y) = y
fun id3(z) = z
let rec p = C(C(C(id7(C(C(id1(p)))))))
fun c(xx) = if xx is
  C(a) then c(a)
fun id4(k) = k
fun id5(j) = j
fun id6(l) = l
fun id7(i) = i
id6(id4)(c)(id5(id2)(id3(p)))
//│ |#fun| |id|(|k|)| |#=| |k|↵|#fun| |id1|(|x|)| |#=| |id|(|x|)|↵|#fun| |id2|(|y|)| |#=| |y|↵|#fun| |id3|(|z|)| |#=| |z|↵|#let| |#rec| |p| |#=| |C|(|C|(|C|(|id7|(|C|(|C|(|id1|(|p|)|)|)|)|)|)|)|↵|#fun| |c|(|xx|)| |#=| |#if| |xx| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id4|(|k|)| |#=| |k|↵|#fun| |id5|(|j|)| |#=| |j|↵|#fun| |id6|(|l|)| |#=| |l|↵|#fun| |id7|(|i|)| |#=| |i|↵|id6|(|id4|)|(|c|)|(|id5|(|id2|)|(|id3|(|p|)|)|)|
//│ Parsed: {fun id = k, => k; fun id1 = x, => id (x,); fun id2 = y, => y; fun id3 = z, => z; let rec p = C (C (C (id7 (C (C (id1 (p,),),),),),),); fun c = xx, => if xx is ‹(C (a,)) then c (a,)›; fun id4 = k, => k; fun id5 = j, => j; fun id6 = l, => l; fun id7 = i, => i; id6 (id4,) (c,) (id5 (id2,) (id3 (p,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ id6^35(id4^36, c^38, id5^40(id2^41, id3^43(p^44)))
//│ def c(xx⁰) = case xx⁰ of {
//│ 	C a⁰ => c^22(a⁰)}
//│ def id(k⁰) = k⁰
//│ def id1(x⁰) = id^3(x⁰)
//│ def id2(y⁰) = y⁰
//│ def id3(z⁰) = z⁰
//│ def id4(k¹) = k¹
//│ def id5(j⁰) = j⁰
//│ def id6(l⁰) = l⁰
//│ def id7(i⁰) = i⁰
//│ def p = [C [C [C id7^11([C [C id1^12(p^13)]])]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^38] (hopeless to continue)
//│ 	[c^38 · c^22] ---> [c^38] (using original def)
//│ [id2^41] (hopeless to continue)
//│ [id3^43] (hopeless to continue)
//│ [id4^36] (hopeless to continue)
//│ [id5^40] (hopeless to continue)
//│ [id6^35] (hopeless to continue)
//│ [p^44] (hopeless to continue)
//│ 	[p^44 · id1^12] (using original def)
//│ 		[p^44 · id1^12 · id^3] (using original def)
//│ 	[p^44 · id7^11] (using original def)
//│ 	[p^44 · p^13] ---> [p^44] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ id6_₀(id4_₀, c_₀, id5_₀(id2_₀, id3_₀(p_₀)))
//│ def c_₀(xx¹) = 
//│ 	case xx¹ of {
//│ 		C a¹ => c_₀(a¹)}
//│ def id2_₀(y¹) = 
//│ 	y¹
//│ def id3_₀(z¹) = 
//│ 	z¹
//│ def id4_₀(k²) = 
//│ 	k²
//│ def id5_₀(j¹) = 
//│ 	j¹
//│ def id6_₀(l¹) = 
//│ 	l¹
//│ def p_₀ = 
//│ 	[C [C [C id7_₀([C [C id1_₀(p_₀)]])]]]
//│ 	where
//│ 	def id1_₀(x¹) = 
//│ 		id_₀(x¹)
//│ 		where
//│ 		def id_₀(k³) = 
//│ 			k³
//│ 	def id7_₀(i¹) = 
//│ 		i¹
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C id1_₀(p_₀)]: 74 --->
//│ 	case xx¹ of {C a¹ => c_₀(a¹)}: 60
//│ [C [C id1_₀(p_₀)]]: 75 --->
//│ 	case xx¹ of {C a¹ => c_₀(a¹)}: 60
//│ [C id7_₀([C [C id1_₀(p_₀)]])]: 77 --->
//│ 	case xx¹ of {C a¹ => c_₀(a¹)}: 60
//│ [C [C id7_₀([C [C id1_₀(p_₀)]])]]: 78 --->
//│ 	case xx¹ of {C a¹ => c_₀(a¹)}: 60
//│ [C [C [C id7_₀([C [C id1_₀(p_₀)]])]]]: 79 --->
//│ 	case xx¹ of {C a¹ => c_₀(a¹)}: 60
//│ ------------------
//│ case xx¹ of {C a¹ => c_₀(a¹)}: 60 --->
//│ 	[C id1_₀(p_₀)]: 74
//│ 	[C [C id1_₀(p_₀)]]: 75
//│ 	[C id7_₀([C [C id1_₀(p_₀)]])]: 77
//│ 	[C [C id7_₀([C [C id1_₀(p_₀)]])]]: 78
//│ 	[C [C [C id7_₀([C [C id1_₀(p_₀)]])]]]: 79
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C id1_₀(p_₀)]: 74 --->
//│ 	case xx¹ of {C a¹ => c_₀(a¹)}: 60
//│ [C [C id1_₀(p_₀)]]: 75 --->
//│ 	case xx¹ of {C a¹ => c_₀(a¹)}: 60
//│ [C id7_₀([C [C id1_₀(p_₀)]])]: 77 --->
//│ 	case xx¹ of {C a¹ => c_₀(a¹)}: 60
//│ [C [C id7_₀([C [C id1_₀(p_₀)]])]]: 78 --->
//│ 	case xx¹ of {C a¹ => c_₀(a¹)}: 60
//│ [C [C [C id7_₀([C [C id1_₀(p_₀)]])]]]: 79 --->
//│ 	case xx¹ of {C a¹ => c_₀(a¹)}: 60
//│ ------------------
//│ case xx¹ of {C a¹ => c_₀(a¹)}: 60 --->
//│ 	[C id1_₀(p_₀)]: 74
//│ 	[C [C id1_₀(p_₀)]]: 75
//│ 	[C id7_₀([C [C id1_₀(p_₀)]])]: 77
//│ 	[C [C id7_₀([C [C id1_₀(p_₀)]])]]: 78
//│ 	[C [C [C id7_₀([C [C id1_₀(p_₀)]])]]]: 79
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ id6_₀(id4_₀, c_₀, id5_₀(id2_₀, id3_₀(p_₀)))
//│ def c_₀(xx²) = 
//│ 	xx²(99)
//│ def id2_₀(y²) = 
//│ 	y²
//│ def id3_₀(z²) = 
//│ 	z²
//│ def id4_₀(k⁴) = 
//│ 	k⁴
//│ def id5_₀(j²) = 
//│ 	j²
//│ def id6_₀(l²) = 
//│ 	l²
//│ def p_₀ = 
//│ 	let a² = 	
//│ 		let a³ = 	
//│ 			let a⁴ = id7_₀(
//│ 				let a⁵ = 	
//│ 					let a⁶ = id1_₀(p_₀)
//│ 					in (fun _lh_dummy⁴ -> c_₀(a⁶))
//│ 				in (fun _lh_dummy³ -> c_₀(a⁵)))
//│ 			in (fun _lh_dummy² -> c_₀(a⁴))
//│ 		in (fun _lh_dummy¹ -> c_₀(a³))
//│ 	in (fun _lh_dummy⁰ -> c_₀(a²))
//│ 	where
//│ 	def id1_₀(x²) = 
//│ 		id_₀(x²)
//│ 		where
//│ 		def id_₀(k⁵) = 
//│ 			k⁵
//│ 	def id7_₀(i²) = 
//│ 		i²
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
fun id(x) = if x is
  ID(b) then b
  C(a) then id(ID(C(a)))
let p = C(p)
fun c(y) = if y is
  C(aa) then c(aa)
c(id(p))
//│ |#fun| |id|(|x|)| |#=| |#if| |x| |is|→|ID|(|b|)| |#then| |b|↵|C|(|a|)| |#then| |id|(|ID|(|C|(|a|)|)|)|←|↵|#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |c|(|aa|)|←|↵|c|(|id|(|p|)|)|
//│ Parsed: {fun id = x, => if x is ‹(ID (b,)) then b; (C (a,)) then id (ID (C (a,),),)›; let p = C (p,); fun c = y, => if y is ‹(C (aa,)) then c (aa,)›; c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^18(id^19(p^20))
//│ def c(y⁰) = case y⁰ of {
//│ 	C aa⁰ => c^13(aa⁰)}
//│ def id(x⁰) = case x⁰ of {
//│ 	ID b⁰ => b⁰
//│ 	| C a⁰ => id^3([ID [C a⁰]])}
//│ def p = [C p^10]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^18] (hopeless to continue)
//│ 	[c^18 · c^13] ---> [c^18] (using original def)
//│ [id^19] (hopeless to continue)
//│ 	[id^19 · id^3] ---> [id^19] (using original def)
//│ [p^20] (hopeless to continue)
//│ 	[p^20 · p^10] ---> [p^20] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(id_₀(p_₀))
//│ def c_₀(y¹) = 
//│ 	case y¹ of {
//│ 		C aa¹ => c_₀(aa¹)}
//│ def id_₀(x¹) = 
//│ 	case x¹ of {
//│ 		ID b¹ => b¹
//│ 		| C a¹ => id_₀([ID [C a¹]])}
//│ def p_₀ = 
//│ 	[C p_₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p_₀]: 30 --->
//│ 	case y¹ of {C aa¹ => c_₀(aa¹)}: 27
//│ 	case x¹ of {ID b¹ => b¹ | C a¹ => id_₀([ID [C a¹]])}: 38
//│ [C a¹]: 35 --->
//│ 	case y¹ of {C aa¹ => c_₀(aa¹)}: 27
//│ [ID [C a¹]]: 36 --->
//│ 	case x¹ of {ID b¹ => b¹ | C a¹ => id_₀([ID [C a¹]])}: 38
//│ ------------------
//│ case y¹ of {C aa¹ => c_₀(aa¹)}: 27 --->
//│ 	[C p_₀]: 30
//│ 	[C a¹]: 35
//│ case x¹ of {ID b¹ => b¹ | C a¹ => id_₀([ID [C a¹]])}: 38 --->
//│ 	[C p_₀]: 30
//│ 	[ID [C a¹]]: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(id_₀(p_₀))
//│ def c_₀(y²) = 
//│ 	case y² of {
//│ 		C aa¹ => c_₀(aa¹)}
//│ def id_₀(x²) = 
//│ 	case x² of {
//│ 		ID b¹ => b¹
//│ 		| C a¹ => id_₀([ID [C a¹]])}
//│ def p_₀ = 
//│ 	[C p_₀]
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: unlike the rev rev case, TODO: why?
fun map(ls) = if ls is
  C(h, t) then C(
    (if h is
      A then AA
      B then BB
    ),
    map(t)
  )
  N then N
fun len(ls) = if ls is
  C(h, t) then 1 + len(t)
  N then 0
len(map(C(A, C(B, N))))
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#fun| |len|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |1| |+| |len|(|t|)|↵|N| |#then| |0|←|↵|len|(|map|(|C|(|A|,| |C|(|B|,| |N|)|)|)|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(A) then AA; (B) then BB›, ')', map (t,),); (N) then N›; fun len = ls, => if ls is ‹(C (h, t,)) then + (1,) (len (t,),); (N) then 0›; len (map (C (A, C (B, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ len^24(map^25([C [A] [C [B] [N]]]))
//│ def len(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => (1 + len^17(t¹))
//│ 	| N  => 0}
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C case h⁰ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]} map^6(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [len^24] (hopeless to continue)
//│ 	[len^24 · len^17] ---> [len^24] (using original def)
//│ [map^25] (hopeless to continue)
//│ 	[map^25 · map^6] ---> [map^25] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ len_₀(map_₀([C [A] [C [B] [N]]]))
//│ def len_₀(ls³) = 
//│ 	case ls³ of {
//│ 		C h³ t³ => (1 + len_₀(t³))
//│ 		| N  => 0}
//│ def map_₀(ls²) = 
//│ 	case ls² of {
//│ 		C h² t² => [C case h² of {
//│ 			A  => [AA]
//│ 			| B  => [BB]} map_₀(t²)]
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)]: 41 --->
//│ 	case ls³ of {C h³ t³ => (1 + len_₀(t³)) | N  => 0}: 54
//│ [N]: 42 --->
//│ 	case ls³ of {C h³ t³ => (1 + len_₀(t³)) | N  => 0}: 54
//│ [A]: 58 --->
//│ 	case h² of {A  => [AA] | B  => [BB]}: 37
//│ [B]: 59 --->
//│ 	case h² of {A  => [AA] | B  => [BB]}: 37
//│ [N]: 60 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43
//│ [C [B] [N]]: 61 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43
//│ [C [A] [C [B] [N]]]: 62 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43
//│ ------------------
//│ case h² of {A  => [AA] | B  => [BB]}: 37 --->
//│ 	[A]: 58
//│ 	[B]: 59
//│ case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43 --->
//│ 	[N]: 60
//│ 	[C [B] [N]]: 61
//│ 	[C [A] [C [B] [N]]]: 62
//│ case ls³ of {C h³ t³ => (1 + len_₀(t³)) | N  => 0}: 54 --->
//│ 	[C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)]: 41
//│ 	[N]: 42
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)]: 41 --->
//│ 	case ls³ of {C h³ t³ => (1 + len_₀(t³)) | N  => 0}: 54
//│ [N]: 42 --->
//│ 	case ls³ of {C h³ t³ => (1 + len_₀(t³)) | N  => 0}: 54
//│ [A]: 58 --->
//│ 	case h² of {A  => [AA] | B  => [BB]}: 37
//│ [B]: 59 --->
//│ 	case h² of {A  => [AA] | B  => [BB]}: 37
//│ [N]: 60 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43
//│ [C [B] [N]]: 61 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43
//│ [C [A] [C [B] [N]]]: 62 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43
//│ ------------------
//│ case h² of {A  => [AA] | B  => [BB]}: 37 --->
//│ 	[A]: 58
//│ 	[B]: 59
//│ case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43 --->
//│ 	[N]: 60
//│ 	[C [B] [N]]: 61
//│ 	[C [A] [C [B] [N]]]: 62
//│ case ls³ of {C h³ t³ => (1 + len_₀(t³)) | N  => 0}: 54 --->
//│ 	[C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)]: 41
//│ 	[N]: 42
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ len_₀(map_₀(
//│ 	let t⁴ = 	
//│ 		let t⁶ = (fun _lh_dummy⁵ -> (fun _lh_dummy⁴ -> 0))
//│ 		in let h⁵ = [BB]
//│ 		in (fun _lh_dummy³ -> 
//│ 			let t⁷ = map_₀(t⁶)
//│ 			in (fun _lh_dummy² -> (1 + len_₀(t⁷))))
//│ 	in let h⁴ = [AA]
//│ 	in (fun _lh_dummy¹ -> 
//│ 		let t⁵ = map_₀(t⁴)
//│ 		in (fun _lh_dummy⁰ -> (1 + len_₀(t⁵))))))
//│ def len_₀(ls⁵) = 
//│ 	ls⁵(99)
//│ def map_₀(ls⁴) = 
//│ 	ls⁴(99)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: multiple match, but correct
fun f(x) = if x is
  C(a) then f
f(C(A))(C(B))(C(D))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |f|←|↵|f|(|C|(|A|)|)|(|C|(|B|)|)|(|C|(|D|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then f›; f (C (A,),) (C (B,),) (C (D,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^5([C [A]], [C [B]], [C [D]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => f^2}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^5] (hopeless to continue)
//│ 	[f^5 · f^2] ---> [f^5] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([C [A]], [C [B]], [C [D]])
//│ def f_₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => f_₀}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 21 --->
//│ 	case x¹ of {C a¹ => f_₀}: 17
//│ [C [B]]: 24 --->
//│ 	case x¹ of {C a¹ => f_₀}: 17
//│ [C [D]]: 27 --->
//│ 	case x¹ of {C a¹ => f_₀}: 17
//│ ------------------
//│ case x¹ of {C a¹ => f_₀}: 17 --->
//│ 	NoProd
//│ 	[C [A]]: 21
//│ 	[C [B]]: 24
//│ 	[C [D]]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀([C [A]], [C [B]], [C [D]])
//│ def f_₀(x²) = 
//│ 	case x² of {
//│ 		C a¹ => f_₀}
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
let aa = T(N, t, t)
let t = T(K, aa, aa)
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |t|,| |t|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |aa|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, t, t,); let t = T (K, aa, aa,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^24(t^25)
//│ def aa = [T [N] t^2 t^3]
//│ def c(x⁰) = case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K  => [KK]
//│ 		| N  => [NN]} c^14(l⁰) c^17(r⁰)]
//│ 	| L  => [LL]}
//│ def t = [T [K] aa^6 aa^7]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^24] (hopeless to continue)
//│ 	[c^24 · c^14] ---> [c^24] (using original def)
//│ 	[c^24 · c^17] ---> [c^24] (using original def)
//│ [t^25] (hopeless to continue)
//│ 	[t^25 · aa^6] (using original def)
//│ 		[t^25 · aa^6 · t^2] ---> [t^25] (using original def)
//│ 		[t^25 · aa^6 · t^3] ---> [t^25] (using original def)
//│ 	[t^25 · aa^7] (using original def)
//│ 		[t^25 · aa^7 · t^2] ---> [t^25] (using original def)
//│ 		[t^25 · aa^7 · t^3] ---> [t^25] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(t_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		T n¹ l¹ r¹ => [T case n¹ of {
//│ 			K  => [KK]
//│ 			| N  => [NN]} c_₀(l¹) c_₀(r¹)]
//│ 		| L  => [LL]}
//│ def t_₀ = 
//│ 	[T [K] aa_₀ aa_₁]
//│ 	where
//│ 	def aa_₀ = 
//│ 		[T [N] t_₀ t_₀]
//│ 	def aa_₁ = 
//│ 		[T [N] t_₀ t_₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 42 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [N] t_₀ t_₀]: 45 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ [K]: 46 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [K] aa_₀ aa_₁]: 49 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ [N]: 50 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [N] t_₀ t_₀]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 31 --->
//│ 	[N]: 42
//│ 	[K]: 46
//│ 	[N]: 50
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40 --->
//│ 	[T [N] t_₀ t_₀]: 45
//│ 	[T [K] aa_₀ aa_₁]: 49
//│ 	[T [N] t_₀ t_₀]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 42 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [N] t_₀ t_₀]: 45 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ [K]: 46 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [K] aa_₀ aa_₁]: 49 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ [N]: 50 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [N] t_₀ t_₀]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 31 --->
//│ 	[N]: 42
//│ 	[K]: 46
//│ 	[N]: 50
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40 --->
//│ 	[T [N] t_₀ t_₀]: 45
//│ 	[T [K] aa_₀ aa_₁]: 49
//│ 	[T [N] t_₀ t_₀]: 53
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(t_₀)
//│ def c_₀(x²) = 
//│ 	x²(99)
//│ def t_₀ = 
//│ 	let r³ = aa_₁
//│ 	in let l³ = aa_₀
//│ 	in let n³ = [KK]
//│ 	in (fun _lh_dummy¹ -> [T n³ c_₀(l³) c_₀(r³)])
//│ 	where
//│ 	def aa_₀ = 
//│ 		let r⁴ = t_₀
//│ 		in let l⁴ = t_₀
//│ 		in let n⁴ = [NN]
//│ 		in (fun _lh_dummy² -> [T n⁴ c_₀(l⁴) c_₀(r⁴)])
//│ 	def aa_₁ = 
//│ 		let r² = t_₀
//│ 		in let l² = t_₀
//│ 		in let n² = [NN]
//│ 		in (fun _lh_dummy⁰ -> [T n² c_₀(l²) c_₀(r²)])
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: but explode on branches
fun filter(ls) = if ls is
  C(h, t) then if h > 1 is
    True then C(h, filter(t))
    False then filter(t)
  N then N
filter(C(1, C(2, C(3, N))))
//│ |#fun| |filter|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |>| |1| |is|→|True| |#then| |C|(|h|,| |filter|(|t|)|)|↵|False| |#then| |filter|(|t|)|←|↵|N| |#then| |N|←|↵|filter|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {fun filter = ls, => if ls is ‹(C (h, t,)) then if > (h,) (1,) is ‹(True) then C (h, filter (t,),); (False) then filter (t,)›; (N) then N›; filter (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ filter^19([C 1 [C 2 [C 3 [N]]]])
//│ def filter(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case (h⁰ > 1) of {
//│ 		True  => [C h⁰ filter^8(t⁰)]
//│ 		| False  => filter^12(t⁰)}
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [filter^19] (hopeless to continue)
//│ 	[filter^19 · filter^12] ---> [filter^19] (using original def)
//│ 	[filter^19 · filter^8] ---> [filter^19] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ filter_₀([C 1 [C 2 [C 3 [N]]]])
//│ def filter_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => case (h¹ > 1) of {
//│ 			True  => [C h¹ filter_₀(t¹)]
//│ 			| False  => filter_₀(t¹)}
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 50 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ [C 3 [N]]: 51 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ [C 2 [C 3 [N]]]: 52 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ [C 1 [C 2 [C 3 [N]]]]: 53 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44 --->
//│ 	[N]: 50
//│ 	[C 3 [N]]: 51
//│ 	[C 2 [C 3 [N]]]: 52
//│ 	[C 1 [C 2 [C 3 [N]]]]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 50 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ [C 3 [N]]: 51 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ [C 2 [C 3 [N]]]: 52 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ [C 1 [C 2 [C 3 [N]]]]: 53 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44 --->
//│ 	[N]: 50
//│ 	[C 3 [N]]: 51
//│ 	[C 2 [C 3 [N]]]: 52
//│ 	[C 1 [C 2 [C 3 [N]]]]: 53
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ filter_₀(
//│ 	let t² = 	
//│ 		let t³ = 	
//│ 			let t⁴ = (fun _lh_dummy³ -> [N])
//│ 			in let h⁴ = 3
//│ 			in (fun _lh_dummy² -> case (h⁴ > 1) of {
//│ 				True  => [C h⁴ filter_₀(t⁴)]
//│ 				| False  => filter_₀(t⁴)})
//│ 		in let h³ = 2
//│ 		in (fun _lh_dummy¹ -> case (h³ > 1) of {
//│ 			True  => [C h³ filter_₀(t³)]
//│ 			| False  => filter_₀(t³)})
//│ 	in let h² = 1
//│ 	in (fun _lh_dummy⁰ -> case (h² > 1) of {
//│ 		True  => [C h² filter_₀(t²)]
//│ 		| False  => filter_₀(t²)}))
//│ def filter_₀(ls²) = 
//│ 	ls²(99)
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: top level defs used multiple times are fine
// but top level producers used multiple times may result in duplicated computation
let p = C(p)
let pp = C(C(pp))
fun c(x) = if x is
  C(a) then if a is
    C(b) then c(b)
    N then a
  N then x
P(c(pp), c(p))
//│ |#let| |p| |#=| |C|(|p|)|↵|#let| |pp| |#=| |C|(|C|(|pp|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |c|(|b|)|↵|N| |#then| |a|←|↵|N| |#then| |x|←|↵|P|(|c|(|pp|)|,| |c|(|p|)|)|
//│ Parsed: {let p = C (p,); let pp = C (C (pp,),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then c (b,); (N) then a›; (N) then x›; P (c (pp,), c (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ [P c^16(pp^17) c^19(p^20)]
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => c^8(b⁰)
//│ 		| N  => a⁰}
//│ 	| N  => x⁰}
//│ def p = [C p^1]
//│ def pp = [C [C pp^3]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^16] (hopeless to continue)
//│ 	[c^16 · c^8] ---> [c^16] (using original def)
//│ [c^19] (hopeless to continue)
//│ 	[c^19 · c^8] ---> [c^19] (using original def)
//│ [p^20] (hopeless to continue)
//│ 	[p^20 · p^1] ---> [p^20] (using original def)
//│ [pp^17] (hopeless to continue)
//│ 	[pp^17 · pp^3] ---> [pp^17] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ [P c_₀(pp_₀) c_₁(p_₀)]
//│ def c_₀(x²) = 
//│ 	case x² of {
//│ 		C a² => case a² of {
//│ 			C b² => c_₀(b²)
//│ 			| N  => a²}
//│ 		| N  => x²}
//│ def c_₁(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => case a¹ of {
//│ 			C b¹ => c_₁(b¹)
//│ 			| N  => a¹}
//│ 		| N  => x¹}
//│ def p_₀ = 
//│ 	[C p_₀]
//│ def pp_₀ = 
//│ 	[C [C pp_₀]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C pp_₀]: 24 --->
//│ 	NoCons
//│ 	case a² of {C b² => c_₀(b²) | N  => a²}: 44
//│ [C [C pp_₀]]: 25 --->
//│ 	NoCons
//│ 	case x² of {C a² => case a² of {C b² => c_₀(b²) | N  => a²} | N  => x²}: 46
//│ [C p_₀]: 37 --->
//│ 	NoCons
//│ 	case a¹ of {C b¹ => c_₁(b¹) | N  => a¹}: 32
//│ 	case x¹ of {C a¹ => case a¹ of {C b¹ => c_₁(b¹) | N  => a¹} | N  => x¹}: 34
//│ ------------------
//│ case a¹ of {C b¹ => c_₁(b¹) | N  => a¹}: 32 --->
//│ 	[C p_₀]: 37
//│ case x¹ of {C a¹ => case a¹ of {C b¹ => c_₁(b¹) | N  => a¹} | N  => x¹}: 34 --->
//│ 	[C p_₀]: 37
//│ case a² of {C b² => c_₀(b²) | N  => a²}: 44 --->
//│ 	[C pp_₀]: 24
//│ case x² of {C a² => case a² of {C b² => c_₀(b²) | N  => a²} | N  => x²}: 46 --->
//│ 	[C [C pp_₀]]: 25
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ [P c_₀(pp_₀) c_₁(p_₀)]
//│ def c_₀(x⁴) = 
//│ 	case x⁴ of {
//│ 		C a² => case a² of {
//│ 			C b² => c_₀(b²)
//│ 			| N  => a²}
//│ 		| N  => x⁴}
//│ def c_₁(x³) = 
//│ 	case x³ of {
//│ 		C a¹ => case a¹ of {
//│ 			C b¹ => c_₁(b¹)
//│ 			| N  => a¹}
//│ 		| N  => x³}
//│ def p_₀ = 
//│ 	[C p_₀]
//│ def pp_₀ = 
//│ 	[C [C pp_₀]]
//│ <<<<<<< after fusion <<<<<<<


// CORRECT:
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  N then a => a
  C(h, t) then a => rev(t, C(h, a))
fun rev2(ls2) = if ls2 is
  N then a2 => a2
  C(h2, t2) then a2 => rev2(t2, C(h2, a2))
rev2(rev(C(1, C(2, N)))(N))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a| |=>| |a|↵|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|,| |C|(|h|,| |a|)|)|←|↵|#fun| |rev2|(|ls2|)| |#=| |#if| |ls2| |is|→|N| |#then| |a2| |=>| |a2|↵|C|(|h2|,| |t2|)| |#then| |a2| |=>| |rev2|(|t2|,| |C|(|h2|,| |a2|)|)|←|↵|rev2|(|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|N|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(N) then a, => a; (C (h, t,)) then a, => rev (t, C (h, a,),)›; fun rev2 = ls2, => if ls2 is ‹(N) then a2, => a2; (C (h2, t2,)) then a2, => rev2 (t2, C (h2, a2,),)›; rev2 (rev (C (1, C (2, N,),),) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev2^27(rev^28([C 1 [C 2 [N]]], [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	N  => (fun a⁰ -> a⁰)
//│ 	| C h⁰ t⁰ => (fun a¹ -> rev^4(t⁰, [C h⁰ a¹]))}
//│ def rev2(ls2⁰) = case ls2⁰ of {
//│ 	N  => (fun a2⁰ -> a2⁰)
//│ 	| C h2⁰ t2⁰ => (fun a2¹ -> rev2^17(t2⁰, [C h2⁰ a2¹]))}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev2^27] (hopeless to continue)
//│ 	[rev2^27 · rev2^17] ---> [rev2^27] (using original def)
//│ [rev^28] (hopeless to continue)
//│ 	[rev^28 · rev^4] ---> [rev^28] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev2_₀(rev_₀([C 1 [C 2 [N]]], [N]), [N])
//│ def rev2_₀(ls2¹) = 
//│ 	case ls2¹ of {
//│ 		N  => (fun a2² -> a2²)
//│ 		| C h2¹ t2¹ => (fun a2³ -> rev2_₀(t2¹, [C h2¹ a2³]))}
//│ def rev_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		N  => (fun a² -> a²)
//│ 		| C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ a³]: 61 --->
//│ 	case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2_₀(t2¹, [C h2¹ a2³]))}: 51
//│ [N]: 70 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64
//│ [C 2 [N]]: 71 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64
//│ [C 1 [C 2 [N]]]: 72 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64
//│ [N]: 74 --->
//│ 	case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2_₀(t2¹, [C h2¹ a2³]))}: 51
//│ ------------------
//│ case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2_₀(t2¹, [C h2¹ a2³]))}: 51 --->
//│ 	[C h¹ a³]: 61
//│ 	[N]: 74
//│ case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64 --->
//│ 	[N]: 70
//│ 	[C 2 [N]]: 71
//│ 	[C 1 [C 2 [N]]]: 72
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a³]: 61 --->
//│ 	case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2_₀(t2¹, [C h2¹ a2³]))}: 51
//│ [N]: 70 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64
//│ [C 2 [N]]: 71 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64
//│ [C 1 [C 2 [N]]]: 72 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64
//│ [N]: 74 --->
//│ 	case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2_₀(t2¹, [C h2¹ a2³]))}: 51
//│ ------------------
//│ case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2_₀(t2¹, [C h2¹ a2³]))}: 51 --->
//│ 	[C h¹ a³]: 61
//│ 	[N]: 74
//│ case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64 --->
//│ 	[N]: 70
//│ 	[C 2 [N]]: 71
//│ 	[C 1 [C 2 [N]]]: 72
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev2_₀(rev_₀(
//│ 	let t² = 	
//│ 		let t³ = (fun a⁶ -> a⁶)
//│ 		in let h³ = 2
//│ 		in (fun a⁵ -> rev_₀(t³, 
//│ 			let t2³ = a⁵
//│ 			in let h2³ = h³
//│ 			in (fun a2⁵ -> rev2_₀(t2³, [C h2³ a2⁵]))))
//│ 	in let h² = 1
//│ 	in (fun a⁴ -> rev_₀(t², 
//│ 		let t2² = a⁴
//│ 		in let h2² = h²
//│ 		in (fun a2⁴ -> rev2_₀(t2², [C h2² a2⁴])))), (fun a2⁶ -> a2⁶)), [N])
//│ def rev2_₀(ls2²) = 
//│ 	ls2²
//│ def rev_₀(ls²) = 
//│ 	ls²
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [N]]]
//│ <<<<<<< evaluate <<<<<<<


// CORRECT: rev actually works (despite the fact that there are some match clash),
// and duplicated usage of toplevel things are alright
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
rev(C(A, C(B, N)))(N)
rev(rev(C(A, C(B, N)))(N))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|rev|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|N|)|↵|rev|(|rev|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|N|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; rev (C (A, C (B, N,),),) (N,); rev (rev (C (A, C (B, N,),),) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^14([C [A] [C [B] [N]]], [N])
//│ rev^23(rev^24([C [A] [C [B] [N]]], [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev^2(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [B] [C [A] [N]]]
//│ [C [A] [C [B] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14] (hopeless to continue)
//│ 	[rev^14 · rev^2] ---> [rev^14] (using original def)
//│ [rev^23] (hopeless to continue)
//│ 	[rev^23 · rev^2] ---> [rev^23] (using original def)
//│ [rev^24] (hopeless to continue)
//│ 	[rev^24 · rev^2] ---> [rev^24] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀([C [A] [C [B] [N]]], [N])
//│ rev_₁(rev_₂([C [A] [C [B] [N]]], [N]), [N])
//│ def rev_₀(ls²) = 
//│ 	case ls² of {
//│ 		C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴]))
//│ 		| N  => (fun a⁵ -> a⁵)}
//│ def rev_₁(ls³) = 
//│ 	case ls³ of {
//│ 		C h³ t³ => (fun a⁶ -> rev_₁(t³, [C h³ a⁶]))
//│ 		| N  => (fun a⁷ -> a⁷)}
//│ def rev_₂(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²]))
//│ 		| N  => (fun a³ -> a³)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ a²]: 42 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> rev_₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73
//│ [N]: 78 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [C [B] [N]]: 79 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [C [A] [C [B] [N]]]: 80 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [N]: 88 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [C [B] [N]]: 89 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [C [A] [C [B] [N]]]: 90 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [N]: 92 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> rev_₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47 --->
//│ 	[N]: 88
//│ 	[C [B] [N]]: 89
//│ 	[C [A] [C [B] [N]]]: 90
//│ case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60 --->
//│ 	[N]: 78
//│ 	[C [B] [N]]: 79
//│ 	[C [A] [C [B] [N]]]: 80
//│ case ls³ of {C h³ t³ => (fun a⁶ -> rev_₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73 --->
//│ 	[C h¹ a²]: 42
//│ 	[N]: 92
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a²]: 42 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> rev_₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73
//│ [N]: 78 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [C [B] [N]]: 79 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [C [A] [C [B] [N]]]: 80 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [N]: 88 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [C [B] [N]]: 89 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [C [A] [C [B] [N]]]: 90 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [N]: 92 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> rev_₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47 --->
//│ 	[N]: 88
//│ 	[C [B] [N]]: 89
//│ 	[C [A] [C [B] [N]]]: 90
//│ case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60 --->
//│ 	[N]: 78
//│ 	[C [B] [N]]: 79
//│ 	[C [A] [C [B] [N]]]: 80
//│ case ls³ of {C h³ t³ => (fun a⁶ -> rev_₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73 --->
//│ 	[C h¹ a²]: 42
//│ 	[N]: 92
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(
//│ 	let t⁴ = 	
//│ 		let t⁵ = (fun a¹⁰ -> a¹⁰)
//│ 		in let h⁵ = [B]
//│ 		in (fun a⁹ -> rev_₀(t⁵, [C h⁵ a⁹]))
//│ 	in let h⁴ = [A]
//│ 	in (fun a⁸ -> rev_₀(t⁴, [C h⁴ a⁸])), [N])
//│ rev_₁(rev_₂(
//│ 	let t⁶ = 	
//│ 		let t⁸ = (fun a¹⁵ -> a¹⁵)
//│ 		in let h⁸ = [B]
//│ 		in (fun a¹³ -> rev_₂(t⁸, 
//│ 			let t⁹ = a¹³
//│ 			in let h⁹ = h⁸
//│ 			in (fun a¹⁴ -> rev_₁(t⁹, [C h⁹ a¹⁴]))))
//│ 	in let h⁶ = [A]
//│ 	in (fun a¹¹ -> rev_₂(t⁶, 
//│ 		let t⁷ = a¹¹
//│ 		in let h⁷ = h⁶
//│ 		in (fun a¹² -> rev_₁(t⁷, [C h⁷ a¹²])))), (fun a¹⁶ -> a¹⁶)), [N])
//│ def rev_₀(ls⁵) = 
//│ 	ls⁵
//│ def rev_₁(ls⁶) = 
//│ 	ls⁶
//│ def rev_₂(ls⁴) = 
//│ 	ls⁴
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [B] [C [A] [N]]]
//│ [C [A] [C [B] [N]]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT: using primitive is also correct
fun rev(ls) = if ls is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
rev(rev(primitive)(N))(N)
//│ |#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|rev|(|rev|(|primitive|)|(|N|)|)|(|N|)|
//│ Parsed: {fun rev = ls, => if ls is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; rev (rev (primitive,) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^14(rev^15(primitive⁰, [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev^2(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14] (hopeless to continue)
//│ 	[rev^14 · rev^2] ---> [rev^14] (using original def)
//│ [rev^15] (hopeless to continue)
//│ 	[rev^15 · rev^2] ---> [rev^15] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀(rev_₁(primitive⁰, [N]), [N])
//│ def rev_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²]))
//│ 		| N  => (fun a³ -> a³)}
//│ def rev_₁(ls²) = 
//│ 	case ls² of {
//│ 		C h² t² => (fun a⁴ -> rev_₁(t², [C h² a⁴]))
//│ 		| N  => (fun a⁵ -> a⁵)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h² a⁴]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ [N]: 53 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34 --->
//│ 	[C h² a⁴]: 42
//│ 	[N]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h² a⁴]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ [N]: 53 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34 --->
//│ 	[C h² a⁴]: 42
//│ 	[N]: 53
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(rev_₁(primitive⁰, (fun a⁶ -> a⁶)), [N])
//│ def rev_₀(ls³) = 
//│ 	ls³
//│ def rev_₁(ls⁴) = 
//│ 	case ls⁴ of {
//│ 		C h² t² => (fun a⁷ -> rev_₁(t², 
//│ 			let t³ = a⁷
//│ 			in let h³ = h²
//│ 			in (fun a⁸ -> rev_₀(t³, [C h³ a⁸]))))
//│ 		| N  => (fun a⁹ -> a⁹)}
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: even normal rev can be optimized?
// NOTE: may be only out of luck: we choose 
_LUMBERHACK_EVAL
fun concat(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(C(1, C(2, N)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^27([C 1 [C 2 [N]]])
//│ def concat(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat^5(t⁰, ys¹)])}
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^15(rev^16(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^27] (hopeless to continue)
//│ 	[rev^27 · concat^15] (using original def)
//│ 		[rev^27 · concat^15 · concat^5] ---> [rev^27 · concat^15] (using original def)
//│ 	[rev^27 · rev^16] ---> [rev^27] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀([C 1 [C 2 [N]]])
//│ def rev_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]])
//│ 		| N  => [N]}
//│ 	where
//│ 	def concat_₀(xs¹) = 
//│ 		case xs¹ of {
//│ 			N  => (fun ys² -> ys²)
//│ 			| C h² t² => (fun ys³ -> [C h² concat_₀(t², ys³)])}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h² concat_₀(t², ys³)]: 43 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat_₀(t², ys³)])}: 45
//│ [N]: 54 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat_₀(t², ys³)])}: 45
//│ [C h³ [N]]: 55 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat_₀(t², ys³)])}: 45
//│ [N]: 57 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat_₀(t², ys³)])}: 45
//│ [N]: 63 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ [C 2 [N]]: 64 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ [C 1 [C 2 [N]]]: 65 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat_₀(t², ys³)])}: 45 --->
//│ 	[C h² concat_₀(t², ys³)]: 43
//│ 	[N]: 54
//│ 	[C h³ [N]]: 55
//│ 	[N]: 57
//│ case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58 --->
//│ 	[N]: 63
//│ 	[C 2 [N]]: 64
//│ 	[C 1 [C 2 [N]]]: 65
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 63 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ [C 2 [N]]: 64 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ [C 1 [C 2 [N]]]: 65 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ ------------------
//│ case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58 --->
//│ 	[N]: 63
//│ 	[C 2 [N]]: 64
//│ 	[C 1 [C 2 [N]]]: 65
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(
//│ 	let t⁴ = 	
//│ 		let t⁵ = (fun _lh_dummy² -> [N])
//│ 		in let h⁵ = 2
//│ 		in (fun _lh_dummy¹ -> concat_₀(rev_₀(t⁵), [C h⁵ [N]]))
//│ 	in let h⁴ = 1
//│ 	in (fun _lh_dummy⁰ -> concat_₀(rev_₀(t⁴), [C h⁴ [N]])))
//│ def rev_₀(ls²) = 
//│ 	ls²(99)
//│ 	where
//│ 	def concat_₀(xs²) = 
//│ 		case xs² of {
//│ 			N  => (fun ys⁴ -> ys⁴)
//│ 			| C h² t² => (fun ys⁵ -> [C h² concat_₀(t², ys⁵)])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [concat_₀^18] (hopeless to continue)
//│ 	[concat_₀^18 · concat_₀^35] ---> [concat_₀^18] (using original def)
//│ [concat_₀^5] (hopeless to continue)
//│ 	[concat_₀^5 · concat_₀^35] ---> [concat_₀^5] (using original def)
//│ [rev_₀^19] (hopeless to continue)
//│ [rev_₀^1] (hopeless to continue)
//│ [rev_₀^6] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀_₁(
//│ 	let t⁵ = 	
//│ 		let t⁶ = (fun _lh_dummy³ -> [N])
//│ 		in let h⁵ = 2
//│ 		in (fun _lh_dummy⁴ -> concat_₀_₁(rev_₀_₂(t⁶), [C h⁵ [N]]))
//│ 	in let h⁶ = 1
//│ 	in (fun _lh_dummy⁵ -> concat_₀_₀(rev_₀_₀(t⁵), [C h⁶ [N]])))
//│ def concat_₀_₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => (fun ys² -> ys²)
//│ 		| C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}
//│ def concat_₀_₁(xs²) = 
//│ 	case xs² of {
//│ 		N  => (fun ys⁴ -> ys⁴)
//│ 		| C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ concat_₀_₁(t⁴, ys⁵)])}
//│ def rev_₀_₀(ls¹) = 
//│ 	ls¹(99)
//│ def rev_₀_₁(ls²) = 
//│ 	ls²(99)
//│ def rev_₀_₂(ls³) = 
//│ 	ls³(99)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁴ concat_₀_₁(t⁴, ys⁵)]: 70 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59
//│ [N]: 87 --->
//│ 	case xs² of {N  => (fun ys⁴ -> ys⁴) | C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ concat_₀_₁(t⁴, ys⁵)])}: 72
//│ [N]: 96 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59
//│ [C h⁵ [N]]: 97 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59 --->
//│ 	[C h⁴ concat_₀_₁(t⁴, ys⁵)]: 70
//│ 	[N]: 96
//│ 	[C h⁵ [N]]: 97
//│ case xs² of {N  => (fun ys⁴ -> ys⁴) | C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ concat_₀_₁(t⁴, ys⁵)])}: 72 --->
//│ 	DeadCodeProd
//│ 	[N]: 87
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h⁴ concat_₀_₁(t⁴, ys⁵)]: 70 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59
//│ [N]: 96 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59
//│ [C h⁵ [N]]: 97 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59 --->
//│ 	[C h⁴ concat_₀_₁(t⁴, ys⁵)]: 70
//│ 	[N]: 96
//│ 	[C h⁵ [N]]: 97
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀_₁(
//│ 	let t⁷ = 	
//│ 		let t⁸ = (fun _lh_dummy⁶ -> [N])
//│ 		in let h⁷ = 2
//│ 		in (fun _lh_dummy⁷ -> concat_₀_₁(rev_₀_₂(t⁸), 
//│ 			let t⁹ = (fun ys⁷ -> ys⁷)
//│ 			in let h⁸ = h⁷
//│ 			in (fun ys⁶ -> [C h⁸ concat_₀_₀(t⁹, ys⁶)])))
//│ 	in let h⁹ = 1
//│ 	in (fun _lh_dummy⁸ -> concat_₀_₀(rev_₀_₀(t⁷), [C h⁹ [N]])))
//│ def concat_₀_₀(xs⁴) = 
//│ 	xs⁴
//│ def concat_₀_₁(xs³) = 
//│ 	case xs³ of {
//│ 		N  => (fun ys⁸ -> ys⁸)
//│ 		| C h⁴ t⁴ => (fun ys⁹ -> 
//│ 			let t¹⁰ = concat_₀_₁(t⁴, ys⁹)
//│ 			in let h¹⁰ = h⁴
//│ 			in (fun ys¹⁰ -> [C h¹⁰ concat_₀_₀(t¹⁰, ys¹⁰)]))}
//│ def rev_₀_₀(ls⁴) = 
//│ 	ls⁴(99)
//│ def rev_₀_₁(ls⁵) = 
//│ 	ls⁵(99)
//│ def rev_₀_₂(ls⁶) = 
//│ 	ls⁶(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<


// CORRECT: but will be WRONG: if strategy-filtering is strict, since y is a destination of [C 1 N]
fun f(x) = if A(x) is
  A(y) then if x is
    C(h, t) then t
f(C(1, N))
//│ |#fun| |f|(|x|)| |#=| |#if| |A|(|x|)| |is|→|A|(|y|)| |#then| |#if| |x| |is|→|C|(|h|,| |t|)| |#then| |t|←|←|↵|f|(|C|(|1|,| |N|)|)|
//│ Parsed: {fun f = x, => if A (x,) is ‹(A (y,)) then if x is ‹(C (h, t,)) then t››; f (C (1, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^8([C 1 [N]])
//│ def f(x⁰) = case [A x⁰] of {
//│ 	A y⁰ => case x⁰ of {
//│ 		C h⁰ t⁰ => t⁰}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^8] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([C 1 [N]])
//│ def f_₀(x¹) = 
//│ 	case [A x¹] of {
//│ 		A y¹ => case x¹ of {
//│ 			C h¹ t¹ => t¹}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A x¹]: 14 --->
//│ 	case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18
//│ [C 1 [N]]: 23 --->
//│ 	DeadCodeCons
//│ 	case x¹ of {C h¹ t¹ => t¹}: 17
//│ ------------------
//│ case x¹ of {C h¹ t¹ => t¹}: 17 --->
//│ 	[C 1 [N]]: 23
//│ case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18 --->
//│ 	[A x¹]: 14
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A x¹]: 14 --->
//│ 	case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18
//│ ------------------
//│ case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18 --->
//│ 	[A x¹]: 14
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀([C 1 [N]])
//│ def f_₀(x²) = 
//│ 	(fun x³ -> case x³ of {
//│ 		C h¹ t¹ => t¹})(x²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f_₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀_₀([C 1 [N]])
//│ def f_₀_₀(x²) = 
//│ 	(fun x³ -> case x³ of {
//│ 		C h¹ t¹ => t¹})(x²)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 23 --->
//│ 	case x³ of {C h¹ t¹ => t¹}: 15
//│ ------------------
//│ case x³ of {C h¹ t¹ => t¹}: 15 --->
//│ 	[C 1 [N]]: 23
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 [N]]: 23 --->
//│ 	case x³ of {C h¹ t¹ => t¹}: 15
//│ ------------------
//│ case x³ of {C h¹ t¹ => t¹}: 15 --->
//│ 	[C 1 [N]]: 23
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀_₀(
//│ 	let t² = [N]
//│ 	in t²)
//│ def f_₀_₀(x⁴) = 
//│ 	(fun x⁵ -> x⁵)(x⁴)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: after using `last(C(hh, tt))` instead of `last(t)` and pushing in of parameters
_LUMBERHACK_EVAL
fun last(ls) = if ls is
  C(h, t) then
    (
      if t is
        N then h => Some(h)
        C(hh, tt) then h => last(C(hh, tt))
    )(h)
  N then None
last(C(1, C(2, C(3, N))))
//│ |_LUMBERHACK_EVAL|↵|#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then|→|(|→|#if| |t| |is|→|N| |#then| |h| |=>| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |h| |=>| |last|(|C|(|hh|,| |tt|)|)|←|←|↵|)|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun last = ls, => if ls is ‹(C (h, t,)) then {'(' if t is ‹(N) then h, => Some (h,); (C (hh, tt,)) then h, => last (C (hh, tt,),)›, ')' (h,)}; (N) then None›; last (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ last^18([C 1 [C 2 [C 3 [N]]]])
//│ def last(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N  => (fun h¹ -> [Some h¹])
//│ 		| C hh⁰ tt⁰ => (fun h² -> last^6([C hh⁰ tt⁰]))}(h⁰)
//│ 	| N  => [None]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [Some 3]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^18] (hopeless to continue)
//│ 	[last^18 · last^6] ---> [last^18] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ last_₀([C 1 [C 2 [C 3 [N]]]])
//│ def last_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h³ t¹ => case t¹ of {
//│ 			N  => (fun h⁴ -> [Some h⁴])
//│ 			| C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}(h³)
//│ 		| N  => [None]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 35 --->
//│ 	case ls¹ of {C h³ t¹ => case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}(h³) | N  => [None]}: 42
//│ [N]: 48 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38
//│ [C 3 [N]]: 49 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38
//│ [C 2 [C 3 [N]]]: 50 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38
//│ [C 1 [C 2 [C 3 [N]]]]: 51 --->
//│ 	case ls¹ of {C h³ t¹ => case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}(h³) | N  => [None]}: 42
//│ ------------------
//│ case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38 --->
//│ 	[N]: 48
//│ 	[C 3 [N]]: 49
//│ 	[C 2 [C 3 [N]]]: 50
//│ case ls¹ of {C h³ t¹ => case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}(h³) | N  => [None]}: 42 --->
//│ 	[C hh¹ tt¹]: 35
//│ 	[C 1 [C 2 [C 3 [N]]]]: 51
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 48 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38
//│ [C 3 [N]]: 49 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38
//│ [C 2 [C 3 [N]]]: 50 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38
//│ ------------------
//│ case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38 --->
//│ 	[N]: 48
//│ 	[C 3 [N]]: 49
//│ 	[C 2 [C 3 [N]]]: 50
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ last_₀([C 1 
//│ 	let tt² = 	
//│ 		let tt³ = (fun h⁸ -> [Some h⁸])
//│ 		in let hh³ = 3
//│ 		in (fun h⁷ -> last_₀([C hh³ tt³]))
//│ 	in let hh² = 2
//│ 	in (fun h⁶ -> last_₀([C hh² tt²]))])
//│ def last_₀(ls²) = 
//│ 	case ls² of {
//│ 		C h³ t¹ => t¹(h³)
//│ 		| N  => [None]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 3]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last_₀^16] (hopeless to continue)
//│ [last_₀^1] (hopeless to continue)
//│ [last_₀^7] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ last_₀_₁([C 1 
//│ 	let tt² = 	
//│ 		let tt³ = (fun h⁷ -> [Some h⁷])
//│ 		in let hh² = 3
//│ 		in (fun h⁸ -> last_₀_₂([C hh² tt³]))
//│ 	in let hh³ = 2
//│ 	in (fun h⁹ -> last_₀_₀([C hh³ tt²]))])
//│ def last_₀_₀(ls³) = 
//│ 	case ls³ of {
//│ 		C h⁶ t³ => t³(h⁶)
//│ 		| N  => [None]}
//│ def last_₀_₁(ls²) = 
//│ 	case ls² of {
//│ 		C h⁵ t² => t²(h⁵)
//│ 		| N  => [None]}
//│ def last_₀_₂(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h⁴ t¹ => t¹(h⁴)
//│ 		| N  => [None]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh² tt³]: 63 --->
//│ 	case ls¹ of {C h⁴ t¹ => t¹(h⁴) | N  => [None]}: 38
//│ [C hh³ tt²]: 72 --->
//│ 	case ls³ of {C h⁶ t³ => t³(h⁶) | N  => [None]}: 52
//│ [C 1 let tt² = let tt³ = (fun h⁷ -> [Some h⁷])
//│ in let hh² = 3
//│ in (fun h⁸ -> last_₀_₂([C hh² tt³]))
//│ in let hh³ = 2
//│ in (fun h⁹ -> last_₀_₀([C hh³ tt²]))]: 77 --->
//│ 	case ls² of {C h⁵ t² => t²(h⁵) | N  => [None]}: 45
//│ ------------------
//│ case ls¹ of {C h⁴ t¹ => t¹(h⁴) | N  => [None]}: 38 --->
//│ 	[C hh² tt³]: 63
//│ case ls² of {C h⁵ t² => t²(h⁵) | N  => [None]}: 45 --->
//│ 	[C 1 let tt² = let tt³ = (fun h⁷ -> [Some h⁷])
//│ in let hh² = 3
//│ in (fun h⁸ -> last_₀_₂([C hh² tt³]))
//│ in let hh³ = 2
//│ in (fun h⁹ -> last_₀_₀([C hh³ tt²]))]: 77
//│ case ls³ of {C h⁶ t³ => t³(h⁶) | N  => [None]}: 52 --->
//│ 	[C hh³ tt²]: 72
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C hh² tt³]: 63 --->
//│ 	case ls¹ of {C h⁴ t¹ => t¹(h⁴) | N  => [None]}: 38
//│ [C hh³ tt²]: 72 --->
//│ 	case ls³ of {C h⁶ t³ => t³(h⁶) | N  => [None]}: 52
//│ [C 1 let tt² = let tt³ = (fun h⁷ -> [Some h⁷])
//│ in let hh² = 3
//│ in (fun h⁸ -> last_₀_₂([C hh² tt³]))
//│ in let hh³ = 2
//│ in (fun h⁹ -> last_₀_₀([C hh³ tt²]))]: 77 --->
//│ 	case ls² of {C h⁵ t² => t²(h⁵) | N  => [None]}: 45
//│ ------------------
//│ case ls¹ of {C h⁴ t¹ => t¹(h⁴) | N  => [None]}: 38 --->
//│ 	[C hh² tt³]: 63
//│ case ls² of {C h⁵ t² => t²(h⁵) | N  => [None]}: 45 --->
//│ 	[C 1 let tt² = let tt³ = (fun h⁷ -> [Some h⁷])
//│ in let hh² = 3
//│ in (fun h⁸ -> last_₀_₂([C hh² tt³]))
//│ in let hh³ = 2
//│ in (fun h⁹ -> last_₀_₀([C hh³ tt²]))]: 77
//│ case ls³ of {C h⁶ t³ => t³(h⁶) | N  => [None]}: 52 --->
//│ 	[C hh³ tt²]: 72
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ last_₀_₁(
//│ 	let t⁴ = 	
//│ 		let tt⁴ = 	
//│ 			let tt⁵ = (fun h¹¹ -> [Some h¹¹])
//│ 			in let hh⁴ = 3
//│ 			in (fun h¹² -> last_₀_₂(
//│ 				let t⁵ = tt⁵
//│ 				in let h¹³ = hh⁴
//│ 				in (fun _lh_dummy¹ -> t⁵(h¹³))))
//│ 		in let hh⁵ = 2
//│ 		in (fun h¹⁴ -> last_₀_₀(
//│ 			let t⁶ = tt⁴
//│ 			in let h¹⁵ = hh⁵
//│ 			in (fun _lh_dummy² -> t⁶(h¹⁵))))
//│ 	in let h¹⁰ = 1
//│ 	in (fun _lh_dummy⁰ -> t⁴(h¹⁰)))
//│ def last_₀_₀(ls⁶) = 
//│ 	ls⁶(99)
//│ def last_₀_₁(ls⁵) = 
//│ 	ls⁵(99)
//│ def last_₀_₂(ls⁴) = 
//│ 	ls⁴(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 3]
//│ <<<<<<< evaluate <<<<<<<


fun f(x) = if primitive(x) then A(x) else B(x + 1)
fun g(scrut, y) = if scrut is
  A(n) then y + n + 1
  B(m) then y + m
g(f(1), 2)
//│ |#fun| |f|(|x|)| |#=| |#if| |primitive|(|x|)| |#then| |A|(|x|)| |#else| |B|(|x| |+| |1|)|↵|#fun| |g|(|scrut|,| |y|)| |#=| |#if| |scrut| |is|→|A|(|n|)| |#then| |y| |+| |n| |+| |1|↵|B|(|m|)| |#then| |y| |+| |m|←|↵|g|(|f|(|1|)|,| |2|)|
//│ Parsed: {fun f = x, => if (primitive (x,)) then A (x,) else B (+ (x,) (1,),); fun g = scrut, y, => if scrut is ‹(A (n,)) then + (+ (y,) (n,),) (1,); (B (m,)) then + (y,) (m,)›; g (f (1,), 2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ g^32(f^33(1), 2)
//│ def f(x⁰) = if primitive⁰(x⁰) then [A x⁰] else [B (x⁰ + 1)]
//│ def g(scrut⁰, y⁰) = case scrut⁰ of {
//│ 	A n⁰ => ((y⁰ + n⁰) + 1)
//│ 	| B m⁰ => (y⁰ + m⁰)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^33] (hopeless to continue)
//│ [g^32] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ g_₀(f_₀(1), 2)
//│ def f_₀(x¹) = 
//│ 	if primitive⁰(x¹) then [A x¹] else [B (x¹ + 1)]
//│ def g_₀(scrut¹, y¹) = 
//│ 	case scrut¹ of {
//│ 		A n¹ => ((y¹ + n¹) + 1)
//│ 		| B m¹ => (y¹ + m¹)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A x¹]: 61 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ [B (x¹ + 1)]: 67 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ ------------------
//│ case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54 --->
//│ 	[A x¹]: 61
//│ 	[B (x¹ + 1)]: 67
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A x¹]: 61 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ [B (x¹ + 1)]: 67 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ ------------------
//│ case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54 --->
//│ 	[A x¹]: 61
//│ 	[B (x¹ + 1)]: 67
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ g_₀(f_₀(1), 2)
//│ def f_₀(x²) = 
//│ 	if primitive⁰(x²) then 
//│ 		let n² = x²
//│ 		in (fun y³ -> ((y³ + n²) + 1)) else 
//│ 		let m² = (x² + 1)
//│ 		in (fun y⁴ -> (y⁴ + m²))
//│ def g_₀(scrut², y²) = 
//│ 	scrut²(y²)
//│ <<<<<<< after fusion <<<<<<<


:lhInHaskell
ack m n = case m of
          Z -> S n
          S m' -> case n of
                    Z -> ack m' (S Z)
                    S n' -> ack m' (ack m n')
ack (S (S (S Z))) (S (S Z))
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ack_lh^30([S [S [S [Z]]]], [S [S [Z]]])
//│ def ack_lh(_lh_ack_arg1⁰, _lh_ack_arg2⁰) = 
//│ 	let _lh_matchIdent⁰ = _lh_ack_arg1⁰
//│ 	in case _lh_matchIdent⁰ of {
//│ 		Z  => [S _lh_ack_arg2⁰]
//│ 		| S _lh_ack_S_0⁰ => 
//│ 			let _lh_matchIdent¹ = _lh_ack_arg2⁰
//│ 			in case _lh_matchIdent¹ of {
//│ 				Z  => ack_lh^7(_lh_ack_S_0⁰, [S [Z]])
//│ 				| S _lh_ack_S_0¹ => ack_lh^13(_lh_ack_S_0⁰, ack_lh^16(_lh_ack_arg1⁰, _lh_ack_S_0¹))
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ack_lh^30] (hopeless to continue)
//│ 	[ack_lh^30 · ack_lh^13] ---> [ack_lh^30] (using original def)
//│ 	[ack_lh^30 · ack_lh^16] ---> [ack_lh^30] (using original def)
//│ 	[ack_lh^30 · ack_lh^7] ---> [ack_lh^30] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ack_lh_₀([S [S [S [Z]]]], [S [S [Z]]])
//│ def ack_lh_₀(_lh_ack_arg1¹, _lh_ack_arg2¹) = 
//│ 	let _lh_matchIdent² = _lh_ack_arg1¹
//│ 	in case _lh_matchIdent² of {
//│ 		Z  => [S _lh_ack_arg2¹]
//│ 		| S _lh_ack_S_0² => 
//│ 			let _lh_matchIdent³ = _lh_ack_arg2¹
//│ 			in case _lh_matchIdent³ of {
//│ 				Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]])
//│ 				| S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³))
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S _lh_ack_arg2¹]: 43 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ [Z]: 49 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ [S [Z]]: 50 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ [Z]: 70 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ [S [Z]]: 71 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ [S [S [Z]]]: 72 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ [S [S [S [Z]]]]: 73 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ [Z]: 75 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ [S [Z]]: 76 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ [S [S [Z]]]: 77 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ ------------------
//│ case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62 --->
//│ 	[S _lh_ack_arg2¹]: 43
//│ 	[Z]: 49
//│ 	[S [Z]]: 50
//│ 	[Z]: 75
//│ 	[S [Z]]: 76
//│ 	[S [S [Z]]]: 77
//│ case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65 --->
//│ 	[Z]: 70
//│ 	[S [Z]]: 71
//│ 	[S [S [Z]]]: 72
//│ 	[S [S [S [Z]]]]: 73
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Z]: 70 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ [S [Z]]: 71 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ [S [S [Z]]]: 72 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ [S [S [S [Z]]]]: 73 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ ------------------
//│ case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack_lh_₀(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0², ack_lh_₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65 --->
//│ 	[Z]: 70
//│ 	[S [Z]]: 71
//│ 	[S [S [Z]]]: 72
//│ 	[S [S [S [Z]]]]: 73
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ack_lh_₀(
//│ 	let _lh_ack_S_0⁴ = 	
//│ 		let _lh_ack_S_0⁵ = 	
//│ 			let _lh_ack_S_0⁶ = (fun _lh_ack_arg2⁵ -> (fun _lh_ack_arg1⁵ -> [S _lh_ack_arg2⁵]))
//│ 			in (fun _lh_ack_arg2⁴ -> (fun _lh_ack_arg1⁴ -> 
//│ 				let _lh_matchIdent⁶ = _lh_ack_arg2⁴
//│ 				in case _lh_matchIdent⁶ of {
//│ 					Z  => ack_lh_₀(_lh_ack_S_0⁶, [S [Z]])
//│ 					| S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0⁶, ack_lh_₀(_lh_ack_arg1⁴, _lh_ack_S_0³))
//│ 					| _  => error⁰}))
//│ 		in (fun _lh_ack_arg2³ -> (fun _lh_ack_arg1³ -> 
//│ 			let _lh_matchIdent⁵ = _lh_ack_arg2³
//│ 			in case _lh_matchIdent⁵ of {
//│ 				Z  => ack_lh_₀(_lh_ack_S_0⁵, [S [Z]])
//│ 				| S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0⁵, ack_lh_₀(_lh_ack_arg1³, _lh_ack_S_0³))
//│ 				| _  => error⁰}))
//│ 	in (fun _lh_ack_arg2² -> (fun _lh_ack_arg1² -> 
//│ 		let _lh_matchIdent⁴ = _lh_ack_arg2²
//│ 		in case _lh_matchIdent⁴ of {
//│ 			Z  => ack_lh_₀(_lh_ack_S_0⁴, [S [Z]])
//│ 			| S _lh_ack_S_0³ => ack_lh_₀(_lh_ack_S_0⁴, ack_lh_₀(_lh_ack_arg1², _lh_ack_S_0³))
//│ 			| _  => error⁰})), [S [S [Z]]])
//│ def ack_lh_₀(_lh_ack_arg1⁶, _lh_ack_arg2⁶) = 
//│ 	let _lh_matchIdent⁷ = _lh_ack_arg1⁶
//│ 	in _lh_matchIdent⁷(_lh_ack_arg2⁶, _lh_ack_arg1⁶)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ack_lh_₀^14] (hopeless to continue)
//│ [ack_lh_₀^17] (hopeless to continue)
//│ [ack_lh_₀^1] (hopeless to continue)
//│ [ack_lh_₀^31] (hopeless to continue)
//│ [ack_lh_₀^37] (hopeless to continue)
//│ [ack_lh_₀^40] (hopeless to continue)
//│ [ack_lh_₀^54] (hopeless to continue)
//│ [ack_lh_₀^60] (hopeless to continue)
//│ [ack_lh_₀^63] (hopeless to continue)
//│ [ack_lh_₀^8] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ack_lh_₀_₂(
//│ 	let _lh_ack_S_0⁶ = 	
//│ 		let _lh_ack_S_0⁷ = 	
//│ 			let _lh_ack_S_0⁸ = (fun _lh_ack_arg2¹⁵ -> (fun _lh_ack_arg1¹⁵ -> [S _lh_ack_arg2¹⁵]))
//│ 			in (fun _lh_ack_arg2¹⁶ -> (fun _lh_ack_arg1¹⁶ -> 
//│ 				let _lh_matchIdent¹⁴ = _lh_ack_arg2¹⁶
//│ 				in case _lh_matchIdent¹⁴ of {
//│ 					Z  => ack_lh_₀_₉(_lh_ack_S_0⁸, [S [Z]])
//│ 					| S _lh_ack_S_0⁹ => ack_lh_₀_₀(_lh_ack_S_0⁸, ack_lh_₀_₁(_lh_ack_arg1¹⁶, _lh_ack_S_0⁹))
//│ 					| _  => error⁰}))
//│ 		in (fun _lh_ack_arg2¹⁷ -> (fun _lh_ack_arg1¹⁷ -> 
//│ 			let _lh_matchIdent¹⁵ = _lh_ack_arg2¹⁷
//│ 			in case _lh_matchIdent¹⁵ of {
//│ 				Z  => ack_lh_₀_₃(_lh_ack_S_0⁷, [S [Z]])
//│ 				| S _lh_ack_S_0¹⁰ => ack_lh_₀_₄(_lh_ack_S_0⁷, ack_lh_₀_₅(_lh_ack_arg1¹⁷, _lh_ack_S_0¹⁰))
//│ 				| _  => error⁰}))
//│ 	in (fun _lh_ack_arg2¹⁸ -> (fun _lh_ack_arg1¹⁸ -> 
//│ 		let _lh_matchIdent¹⁶ = _lh_ack_arg2¹⁸
//│ 		in case _lh_matchIdent¹⁶ of {
//│ 			Z  => ack_lh_₀_₆(_lh_ack_S_0⁶, [S [Z]])
//│ 			| S _lh_ack_S_0¹¹ => ack_lh_₀_₇(_lh_ack_S_0⁶, ack_lh_₀_₈(_lh_ack_arg1¹⁸, _lh_ack_S_0¹¹))
//│ 			| _  => error⁰})), [S [S [Z]]])
//│ def ack_lh_₀_₀(_lh_ack_arg1⁶, _lh_ack_arg2⁶) = 
//│ 	let _lh_matchIdent⁵ = _lh_ack_arg1⁶
//│ 	in _lh_matchIdent⁵(_lh_ack_arg2⁶, _lh_ack_arg1⁶)
//│ def ack_lh_₀_₁(_lh_ack_arg1¹⁴, _lh_ack_arg2¹⁴) = 
//│ 	let _lh_matchIdent¹³ = _lh_ack_arg1¹⁴
//│ 	in _lh_matchIdent¹³(_lh_ack_arg2¹⁴, _lh_ack_arg1¹⁴)
//│ def ack_lh_₀_₂(_lh_ack_arg1¹³, _lh_ack_arg2¹³) = 
//│ 	let _lh_matchIdent¹² = _lh_ack_arg1¹³
//│ 	in _lh_matchIdent¹²(_lh_ack_arg2¹³, _lh_ack_arg1¹³)
//│ def ack_lh_₀_₃(_lh_ack_arg1⁵, _lh_ack_arg2⁵) = 
//│ 	let _lh_matchIdent⁴ = _lh_ack_arg1⁵
//│ 	in _lh_matchIdent⁴(_lh_ack_arg2⁵, _lh_ack_arg1⁵)
//│ def ack_lh_₀_₄(_lh_ack_arg1¹¹, _lh_ack_arg2¹¹) = 
//│ 	let _lh_matchIdent¹⁰ = _lh_ack_arg1¹¹
//│ 	in _lh_matchIdent¹⁰(_lh_ack_arg2¹¹, _lh_ack_arg1¹¹)
//│ def ack_lh_₀_₅(_lh_ack_arg1⁷, _lh_ack_arg2⁷) = 
//│ 	let _lh_matchIdent⁶ = _lh_ack_arg1⁷
//│ 	in _lh_matchIdent⁶(_lh_ack_arg2⁷, _lh_ack_arg1⁷)
//│ def ack_lh_₀_₆(_lh_ack_arg1⁹, _lh_ack_arg2⁹) = 
//│ 	let _lh_matchIdent⁸ = _lh_ack_arg1⁹
//│ 	in _lh_matchIdent⁸(_lh_ack_arg2⁹, _lh_ack_arg1⁹)
//│ def ack_lh_₀_₇(_lh_ack_arg1¹⁰, _lh_ack_arg2¹⁰) = 
//│ 	let _lh_matchIdent⁹ = _lh_ack_arg1¹⁰
//│ 	in _lh_matchIdent⁹(_lh_ack_arg2¹⁰, _lh_ack_arg1¹⁰)
//│ def ack_lh_₀_₈(_lh_ack_arg1⁸, _lh_ack_arg2⁸) = 
//│ 	let _lh_matchIdent⁷ = _lh_ack_arg1⁸
//│ 	in _lh_matchIdent⁷(_lh_ack_arg2⁸, _lh_ack_arg1⁸)
//│ def ack_lh_₀_₉(_lh_ack_arg1¹², _lh_ack_arg2¹²) = 
//│ 	let _lh_matchIdent¹¹ = _lh_ack_arg1¹²
//│ 	in _lh_matchIdent¹¹(_lh_ack_arg2¹², _lh_ack_arg1¹²)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S _lh_ack_arg2¹⁵]: 181 --->
//│ 	DeadCodeCons
//│ 	NoCons
//│ 	case _lh_matchIdent¹⁴ of {Z  => ack_lh_₀_₉(_lh_ack_S_0⁸, [S [Z]]) | S _lh_ack_S_0⁹ => ack_lh_₀_₀(_lh_ack_S_0⁸, ack_lh_₀_₁(_lh_ack_arg1¹⁶, _lh_ack_S_0⁹)) | _  => error⁰}: 202
//│ 	case _lh_matchIdent¹⁵ of {Z  => ack_lh_₀_₃(_lh_ack_S_0⁷, [S [Z]]) | S _lh_ack_S_0¹⁰ => ack_lh_₀_₄(_lh_ack_S_0⁷, ack_lh_₀_₅(_lh_ack_arg1¹⁷, _lh_ack_S_0¹⁰)) | _  => error⁰}: 225
//│ [Z]: 189 --->
//│ 	NoCons
//│ 	DeadCodeCons
//│ 	case _lh_matchIdent¹⁴ of {Z  => ack_lh_₀_₉(_lh_ack_S_0⁸, [S [Z]]) | S _lh_ack_S_0⁹ => ack_lh_₀_₀(_lh_ack_S_0⁸, ack_lh_₀_₁(_lh_ack_arg1¹⁶, _lh_ack_S_0⁹)) | _  => error⁰}: 202
//│ 	case _lh_matchIdent¹⁵ of {Z  => ack_lh_₀_₃(_lh_ack_S_0⁷, [S [Z]]) | S _lh_ack_S_0¹⁰ => ack_lh_₀_₄(_lh_ack_S_0⁷, ack_lh_₀_₅(_lh_ack_arg1¹⁷, _lh_ack_S_0¹⁰)) | _  => error⁰}: 225
//│ [S [Z]]: 190 --->
//│ 	DeadCodeCons
//│ 	NoCons
//│ 	case _lh_matchIdent¹⁴ of {Z  => ack_lh_₀_₉(_lh_ack_S_0⁸, [S [Z]]) | S _lh_ack_S_0⁹ => ack_lh_₀_₀(_lh_ack_S_0⁸, ack_lh_₀_₁(_lh_ack_arg1¹⁶, _lh_ack_S_0⁹)) | _  => error⁰}: 202
//│ 	case _lh_matchIdent¹⁵ of {Z  => ack_lh_₀_₃(_lh_ack_S_0⁷, [S [Z]]) | S _lh_ack_S_0¹⁰ => ack_lh_₀_₄(_lh_ack_S_0⁷, ack_lh_₀_₅(_lh_ack_arg1¹⁷, _lh_ack_S_0¹⁰)) | _  => error⁰}: 225
//│ [Z]: 212 --->
//│ 	case _lh_matchIdent¹⁴ of {Z  => ack_lh_₀_₉(_lh_ack_S_0⁸, [S [Z]]) | S _lh_ack_S_0⁹ => ack_lh_₀_₀(_lh_ack_S_0⁸, ack_lh_₀_₁(_lh_ack_arg1¹⁶, _lh_ack_S_0⁹)) | _  => error⁰}: 202
//│ [S [Z]]: 213 --->
//│ 	case _lh_matchIdent¹⁴ of {Z  => ack_lh_₀_₉(_lh_ack_S_0⁸, [S [Z]]) | S _lh_ack_S_0⁹ => ack_lh_₀_₀(_lh_ack_S_0⁸, ack_lh_₀_₁(_lh_ack_arg1¹⁶, _lh_ack_S_0⁹)) | _  => error⁰}: 202
//│ [Z]: 235 --->
//│ 	case _lh_matchIdent¹⁵ of {Z  => ack_lh_₀_₃(_lh_ack_S_0⁷, [S [Z]]) | S _lh_ack_S_0¹⁰ => ack_lh_₀_₄(_lh_ack_S_0⁷, ack_lh_₀_₅(_lh_ack_arg1¹⁷, _lh_ack_S_0¹⁰)) | _  => error⁰}: 225
//│ [S [Z]]: 236 --->
//│ 	case _lh_matchIdent¹⁵ of {Z  => ack_lh_₀_₃(_lh_ack_S_0⁷, [S [Z]]) | S _lh_ack_S_0¹⁰ => ack_lh_₀_₄(_lh_ack_S_0⁷, ack_lh_₀_₅(_lh_ack_arg1¹⁷, _lh_ack_S_0¹⁰)) | _  => error⁰}: 225
//│ [Z]: 254 --->
//│ 	case _lh_matchIdent¹⁶ of {Z  => ack_lh_₀_₆(_lh_ack_S_0⁶, [S [Z]]) | S _lh_ack_S_0¹¹ => ack_lh_₀_₇(_lh_ack_S_0⁶, ack_lh_₀_₈(_lh_ack_arg1¹⁸, _lh_ack_S_0¹¹)) | _  => error⁰}: 248
//│ [S [Z]]: 255 --->
//│ 	case _lh_matchIdent¹⁶ of {Z  => ack_lh_₀_₆(_lh_ack_S_0⁶, [S [Z]]) | S _lh_ack_S_0¹¹ => ack_lh_₀_₇(_lh_ack_S_0⁶, ack_lh_₀_₈(_lh_ack_arg1¹⁸, _lh_ack_S_0¹¹)) | _  => error⁰}: 248
//│ [S [S [Z]]]: 256 --->
//│ 	case _lh_matchIdent¹⁶ of {Z  => ack_lh_₀_₆(_lh_ack_S_0⁶, [S [Z]]) | S _lh_ack_S_0¹¹ => ack_lh_₀_₇(_lh_ack_S_0⁶, ack_lh_₀_₈(_lh_ack_arg1¹⁸, _lh_ack_S_0¹¹)) | _  => error⁰}: 248
//│ ------------------
//│ case _lh_matchIdent¹⁴ of {Z  => ack_lh_₀_₉(_lh_ack_S_0⁸, [S [Z]]) | S _lh_ack_S_0⁹ => ack_lh_₀_₀(_lh_ack_S_0⁸, ack_lh_₀_₁(_lh_ack_arg1¹⁶, _lh_ack_S_0⁹)) | _  => error⁰}: 202 --->
//│ 	DeadCodeProd
//│ 	[S _lh_ack_arg2¹⁵]: 181
//│ 	[Z]: 189
//│ 	[S [Z]]: 190
//│ 	[Z]: 212
//│ 	[S [Z]]: 213
//│ case _lh_matchIdent¹⁵ of {Z  => ack_lh_₀_₃(_lh_ack_S_0⁷, [S [Z]]) | S _lh_ack_S_0¹⁰ => ack_lh_₀_₄(_lh_ack_S_0⁷, ack_lh_₀_₅(_lh_ack_arg1¹⁷, _lh_ack_S_0¹⁰)) | _  => error⁰}: 225 --->
//│ 	DeadCodeProd
//│ 	[S _lh_ack_arg2¹⁵]: 181
//│ 	[Z]: 189
//│ 	[S [Z]]: 190
//│ 	[Z]: 235
//│ 	[S [Z]]: 236
//│ case _lh_matchIdent¹⁶ of {Z  => ack_lh_₀_₆(_lh_ack_S_0⁶, [S [Z]]) | S _lh_ack_S_0¹¹ => ack_lh_₀_₇(_lh_ack_S_0⁶, ack_lh_₀_₈(_lh_ack_arg1¹⁸, _lh_ack_S_0¹¹)) | _  => error⁰}: 248 --->
//│ 	[Z]: 254
//│ 	[S [Z]]: 255
//│ 	[S [S [Z]]]: 256
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Z]: 254 --->
//│ 	case _lh_matchIdent¹⁶ of {Z  => ack_lh_₀_₆(_lh_ack_S_0⁶, [S [Z]]) | S _lh_ack_S_0¹¹ => ack_lh_₀_₇(_lh_ack_S_0⁶, ack_lh_₀_₈(_lh_ack_arg1¹⁸, _lh_ack_S_0¹¹)) | _  => error⁰}: 248
//│ [S [Z]]: 255 --->
//│ 	case _lh_matchIdent¹⁶ of {Z  => ack_lh_₀_₆(_lh_ack_S_0⁶, [S [Z]]) | S _lh_ack_S_0¹¹ => ack_lh_₀_₇(_lh_ack_S_0⁶, ack_lh_₀_₈(_lh_ack_arg1¹⁸, _lh_ack_S_0¹¹)) | _  => error⁰}: 248
//│ [S [S [Z]]]: 256 --->
//│ 	case _lh_matchIdent¹⁶ of {Z  => ack_lh_₀_₆(_lh_ack_S_0⁶, [S [Z]]) | S _lh_ack_S_0¹¹ => ack_lh_₀_₇(_lh_ack_S_0⁶, ack_lh_₀_₈(_lh_ack_arg1¹⁸, _lh_ack_S_0¹¹)) | _  => error⁰}: 248
//│ ------------------
//│ case _lh_matchIdent¹⁶ of {Z  => ack_lh_₀_₆(_lh_ack_S_0⁶, [S [Z]]) | S _lh_ack_S_0¹¹ => ack_lh_₀_₇(_lh_ack_S_0⁶, ack_lh_₀_₈(_lh_ack_arg1¹⁸, _lh_ack_S_0¹¹)) | _  => error⁰}: 248 --->
//│ 	[Z]: 254
//│ 	[S [Z]]: 255
//│ 	[S [S [Z]]]: 256
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ack_lh_₀_₂(
//│ 	let _lh_ack_S_0¹² = 	
//│ 		let _lh_ack_S_0¹³ = 	
//│ 			let _lh_ack_S_0¹⁴ = (fun _lh_ack_arg2¹⁹ -> (fun _lh_ack_arg1¹⁹ -> [S _lh_ack_arg2¹⁹]))
//│ 			in (fun _lh_ack_arg2²⁰ -> (fun _lh_ack_arg1²⁰ -> 
//│ 				let _lh_matchIdent¹⁷ = _lh_ack_arg2²⁰
//│ 				in case _lh_matchIdent¹⁷ of {
//│ 					Z  => ack_lh_₀_₉(_lh_ack_S_0¹⁴, [S [Z]])
//│ 					| S _lh_ack_S_0⁹ => ack_lh_₀_₀(_lh_ack_S_0¹⁴, ack_lh_₀_₁(_lh_ack_arg1²⁰, _lh_ack_S_0⁹))
//│ 					| _  => error⁰}))
//│ 		in (fun _lh_ack_arg2²¹ -> (fun _lh_ack_arg1²¹ -> 
//│ 			let _lh_matchIdent¹⁸ = _lh_ack_arg2²¹
//│ 			in case _lh_matchIdent¹⁸ of {
//│ 				Z  => ack_lh_₀_₃(_lh_ack_S_0¹³, [S [Z]])
//│ 				| S _lh_ack_S_0¹⁰ => ack_lh_₀_₄(_lh_ack_S_0¹³, ack_lh_₀_₅(_lh_ack_arg1²¹, _lh_ack_S_0¹⁰))
//│ 				| _  => error⁰}))
//│ 	in (fun _lh_ack_arg2²² -> (fun _lh_ack_arg1²² -> 
//│ 		let _lh_matchIdent¹⁹ = _lh_ack_arg2²²
//│ 		in _lh_matchIdent¹⁹(_lh_ack_S_0¹², _lh_ack_arg1²²))), 
//│ 	let _lh_ack_S_0¹⁵ = 	
//│ 		let _lh_ack_S_0¹⁷ = (fun _lh_ack_S_0¹⁹ -> (fun _lh_ack_arg1²⁵ -> ack_lh_₀_₆(_lh_ack_S_0¹⁹, [S [Z]])))
//│ 		in (fun _lh_ack_S_0¹⁸ -> (fun _lh_ack_arg1²⁴ -> ack_lh_₀_₇(_lh_ack_S_0¹⁸, ack_lh_₀_₈(_lh_ack_arg1²⁴, _lh_ack_S_0¹⁷))))
//│ 	in (fun _lh_ack_S_0¹⁶ -> (fun _lh_ack_arg1²³ -> ack_lh_₀_₇(_lh_ack_S_0¹⁶, ack_lh_₀_₈(_lh_ack_arg1²³, _lh_ack_S_0¹⁵)))))
//│ def ack_lh_₀_₀(_lh_ack_arg1²⁸, _lh_ack_arg2²⁵) = 
//│ 	let _lh_matchIdent²² = _lh_ack_arg1²⁸
//│ 	in _lh_matchIdent²²(_lh_ack_arg2²⁵, _lh_ack_arg1²⁸)
//│ def ack_lh_₀_₁(_lh_ack_arg1²⁹, _lh_ack_arg2²⁶) = 
//│ 	let _lh_matchIdent²³ = _lh_ack_arg1²⁹
//│ 	in _lh_matchIdent²³(_lh_ack_arg2²⁶, _lh_ack_arg1²⁹)
//│ def ack_lh_₀_₂(_lh_ack_arg1³³, _lh_ack_arg2³⁰) = 
//│ 	let _lh_matchIdent²⁷ = _lh_ack_arg1³³
//│ 	in _lh_matchIdent²⁷(_lh_ack_arg2³⁰, _lh_ack_arg1³³)
//│ def ack_lh_₀_₃(_lh_ack_arg1³⁴, _lh_ack_arg2³¹) = 
//│ 	let _lh_matchIdent²⁸ = _lh_ack_arg1³⁴
//│ 	in _lh_matchIdent²⁸(_lh_ack_arg2³¹, _lh_ack_arg1³⁴)
//│ def ack_lh_₀_₄(_lh_ack_arg1³⁵, _lh_ack_arg2³²) = 
//│ 	let _lh_matchIdent²⁹ = _lh_ack_arg1³⁵
//│ 	in _lh_matchIdent²⁹(_lh_ack_arg2³², _lh_ack_arg1³⁵)
//│ def ack_lh_₀_₅(_lh_ack_arg1³¹, _lh_ack_arg2²⁸) = 
//│ 	let _lh_matchIdent²⁵ = _lh_ack_arg1³¹
//│ 	in _lh_matchIdent²⁵(_lh_ack_arg2²⁸, _lh_ack_arg1³¹)
//│ def ack_lh_₀_₆(_lh_ack_arg1³², _lh_ack_arg2²⁹) = 
//│ 	let _lh_matchIdent²⁶ = _lh_ack_arg1³²
//│ 	in _lh_matchIdent²⁶(_lh_ack_arg2²⁹, _lh_ack_arg1³²)
//│ def ack_lh_₀_₇(_lh_ack_arg1³⁰, _lh_ack_arg2²⁷) = 
//│ 	let _lh_matchIdent²⁴ = _lh_ack_arg1³⁰
//│ 	in _lh_matchIdent²⁴(_lh_ack_arg2²⁷, _lh_ack_arg1³⁰)
//│ def ack_lh_₀_₈(_lh_ack_arg1²⁶, _lh_ack_arg2²³) = 
//│ 	let _lh_matchIdent²⁰ = _lh_ack_arg1²⁶
//│ 	in _lh_matchIdent²⁰(_lh_ack_arg2²³, _lh_ack_arg1²⁶)
//│ def ack_lh_₀_₉(_lh_ack_arg1²⁷, _lh_ack_arg2²⁴) = 
//│ 	let _lh_matchIdent²¹ = _lh_ack_arg1²⁷
//│ 	in _lh_matchIdent²¹(_lh_ack_arg2²⁴, _lh_ack_arg1²⁷)
//│ <<<<<<< after fusion <<<<<<<

:lhInHaskell
:lhEval
test n = foldl (\a b -> a + b) 0 [1..n]
test $ primId 10
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ test_lh^56(primId⁰(10))
//│ def enumFromTo_lh(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh^24((a⁰ + 1), b⁰)] else [LH_N]
//│ def foldl_lh(f⁰, i⁰, ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => foldl_lh^2(f⁰, f⁰(i⁰, h⁰), t⁰)
//│ 	| LH_N  => i⁰}
//│ def test_lh(_lh_test_arg1⁰) = foldl_lh^38((fun a¹ -> (fun b¹ -> (a¹ + b¹))), 0, enumFromTo_lh^49(1, _lh_test_arg1⁰))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 55
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [test_lh^56] (hopeless to continue)
//│ 	[test_lh^56 · enumFromTo_lh^49] (using original def)
//│ 		[test_lh^56 · enumFromTo_lh^49 · enumFromTo_lh^24] ---> [test_lh^56 · enumFromTo_lh^49] (using original def)
//│ 	[test_lh^56 · foldl_lh^38] (using original def)
//│ 		[test_lh^56 · foldl_lh^38 · foldl_lh^2] ---> [test_lh^56 · foldl_lh^38] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ test_lh_₀(primId⁰(10))
//│ def test_lh_₀(_lh_test_arg1¹) = 
//│ 	foldl_lh_₀((fun a³ -> (fun b³ -> (a³ + b³))), 0, enumFromTo_lh_₀(1, _lh_test_arg1¹))
//│ 	where
//│ 	def enumFromTo_lh_₀(a², b²) = 
//│ 		if (a² <= b²) then [LH_C a² enumFromTo_lh_₀((a² + 1), b²)] else [LH_N]
//│ 	def foldl_lh_₀(f¹, i¹, ls¹) = 
//│ 		case ls¹ of {
//│ 			LH_C h¹ t¹ => foldl_lh_₀(f¹, f¹(i¹, h¹), t¹)
//│ 			| LH_N  => i¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a² enumFromTo_lh_₀((a² + 1), b²)]: 76 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_lh_₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 94
//│ [LH_N]: 77 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_lh_₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 94
//│ ------------------
//│ case ls¹ of {LH_C h¹ t¹ => foldl_lh_₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 94 --->
//│ 	[LH_C a² enumFromTo_lh_₀((a² + 1), b²)]: 76
//│ 	[LH_N]: 77
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a² enumFromTo_lh_₀((a² + 1), b²)]: 76 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_lh_₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 94
//│ [LH_N]: 77 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_lh_₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 94
//│ ------------------
//│ case ls¹ of {LH_C h¹ t¹ => foldl_lh_₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 94 --->
//│ 	[LH_C a² enumFromTo_lh_₀((a² + 1), b²)]: 76
//│ 	[LH_N]: 77
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ test_lh_₀(primId⁰(10))
//│ def test_lh_₀(_lh_test_arg1²) = 
//│ 	foldl_lh_₀((fun a⁵ -> (fun b⁵ -> (a⁵ + b⁵))), 0, enumFromTo_lh_₀(1, _lh_test_arg1²))
//│ 	where
//│ 	def enumFromTo_lh_₀(a⁴, b⁴) = 
//│ 		if (a⁴ <= b⁴) then 
//│ 			let t² = enumFromTo_lh_₀((a⁴ + 1), b⁴)
//│ 			in let h² = a⁴
//│ 			in (fun f² -> (fun i² -> foldl_lh_₀(f², f²(i², h²), t²))) else (fun f³ -> (fun i³ -> i³))
//│ 	def foldl_lh_₀(f⁴, i⁴, ls²) = 
//│ 		ls²(f⁴, i⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 55
//│ <<<<<<< evaluate <<<<<<<

:lhInHaskell
:lhEval
:lhGenDistill
test n = sum $ zipWith (\a b -> a * b) (primId [1..n]) (primId [n..(2*n)])
test $ primId 10
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ test_lh^86(primId⁰(10))
//│ def enumFromTo_lh(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh^29((a⁰ + 1), b⁰)] else [LH_N]
//│ def sum_lh(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (h⁰ + sum_lh^47(t⁰))
//│ 	| LH_N  => 0}
//│ def test_lh(_lh_test_arg1⁰) = sum_lh^54(zipWith_lh^55((fun a¹ -> (fun b¹ -> (a¹ * b¹))), primId⁰(enumFromTo_lh^65(1, _lh_test_arg1⁰)), primId⁰(enumFromTo_lh^73(_lh_test_arg1⁰, (2 * _lh_test_arg1⁰)))))
//│ def zipWith_lh(f⁰, xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lh^8(f⁰, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized distiller gen ----------
//│ 		main = (test_lh 10);
//│ 		enumFromTo_lh a_0 b_0 =
//│ 		  (case (le a_0 b_0) of True -> ((LH_C(a_0, ((enumFromTo_lh (plus a_0 1)) b_0)))) | False -> ((LH_N)));
//│ 		sum_lh ls_0 =
//│ 		  (case ls_0 of LH_C(h_0, t_0) -> (plus h_0 (sum_lh t_0)) | LH_N -> 0);
//│ 		test_lh _lh_test_arg1_0 =
//│ 		  (sum_lh (((zipWith_lh (\a_1 b_1 -> (mul a_1 b_1))) ((enumFromTo_lh 1) _lh_test_arg1_0)) ((enumFromTo_lh _lh_test_arg1_0) (mul 2 _lh_test_arg1_0))));
//│ 		zipWith_lh f_0 xs_0 ys_0 =
//│ 		  (case xs_0 of LH_C(hx_0, tx_0) -> (case ys_0 of LH_C(hy_0, ty_0) -> (LH_C(((f_0 hx_0) hy_0), (((zipWith_lh f_0) tx_0) ty_0))) | LH_N -> (LH_N)) | LH_N -> (LH_N))
//│ 		---------- unoptimized distiller gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 880
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [test_lh^86] (hopeless to continue)
//│ 	[test_lh^86 · enumFromTo_lh^65] (using original def)
//│ 		[test_lh^86 · enumFromTo_lh^65 · enumFromTo_lh^29] ---> [test_lh^86 · enumFromTo_lh^65] (using original def)
//│ 	[test_lh^86 · enumFromTo_lh^73] (using original def)
//│ 		[test_lh^86 · enumFromTo_lh^73 · enumFromTo_lh^29] ---> [test_lh^86 · enumFromTo_lh^73] (using original def)
//│ 	[test_lh^86 · sum_lh^54] (using original def)
//│ 		[test_lh^86 · sum_lh^54 · sum_lh^47] ---> [test_lh^86 · sum_lh^54] (using original def)
//│ 	[test_lh^86 · zipWith_lh^55] (using original def)
//│ 		[test_lh^86 · zipWith_lh^55 · zipWith_lh^8] ---> [test_lh^86 · zipWith_lh^55] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ test_lh_₀(primId⁰(10))
//│ def test_lh_₀(_lh_test_arg1¹) = 
//│ 	sum_lh_₀(zipWith_lh_₀((fun a⁴ -> (fun b⁴ -> (a⁴ * b⁴))), primId⁰(enumFromTo_lh_₀(1, _lh_test_arg1¹)), primId⁰(enumFromTo_lh_₁(_lh_test_arg1¹, (2 * _lh_test_arg1¹)))))
//│ 	where
//│ 	def enumFromTo_lh_₀(a³, b³) = 
//│ 		if (a³ <= b³) then [LH_C a³ enumFromTo_lh_₀((a³ + 1), b³)] else [LH_N]
//│ 	def enumFromTo_lh_₁(a², b²) = 
//│ 		if (a² <= b²) then [LH_C a² enumFromTo_lh_₁((a² + 1), b²)] else [LH_N]
//│ 	def sum_lh_₀(ls¹) = 
//│ 		case ls¹ of {
//│ 			LH_C h¹ t¹ => (h¹ + sum_lh_₀(t¹))
//│ 			| LH_N  => 0}
//│ 	def zipWith_lh_₀(f¹, xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			LH_C hx¹ tx¹ => case ys¹ of {
//│ 				LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_lh_₀(f¹, tx¹, ty¹)]
//│ 				| LH_N  => [LH_N]}
//│ 			| LH_N  => [LH_N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f¹(hx¹, hy¹) zipWith_lh_₀(f¹, tx¹, ty¹)]: 136 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_lh_₀(t¹)) | LH_N  => 0}: 120
//│ [LH_N]: 137 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_lh_₀(t¹)) | LH_N  => 0}: 120
//│ [LH_N]: 139 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_lh_₀(t¹)) | LH_N  => 0}: 120
//│ ------------------
//│ case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_lh_₀(t¹)) | LH_N  => 0}: 120 --->
//│ 	[LH_C f¹(hx¹, hy¹) zipWith_lh_₀(f¹, tx¹, ty¹)]: 136
//│ 	[LH_N]: 137
//│ 	[LH_N]: 139
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f¹(hx¹, hy¹) zipWith_lh_₀(f¹, tx¹, ty¹)]: 136 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_lh_₀(t¹)) | LH_N  => 0}: 120
//│ [LH_N]: 137 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_lh_₀(t¹)) | LH_N  => 0}: 120
//│ [LH_N]: 139 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_lh_₀(t¹)) | LH_N  => 0}: 120
//│ ------------------
//│ case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_lh_₀(t¹)) | LH_N  => 0}: 120 --->
//│ 	[LH_C f¹(hx¹, hy¹) zipWith_lh_₀(f¹, tx¹, ty¹)]: 136
//│ 	[LH_N]: 137
//│ 	[LH_N]: 139
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ test_lh_₀(primId⁰(10))
//│ def test_lh_₀(_lh_test_arg1²) = 
//│ 	sum_lh_₀(zipWith_lh_₀((fun a⁵ -> (fun b⁵ -> (a⁵ * b⁵))), primId⁰(enumFromTo_lh_₀(1, _lh_test_arg1²)), primId⁰(enumFromTo_lh_₁(_lh_test_arg1², (2 * _lh_test_arg1²)))))
//│ 	where
//│ 	def enumFromTo_lh_₀(a⁷, b⁷) = 
//│ 		if (a⁷ <= b⁷) then [LH_C a⁷ enumFromTo_lh_₀((a⁷ + 1), b⁷)] else [LH_N]
//│ 	def enumFromTo_lh_₁(a⁶, b⁶) = 
//│ 		if (a⁶ <= b⁶) then [LH_C a⁶ enumFromTo_lh_₁((a⁶ + 1), b⁶)] else [LH_N]
//│ 	def sum_lh_₀(ls²) = 
//│ 		ls²(99)
//│ 	def zipWith_lh_₀(f², xs², ys²) = 
//│ 		case xs² of {
//│ 			LH_C hx¹ tx¹ => case ys² of {
//│ 				LH_C hy¹ ty¹ => 
//│ 					let t² = zipWith_lh_₀(f², tx¹, ty¹)
//│ 					in let h² = f²(hx¹, hy¹)
//│ 					in (fun _lh_dummy⁰ -> (h² + sum_lh_₀(t²)))
//│ 				| LH_N  => (fun _lh_dummy¹ -> 0)}
//│ 			| LH_N  => (fun _lh_dummy² -> 0)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 880
//│ <<<<<<< evaluate <<<<<<<

:lhInHaskell
:lhEval
fact r Z = S Z
fact r (S a) = mmul (S a) (r (mmin (S a) (S Z)))
pplus Z b = b
pplus (S a) b = S (pplus a b)
mmul Z b = Z
mmul (S a) b = pplus b (mmul a b)
mmin a b = case b of {
  Z -> a;
  (S bb) -> case a of {
    Z -> Z;
    (S aa) -> mmin aa bb
  }
}
let mainFact = (\x -> fact (\y -> x x y)) (\x -> fact (\y -> x x y)) in mainFact (primId (S (S (S Z))))
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ let mainFact⁰ = (fun x⁰ -> fact_lh^68((fun y⁰ -> x⁰(x⁰, y⁰))))((fun x¹ -> fact_lh^77((fun y¹ -> x¹(x¹, y¹)))))
//│ in mainFact⁰(primId⁰([S [S [S [Z]]]]))
//│ def fact_lh(_lh_fact_arg1⁰, _lh_fact_arg2⁰) = case _lh_fact_arg2⁰ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_fact_S_0⁰ => mmul_lh^4([S _lh_fact_S_0⁰], _lh_fact_arg1⁰(mmin_lh^9([S _lh_fact_S_0⁰], [S [Z]])))
//│ 	| _  => error⁰}
//│ def mmin_lh(_lh_mmin_arg1⁰, _lh_mmin_arg2⁰) = 
//│ 	let _lh_matchIdent⁰ = _lh_mmin_arg2⁰
//│ 	in case _lh_matchIdent⁰ of {
//│ 		Z  => _lh_mmin_arg1⁰
//│ 		| S _lh_mmin_S_0⁰ => 
//│ 			let _lh_matchIdent¹ = _lh_mmin_arg1⁰
//│ 			in case _lh_matchIdent¹ of {
//│ 				Z  => [Z]
//│ 				| S _lh_mmin_S_0¹ => mmin_lh^40(_lh_mmin_S_0¹, _lh_mmin_S_0⁰)
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ def mmul_lh(_lh_mmul_arg1⁰, _lh_mmul_arg2⁰) = case _lh_mmul_arg1⁰ of {
//│ 	Z  => [Z]
//│ 	| S _lh_mmul_S_0⁰ => pplus_lh^55(_lh_mmul_arg2⁰, mmul_lh^58(_lh_mmul_S_0⁰, _lh_mmul_arg2⁰))
//│ 	| _  => error⁰}
//│ def pplus_lh(_lh_pplus_arg1⁰, _lh_pplus_arg2⁰) = case _lh_pplus_arg1⁰ of {
//│ 	Z  => _lh_pplus_arg2⁰
//│ 	| S _lh_pplus_S_0⁰ => [S pplus_lh^24(_lh_pplus_S_0⁰, _lh_pplus_arg2⁰)]
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [S [S [S [S [S [S [Z]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fact_lh^68] (hopeless to continue)
//│ 	[fact_lh^68 · mmin_lh^9] (using original def)
//│ 		[fact_lh^68 · mmin_lh^9 · mmin_lh^40] ---> [fact_lh^68 · mmin_lh^9] (using original def)
//│ 	[fact_lh^68 · mmul_lh^4] (using original def)
//│ 		[fact_lh^68 · mmul_lh^4 · mmul_lh^58] ---> [fact_lh^68 · mmul_lh^4] (using original def)
//│ 		[fact_lh^68 · mmul_lh^4 · pplus_lh^55] (using original def)
//│ 			[fact_lh^68 · mmul_lh^4 · pplus_lh^55 · pplus_lh^24] ---> [fact_lh^68 · mmul_lh^4 · pplus_lh^55] (using original def)
//│ [fact_lh^77] (hopeless to continue)
//│ 	[fact_lh^77 · mmin_lh^9] (using original def)
//│ 		[fact_lh^77 · mmin_lh^9 · mmin_lh^40] ---> [fact_lh^77 · mmin_lh^9] (using original def)
//│ 	[fact_lh^77 · mmul_lh^4] (using original def)
//│ 		[fact_lh^77 · mmul_lh^4 · mmul_lh^58] ---> [fact_lh^77 · mmul_lh^4] (using original def)
//│ 		[fact_lh^77 · mmul_lh^4 · pplus_lh^55] (using original def)
//│ 			[fact_lh^77 · mmul_lh^4 · pplus_lh^55 · pplus_lh^24] ---> [fact_lh^77 · mmul_lh^4 · pplus_lh^55] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ 
//│ 	let mainFact¹ = (fun x² -> fact_lh_₀((fun y² -> x²(x², y²))))((fun x³ -> fact_lh_₁((fun y³ -> x³(x³, y³)))))
//│ 	in mainFact¹(primId⁰([S [S [S [Z]]]]))
//│ def fact_lh_₀(_lh_fact_arg1¹, _lh_fact_arg2¹) = 
//│ 	case _lh_fact_arg2¹ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0¹ => mmul_lh_₀([S _lh_fact_S_0¹], _lh_fact_arg1¹(mmin_lh_₀([S _lh_fact_S_0¹], [S [Z]])))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_lh_₀(_lh_mmin_arg1², _lh_mmin_arg2²) = 
//│ 		let _lh_matchIdent⁴ = _lh_mmin_arg2²
//│ 		in case _lh_matchIdent⁴ of {
//│ 			Z  => _lh_mmin_arg1²
//│ 			| S _lh_mmin_S_0⁴ => 
//│ 				let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ 				in case _lh_matchIdent⁵ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁵ => mmin_lh_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴)
//│ 					| _  => error⁰}
//│ 			| _  => error⁰}
//│ 	def mmul_lh_₀(_lh_mmul_arg1², _lh_mmul_arg2²) = 
//│ 		case _lh_mmul_arg1² of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0² => pplus_lh_₀(_lh_mmul_arg2², mmul_lh_₀(_lh_mmul_S_0², _lh_mmul_arg2²))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus_lh_₀(_lh_pplus_arg1¹, _lh_pplus_arg2¹) = 
//│ 			case _lh_pplus_arg1¹ of {
//│ 				Z  => _lh_pplus_arg2¹
//│ 				| S _lh_pplus_S_0¹ => [S pplus_lh_₀(_lh_pplus_S_0¹, _lh_pplus_arg2¹)]
//│ 				| _  => error⁰}
//│ def fact_lh_₁(_lh_fact_arg1², _lh_fact_arg2²) = 
//│ 	case _lh_fact_arg2² of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0² => mmul_lh_₁([S _lh_fact_S_0²], _lh_fact_arg1²(mmin_lh_₁([S _lh_fact_S_0²], [S [Z]])))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_lh_₁(_lh_mmin_arg1¹, _lh_mmin_arg2¹) = 
//│ 		let _lh_matchIdent² = _lh_mmin_arg2¹
//│ 		in case _lh_matchIdent² of {
//│ 			Z  => _lh_mmin_arg1¹
//│ 			| S _lh_mmin_S_0² => 
//│ 				let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ 				in case _lh_matchIdent³ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²)
//│ 					| _  => error⁰}
//│ 			| _  => error⁰}
//│ 	def mmul_lh_₁(_lh_mmul_arg1¹, _lh_mmul_arg2¹) = 
//│ 		case _lh_mmul_arg1¹ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0¹ => pplus_lh_₁(_lh_mmul_arg2¹, mmul_lh_₁(_lh_mmul_S_0¹, _lh_mmul_arg2¹))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus_lh_₁(_lh_pplus_arg1², _lh_pplus_arg2²) = 
//│ 			case _lh_pplus_arg1² of {
//│ 				Z  => _lh_pplus_arg2²
//│ 				| S _lh_pplus_S_0² => [S pplus_lh_₁(_lh_pplus_S_0², _lh_pplus_arg2²)]
//│ 				| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Z]: 109 --->
//│ 	case _lh_pplus_arg1¹ of {Z  => _lh_pplus_arg2¹ | S _lh_pplus_S_0¹ => [S pplus_lh_₀(_lh_pplus_S_0¹, _lh_pplus_arg2¹)] | _  => error⁰}: 105
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_lh_₁(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 206
//│ [S _lh_fact_S_0¹]: 128 --->
//│ 	case _lh_mmul_arg1² of {Z  => [Z] | S _lh_mmul_S_0² => pplus_lh_₀(_lh_mmul_arg2², mmul_lh_₀(_lh_mmul_S_0², _lh_mmul_arg2²)) | _  => error⁰}: 175
//│ [S _lh_fact_S_0¹]: 133 --->
//│ 	case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_lh_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 190
//│ 	case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul_lh_₁([S _lh_fact_S_0²], _lh_fact_arg1²(mmin_lh_₁([S _lh_fact_S_0²], [S [Z]]))) | _  => error⁰}: 227
//│ [Z]: 135 --->
//│ 	case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_lh_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 193
//│ [S [Z]]: 136 --->
//│ 	case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_lh_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 193
//│ [Z]: 149 --->
//│ 	case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul_lh_₁([S _lh_fact_S_0²], _lh_fact_arg1²(mmin_lh_₁([S _lh_fact_S_0²], [S [Z]]))) | _  => error⁰}: 227
//│ [Z]: 183 --->
//│ 	case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul_lh_₁([S _lh_fact_S_0²], _lh_fact_arg1²(mmin_lh_₁([S _lh_fact_S_0²], [S [Z]]))) | _  => error⁰}: 227
//│ [S pplus_lh_₁(_lh_pplus_S_0², _lh_pplus_arg2²)]: 204 --->
//│ 	case _lh_pplus_arg1¹ of {Z  => _lh_pplus_arg2¹ | S _lh_pplus_S_0¹ => [S pplus_lh_₀(_lh_pplus_S_0¹, _lh_pplus_arg2¹)] | _  => error⁰}: 105
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_lh_₁(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 206
//│ [Z]: 210 --->
//│ 	case _lh_pplus_arg1¹ of {Z  => _lh_pplus_arg2¹ | S _lh_pplus_S_0¹ => [S pplus_lh_₀(_lh_pplus_S_0¹, _lh_pplus_arg2¹)] | _  => error⁰}: 105
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_lh_₁(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 206
//│ [S [Z]]: 211 --->
//│ 	case _lh_pplus_arg1¹ of {Z  => _lh_pplus_arg2¹ | S _lh_pplus_S_0¹ => [S pplus_lh_₀(_lh_pplus_S_0¹, _lh_pplus_arg2¹)] | _  => error⁰}: 105
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_lh_₁(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 206
//│ [S _lh_fact_S_0²]: 214 --->
//│ 	case _lh_mmul_arg1¹ of {Z  => [Z] | S _lh_mmul_S_0¹ => pplus_lh_₁(_lh_mmul_arg2¹, mmul_lh_₁(_lh_mmul_S_0¹, _lh_mmul_arg2¹)) | _  => error⁰}: 120
//│ [S _lh_fact_S_0²]: 219 --->
//│ 	case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰}: 156
//│ 	case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul_lh_₁([S _lh_fact_S_0²], _lh_fact_arg1²(mmin_lh_₁([S _lh_fact_S_0²], [S [Z]]))) | _  => error⁰}: 227
//│ [Z]: 221 --->
//│ 	case _lh_matchIdent² of {Z  => _lh_mmin_arg1¹ | S _lh_mmin_S_0² => let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ in case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰} | _  => error⁰}: 159
//│ [S [Z]]: 222 --->
//│ 	case _lh_matchIdent² of {Z  => _lh_mmin_arg1¹ | S _lh_mmin_S_0² => let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ in case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰} | _  => error⁰}: 159
//│ ------------------
//│ case _lh_pplus_arg1¹ of {Z  => _lh_pplus_arg2¹ | S _lh_pplus_S_0¹ => [S pplus_lh_₀(_lh_pplus_S_0¹, _lh_pplus_arg2¹)] | _  => error⁰}: 105 --->
//│ 	[Z]: 109
//│ 	[S pplus_lh_₁(_lh_pplus_S_0², _lh_pplus_arg2²)]: 204
//│ 	[Z]: 210
//│ 	[S [Z]]: 211
//│ case _lh_mmul_arg1¹ of {Z  => [Z] | S _lh_mmul_S_0¹ => pplus_lh_₁(_lh_mmul_arg2¹, mmul_lh_₁(_lh_mmul_S_0¹, _lh_mmul_arg2¹)) | _  => error⁰}: 120 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0²]: 214
//│ case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰}: 156 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0²]: 219
//│ case _lh_matchIdent² of {Z  => _lh_mmin_arg1¹ | S _lh_mmin_S_0² => let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ in case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰} | _  => error⁰}: 159 --->
//│ 	[Z]: 221
//│ 	[S [Z]]: 222
//│ case _lh_mmul_arg1² of {Z  => [Z] | S _lh_mmul_S_0² => pplus_lh_₀(_lh_mmul_arg2², mmul_lh_₀(_lh_mmul_S_0², _lh_mmul_arg2²)) | _  => error⁰}: 175 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0¹]: 128
//│ case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_lh_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 190 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0¹]: 133
//│ case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_lh_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 193 --->
//│ 	[Z]: 135
//│ 	[S [Z]]: 136
//│ case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_lh_₁(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 206 --->
//│ 	[Z]: 109
//│ 	[S pplus_lh_₁(_lh_pplus_S_0², _lh_pplus_arg2²)]: 204
//│ 	[Z]: 210
//│ 	[S [Z]]: 211
//│ case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul_lh_₁([S _lh_fact_S_0²], _lh_fact_arg1²(mmin_lh_₁([S _lh_fact_S_0²], [S [Z]]))) | _  => error⁰}: 227 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0¹]: 133
//│ 	[Z]: 149
//│ 	[Z]: 183
//│ 	[S _lh_fact_S_0²]: 219
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Z]: 135 --->
//│ 	case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_lh_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 193
//│ [S [Z]]: 136 --->
//│ 	case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_lh_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 193
//│ [Z]: 221 --->
//│ 	case _lh_matchIdent² of {Z  => _lh_mmin_arg1¹ | S _lh_mmin_S_0² => let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ in case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰} | _  => error⁰}: 159
//│ [S [Z]]: 222 --->
//│ 	case _lh_matchIdent² of {Z  => _lh_mmin_arg1¹ | S _lh_mmin_S_0² => let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ in case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰} | _  => error⁰}: 159
//│ ------------------
//│ case _lh_matchIdent² of {Z  => _lh_mmin_arg1¹ | S _lh_mmin_S_0² => let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ in case _lh_matchIdent³ of {Z  => [Z] | S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0²) | _  => error⁰} | _  => error⁰}: 159 --->
//│ 	[Z]: 221
//│ 	[S [Z]]: 222
//│ case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_lh_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 193 --->
//│ 	[Z]: 135
//│ 	[S [Z]]: 136
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let mainFact² = (fun x⁴ -> fact_lh_₀((fun y⁴ -> x⁴(x⁴, y⁴))))((fun x⁵ -> fact_lh_₁((fun y⁵ -> x⁵(x⁵, y⁵)))))
//│ 	in mainFact²(primId⁰([S [S [S [Z]]]]))
//│ def fact_lh_₀(_lh_fact_arg1³, _lh_fact_arg2³) = 
//│ 	case _lh_fact_arg2³ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0¹ => mmul_lh_₀([S _lh_fact_S_0¹], _lh_fact_arg1³(mmin_lh_₀([S _lh_fact_S_0¹], 
//│ 			let _lh_mmin_S_0⁶ = (fun _lh_mmin_arg1⁵ -> _lh_mmin_arg1⁵)
//│ 			in (fun _lh_mmin_arg1⁴ -> 
//│ 				let _lh_matchIdent⁷ = _lh_mmin_arg1⁴
//│ 				in case _lh_matchIdent⁷ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁵ => mmin_lh_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁶)
//│ 					| _  => error⁰}))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_lh_₀(_lh_mmin_arg1³, _lh_mmin_arg2³) = 
//│ 		let _lh_matchIdent⁶ = _lh_mmin_arg2³
//│ 		in _lh_matchIdent⁶(_lh_mmin_arg1³)
//│ 	def mmul_lh_₀(_lh_mmul_arg1³, _lh_mmul_arg2³) = 
//│ 		case _lh_mmul_arg1³ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0² => pplus_lh_₀(_lh_mmul_arg2³, mmul_lh_₀(_lh_mmul_S_0², _lh_mmul_arg2³))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus_lh_₀(_lh_pplus_arg1⁴, _lh_pplus_arg2⁴) = 
//│ 			case _lh_pplus_arg1⁴ of {
//│ 				Z  => _lh_pplus_arg2⁴
//│ 				| S _lh_pplus_S_0¹ => [S pplus_lh_₀(_lh_pplus_S_0¹, _lh_pplus_arg2⁴)]
//│ 				| _  => error⁰}
//│ def fact_lh_₁(_lh_fact_arg1⁴, _lh_fact_arg2⁴) = 
//│ 	case _lh_fact_arg2⁴ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0² => mmul_lh_₁([S _lh_fact_S_0²], _lh_fact_arg1⁴(mmin_lh_₁([S _lh_fact_S_0²], 
//│ 			let _lh_mmin_S_0⁷ = (fun _lh_mmin_arg1⁷ -> _lh_mmin_arg1⁷)
//│ 			in (fun _lh_mmin_arg1⁶ -> 
//│ 				let _lh_matchIdent⁸ = _lh_mmin_arg1⁶
//│ 				in case _lh_matchIdent⁸ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0³ => mmin_lh_₁(_lh_mmin_S_0³, _lh_mmin_S_0⁷)
//│ 					| _  => error⁰}))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_lh_₁(_lh_mmin_arg1⁸, _lh_mmin_arg2⁴) = 
//│ 		let _lh_matchIdent⁹ = _lh_mmin_arg2⁴
//│ 		in _lh_matchIdent⁹(_lh_mmin_arg1⁸)
//│ 	def mmul_lh_₁(_lh_mmul_arg1⁴, _lh_mmul_arg2⁴) = 
//│ 		case _lh_mmul_arg1⁴ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0¹ => pplus_lh_₁(_lh_mmul_arg2⁴, mmul_lh_₁(_lh_mmul_S_0¹, _lh_mmul_arg2⁴))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus_lh_₁(_lh_pplus_arg1³, _lh_pplus_arg2³) = 
//│ 			case _lh_pplus_arg1³ of {
//│ 				Z  => _lh_pplus_arg2³
//│ 				| S _lh_pplus_S_0² => [S pplus_lh_₁(_lh_pplus_S_0², _lh_pplus_arg2³)]
//│ 				| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [S [S [S [S [S [S [Z]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fact_lh_₀^1] (hopeless to continue)
//│ 	[fact_lh_₀^1 · mmin_lh_₀^59] (using original def)
//│ 	[fact_lh_₀^1 · mmin_lh_₀^68] (using original def)
//│ 	[fact_lh_₀^1 · mmul_lh_₀^54] (using original def)
//│ 		[fact_lh_₀^1 · mmul_lh_₀^54 · mmul_lh_₀^34] ---> [fact_lh_₀^1 · mmul_lh_₀^54] (using original def)
//│ 		[fact_lh_₀^1 · mmul_lh_₀^54 · pplus_lh_₀^31] (using original def)
//│ 			[fact_lh_₀^1 · mmul_lh_₀^54 · pplus_lh_₀^31 · pplus_lh_₀^133] ---> [fact_lh_₀^1 · mmul_lh_₀^54 · pplus_lh_₀^31] (using original def)
//│ [fact_lh_₁^10] (hopeless to continue)
//│ 	[fact_lh_₁^10 · mmin_lh_₁^102] (using original def)
//│ 	[fact_lh_₁^10 · mmin_lh_₁^93] (using original def)
//│ 	[fact_lh_₁^10 · mmul_lh_₁^88] (using original def)
//│ 		[fact_lh_₁^10 · mmul_lh_₁^88 · mmul_lh_₁^148] ---> [fact_lh_₁^10 · mmul_lh_₁^88] (using original def)
//│ 		[fact_lh_₁^10 · mmul_lh_₁^88 · pplus_lh_₁^145] (using original def)
//│ 			[fact_lh_₁^10 · mmul_lh_₁^88 · pplus_lh_₁^145 · pplus_lh_₁^121] ---> [fact_lh_₁^10 · mmul_lh_₁^88 · pplus_lh_₁^145] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ 
//│ 	let mainFact¹ = (fun x² -> fact_lh_₀_₀((fun y² -> x²(x², y²))))((fun x³ -> fact_lh_₁_₀((fun y³ -> x³(x³, y³)))))
//│ 	in mainFact¹(primId⁰([S [S [S [Z]]]]))
//│ def fact_lh_₀_₀(_lh_fact_arg1², _lh_fact_arg2²) = 
//│ 	case _lh_fact_arg2² of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0² => mmul_lh_₀_₀([S _lh_fact_S_0²], _lh_fact_arg1²(mmin_lh_₀_₀([S _lh_fact_S_0²], 
//│ 			let _lh_mmin_S_0⁴ = (fun _lh_mmin_arg1⁶ -> _lh_mmin_arg1⁶)
//│ 			in (fun _lh_mmin_arg1⁷ -> 
//│ 				let _lh_matchIdent⁴ = _lh_mmin_arg1⁷
//│ 				in case _lh_matchIdent⁴ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁵ => mmin_lh_₀_₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴)
//│ 					| _  => error⁰}))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_lh_₀_₀(_lh_mmin_arg1¹⁰, _lh_mmin_arg2⁴) = 
//│ 		let _lh_matchIdent⁷ = _lh_mmin_arg2⁴
//│ 		in _lh_matchIdent⁷(_lh_mmin_arg1¹⁰)
//│ 	def mmin_lh_₀_₁(_lh_mmin_arg1¹¹, _lh_mmin_arg2⁵) = 
//│ 		let _lh_matchIdent⁸ = _lh_mmin_arg2⁵
//│ 		in _lh_matchIdent⁸(_lh_mmin_arg1¹¹)
//│ 	def mmul_lh_₀_₀(_lh_mmul_arg1³, _lh_mmul_arg2³) = 
//│ 		case _lh_mmul_arg1³ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0³ => pplus_lh_₀_₀(_lh_mmul_arg2³, mmul_lh_₀_₀(_lh_mmul_S_0³, _lh_mmul_arg2³))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus_lh_₀_₀(_lh_pplus_arg1², _lh_pplus_arg2²) = 
//│ 			case _lh_pplus_arg1² of {
//│ 				Z  => _lh_pplus_arg2²
//│ 				| S _lh_pplus_S_0² => [S pplus_lh_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2²)]
//│ 				| _  => error⁰}
//│ def fact_lh_₁_₀(_lh_fact_arg1³, _lh_fact_arg2³) = 
//│ 	case _lh_fact_arg2³ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0³ => mmul_lh_₁_₀([S _lh_fact_S_0³], _lh_fact_arg1³(mmin_lh_₁_₁([S _lh_fact_S_0³], 
//│ 			let _lh_mmin_S_0⁶ = (fun _lh_mmin_arg1¹² -> _lh_mmin_arg1¹²)
//│ 			in (fun _lh_mmin_arg1¹³ -> 
//│ 				let _lh_matchIdent⁹ = _lh_mmin_arg1¹³
//│ 				in case _lh_matchIdent⁹ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁷ => mmin_lh_₁_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶)
//│ 					| _  => error⁰}))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_lh_₁_₀(_lh_mmin_arg1⁹, _lh_mmin_arg2³) = 
//│ 		let _lh_matchIdent⁶ = _lh_mmin_arg2³
//│ 		in _lh_matchIdent⁶(_lh_mmin_arg1⁹)
//│ 	def mmin_lh_₁_₁(_lh_mmin_arg1⁸, _lh_mmin_arg2²) = 
//│ 		let _lh_matchIdent⁵ = _lh_mmin_arg2²
//│ 		in _lh_matchIdent⁵(_lh_mmin_arg1⁸)
//│ 	def mmul_lh_₁_₀(_lh_mmul_arg1², _lh_mmul_arg2²) = 
//│ 		case _lh_mmul_arg1² of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0² => pplus_lh_₁_₀(_lh_mmul_arg2², mmul_lh_₁_₀(_lh_mmul_S_0², _lh_mmul_arg2²))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus_lh_₁_₀(_lh_pplus_arg1³, _lh_pplus_arg2³) = 
//│ 			case _lh_pplus_arg1³ of {
//│ 				Z  => _lh_pplus_arg2³
//│ 				| S _lh_pplus_S_0³ => [S pplus_lh_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]
//│ 				| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S _lh_fact_S_0²]: 182 --->
//│ 	case _lh_mmul_arg1³ of {Z  => [Z] | S _lh_mmul_S_0³ => pplus_lh_₀_₀(_lh_mmul_arg2³, mmul_lh_₀_₀(_lh_mmul_S_0³, _lh_mmul_arg2³)) | _  => error⁰}: 278
//│ [S _lh_fact_S_0²]: 187 --->
//│ 	case _lh_matchIdent⁴ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_lh_₀_₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 200
//│ [Z]: 193 --->
//│ 	case _lh_fact_arg2³ of {Z  => [S [Z]] | S _lh_fact_S_0³ => mmul_lh_₁_₀([S _lh_fact_S_0³], _lh_fact_arg1³(mmin_lh_₁_₁([S _lh_fact_S_0³], let _lh_mmin_S_0⁶ = (fun _lh_mmin_arg1¹² -> _lh_mmin_arg1¹²)
//│ in (fun _lh_mmin_arg1¹³ -> let _lh_matchIdent⁹ = _lh_mmin_arg1¹³
//│ in case _lh_matchIdent⁹ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_lh_₁_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰})))) | _  => error⁰}: 312
//│ [Z]: 212 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_lh_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 174
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_lh_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 249
//│ [S pplus_lh_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 247 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_lh_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 174
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_lh_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 249
//│ [Z]: 282 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_lh_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 174
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_lh_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 249
//│ [S [Z]]: 283 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_lh_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 174
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_lh_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 249
//│ [S _lh_fact_S_0³]: 286 --->
//│ 	case _lh_mmul_arg1² of {Z  => [Z] | S _lh_mmul_S_0² => pplus_lh_₁_₀(_lh_mmul_arg2², mmul_lh_₁_₀(_lh_mmul_S_0², _lh_mmul_arg2²)) | _  => error⁰}: 223
//│ [S _lh_fact_S_0³]: 291 --->
//│ 	case _lh_matchIdent⁹ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_lh_₁_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 304
//│ [Z]: 297 --->
//│ 	case _lh_fact_arg2³ of {Z  => [S [Z]] | S _lh_fact_S_0³ => mmul_lh_₁_₀([S _lh_fact_S_0³], _lh_fact_arg1³(mmin_lh_₁_₁([S _lh_fact_S_0³], let _lh_mmin_S_0⁶ = (fun _lh_mmin_arg1¹² -> _lh_mmin_arg1¹²)
//│ in (fun _lh_mmin_arg1¹³ -> let _lh_matchIdent⁹ = _lh_mmin_arg1¹³
//│ in case _lh_matchIdent⁹ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_lh_₁_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰})))) | _  => error⁰}: 312
//│ ------------------
//│ case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_lh_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 174 --->
//│ 	[Z]: 212
//│ 	[S pplus_lh_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 247
//│ 	[Z]: 282
//│ 	[S [Z]]: 283
//│ case _lh_matchIdent⁴ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_lh_₀_₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 200 --->
//│ 	[S _lh_fact_S_0²]: 187
//│ case _lh_mmul_arg1² of {Z  => [Z] | S _lh_mmul_S_0² => pplus_lh_₁_₀(_lh_mmul_arg2², mmul_lh_₁_₀(_lh_mmul_S_0², _lh_mmul_arg2²)) | _  => error⁰}: 223 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0³]: 286
//│ case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_lh_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 249 --->
//│ 	[Z]: 212
//│ 	[S pplus_lh_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 247
//│ 	[Z]: 282
//│ 	[S [Z]]: 283
//│ case _lh_mmul_arg1³ of {Z  => [Z] | S _lh_mmul_S_0³ => pplus_lh_₀_₀(_lh_mmul_arg2³, mmul_lh_₀_₀(_lh_mmul_S_0³, _lh_mmul_arg2³)) | _  => error⁰}: 278 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0²]: 182
//│ case _lh_matchIdent⁹ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_lh_₁_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 304 --->
//│ 	[S _lh_fact_S_0³]: 291
//│ case _lh_fact_arg2³ of {Z  => [S [Z]] | S _lh_fact_S_0³ => mmul_lh_₁_₀([S _lh_fact_S_0³], _lh_fact_arg1³(mmin_lh_₁_₁([S _lh_fact_S_0³], let _lh_mmin_S_0⁶ = (fun _lh_mmin_arg1¹² -> _lh_mmin_arg1¹²)
//│ in (fun _lh_mmin_arg1¹³ -> let _lh_matchIdent⁹ = _lh_mmin_arg1¹³
//│ in case _lh_matchIdent⁹ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_lh_₁_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰})))) | _  => error⁰}: 312 --->
//│ 	NoProd
//│ 	[Z]: 193
//│ 	[Z]: 297
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [S _lh_fact_S_0²]: 187 --->
//│ 	case _lh_matchIdent⁴ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_lh_₀_₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 200
//│ [S _lh_fact_S_0³]: 291 --->
//│ 	case _lh_matchIdent⁹ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_lh_₁_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 304
//│ ------------------
//│ case _lh_matchIdent⁴ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_lh_₀_₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 200 --->
//│ 	[S _lh_fact_S_0²]: 187
//│ case _lh_matchIdent⁹ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_lh_₁_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 304 --->
//│ 	[S _lh_fact_S_0³]: 291
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let mainFact² = (fun x⁴ -> fact_lh_₀_₀((fun y⁴ -> x⁴(x⁴, y⁴))))((fun x⁵ -> fact_lh_₁_₀((fun y⁵ -> x⁵(x⁵, y⁵)))))
//│ 	in mainFact²(primId⁰([S [S [S [Z]]]]))
//│ def fact_lh_₀_₀(_lh_fact_arg1⁴, _lh_fact_arg2⁴) = 
//│ 	case _lh_fact_arg2⁴ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0² => mmul_lh_₀_₀([S _lh_fact_S_0²], _lh_fact_arg1⁴(mmin_lh_₀_₀(
//│ 			let _lh_mmin_S_0⁸ = _lh_fact_S_0²
//│ 			in (fun _lh_mmin_S_0⁹ -> mmin_lh_₀_₁(_lh_mmin_S_0⁸, _lh_mmin_S_0⁹)), 
//│ 			let _lh_mmin_S_0¹⁰ = (fun _lh_mmin_arg1¹⁵ -> _lh_mmin_arg1¹⁵)
//│ 			in (fun _lh_mmin_arg1¹⁶ -> 
//│ 				let _lh_matchIdent¹¹ = _lh_mmin_arg1¹⁶
//│ 				in _lh_matchIdent¹¹(_lh_mmin_S_0¹⁰)))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_lh_₀_₀(_lh_mmin_arg1¹⁴, _lh_mmin_arg2⁶) = 
//│ 		let _lh_matchIdent¹⁰ = _lh_mmin_arg2⁶
//│ 		in _lh_matchIdent¹⁰(_lh_mmin_arg1¹⁴)
//│ 	def mmin_lh_₀_₁(_lh_mmin_arg1¹⁹, _lh_mmin_arg2⁷) = 
//│ 		let _lh_matchIdent¹³ = _lh_mmin_arg2⁷
//│ 		in _lh_matchIdent¹³(_lh_mmin_arg1¹⁹)
//│ 	def mmul_lh_₀_₀(_lh_mmul_arg1⁵, _lh_mmul_arg2⁵) = 
//│ 		case _lh_mmul_arg1⁵ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0³ => pplus_lh_₀_₀(_lh_mmul_arg2⁵, mmul_lh_₀_₀(_lh_mmul_S_0³, _lh_mmul_arg2⁵))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus_lh_₀_₀(_lh_pplus_arg1⁴, _lh_pplus_arg2⁴) = 
//│ 			case _lh_pplus_arg1⁴ of {
//│ 				Z  => _lh_pplus_arg2⁴
//│ 				| S _lh_pplus_S_0² => [S pplus_lh_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2⁴)]
//│ 				| _  => error⁰}
//│ def fact_lh_₁_₀(_lh_fact_arg1⁵, _lh_fact_arg2⁵) = 
//│ 	case _lh_fact_arg2⁵ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0³ => mmul_lh_₁_₀([S _lh_fact_S_0³], _lh_fact_arg1⁵(mmin_lh_₁_₁(
//│ 			let _lh_mmin_S_0¹¹ = _lh_fact_S_0³
//│ 			in (fun _lh_mmin_S_0¹² -> mmin_lh_₁_₀(_lh_mmin_S_0¹¹, _lh_mmin_S_0¹²)), 
//│ 			let _lh_mmin_S_0¹³ = (fun _lh_mmin_arg1¹⁷ -> _lh_mmin_arg1¹⁷)
//│ 			in (fun _lh_mmin_arg1¹⁸ -> 
//│ 				let _lh_matchIdent¹² = _lh_mmin_arg1¹⁸
//│ 				in _lh_matchIdent¹²(_lh_mmin_S_0¹³)))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_lh_₁_₀(_lh_mmin_arg1²⁰, _lh_mmin_arg2⁸) = 
//│ 		let _lh_matchIdent¹⁴ = _lh_mmin_arg2⁸
//│ 		in _lh_matchIdent¹⁴(_lh_mmin_arg1²⁰)
//│ 	def mmin_lh_₁_₁(_lh_mmin_arg1²¹, _lh_mmin_arg2⁹) = 
//│ 		let _lh_matchIdent¹⁵ = _lh_mmin_arg2⁹
//│ 		in _lh_matchIdent¹⁵(_lh_mmin_arg1²¹)
//│ 	def mmul_lh_₁_₀(_lh_mmul_arg1⁴, _lh_mmul_arg2⁴) = 
//│ 		case _lh_mmul_arg1⁴ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0² => pplus_lh_₁_₀(_lh_mmul_arg2⁴, mmul_lh_₁_₀(_lh_mmul_S_0², _lh_mmul_arg2⁴))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus_lh_₁_₀(_lh_pplus_arg1⁵, _lh_pplus_arg2⁵) = 
//│ 			case _lh_pplus_arg1⁵ of {
//│ 				Z  => _lh_pplus_arg2⁵
//│ 				| S _lh_pplus_S_0³ => [S pplus_lh_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2⁵)]
//│ 				| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [S [S [S [S [S [S [Z]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
