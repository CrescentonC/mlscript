:NewParser
:ParseOnly

let rec p = C(p)
fun c(x) = if x is
  C(a) then c(a)
c(p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^9 p^10)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => (c^4 a⁰)})
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^9]
//│ 	[c^9 · c^4] ---> [c^9] (only one)
//│ [p^10]
//│ 	[p^10 · p^1] ---> [p^10] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C a¹ => (c₀ a¹)})
//│ def p₀ = 
//│ 	[C p₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p₀]: 19 --->
//│ 	case x¹ of {C a¹ => (c₀ a¹)}: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> x¹)
//│ def p₀ = 
//│ 	let a¹ = p₀
//│ 	in (c₀ a¹)
//│ <<<<<<< after fusion <<<<<<<



let p = C(1, C(2, N))
fun e(z) = if z is
  C(aaa, bbb) then bbb
  N then 7
fun d(y) = if y is
  C(aa, bb) then e(bb)
  N then 5
fun c(x) = if x is
  C(a, b) then d(b)
  N then 3
c(p)
//│ |#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#fun| |e|(|z|)| |#=| |#if| |z| |is|→|C|(|aaa|,| |bbb|)| |#then| |bbb|↵|N| |#then| |7|←|↵|#fun| |d|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|,| |bb|)| |#then| |e|(|bb|)|↵|N| |#then| |5|←|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|,| |b|)| |#then| |d|(|b|)|↵|N| |#then| |3|←|↵|c|(|p|)|
//│ Parsed: {let p = C (1, C (2, N,),); fun e = z, => if z is ‹(C (aaa, bbb,)) then bbb; (N) then 7›; fun d = y, => if y is ‹(C (aa, bb,)) then e (bb,); (N) then 5›; fun c = x, => if x is ‹(C (a, b,)) then d (b,); (N) then 3›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^25 p^26)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ b⁰ => (d^19 b⁰)
//│ 	| N => 3})
//│ def d = (fun y⁰ -> case y⁰ of {
//│ 	C aa⁰ bb⁰ => (e^12 bb⁰)
//│ 	| N => 5})
//│ def e = (fun z⁰ -> case z⁰ of {
//│ 	C aaa⁰ bbb⁰ => bbb⁰
//│ 	| N => 7})
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^25] (hopeless to continue)
//│ 	[c^25 · d^19] (using original def)
//│ 		[c^25 · d^19 · e^12] (using original def)
//│ [p^26] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C a¹ b¹ => (d₀ b¹)
//│ 		| N => 3})
//│ 	where
//│ 	def d₀ = 
//│ 		(fun y¹ -> case y¹ of {
//│ 			C aa¹ bb¹ => (e₀ bb¹)
//│ 			| N => 5})
//│ 		where
//│ 		def e₀ = 
//│ 			(fun z¹ -> case z¹ of {
//│ 				C aaa¹ bbb¹ => bbb¹
//│ 				| N => 7})
//│ def p₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case x¹ of {C a¹ b¹ => (d₀ b¹) | N => 3}: 33
//│ [C 2 [N]]: 38 --->
//│ 	case y¹ of {C aa¹ bb¹ => (e₀ bb¹) | N => 5}: 50
//│ [N]: 37 --->
//│ 	case z¹ of {C aaa¹ bbb¹ => bbb¹ | N => 7}: 43
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> x¹)
//│ 	where
//│ 	def d₀ = 
//│ 		(fun y¹ -> y¹)
//│ 		where
//│ 		def e₀ = 
//│ 			(fun z¹ -> z¹)
//│ def p₀ = 
//│ 	let a¹ = 1
//│ 	in let b¹ = 	
//│ 		let aa¹ = 2
//│ 		in let bb¹ = 7
//│ 		in (e₀ bb¹)
//│ 	in (d₀ b¹)
//│ <<<<<<< after fusion <<<<<<<


let rec p = C(C(p))
fun c(x) = if x is
  C(a) then if a is
    C(b) then if b is
      C(y) then c(y)
c(p)
//│ |#let| |#rec| |p| |#=| |C|(|C|(|p|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |#if| |b| |is|→|C|(|y|)| |#then| |c|(|y|)|←|←|←|↵|c|(|p|)|
//│ Parsed: {let rec p = C (C (p,),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then if b is ‹(C (y,)) then c (y,)›››; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^14 p^15)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => case b⁰ of {
//│ 			C y⁰ => (c^7 y⁰)}}})
//│ def p = [C [C p^1]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^14]
//│ 	[c^14 · c^7]
//│ 		[c^14 · c^7 · c^7] ---> [c^14] (only one)
//│ [p^15]
//│ 	[p^15 · p^1]
//│ 		[p^15 · p^1 · p^1]
//│ 			[p^15 · p^1 · p^1 · p^1] ---> [p^15] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x² -> case x² of {
//│ 		C a² => case a² of {
//│ 			C b² => case b² of {
//│ 				C y² => (c₁ y²)}}})
//│ 	where
//│ 	def c₁ = 
//│ 		(fun x¹ -> case x¹ of {
//│ 			C a¹ => case a¹ of {
//│ 				C b¹ => case b¹ of {
//│ 					C y¹ => (c₀ y¹)}}})
//│ def p₀ = 
//│ 	[C [C p₁]]
//│ 	where
//│ 	def p₁ = 
//│ 		[C [C p₂]]
//│ 		where
//│ 		def p₂ = 
//│ 			[C [C p₀]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [C p₀]]: 29 --->
//│ 	case a¹ of {C b¹ => case b¹ of {C y¹ => (c₀ y¹)}}: 24
//│ [C [C p₁]]: 42 --->
//│ 	case x² of {C a² => case a² of {C b² => case b² of {C y² => (c₁ y²)}}}: 38
//│ [C [C p₂]]: 45 --->
//│ 	case b² of {C y² => (c₁ y²)}: 36
//│ [C p₀]: 28 --->
//│ 	case b¹ of {C y¹ => (c₀ y¹)}: 23
//│ [C p₁]: 41 --->
//│ 	case a² of {C b² => case b² of {C y² => (c₁ y²)}}: 37
//│ [C p₂]: 44 --->
//│ 	case x¹ of {C a¹ => case a¹ of {C b¹ => case b¹ of {C y¹ => (c₀ y¹)}}}: 25
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x² -> x²)
//│ 	where
//│ 	def c₁ = 
//│ 		(fun x¹ -> x¹)
//│ def p₀ = 
//│ 	let a² = 	
//│ 		let b² = p₁
//│ 		in b²
//│ 	in a²
//│ 	where
//│ 	def p₁ = 
//│ 		let y² = 	
//│ 			let a¹ = p₂
//│ 			in a¹
//│ 		in (c₁ y²)
//│ 		where
//│ 		def p₂ = 
//│ 			let b¹ = 	
//│ 				let y¹ = p₀
//│ 				in (c₀ y¹)
//│ 			in b¹
//│ <<<<<<< after fusion <<<<<<<




let rec p = C(C(p))
fun c(x) = if x is
  C(a) then c(a)
fun id2(yy) = yy
fun id(y) = id2(y)
c(id(p))
//│ |#let| |#rec| |p| |#=| |C|(|C|(|p|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id2|(|yy|)| |#=| |yy|↵|#fun| |id|(|y|)| |#=| |id2|(|y|)|↵|c|(|id|(|p|)|)|
//│ Parsed: {let rec p = C (C (p,),); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun id2 = yy, => yy; fun id = y, => id2 (y,); c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^16 (id^17 p^18))
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => (c^5 a⁰)})
//│ def id = (fun y⁰ -> (id2^12 y⁰))
//│ def id2 = (fun yy⁰ -> yy⁰)
//│ def p = [C [C p^1]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^16]
//│ 	[c^16 · c^5]
//│ 		[c^16 · c^5 · c^5] ---> [c^16] (only one)
//│ [id^17] (hopeless to continue)
//│ 	[id^17 · id2^12] (using original def)
//│ [p^18]
//│ 	[p^18 · p^1] ---> [p^18] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ (id₀ p₀))
//│ def c₀ = 
//│ 	(fun x² -> case x² of {
//│ 		C a² => (c₁ a²)})
//│ 	where
//│ 	def c₁ = 
//│ 		(fun x¹ -> case x¹ of {
//│ 			C a¹ => (c₀ a¹)})
//│ def id₀ = 
//│ 	(fun y¹ -> (id2₀ y¹))
//│ 	where
//│ 	def id2₀ = 
//│ 		(fun yy¹ -> yy¹)
//│ def p₀ = 
//│ 	[C [C p₀]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [C p₀]]: 35 --->
//│ 	case x² of {C a² => (c₁ a²)}: 40
//│ [C p₀]: 34 --->
//│ 	case x¹ of {C a¹ => (c₀ a¹)}: 25
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ (id₀ p₀))
//│ def c₀ = 
//│ 	(fun x² -> x²)
//│ 	where
//│ 	def c₁ = 
//│ 		(fun x¹ -> x¹)
//│ def id₀ = 
//│ 	(fun y¹ -> (id2₀ y¹))
//│ 	where
//│ 	def id2₀ = 
//│ 		(fun yy¹ -> yy¹)
//│ def p₀ = 
//│ 	let a² = 	
//│ 		let a¹ = p₀
//│ 		in (c₀ a¹)
//│ 	in (c₁ a²)
//│ <<<<<<< after fusion <<<<<<<

fun sum(ls) = if ls is
  C(h, t) then S(N, sum(t))
fun mapa(lsa) = if lsa is
  C(ha, ta) then C(primitive(ha), mapa(ta))
fun mapb(lsb) = if lsb is
  C(hb, tb) then C(primitive(hb), mapb(tb))
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),)›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),)›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),)›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (sum^29 (mapa^30 (mapb^31 primitive⁰)))
//│ def mapa = (fun lsa⁰ -> case lsa⁰ of {
//│ 	C ha⁰ ta⁰ => [C (primitive⁰ ha⁰) (mapa^13 ta⁰)]})
//│ def mapb = (fun lsb⁰ -> case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => [C (primitive⁰ hb⁰) (mapb^23 tb⁰)]})
//│ def sum = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [S [N] (sum^3 t⁰)]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa^30]
//│ 	[mapa^30 · mapa^13]
//│ 		[mapa^30 · mapa^13 · mapa^13] ---> [mapa^30 · mapa^13] (only one)
//│ [mapb^31]
//│ 	[mapb^31 · mapb^23]
//│ 		[mapb^31 · mapb^23 · mapb^23] ---> [mapb^31 · mapb^23] (only one)
//│ [sum^29]
//│ 	[sum^29 · sum^3]
//│ 		[sum^29 · sum^3 · sum^3] ---> [sum^29 · sum^3] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (sum₀ (mapa₀ (mapb₀ primitive⁰)))
//│ def mapa₀ = 
//│ 	(fun lsa² -> case lsa² of {
//│ 		C ha² ta² => [C (primitive⁰ ha²) (mapa₁ ta²)]})
//│ 	where
//│ 	def mapa₁ = 
//│ 		(fun lsa¹ -> case lsa¹ of {
//│ 			C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₁ ta¹)]})
//│ def mapb₀ = 
//│ 	(fun lsb² -> case lsb² of {
//│ 		C hb² tb² => [C (primitive⁰ hb²) (mapb₁ tb²)]})
//│ 	where
//│ 	def mapb₁ = 
//│ 		(fun lsb¹ -> case lsb¹ of {
//│ 			C hb¹ tb¹ => [C (primitive⁰ hb¹) (mapb₁ tb¹)]})
//│ def sum₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => [S [N] (sum₁ t¹)]})
//│ 	where
//│ 	def sum₁ = 
//│ 		(fun ls² -> case ls² of {
//│ 			C h² t² => [S [N] (sum₁ t²)]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C (primitive⁰ ha¹) (mapa₁ ta¹)]: 51 --->
//│ 	case ls² of {C h² t² => [S [N] (sum₁ t²)]}: 60
//│ [C (primitive⁰ ha²) (mapa₁ ta²)]: 89 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] (sum₁ t¹)]}: 42
//│ [C (primitive⁰ hb¹) (mapb₁ tb¹)]: 69 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₁ ta¹)]}: 52
//│ [C (primitive⁰ hb²) (mapb₁ tb²)]: 79 --->
//│ 	case lsa² of {C ha² ta² => [C (primitive⁰ ha²) (mapa₁ ta²)]}: 90
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (sum₀ (mapa₀ (mapb₀ primitive⁰)))
//│ def mapa₀ = 
//│ 	(fun lsa² -> lsa²)
//│ 	where
//│ 	def mapa₁ = 
//│ 		(fun lsa¹ -> lsa¹)
//│ def mapb₀ = 
//│ 	(fun lsb² -> case lsb² of {
//│ 		C hb² tb² => 
//│ 			let ha² = (primitive⁰ hb²)
//│ 			in let ta² = (mapb₁ tb²)
//│ 			in let h¹ = (primitive⁰ ha²)
//│ 			in let t¹ = (mapa₁ ta²)
//│ 			in [S [N] (sum₁ t¹)]})
//│ 	where
//│ 	def mapb₁ = 
//│ 		(fun lsb¹ -> case lsb¹ of {
//│ 			C hb¹ tb¹ => 
//│ 				let ha¹ = (primitive⁰ hb¹)
//│ 				in let ta¹ = (mapb₁ tb¹)
//│ 				in let h² = (primitive⁰ ha¹)
//│ 				in let t² = (mapa₁ ta¹)
//│ 				in [S [N] (sum₁ t²)]})
//│ def sum₀ = 
//│ 	(fun ls¹ -> ls¹)
//│ 	where
//│ 	def sum₁ = 
//│ 		(fun ls² -> ls²)
//│ <<<<<<< after fusion <<<<<<<


if C(A, B(C)) is
  C(a, b) then D(b)
//│ |#if| |C|(|A|,| |B|(|C|)|)| |is|→|C|(|a|,| |b|)| |#then| |D|(|b|)|←|
//│ Parsed: {if C (A, B (C,),) is ‹(C (a, b,)) then D (b,)›}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a⁰ b⁰ => [D b⁰]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a¹ b¹ => [D b¹]}
//│ 
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A] [B [C]]]: 11 --->
//│ 	case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let a¹ = [A]
//│ 	in let b¹ = [B [C]]
//│ 	in [D b¹]
//│ 
//│ <<<<<<< after fusion <<<<<<<
//│



let rec p = C(C(C(p)))
fun ca(x) = if x is
  C(a) then cb(a)
fun cb(x) = if x is
  C(b) then ca(b)
ca(p)
//│ |#let| |#rec| |p| |#=| |C|(|C|(|C|(|p|)|)|)|↵|#fun| |ca|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |cb|(|a|)|←|↵|#fun| |cb|(|x|)| |#=| |#if| |x| |is|→|C|(|b|)| |#then| |ca|(|b|)|←|↵|ca|(|p|)|
//│ Parsed: {let rec p = C (C (C (p,),),); fun ca = x, => if x is ‹(C (a,)) then cb (a,)›; fun cb = x, => if x is ‹(C (b,)) then ca (b,)›; ca (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (ca^17 p^18)
//│ def ca = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => (cb^6 a⁰)})
//│ def cb = (fun x¹ -> case x¹ of {
//│ 	C b⁰ => (ca^12 b⁰)})
//│ def p = [C [C [C p^1]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ca^17]
//│ 	[ca^17 · cb^6]
//│ 		[ca^17 · cb^6 · ca^12]
//│ 			[ca^17 · cb^6 · ca^12 · cb^6]
//│ 				[ca^17 · cb^6 · ca^12 · cb^6 · ca^12]
//│ 					[ca^17 · cb^6 · ca^12 · cb^6 · ca^12 · cb^6]
//│ 						[ca^17 · cb^6 · ca^12 · cb^6 · ca^12 · cb^6 · ca^12] ---> [ca^17] (only one)
//│ [p^18]
//│ 	[p^18 · p^1]
//│ 		[p^18 · p^1 · p^1] ---> [p^18] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (ca₀ p₀)
//│ def ca₀ = 
//│ 	(fun x³ -> case x³ of {
//│ 		C a² => (cb₀ a²)})
//│ 	where
//│ 	def cb₀ = 
//│ 		(fun x⁶ -> case x⁶ of {
//│ 			C b² => (ca₁ b²)})
//│ 		where
//│ 		def ca₁ = 
//│ 			(fun x⁴ -> case x⁴ of {
//│ 				C a³ => (cb₁ a³)})
//│ 			where
//│ 			def cb₁ = 
//│ 				(fun x⁷ -> case x⁷ of {
//│ 					C b³ => (ca₂ b³)})
//│ 				where
//│ 				def ca₂ = 
//│ 					(fun x² -> case x² of {
//│ 						C a¹ => (cb₂ a¹)})
//│ 					where
//│ 					def cb₂ = 
//│ 						(fun x⁵ -> case x⁵ of {
//│ 							C b¹ => (ca₀ b¹)})
//│ def p₀ = 
//│ 	[C [C [C p₁]]]
//│ 	where
//│ 	def p₁ = 
//│ 		[C [C [C p₀]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [C [C p₀]]]: 35 --->
//│ 	case x⁷ of {C b³ => (ca₂ b³)}: 62
//│ [C [C [C p₁]]]: 57 --->
//│ 	case x³ of {C a² => (cb₀ a²)}: 30
//│ [C [C p₀]]: 34 --->
//│ 	case x² of {C a¹ => (cb₂ a¹)}: 24
//│ [C [C p₁]]: 56 --->
//│ 	case x⁶ of {C b² => (ca₁ b²)}: 52
//│ [C p₀]: 33 --->
//│ 	case x⁵ of {C b¹ => (ca₀ b¹)}: 46
//│ [C p₁]: 55 --->
//│ 	case x⁴ of {C a³ => (cb₁ a³)}: 40
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (ca₀ p₀)
//│ def ca₀ = 
//│ 	(fun x³ -> x³)
//│ 	where
//│ 	def cb₀ = 
//│ 		(fun x⁶ -> x⁶)
//│ 		where
//│ 		def ca₁ = 
//│ 			(fun x⁴ -> x⁴)
//│ 			where
//│ 			def cb₁ = 
//│ 				(fun x⁷ -> x⁷)
//│ 				where
//│ 				def ca₂ = 
//│ 					(fun x² -> x²)
//│ 					where
//│ 					def cb₂ = 
//│ 						(fun x⁵ -> x⁵)
//│ def p₀ = 
//│ 	let a² = 	
//│ 		let b² = 	
//│ 			let a³ = p₁
//│ 			in (cb₁ a³)
//│ 		in (ca₁ b²)
//│ 	in (cb₀ a²)
//│ 	where
//│ 	def p₁ = 
//│ 		let b³ = 	
//│ 			let a¹ = 	
//│ 				let b¹ = p₀
//│ 				in (ca₀ b¹)
//│ 			in (cb₂ a¹)
//│ 		in (ca₂ b³)
//│ <<<<<<< after fusion <<<<<<<


// def p:6^18 =
//      ... p:6^1 ~> p:6^18.p:6^1 ...

// def p:6^18.p:6^1 =
//      ... p:6^1 ~> p:6^18 ...

// def ca:7^17
//      ... 



fun c1(x1) = if x1 is
  C(a) then c2(a)
fun c2(x2) = if x2 is
  C(b) then c1(b)
let p1 = C(C(C(p2)))
let p2 = C(p1)
c1(p1)
//│ |#fun| |c1|(|x1|)| |#=| |#if| |x1| |is|→|C|(|a|)| |#then| |c2|(|a|)|←|↵|#fun| |c2|(|x2|)| |#=| |#if| |x2| |is|→|C|(|b|)| |#then| |c1|(|b|)|←|↵|#let| |p1| |#=| |C|(|C|(|C|(|p2|)|)|)|↵|#let| |p2| |#=| |C|(|p1|)|↵|c1|(|p1|)|
//│ Parsed: {fun c1 = x1, => if x1 is ‹(C (a,)) then c2 (a,)›; fun c2 = x2, => if x2 is ‹(C (b,)) then c1 (b,)›; let p1 = C (C (C (p2,),),); let p2 = C (p1,); c1 (p1,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c1^19 p1^20)
//│ def c1 = (fun x1⁰ -> case x1⁰ of {
//│ 	C a⁰ => (c2^2 a⁰)})
//│ def c2 = (fun x2⁰ -> case x2⁰ of {
//│ 	C b⁰ => (c1^8 b⁰)})
//│ def p1 = [C [C [C p2^13]]]
//│ def p2 = [C p1^17]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c1^19]
//│ 	[c1^19 · c2^2]
//│ 		[c1^19 · c2^2 · c1^8]
//│ 			[c1^19 · c2^2 · c1^8 · c2^2]
//│ 				[c1^19 · c2^2 · c1^8 · c2^2 · c1^8]
//│ 					[c1^19 · c2^2 · c1^8 · c2^2 · c1^8 · c2^2] ---> [c1^19 · c2^2] (only one)
//│ [p1^20]
//│ 	[p1^20 · p2^13]
//│ 		[p1^20 · p2^13 · p1^17] ---> [p1^20] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c1₀ p1₀)
//│ def c1₀ = 
//│ 	(fun x1² -> case x1² of {
//│ 		C a² => (c2₀ a²)})
//│ 	where
//│ 	def c2₀ = 
//│ 		(fun x2¹ -> case x2¹ of {
//│ 			C b¹ => (c1₁ b¹)})
//│ 		where
//│ 		def c1₁ = 
//│ 			(fun x1³ -> case x1³ of {
//│ 				C a³ => (c2₁ a³)})
//│ 			where
//│ 			def c2₁ = 
//│ 				(fun x2² -> case x2² of {
//│ 					C b² => (c1₂ b²)})
//│ 				where
//│ 				def c1₂ = 
//│ 					(fun x1¹ -> case x1¹ of {
//│ 						C a¹ => (c2₀ a¹)})
//│ def p1₀ = 
//│ 	[C [C [C p2₀]]]
//│ 	where
//│ 	def p2₀ = 
//│ 		[C p1₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [C [C p2₀]]]: 37 --->
//│ 	case x1² of {C a² => (c2₀ a²)}: 32
//│ 	case x1¹ of {C a¹ => (c2₀ a¹)}: 26
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C [C p2₀]]: 36 --->
//│ 	case x2¹ of {C b¹ => (c1₁ b¹)}: 42
//│ [C p1₀]: 57 --->
//│ 	case x2² of {C b² => (c1₂ b²)}: 54
//│ [C p2₀]: 35 --->
//│ 	case x1³ of {C a³ => (c2₁ a³)}: 48
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c1₀ p1₀)
//│ def c1₀ = 
//│ 	(fun x1² -> x1²)
//│ 	where
//│ 	def c2₀ = 
//│ 		(fun x2¹ -> x2¹)
//│ 		where
//│ 		def c1₁ = 
//│ 			(fun x1³ -> x1³)
//│ 			where
//│ 			def c2₁ = 
//│ 				(fun x2² -> x2²)
//│ 				where
//│ 				def c1₂ = 
//│ 					(fun x1¹ -> case x1¹ of {
//│ 						C a¹ => (c2₀ a¹)})
//│ def p1₀ = 
//│ 	let a² = 	
//│ 		let b¹ = 	
//│ 			let a³ = p2₀
//│ 			in (c2₁ a³)
//│ 		in (c1₁ b¹)
//│ 	in (c2₀ a²)
//│ 	where
//│ 	def p2₀ = 
//│ 		let b² = p1₀
//│ 		in (c1₂ b²)
//│ <<<<<<< after fusion <<<<<<<


fun ff(x) = if x is
  K then T
  KK then TT
  KKKK then TTTT
fun map(ls) = if ls is
  C(h, t) then C(ff(h), map(t))
  N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|ff|(|h|)|,| |map|(|t|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; fun map = ls, => if ls is ‹(C (h, t,)) then C (ff (h,), map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^25 l^26)
//│ def ff = (fun x⁰ -> case x⁰ of {
//│ 	K => [T]
//│ 	| KK => [TT]
//│ 	| KKKK => [TTTT]})
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C (ff^8 h⁰) (map^11 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^26]
//│ [map^25]
//│ 	[map^25 · ff^8] (hopeless to continue)
//│ 	[map^25 · map^11]
//│ 		[map^25 · map^11 · ff^8] (hopeless to continue)
//│ 		[map^25 · map^11 · map^11]
//│ 			[map^25 · map^11 · map^11 · ff^8] (hopeless to continue)
//│ 			[map^25 · map^11 · map^11 · map^11]
//│ 				[map^25 · map^11 · map^11 · map^11 · ff^8] (hopeless to continue)
//│ 				[map^25 · map^11 · map^11 · map^11 · map^11] ---> [map^25 · map^11 · map^11 · map^11] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map₀ = 
//│ 	(fun ls³ -> case ls³ of {
//│ 		C h³ t³ => [C (ff₀ h³) (map₁ t³)]
//│ 		| N => [N]})
//│ 	where
//│ 	def ff₀ = 
//│ 		(fun x² -> case x² of {
//│ 			K => [T]
//│ 			| KK => [TT]
//│ 			| KKKK => [TTTT]})
//│ 	def map₁ = 
//│ 		(fun ls¹ -> case ls¹ of {
//│ 			C h¹ t¹ => [C (ff₁ h¹) (map₂ t¹)]
//│ 			| N => [N]})
//│ 		where
//│ 		def ff₁ = 
//│ 			(fun x³ -> case x³ of {
//│ 				K => [T]
//│ 				| KK => [TT]
//│ 				| KKKK => [TTTT]})
//│ 		def map₂ = 
//│ 			(fun ls⁴ -> case ls⁴ of {
//│ 				C h⁴ t⁴ => [C (ff₂ h⁴) (map₃ t⁴)]
//│ 				| N => [N]})
//│ 			where
//│ 			def ff₂ = 
//│ 				(fun x¹ -> case x¹ of {
//│ 					K => [T]
//│ 					| KK => [TT]
//│ 					| KKKK => [TTTT]})
//│ 			def map₃ = 
//│ 				(fun ls² -> case ls² of {
//│ 					C h² t² => [C (ff₃ h²) (map₃ t²)]
//│ 					| N => [N]})
//│ 				where
//│ 				def ff₃ = 
//│ 					(fun x⁴ -> case x⁴ of {
//│ 						K => [T]
//│ 						| KK => [TT]
//│ 						| KKKK => [TTTT]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [KKKK] [N]]: 60 --->
//│ 	case ls⁴ of {C h⁴ t⁴ => [C (ff₂ h⁴) (map₃ t⁴)] | N => [N]}: 101
//│ [C [KK] [C [KKKK] [N]]]: 61 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (ff₁ h¹) (map₂ t¹)] | N => [N]}: 43
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 62 --->
//│ 	case ls³ of {C h³ t³ => [C (ff₀ h³) (map₁ t³)] | N => [N]}: 90
//│ [KKKK]: 58 --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 32
//│ [KK]: 57 --->
//│ 	case x³ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 73
//│ [K]: 56 --->
//│ 	case x² of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 67
//│ [N]: 59 --->
//│ 	case ls² of {C h² t² => [C (ff₃ h²) (map₃ t²)] | N => [N]}: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	let h³ = [T]
//│ 	in let t³ = 	
//│ 		let h¹ = [TT]
//│ 		in let t¹ = 	
//│ 			let h⁴ = [TTTT]
//│ 			in let t⁴ = [N]
//│ 			in [C (ff₂ h⁴) (map₃ t⁴)]
//│ 		in [C (ff₁ h¹) (map₂ t¹)]
//│ 	in [C (ff₀ h³) (map₁ t³)]
//│ def map₀ = 
//│ 	(fun ls³ -> ls³)
//│ 	where
//│ 	def ff₀ = 
//│ 		(fun x² -> x²)
//│ 	def map₁ = 
//│ 		(fun ls¹ -> ls¹)
//│ 		where
//│ 		def ff₁ = 
//│ 			(fun x³ -> x³)
//│ 		def map₂ = 
//│ 			(fun ls⁴ -> ls⁴)
//│ 			where
//│ 			def ff₂ = 
//│ 				(fun x¹ -> x¹)
//│ 			def map₃ = 
//│ 				(fun ls² -> ls²)
//│ 				where
//│ 				def ff₃ = 
//│ 					(fun x⁴ -> case x⁴ of {
//│ 						K => [T]
//│ 						| KK => [TT]
//│ 						| KKKK => [TTTT]})
//│ <<<<<<< after fusion <<<<<<<


fun map(ls) = if ls is
  C(h, t) then C(
    (if h is
      K then T
      KK then TT
      KKKK then TTTT
    ),
    map(t)
  )
  N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›, ')', map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^21 l^22)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C case h⁰ of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} (map^7 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^22]
//│ [map^21]
//│ 	[map^21 · map^7]
//│ 		[map^21 · map^7 · map^7]
//│ 			[map^21 · map^7 · map^7 · map^7]
//│ 				[map^21 · map^7 · map^7 · map^7 · map^7] ---> [map^21 · map^7 · map^7 · map^7] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map₀ = 
//│ 	(fun ls⁴ -> case ls⁴ of {
//│ 		C h⁴ t⁴ => [C case h⁴ of {
//│ 			K => [T]
//│ 			| KK => [TT]
//│ 			| KKKK => [TTTT]} (map₁ t⁴)]
//│ 		| N => [N]})
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls² -> case ls² of {
//│ 			C h² t² => [C case h² of {
//│ 				K => [T]
//│ 				| KK => [TT]
//│ 				| KKKK => [TTTT]} (map₂ t²)]
//│ 			| N => [N]})
//│ 		where
//│ 		def map₂ = 
//│ 			(fun ls³ -> case ls³ of {
//│ 				C h³ t³ => [C case h³ of {
//│ 					K => [T]
//│ 					| KK => [TT]
//│ 					| KKKK => [TTTT]} (map₃ t³)]
//│ 				| N => [N]})
//│ 			where
//│ 			def map₃ = 
//│ 				(fun ls¹ -> case ls¹ of {
//│ 					C h¹ t¹ => [C case h¹ of {
//│ 						K => [T]
//│ 						| KK => [TT]
//│ 						| KKKK => [TTTT]} (map₃ t¹)]
//│ 					| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [KKKK] [N]]: 80 --->
//│ 	case ls³ of {C h³ t³ => [C case h³ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₃ t³)] | N => [N]}: 61
//│ [C [KK] [C [KKKK] [N]]]: 81 --->
//│ 	case ls² of {C h² t² => [C case h² of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₂ t²)] | N => [N]}: 48
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 82 --->
//│ 	case ls⁴ of {C h⁴ t⁴ => [C case h⁴ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₁ t⁴)] | N => [N]}: 74
//│ [KKKK]: 78 --->
//│ 	case h³ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 55
//│ [KK]: 77 --->
//│ 	case h² of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 42
//│ [K]: 76 --->
//│ 	case h⁴ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 68
//│ [N]: 79 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₃ t¹)] | N => [N]}: 35
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	let h⁴ = [T]
//│ 	in let t⁴ = 	
//│ 		let h² = [TT]
//│ 		in let t² = 	
//│ 			let h³ = [TTTT]
//│ 			in let t³ = [N]
//│ 			in [C h³ (map₃ t³)]
//│ 		in [C h² (map₂ t²)]
//│ 	in [C h⁴ (map₁ t⁴)]
//│ def map₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls² -> ls²)
//│ 		where
//│ 		def map₂ = 
//│ 			(fun ls³ -> ls³)
//│ 			where
//│ 			def map₃ = 
//│ 				(fun ls¹ -> ls¹)
//│ <<<<<<< after fusion <<<<<<<


fun sum(ls) = if ls is
  C(h, t) then S(N, sum(t))
  N then N
fun mapa(lsa) = if lsa is
  C(ha, ta) then C(primitive(ha), mapa(ta))
  N then N
fun mapb(lsb) = if lsb is
  C(hb, tb) then C(primitive(hb), mapb(tb))
  N then N
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|↵|N| |#then| |N|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|↵|N| |#then| |N|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),); (N) then N›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),); (N) then N›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),); (N) then N›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (sum^32 (mapa^33 (mapb^34 primitive⁰)))
//│ def mapa = (fun lsa⁰ -> case lsa⁰ of {
//│ 	C ha⁰ ta⁰ => [C (primitive⁰ ha⁰) (mapa^14 ta⁰)]
//│ 	| N => [N]})
//│ def mapb = (fun lsb⁰ -> case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => [C (primitive⁰ hb⁰) (mapb^25 tb⁰)]
//│ 	| N => [N]})
//│ def sum = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [S [N] (sum^3 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa^33]
//│ 	[mapa^33 · mapa^14]
//│ 		[mapa^33 · mapa^14 · mapa^14] ---> [mapa^33 · mapa^14] (only one)
//│ [mapb^34]
//│ 	[mapb^34 · mapb^25]
//│ 		[mapb^34 · mapb^25 · mapb^25] ---> [mapb^34 · mapb^25] (only one)
//│ [sum^32]
//│ 	[sum^32 · sum^3]
//│ 		[sum^32 · sum^3 · sum^3] ---> [sum^32 · sum^3] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (sum₀ (mapa₀ (mapb₀ primitive⁰)))
//│ def mapa₀ = 
//│ 	(fun lsa¹ -> case lsa¹ of {
//│ 		C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₁ ta¹)]
//│ 		| N => [N]})
//│ 	where
//│ 	def mapa₁ = 
//│ 		(fun lsa² -> case lsa² of {
//│ 			C ha² ta² => [C (primitive⁰ ha²) (mapa₁ ta²)]
//│ 			| N => [N]})
//│ def mapb₀ = 
//│ 	(fun lsb² -> case lsb² of {
//│ 		C hb² tb² => [C (primitive⁰ hb²) (mapb₁ tb²)]
//│ 		| N => [N]})
//│ 	where
//│ 	def mapb₁ = 
//│ 		(fun lsb¹ -> case lsb¹ of {
//│ 			C hb¹ tb¹ => [C (primitive⁰ hb¹) (mapb₁ tb¹)]
//│ 			| N => [N]})
//│ def sum₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h² t² => [S [N] (sum₁ t²)]
//│ 		| N => [N]})
//│ 	where
//│ 	def sum₁ = 
//│ 		(fun ls¹ -> case ls¹ of {
//│ 			C h¹ t¹ => [S [N] (sum₁ t¹)]
//│ 			| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C (primitive⁰ ha²) (mapa₁ ta²)]: 86 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] (sum₁ t¹)] | N => [N]}: 68
//│ [C (primitive⁰ ha¹) (mapa₁ ta¹)]: 46 --->
//│ 	case ls² of {C h² t² => [S [N] (sum₁ t²)] | N => [N]}: 77
//│ [C (primitive⁰ hb²) (mapb₁ tb²)]: 97 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₁ ta¹)] | N => [N]}: 48
//│ [C (primitive⁰ hb¹) (mapb₁ tb¹)]: 57 --->
//│ 	case lsa² of {C ha² ta² => [C (primitive⁰ ha²) (mapa₁ ta²)] | N => [N]}: 88
//│ [N]: 98 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₁ ta¹)] | N => [N]}: 48
//│ [N]: 87 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] (sum₁ t¹)] | N => [N]}: 68
//│ [N]: 58 --->
//│ 	case lsa² of {C ha² ta² => [C (primitive⁰ ha²) (mapa₁ ta²)] | N => [N]}: 88
//│ [N]: 47 --->
//│ 	case ls² of {C h² t² => [S [N] (sum₁ t²)] | N => [N]}: 77
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (sum₀ (mapa₀ (mapb₀ primitive⁰)))
//│ def mapa₀ = 
//│ 	(fun lsa¹ -> lsa¹)
//│ 	where
//│ 	def mapa₁ = 
//│ 		(fun lsa² -> lsa²)
//│ def mapb₀ = 
//│ 	(fun lsb² -> case lsb² of {
//│ 		C hb² tb² => 
//│ 			let ha¹ = (primitive⁰ hb²)
//│ 			in let ta¹ = (mapb₁ tb²)
//│ 			in let h² = (primitive⁰ ha¹)
//│ 			in let t² = (mapa₁ ta¹)
//│ 			in [S [N] (sum₁ t²)]
//│ 		| N => [N]})
//│ 	where
//│ 	def mapb₁ = 
//│ 		(fun lsb¹ -> case lsb¹ of {
//│ 			C hb¹ tb¹ => 
//│ 				let ha² = (primitive⁰ hb¹)
//│ 				in let ta² = (mapb₁ tb¹)
//│ 				in let h¹ = (primitive⁰ ha²)
//│ 				in let t¹ = (mapa₁ ta²)
//│ 				in [S [N] (sum₁ t¹)]
//│ 			| N => [N]})
//│ def sum₀ = 
//│ 	(fun ls² -> ls²)
//│ 	where
//│ 	def sum₁ = 
//│ 		(fun ls¹ -> ls¹)
//│ <<<<<<< after fusion <<<<<<<



let rec p = C(p)
fun c(x) = if x is
  C(a) then c(a)
fun main(cc) = cc(p)
main(c)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|cc|)| |#=| |cc|(|p|)|↵|main|(|c|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = cc, => cc (p,); main (c,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (main^13 c^14)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => (c^4 a⁰)})
//│ def main = (fun cc⁰ -> (cc⁰ p^10))
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^14]
//│ 	[c^14 · c^4] ---> [c^14] (only one)
//│ [main^13]
//│ 	[main^13 · p^10]
//│ 		[main^13 · p^10 · p^1] ---> [main^13 · p^10] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (main₀ c₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C a¹ => (c₀ a¹)})
//│ def main₀ = 
//│ 	(fun cc¹ -> (cc¹ p₀))
//│ 	where
//│ 	def p₀ = 
//│ 		[C p₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p₀]: 17 --->
//│ 	case x¹ of {C a¹ => (c₀ a¹)}: 26
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (main₀ c₀)
//│ def c₀ = 
//│ 	(fun x¹ -> x¹)
//│ def main₀ = 
//│ 	(fun cc¹ -> (cc¹ p₀))
//│ 	where
//│ 	def p₀ = 
//│ 		let a¹ = p₀
//│ 		in (c₀ a¹)
//│ <<<<<<< after fusion <<<<<<<


// this path seems also to be sensible
let rec p = C(p)
fun c(x) = if x is
  C(a) then c(a)
fun main(pp) = if pp is
  C(b) then if b is
    C(d) then c(d)
main(p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|pp|)| |#=| |#if| |pp| |is|→|C|(|b|)| |#then| |#if| |b| |is|→|C|(|d|)| |#then| |c|(|d|)|←|←|↵|main|(|p|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = pp, => if pp is ‹(C (b,)) then if b is ‹(C (d,)) then c (d,)››; main (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (main^17 p^18)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => (c^4 a⁰)})
//│ def main = (fun pp⁰ -> case pp⁰ of {
//│ 	C b⁰ => case b⁰ of {
//│ 		C d⁰ => (c^11 d⁰)}})
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [main^17]
//│ 	[main^17 · c^11]
//│ 		[main^17 · c^11 · c^4] ---> [main^17 · c^11] (only one)
//│ [p^18]
//│ 	[p^18 · p^1]
//│ 		[p^18 · p^1 · p^1]
//│ 			[p^18 · p^1 · p^1 · p^1] ---> [p^18 · p^1 · p^1] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (main₀ p₀)
//│ def main₀ = 
//│ 	(fun pp¹ -> case pp¹ of {
//│ 		C b¹ => case b¹ of {
//│ 			C d¹ => (c₀ d¹)}})
//│ 	where
//│ 	def c₀ = 
//│ 		(fun x¹ -> case x¹ of {
//│ 			C a¹ => (c₀ a¹)})
//│ def p₀ = 
//│ 	[C p₁]
//│ 	where
//│ 	def p₁ = 
//│ 		[C p₂]
//│ 		where
//│ 		def p₂ = 
//│ 			[C p₂]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p₁]: 39 --->
//│ 	case pp¹ of {C b¹ => case b¹ of {C d¹ => (c₀ d¹)}}: 26
//│ [C p₂]: 37 --->
//│ 	case b¹ of {C d¹ => (c₀ d¹)}: 25
//│ [C p₂]: 29 --->
//│ 	case x¹ of {C a¹ => (c₀ a¹)}: 34
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (main₀ p₀)
//│ def main₀ = 
//│ 	(fun pp¹ -> pp¹)
//│ 	where
//│ 	def c₀ = 
//│ 		(fun x¹ -> x¹)
//│ def p₀ = 
//│ 	let b¹ = p₁
//│ 	in b¹
//│ 	where
//│ 	def p₁ = 
//│ 		let d¹ = p₂
//│ 		in (c₀ d¹)
//│ 		where
//│ 		def p₂ = 
//│ 			let a¹ = p₂
//│ 			in (c₀ a¹)
//│ <<<<<<< after fusion <<<<<<<


let rec p = C(p)
let c(x) = if x is
  C(a) then c(a)
fun main(cc, pp) = cc(pp)
main(c, p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#let| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|cc|,| |pp|)| |#=| |cc|(|pp|)|↵|main|(|c|,| |p|)|
//│ Parsed: {let rec p = C (p,); let c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = cc, pp, => cc (pp,); main (c, p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((main^14 c^15) p^17)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => (c^4 a⁰)})
//│ def main = (fun cc⁰ -> (fun pp⁰ -> (cc⁰ pp⁰)))
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^15]
//│ 	[c^15 · c^4] ---> [c^15] (only one)
//│ [main^14] (hopeless to continue)
//│ [p^17]
//│ 	[p^17 · p^1] ---> [p^17] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((main₀ c₀) p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C a¹ => (c₀ a¹)})
//│ def main₀ = 
//│ 	(fun cc¹ -> (fun pp¹ -> (cc¹ pp¹)))
//│ def p₀ = 
//│ 	[C p₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p₀]: 26 --->
//│ 	case x¹ of {C a¹ => (c₀ a¹)}: 23
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((main₀ c₀) p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> x¹)
//│ def main₀ = 
//│ 	(fun cc¹ -> (fun pp¹ -> (cc¹ pp¹)))
//│ def p₀ = 
//│ 	let a¹ = p₀
//│ 	in (c₀ a¹)
//│ <<<<<<< after fusion <<<<<<<


fun cons(y) = if y is
  C(aa) then cons(aa)
fun a(x) = b(x)
fun b(x) = c(x)
fun c(x) = d(cons, x)
fun d(cc, x) = cc(x)
let p = C(p)
a(p)
//│ |#fun| |cons|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |cons|(|aa|)|←|↵|#fun| |a|(|x|)| |#=| |b|(|x|)|↵|#fun| |b|(|x|)| |#=| |c|(|x|)|↵|#fun| |c|(|x|)| |#=| |d|(|cons|,| |x|)|↵|#fun| |d|(|cc|,| |x|)| |#=| |cc|(|x|)|↵|#let| |p| |#=| |C|(|p|)|↵|a|(|p|)|
//│ Parsed: {fun cons = y, => if y is ‹(C (aa,)) then cons (aa,)›; fun a = x, => b (x,); fun b = x, => c (x,); fun c = x, => d (cons, x,); fun d = cc, x, => cc (x,); let p = C (p,); a (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (a^28 p^29)
//│ def a = (fun x⁰ -> (b^7 x⁰))
//│ def b = (fun x¹ -> (c^11 x¹))
//│ def c = (fun x² -> ((d^15 cons^16) x²))
//│ def cons = (fun y⁰ -> case y⁰ of {
//│ 	C aa⁰ => (cons^2 aa⁰)})
//│ def d = (fun cc⁰ -> (fun x³ -> (cc⁰ x³)))
//│ def p = [C p^26]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [a^28]
//│ 	[a^28 · b^7]
//│ 		[a^28 · b^7 · c^11]
//│ 			[a^28 · b^7 · c^11 · cons^16]
//│ 				[a^28 · b^7 · c^11 · cons^16 · cons^2]
//│ 					[a^28 · b^7 · c^11 · cons^16 · cons^2 · cons^2] ---> [a^28 · b^7 · c^11 · cons^16 · cons^2] (only one)
//│ 			[a^28 · b^7 · c^11 · d^15] (hopeless to continue)
//│ [p^29]
//│ 	[p^29 · p^26]
//│ 		[p^29 · p^26 · p^26] ---> [p^29 · p^26] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (a₀ p₀)
//│ def a₀ = 
//│ 	(fun x⁴ -> (b₀ x⁴))
//│ 	where
//│ 	def b₀ = 
//│ 		(fun x⁷ -> (c₀ x⁷))
//│ 		where
//│ 		def c₀ = 
//│ 			(fun x⁶ -> ((d₀ cons₀) x⁶))
//│ 			where
//│ 			def cons₀ = 
//│ 				(fun y² -> case y² of {
//│ 					C aa² => (cons₁ aa²)})
//│ 				where
//│ 				def cons₁ = 
//│ 					(fun y¹ -> case y¹ of {
//│ 						C aa¹ => (cons₁ aa¹)})
//│ 			def d₀ = 
//│ 				(fun cc¹ -> (fun x⁵ -> (cc¹ x⁵)))
//│ def p₀ = 
//│ 	[C p₁]
//│ 	where
//│ 	def p₁ = 
//│ 		[C p₁]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p₁]: 50 --->
//│ 	case y² of {C aa² => (cons₁ aa²)}: 47
//│ [C p₁]: 38 --->
//│ 	case y¹ of {C aa¹ => (cons₁ aa¹)}: 35
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (a₀ p₀)
//│ def a₀ = 
//│ 	(fun x⁴ -> (b₀ x⁴))
//│ 	where
//│ 	def b₀ = 
//│ 		(fun x⁷ -> (c₀ x⁷))
//│ 		where
//│ 		def c₀ = 
//│ 			(fun x⁶ -> ((d₀ cons₀) x⁶))
//│ 			where
//│ 			def cons₀ = 
//│ 				(fun y² -> y²)
//│ 				where
//│ 				def cons₁ = 
//│ 					(fun y¹ -> y¹)
//│ 			def d₀ = 
//│ 				(fun cc¹ -> (fun x⁵ -> (cc¹ x⁵)))
//│ def p₀ = 
//│ 	let aa² = p₁
//│ 	in (cons₁ aa²)
//│ 	where
//│ 	def p₁ = 
//│ 		let aa¹ = p₁
//│ 		in (cons₁ aa¹)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
let p = C(N)
fun c(x) = if C(x) is
  C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|N|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (N,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^10 p^11)
//│ def c = (fun x⁰ -> case [C x⁰] of {
//│ 	C a⁰ => (c^5 a⁰)})
//│ def p = [C [N]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^10] (hopeless to continue)
//│ 	[c^10 · c^5] ---> [c^10] (using original def)
//│ [p^11] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case [C x¹] of {
//│ 		C a¹ => (c₀ a¹)})
//│ def p₀ = 
//│ 	[C [N]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => (c₀ a¹)}: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> 
//│ 		let a¹ = x¹
//│ 		in (c₀ a¹))
//│ def p₀ = 
//│ 	[C [N]]
//│ <<<<<<< after fusion <<<<<<<


// let rec p = C(p)
// let q = p
// fun c(x) = if x is
//     C(a) then a
// fun c2(z) = if z is
//     C(b) then c2(b)
// let main = c(q)
// c2(main)


let rec p = C(p)
fun c(x) = if x is
  C(a) then a
fun c1(xx) = if xx is
  C(aa) then aa
fun c2(z) = if z is
  C(b) then c2(b)
let main = c(p)
fun id(y) = c1(C(y))
c2(id(main))
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |a|←|↵|#fun| |c1|(|xx|)| |#=| |#if| |xx| |is|→|C|(|aa|)| |#then| |aa|←|↵|#fun| |c2|(|z|)| |#=| |#if| |z| |is|→|C|(|b|)| |#then| |c2|(|b|)|←|↵|#let| |main| |#=| |c|(|p|)|↵|#fun| |id|(|y|)| |#=| |c1|(|C|(|y|)|)|↵|c2|(|id|(|main|)|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then a›; fun c1 = xx, => if xx is ‹(C (aa,)) then aa›; fun c2 = z, => if z is ‹(C (b,)) then c2 (b,)›; let main = c (p,); fun id = y, => c1 (C (y,),); c2 (id (main,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c2^25 (id^26 main^27))
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => a⁰})
//│ def c1 = (fun xx⁰ -> case xx⁰ of {
//│ 	C aa⁰ => aa⁰})
//│ def c2 = (fun z⁰ -> case z⁰ of {
//│ 	C b⁰ => (c2^12 b⁰)})
//│ def id = (fun y⁰ -> (c1^20 [C y⁰]))
//│ def main = (c^17 p^18)
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c2^25]
//│ 	[c2^25 · c2^12] ---> [c2^25] (only one)
//│ [id^26] (hopeless to continue)
//│ 	[id^26 · c1^20] (using original def)
//│ [main^27]
//│ 	[main^27 · c^17] (hopeless to continue)
//│ 	[main^27 · p^18]
//│ 		[main^27 · p^18 · p^1]
//│ 			[main^27 · p^18 · p^1 · p^1] ---> [main^27 · p^18 · p^1] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c2₀ (id₀ main₀))
//│ def c2₀ = 
//│ 	(fun z¹ -> case z¹ of {
//│ 		C b¹ => (c2₀ b¹)})
//│ def id₀ = 
//│ 	(fun y¹ -> (c1₀ [C y¹]))
//│ 	where
//│ 	def c1₀ = 
//│ 		(fun xx¹ -> case xx¹ of {
//│ 			C aa¹ => aa¹})
//│ def main₀ = 
//│ 	(c₀ p₀)
//│ 	where
//│ 	def c₀ = 
//│ 		(fun x¹ -> case x¹ of {
//│ 			C a¹ => a¹})
//│ 	def p₀ = 
//│ 		[C p₁]
//│ 		where
//│ 		def p₁ = 
//│ 			[C p₁]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p₁]: 45 --->
//│ 	case z¹ of {C b¹ => (c2₀ b¹)}: 54
//│ [C p₁]: 31 --->
//│ 	case x¹ of {C a¹ => a¹}: 48
//│ [C y¹]: 34 --->
//│ 	case xx¹ of {C aa¹ => aa¹}: 42
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c2₀ (id₀ main₀))
//│ def c2₀ = 
//│ 	(fun z¹ -> z¹)
//│ def id₀ = 
//│ 	(fun y¹ -> (c1₀ 
//│ 		let aa¹ = y¹
//│ 		in aa¹))
//│ 	where
//│ 	def c1₀ = 
//│ 		(fun xx¹ -> xx¹)
//│ def main₀ = 
//│ 	(c₀ p₀)
//│ 	where
//│ 	def c₀ = 
//│ 		(fun x¹ -> x¹)
//│ 	def p₀ = 
//│ 		let a¹ = p₁
//│ 		in a¹
//│ 		where
//│ 		def p₁ = 
//│ 			let b¹ = p₁
//│ 			in (c2₀ b¹)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
let t = T(K, T(N, L, L), T(N, L, L))
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |#let| |t| |#=| |T|(|K|,| |T|(|N|,| |L|,| |L|)|,| |T|(|N|,| |L|,| |L|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let t = T (K, T (N, L, L,), T (N, L, L,),); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^26 t^27)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^16 l⁰) (c^19 r⁰)]
//│ 	| L => [LL]})
//│ def t = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^26]
//│ 	[c^26 · c^16]
//│ 		[c^26 · c^16 · c^16]
//│ 			[c^26 · c^16 · c^16 · c^16] ---> [c^26 · c^16 · c^16] (only one)
//│ 			[c^26 · c^16 · c^16 · c^19] ---> [c^26 · c^16 · c^16] (only one)
//│ 		[c^26 · c^16 · c^19]
//│ 			[c^26 · c^16 · c^19 · c^16] ---> [c^26 · c^16 · c^19] (only one)
//│ 			[c^26 · c^16 · c^19 · c^19] ---> [c^26 · c^16 · c^19] (only one)
//│ 	[c^26 · c^19]
//│ 		[c^26 · c^19 · c^16]
//│ 			[c^26 · c^19 · c^16 · c^16] ---> [c^26 · c^19 · c^16] (only one)
//│ 			[c^26 · c^19 · c^16 · c^19] ---> [c^26 · c^19 · c^16] (only one)
//│ 		[c^26 · c^19 · c^19]
//│ 			[c^26 · c^19 · c^19 · c^16] ---> [c^26 · c^19 · c^19] (only one)
//│ 			[c^26 · c^19 · c^19 · c^19] ---> [c^26 · c^19 · c^19] (only one)
//│ [t^27]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ t₀)
//│ def c₀ = 
//│ 	(fun x⁶ -> case x⁶ of {
//│ 		T n⁶ l⁶ r⁶ => [T case n⁶ of {
//│ 			K => [KK]
//│ 			| N => [NN]} (c₁ l⁶) (c₄ r⁶)]
//│ 		| L => [LL]})
//│ 	where
//│ 	def c₁ = 
//│ 		(fun x² -> case x² of {
//│ 			T n² l² r² => [T case n² of {
//│ 				K => [KK]
//│ 				| N => [NN]} (c₂ l²) (c₃ r²)]
//│ 			| L => [LL]})
//│ 		where
//│ 		def c₂ = 
//│ 			(fun x⁷ -> case x⁷ of {
//│ 				T n⁷ l⁷ r⁷ => [T case n⁷ of {
//│ 					K => [KK]
//│ 					| N => [NN]} (c₂ l⁷) (c₂ r⁷)]
//│ 				| L => [LL]})
//│ 		def c₃ = 
//│ 			(fun x⁴ -> case x⁴ of {
//│ 				T n⁴ l⁴ r⁴ => [T case n⁴ of {
//│ 					K => [KK]
//│ 					| N => [NN]} (c₃ l⁴) (c₃ r⁴)]
//│ 				| L => [LL]})
//│ 	def c₄ = 
//│ 		(fun x¹ -> case x¹ of {
//│ 			T n¹ l¹ r¹ => [T case n¹ of {
//│ 				K => [KK]
//│ 				| N => [NN]} (c₅ l¹) (c₆ r¹)]
//│ 			| L => [LL]})
//│ 		where
//│ 		def c₅ = 
//│ 			(fun x³ -> case x³ of {
//│ 				T n³ l³ r³ => [T case n³ of {
//│ 					K => [KK]
//│ 					| N => [NN]} (c₅ l³) (c₅ r³)]
//│ 				| L => [LL]})
//│ 		def c₆ = 
//│ 			(fun x⁵ -> case x⁵ of {
//│ 				T n⁵ l⁵ r⁵ => [T case n⁵ of {
//│ 					K => [KK]
//│ 					| N => [NN]} (c₆ l⁵) (c₆ r⁵)]
//│ 				| L => [LL]})
//│ def t₀ = 
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 29 --->
//│ 	case n⁶ of {K => [KK] | N => [NN]}: 118
//│ [L]: 32 --->
//│ 	case x⁴ of {T n⁴ l⁴ r⁴ => [T case n⁴ of {K => [KK] | N => [NN]} (c₃ l⁴) (c₃ r⁴)] | L => [LL]}: 97
//│ [L]: 35 --->
//│ 	case x³ of {T n³ l³ r³ => [T case n³ of {K => [KK] | N => [NN]} (c₅ l³) (c₅ r³)] | L => [LL]}: 82
//│ [L]: 36 --->
//│ 	case x⁵ of {T n⁵ l⁵ r⁵ => [T case n⁵ of {K => [KK] | N => [NN]} (c₆ l⁵) (c₆ r⁵)] | L => [LL]}: 112
//│ [L]: 31 --->
//│ 	case x⁷ of {T n⁷ l⁷ r⁷ => [T case n⁷ of {K => [KK] | N => [NN]} (c₂ l⁷) (c₂ r⁷)] | L => [LL]}: 142
//│ [N]: 34 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 43
//│ [N]: 30 --->
//│ 	case n² of {K => [KK] | N => [NN]}: 58
//│ [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 38 --->
//│ 	case x⁶ of {T n⁶ l⁶ r⁶ => [T case n⁶ of {K => [KK] | N => [NN]} (c₁ l⁶) (c₄ r⁶)] | L => [LL]}: 127
//│ [T [N] [L] [L]]: 33 --->
//│ 	case x² of {T n² l² r² => [T case n² of {K => [KK] | N => [NN]} (c₂ l²) (c₃ r²)] | L => [LL]}: 67
//│ [T [N] [L] [L]]: 37 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₅ l¹) (c₆ r¹)] | L => [LL]}: 52
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ t₀)
//│ def c₀ = 
//│ 	(fun x⁶ -> x⁶)
//│ 	where
//│ 	def c₁ = 
//│ 		(fun x² -> x²)
//│ 		where
//│ 		def c₂ = 
//│ 			(fun x⁷ -> x⁷)
//│ 		def c₃ = 
//│ 			(fun x⁴ -> x⁴)
//│ 	def c₄ = 
//│ 		(fun x¹ -> x¹)
//│ 		where
//│ 		def c₅ = 
//│ 			(fun x³ -> x³)
//│ 		def c₆ = 
//│ 			(fun x⁵ -> x⁵)
//│ def t₀ = 
//│ 	let n⁶ = [KK]
//│ 	in let l⁶ = 	
//│ 		let n² = [NN]
//│ 		in let l² = [LL]
//│ 		in let r² = [LL]
//│ 		in [T n² (c₂ l²) (c₃ r²)]
//│ 	in let r⁶ = 	
//│ 		let n¹ = [NN]
//│ 		in let l¹ = [LL]
//│ 		in let r¹ = [LL]
//│ 		in [T n¹ (c₅ l¹) (c₆ r¹)]
//│ 	in [T n⁶ (c₁ l⁶) (c₄ r⁶)]
//│ <<<<<<< after fusion <<<<<<<


let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^28 t^29)
//│ def aa = [T [N] [L] [L]]
//│ def bb = [T [N] [L] [L]]
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^18 l⁰) (c^21 r⁰)]
//│ 	| L => [LL]})
//│ def t = [T [K] aa^10 bb^11]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^28]
//│ 	[c^28 · c^18]
//│ 		[c^28 · c^18 · c^18]
//│ 			[c^28 · c^18 · c^18 · c^18] ---> [c^28 · c^18 · c^18] (only one)
//│ 			[c^28 · c^18 · c^18 · c^21] ---> [c^28 · c^18 · c^18] (only one)
//│ 		[c^28 · c^18 · c^21]
//│ 			[c^28 · c^18 · c^21 · c^18] ---> [c^28 · c^18 · c^21] (only one)
//│ 			[c^28 · c^18 · c^21 · c^21] ---> [c^28 · c^18 · c^21] (only one)
//│ 	[c^28 · c^21]
//│ 		[c^28 · c^21 · c^18]
//│ 			[c^28 · c^21 · c^18 · c^18] ---> [c^28 · c^21 · c^18] (only one)
//│ 			[c^28 · c^21 · c^18 · c^21] ---> [c^28 · c^21 · c^18] (only one)
//│ 		[c^28 · c^21 · c^21]
//│ 			[c^28 · c^21 · c^21 · c^18] ---> [c^28 · c^21 · c^21] (only one)
//│ 			[c^28 · c^21 · c^21 · c^21] ---> [c^28 · c^21 · c^21] (only one)
//│ [t^29]
//│ 	[t^29 · aa^10]
//│ 	[t^29 · bb^11]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ t₀)
//│ def c₀ = 
//│ 	(fun x³ -> case x³ of {
//│ 		T n³ l³ r³ => [T case n³ of {
//│ 			K => [KK]
//│ 			| N => [NN]} (c₁ l³) (c₄ r³)]
//│ 		| L => [LL]})
//│ 	where
//│ 	def c₁ = 
//│ 		(fun x¹ -> case x¹ of {
//│ 			T n¹ l¹ r¹ => [T case n¹ of {
//│ 				K => [KK]
//│ 				| N => [NN]} (c₂ l¹) (c₃ r¹)]
//│ 			| L => [LL]})
//│ 		where
//│ 		def c₂ = 
//│ 			(fun x² -> case x² of {
//│ 				T n² l² r² => [T case n² of {
//│ 					K => [KK]
//│ 					| N => [NN]} (c₂ l²) (c₂ r²)]
//│ 				| L => [LL]})
//│ 		def c₃ = 
//│ 			(fun x⁶ -> case x⁶ of {
//│ 				T n⁶ l⁶ r⁶ => [T case n⁶ of {
//│ 					K => [KK]
//│ 					| N => [NN]} (c₃ l⁶) (c₃ r⁶)]
//│ 				| L => [LL]})
//│ 	def c₄ = 
//│ 		(fun x⁴ -> case x⁴ of {
//│ 			T n⁴ l⁴ r⁴ => [T case n⁴ of {
//│ 				K => [KK]
//│ 				| N => [NN]} (c₅ l⁴) (c₆ r⁴)]
//│ 			| L => [LL]})
//│ 		where
//│ 		def c₅ = 
//│ 			(fun x⁷ -> case x⁷ of {
//│ 				T n⁷ l⁷ r⁷ => [T case n⁷ of {
//│ 					K => [KK]
//│ 					| N => [NN]} (c₅ l⁷) (c₅ r⁷)]
//│ 				| L => [LL]})
//│ 		def c₆ = 
//│ 			(fun x⁵ -> case x⁵ of {
//│ 				T n⁵ l⁵ r⁵ => [T case n⁵ of {
//│ 					K => [KK]
//│ 					| N => [NN]} (c₆ l⁵) (c₆ r⁵)]
//│ 				| L => [LL]})
//│ def t₀ = 
//│ 	[T [K] aa₀ bb₀]
//│ 	where
//│ 	def aa₀ = 
//│ 		[T [N] [L] [L]]
//│ 	def bb₀ = 
//│ 		[T [N] [L] [L]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 80 --->
//│ 	case n³ of {K => [KK] | N => [NN]}: 69
//│ [L]: 130 --->
//│ 	case x² of {T n² l² r² => [T case n² of {K => [KK] | N => [NN]} (c₂ l²) (c₂ r²)] | L => [LL]}: 59
//│ [L]: 131 --->
//│ 	case x⁶ of {T n⁶ l⁶ r⁶ => [T case n⁶ of {K => [KK] | N => [NN]} (c₃ l⁶) (c₃ r⁶)] | L => [LL]}: 127
//│ [L]: 62 --->
//│ 	case x⁷ of {T n⁷ l⁷ r⁷ => [T case n⁷ of {K => [KK] | N => [NN]} (c₅ l⁷) (c₅ r⁷)] | L => [LL]}: 146
//│ [L]: 63 --->
//│ 	case x⁵ of {T n⁵ l⁵ r⁵ => [T case n⁵ of {K => [KK] | N => [NN]} (c₆ l⁵) (c₆ r⁵)] | L => [LL]}: 112
//│ [N]: 129 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 35
//│ [N]: 61 --->
//│ 	case n⁴ of {K => [KK] | N => [NN]}: 88
//│ [T [K] aa₀ bb₀]: 83 --->
//│ 	case x³ of {T n³ l³ r³ => [T case n³ of {K => [KK] | N => [NN]} (c₁ l³) (c₄ r³)] | L => [LL]}: 78
//│ [T [N] [L] [L]]: 64 --->
//│ 	case x⁴ of {T n⁴ l⁴ r⁴ => [T case n⁴ of {K => [KK] | N => [NN]} (c₅ l⁴) (c₆ r⁴)] | L => [LL]}: 97
//│ [T [N] [L] [L]]: 132 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₂ l¹) (c₃ r¹)] | L => [LL]}: 44
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ t₀)
//│ def c₀ = 
//│ 	(fun x³ -> x³)
//│ 	where
//│ 	def c₁ = 
//│ 		(fun x¹ -> x¹)
//│ 		where
//│ 		def c₂ = 
//│ 			(fun x² -> x²)
//│ 		def c₃ = 
//│ 			(fun x⁶ -> x⁶)
//│ 	def c₄ = 
//│ 		(fun x⁴ -> x⁴)
//│ 		where
//│ 		def c₅ = 
//│ 			(fun x⁷ -> x⁷)
//│ 		def c₆ = 
//│ 			(fun x⁵ -> x⁵)
//│ def t₀ = 
//│ 	let n³ = [KK]
//│ 	in let l³ = aa₀
//│ 	in let r³ = bb₀
//│ 	in [T n³ (c₁ l³) (c₄ r³)]
//│ 	where
//│ 	def aa₀ = 
//│ 		let n¹ = [NN]
//│ 		in let l¹ = [LL]
//│ 		in let r¹ = [LL]
//│ 		in [T n¹ (c₂ l¹) (c₃ r¹)]
//│ 	def bb₀ = 
//│ 		let n⁴ = [NN]
//│ 		in let l⁴ = [LL]
//│ 		in let r⁴ = [LL]
//│ 		in [T n⁴ (c₅ l⁴) (c₆ r⁴)]
//│ <<<<<<< after fusion <<<<<<<


fun map(ls) = if ls is
  C(h, t) then f => C(f(h), map(t)(f))
  N then f => N
let l = C(K, N)
map(l)(
  x => if x is
    K then T
)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#let| |l| |#=| |C|(|K|,| |N|)|↵|map|(|l|)|(|→|x| |=>| |#if| |x| |is|→|K| |#then| |T|←|←|↵|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then f, => C (f (h,), map (t,) (f,),); (N) then f, => N›; let l = C (K, N,); map (l,) (x, => if x is ‹(K) then T›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((map^19 l^20) (fun x⁰ -> case x⁰ of {
//│ 	K => [T]}))
//│ def l = [C [K] [N]]
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> [C (f⁰ h⁰) ((map^5 t⁰) f⁰)])
//│ 	| N => (fun f¹ -> [N])})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^20]
//│ [map^19]
//│ 	[map^19 · map^5]
//│ 		[map^19 · map^5 · map^5] ---> [map^19 · map^5] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((map₀ l₀) (fun x¹ -> case x¹ of {
//│ 	K => [T]}))
//│ def l₀ = 
//│ 	[C [K] [N]]
//│ def map₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h² t² => (fun f⁴ -> [C (f⁴ h²) ((map₁ t²) f⁴)])
//│ 		| N => (fun f⁵ -> [N])})
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls¹ -> case ls¹ of {
//│ 			C h¹ t¹ => (fun f² -> [C (f² h¹) ((map₁ t¹) f²)])
//│ 			| N => (fun f³ -> [N])})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [K] [N]]: 44 --->
//│ 	case ls² of {C h² t² => (fun f⁴ -> [C (f⁴ h²) ((map₁ t²) f⁴)]) | N => (fun f⁵ -> [N])}: 58
//│ [K]: 42 --->
//│ 	case x¹ of {K => [T]}: 65
//│ [N]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C (f² h¹) ((map₁ t¹) f²)]) | N => (fun f³ -> [N])}: 40
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((map₀ l₀) (fun x¹ -> x¹))
//│ def l₀ = 
//│ 	let h² = [T]
//│ 	in let t² = (fun f³ -> [N])
//│ 	in (fun f⁴ -> [C (f⁴ h²) ((map₁ t²) f⁴)])
//│ def map₀ = 
//│ 	(fun ls² -> ls²)
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls¹ -> ls¹)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
fun last(ys) = if ys is
  N then x => x
  C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
  N then None
  C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (lastDrive^22 [C 1 [C 2 [N]]])
//│ def last = (fun ys⁰ -> case ys⁰ of {
//│ 	N => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> ((last^4 t⁰) h⁰))})
//│ def lastDrive = (fun xs⁰ -> case xs⁰ of {
//│ 	N => [None]
//│ 	| C hh⁰ tt⁰ => [Some ((last^14 tt⁰) hh⁰)]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive^22]
//│ 	[lastDrive^22 · last^14]
//│ 		[lastDrive^22 · last^14 · last^4]
//│ 			[lastDrive^22 · last^14 · last^4 · last^4] ---> [lastDrive^22 · last^14 · last^4] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (lastDrive₀ [C 1 [C 2 [N]]])
//│ def lastDrive₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		N => [None]
//│ 		| C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]})
//│ 	where
//│ 	def last₀ = 
//│ 		(fun ys¹ -> case ys¹ of {
//│ 			N => (fun x² -> x²)
//│ 			| C h¹ t¹ => (fun x³ -> ((last₁ t¹) h¹))})
//│ 		where
//│ 		def last₁ = 
//│ 			(fun ys² -> case ys² of {
//│ 				N => (fun x⁴ -> x⁴)
//│ 				| C h² t² => (fun x⁵ -> ((last₁ t²) h²))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]]: 66 --->
//│ 	case xs¹ of {N => [None] | C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]}: 37
//│ [C 2 [N]]: 65 --->
//│ 	case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₁ t¹) h¹))}: 48
//│ [N]: 64 --->
//│ 	case ys² of {N => (fun x⁴ -> x⁴) | C h² t² => (fun x⁵ -> ((last₁ t²) h²))}: 59
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (lastDrive₀ 
//│ 	let hh¹ = 1
//│ 	in let tt¹ = 	
//│ 		let h¹ = 2
//│ 		in let t¹ = (fun x⁴ -> x⁴)
//│ 		in (fun x³ -> ((last₁ t¹) h¹))
//│ 	in [Some ((last₀ tt¹) hh¹)])
//│ def lastDrive₀ = 
//│ 	(fun xs¹ -> xs¹)
//│ 	where
//│ 	def last₀ = 
//│ 		(fun ys¹ -> ys¹)
//│ 		where
//│ 		def last₁ = 
//│ 			(fun ys² -> ys²)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: with expanding termination
let p = C(p)
fun c(x) = if C(x) is
  C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^10 p^11)
//│ def c = (fun x⁰ -> case [C x⁰] of {
//│ 	C a⁰ => (c^5 a⁰)})
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^10] (hopeless to continue)
//│ 	[c^10 · c^5] ---> [c^10] (using original def)
//│ [p^11] (hopeless to continue)
//│ 	[p^11 · p^1] ---> [p^11] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case [C x¹] of {
//│ 		C a¹ => (c₀ a¹)})
//│ def p₀ = 
//│ 	[C p₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => (c₀ a¹)}: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> 
//│ 		let a¹ = x¹
//│ 		in (c₀ a¹))
//│ def p₀ = 
//│ 	[C p₀]
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: with expanding termination
let rec p = C(p)
fun c(x) = if x is
  C(a) then a
fun main(y) = c(p)
main(0)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |a|←|↵|#fun| |main|(|y|)| |#=| |c|(|p|)|↵|main|(|0|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then a›; fun main = y, => c (p,); main (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (main^11 0)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => a⁰})
//│ def main = (fun y⁰ -> (c^7 p^8))
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [main^11] (hopeless to continue)
//│ 	[main^11 · c^7] (using original def)
//│ 	[main^11 · p^8] (using original def)
//│ 		[main^11 · p^8 · p^1] ---> [main^11 · p^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (main₀ 0)
//│ def main₀ = 
//│ 	(fun y¹ -> (c₀ p₀))
//│ 	where
//│ 	def c₀ = 
//│ 		(fun x¹ -> case x¹ of {
//│ 			C a¹ => a¹})
//│ 	def p₀ = 
//│ 		[C p₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p₀]: 23 --->
//│ 	case x¹ of {C a¹ => a¹}: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (main₀ 0)
//│ def main₀ = 
//│ 	(fun y¹ -> (c₀ p₀))
//│ 	where
//│ 	def c₀ = 
//│ 		(fun x¹ -> x¹)
//│ 	def p₀ = 
//│ 		let a¹ = p₀
//│ 		in a¹
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: although multiple matches
// top level definitions as producers can be duplicated
fun c1(x1) = if x1 is
  A then AA
  B then BB
fun c2(x2) = if x2 is
  A then AAA
  B then BBB
let a = A
c1(a)
c2(a)
c2(B)
//│ |#fun| |c1|(|x1|)| |#=| |#if| |x1| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|#fun| |c2|(|x2|)| |#=| |#if| |x2| |is|→|A| |#then| |AAA|↵|B| |#then| |BBB|←|↵|#let| |a| |#=| |A|↵|c1|(|a|)|↵|c2|(|a|)|↵|c2|(|B|)|
//│ Parsed: {fun c1 = x1, => if x1 is ‹(A) then AA; (B) then BB›; fun c2 = x2, => if x2 is ‹(A) then AAA; (B) then BBB›; let a = A; c1 (a,); c2 (a,); c2 (B,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c1^12 a^13)
//│ (c2^15 a^16)
//│ (c2^18 [B])
//│ def a = [A]
//│ def c1 = (fun x1⁰ -> case x1⁰ of {
//│ 	A => [AA]
//│ 	| B => [BB]})
//│ def c2 = (fun x2⁰ -> case x2⁰ of {
//│ 	A => [AAA]
//│ 	| B => [BBB]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [a^13] (hopeless to continue)
//│ [a^16] (hopeless to continue)
//│ [c1^12] (hopeless to continue)
//│ [c2^15] (hopeless to continue)
//│ [c2^18] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c1₀ a₀)
//│ (c2₀ a₁)
//│ (c2₁ [B])
//│ def a₀ = 
//│ 	[A]
//│ def a₁ = 
//│ 	[A]
//│ def c1₀ = 
//│ 	(fun x1¹ -> case x1¹ of {
//│ 		A => [AA]
//│ 		| B => [BB]})
//│ def c2₀ = 
//│ 	(fun x2¹ -> case x2¹ of {
//│ 		A => [AAA]
//│ 		| B => [BBB]})
//│ def c2₁ = 
//│ 	(fun x2² -> case x2² of {
//│ 		A => [AAA]
//│ 		| B => [BBB]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 21 --->
//│ 	case x1¹ of {A => [AA] | B => [BB]}: 25
//│ [A]: 27 --->
//│ 	case x2¹ of {A => [AAA] | B => [BBB]}: 31
//│ [B]: 45 --->
//│ 	case x2² of {A => [AAA] | B => [BBB]}: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c1₀ a₀)
//│ (c2₀ a₁)
//│ (c2₁ [BBB])
//│ def a₀ = 
//│ 	[AA]
//│ def a₁ = 
//│ 	[AAA]
//│ def c1₀ = 
//│ 	(fun x1¹ -> x1¹)
//│ def c2₀ = 
//│ 	(fun x2¹ -> x2¹)
//│ def c2₁ = 
//│ 	(fun x2² -> x2²)
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: the single rev can work, because the expansion can
// handle the correct time of expansion
fun rev(ls) = if ls is
  N then a => a
  C(h, t) then a => rev(t)(C(h, a))
rev(C(AA, C(BB, C(CC, N))))(N)
//│ |#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a| |=>| |a|↵|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|←|↵|rev|(|C|(|AA|,| |C|(|BB|,| |C|(|CC|,| |N|)|)|)|)|(|N|)|
//│ Parsed: {fun rev = ls, => if ls is ‹(N) then a, => a; (C (h, t,)) then a, => rev (t,) (C (h, a,),)›; rev (C (AA, C (BB, C (CC, N,),),),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev^14 [C [AA] [C [BB] [C [CC] [N]]]]) [N])
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	N => (fun a⁰ -> a⁰)
//│ 	| C h⁰ t⁰ => (fun a¹ -> ((rev^4 t⁰) [C h⁰ a¹]))})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14]
//│ 	[rev^14 · rev^4]
//│ 		[rev^14 · rev^4 · rev^4]
//│ 			[rev^14 · rev^4 · rev^4 · rev^4]
//│ 				[rev^14 · rev^4 · rev^4 · rev^4 · rev^4] ---> [rev^14 · rev^4 · rev^4 · rev^4] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev₀ [C [AA] [C [BB] [C [CC] [N]]]]) [N])
//│ def rev₀ = 
//│ 	(fun ls⁴ -> case ls⁴ of {
//│ 		N => (fun a⁸ -> a⁸)
//│ 		| C h⁴ t⁴ => (fun a⁹ -> ((rev₁ t⁴) [C h⁴ a⁹]))})
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun ls³ -> case ls³ of {
//│ 			N => (fun a⁶ -> a⁶)
//│ 			| C h³ t³ => (fun a⁷ -> ((rev₂ t³) [C h³ a⁷]))})
//│ 		where
//│ 		def rev₂ = 
//│ 			(fun ls² -> case ls² of {
//│ 				N => (fun a⁴ -> a⁴)
//│ 				| C h² t² => (fun a⁵ -> ((rev₃ t²) [C h² a⁵]))})
//│ 			where
//│ 			def rev₃ = 
//│ 				(fun ls¹ -> case ls¹ of {
//│ 					N => (fun a² -> a²)
//│ 					| C h¹ t¹ => (fun a³ -> ((rev₃ t¹) [C h¹ a³]))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [AA] [C [BB] [C [CC] [N]]]]: 84 --->
//│ 	case ls⁴ of {N => (fun a⁸ -> a⁸) | C h⁴ t⁴ => (fun a⁹ -> ((rev₁ t⁴) [C h⁴ a⁹]))}: 75
//│ [C [BB] [C [CC] [N]]]: 83 --->
//│ 	case ls³ of {N => (fun a⁶ -> a⁶) | C h³ t³ => (fun a⁷ -> ((rev₂ t³) [C h³ a⁷]))}: 62
//│ [C [CC] [N]]: 82 --->
//│ 	case ls² of {N => (fun a⁴ -> a⁴) | C h² t² => (fun a⁵ -> ((rev₃ t²) [C h² a⁵]))}: 49
//│ [N]: 81 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₃ t¹) [C h¹ a³]))}: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev₀ 
//│ 	let h⁴ = [AA]
//│ 	in let t⁴ = 	
//│ 		let h³ = [BB]
//│ 		in let t³ = 	
//│ 			let h² = [CC]
//│ 			in let t² = (fun a² -> a²)
//│ 			in (fun a⁵ -> ((rev₃ t²) [C h² a⁵]))
//│ 		in (fun a⁷ -> ((rev₂ t³) [C h³ a⁷]))
//│ 	in (fun a⁹ -> ((rev₁ t⁴) [C h⁴ a⁹]))) [N])
//│ def rev₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun ls³ -> ls³)
//│ 		where
//│ 		def rev₂ = 
//│ 			(fun ls² -> ls²)
//│ 			where
//│ 			def rev₃ = 
//│ 				(fun ls¹ -> ls¹)
//│ <<<<<<< after fusion <<<<<<<



// CORRECT:
fun last(ys) = if ys is
  N then x => x
  C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
  N then None
  C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (lastDrive^22 [C 1 [C 2 [N]]])
//│ def last = (fun ys⁰ -> case ys⁰ of {
//│ 	N => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> ((last^4 t⁰) h⁰))})
//│ def lastDrive = (fun xs⁰ -> case xs⁰ of {
//│ 	N => [None]
//│ 	| C hh⁰ tt⁰ => [Some ((last^14 tt⁰) hh⁰)]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive^22]
//│ 	[lastDrive^22 · last^14]
//│ 		[lastDrive^22 · last^14 · last^4]
//│ 			[lastDrive^22 · last^14 · last^4 · last^4] ---> [lastDrive^22 · last^14 · last^4] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (lastDrive₀ [C 1 [C 2 [N]]])
//│ def lastDrive₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		N => [None]
//│ 		| C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]})
//│ 	where
//│ 	def last₀ = 
//│ 		(fun ys¹ -> case ys¹ of {
//│ 			N => (fun x² -> x²)
//│ 			| C h¹ t¹ => (fun x³ -> ((last₁ t¹) h¹))})
//│ 		where
//│ 		def last₁ = 
//│ 			(fun ys² -> case ys² of {
//│ 				N => (fun x⁴ -> x⁴)
//│ 				| C h² t² => (fun x⁵ -> ((last₁ t²) h²))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]]: 66 --->
//│ 	case xs¹ of {N => [None] | C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]}: 37
//│ [C 2 [N]]: 65 --->
//│ 	case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₁ t¹) h¹))}: 48
//│ [N]: 64 --->
//│ 	case ys² of {N => (fun x⁴ -> x⁴) | C h² t² => (fun x⁵ -> ((last₁ t²) h²))}: 59
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (lastDrive₀ 
//│ 	let hh¹ = 1
//│ 	in let tt¹ = 	
//│ 		let h¹ = 2
//│ 		in let t¹ = (fun x⁴ -> x⁴)
//│ 		in (fun x³ -> ((last₁ t¹) h¹))
//│ 	in [Some ((last₀ tt¹) hh¹)])
//│ def lastDrive₀ = 
//│ 	(fun xs¹ -> xs¹)
//│ 	where
//│ 	def last₀ = 
//│ 		(fun ys¹ -> ys¹)
//│ 		where
//│ 		def last₁ = 
//│ 			(fun ys² -> ys²)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: the time of unrolling is correct
fun id(k) = k
fun id1(x) = id(x)
fun id2(y) = y
fun id3(z) = z
let rec p = C(C(C(id7(C(C(id1(p)))))))
fun c(xx) = if xx is
  C(a) then c(a)
fun id4(k) = k
fun id5(j) = j
fun id6(l) = l
fun id7(i) = i
id6(id4)(c)(id5(id2)(id3(p)))
//│ |#fun| |id|(|k|)| |#=| |k|↵|#fun| |id1|(|x|)| |#=| |id|(|x|)|↵|#fun| |id2|(|y|)| |#=| |y|↵|#fun| |id3|(|z|)| |#=| |z|↵|#let| |#rec| |p| |#=| |C|(|C|(|C|(|id7|(|C|(|C|(|id1|(|p|)|)|)|)|)|)|)|↵|#fun| |c|(|xx|)| |#=| |#if| |xx| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id4|(|k|)| |#=| |k|↵|#fun| |id5|(|j|)| |#=| |j|↵|#fun| |id6|(|l|)| |#=| |l|↵|#fun| |id7|(|i|)| |#=| |i|↵|id6|(|id4|)|(|c|)|(|id5|(|id2|)|(|id3|(|p|)|)|)|
//│ Parsed: {fun id = k, => k; fun id1 = x, => id (x,); fun id2 = y, => y; fun id3 = z, => z; let rec p = C (C (C (id7 (C (C (id1 (p,),),),),),),); fun c = xx, => if xx is ‹(C (a,)) then c (a,)›; fun id4 = k, => k; fun id5 = j, => j; fun id6 = l, => l; fun id7 = i, => i; id6 (id4,) (c,) (id5 (id2,) (id3 (p,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (((id6^35 id4^36) c^38) ((id5^40 id2^41) (id3^43 p^44)))
//│ def c = (fun xx⁰ -> case xx⁰ of {
//│ 	C a⁰ => (c^22 a⁰)})
//│ def id = (fun k⁰ -> k⁰)
//│ def id1 = (fun x⁰ -> (id^3 x⁰))
//│ def id2 = (fun y⁰ -> y⁰)
//│ def id3 = (fun z⁰ -> z⁰)
//│ def id4 = (fun k¹ -> k¹)
//│ def id5 = (fun j⁰ -> j⁰)
//│ def id6 = (fun l⁰ -> l⁰)
//│ def id7 = (fun i⁰ -> i⁰)
//│ def p = [C [C [C (id7^11 [C [C (id1^12 p^13)]])]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^38]
//│ 	[c^38 · c^22]
//│ 		[c^38 · c^22 · c^22]
//│ 			[c^38 · c^22 · c^22 · c^22]
//│ 				[c^38 · c^22 · c^22 · c^22 · c^22]
//│ 					[c^38 · c^22 · c^22 · c^22 · c^22 · c^22]
//│ 						[c^38 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22]
//│ 							[c^38 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22]
//│ 								[c^38 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22]
//│ 									[c^38 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22] ---> [c^38 · c^22 · c^22 · c^22 · c^22] (only one)
//│ [id2^41] (hopeless to continue)
//│ [id3^43] (hopeless to continue)
//│ [id4^36] (hopeless to continue)
//│ [id5^40] (hopeless to continue)
//│ [id6^35] (hopeless to continue)
//│ [p^44]
//│ 	[p^44 · id1^12] (hopeless to continue)
//│ 		[p^44 · id1^12 · id^3] (using original def)
//│ 	[p^44 · id7^11] (hopeless to continue)
//│ 	[p^44 · p^13]
//│ 		[p^44 · p^13 · id1^12] (hopeless to continue)
//│ 			[p^44 · p^13 · id1^12 · id^3] (using original def)
//│ 		[p^44 · p^13 · id7^11] (hopeless to continue)
//│ 		[p^44 · p^13 · p^13] ---> [p^44 · p^13] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (((id6₀ id4₀) c₀) ((id5₀ id2₀) (id3₀ p₀)))
//│ def c₀ = 
//│ 	(fun xx⁷ -> case xx⁷ of {
//│ 		C a⁷ => (c₁ a⁷)})
//│ 	where
//│ 	def c₁ = 
//│ 		(fun xx³ -> case xx³ of {
//│ 			C a³ => (c₂ a³)})
//│ 		where
//│ 		def c₂ = 
//│ 			(fun xx⁵ -> case xx⁵ of {
//│ 				C a⁵ => (c₃ a⁵)})
//│ 			where
//│ 			def c₃ = 
//│ 				(fun xx² -> case xx² of {
//│ 					C a² => (c₄ a²)})
//│ 				where
//│ 				def c₄ = 
//│ 					(fun xx⁴ -> case xx⁴ of {
//│ 						C a⁴ => (c₅ a⁴)})
//│ 					where
//│ 					def c₅ = 
//│ 						(fun xx⁸ -> case xx⁸ of {
//│ 							C a⁸ => (c₆ a⁸)})
//│ 						where
//│ 						def c₆ = 
//│ 							(fun xx⁹ -> case xx⁹ of {
//│ 								C a⁹ => (c₇ a⁹)})
//│ 							where
//│ 							def c₇ = 
//│ 								(fun xx¹ -> case xx¹ of {
//│ 									C a¹ => (c₈ a¹)})
//│ 								where
//│ 								def c₈ = 
//│ 									(fun xx⁶ -> case xx⁶ of {
//│ 										C a⁶ => (c₄ a⁶)})
//│ def id2₀ = 
//│ 	(fun y¹ -> y¹)
//│ def id3₀ = 
//│ 	(fun z¹ -> z¹)
//│ def id4₀ = 
//│ 	(fun k³ -> k³)
//│ def id5₀ = 
//│ 	(fun j¹ -> j¹)
//│ def id6₀ = 
//│ 	(fun l¹ -> l¹)
//│ def p₀ = 
//│ 	[C [C [C (id7₀ [C [C (id1₀ p₁)]])]]]
//│ 	where
//│ 	def id1₀ = 
//│ 		(fun x¹ -> (id₀ x¹))
//│ 		where
//│ 		def id₀ = 
//│ 			(fun k⁴ -> k⁴)
//│ 	def id7₀ = 
//│ 		(fun i¹ -> i¹)
//│ 	def p₁ = 
//│ 		[C [C [C (id7₁ [C [C (id1₁ p₁)]])]]]
//│ 		where
//│ 		def id1₁ = 
//│ 			(fun x² -> (id₁ x²))
//│ 			where
//│ 			def id₁ = 
//│ 				(fun k² -> k²)
//│ 		def id7₁ = 
//│ 			(fun i² -> i²)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C (id1₀ p₁)]: 136 --->
//│ 	case xx⁴ of {C a⁴ => (c₅ a⁴)}: 84
//│ [C (id1₁ p₁)]: 90 --->
//│ 	case xx⁴ of {C a⁴ => (c₅ a⁴)}: 84
//│ [C (id7₀ [C [C (id1₀ p₁)]])]: 139 --->
//│ 	case xx⁵ of {C a⁵ => (c₃ a⁵)}: 100
//│ [C (id7₁ [C [C (id1₁ p₁)]])]: 93 --->
//│ 	case xx¹ of {C a¹ => (c₈ a¹)}: 58
//│ [C [C (id1₀ p₁)]]: 137 --->
//│ 	case xx² of {C a² => (c₄ a²)}: 64
//│ [C [C (id1₁ p₁)]]: 91 --->
//│ 	case xx⁶ of {C a⁶ => (c₄ a⁶)}: 106
//│ [C [C (id7₀ [C [C (id1₀ p₁)]])]]: 140 --->
//│ 	case xx³ of {C a³ => (c₂ a³)}: 70
//│ [C [C (id7₁ [C [C (id1₁ p₁)]])]]: 94 --->
//│ 	case xx⁹ of {C a⁹ => (c₇ a⁹)}: 146
//│ [C [C [C (id7₀ [C [C (id1₀ p₁)]])]]]: 141 --->
//│ 	case xx⁷ of {C a⁷ => (c₁ a⁷)}: 112
//│ [C [C [C (id7₁ [C [C (id1₁ p₁)]])]]]: 95 --->
//│ 	case xx⁸ of {C a⁸ => (c₆ a⁸)}: 126
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (((id6₀ id4₀) c₀) ((id5₀ id2₀) (id3₀ p₀)))
//│ def c₀ = 
//│ 	(fun xx⁷ -> xx⁷)
//│ 	where
//│ 	def c₁ = 
//│ 		(fun xx³ -> xx³)
//│ 		where
//│ 		def c₂ = 
//│ 			(fun xx⁵ -> xx⁵)
//│ 			where
//│ 			def c₃ = 
//│ 				(fun xx² -> xx²)
//│ 				where
//│ 				def c₄ = 
//│ 					(fun xx⁴ -> xx⁴)
//│ 					where
//│ 					def c₅ = 
//│ 						(fun xx⁸ -> xx⁸)
//│ 						where
//│ 						def c₆ = 
//│ 							(fun xx⁹ -> xx⁹)
//│ 							where
//│ 							def c₇ = 
//│ 								(fun xx¹ -> xx¹)
//│ 								where
//│ 								def c₈ = 
//│ 									(fun xx⁶ -> xx⁶)
//│ def id2₀ = 
//│ 	(fun y¹ -> y¹)
//│ def id3₀ = 
//│ 	(fun z¹ -> z¹)
//│ def id4₀ = 
//│ 	(fun k³ -> k³)
//│ def id5₀ = 
//│ 	(fun j¹ -> j¹)
//│ def id6₀ = 
//│ 	(fun l¹ -> l¹)
//│ def p₀ = 
//│ 	let a⁷ = 	
//│ 		let a³ = 	
//│ 			let a⁵ = (id7₀ 
//│ 				let a² = 	
//│ 					let a⁴ = (id1₀ p₁)
//│ 					in (c₅ a⁴)
//│ 				in (c₄ a²))
//│ 			in (c₃ a⁵)
//│ 		in (c₂ a³)
//│ 	in (c₁ a⁷)
//│ 	where
//│ 	def id1₀ = 
//│ 		(fun x¹ -> (id₀ x¹))
//│ 		where
//│ 		def id₀ = 
//│ 			(fun k⁴ -> k⁴)
//│ 	def id7₀ = 
//│ 		(fun i¹ -> i¹)
//│ 	def p₁ = 
//│ 		let a⁸ = 	
//│ 			let a⁹ = 	
//│ 				let a¹ = (id7₁ 
//│ 					let a⁶ = 	
//│ 						let a⁴ = (id1₁ p₁)
//│ 						in (c₅ a⁴)
//│ 					in (c₄ a⁶))
//│ 				in (c₈ a¹)
//│ 			in (c₇ a⁹)
//│ 		in (c₆ a⁸)
//│ 		where
//│ 		def id1₁ = 
//│ 			(fun x² -> (id₁ x²))
//│ 			where
//│ 			def id₁ = 
//│ 				(fun k² -> k²)
//│ 		def id7₁ = 
//│ 			(fun i² -> i²)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
fun id(x) = if x is
  ID(b) then b
  C(a) then id(ID(C(a)))
let p = C(p)
fun c(y) = if y is
  C(aa) then c(aa)
c(id(p))
//│ |#fun| |id|(|x|)| |#=| |#if| |x| |is|→|ID|(|b|)| |#then| |b|↵|C|(|a|)| |#then| |id|(|ID|(|C|(|a|)|)|)|←|↵|#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |c|(|aa|)|←|↵|c|(|id|(|p|)|)|
//│ Parsed: {fun id = x, => if x is ‹(ID (b,)) then b; (C (a,)) then id (ID (C (a,),),)›; let p = C (p,); fun c = y, => if y is ‹(C (aa,)) then c (aa,)›; c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^18 (id^19 p^20))
//│ def c = (fun y⁰ -> case y⁰ of {
//│ 	C aa⁰ => (c^13 aa⁰)})
//│ def id = (fun x⁰ -> case x⁰ of {
//│ 	ID b⁰ => b⁰
//│ 	| C a⁰ => (id^3 [ID [C a⁰]])})
//│ def p = [C p^10]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^18]
//│ 	[c^18 · c^13] ---> [c^18] (only one)
//│ [id^19]
//│ 	[id^19 · id^3] (hopeless to continue)
//│ 		[id^19 · id^3 · id^3] ---> [id^19 · id^3] (using original def)
//│ [p^20]
//│ 	[p^20 · p^10]
//│ 		[p^20 · p^10 · p^10] ---> [p^20 · p^10] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ (id₀ p₀))
//│ def c₀ = 
//│ 	(fun y¹ -> case y¹ of {
//│ 		C aa¹ => (c₀ aa¹)})
//│ def id₀ = 
//│ 	(fun x² -> case x² of {
//│ 		ID b² => b²
//│ 		| C a² => (id₁ [ID [C a²]])})
//│ 	where
//│ 	def id₁ = 
//│ 		(fun x¹ -> case x¹ of {
//│ 			ID b¹ => b¹
//│ 			| C a¹ => (id₁ [ID [C a¹]])})
//│ def p₀ = 
//│ 	[C p₁]
//│ 	where
//│ 	def p₁ = 
//│ 		[C p₁]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a¹]: 29 --->
//│ 	case y¹ of {C aa¹ => (c₀ aa¹)}: 38
//│ [C a²]: 46 --->
//│ 	case y¹ of {C aa¹ => (c₀ aa¹)}: 38
//│ [C p₁]: 24 --->
//│ 	case y¹ of {C aa¹ => (c₀ aa¹)}: 38
//│ [C p₁]: 41 --->
//│ 	case x² of {ID b² => b² | C a² => (id₁ [ID [C a²]])}: 49
//│ [ID [C a¹]]: 30 --->
//│ 	case x¹ of {ID b¹ => b¹ | C a¹ => (id₁ [ID [C a¹]])}: 32
//│ [ID [C a²]]: 47 --->
//│ 	case x¹ of {ID b¹ => b¹ | C a¹ => (id₁ [ID [C a¹]])}: 32
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ (id₀ p₀))
//│ def c₀ = 
//│ 	(fun y¹ -> y¹)
//│ def id₀ = 
//│ 	(fun x² -> x²)
//│ 	where
//│ 	def id₁ = 
//│ 		(fun x¹ -> x¹)
//│ def p₀ = 
//│ 	let a² = p₁
//│ 	in (id₁ 
//│ 		let b¹ = 	
//│ 			let aa¹ = a²
//│ 			in (c₀ aa¹)
//│ 		in b¹)
//│ 	where
//│ 	def p₁ = 
//│ 		let aa¹ = p₁
//│ 		in (c₀ aa¹)
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: unlike the rev rev case, TODO: why?
fun map(ls) = if ls is
  C(h, t) then C(
    (if h is
      A then AA
      B then BB
    ),
    map(t)
  )
  N then N
fun len(ls) = if ls is
  C(h, t) then 1 + len(t)
  N then 0
len(map(C(A, C(B, N))))
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#fun| |len|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |1| |+| |len|(|t|)|↵|N| |#then| |0|←|↵|len|(|map|(|C|(|A|,| |C|(|B|,| |N|)|)|)|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(A) then AA; (B) then BB›, ')', map (t,),); (N) then N›; fun len = ls, => if ls is ‹(C (h, t,)) then + (1,) (len (t,),); (N) then 0›; len (map (C (A, C (B, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (len^24 (map^25 [C [A] [C [B] [N]]]))
//│ def len = (fun ls¹ -> case ls¹ of {
//│ 	C h¹ t¹ => (1 + (len^17 t¹))
//│ 	| N => 0})
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C case h⁰ of {
//│ 		A => [AA]
//│ 		| B => [BB]} (map^6 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [len^24]
//│ 	[len^24 · len^17] ---> [len^24] (only one)
//│ [map^25]
//│ 	[map^25 · map^6]
//│ 		[map^25 · map^6 · map^6] ---> [map^25 · map^6] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (len₀ (map₀ [C [A] [C [B] [N]]]))
//│ def len₀ = 
//│ 	(fun ls³ -> case ls³ of {
//│ 		C h³ t³ => (1 + (len₀ t³))
//│ 		| N => 0})
//│ def map₀ = 
//│ 	(fun ls⁴ -> case ls⁴ of {
//│ 		C h⁴ t⁴ => [C case h⁴ of {
//│ 			A => [AA]
//│ 			| B => [BB]} (map₁ t⁴)]
//│ 		| N => [N]})
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls² -> case ls² of {
//│ 			C h² t² => [C case h² of {
//│ 				A => [AA]
//│ 				| B => [BB]} (map₁ t²)]
//│ 			| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 70 --->
//│ 	case h⁴ of {A => [AA] | B => [BB]}: 60
//│ [B]: 71 --->
//│ 	case h² of {A => [AA] | B => [BB]}: 37
//│ [C [A] [C [B] [N]]]: 74 --->
//│ 	case ls⁴ of {C h⁴ t⁴ => [C case h⁴ of {A => [AA] | B => [BB]} (map₁ t⁴)] | N => [N]}: 66
//│ [C [B] [N]]: 73 --->
//│ 	case ls² of {C h² t² => [C case h² of {A => [AA] | B => [BB]} (map₁ t²)] | N => [N]}: 43
//│ [C case h⁴ of {A => [AA] | B => [BB]} (map₁ t⁴)]: 64 --->
//│ 	case ls³ of {C h³ t³ => (1 + (len₀ t³)) | N => 0}: 54
//│ [C case h² of {A => [AA] | B => [BB]} (map₁ t²)]: 41 --->
//│ 	case ls³ of {C h³ t³ => (1 + (len₀ t³)) | N => 0}: 54
//│ [N]: 65 --->
//│ 	case ls³ of {C h³ t³ => (1 + (len₀ t³)) | N => 0}: 54
//│ [N]: 72 --->
//│ 	case ls² of {C h² t² => [C case h² of {A => [AA] | B => [BB]} (map₁ t²)] | N => [N]}: 43
//│ [N]: 42 --->
//│ 	case ls³ of {C h³ t³ => (1 + (len₀ t³)) | N => 0}: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (len₀ (map₀ 
//│ 	let h⁴ = [AA]
//│ 	in let t⁴ = 	
//│ 		let h² = [BB]
//│ 		in let t² = 0
//│ 		in let h³ = h²
//│ 		in let t³ = (map₁ t²)
//│ 		in (1 + (len₀ t³))
//│ 	in let h³ = h⁴
//│ 	in let t³ = (map₁ t⁴)
//│ 	in (1 + (len₀ t³))))
//│ def len₀ = 
//│ 	(fun ls³ -> ls³)
//│ def map₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls² -> ls²)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: multiple match, but correct
fun f(x) = if x is
  C(a) then f
f(C(A))(C(B))(C(D))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |f|←|↵|f|(|C|(|A|)|)|(|C|(|B|)|)|(|C|(|D|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then f›; f (C (A,),) (C (B,),) (C (D,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (((f^5 [C [A]]) [C [B]]) [C [D]])
//│ def f = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => f^2})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^5] (hopeless to continue)
//│ 	[f^5 · f^2] ---> [f^5] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (((f₀ [C [A]]) [C [B]]) [C [D]])
//│ def f₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C a¹ => f₀})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 21 --->
//│ 	case x¹ of {C a¹ => f₀}: 17
//│ [C [B]]: 24 --->
//│ 	case x¹ of {C a¹ => f₀}: 17
//│ [C [D]]: 27 --->
//│ 	case x¹ of {C a¹ => f₀}: 17
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (((f₀ 
//│ 	let a¹ = [A]
//│ 	in f₀) 
//│ 	let a¹ = [B]
//│ 	in f₀) 
//│ 	let a¹ = [D]
//│ 	in f₀)
//│ def f₀ = 
//│ 	(fun x¹ -> x¹)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
let aa = T(N, t, t)
let t = T(K, aa, aa)
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |t|,| |t|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |aa|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, t, t,); let t = T (K, aa, aa,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^24 t^25)
//│ def aa = [T [N] t^2 t^3]
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^14 l⁰) (c^17 r⁰)]
//│ 	| L => [LL]})
//│ def t = [T [K] aa^6 aa^7]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^24]
//│ 	[c^24 · c^14]
//│ 		[c^24 · c^14 · c^14] ---> [c^24] (only one)
//│ 		[c^24 · c^14 · c^17] ---> [c^24] (only one)
//│ 	[c^24 · c^17]
//│ 		[c^24 · c^17 · c^14] ---> [c^24] (only one)
//│ 		[c^24 · c^17 · c^17] ---> [c^24] (only one)
//│ [t^25]
//│ 	[t^25 · aa^6]
//│ 		[t^25 · aa^6 · t^2]
//│ 			[t^25 · aa^6 · t^2 · aa^6] ---> [t^25 · aa^6] (only one)
//│ 			[t^25 · aa^6 · t^2 · aa^7] ---> [t^25 · aa^6] (only one)
//│ 		[t^25 · aa^6 · t^3]
//│ 			[t^25 · aa^6 · t^3 · aa^6] ---> [t^25 · aa^6] (only one)
//│ 			[t^25 · aa^6 · t^3 · aa^7] ---> [t^25 · aa^6] (only one)
//│ 	[t^25 · aa^7]
//│ 		[t^25 · aa^7 · t^2]
//│ 			[t^25 · aa^7 · t^2 · aa^6] ---> [t^25 · aa^7] (only one)
//│ 			[t^25 · aa^7 · t^2 · aa^7] ---> [t^25 · aa^7] (only one)
//│ 		[t^25 · aa^7 · t^3]
//│ 			[t^25 · aa^7 · t^3 · aa^6] ---> [t^25 · aa^7] (only one)
//│ 			[t^25 · aa^7 · t^3 · aa^7] ---> [t^25 · aa^7] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ t₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		T n¹ l¹ r¹ => [T case n¹ of {
//│ 			K => [KK]
//│ 			| N => [NN]} (c₁ l¹) (c₂ r¹)]
//│ 		| L => [LL]})
//│ 	where
//│ 	def c₁ = 
//│ 		(fun x² -> case x² of {
//│ 			T n² l² r² => [T case n² of {
//│ 				K => [KK]
//│ 				| N => [NN]} (c₀ l²) (c₀ r²)]
//│ 			| L => [LL]})
//│ 	def c₂ = 
//│ 		(fun x³ -> case x³ of {
//│ 			T n³ l³ r³ => [T case n³ of {
//│ 				K => [KK]
//│ 				| N => [NN]} (c₀ l³) (c₀ r³)]
//│ 			| L => [LL]})
//│ def t₀ = 
//│ 	[T [K] aa₀ aa₁]
//│ 	where
//│ 	def aa₀ = 
//│ 		[T [N] t₁ t₂]
//│ 		where
//│ 		def t₁ = 
//│ 			[T [K] aa₀ aa₀]
//│ 		def t₂ = 
//│ 			[T [K] aa₀ aa₀]
//│ 	def aa₁ = 
//│ 		[T [N] t₃ t₄]
//│ 		where
//│ 		def t₃ = 
//│ 			[T [K] aa₁ aa₁]
//│ 		def t₄ = 
//│ 			[T [K] aa₁ aa₁]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 54 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 39
//│ [K]: 58 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 39
//│ [K]: 27 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 39
//│ [K]: 62 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 39
//│ [K]: 31 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 39
//│ [N]: 81 --->
//│ 	case n² of {K => [KK] | N => [NN]}: 70
//│ 	case n³ of {K => [KK] | N => [NN]}: 89
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N]: 50 --->
//│ 	case n³ of {K => [KK] | N => [NN]}: 89
//│ 	case n² of {K => [KK] | N => [NN]}: 70
//│ 	 MORE THAN ONE MATCH EXPR
//│ [T [K] aa₀ aa₀]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₁ l¹) (c₂ r¹)] | L => [LL]}: 48
//│ [T [K] aa₀ aa₀]: 61 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₁ l¹) (c₂ r¹)] | L => [LL]}: 48
//│ [T [K] aa₀ aa₁]: 65 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₁ l¹) (c₂ r¹)] | L => [LL]}: 48
//│ [T [K] aa₁ aa₁]: 34 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₁ l¹) (c₂ r¹)] | L => [LL]}: 48
//│ [T [K] aa₁ aa₁]: 30 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₁ l¹) (c₂ r¹)] | L => [LL]}: 48
//│ [T [N] t₁ t₂]: 84 --->
//│ 	case x² of {T n² l² r² => [T case n² of {K => [KK] | N => [NN]} (c₀ l²) (c₀ r²)] | L => [LL]}: 79
//│ 	case x³ of {T n³ l³ r³ => [T case n³ of {K => [KK] | N => [NN]} (c₀ l³) (c₀ r³)] | L => [LL]}: 98
//│ 	 MORE THAN ONE MATCH EXPR
//│ [T [N] t₃ t₄]: 53 --->
//│ 	case x³ of {T n³ l³ r³ => [T case n³ of {K => [KK] | N => [NN]} (c₀ l³) (c₀ r³)] | L => [LL]}: 98
//│ 	case x² of {T n² l² r² => [T case n² of {K => [KK] | N => [NN]} (c₀ l²) (c₀ r²)] | L => [LL]}: 79
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ t₀)
//│ def c₀ = 
//│ 	(fun x¹ -> x¹)
//│ 	where
//│ 	def c₁ = 
//│ 		(fun x² -> x²)
//│ 	def c₂ = 
//│ 		(fun x³ -> x³)
//│ def t₀ = 
//│ 	let n¹ = [KK]
//│ 	in let l¹ = aa₀
//│ 	in let r¹ = aa₁
//│ 	in [T n¹ (c₁ l¹) (c₂ r¹)]
//│ 	where
//│ 	def aa₀ = 
//│ 		let n² = [NN]
//│ 		in let l² = t₁
//│ 		in let r² = t₂
//│ 		in [T n² (c₀ l²) (c₀ r²)]
//│ 		where
//│ 		def t₁ = 
//│ 			let n¹ = [KK]
//│ 			in let l¹ = aa₀
//│ 			in let r¹ = aa₀
//│ 			in [T n¹ (c₁ l¹) (c₂ r¹)]
//│ 		def t₂ = 
//│ 			let n¹ = [KK]
//│ 			in let l¹ = aa₀
//│ 			in let r¹ = aa₀
//│ 			in [T n¹ (c₁ l¹) (c₂ r¹)]
//│ 	def aa₁ = 
//│ 		let n³ = [NN]
//│ 		in let l³ = t₃
//│ 		in let r³ = t₄
//│ 		in [T n³ (c₀ l³) (c₀ r³)]
//│ 		where
//│ 		def t₃ = 
//│ 			let n¹ = [KK]
//│ 			in let l¹ = aa₁
//│ 			in let r¹ = aa₁
//│ 			in [T n¹ (c₁ l¹) (c₂ r¹)]
//│ 		def t₄ = 
//│ 			let n¹ = [KK]
//│ 			in let l¹ = aa₁
//│ 			in let r¹ = aa₁
//│ 			in [T n¹ (c₁ l¹) (c₂ r¹)]
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: but explode on branches
fun filter(ls) = if ls is
  C(h, t) then if h > 1 is
    True then C(h, filter(t))
    False then filter(t)
  N then N
filter(C(1, C(2, C(3, N))))
//│ |#fun| |filter|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |>| |1| |is|→|True| |#then| |C|(|h|,| |filter|(|t|)|)|↵|False| |#then| |filter|(|t|)|←|↵|N| |#then| |N|←|↵|filter|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {fun filter = ls, => if ls is ‹(C (h, t,)) then if > (h,) (1,) is ‹(True) then C (h, filter (t,),); (False) then filter (t,)›; (N) then N›; filter (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (filter^19 [C 1 [C 2 [C 3 [N]]]])
//│ def filter = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => case (h⁰ > 1) of {
//│ 		True => [C h⁰ (filter^8 t⁰)]
//│ 		| False => (filter^12 t⁰)}
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [filter^19]
//│ 	[filter^19 · filter^12]
//│ 		[filter^19 · filter^12 · filter^12]
//│ 			[filter^19 · filter^12 · filter^12 · filter^12]
//│ 				[filter^19 · filter^12 · filter^12 · filter^12 · filter^12] ---> [filter^19 · filter^12 · filter^12 · filter^12] (only one)
//│ 				[filter^19 · filter^12 · filter^12 · filter^12 · filter^8]
//│ 					[filter^19 · filter^12 · filter^12 · filter^12 · filter^8 · filter^12] ---> [filter^19 · filter^12 · filter^12 · filter^12 · filter^8] (only one)
//│ 					[filter^19 · filter^12 · filter^12 · filter^12 · filter^8 · filter^8] ---> [filter^19 · filter^12 · filter^12 · filter^12 · filter^8] (only one)
//│ 			[filter^19 · filter^12 · filter^12 · filter^8]
//│ 				[filter^19 · filter^12 · filter^12 · filter^8 · filter^12] ---> [filter^19 · filter^12 · filter^12 · filter^8] (only one)
//│ 				[filter^19 · filter^12 · filter^12 · filter^8 · filter^8] ---> [filter^19 · filter^12 · filter^12 · filter^8] (only one)
//│ 		[filter^19 · filter^12 · filter^8]
//│ 			[filter^19 · filter^12 · filter^8 · filter^12]
//│ 				[filter^19 · filter^12 · filter^8 · filter^12 · filter^12] ---> [filter^19 · filter^12 · filter^8 · filter^12] (only one)
//│ 				[filter^19 · filter^12 · filter^8 · filter^12 · filter^8] ---> [filter^19 · filter^12 · filter^8 · filter^12] (only one)
//│ 			[filter^19 · filter^12 · filter^8 · filter^8]
//│ 				[filter^19 · filter^12 · filter^8 · filter^8 · filter^12] ---> [filter^19 · filter^12 · filter^8 · filter^8] (only one)
//│ 				[filter^19 · filter^12 · filter^8 · filter^8 · filter^8] ---> [filter^19 · filter^12 · filter^8 · filter^8] (only one)
//│ 	[filter^19 · filter^8]
//│ 		[filter^19 · filter^8 · filter^12]
//│ 			[filter^19 · filter^8 · filter^12 · filter^12]
//│ 				[filter^19 · filter^8 · filter^12 · filter^12 · filter^12] ---> [filter^19 · filter^8 · filter^12 · filter^12] (only one)
//│ 				[filter^19 · filter^8 · filter^12 · filter^12 · filter^8] ---> [filter^19 · filter^8 · filter^12 · filter^12] (only one)
//│ 			[filter^19 · filter^8 · filter^12 · filter^8]
//│ 				[filter^19 · filter^8 · filter^12 · filter^8 · filter^12] ---> [filter^19 · filter^8 · filter^12 · filter^8] (only one)
//│ 				[filter^19 · filter^8 · filter^12 · filter^8 · filter^8] ---> [filter^19 · filter^8 · filter^12 · filter^8] (only one)
//│ 		[filter^19 · filter^8 · filter^8]
//│ 			[filter^19 · filter^8 · filter^8 · filter^12]
//│ 				[filter^19 · filter^8 · filter^8 · filter^12 · filter^12] ---> [filter^19 · filter^8 · filter^8 · filter^12] (only one)
//│ 				[filter^19 · filter^8 · filter^8 · filter^12 · filter^8] ---> [filter^19 · filter^8 · filter^8 · filter^12] (only one)
//│ 			[filter^19 · filter^8 · filter^8 · filter^8]
//│ 				[filter^19 · filter^8 · filter^8 · filter^8 · filter^12] ---> [filter^19 · filter^8 · filter^8 · filter^8] (only one)
//│ 				[filter^19 · filter^8 · filter^8 · filter^8 · filter^8] ---> [filter^19 · filter^8 · filter^8 · filter^8] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (filter₀ [C 1 [C 2 [C 3 [N]]]])
//│ def filter₀ = 
//│ 	(fun ls⁴ -> case ls⁴ of {
//│ 		C h⁴ t⁴ => case (h⁴ > 1) of {
//│ 			True => [C h⁴ (filter₉ t⁴)]
//│ 			| False => (filter₁ t⁴)}
//│ 		| N => [N]})
//│ 	where
//│ 	def filter₁ = 
//│ 		(fun ls⁵ -> case ls⁵ of {
//│ 			C h⁵ t⁵ => case (h⁵ > 1) of {
//│ 				True => [C h⁵ (filter₆ t⁵)]
//│ 				| False => (filter₂ t⁵)}
//│ 			| N => [N]})
//│ 		where
//│ 		def filter₂ = 
//│ 			(fun ls¹⁶ -> case ls¹⁶ of {
//│ 				C h¹⁶ t¹⁶ => case (h¹⁶ > 1) of {
//│ 					True => [C h¹⁶ (filter₅ t¹⁶)]
//│ 					| False => (filter₃ t¹⁶)}
//│ 				| N => [N]})
//│ 			where
//│ 			def filter₃ = 
//│ 				(fun ls¹⁰ -> case ls¹⁰ of {
//│ 					C h¹⁰ t¹⁰ => case (h¹⁰ > 1) of {
//│ 						True => [C h¹⁰ (filter₄ t¹⁰)]
//│ 						| False => (filter₃ t¹⁰)}
//│ 					| N => [N]})
//│ 				where
//│ 				def filter₄ = 
//│ 					(fun ls¹ -> case ls¹ of {
//│ 						C h¹ t¹ => case (h¹ > 1) of {
//│ 							True => [C h¹ (filter₄ t¹)]
//│ 							| False => (filter₄ t¹)}
//│ 						| N => [N]})
//│ 			def filter₅ = 
//│ 				(fun ls⁹ -> case ls⁹ of {
//│ 					C h⁹ t⁹ => case (h⁹ > 1) of {
//│ 						True => [C h⁹ (filter₅ t⁹)]
//│ 						| False => (filter₅ t⁹)}
//│ 					| N => [N]})
//│ 		def filter₆ = 
//│ 			(fun ls⁸ -> case ls⁸ of {
//│ 				C h⁸ t⁸ => case (h⁸ > 1) of {
//│ 					True => [C h⁸ (filter₈ t⁸)]
//│ 					| False => (filter₇ t⁸)}
//│ 				| N => [N]})
//│ 			where
//│ 			def filter₇ = 
//│ 				(fun ls¹³ -> case ls¹³ of {
//│ 					C h¹³ t¹³ => case (h¹³ > 1) of {
//│ 						True => [C h¹³ (filter₇ t¹³)]
//│ 						| False => (filter₇ t¹³)}
//│ 					| N => [N]})
//│ 			def filter₈ = 
//│ 				(fun ls¹⁵ -> case ls¹⁵ of {
//│ 					C h¹⁵ t¹⁵ => case (h¹⁵ > 1) of {
//│ 						True => [C h¹⁵ (filter₈ t¹⁵)]
//│ 						| False => (filter₈ t¹⁵)}
//│ 					| N => [N]})
//│ 	def filter₉ = 
//│ 		(fun ls¹² -> case ls¹² of {
//│ 			C h¹² t¹² => case (h¹² > 1) of {
//│ 				True => [C h¹² (filter₁₃ t¹²)]
//│ 				| False => (filter₁₀ t¹²)}
//│ 			| N => [N]})
//│ 		where
//│ 		def filter₁₀ = 
//│ 			(fun ls⁶ -> case ls⁶ of {
//│ 				C h⁶ t⁶ => case (h⁶ > 1) of {
//│ 					True => [C h⁶ (filter₁₂ t⁶)]
//│ 					| False => (filter₁₁ t⁶)}
//│ 				| N => [N]})
//│ 			where
//│ 			def filter₁₁ = 
//│ 				(fun ls¹¹ -> case ls¹¹ of {
//│ 					C h¹¹ t¹¹ => case (h¹¹ > 1) of {
//│ 						True => [C h¹¹ (filter₁₁ t¹¹)]
//│ 						| False => (filter₁₁ t¹¹)}
//│ 					| N => [N]})
//│ 			def filter₁₂ = 
//│ 				(fun ls³ -> case ls³ of {
//│ 					C h³ t³ => case (h³ > 1) of {
//│ 						True => [C h³ (filter₁₂ t³)]
//│ 						| False => (filter₁₂ t³)}
//│ 					| N => [N]})
//│ 		def filter₁₃ = 
//│ 			(fun ls¹⁴ -> case ls¹⁴ of {
//│ 				C h¹⁴ t¹⁴ => case (h¹⁴ > 1) of {
//│ 					True => [C h¹⁴ (filter₁₅ t¹⁴)]
//│ 					| False => (filter₁₄ t¹⁴)}
//│ 				| N => [N]})
//│ 			where
//│ 			def filter₁₄ = 
//│ 				(fun ls⁷ -> case ls⁷ of {
//│ 					C h⁷ t⁷ => case (h⁷ > 1) of {
//│ 						True => [C h⁷ (filter₁₄ t⁷)]
//│ 						| False => (filter₁₄ t⁷)}
//│ 					| N => [N]})
//│ 			def filter₁₅ = 
//│ 				(fun ls² -> case ls² of {
//│ 					C h² t² => case (h² > 1) of {
//│ 						True => [C h² (filter₁₅ t²)]
//│ 						| False => (filter₁₅ t²)}
//│ 					| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [C 3 [N]]]]: 323 --->
//│ 	case ls⁴ of {C h⁴ t⁴ => case (h⁴ > 1) of {True => [C h⁴ (filter₉ t⁴)] | False => (filter₁ t⁴)} | N => [N]}: 98
//│ [C 2 [C 3 [N]]]: 322 --->
//│ 	case ls¹² of {C h¹² t¹² => case (h¹² > 1) of {True => [C h¹² (filter₁₃ t¹²)] | False => (filter₁₀ t¹²)} | N => [N]}: 242
//│ 	case ls⁵ of {C h⁵ t⁵ => case (h⁵ > 1) of {True => [C h⁵ (filter₆ t⁵)] | False => (filter₂ t⁵)} | N => [N]}: 116
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C 3 [N]]: 321 --->
//│ 	case ls⁶ of {C h⁶ t⁶ => case (h⁶ > 1) of {True => [C h⁶ (filter₁₂ t⁶)] | False => (filter₁₁ t⁶)} | N => [N]}: 134
//│ 	case ls¹⁴ of {C h¹⁴ t¹⁴ => case (h¹⁴ > 1) of {True => [C h¹⁴ (filter₁₅ t¹⁴)] | False => (filter₁₄ t¹⁴)} | N => [N]}: 278
//│ 	case ls¹⁶ of {C h¹⁶ t¹⁶ => case (h¹⁶ > 1) of {True => [C h¹⁶ (filter₅ t¹⁶)] | False => (filter₃ t¹⁶)} | N => [N]}: 314
//│ 	case ls⁸ of {C h⁸ t⁸ => case (h⁸ > 1) of {True => [C h⁸ (filter₈ t⁸)] | False => (filter₇ t⁸)} | N => [N]}: 170
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N]: 320 --->
//│ 	case ls¹¹ of {C h¹¹ t¹¹ => case (h¹¹ > 1) of {True => [C h¹¹ (filter₁₁ t¹¹)] | False => (filter₁₁ t¹¹)} | N => [N]}: 224
//│ 	case ls³ of {C h³ t³ => case (h³ > 1) of {True => [C h³ (filter₁₂ t³)] | False => (filter₁₂ t³)} | N => [N]}: 80
//│ 	case ls⁷ of {C h⁷ t⁷ => case (h⁷ > 1) of {True => [C h⁷ (filter₁₄ t⁷)] | False => (filter₁₄ t⁷)} | N => [N]}: 152
//│ 	case ls² of {C h² t² => case (h² > 1) of {True => [C h² (filter₁₅ t²)] | False => (filter₁₅ t²)} | N => [N]}: 62
//│ 	case ls¹⁰ of {C h¹⁰ t¹⁰ => case (h¹⁰ > 1) of {True => [C h¹⁰ (filter₄ t¹⁰)] | False => (filter₃ t¹⁰)} | N => [N]}: 206
//│ 	case ls⁹ of {C h⁹ t⁹ => case (h⁹ > 1) of {True => [C h⁹ (filter₅ t⁹)] | False => (filter₅ t⁹)} | N => [N]}: 188
//│ 	case ls¹³ of {C h¹³ t¹³ => case (h¹³ > 1) of {True => [C h¹³ (filter₇ t¹³)] | False => (filter₇ t¹³)} | N => [N]}: 260
//│ 	case ls¹⁵ of {C h¹⁵ t¹⁵ => case (h¹⁵ > 1) of {True => [C h¹⁵ (filter₈ t¹⁵)] | False => (filter₈ t¹⁵)} | N => [N]}: 296
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (filter₀ 
//│ 	let h⁴ = 1
//│ 	in let t⁴ = 	
//│ 		let h¹² = 2
//│ 		in let t¹² = 	
//│ 			let h⁶ = 3
//│ 			in let t⁶ = [N]
//│ 			in case (h⁶ > 1) of {
//│ 				True => [C h⁶ (filter₁₂ t⁶)]
//│ 				| False => (filter₁₁ t⁶)}
//│ 		in case (h¹² > 1) of {
//│ 			True => [C h¹² (filter₁₃ t¹²)]
//│ 			| False => (filter₁₀ t¹²)}
//│ 	in case (h⁴ > 1) of {
//│ 		True => [C h⁴ (filter₉ t⁴)]
//│ 		| False => (filter₁ t⁴)})
//│ def filter₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ 	where
//│ 	def filter₁ = 
//│ 		(fun ls⁵ -> case ls⁵ of {
//│ 			C h⁵ t⁵ => case (h⁵ > 1) of {
//│ 				True => [C h⁵ (filter₆ t⁵)]
//│ 				| False => (filter₂ t⁵)}
//│ 			| N => [N]})
//│ 		where
//│ 		def filter₂ = 
//│ 			(fun ls¹⁶ -> case ls¹⁶ of {
//│ 				C h¹⁶ t¹⁶ => case (h¹⁶ > 1) of {
//│ 					True => [C h¹⁶ (filter₅ t¹⁶)]
//│ 					| False => (filter₃ t¹⁶)}
//│ 				| N => [N]})
//│ 			where
//│ 			def filter₃ = 
//│ 				(fun ls¹⁰ -> case ls¹⁰ of {
//│ 					C h¹⁰ t¹⁰ => case (h¹⁰ > 1) of {
//│ 						True => [C h¹⁰ (filter₄ t¹⁰)]
//│ 						| False => (filter₃ t¹⁰)}
//│ 					| N => [N]})
//│ 				where
//│ 				def filter₄ = 
//│ 					(fun ls¹ -> case ls¹ of {
//│ 						C h¹ t¹ => case (h¹ > 1) of {
//│ 							True => [C h¹ (filter₄ t¹)]
//│ 							| False => (filter₄ t¹)}
//│ 						| N => [N]})
//│ 			def filter₅ = 
//│ 				(fun ls⁹ -> case ls⁹ of {
//│ 					C h⁹ t⁹ => case (h⁹ > 1) of {
//│ 						True => [C h⁹ (filter₅ t⁹)]
//│ 						| False => (filter₅ t⁹)}
//│ 					| N => [N]})
//│ 		def filter₆ = 
//│ 			(fun ls⁸ -> case ls⁸ of {
//│ 				C h⁸ t⁸ => case (h⁸ > 1) of {
//│ 					True => [C h⁸ (filter₈ t⁸)]
//│ 					| False => (filter₇ t⁸)}
//│ 				| N => [N]})
//│ 			where
//│ 			def filter₇ = 
//│ 				(fun ls¹³ -> case ls¹³ of {
//│ 					C h¹³ t¹³ => case (h¹³ > 1) of {
//│ 						True => [C h¹³ (filter₇ t¹³)]
//│ 						| False => (filter₇ t¹³)}
//│ 					| N => [N]})
//│ 			def filter₈ = 
//│ 				(fun ls¹⁵ -> case ls¹⁵ of {
//│ 					C h¹⁵ t¹⁵ => case (h¹⁵ > 1) of {
//│ 						True => [C h¹⁵ (filter₈ t¹⁵)]
//│ 						| False => (filter₈ t¹⁵)}
//│ 					| N => [N]})
//│ 	def filter₉ = 
//│ 		(fun ls¹² -> ls¹²)
//│ 		where
//│ 		def filter₁₀ = 
//│ 			(fun ls⁶ -> ls⁶)
//│ 			where
//│ 			def filter₁₁ = 
//│ 				(fun ls¹¹ -> case ls¹¹ of {
//│ 					C h¹¹ t¹¹ => case (h¹¹ > 1) of {
//│ 						True => [C h¹¹ (filter₁₁ t¹¹)]
//│ 						| False => (filter₁₁ t¹¹)}
//│ 					| N => [N]})
//│ 			def filter₁₂ = 
//│ 				(fun ls³ -> case ls³ of {
//│ 					C h³ t³ => case (h³ > 1) of {
//│ 						True => [C h³ (filter₁₂ t³)]
//│ 						| False => (filter₁₂ t³)}
//│ 					| N => [N]})
//│ 		def filter₁₃ = 
//│ 			(fun ls¹⁴ -> case ls¹⁴ of {
//│ 				C h¹⁴ t¹⁴ => case (h¹⁴ > 1) of {
//│ 					True => [C h¹⁴ (filter₁₅ t¹⁴)]
//│ 					| False => (filter₁₄ t¹⁴)}
//│ 				| N => [N]})
//│ 			where
//│ 			def filter₁₄ = 
//│ 				(fun ls⁷ -> ls⁷)
//│ 			def filter₁₅ = 
//│ 				(fun ls² -> case ls² of {
//│ 					C h² t² => case (h² > 1) of {
//│ 						True => [C h² (filter₁₅ t²)]
//│ 						| False => (filter₁₅ t²)}
//│ 					| N => [N]})
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: top level defs used multiple times are fine
// but top level producers used multiple times may result in duplicated computation
let p = C(p)
let pp = C(C(pp))
fun c(x) = if x is
  C(a) then if a is
    C(b) then c(b)
    N then a
  N then x
P(c(pp), c(p))
//│ |#let| |p| |#=| |C|(|p|)|↵|#let| |pp| |#=| |C|(|C|(|pp|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |c|(|b|)|↵|N| |#then| |a|←|↵|N| |#then| |x|←|↵|P|(|c|(|pp|)|,| |c|(|p|)|)|
//│ Parsed: {let p = C (p,); let pp = C (C (pp,),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then c (b,); (N) then a›; (N) then x›; P (c (pp,), c (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ [P (c^16 pp^17) (c^19 p^20)]
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => (c^8 b⁰)
//│ 		| N => a⁰}
//│ 	| N => x⁰})
//│ def p = [C p^1]
//│ def pp = [C [C pp^3]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^16]
//│ 	[c^16 · c^8] ---> [c^16] (only one)
//│ [c^19]
//│ 	[c^19 · c^8] ---> [c^19] (only one)
//│ [p^20]
//│ 	[p^20 · p^1]
//│ 		[p^20 · p^1 · p^1] ---> [p^20] (only one)
//│ [pp^17]
//│ 	[pp^17 · pp^3] ---> [pp^17] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ [P (c₀ pp₀) (c₁ p₀)]
//│ def c₀ = 
//│ 	(fun x² -> case x² of {
//│ 		C a² => case a² of {
//│ 			C b² => (c₀ b²)
//│ 			| N => a²}
//│ 		| N => x²})
//│ def c₁ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C a¹ => case a¹ of {
//│ 			C b¹ => (c₁ b¹)
//│ 			| N => a¹}
//│ 		| N => x¹})
//│ def p₀ = 
//│ 	[C p₁]
//│ 	where
//│ 	def p₁ = 
//│ 		[C p₀]
//│ def pp₀ = 
//│ 	[C [C pp₀]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [C pp₀]]: 25 --->
//│ 	case x² of {C a² => case a² of {C b² => (c₀ b²) | N => a²} | N => x²}: 48
//│ [C pp₀]: 24 --->
//│ 	case a² of {C b² => (c₀ b²) | N => a²}: 46
//│ [C p₀]: 37 --->
//│ 	case a¹ of {C b¹ => (c₁ b¹) | N => a¹}: 32
//│ [C p₁]: 39 --->
//│ 	case x¹ of {C a¹ => case a¹ of {C b¹ => (c₁ b¹) | N => a¹} | N => x¹}: 34
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ [P (c₀ pp₀) (c₁ p₀)]
//│ def c₀ = 
//│ 	(fun x² -> x²)
//│ def c₁ = 
//│ 	(fun x¹ -> x¹)
//│ def p₀ = 
//│ 	let a¹ = p₁
//│ 	in a¹
//│ 	where
//│ 	def p₁ = 
//│ 		let b¹ = p₀
//│ 		in (c₁ b¹)
//│ def pp₀ = 
//│ 	let a² = 	
//│ 		let b² = pp₀
//│ 		in (c₀ b²)
//│ 	in a²
//│ <<<<<<< after fusion <<<<<<<


// CORRECT:
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  N then a => a
  C(h, t) then a => rev(t, C(h, a))
fun rev2(ls2) = if ls2 is
  N then a2 => a2
  C(h2, t2) then a2 => rev2(t2, C(h2, a2))
rev2(rev(C(1, C(2, N)))(N))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a| |=>| |a|↵|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|,| |C|(|h|,| |a|)|)|←|↵|#fun| |rev2|(|ls2|)| |#=| |#if| |ls2| |is|→|N| |#then| |a2| |=>| |a2|↵|C|(|h2|,| |t2|)| |#then| |a2| |=>| |rev2|(|t2|,| |C|(|h2|,| |a2|)|)|←|↵|rev2|(|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|N|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(N) then a, => a; (C (h, t,)) then a, => rev (t, C (h, a,),)›; fun rev2 = ls2, => if ls2 is ‹(N) then a2, => a2; (C (h2, t2,)) then a2, => rev2 (t2, C (h2, a2,),)›; rev2 (rev (C (1, C (2, N,),),) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev2^27 ((rev^28 [C 1 [C 2 [N]]]) [N])) [N])
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	N => (fun a⁰ -> a⁰)
//│ 	| C h⁰ t⁰ => (fun a¹ -> ((rev^4 t⁰) [C h⁰ a¹]))})
//│ def rev2 = (fun ls2⁰ -> case ls2⁰ of {
//│ 	N => (fun a2⁰ -> a2⁰)
//│ 	| C h2⁰ t2⁰ => (fun a2¹ -> ((rev2^17 t2⁰) [C h2⁰ a2¹]))})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev2^27]
//│ 	[rev2^27 · rev2^17] ---> [rev2^27] (only one)
//│ [rev^28]
//│ 	[rev^28 · rev^4]
//│ 		[rev^28 · rev^4 · rev^4]
//│ 			[rev^28 · rev^4 · rev^4 · rev^4] ---> [rev^28 · rev^4 · rev^4] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev2₀ ((rev₀ [C 1 [C 2 [N]]]) [N])) [N])
//│ def rev2₀ = 
//│ 	(fun ls2¹ -> case ls2¹ of {
//│ 		N => (fun a2² -> a2²)
//│ 		| C h2¹ t2¹ => (fun a2³ -> ((rev2₀ t2¹) [C h2¹ a2³]))})
//│ def rev₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		N => (fun a² -> a²)
//│ 		| C h¹ t¹ => (fun a³ -> ((rev₁ t¹) [C h¹ a³]))})
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun ls³ -> case ls³ of {
//│ 			N => (fun a⁶ -> a⁶)
//│ 			| C h³ t³ => (fun a⁷ -> ((rev₂ t³) [C h³ a⁷]))})
//│ 		where
//│ 		def rev₂ = 
//│ 			(fun ls² -> case ls² of {
//│ 				N => (fun a⁴ -> a⁴)
//│ 				| C h² t² => (fun a⁵ -> ((rev₂ t²) [C h² a⁵]))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]]: 98 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₁ t¹) [C h¹ a³]))}: 64
//│ [C 2 [N]]: 97 --->
//│ 	case ls³ of {N => (fun a⁶ -> a⁶) | C h³ t³ => (fun a⁷ -> ((rev₂ t³) [C h³ a⁷]))}: 90
//│ [C h³ a⁷]: 87 --->
//│ 	case ls2¹ of {N => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> ((rev2₀ t2¹) [C h2¹ a2³]))}: 51
//│ [C h² a⁵]: 74 --->
//│ 	case ls2¹ of {N => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> ((rev2₀ t2¹) [C h2¹ a2³]))}: 51
//│ [C h¹ a³]: 61 --->
//│ 	case ls2¹ of {N => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> ((rev2₀ t2¹) [C h2¹ a2³]))}: 51
//│ [N]: 96 --->
//│ 	case ls² of {N => (fun a⁴ -> a⁴) | C h² t² => (fun a⁵ -> ((rev₂ t²) [C h² a⁵]))}: 77
//│ [N]: 100 --->
//│ 	case ls2¹ of {N => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> ((rev2₀ t2¹) [C h2¹ a2³]))}: 51
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev2₀ ((rev₀ 
//│ 	let h¹ = 1
//│ 	in let t¹ = 	
//│ 		let h³ = 2
//│ 		in let t³ = (fun a⁴ -> a⁴)
//│ 		in (fun a⁷ -> ((rev₂ t³) 
//│ 			let h2¹ = h³
//│ 			in let t2¹ = a⁷
//│ 			in (fun a2³ -> ((rev2₀ t2¹) [C h2¹ a2³]))))
//│ 	in (fun a³ -> ((rev₁ t¹) 
//│ 		let h2¹ = h¹
//│ 		in let t2¹ = a³
//│ 		in (fun a2³ -> ((rev2₀ t2¹) [C h2¹ a2³]))))) (fun a2² -> a2²))) [N])
//│ def rev2₀ = 
//│ 	(fun ls2¹ -> ls2¹)
//│ def rev₀ = 
//│ 	(fun ls¹ -> ls¹)
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun ls³ -> ls³)
//│ 		where
//│ 		def rev₂ = 
//│ 			(fun ls² -> ls²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [N]]]
//│ <<<<<<< evaluate <<<<<<<


// CORRECT: rev actually works (despite the fact that there are some match clash),
// and duplicated usage of toplevel things are alright
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
rev(C(A, C(B, N)))(N)
rev(rev(C(A, C(B, N)))(N))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|rev|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|N|)|↵|rev|(|rev|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|N|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; rev (C (A, C (B, N,),),) (N,); rev (rev (C (A, C (B, N,),),) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev^14 [C [A] [C [B] [N]]]) [N])
//│ ((rev^23 ((rev^24 [C [A] [C [B] [N]]]) [N])) [N])
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> ((rev^2 t⁰) [C h⁰ a⁰]))
//│ 	| N => (fun a¹ -> a¹)})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14]
//│ 	[rev^14 · rev^2]
//│ 		[rev^14 · rev^2 · rev^2]
//│ 			[rev^14 · rev^2 · rev^2 · rev^2] ---> [rev^14 · rev^2 · rev^2] (only one)
//│ [rev^23]
//│ 	[rev^23 · rev^2]
//│ 		[rev^23 · rev^2 · rev^2] ---> [rev^23 · rev^2] (only one)
//│ [rev^24]
//│ 	[rev^24 · rev^2]
//│ 		[rev^24 · rev^2 · rev^2]
//│ 			[rev^24 · rev^2 · rev^2 · rev^2] ---> [rev^24 · rev^2 · rev^2] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev₀ [C [A] [C [B] [N]]]) [N])
//│ ((rev₃ ((rev₅ [C [A] [C [B] [N]]]) [N])) [N])
//│ def rev₀ = 
//│ 	(fun ls⁶ -> case ls⁶ of {
//│ 		C h⁶ t⁶ => (fun a¹² -> ((rev₁ t⁶) [C h⁶ a¹²]))
//│ 		| N => (fun a¹³ -> a¹³)})
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun ls⁵ -> case ls⁵ of {
//│ 			C h⁵ t⁵ => (fun a¹⁰ -> ((rev₂ t⁵) [C h⁵ a¹⁰]))
//│ 			| N => (fun a¹¹ -> a¹¹)})
//│ 		where
//│ 		def rev₂ = 
//│ 			(fun ls² -> case ls² of {
//│ 				C h² t² => (fun a⁴ -> ((rev₂ t²) [C h² a⁴]))
//│ 				| N => (fun a⁵ -> a⁵)})
//│ def rev₃ = 
//│ 	(fun ls⁸ -> case ls⁸ of {
//│ 		C h⁸ t⁸ => (fun a¹⁶ -> ((rev₄ t⁸) [C h⁸ a¹⁶]))
//│ 		| N => (fun a¹⁷ -> a¹⁷)})
//│ 	where
//│ 	def rev₄ = 
//│ 		(fun ls³ -> case ls³ of {
//│ 			C h³ t³ => (fun a⁶ -> ((rev₄ t³) [C h³ a⁶]))
//│ 			| N => (fun a⁷ -> a⁷)})
//│ def rev₅ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => (fun a² -> ((rev₆ t¹) [C h¹ a²]))
//│ 		| N => (fun a³ -> a³)})
//│ 	where
//│ 	def rev₆ = 
//│ 		(fun ls⁷ -> case ls⁷ of {
//│ 			C h⁷ t⁷ => (fun a¹⁴ -> ((rev₇ t⁷) [C h⁷ a¹⁴]))
//│ 			| N => (fun a¹⁵ -> a¹⁵)})
//│ 		where
//│ 		def rev₇ = 
//│ 			(fun ls⁴ -> case ls⁴ of {
//│ 				C h⁴ t⁴ => (fun a⁸ -> ((rev₇ t⁴) [C h⁴ a⁸]))
//│ 				| N => (fun a⁹ -> a⁹)})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A] [C [B] [N]]]: 145 --->
//│ 	case ls⁶ of {C h⁶ t⁶ => (fun a¹² -> ((rev₁ t⁶) [C h⁶ a¹²])) | N => (fun a¹³ -> a¹³)}: 112
//│ [C [A] [C [B] [N]]]: 155 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₆ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 47
//│ [C [B] [N]]: 144 --->
//│ 	case ls⁵ of {C h⁵ t⁵ => (fun a¹⁰ -> ((rev₂ t⁵) [C h⁵ a¹⁰])) | N => (fun a¹¹ -> a¹¹)}: 99
//│ [C [B] [N]]: 154 --->
//│ 	case ls⁷ of {C h⁷ t⁷ => (fun a¹⁴ -> ((rev₇ t⁷) [C h⁷ a¹⁴])) | N => (fun a¹⁵ -> a¹⁵)}: 125
//│ [C h⁴ a⁸]: 81 --->
//│ 	case ls⁸ of {C h⁸ t⁸ => (fun a¹⁶ -> ((rev₄ t⁸) [C h⁸ a¹⁶])) | N => (fun a¹⁷ -> a¹⁷)}: 138
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> ((rev₄ t³) [C h³ a⁶])) | N => (fun a⁷ -> a⁷)}: 73
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C h⁷ a¹⁴]: 120 --->
//│ 	case ls⁸ of {C h⁸ t⁸ => (fun a¹⁶ -> ((rev₄ t⁸) [C h⁸ a¹⁶])) | N => (fun a¹⁷ -> a¹⁷)}: 138
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> ((rev₄ t³) [C h³ a⁶])) | N => (fun a⁷ -> a⁷)}: 73
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C h¹ a²]: 42 --->
//│ 	case ls⁸ of {C h⁸ t⁸ => (fun a¹⁶ -> ((rev₄ t⁸) [C h⁸ a¹⁶])) | N => (fun a¹⁷ -> a¹⁷)}: 138
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> ((rev₄ t³) [C h³ a⁶])) | N => (fun a⁷ -> a⁷)}: 73
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N]: 153 --->
//│ 	case ls⁴ of {C h⁴ t⁴ => (fun a⁸ -> ((rev₇ t⁴) [C h⁴ a⁸])) | N => (fun a⁹ -> a⁹)}: 86
//│ [N]: 157 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> ((rev₄ t³) [C h³ a⁶])) | N => (fun a⁷ -> a⁷)}: 73
//│ 	case ls⁸ of {C h⁸ t⁸ => (fun a¹⁶ -> ((rev₄ t⁸) [C h⁸ a¹⁶])) | N => (fun a¹⁷ -> a¹⁷)}: 138
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N]: 143 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> ((rev₂ t²) [C h² a⁴])) | N => (fun a⁵ -> a⁵)}: 60
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev₀ 
//│ 	let h⁶ = [A]
//│ 	in let t⁶ = 	
//│ 		let h⁵ = [B]
//│ 		in let t⁵ = (fun a⁵ -> a⁵)
//│ 		in (fun a¹⁰ -> ((rev₂ t⁵) [C h⁵ a¹⁰]))
//│ 	in (fun a¹² -> ((rev₁ t⁶) [C h⁶ a¹²]))) [N])
//│ ((rev₃ ((rev₅ 
//│ 	let h¹ = [A]
//│ 	in let t¹ = 	
//│ 		let h⁷ = [B]
//│ 		in let t⁷ = (fun a⁹ -> a⁹)
//│ 		in (fun a¹⁴ -> ((rev₇ t⁷) 
//│ 			let h⁸ = h⁷
//│ 			in let t⁸ = a¹⁴
//│ 			in (fun a¹⁶ -> ((rev₄ t⁸) [C h⁸ a¹⁶]))))
//│ 	in (fun a² -> ((rev₆ t¹) 
//│ 		let h⁸ = h¹
//│ 		in let t⁸ = a²
//│ 		in (fun a¹⁶ -> ((rev₄ t⁸) [C h⁸ a¹⁶]))))) (fun a⁷ -> a⁷))) [N])
//│ def rev₀ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun ls⁵ -> ls⁵)
//│ 		where
//│ 		def rev₂ = 
//│ 			(fun ls² -> ls²)
//│ def rev₃ = 
//│ 	(fun ls⁸ -> ls⁸)
//│ 	where
//│ 	def rev₄ = 
//│ 		(fun ls³ -> ls³)
//│ def rev₅ = 
//│ 	(fun ls¹ -> ls¹)
//│ 	where
//│ 	def rev₆ = 
//│ 		(fun ls⁷ -> ls⁷)
//│ 		where
//│ 		def rev₇ = 
//│ 			(fun ls⁴ -> ls⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [B] [C [A] [N]]]
//│ [C [A] [C [B] [N]]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT: using primitive is also correct
fun rev(ls) = if ls is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
rev(rev(primitive)(N))(N)
//│ |#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|rev|(|rev|(|primitive|)|(|N|)|)|(|N|)|
//│ Parsed: {fun rev = ls, => if ls is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; rev (rev (primitive,) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev^14 ((rev^15 primitive⁰) [N])) [N])
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> ((rev^2 t⁰) [C h⁰ a⁰]))
//│ 	| N => (fun a¹ -> a¹)})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14]
//│ 	[rev^14 · rev^2]
//│ 		[rev^14 · rev^2 · rev^2] ---> [rev^14 · rev^2] (only one)
//│ [rev^15]
//│ 	[rev^15 · rev^2]
//│ 		[rev^15 · rev^2 · rev^2] ---> [rev^15 · rev^2] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev₀ ((rev₂ primitive⁰) [N])) [N])
//│ def rev₀ = 
//│ 	(fun ls⁴ -> case ls⁴ of {
//│ 		C h⁴ t⁴ => (fun a⁸ -> ((rev₁ t⁴) [C h⁴ a⁸]))
//│ 		| N => (fun a⁹ -> a⁹)})
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun ls³ -> case ls³ of {
//│ 			C h³ t³ => (fun a⁶ -> ((rev₁ t³) [C h³ a⁶]))
//│ 			| N => (fun a⁷ -> a⁷)})
//│ def rev₂ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => (fun a² -> ((rev₃ t¹) [C h¹ a²]))
//│ 		| N => (fun a³ -> a³)})
//│ 	where
//│ 	def rev₃ = 
//│ 		(fun ls² -> case ls² of {
//│ 			C h² t² => (fun a⁴ -> ((rev₃ t²) [C h² a⁴]))
//│ 			| N => (fun a⁵ -> a⁵)})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h² a⁴]: 42 --->
//│ 	case ls⁴ of {C h⁴ t⁴ => (fun a⁸ -> ((rev₁ t⁴) [C h⁴ a⁸])) | N => (fun a⁹ -> a⁹)}: 73
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> ((rev₁ t³) [C h³ a⁶])) | N => (fun a⁷ -> a⁷)}: 60
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C h¹ a²]: 29 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> ((rev₁ t³) [C h³ a⁶])) | N => (fun a⁷ -> a⁷)}: 60
//│ 	case ls⁴ of {C h⁴ t⁴ => (fun a⁸ -> ((rev₁ t⁴) [C h⁴ a⁸])) | N => (fun a⁹ -> a⁹)}: 73
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N]: 79 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> ((rev₁ t³) [C h³ a⁶])) | N => (fun a⁷ -> a⁷)}: 60
//│ 	case ls⁴ of {C h⁴ t⁴ => (fun a⁸ -> ((rev₁ t⁴) [C h⁴ a⁸])) | N => (fun a⁹ -> a⁹)}: 73
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev₀ ((rev₂ primitive⁰) (fun a⁷ -> a⁷))) [N])
//│ def rev₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ 	where
//│ 	def rev₁ = 
//│ 		(fun ls³ -> ls³)
//│ def rev₂ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => (fun a² -> ((rev₃ t¹) 
//│ 			let h³ = h¹
//│ 			in let t³ = a²
//│ 			in (fun a⁶ -> ((rev₁ t³) [C h³ a⁶]))))
//│ 		| N => (fun a³ -> a³)})
//│ 	where
//│ 	def rev₃ = 
//│ 		(fun ls² -> case ls² of {
//│ 			C h² t² => (fun a⁴ -> ((rev₃ t²) 
//│ 				let h⁴ = h²
//│ 				in let t⁴ = a⁴
//│ 				in (fun a⁸ -> ((rev₁ t⁴) [C h⁴ a⁸]))))
//│ 			| N => (fun a⁵ -> a⁵)})
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: even normal rev can be optimized?
// NOTE: may be only out of luck: we choose 
_LUMBERHACK_EVAL
fun concat(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(C(1, C(2, N)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (rev^27 [C 1 [C 2 [N]]])
//│ def concat = (fun xs⁰ -> case xs⁰ of {
//│ 	N => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ ((concat^5 t⁰) ys¹)])})
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	C h¹ t¹ => ((concat^15 (rev^16 t¹)) [C h¹ [N]])
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^27]
//│ 	[rev^27 · concat^15] (hopeless to continue)
//│ 		[rev^27 · concat^15 · concat^5] ---> [rev^27 · concat^15] (using original def)
//│ 	[rev^27 · rev^16]
//│ 		[rev^27 · rev^16 · concat^15] (hopeless to continue)
//│ 			[rev^27 · rev^16 · concat^15 · concat^5] ---> [rev^27 · rev^16 · concat^15] (using original def)
//│ 		[rev^27 · rev^16 · rev^16]
//│ 			[rev^27 · rev^16 · rev^16 · concat^15] (hopeless to continue)
//│ 				[rev^27 · rev^16 · rev^16 · concat^15 · concat^5] ---> [rev^27 · rev^16 · rev^16 · concat^15] (using original def)
//│ 			[rev^27 · rev^16 · rev^16 · rev^16] ---> [rev^27 · rev^16 · rev^16] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (rev₀ [C 1 [C 2 [N]]])
//│ def rev₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h³ t³ => ((concat₀ (rev₁ t³)) [C h³ [N]])
//│ 		| N => [N]})
//│ 	where
//│ 	def concat₀ = 
//│ 		(fun xs³ -> case xs³ of {
//│ 			N => (fun ys⁶ -> ys⁶)
//│ 			| C h⁷ t⁷ => (fun ys⁷ -> [C h⁷ ((concat₀ t⁷) ys⁷)])})
//│ 	def rev₁ = 
//│ 		(fun ls³ -> case ls³ of {
//│ 			C h⁴ t⁴ => ((concat₁ (rev₂ t⁴)) [C h⁴ [N]])
//│ 			| N => [N]})
//│ 		where
//│ 		def concat₁ = 
//│ 			(fun xs² -> case xs² of {
//│ 				N => (fun ys⁴ -> ys⁴)
//│ 				| C h⁶ t⁶ => (fun ys⁵ -> [C h⁶ ((concat₁ t⁶) ys⁵)])})
//│ 		def rev₂ = 
//│ 			(fun ls¹ -> case ls¹ of {
//│ 				C h² t² => ((concat₂ (rev₂ t²)) [C h² [N]])
//│ 				| N => [N]})
//│ 			where
//│ 			def concat₂ = 
//│ 				(fun xs¹ -> case xs¹ of {
//│ 					N => (fun ys² -> ys²)
//│ 					| C h⁵ t⁵ => (fun ys³ -> [C h⁵ ((concat₂ t⁵) ys³)])})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]]: 117 --->
//│ 	case ls² of {C h³ t³ => ((concat₀ (rev₁ t³)) [C h³ [N]]) | N => [N]}: 58
//│ [C 2 [N]]: 116 --->
//│ 	case ls³ of {C h⁴ t⁴ => ((concat₁ (rev₂ t⁴)) [C h⁴ [N]]) | N => [N]}: 71
//│ [C h⁶ ((concat₁ t⁶) ys⁵)]: 95 --->
//│ 	case xs³ of {N => (fun ys⁶ -> ys⁶) | C h⁷ t⁷ => (fun ys⁷ -> [C h⁷ ((concat₀ t⁷) ys⁷)])}: 110
//│ [C h⁵ ((concat₂ t⁵) ys³)]: 82 --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁶ t⁶ => (fun ys⁵ -> [C h⁶ ((concat₁ t⁶) ys⁵)])}: 97
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h⁵ t⁵ => (fun ys³ -> [C h⁵ ((concat₂ t⁵) ys³)])}: 84
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C h⁴ [N]]: 68 --->
//│ 	case xs³ of {N => (fun ys⁶ -> ys⁶) | C h⁷ t⁷ => (fun ys⁷ -> [C h⁷ ((concat₀ t⁷) ys⁷)])}: 110
//│ [C h² [N]]: 42 --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁶ t⁶ => (fun ys⁵ -> [C h⁶ ((concat₁ t⁶) ys⁵)])}: 97
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h⁵ t⁵ => (fun ys³ -> [C h⁵ ((concat₂ t⁵) ys³)])}: 84
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N]: 67 --->
//│ 	case xs³ of {N => (fun ys⁶ -> ys⁶) | C h⁷ t⁷ => (fun ys⁷ -> [C h⁷ ((concat₀ t⁷) ys⁷)])}: 110
//│ [N]: 115 --->
//│ 	case ls¹ of {C h² t² => ((concat₂ (rev₂ t²)) [C h² [N]]) | N => [N]}: 45
//│ [N]: 70 --->
//│ 	case xs³ of {N => (fun ys⁶ -> ys⁶) | C h⁷ t⁷ => (fun ys⁷ -> [C h⁷ ((concat₀ t⁷) ys⁷)])}: 110
//│ [N]: 41 --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁶ t⁶ => (fun ys⁵ -> [C h⁶ ((concat₁ t⁶) ys⁵)])}: 97
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h⁵ t⁵ => (fun ys³ -> [C h⁵ ((concat₂ t⁵) ys³)])}: 84
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N]: 44 --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁶ t⁶ => (fun ys⁵ -> [C h⁶ ((concat₁ t⁶) ys⁵)])}: 97
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h⁵ t⁵ => (fun ys³ -> [C h⁵ ((concat₂ t⁵) ys³)])}: 84
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (rev₀ 
//│ 	let h³ = 1
//│ 	in let t³ = 	
//│ 		let h⁴ = 2
//│ 		in let t⁴ = (fun ys⁴ -> ys⁴)
//│ 		in ((concat₁ (rev₂ t⁴)) 
//│ 			let h⁷ = h⁴
//│ 			in let t⁷ = (fun ys⁶ -> ys⁶)
//│ 			in (fun ys⁷ -> [C h⁷ ((concat₀ t⁷) ys⁷)]))
//│ 	in ((concat₀ (rev₁ t³)) [C h³ [N]]))
//│ def rev₀ = 
//│ 	(fun ls² -> ls²)
//│ 	where
//│ 	def concat₀ = 
//│ 		(fun xs³ -> xs³)
//│ 	def rev₁ = 
//│ 		(fun ls³ -> ls³)
//│ 		where
//│ 		def concat₁ = 
//│ 			(fun xs² -> xs²)
//│ 		def rev₂ = 
//│ 			(fun ls¹ -> ls¹)
//│ 			where
//│ 			def concat₂ = 
//│ 				(fun xs¹ -> case xs¹ of {
//│ 					N => (fun ys² -> ys²)
//│ 					| C h⁵ t⁵ => (fun ys³ -> 
//│ 						let h⁶ = h⁵
//│ 						in let t⁶ = ((concat₂ t⁵) ys³)
//│ 						in (fun ys⁵ -> 
//│ 							let h⁷ = h⁶
//│ 							in let t⁷ = ((concat₁ t⁶) ys⁵)
//│ 							in (fun ys⁷ -> [C h⁷ ((concat₀ t⁷) ys⁷)])))})
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<
