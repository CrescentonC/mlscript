:NewParser
:ParseOnly

let rec p = C(p)
fun c(x) = if x is
    C(a) then c(a)
c(p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^9 p^10)
//│ def c = (fun x:8 -> case x:8 of {
//│ 	C a:9 => (c^4 a:9)})
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('p:6) <: 'x:8
//│ 	[-p^1 · -p^10 · +c^9 · +c^4]  --->  [-p^10 · +c^9]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c^9 · c^4] --> [c^9]
//│ [p^10 · p^1] --> [p^10]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^9]
//│ 	[c^9 · c^4] ---> [c^9] (only one)
//│ [p^10]
//│ 	[p^10 · p^1] ---> [p^10] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c^9 p^10)
//│ def c = (fun x:8 -> case x:8 of {
//│ 	C a:9 => (c a:9)})
//│ def c^9 = (fun x:12 -> case x:12 of {
//│ 	C a:13 => (c^9 a:13)})
//│ def p = [C p]
//│ def p^10 = [C p^10]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 19: [C 18: p^10]
//│ [C p^10] --->
//│ 	case x:12 of {C a:13 => (c^9 a:13)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c^9 p^10)
//│ def c = (fun x:8 -> case x:8 of {
//│ 	C a:9 => (c a:9)})
//│ def c^9 = (fun x:12 -> x:12)
//│ def p = [C p]
//│ def p^10 = let a:13 = p^10
//│ in (c^9 a:13)
//│ <<<<<<< after fusion <<<<<<<



let p = C(1, C(2, N))
fun e(z) = if z is
    C(aaa, bbb) then bbb
    N then 7
fun d(y) = if y is
    C(aa, bb) then e(bb)
    N then 5
fun c(x) = if x is
    C(a, b) then d(b)
    N then 3
c(p)
//│ |#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#fun| |e|(|z|)| |#=| |#if| |z| |is|→|C|(|aaa|,| |bbb|)| |#then| |bbb|↵|N| |#then| |7|←|↵|#fun| |d|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|,| |bb|)| |#then| |e|(|bb|)|↵|N| |#then| |5|←|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|,| |b|)| |#then| |d|(|b|)|↵|N| |#then| |3|←|↵|c|(|p|)|
//│ Parsed: {let p = C (1, C (2, N,),); fun e = z, => if z is ‹(C (aaa, bbb,)) then bbb; (N) then 7›; fun d = y, => if y is ‹(C (aa, bb,)) then e (bb,); (N) then 5›; fun c = x, => if x is ‹(C (a, b,)) then d (b,); (N) then 3›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^25 p^26)
//│ def c = (fun x:16 -> case x:16 of {
//│ 	C a:17 b:18 => (d^19 b:18)
//│ 	| N => 3})
//│ def d = (fun y:13 -> case y:13 of {
//│ 	C aa:14 bb:15 => (e^12 bb:15)
//│ 	| N => 5})
//│ def e = (fun z:10 -> case z:10 of {
//│ 	C aaa:11 bbb:12 => bbb:12
//│ 	| N => 7})
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^25] ---> [c^25] (hopeless to continue)
//│ [p^26] ---> [p^26] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c p)
//│ def c = (fun x:16 -> case x:16 of {
//│ 	C a:17 b:18 => (d b:18)
//│ 	| N => 3})
//│ def d = (fun y:13 -> case y:13 of {
//│ 	C aa:14 bb:15 => (e bb:15)
//│ 	| N => 5})
//│ def e = (fun z:10 -> case z:10 of {
//│ 	C aaa:11 bbb:12 => bbb:12
//│ 	| N => 7})
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 6: [N]
//│ [N] --->
//│ 	case z:10 of {C aaa:11 bbb:12 => bbb:12 | N => 7}
//│ 7: [C 5: 2 6: [N]]
//│ [C 2 [N]] --->
//│ 	case y:13 of {C aa:14 bb:15 => (e bb:15) | N => 5}
//│ 8: [C 4: 1 7: [C 5: 2 6: [N]]]
//│ [C 1 [C 2 [N]]] --->
//│ 	case x:16 of {C a:17 b:18 => (d b:18) | N => 3}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c p)
//│ def c = (fun x:16 -> x:16)
//│ def d = (fun y:13 -> y:13)
//│ def e = (fun z:10 -> z:10)
//│ def p = let a:17 = 1
//│ in let b:18 = 
//│ 	let aa:14 = 2
//│ 	in let bb:15 = 7
//│ 	in (e bb:15)
//│ in (d b:18)
//│ <<<<<<< after fusion <<<<<<<


let rec p = C(C(p))
fun c(x) = if x is
    C(a) then if a is
        C(b) then if b is
            C(y) then c(y)
c(p)
//│ |#let| |#rec| |p| |#=| |C|(|C|(|p|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |#if| |b| |is|→|C|(|y|)| |#then| |c|(|y|)|←|←|←|↵|c|(|p|)|
//│ Parsed: {let rec p = C (C (p,),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then if b is ‹(C (y,)) then c (y,)›››; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^14 p^15)
//│ def c = (fun x:8 -> case x:8 of {
//│ 	C a:9 => case a:9 of {
//│ 		C b:10 => case b:10 of {
//│ 			C y:11 => (c^7 y:11)}}})
//│ def p = [C [C p^1]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(C('p:6)) <: 'x:8
//│ 	[-p^1 · -p^1 · -p^1 · -p^15 · +c^14 · +c^7 · +c^7]  --->  [-p^15 · +c^14]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c^14 · c^7 · c^7] --> [c^14]
//│ [p^15 · p^1 · p^1 · p^1] --> [p^15]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^14]
//│ 	[c^14 · c^7]
//│ 		[c^14 · c^7 · c^7] ---> [c^14] (only one)
//│ [p^15]
//│ 	[p^15 · p^1]
//│ 		[p^15 · p^1 · p^1]
//│ 			[p^15 · p^1 · p^1 · p^1] ---> [p^15] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c^14 p^15)
//│ def c = (fun x:8 -> case x:8 of {
//│ 	C a:9 => case a:9 of {
//│ 		C b:10 => case b:10 of {
//│ 			C y:11 => (c y:11)}}})
//│ def c^14 = (fun x:17 -> case x:17 of {
//│ 	C a:18 => case a:18 of {
//│ 		C b:19 => case b:19 of {
//│ 			C y:20 => (c^14_c^7 y:20)}}})
//│ def c^14_c^7 = (fun x:21 -> case x:21 of {
//│ 	C a:22 => case a:22 of {
//│ 		C b:23 => case b:23 of {
//│ 			C y:24 => (c^14 y:24)}}})
//│ def p = [C [C p]]
//│ def p^15 = [C [C p^15_p^1]]
//│ def p^15_p^1 = [C [C p^15_p^1_p^1]]
//│ def p^15_p^1_p^1 = [C [C p^15]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 38: [C 37: p^15]
//│ [C p^15] --->
//│ 	case b:23 of {C y:24 => (c^14 y:24)}
//│ 39: [C 38: [C 37: p^15]]
//│ [C [C p^15]] --->
//│ 	case a:22 of {C b:23 => case b:23 of {C y:24 => (c^14 y:24)}}
//│ 41: [C 40: p^15_p^1_p^1]
//│ [C p^15_p^1_p^1] --->
//│ 	case x:21 of {C a:22 => case a:22 of {C b:23 => case b:23 of {C y:24 => (c^14 y:24)}}}
//│ 42: [C 41: [C 40: p^15_p^1_p^1]]
//│ [C [C p^15_p^1_p^1]] --->
//│ 	case b:19 of {C y:20 => (c^14_c^7 y:20)}
//│ 44: [C 43: p^15_p^1]
//│ [C p^15_p^1] --->
//│ 	case a:18 of {C b:19 => case b:19 of {C y:20 => (c^14_c^7 y:20)}}
//│ 45: [C 44: [C 43: p^15_p^1]]
//│ [C [C p^15_p^1]] --->
//│ 	case x:17 of {C a:18 => case a:18 of {C b:19 => case b:19 of {C y:20 => (c^14_c^7 y:20)}}}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c^14 p^15)
//│ def c = (fun x:8 -> case x:8 of {
//│ 	C a:9 => case a:9 of {
//│ 		C b:10 => case b:10 of {
//│ 			C y:11 => (c y:11)}}})
//│ def c^14 = (fun x:17 -> x:17)
//│ def c^14_c^7 = (fun x:21 -> x:21)
//│ def p = [C [C p]]
//│ def p^15 = let a:18 = 
//│ 	let b:19 = p^15_p^1
//│ 	in b:19
//│ in a:18
//│ def p^15_p^1 = let y:20 = 
//│ 	let a:22 = p^15_p^1_p^1
//│ 	in a:22
//│ in (c^14_c^7 y:20)
//│ def p^15_p^1_p^1 = let b:23 = 
//│ 	let y:24 = p^15
//│ 	in (c^14 y:24)
//│ in b:23
//│ <<<<<<< after fusion <<<<<<<




let rec p = C(C(p))
fun c(x) = if x is
    C(a) then c(a)
fun id2(yy) = yy
fun id(y) = id2(y)
c(id(p))
//│ |#let| |#rec| |p| |#=| |C|(|C|(|p|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id2|(|yy|)| |#=| |yy|↵|#fun| |id|(|y|)| |#=| |id2|(|y|)|↵|c|(|id|(|p|)|)|
//│ Parsed: {let rec p = C (C (p,),); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun id2 = yy, => yy; fun id = y, => id2 (y,); c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^16 (id^17 p^18))
//│ def c = (fun x:10 -> case x:10 of {
//│ 	C a:11 => (c^5 a:11)})
//│ def id = (fun y:13 -> (id2^12 y:13))
//│ def id2 = (fun yy:12 -> yy:12)
//│ def p = [C [C p^1]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(C('p:6)) <: 'x:10
//│ 	[-p^1 · -p^18 · +id^17 · +id2^12 · -id2^12 · -id^17 · +c^16 · +c^5 · +c^5]  --->  [-p^18 · +id^17 · +id2^12 · -id2^12 · -id^17 · +c^16]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c^16 · c^5 · c^5] --> [c^16]
//│ [p^18 · p^1] --> [p^18]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^16]
//│ 	[c^16 · c^5]
//│ 		[c^16 · c^5 · c^5] ---> [c^16] (only one)
//│ [id^17] ---> [id^17] (hopeless to continue)
//│ [p^18]
//│ 	[p^18 · p^1] ---> [p^18] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c^16 (id p^18))
//│ def c = (fun x:10 -> case x:10 of {
//│ 	C a:11 => (c a:11)})
//│ def c^16 = (fun x:19 -> case x:19 of {
//│ 	C a:20 => (c^16_c^5 a:20)})
//│ def c^16_c^5 = (fun x:17 -> case x:17 of {
//│ 	C a:18 => (c^16 a:18)})
//│ def id = (fun y:13 -> (id2 y:13))
//│ def id2 = (fun yy:12 -> yy:12)
//│ def p = [C [C p]]
//│ def p^18 = [C [C p^18]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 22: [C 21: p^18]
//│ [C p^18] --->
//│ 	case x:17 of {C a:18 => (c^16 a:18)}
//│ 23: [C 22: [C 21: p^18]]
//│ [C [C p^18]] --->
//│ 	case x:19 of {C a:20 => (c^16_c^5 a:20)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c^16 (id p^18))
//│ def c = (fun x:10 -> case x:10 of {
//│ 	C a:11 => (c a:11)})
//│ def c^16 = (fun x:19 -> x:19)
//│ def c^16_c^5 = (fun x:17 -> x:17)
//│ def id = (fun y:13 -> (id2 y:13))
//│ def id2 = (fun yy:12 -> yy:12)
//│ def p = [C [C p]]
//│ def p^18 = let a:20 = 
//│ 	let a:18 = p^18
//│ 	in (c^16 a:18)
//│ in (c^16_c^5 a:20)
//│ <<<<<<< after fusion <<<<<<<

fun sum(ls) = if ls is
    C(h, t) then S(N, sum(t))
fun mapa(lsa) = if lsa is
    C(ha, ta) then C(primitive(ha), mapa(ta))
fun mapb(lsb) = if lsb is
    C(hb, tb) then C(primitive(hb), mapb(tb))
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),)›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),)›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),)›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (sum^29 (mapa^30 (mapb^31 primitive:3)))
//│ def mapa = (fun lsa:12 -> case lsa:12 of {
//│ 	C ha:13 ta:14 => [C (primitive:3 ha:13) (mapa^13 ta:14)]})
//│ def mapb = (fun lsb:15 -> case lsb:15 of {
//│ 	C hb:16 tb:17 => [C (primitive:3 hb:16) (mapb^23 tb:17)]})
//│ def sum = (fun ls:9 -> case ls:9 of {
//│ 	C h:10 t:11 => [S [N] (sum^3 t:11)]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('12_callres, '15_callres) <: 'ls:9
//│ 	[-mapa^13 · -mapa^13 · -mapa^30 · +sum^29 · +sum^3 · +sum^3]  --->  [-mapa^13 · -mapa^30 · +sum^29 · +sum^3]
//│ C('22_callres, '25_callres) <: 'lsa:12
//│ 	[-mapb^23 · -mapb^23 · -mapb^31 · +mapa^30 · +mapa^13 · +mapa^13]  --->  [-mapb^23 · -mapb^31 · +mapa^30 · +mapa^13]
//│ NoProd <: 'lsb:15
//│ 	[+mapb^31 · +mapb^23 · +mapb^23]  --->  [+mapb^31 · +mapb^23]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [mapa^30 · mapa^13 · mapa^13] --> [mapa^30 · mapa^13]
//│ [sum^29 · sum^3 · sum^3] --> [sum^29 · sum^3]
//│ [mapb^31 · mapb^23 · mapb^23] --> [mapb^31 · mapb^23]
//│ [] --> []
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa^30]
//│ 	[mapa^30 · mapa^13]
//│ 		[mapa^30 · mapa^13 · mapa^13] ---> [mapa^30 · mapa^13] (only one)
//│ [mapb^31]
//│ 	[mapb^31 · mapb^23]
//│ 		[mapb^31 · mapb^23 · mapb^23] ---> [mapb^31 · mapb^23] (only one)
//│ [sum^29]
//│ 	[sum^29 · sum^3]
//│ 		[sum^29 · sum^3 · sum^3] ---> [sum^29 · sum^3] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (sum^29 (mapa^30 (mapb^31 primitive:3)))
//│ def mapa = (fun lsa:12 -> case lsa:12 of {
//│ 	C ha:13 ta:14 => [C (primitive:3 ha:13) (mapa ta:14)]})
//│ def mapa^30 = (fun lsa:30 -> case lsa:30 of {
//│ 	C ha:31 ta:32 => [C (primitive:3 ha:31) (mapa^30_mapa^13 ta:32)]})
//│ def mapa^30_mapa^13 = (fun lsa:36 -> case lsa:36 of {
//│ 	C ha:37 ta:38 => [C (primitive:3 ha:37) (mapa^30_mapa^13 ta:38)]})
//│ def mapb = (fun lsb:15 -> case lsb:15 of {
//│ 	C hb:16 tb:17 => [C (primitive:3 hb:16) (mapb tb:17)]})
//│ def mapb^31 = (fun lsb:24 -> case lsb:24 of {
//│ 	C hb:25 tb:26 => [C (primitive:3 hb:25) (mapb^31_mapb^23 tb:26)]})
//│ def mapb^31_mapb^23 = (fun lsb:27 -> case lsb:27 of {
//│ 	C hb:28 tb:29 => [C (primitive:3 hb:28) (mapb^31_mapb^23 tb:29)]})
//│ def sum = (fun ls:9 -> case ls:9 of {
//│ 	C h:10 t:11 => [S [N] (sum t:11)]})
//│ def sum^29 = (fun ls:39 -> case ls:39 of {
//│ 	C h:40 t:41 => [S [N] (sum^29_sum^3 t:41)]})
//│ def sum^29_sum^3 = (fun ls:33 -> case ls:33 of {
//│ 	C h:34 t:35 => [S [N] (sum^29_sum^3 t:35)]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 43: [C 39: (37: primitive 38: hb) 42: (40: mapb^31_mapb^23 41: tb)]
//│ [C (primitive:3 hb:25) (mapb^31_mapb^23 tb:26)] --->
//│ 	case lsa:30 of {C ha:31 ta:32 => [C (primitive:3 ha:31) (mapa^30_mapa^13 ta:32)]}
//│ 53: [C 49: (47: primitive 48: hb) 52: (50: mapb^31_mapb^23 51: tb)]
//│ [C (primitive:3 hb:28) (mapb^31_mapb^23 tb:29)] --->
//│ 	case lsa:36 of {C ha:37 ta:38 => [C (primitive:3 ha:37) (mapa^30_mapa^13 ta:38)]}
//│ 63: [C 59: (57: primitive 58: ha) 62: (60: mapa^30_mapa^13 61: ta)]
//│ [C (primitive:3 ha:31) (mapa^30_mapa^13 ta:32)] --->
//│ 	case ls:39 of {C h:40 t:41 => [S [N] (sum^29_sum^3 t:41)]}
//│ 81: [C 77: (75: primitive 76: ha) 80: (78: mapa^30_mapa^13 79: ta)]
//│ [C (primitive:3 ha:37) (mapa^30_mapa^13 ta:38)] --->
//│ 	case ls:33 of {C h:34 t:35 => [S [N] (sum^29_sum^3 t:35)]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (sum^29 (mapa^30 (mapb^31 primitive:3)))
//│ def mapa = (fun lsa:12 -> case lsa:12 of {
//│ 	C ha:13 ta:14 => [C (primitive:3 ha:13) (mapa ta:14)]})
//│ def mapa^30 = (fun lsa:30 -> lsa:30)
//│ def mapa^30_mapa^13 = (fun lsa:36 -> lsa:36)
//│ def mapb = (fun lsb:15 -> case lsb:15 of {
//│ 	C hb:16 tb:17 => [C (primitive:3 hb:16) (mapb tb:17)]})
//│ def mapb^31 = (fun lsb:24 -> case lsb:24 of {
//│ 	C hb:25 tb:26 => let ha:31 = (primitive:3 hb:25)
//│ 	in let ta:32 = (mapb^31_mapb^23 tb:26)
//│ 	in let h:40 = (primitive:3 ha:31)
//│ 	in let t:41 = (mapa^30_mapa^13 ta:32)
//│ 	in [S [N] (sum^29_sum^3 t:41)]})
//│ def mapb^31_mapb^23 = (fun lsb:27 -> case lsb:27 of {
//│ 	C hb:28 tb:29 => let ha:37 = (primitive:3 hb:28)
//│ 	in let ta:38 = (mapb^31_mapb^23 tb:29)
//│ 	in let h:34 = (primitive:3 ha:37)
//│ 	in let t:35 = (mapa^30_mapa^13 ta:38)
//│ 	in [S [N] (sum^29_sum^3 t:35)]})
//│ def sum = (fun ls:9 -> case ls:9 of {
//│ 	C h:10 t:11 => [S [N] (sum t:11)]})
//│ def sum^29 = (fun ls:39 -> ls:39)
//│ def sum^29_sum^3 = (fun ls:33 -> ls:33)
//│ <<<<<<< after fusion <<<<<<<


if C(A, B(C)) is
    C(a, b) then D(b)
//│ |#if| |C|(|A|,| |B|(|C|)|)| |is|→|C|(|a|,| |b|)| |#then| |D|(|b|)|←|
//│ Parsed: {if C (A, B (C,),) is ‹(C (a, b,)) then D (b,)›}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a:6 b:7 => [D b:7]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a:8 b:9 => [D b:9]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 11: [C 8: [A] 10: [B 9: [C]]]
//│ [C [A] [B [C]]] --->
//│ 	case [C [A] [B [C]]] of {C a:8 b:9 => [D b:9]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ let a:8 = [A]
//│ in let b:9 = [B [C]]
//│ in [D b:9]
//│ <<<<<<< after fusion <<<<<<<
//│



let rec p = C(C(C(p)))
fun ca(x) = if x is
    C(a) then cb(a)
fun cb(x) = if x is
    C(b) then ca(b)
ca(p)
//│ |#let| |#rec| |p| |#=| |C|(|C|(|C|(|p|)|)|)|↵|#fun| |ca|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |cb|(|a|)|←|↵|#fun| |cb|(|x|)| |#=| |#if| |x| |is|→|C|(|b|)| |#then| |ca|(|b|)|←|↵|ca|(|p|)|
//│ Parsed: {let rec p = C (C (C (p,),),); fun ca = x, => if x is ‹(C (a,)) then cb (a,)›; fun cb = x, => if x is ‹(C (b,)) then ca (b,)›; ca (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (ca^17 p^18)
//│ def ca = (fun x:9 -> case x:9 of {
//│ 	C a:10 => (cb^6 a:10)})
//│ def cb = (fun x:11 -> case x:11 of {
//│ 	C b:12 => (ca^12 b:12)})
//│ def p = [C [C [C p^1]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(C(C('p:6))) <: 'x:9
//│ 	[-p^1 · -p^1 · -p^18 · +ca^17 · +cb^6 · +ca^12 · +cb^6 · +ca^12 · +cb^6 · +ca^12]  --->  [-p^18 · +ca^17]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [ca^17 · cb^6 · ca^12 · cb^6 · ca^12 · cb^6 · ca^12] --> [ca^17]
//│ [p^18 · p^1 · p^1] --> [p^18]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ca^17]
//│ 	[ca^17 · cb^6]
//│ 		[ca^17 · cb^6 · ca^12]
//│ 			[ca^17 · cb^6 · ca^12 · cb^6]
//│ 				[ca^17 · cb^6 · ca^12 · cb^6 · ca^12]
//│ 					[ca^17 · cb^6 · ca^12 · cb^6 · ca^12 · cb^6]
//│ 						[ca^17 · cb^6 · ca^12 · cb^6 · ca^12 · cb^6 · ca^12] ---> [ca^17] (only one)
//│ [p^18]
//│ 	[p^18 · p^1]
//│ 		[p^18 · p^1 · p^1] ---> [p^18] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (ca^17 p^18)
//│ def ca = (fun x:9 -> case x:9 of {
//│ 	C a:10 => (cb a:10)})
//│ def ca^17 = (fun x:31 -> case x:31 of {
//│ 	C a:32 => (ca^17_cb^6 a:32)})
//│ def ca^17_cb^6 = (fun x:25 -> case x:25 of {
//│ 	C b:26 => (ca^17_cb^6_ca^12 b:26)})
//│ def ca^17_cb^6_ca^12 = (fun x:29 -> case x:29 of {
//│ 	C a:30 => (ca^17_cb^6_ca^12_cb^6 a:30)})
//│ def ca^17_cb^6_ca^12_cb^6 = (fun x:23 -> case x:23 of {
//│ 	C b:24 => (ca^17_cb^6_ca^12_cb^6_ca^12 b:24)})
//│ def ca^17_cb^6_ca^12_cb^6_ca^12 = (fun x:27 -> case x:27 of {
//│ 	C a:28 => (ca^17_cb^6_ca^12_cb^6_ca^12_cb^6 a:28)})
//│ def ca^17_cb^6_ca^12_cb^6_ca^12_cb^6 = (fun x:21 -> case x:21 of {
//│ 	C b:22 => (ca^17 b:22)})
//│ def cb = (fun x:11 -> case x:11 of {
//│ 	C b:12 => (ca b:12)})
//│ def p = [C [C [C p]]]
//│ def p^18 = [C [C [C p^18_p^1]]]
//│ def p^18_p^1 = [C [C [C p^18]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 33: [C 32: p^18]
//│ [C p^18] --->
//│ 	case x:21 of {C b:22 => (ca^17 b:22)}
//│ 34: [C 33: [C 32: p^18]]
//│ [C [C p^18]] --->
//│ 	case x:27 of {C a:28 => (ca^17_cb^6_ca^12_cb^6_ca^12_cb^6 a:28)}
//│ 35: [C 34: [C 33: [C 32: p^18]]]
//│ [C [C [C p^18]]] --->
//│ 	case x:23 of {C b:24 => (ca^17_cb^6_ca^12_cb^6_ca^12 b:24)}
//│ 37: [C 36: p^18_p^1]
//│ [C p^18_p^1] --->
//│ 	case x:29 of {C a:30 => (ca^17_cb^6_ca^12_cb^6 a:30)}
//│ 38: [C 37: [C 36: p^18_p^1]]
//│ [C [C p^18_p^1]] --->
//│ 	case x:25 of {C b:26 => (ca^17_cb^6_ca^12 b:26)}
//│ 39: [C 38: [C 37: [C 36: p^18_p^1]]]
//│ [C [C [C p^18_p^1]]] --->
//│ 	case x:31 of {C a:32 => (ca^17_cb^6 a:32)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (ca^17 p^18)
//│ def ca = (fun x:9 -> case x:9 of {
//│ 	C a:10 => (cb a:10)})
//│ def ca^17 = (fun x:31 -> x:31)
//│ def ca^17_cb^6 = (fun x:25 -> x:25)
//│ def ca^17_cb^6_ca^12 = (fun x:29 -> x:29)
//│ def ca^17_cb^6_ca^12_cb^6 = (fun x:23 -> x:23)
//│ def ca^17_cb^6_ca^12_cb^6_ca^12 = (fun x:27 -> x:27)
//│ def ca^17_cb^6_ca^12_cb^6_ca^12_cb^6 = (fun x:21 -> x:21)
//│ def cb = (fun x:11 -> case x:11 of {
//│ 	C b:12 => (ca b:12)})
//│ def p = [C [C [C p]]]
//│ def p^18 = let a:32 = 
//│ 	let b:26 = 
//│ 		let a:30 = p^18_p^1
//│ 		in (ca^17_cb^6_ca^12_cb^6 a:30)
//│ 	in (ca^17_cb^6_ca^12 b:26)
//│ in (ca^17_cb^6 a:32)
//│ def p^18_p^1 = let b:24 = 
//│ 	let a:28 = 
//│ 		let b:22 = p^18
//│ 		in (ca^17 b:22)
//│ 	in (ca^17_cb^6_ca^12_cb^6_ca^12_cb^6 a:28)
//│ in (ca^17_cb^6_ca^12_cb^6_ca^12 b:24)
//│ <<<<<<< after fusion <<<<<<<


// def p:6^18 =
//      ... p:6^1 ~> p:6^18.p:6^1 ...

// def p:6^18.p:6^1 =
//      ... p:6^1 ~> p:6^18 ...

// def ca:7^17
//      ... 



fun c1(x1) = if x1 is
    C(a) then c2(a)
fun c2(x2) = if x2 is
    C(b) then c1(b)
let p1 = C(C(C(p2)))
let p2 = C(p1)
c1(p1)
//│ |#fun| |c1|(|x1|)| |#=| |#if| |x1| |is|→|C|(|a|)| |#then| |c2|(|a|)|←|↵|#fun| |c2|(|x2|)| |#=| |#if| |x2| |is|→|C|(|b|)| |#then| |c1|(|b|)|←|↵|#let| |p1| |#=| |C|(|C|(|C|(|p2|)|)|)|↵|#let| |p2| |#=| |C|(|p1|)|↵|c1|(|p1|)|
//│ Parsed: {fun c1 = x1, => if x1 is ‹(C (a,)) then c2 (a,)›; fun c2 = x2, => if x2 is ‹(C (b,)) then c1 (b,)›; let p1 = C (C (C (p2,),),); let p2 = C (p1,); c1 (p1,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c1^19 p1^20)
//│ def c1 = (fun x1:10 -> case x1:10 of {
//│ 	C a:11 => (c2^2 a:11)})
//│ def c2 = (fun x2:12 -> case x2:12 of {
//│ 	C b:13 => (c1^8 b:13)})
//│ def p1 = [C [C [C p2^13]]]
//│ def p2 = [C p1^17]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(C('p2:9)) <: 'x2:12
//│ 	[-p1^17 · -p2^13 · -p1^20 · +c1^19 · +c2^2 · +c1^8 · +c2^2 · +c1^8 · +c2^2]  --->  [-p1^20 · +c1^19 · +c2^2]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c1^19 · c2^2 · c1^8 · c2^2 · c1^8 · c2^2] --> [c1^19 · c2^2]
//│ [p1^20 · p2^13 · p1^17] --> [p1^20]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c1^19]
//│ 	[c1^19 · c2^2]
//│ 		[c1^19 · c2^2 · c1^8]
//│ 			[c1^19 · c2^2 · c1^8 · c2^2]
//│ 				[c1^19 · c2^2 · c1^8 · c2^2 · c1^8]
//│ 					[c1^19 · c2^2 · c1^8 · c2^2 · c1^8 · c2^2] ---> [c1^19 · c2^2] (only one)
//│ [p1^20]
//│ 	[p1^20 · p2^13]
//│ 		[p1^20 · p2^13 · p1^17] ---> [p1^20] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c1^19 p1^20)
//│ def c1 = (fun x1:10 -> case x1:10 of {
//│ 	C a:11 => (c2 a:11)})
//│ def c1^19 = (fun x1:23 -> case x1:23 of {
//│ 	C a:24 => (c1^19_c2^2 a:24)})
//│ def c1^19_c2^2 = (fun x2:21 -> case x2:21 of {
//│ 	C b:22 => (c1^19_c2^2_c1^8 b:22)})
//│ def c1^19_c2^2_c1^8 = (fun x1:27 -> case x1:27 of {
//│ 	C a:28 => (c1^19_c2^2_c1^8_c2^2 a:28)})
//│ def c1^19_c2^2_c1^8_c2^2 = (fun x2:25 -> case x2:25 of {
//│ 	C b:26 => (c1^19_c2^2_c1^8_c2^2_c1^8 b:26)})
//│ def c1^19_c2^2_c1^8_c2^2_c1^8 = (fun x1:29 -> case x1:29 of {
//│ 	C a:30 => (c1^19_c2^2 a:30)})
//│ def c2 = (fun x2:12 -> case x2:12 of {
//│ 	C b:13 => (c1 b:13)})
//│ def p1 = [C [C [C p2]]]
//│ def p1^20 = [C [C [C p1^20_p2^13]]]
//│ def p1^20_p2^13 = [C p1^20]
//│ def p2 = [C p1]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 29: [C 28: p1^20_p2^13]
//│ [C p1^20_p2^13] --->
//│ 	case x1:27 of {C a:28 => (c1^19_c2^2_c1^8_c2^2 a:28)}
//│ 30: [C 29: [C 28: p1^20_p2^13]]
//│ [C [C p1^20_p2^13]] --->
//│ 	case x2:21 of {C b:22 => (c1^19_c2^2_c1^8 b:22)}
//│ 31: [C 30: [C 29: [C 28: p1^20_p2^13]]]
//│ [C [C [C p1^20_p2^13]]] --->
//│ 	case x1:23 of {C a:24 => (c1^19_c2^2 a:24)}
//│ 	case x1:29 of {C a:30 => (c1^19_c2^2 a:30)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 33: [C 32: p1^20]
//│ [C p1^20] --->
//│ 	case x2:25 of {C b:26 => (c1^19_c2^2_c1^8_c2^2_c1^8 b:26)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c1^19 p1^20)
//│ def c1 = (fun x1:10 -> case x1:10 of {
//│ 	C a:11 => (c2 a:11)})
//│ def c1^19 = (fun x1:23 -> x1:23)
//│ def c1^19_c2^2 = (fun x2:21 -> x2:21)
//│ def c1^19_c2^2_c1^8 = (fun x1:27 -> x1:27)
//│ def c1^19_c2^2_c1^8_c2^2 = (fun x2:25 -> x2:25)
//│ def c1^19_c2^2_c1^8_c2^2_c1^8 = (fun x1:29 -> case x1:29 of {
//│ 	C a:30 => (c1^19_c2^2 a:30)})
//│ def c2 = (fun x2:12 -> case x2:12 of {
//│ 	C b:13 => (c1 b:13)})
//│ def p1 = [C [C [C p2]]]
//│ def p1^20 = let a:24 = 
//│ 	let b:22 = 
//│ 		let a:28 = p1^20_p2^13
//│ 		in (c1^19_c2^2_c1^8_c2^2 a:28)
//│ 	in (c1^19_c2^2_c1^8 b:22)
//│ in (c1^19_c2^2 a:24)
//│ def p1^20_p2^13 = let b:26 = p1^20
//│ in (c1^19_c2^2_c1^8_c2^2_c1^8 b:26)
//│ def p2 = [C p1]
//│ <<<<<<< after fusion <<<<<<<


fun ff(x) = if x is
    K then T
    KK then TT
    KKKK then TTTT
fun map(ls) = if ls is
    C(h, t) then C(ff(h), map(t))
    N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|ff|(|h|)|,| |map|(|t|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; fun map = ls, => if ls is ‹(C (h, t,)) then C (ff (h,), map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^25 l^26)
//│ def ff = (fun x:9 -> case x:9 of {
//│ 	K => [T]
//│ 	| KK => [TT]
//│ 	| KKKK => [TTTT]})
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun ls:10 -> case ls:10 of {
//│ 	C h:11 t:12 => [C (ff^8 h:11) (map^11 t:12)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 't:12
//│ 	[-l^26 · +map^25 · +map^11 · +map^11 · +map^11 · +map^11]  --->  [-l^26 · +map^25 · +map^11 · +map^11 · +map^11]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [map^25 · map^11 · map^11 · map^11 · map^11] --> [map^25 · map^11 · map^11 · map^11]
//│ [l^26] --> [l^26]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^26]
//│ [map^25]
//│ 	[map^25 · map^11]
//│ 		[map^25 · map^11 · map^11]
//│ 			[map^25 · map^11 · map^11 · map^11]
//│ 				[map^25 · map^11 · map^11 · map^11 · map^11] ---> [map^25 · map^11 · map^11 · map^11] (only one)
//│ 				[map^25 · map^11 · map^11 · map^11 · ff^8] ---> [ff^8] (hopeless to continue)
//│ 			[map^25 · map^11 · map^11 · ff^8] ---> [ff^8] (hopeless to continue)
//│ 		[map^25 · map^11 · ff^8] ---> [ff^8] (hopeless to continue)
//│ 	[map^25 · ff^8] ---> [ff^8] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map^25 l^26)
//│ def ff = (fun x:9 -> case x:9 of {
//│ 	K => [T]
//│ 	| KK => [TT]
//│ 	| KKKK => [TTTT]})
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def l^26 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun ls:10 -> case ls:10 of {
//│ 	C h:11 t:12 => [C (ff h:11) (map t:12)]
//│ 	| N => [N]})
//│ def map^25 = (fun ls:18 -> case ls:18 of {
//│ 	C h:19 t:20 => [C (ff h:19) (map^25_map^11 t:20)]
//│ 	| N => [N]})
//│ def map^25_map^11 = (fun ls:21 -> case ls:21 of {
//│ 	C h:22 t:23 => [C (ff h:22) (map^25_map^11_map^11 t:23)]
//│ 	| N => [N]})
//│ def map^25_map^11_map^11 = (fun ls:24 -> case ls:24 of {
//│ 	C h:25 t:26 => [C (ff h:25) (map^25_map^11_map^11_map^11 t:26)]
//│ 	| N => [N]})
//│ def map^25_map^11_map^11_map^11 = (fun ls:27 -> case ls:27 of {
//│ 	C h:28 t:29 => [C (ff h:28) (map^25_map^11_map^11_map^11 t:29)]
//│ 	| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 39: [K]
//│ [K] --->
//│ 	case x:9 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 40: [KK]
//│ [KK] --->
//│ 	case x:9 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 41: [KKKK]
//│ [KKKK] --->
//│ 	case x:9 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 42: [N]
//│ [N] --->
//│ 	case ls:27 of {C h:28 t:29 => [C (ff h:28) (map^25_map^11_map^11_map^11 t:29)] | N => [N]}
//│ 43: [C 41: [KKKK] 42: [N]]
//│ [C [KKKK] [N]] --->
//│ 	case ls:24 of {C h:25 t:26 => [C (ff h:25) (map^25_map^11_map^11_map^11 t:26)] | N => [N]}
//│ 44: [C 40: [KK] 43: [C 41: [KKKK] 42: [N]]]
//│ [C [KK] [C [KKKK] [N]]] --->
//│ 	case ls:21 of {C h:22 t:23 => [C (ff h:22) (map^25_map^11_map^11 t:23)] | N => [N]}
//│ 45: [C 39: [K] 44: [C 40: [KK] 43: [C 41: [KKKK] 42: [N]]]]
//│ [C [K] [C [KK] [C [KKKK] [N]]]] --->
//│ 	case ls:18 of {C h:19 t:20 => [C (ff h:19) (map^25_map^11 t:20)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map^25 l^26)
//│ def ff = (fun x:9 -> x:9)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def l^26 = let h:19 = [T]
//│ in let t:20 = 
//│ 	let h:22 = [TT]
//│ 	in let t:23 = 
//│ 		let h:25 = [TTTT]
//│ 		in let t:26 = [N]
//│ 		in [C (ff h:25) (map^25_map^11_map^11_map^11 t:26)]
//│ 	in [C (ff h:22) (map^25_map^11_map^11 t:23)]
//│ in [C (ff h:19) (map^25_map^11 t:20)]
//│ def map = (fun ls:10 -> case ls:10 of {
//│ 	C h:11 t:12 => [C (ff h:11) (map t:12)]
//│ 	| N => [N]})
//│ def map^25 = (fun ls:18 -> ls:18)
//│ def map^25_map^11 = (fun ls:21 -> ls:21)
//│ def map^25_map^11_map^11 = (fun ls:24 -> ls:24)
//│ def map^25_map^11_map^11_map^11 = (fun ls:27 -> ls:27)
//│ <<<<<<< after fusion <<<<<<<


fun map(ls) = if ls is
    C(h, t) then C(
        (if h is
            K then T
            KK then TT
            KKKK then TTTT
        ),
        map(t)
    )
    N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›, ')', map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^21 l^22)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun ls:8 -> case ls:8 of {
//│ 	C h:9 t:10 => [C case h:9 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} (map^7 t:10)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 't:10
//│ 	[-l^22 · +map^21 · +map^7 · +map^7 · +map^7 · +map^7]  --->  [-l^22 · +map^21 · +map^7 · +map^7 · +map^7]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [map^21 · map^7 · map^7 · map^7 · map^7] --> [map^21 · map^7 · map^7 · map^7]
//│ [l^22] --> [l^22]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^22]
//│ [map^21]
//│ 	[map^21 · map^7]
//│ 		[map^21 · map^7 · map^7]
//│ 			[map^21 · map^7 · map^7 · map^7]
//│ 				[map^21 · map^7 · map^7 · map^7 · map^7] ---> [map^21 · map^7 · map^7 · map^7] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map^21 l^22)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def l^22 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun ls:8 -> case ls:8 of {
//│ 	C h:9 t:10 => [C case h:9 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} (map t:10)]
//│ 	| N => [N]})
//│ def map^21 = (fun ls:22 -> case ls:22 of {
//│ 	C h:23 t:24 => [C case h:23 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} (map^21_map^7 t:24)]
//│ 	| N => [N]})
//│ def map^21_map^7 = (fun ls:19 -> case ls:19 of {
//│ 	C h:20 t:21 => [C case h:20 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} (map^21_map^7_map^7 t:21)]
//│ 	| N => [N]})
//│ def map^21_map^7_map^7 = (fun ls:25 -> case ls:25 of {
//│ 	C h:26 t:27 => [C case h:26 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} (map^21_map^7_map^7_map^7 t:27)]
//│ 	| N => [N]})
//│ def map^21_map^7_map^7_map^7 = (fun ls:16 -> case ls:16 of {
//│ 	C h:17 t:18 => [C case h:17 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} (map^21_map^7_map^7_map^7 t:18)]
//│ 	| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 76: [K]
//│ [K] --->
//│ 	case h:23 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 77: [KK]
//│ [KK] --->
//│ 	case h:20 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 78: [KKKK]
//│ [KKKK] --->
//│ 	case h:26 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 79: [N]
//│ [N] --->
//│ 	case ls:16 of {C h:17 t:18 => [C case h:17 of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map^21_map^7_map^7_map^7 t:18)] | N => [N]}
//│ 80: [C 78: [KKKK] 79: [N]]
//│ [C [KKKK] [N]] --->
//│ 	case ls:25 of {C h:26 t:27 => [C case h:26 of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map^21_map^7_map^7_map^7 t:27)] | N => [N]}
//│ 81: [C 77: [KK] 80: [C 78: [KKKK] 79: [N]]]
//│ [C [KK] [C [KKKK] [N]]] --->
//│ 	case ls:19 of {C h:20 t:21 => [C case h:20 of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map^21_map^7_map^7 t:21)] | N => [N]}
//│ 82: [C 76: [K] 81: [C 77: [KK] 80: [C 78: [KKKK] 79: [N]]]]
//│ [C [K] [C [KK] [C [KKKK] [N]]]] --->
//│ 	case ls:22 of {C h:23 t:24 => [C case h:23 of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map^21_map^7 t:24)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map^21 l^22)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def l^22 = let h:23 = [T]
//│ in let t:24 = 
//│ 	let h:20 = [TT]
//│ 	in let t:21 = 
//│ 		let h:26 = [TTTT]
//│ 		in let t:27 = [N]
//│ 		in [C h:26 (map^21_map^7_map^7_map^7 t:27)]
//│ 	in [C h:20 (map^21_map^7_map^7 t:21)]
//│ in [C h:23 (map^21_map^7 t:24)]
//│ def map = (fun ls:8 -> case ls:8 of {
//│ 	C h:9 t:10 => [C case h:9 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} (map t:10)]
//│ 	| N => [N]})
//│ def map^21 = (fun ls:22 -> ls:22)
//│ def map^21_map^7 = (fun ls:19 -> ls:19)
//│ def map^21_map^7_map^7 = (fun ls:25 -> ls:25)
//│ def map^21_map^7_map^7_map^7 = (fun ls:16 -> ls:16)
//│ <<<<<<< after fusion <<<<<<<


fun sum(ls) = if ls is
    C(h, t) then S(N, sum(t))
    N then N
fun mapa(lsa) = if lsa is
    C(ha, ta) then C(primitive(ha), mapa(ta))
    N then N
fun mapb(lsb) = if lsb is
    C(hb, tb) then C(primitive(hb), mapb(tb))
    N then N
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|↵|N| |#then| |N|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|↵|N| |#then| |N|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),); (N) then N›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),); (N) then N›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),); (N) then N›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (sum^32 (mapa^33 (mapb^34 primitive:3)))
//│ def mapa = (fun lsa:12 -> case lsa:12 of {
//│ 	C ha:13 ta:14 => [C (primitive:3 ha:13) (mapa^14 ta:14)]
//│ 	| N => [N]})
//│ def mapb = (fun lsb:15 -> case lsb:15 of {
//│ 	C hb:16 tb:17 => [C (primitive:3 hb:16) (mapb^25 tb:17)]
//│ 	| N => [N]})
//│ def sum = (fun ls:9 -> case ls:9 of {
//│ 	C h:10 t:11 => [S [N] (sum^3 t:11)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('13_callres, '16_callres) <: 'ls:9
//│ 	[-mapa^14 · -mapa^14 · -mapa^33 · +sum^32 · +sum^3 · +sum^3]  --->  [-mapa^14 · -mapa^33 · +sum^32 · +sum^3]
//│ C('24_callres, '27_callres) <: 'lsa:12
//│ 	[-mapb^25 · -mapb^25 · -mapb^34 · +mapa^33 · +mapa^14 · +mapa^14]  --->  [-mapb^25 · -mapb^34 · +mapa^33 · +mapa^14]
//│ NoProd <: 'ls:9
//│ 	[-mapa^33 · +sum^32 · +sum^3 · +sum^3]  --->  [-mapa^33 · +sum^32 · +sum^3]
//│ NoProd <: 't:11
//│ 	[-mapa^14 · -mapa^14 · -mapa^33 · +sum^32 · +sum^3 · +sum^3 · +sum^3]  --->  [-mapa^14 · -mapa^14 · -mapa^33 · +sum^32 · +sum^3 · +sum^3]
//│ 	[-mapa^14 · -mapa^33 · +sum^32 · +sum^3 · +sum^3]  --->  [-mapa^14 · -mapa^33 · +sum^32 · +sum^3]
//│ NoProd <: 'ta:14
//│ 	[-mapb^25 · -mapb^34 · +mapa^33 · +mapa^14 · +mapa^14]  --->  [-mapb^25 · -mapb^34 · +mapa^33 · +mapa^14]
//│ 	[-mapb^25 · -mapb^25 · -mapb^34 · +mapa^33 · +mapa^14 · +mapa^14 · +mapa^14]  --->  [-mapb^25 · -mapb^25 · -mapb^34 · +mapa^33 · +mapa^14 · +mapa^14]
//│ NoProd <: 'lsb:15
//│ 	[+mapb^34 · +mapb^25 · +mapb^25]  --->  [+mapb^34 · +mapb^25]
//│ NoProd <: 'lsa:12
//│ 	[-mapb^34 · +mapa^33 · +mapa^14 · +mapa^14]  --->  [-mapb^34 · +mapa^33 · +mapa^14]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [mapa^33 · mapa^14 · mapa^14 · mapa^14] --> [mapa^33 · mapa^14 · mapa^14]
//│ [mapb^34 · mapb^25 · mapb^25] --> [mapb^34 · mapb^25]
//│ 	[mapb^34 · mapb^25 · mapb^25]
//│ 	!!MORE THAN ONE MATCH
//│ [sum^32 · sum^3 · sum^3 · sum^3] --> [sum^32 · sum^3 · sum^3]
//│ [sum^32 · sum^3 · sum^3] --> [sum^32 · sum^3]
//│ [mapa^33 · mapa^14 · mapa^14] --> [mapa^33 · mapa^14 · mapa^14]
//│ 	[mapa^33 · mapa^14]
//│ 	!!MORE THAN ONE MATCH
//│ [mapa^33 · mapa^14] --> [mapa^33 · mapa^14]
//│ [mapa^33] --> [mapa^33]
//│ [mapb^34 · mapb^25] --> [mapb^34 · mapb^25]
//│ [mapb^34] --> [mapb^34]
//│ [] --> []
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa^33]
//│ 	[mapa^33 · mapa^14]
//│ 		[mapa^33 · mapa^14 · mapa^14] ---> [mapa^33 · mapa^14] (only one)
//│ [mapb^34]
//│ 	[mapb^34 · mapb^25]
//│ 		[mapb^34 · mapb^25 · mapb^25] ---> [mapb^34 · mapb^25] (only one)
//│ [sum^32]
//│ 	[sum^32 · sum^3]
//│ 		[sum^32 · sum^3 · sum^3] ---> [sum^32 · sum^3] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (sum^32 (mapa^33 (mapb^34 primitive:3)))
//│ def mapa = (fun lsa:12 -> case lsa:12 of {
//│ 	C ha:13 ta:14 => [C (primitive:3 ha:13) (mapa ta:14)]
//│ 	| N => [N]})
//│ def mapa^33 = (fun lsa:36 -> case lsa:36 of {
//│ 	C ha:37 ta:38 => [C (primitive:3 ha:37) (mapa^33_mapa^14 ta:38)]
//│ 	| N => [N]})
//│ def mapa^33_mapa^14 = (fun lsa:24 -> case lsa:24 of {
//│ 	C ha:25 ta:26 => [C (primitive:3 ha:25) (mapa^33_mapa^14 ta:26)]
//│ 	| N => [N]})
//│ def mapb = (fun lsb:15 -> case lsb:15 of {
//│ 	C hb:16 tb:17 => [C (primitive:3 hb:16) (mapb tb:17)]
//│ 	| N => [N]})
//│ def mapb^34 = (fun lsb:27 -> case lsb:27 of {
//│ 	C hb:28 tb:29 => [C (primitive:3 hb:28) (mapb^34_mapb^25 tb:29)]
//│ 	| N => [N]})
//│ def mapb^34_mapb^25 = (fun lsb:33 -> case lsb:33 of {
//│ 	C hb:34 tb:35 => [C (primitive:3 hb:34) (mapb^34_mapb^25 tb:35)]
//│ 	| N => [N]})
//│ def sum = (fun ls:9 -> case ls:9 of {
//│ 	C h:10 t:11 => [S [N] (sum t:11)]
//│ 	| N => [N]})
//│ def sum^32 = (fun ls:39 -> case ls:39 of {
//│ 	C h:40 t:41 => [S [N] (sum^32_sum^3 t:41)]
//│ 	| N => [N]})
//│ def sum^32_sum^3 = (fun ls:30 -> case ls:30 of {
//│ 	C h:31 t:32 => [S [N] (sum^32_sum^3 t:32)]
//│ 	| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 46: [C 42: (40: primitive 41: ha) 45: (43: mapa^33_mapa^14 44: ta)]
//│ [C (primitive:3 ha:25) (mapa^33_mapa^14 ta:26)] --->
//│ 	case ls:30 of {C h:31 t:32 => [S [N] (sum^32_sum^3 t:32)] | N => [N]}
//│ 47: [N]
//│ [N] --->
//│ 	case ls:30 of {C h:31 t:32 => [S [N] (sum^32_sum^3 t:32)] | N => [N]}
//│ 57: [C 53: (51: primitive 52: hb) 56: (54: mapb^34_mapb^25 55: tb)]
//│ [C (primitive:3 hb:28) (mapb^34_mapb^25 tb:29)] --->
//│ 	case lsa:36 of {C ha:37 ta:38 => [C (primitive:3 ha:37) (mapa^33_mapa^14 ta:38)] | N => [N]}
//│ 58: [N]
//│ [N] --->
//│ 	case lsa:36 of {C ha:37 ta:38 => [C (primitive:3 ha:37) (mapa^33_mapa^14 ta:38)] | N => [N]}
//│ 77: [C 73: (71: primitive 72: hb) 76: (74: mapb^34_mapb^25 75: tb)]
//│ [C (primitive:3 hb:34) (mapb^34_mapb^25 tb:35)] --->
//│ 	case lsa:24 of {C ha:25 ta:26 => [C (primitive:3 ha:25) (mapa^33_mapa^14 ta:26)] | N => [N]}
//│ 78: [N]
//│ [N] --->
//│ 	case lsa:24 of {C ha:25 ta:26 => [C (primitive:3 ha:25) (mapa^33_mapa^14 ta:26)] | N => [N]}
//│ 88: [C 84: (82: primitive 83: ha) 87: (85: mapa^33_mapa^14 86: ta)]
//│ [C (primitive:3 ha:37) (mapa^33_mapa^14 ta:38)] --->
//│ 	case ls:39 of {C h:40 t:41 => [S [N] (sum^32_sum^3 t:41)] | N => [N]}
//│ 89: [N]
//│ [N] --->
//│ 	case ls:39 of {C h:40 t:41 => [S [N] (sum^32_sum^3 t:41)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (sum^32 (mapa^33 (mapb^34 primitive:3)))
//│ def mapa = (fun lsa:12 -> case lsa:12 of {
//│ 	C ha:13 ta:14 => [C (primitive:3 ha:13) (mapa ta:14)]
//│ 	| N => [N]})
//│ def mapa^33 = (fun lsa:36 -> lsa:36)
//│ def mapa^33_mapa^14 = (fun lsa:24 -> lsa:24)
//│ def mapb = (fun lsb:15 -> case lsb:15 of {
//│ 	C hb:16 tb:17 => [C (primitive:3 hb:16) (mapb tb:17)]
//│ 	| N => [N]})
//│ def mapb^34 = (fun lsb:27 -> case lsb:27 of {
//│ 	C hb:28 tb:29 => let ha:37 = (primitive:3 hb:28)
//│ 	in let ta:38 = (mapb^34_mapb^25 tb:29)
//│ 	in let h:40 = (primitive:3 ha:37)
//│ 	in let t:41 = (mapa^33_mapa^14 ta:38)
//│ 	in [S [N] (sum^32_sum^3 t:41)]
//│ 	| N => [N]})
//│ def mapb^34_mapb^25 = (fun lsb:33 -> case lsb:33 of {
//│ 	C hb:34 tb:35 => let ha:25 = (primitive:3 hb:34)
//│ 	in let ta:26 = (mapb^34_mapb^25 tb:35)
//│ 	in let h:31 = (primitive:3 ha:25)
//│ 	in let t:32 = (mapa^33_mapa^14 ta:26)
//│ 	in [S [N] (sum^32_sum^3 t:32)]
//│ 	| N => [N]})
//│ def sum = (fun ls:9 -> case ls:9 of {
//│ 	C h:10 t:11 => [S [N] (sum t:11)]
//│ 	| N => [N]})
//│ def sum^32 = (fun ls:39 -> ls:39)
//│ def sum^32_sum^3 = (fun ls:30 -> ls:30)
//│ <<<<<<< after fusion <<<<<<<



let rec p = C(p)
fun c(x) = if x is
    C(a) then c(a)
fun main(cc) = cc(p)
main(c)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|cc|)| |#=| |cc|(|p|)|↵|main|(|c|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = cc, => cc (p,); main (c,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (main^13 c^14)
//│ def c = (fun x:9 -> case x:9 of {
//│ 	C a:10 => (c^4 a:10)})
//│ def main = (fun cc:11 -> (cc:11 p^10))
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('p:6) <: 'x:9
//│ 	[-p^1 · -p^10 · -main^13 · +c^14 · +c^4]  --->  [-p^10 · -main^13 · +c^14]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c^14 · c^4] --> [c^14]
//│ [main^13 · p^10 · p^1] --> [main^13 · p^10]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^14]
//│ 	[c^14 · c^4] ---> [c^14] (only one)
//│ [main^13]
//│ 	[main^13 · p^10]
//│ 		[main^13 · p^10 · p^1] ---> [main^13 · p^10] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (main^13 c^14)
//│ def c = (fun x:9 -> case x:9 of {
//│ 	C a:10 => (c a:10)})
//│ def c^14 = (fun x:15 -> case x:15 of {
//│ 	C a:16 => (c^14 a:16)})
//│ def main = (fun cc:11 -> (cc:11 p))
//│ def main^13 = (fun cc:17 -> (cc:17 main^13_p^10))
//│ def main^13_p^10 = [C main^13_p^10]
//│ def p = [C p]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 17: [C 16: main^13_p^10]
//│ [C main^13_p^10] --->
//│ 	case x:15 of {C a:16 => (c^14 a:16)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (main^13 c^14)
//│ def c = (fun x:9 -> case x:9 of {
//│ 	C a:10 => (c a:10)})
//│ def c^14 = (fun x:15 -> x:15)
//│ def main = (fun cc:11 -> (cc:11 p))
//│ def main^13 = (fun cc:17 -> (cc:17 main^13_p^10))
//│ def main^13_p^10 = let a:16 = main^13_p^10
//│ in (c^14 a:16)
//│ def p = [C p]
//│ <<<<<<< after fusion <<<<<<<


// this path seems also to be sensible
let rec p = C(p)
fun c(x) = if x is
    C(a) then c(a)
fun main(pp) = if pp is
    C(b) then if b is
        C(d) then c(d)
main(p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|pp|)| |#=| |#if| |pp| |is|→|C|(|b|)| |#then| |#if| |b| |is|→|C|(|d|)| |#then| |c|(|d|)|←|←|↵|main|(|p|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = pp, => if pp is ‹(C (b,)) then if b is ‹(C (d,)) then c (d,)››; main (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (main^17 p^18)
//│ def c = (fun x:9 -> case x:9 of {
//│ 	C a:10 => (c^4 a:10)})
//│ def main = (fun pp:11 -> case pp:11 of {
//│ 	C b:12 => case b:12 of {
//│ 		C d:13 => (c^11 d:13)}})
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('p:6) <: 'x:9
//│ 	[-p^1 · -p^1 · -p^1 · -p^18 · +main^17 · +c^11 · +c^4]  --->  [-p^1 · -p^1 · -p^18 · +main^17 · +c^11]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [main^17 · c^11 · c^4] --> [main^17 · c^11]
//│ [p^18 · p^1 · p^1 · p^1] --> [p^18 · p^1 · p^1]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [main^17]
//│ 	[main^17 · c^11]
//│ 		[main^17 · c^11 · c^4] ---> [main^17 · c^11] (only one)
//│ [p^18]
//│ 	[p^18 · p^1]
//│ 		[p^18 · p^1 · p^1]
//│ 			[p^18 · p^1 · p^1 · p^1] ---> [p^18 · p^1 · p^1] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (main^17 p^18)
//│ def c = (fun x:9 -> case x:9 of {
//│ 	C a:10 => (c a:10)})
//│ def main = (fun pp:11 -> case pp:11 of {
//│ 	C b:12 => case b:12 of {
//│ 		C d:13 => (c d:13)}})
//│ def main^17 = (fun pp:19 -> case pp:19 of {
//│ 	C b:20 => case b:20 of {
//│ 		C d:21 => (main^17_c^11 d:21)}})
//│ def main^17_c^11 = (fun x:22 -> case x:22 of {
//│ 	C a:23 => (main^17_c^11 a:23)})
//│ def p = [C p]
//│ def p^18 = [C p^18_p^1]
//│ def p^18_p^1 = [C p^18_p^1_p^1]
//│ def p^18_p^1_p^1 = [C p^18_p^1_p^1]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 21: [C 20: p^18_p^1_p^1]
//│ [C p^18_p^1_p^1] --->
//│ 	case b:20 of {C d:21 => (main^17_c^11 d:21)}
//│ 23: [C 22: p^18_p^1]
//│ [C p^18_p^1] --->
//│ 	case pp:19 of {C b:20 => case b:20 of {C d:21 => (main^17_c^11 d:21)}}
//│ 33: [C 32: p^18_p^1_p^1]
//│ [C p^18_p^1_p^1] --->
//│ 	case x:22 of {C a:23 => (main^17_c^11 a:23)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (main^17 p^18)
//│ def c = (fun x:9 -> case x:9 of {
//│ 	C a:10 => (c a:10)})
//│ def main = (fun pp:11 -> case pp:11 of {
//│ 	C b:12 => case b:12 of {
//│ 		C d:13 => (c d:13)}})
//│ def main^17 = (fun pp:19 -> pp:19)
//│ def main^17_c^11 = (fun x:22 -> x:22)
//│ def p = [C p]
//│ def p^18 = let b:20 = p^18_p^1
//│ in b:20
//│ def p^18_p^1 = let d:21 = p^18_p^1_p^1
//│ in (main^17_c^11 d:21)
//│ def p^18_p^1_p^1 = let a:23 = p^18_p^1_p^1
//│ in (main^17_c^11 a:23)
//│ <<<<<<< after fusion <<<<<<<


let rec p = C(p)
let c(x) = if x is
    C(a) then c(a)
fun main(cc, pp) = cc(pp)
main(c, p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#let| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|cc|,| |pp|)| |#=| |cc|(|pp|)|↵|main|(|c|,| |p|)|
//│ Parsed: {let rec p = C (p,); let c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = cc, pp, => cc (pp,); main (c, p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((main^14 c^15) p^17)
//│ def c = (fun x:9 -> case x:9 of {
//│ 	C a:10 => (c^4 a:10)})
//│ def main = (fun cc:11 -> (fun pp:12 -> (cc:11 pp:12)))
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('p:6) <: 'x:9
//│ 	[-p^1 · -p^17 · +main^14 · -main^14 · +c^15 · +c^4]  --->  [-p^17 · +main^14 · -main^14 · +c^15]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c^15 · c^4] --> [c^15]
//│ [p^17 · p^1] --> [p^17]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^15]
//│ 	[c^15 · c^4] ---> [c^15] (only one)
//│ [main^14] ---> [main^14] (hopeless to continue)
//│ [p^17]
//│ 	[p^17 · p^1] ---> [p^17] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((main c^15) p^17)
//│ def c = (fun x:9 -> case x:9 of {
//│ 	C a:10 => (c a:10)})
//│ def c^15 = (fun x:15 -> case x:15 of {
//│ 	C a:16 => (c^15 a:16)})
//│ def main = (fun cc:11 -> (fun pp:12 -> (cc:11 pp:12)))
//│ def p = [C p]
//│ def p^17 = [C p^17]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 26: [C 25: p^17]
//│ [C p^17] --->
//│ 	case x:15 of {C a:16 => (c^15 a:16)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((main c^15) p^17)
//│ def c = (fun x:9 -> case x:9 of {
//│ 	C a:10 => (c a:10)})
//│ def c^15 = (fun x:15 -> x:15)
//│ def main = (fun cc:11 -> (fun pp:12 -> (cc:11 pp:12)))
//│ def p = [C p]
//│ def p^17 = let a:16 = p^17
//│ in (c^15 a:16)
//│ <<<<<<< after fusion <<<<<<<


fun cons(y) = if y is
    C(aa) then cons(aa)
fun a(x) = b(x)
fun b(x) = c(x)
fun c(x) = d(cons, x)
fun d(cc, x) = cc(x)
let p = C(p)
a(p)
//│ |#fun| |cons|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |cons|(|aa|)|←|↵|#fun| |a|(|x|)| |#=| |b|(|x|)|↵|#fun| |b|(|x|)| |#=| |c|(|x|)|↵|#fun| |c|(|x|)| |#=| |d|(|cons|,| |x|)|↵|#fun| |d|(|cc|,| |x|)| |#=| |cc|(|x|)|↵|#let| |p| |#=| |C|(|p|)|↵|a|(|p|)|
//│ Parsed: {fun cons = y, => if y is ‹(C (aa,)) then cons (aa,)›; fun a = x, => b (x,); fun b = x, => c (x,); fun c = x, => d (cons, x,); fun d = cc, x, => cc (x,); let p = C (p,); a (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (a^28 p^29)
//│ def a = (fun x:14 -> (b^7 x:14))
//│ def b = (fun x:15 -> (c^11 x:15))
//│ def c = (fun x:16 -> ((d^15 cons^16) x:16))
//│ def cons = (fun y:12 -> case y:12 of {
//│ 	C aa:13 => (cons^2 aa:13)})
//│ def d = (fun cc:17 -> (fun x:18 -> (cc:17 x:18)))
//│ def p = [C p^26]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('p:11) <: 'y:12
//│ 	[-p^26 · -p^26 · -p^29 · +a^28 · +b^7 · +c^11 · +d^15 · -d^15 · +cons^16 · +cons^2 · +cons^2]  --->  [-p^26 · -p^29 · +a^28 · +b^7 · +c^11 · +d^15 · -d^15 · +cons^16 · +cons^2]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [a^28 · b^7 · c^11 · cons^16 · cons^2 · cons^2] --> [a^28 · b^7 · c^11 · cons^16 · cons^2]
//│ [p^29 · p^26 · p^26] --> [p^29 · p^26]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [a^28]
//│ 	[a^28 · b^7]
//│ 		[a^28 · b^7 · c^11]
//│ 			[a^28 · b^7 · c^11 · cons^16]
//│ 				[a^28 · b^7 · c^11 · cons^16 · cons^2]
//│ 					[a^28 · b^7 · c^11 · cons^16 · cons^2 · cons^2] ---> [a^28 · b^7 · c^11 · cons^16 · cons^2] (only one)
//│ 			[a^28 · b^7 · c^11 · d^15] ---> [d^15] (hopeless to continue)
//│ [p^29]
//│ 	[p^29 · p^26]
//│ 		[p^29 · p^26 · p^26] ---> [p^29 · p^26] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (a^28 p^29)
//│ def a = (fun x:12 -> (b x:12))
//│ def a^28 = (fun x:32 -> (a^28_b^7 x:32))
//│ def a^28_b^7 = (fun x:27 -> (a^28_b^7_c^11 x:27))
//│ def a^28_b^7_c^11 = (fun x:26 -> ((d a^28_b^7_c^11_cons^16) x:26))
//│ def a^28_b^7_c^11_cons^16 = (fun y:30 -> case y:30 of {
//│ 	C aa:31 => (a^28_b^7_c^11_cons^16_cons^2 aa:31)})
//│ def a^28_b^7_c^11_cons^16_cons^2 = (fun y:28 -> case y:28 of {
//│ 	C aa:29 => (a^28_b^7_c^11_cons^16_cons^2 aa:29)})
//│ def b = (fun x:15 -> (c x:15))
//│ def c = (fun x:16 -> ((d cons) x:16))
//│ def cons = (fun y:13 -> case y:13 of {
//│ 	C aa:14 => (cons aa:14)})
//│ def d = (fun cc:17 -> (fun x:18 -> (cc:17 x:18)))
//│ def p = [C p]
//│ def p^29 = [C p^29_p^26]
//│ def p^29_p^26 = [C p^29_p^26]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 54: [C 53: p^29_p^26]
//│ [C p^29_p^26] --->
//│ 	case y:13 of {C aa:14 => (cons aa:14)}
//│ 	case y:30 of {C aa:31 => (a^28_b^7_c^11_cons^16_cons^2 aa:31)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 56: [C 55: p^29_p^26]
//│ [C p^29_p^26] --->
//│ 	case y:28 of {C aa:29 => (a^28_b^7_c^11_cons^16_cons^2 aa:29)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (a^28 p^29)
//│ def a = (fun x:12 -> (b x:12))
//│ def a^28 = (fun x:32 -> (a^28_b^7 x:32))
//│ def a^28_b^7 = (fun x:27 -> (a^28_b^7_c^11 x:27))
//│ def a^28_b^7_c^11 = (fun x:26 -> ((d a^28_b^7_c^11_cons^16) x:26))
//│ def a^28_b^7_c^11_cons^16 = (fun y:30 -> case y:30 of {
//│ 	C aa:31 => (a^28_b^7_c^11_cons^16_cons^2 aa:31)})
//│ def a^28_b^7_c^11_cons^16_cons^2 = (fun y:28 -> y:28)
//│ def b = (fun x:15 -> (c x:15))
//│ def c = (fun x:16 -> ((d cons) x:16))
//│ def cons = (fun y:13 -> y:13)
//│ def d = (fun cc:17 -> (fun x:18 -> (cc:17 x:18)))
//│ def p = [C p]
//│ def p^29 = let aa:14 = p^29_p^26
//│ in (cons aa:14)
//│ def p^29_p^26 = let aa:29 = p^29_p^26
//│ in (a^28_b^7_c^11_cons^16_cons^2 aa:29)
//│ <<<<<<< after fusion <<<<<<<


let p = C(N)
fun c(x) = if C(x) is
    C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|N|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (N,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^10 p^11)
//│ def c = (fun x:8 -> case [C x:8] of {
//│ 	C a:9 => (c^5 a:9)})
//│ def p = [C [N]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^10] ---> [c^10] (hopeless to continue)
//│ [p^11] ---> [p^11] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c p)
//│ def c = (fun x:8 -> case [C x:8] of {
//│ 	C a:9 => (c a:9)})
//│ def p = [C [N]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 7: [C 6: x]
//│ [C x:8] --->
//│ 	case [C x:8] of {C a:9 => (c a:9)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c p)
//│ def c = (fun x:8 -> let a:9 = x:8
//│ in (c a:9))
//│ def p = [C [N]]
//│ <<<<<<< after fusion <<<<<<<


// let rec p = C(p)
// let q = p
// fun c(x) = if x is
//     C(a) then a
// fun c2(z) = if z is
//     C(b) then c2(b)
// let main = c(q)
// c2(main)


let rec p = C(p)
fun c(x) = if x is
    C(a) then a
fun c1(xx) = if xx is
    C(aa) then aa
fun c2(z) = if z is
    C(b) then c2(b)
let main = c(p)
fun id(y) = c1(C(y))
c2(id(main))
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |a|←|↵|#fun| |c1|(|xx|)| |#=| |#if| |xx| |is|→|C|(|aa|)| |#then| |aa|←|↵|#fun| |c2|(|z|)| |#=| |#if| |z| |is|→|C|(|b|)| |#then| |c2|(|b|)|←|↵|#let| |main| |#=| |c|(|p|)|↵|#fun| |id|(|y|)| |#=| |c1|(|C|(|y|)|)|↵|c2|(|id|(|main|)|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then a›; fun c1 = xx, => if xx is ‹(C (aa,)) then aa›; fun c2 = z, => if z is ‹(C (b,)) then c2 (b,)›; let main = c (p,); fun id = y, => c1 (C (y,),); c2 (id (main,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c2^25 (id^26 main^27))
//│ def c = (fun x:12 -> case x:12 of {
//│ 	C a:13 => a:13})
//│ def c1 = (fun xx:14 -> case xx:14 of {
//│ 	C aa:15 => aa:15})
//│ def c2 = (fun z:16 -> case z:16 of {
//│ 	C b:17 => (c2^12 b:17)})
//│ def id = (fun y:18 -> (c1^20 [C y:18]))
//│ def main = (c^17 p^18)
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('p:6) <: 'z:16
//│ 	[-p^1 · -p^1 · -p^18 · +c^17 · -c^17 · -main^27 · +id^26 · +c1^20 · -c1^20 · -id^26 · +c2^25 · +c2^12]  --->  [-p^1 · -p^18 · +c^17 · -c^17 · -main^27 · +id^26 · +c1^20 · -c1^20 · -id^26 · +c2^25]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c2^25 · c2^12] --> [c2^25]
//│ [main^27 · p^18 · p^1 · p^1] --> [main^27 · p^18 · p^1]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c2^25]
//│ 	[c2^25 · c2^12] ---> [c2^25] (only one)
//│ [id^26] ---> [id^26] (hopeless to continue)
//│ [main^27]
//│ 	[main^27 · c^17] ---> [c^17] (hopeless to continue)
//│ 	[main^27 · p^18]
//│ 		[main^27 · p^18 · p^1]
//│ 			[main^27 · p^18 · p^1 · p^1] ---> [main^27 · p^18 · p^1] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c2^25 (id main^27))
//│ def c = (fun x:17 -> case x:17 of {
//│ 	C a:18 => a:18})
//│ def c1 = (fun xx:13 -> case xx:13 of {
//│ 	C aa:14 => aa:14})
//│ def c2 = (fun z:15 -> case z:15 of {
//│ 	C b:16 => (c2 b:16)})
//│ def c2^25 = (fun z:23 -> case z:23 of {
//│ 	C b:24 => (c2^25 b:24)})
//│ def id = (fun y:12 -> (c1 [C y:12]))
//│ def main = (c p)
//│ def main^27 = (c main^27_p^18)
//│ def main^27_p^18 = [C main^27_p^18_p^1]
//│ def main^27_p^18_p^1 = [C main^27_p^18_p^1]
//│ def p = [C p]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 25: [C 24: p]
//│ [C p] --->
//│ 	case x:17 of {C a:18 => a:18}
//│ 	case z:23 of {C b:24 => (c2^25 b:24)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 37: [C 36: main^27_p^18_p^1]
//│ [C main^27_p^18_p^1] --->
//│ 	case x:17 of {C a:18 => a:18}
//│ 42: [C 41: main^27_p^18_p^1]
//│ [C main^27_p^18_p^1] --->
//│ 	case z:23 of {C b:24 => (c2^25 b:24)}
//│ 8: [C 7: y]
//│ [C y:12] --->
//│ 	case xx:13 of {C aa:14 => aa:14}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c2^25 (id main^27))
//│ def c = (fun x:17 -> x:17)
//│ def c1 = (fun xx:13 -> xx:13)
//│ def c2 = (fun z:15 -> case z:15 of {
//│ 	C b:16 => (c2 b:16)})
//│ def c2^25 = (fun z:23 -> z:23)
//│ def id = (fun y:12 -> (c1 let aa:14 = y:12
//│ in aa:14))
//│ def main = (c p)
//│ def main^27 = (c main^27_p^18)
//│ def main^27_p^18 = let a:18 = main^27_p^18_p^1
//│ in a:18
//│ def main^27_p^18_p^1 = let b:24 = main^27_p^18_p^1
//│ in (c2^25 b:24)
//│ def p = let a:18 = p
//│ in a:18
//│ <<<<<<< after fusion <<<<<<<


let t = T(K, T(N, L, L), T(N, L, L))
fun c(x) = if x is
    T(n, l, r) then T(
        (if n is
            K then KK
            N then NN
        ),
        c(l),
        c(r)
    )
    L then LL
c(t)
//│ |#let| |t| |#=| |T|(|K|,| |T|(|N|,| |L|,| |L|)|,| |T|(|N|,| |L|,| |L|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let t = T (K, T (N, L, L,), T (N, L, L,),); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^26 t^27)
//│ def c = (fun x:8 -> case x:8 of {
//│ 	T n:9 l:10 r:11 => [T case n:9 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^16 l:10) (c^19 r:11)]
//│ 	| L => [LL]})
//│ def t = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 'r:11
//│ 	[-t^27 · +c^26 · +c^16 · +c^16 · +c^19]  --->  [-t^27 · +c^26 · +c^16 · +c^16]
//│ 	[-t^27 · +c^26 · +c^16 · +c^19 · +c^19]  --->  [-t^27 · +c^26 · +c^16 · +c^19]
//│ 	[-t^27 · +c^26 · +c^19 · +c^19 · +c^19]  --->  [-t^27 · +c^26 · +c^19 · +c^19]
//│ 	[-t^27 · +c^26 · +c^19 · +c^16 · +c^19]  --->  [-t^27 · +c^26 · +c^19 · +c^16]
//│ NoProd <: 'l:10
//│ 	[-t^27 · +c^26 · +c^19 · +c^16 · +c^16]  --->  [-t^27 · +c^26 · +c^19 · +c^16]
//│ 	[-t^27 · +c^26 · +c^16 · +c^16 · +c^16]  --->  [-t^27 · +c^26 · +c^16 · +c^16]
//│ 	[-t^27 · +c^26 · +c^19 · +c^19 · +c^16]  --->  [-t^27 · +c^26 · +c^19 · +c^19]
//│ 	[-t^27 · +c^26 · +c^16 · +c^19 · +c^16]  --->  [-t^27 · +c^26 · +c^16 · +c^19]
//│ NoProd <: 'x:8
//│ 	[-t^27 · +c^26 · +c^16 · +c^16 · +c^16 · +c^19]  --->  [-t^27 · +c^26 · +c^16 · +c^16 · +c^16]
//│ 	[-t^27 · +c^26 · +c^19 · +c^19 · +c^19 · +c^16]  --->  [-t^27 · +c^26 · +c^19 · +c^19 · +c^19]
//│ 	[-t^27 · +c^26 · +c^16 · +c^19 · +c^19 · +c^16]  --->  [-t^27 · +c^26 · +c^16 · +c^19 · +c^19]
//│ 	[-t^27 · +c^26 · +c^19 · +c^19 · +c^16 · +c^19]  --->  [-t^27 · +c^26 · +c^19 · +c^19 · +c^16]
//│ 	[-t^27 · +c^26 · +c^19 · +c^16 · +c^16 · +c^19]  --->  [-t^27 · +c^26 · +c^19 · +c^16 · +c^16]
//│ 	[-t^27 · +c^26 · +c^16 · +c^16 · +c^19 · +c^16]  --->  [-t^27 · +c^26 · +c^16 · +c^16 · +c^19]
//│ 	[-t^27 · +c^26 · +c^19 · +c^16 · +c^19 · +c^16]  --->  [-t^27 · +c^26 · +c^19 · +c^16 · +c^19]
//│ 	[-t^27 · +c^26 · +c^16 · +c^19 · +c^16 · +c^19]  --->  [-t^27 · +c^26 · +c^16 · +c^19 · +c^16]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c^26 · c^16 · c^19 · c^19 · c^16] --> [c^26 · c^16 · c^19 · c^19]
//│ [c^26 · c^19 · c^19 · c^16 · c^19] --> [c^26 · c^19 · c^19 · c^16]
//│ [c^26 · c^19 · c^19 · c^19 · c^16] --> [c^26 · c^19 · c^19 · c^19]
//│ [c^26 · c^19 · c^16 · c^16 · c^19] --> [c^26 · c^19 · c^16 · c^16]
//│ [c^26 · c^16 · c^19 · c^16 · c^19] --> [c^26 · c^16 · c^19 · c^16]
//│ [c^26 · c^16 · c^16 · c^16 · c^19] --> [c^26 · c^16 · c^16 · c^16]
//│ [c^26 · c^16 · c^16 · c^19 · c^16] --> [c^26 · c^16 · c^16 · c^19]
//│ [c^26 · c^19 · c^16 · c^19 · c^16] --> [c^26 · c^19 · c^16 · c^19]
//│ [c^26 · c^16 · c^19 · c^16] --> [c^26 · c^16 · c^19]
//│ [c^26 · c^16 · c^19 · c^19] --> [c^26 · c^16 · c^19]
//│ [c^26 · c^19 · c^16 · c^19] --> [c^26 · c^19 · c^16]
//│ [c^26 · c^19 · c^19 · c^16] --> [c^26 · c^19 · c^19]
//│ [c^26 · c^19 · c^19 · c^19] --> [c^26 · c^19 · c^19]
//│ [c^26 · c^16 · c^16 · c^19] --> [c^26 · c^16 · c^16]
//│ [c^26 · c^19 · c^16 · c^16] --> [c^26 · c^19 · c^16]
//│ [c^26 · c^16 · c^16 · c^16] --> [c^26 · c^16 · c^16]
//│ [t^27] --> [t^27]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^26]
//│ 	[c^26 · c^16]
//│ 		[c^26 · c^16 · c^16]
//│ 			[c^26 · c^16 · c^16 · c^16] ---> [c^26 · c^16 · c^16] (only one)
//│ 			[c^26 · c^16 · c^16 · c^19] ---> [c^26 · c^16 · c^16] (only one)
//│ 		[c^26 · c^16 · c^19]
//│ 			[c^26 · c^16 · c^19 · c^16] ---> [c^26 · c^16 · c^19] (only one)
//│ 			[c^26 · c^16 · c^19 · c^19] ---> [c^26 · c^16 · c^19] (only one)
//│ 	[c^26 · c^19]
//│ 		[c^26 · c^19 · c^16]
//│ 			[c^26 · c^19 · c^16 · c^16] ---> [c^26 · c^19 · c^16] (only one)
//│ 			[c^26 · c^19 · c^16 · c^19] ---> [c^26 · c^19 · c^16] (only one)
//│ 		[c^26 · c^19 · c^19]
//│ 			[c^26 · c^19 · c^19 · c^16] ---> [c^26 · c^19 · c^19] (only one)
//│ 			[c^26 · c^19 · c^19 · c^19] ---> [c^26 · c^19 · c^19] (only one)
//│ [t^27]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c^26 t^27)
//│ def c = (fun x:8 -> case x:8 of {
//│ 	T n:9 l:10 r:11 => [T case n:9 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c l:10) (c r:11)]
//│ 	| L => [LL]})
//│ def c^26 = (fun x:20 -> case x:20 of {
//│ 	T n:21 l:22 r:23 => [T case n:21 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^26_c^16 l:22) (c^26_c^19 r:23)]
//│ 	| L => [LL]})
//│ def c^26_c^16 = (fun x:32 -> case x:32 of {
//│ 	T n:33 l:34 r:35 => [T case n:33 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^26_c^16_c^16 l:34) (c^26_c^16_c^19 r:35)]
//│ 	| L => [LL]})
//│ def c^26_c^16_c^16 = (fun x:28 -> case x:28 of {
//│ 	T n:29 l:30 r:31 => [T case n:29 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^26_c^16_c^16 l:30) (c^26_c^16_c^16 r:31)]
//│ 	| L => [LL]})
//│ def c^26_c^16_c^19 = (fun x:40 -> case x:40 of {
//│ 	T n:41 l:42 r:43 => [T case n:41 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^26_c^16_c^19 l:42) (c^26_c^16_c^19 r:43)]
//│ 	| L => [LL]})
//│ def c^26_c^19 = (fun x:36 -> case x:36 of {
//│ 	T n:37 l:38 r:39 => [T case n:37 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^26_c^19_c^16 l:38) (c^26_c^19_c^19 r:39)]
//│ 	| L => [LL]})
//│ def c^26_c^19_c^16 = (fun x:24 -> case x:24 of {
//│ 	T n:25 l:26 r:27 => [T case n:25 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^26_c^19_c^16 l:26) (c^26_c^19_c^16 r:27)]
//│ 	| L => [LL]})
//│ def c^26_c^19_c^19 = (fun x:44 -> case x:44 of {
//│ 	T n:45 l:46 r:47 => [T case n:45 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^26_c^19_c^19 l:46) (c^26_c^19_c^19 r:47)]
//│ 	| L => [LL]})
//│ def t = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ def t^27 = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 59: [K]
//│ [K] --->
//│ 	case n:21 of {K => [KK] | N => [NN]}
//│ 60: [N]
//│ [N] --->
//│ 	case n:33 of {K => [KK] | N => [NN]}
//│ 61: [L]
//│ [L] --->
//│ 	case x:28 of {T n:29 l:30 r:31 => [T case n:29 of {K => [KK] | N => [NN]} (c^26_c^16_c^16 l:30) (c^26_c^16_c^16 r:31)] | L => [LL]}
//│ 62: [L]
//│ [L] --->
//│ 	case x:40 of {T n:41 l:42 r:43 => [T case n:41 of {K => [KK] | N => [NN]} (c^26_c^16_c^19 l:42) (c^26_c^16_c^19 r:43)] | L => [LL]}
//│ 63: [T 60: [N] 61: [L] 62: [L]]
//│ [T [N] [L] [L]] --->
//│ 	case x:32 of {T n:33 l:34 r:35 => [T case n:33 of {K => [KK] | N => [NN]} (c^26_c^16_c^16 l:34) (c^26_c^16_c^19 r:35)] | L => [LL]}
//│ 64: [N]
//│ [N] --->
//│ 	case n:37 of {K => [KK] | N => [NN]}
//│ 65: [L]
//│ [L] --->
//│ 	case x:24 of {T n:25 l:26 r:27 => [T case n:25 of {K => [KK] | N => [NN]} (c^26_c^19_c^16 l:26) (c^26_c^19_c^16 r:27)] | L => [LL]}
//│ 66: [L]
//│ [L] --->
//│ 	case x:44 of {T n:45 l:46 r:47 => [T case n:45 of {K => [KK] | N => [NN]} (c^26_c^19_c^19 l:46) (c^26_c^19_c^19 r:47)] | L => [LL]}
//│ 67: [T 64: [N] 65: [L] 66: [L]]
//│ [T [N] [L] [L]] --->
//│ 	case x:36 of {T n:37 l:38 r:39 => [T case n:37 of {K => [KK] | N => [NN]} (c^26_c^19_c^16 l:38) (c^26_c^19_c^19 r:39)] | L => [LL]}
//│ 68: [T 59: [K] 63: [T 60: [N] 61: [L] 62: [L]] 67: [T 64: [N] 65: [L] 66: [L]]]
//│ [T [K] [T [N] [L] [L]] [T [N] [L] [L]]] --->
//│ 	case x:20 of {T n:21 l:22 r:23 => [T case n:21 of {K => [KK] | N => [NN]} (c^26_c^16 l:22) (c^26_c^19 r:23)] | L => [LL]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c^26 t^27)
//│ def c = (fun x:8 -> case x:8 of {
//│ 	T n:9 l:10 r:11 => [T case n:9 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c l:10) (c r:11)]
//│ 	| L => [LL]})
//│ def c^26 = (fun x:20 -> x:20)
//│ def c^26_c^16 = (fun x:32 -> x:32)
//│ def c^26_c^16_c^16 = (fun x:28 -> x:28)
//│ def c^26_c^16_c^19 = (fun x:40 -> x:40)
//│ def c^26_c^19 = (fun x:36 -> x:36)
//│ def c^26_c^19_c^16 = (fun x:24 -> x:24)
//│ def c^26_c^19_c^19 = (fun x:44 -> x:44)
//│ def t = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ def t^27 = let n:21 = [KK]
//│ in let l:22 = 
//│ 	let n:33 = [NN]
//│ 	in let l:34 = [LL]
//│ 	in let r:35 = [LL]
//│ 	in [T n:33 (c^26_c^16_c^16 l:34) (c^26_c^16_c^19 r:35)]
//│ in let r:23 = 
//│ 	let n:37 = [NN]
//│ 	in let l:38 = [LL]
//│ 	in let r:39 = [LL]
//│ 	in [T n:37 (c^26_c^19_c^16 l:38) (c^26_c^19_c^19 r:39)]
//│ in [T n:21 (c^26_c^16 l:22) (c^26_c^19 r:23)]
//│ <<<<<<< after fusion <<<<<<<


let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
    T(n, l, r) then T(
        (if n is
            K then KK
            N then NN
        ),
        c(l),
        c(r)
    )
    L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^28 t^29)
//│ def aa = [T [N] [L] [L]]
//│ def bb = [T [N] [L] [L]]
//│ def c = (fun x:10 -> case x:10 of {
//│ 	T n:11 l:12 r:13 => [T case n:11 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^18 l:12) (c^21 r:13)]
//│ 	| L => [LL]})
//│ def t = [T [K] aa^10 bb^11]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 'l:12
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^18 · +c^18]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^18]
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^21 · +c^18]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^21]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^21 · +c^18]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^21]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^18 · +c^18]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^18]
//│ NoProd <: 'r:13
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^21 · +c^21]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^21]
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^18 · +c^21]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^18]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^21 · +c^21]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^21]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^18 · +c^21]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^18]
//│ NoProd <: 'x:10
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^21 · +c^21 · +c^18]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^21 · +c^21]
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^18 · +c^18 · +c^21]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^18 · +c^18]
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^21 · +c^18 · +c^21]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^21 · +c^18]
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^18 · +c^21 · +c^18]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^18 · +c^21]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^18 · +c^18 · +c^21]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^18 · +c^18]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^21 · +c^21 · +c^18]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^21 · +c^21]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^21 · +c^18 · +c^21]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^21 · +c^18]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^18 · +c^21 · +c^18]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^18 · +c^21]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c^28 · c^18 · c^21 · c^18 · c^21] --> [c^28 · c^18 · c^21 · c^18]
//│ [c^28 · c^21 · c^21 · c^21 · c^18] --> [c^28 · c^21 · c^21 · c^21]
//│ [c^28 · c^18 · c^21 · c^21 · c^18] --> [c^28 · c^18 · c^21 · c^21]
//│ [c^28 · c^18 · c^18 · c^18 · c^21] --> [c^28 · c^18 · c^18 · c^18]
//│ [c^28 · c^21 · c^18 · c^21 · c^18] --> [c^28 · c^21 · c^18 · c^21]
//│ [c^28 · c^18 · c^18 · c^21 · c^18] --> [c^28 · c^18 · c^18 · c^21]
//│ [c^28 · c^21 · c^18 · c^18 · c^21] --> [c^28 · c^21 · c^18 · c^18]
//│ [c^28 · c^21 · c^21 · c^18 · c^21] --> [c^28 · c^21 · c^21 · c^18]
//│ [c^28 · c^18 · c^18 · c^18] --> [c^28 · c^18 · c^18]
//│ [c^28 · c^21 · c^21 · c^21] --> [c^28 · c^21 · c^21]
//│ [c^28 · c^18 · c^18 · c^21] --> [c^28 · c^18 · c^18]
//│ [c^28 · c^18 · c^21 · c^21] --> [c^28 · c^18 · c^21]
//│ [c^28 · c^21 · c^18 · c^21] --> [c^28 · c^21 · c^18]
//│ [c^28 · c^21 · c^21 · c^18] --> [c^28 · c^21 · c^21]
//│ [c^28 · c^21 · c^18 · c^18] --> [c^28 · c^21 · c^18]
//│ [c^28 · c^18 · c^21 · c^18] --> [c^28 · c^18 · c^21]
//│ [t^29 · aa^10] --> [t^29 · aa^10]
//│ [t^29 · bb^11] --> [t^29 · bb^11]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^28]
//│ 	[c^28 · c^21]
//│ 		[c^28 · c^21 · c^21]
//│ 			[c^28 · c^21 · c^21 · c^21] ---> [c^28 · c^21 · c^21] (only one)
//│ 			[c^28 · c^21 · c^21 · c^18] ---> [c^28 · c^21 · c^21] (only one)
//│ 		[c^28 · c^21 · c^18]
//│ 			[c^28 · c^21 · c^18 · c^21] ---> [c^28 · c^21 · c^18] (only one)
//│ 			[c^28 · c^21 · c^18 · c^18] ---> [c^28 · c^21 · c^18] (only one)
//│ 	[c^28 · c^18]
//│ 		[c^28 · c^18 · c^21]
//│ 			[c^28 · c^18 · c^21 · c^21] ---> [c^28 · c^18 · c^21] (only one)
//│ 			[c^28 · c^18 · c^21 · c^18] ---> [c^28 · c^18 · c^21] (only one)
//│ 		[c^28 · c^18 · c^18]
//│ 			[c^28 · c^18 · c^18 · c^21] ---> [c^28 · c^18 · c^18] (only one)
//│ 			[c^28 · c^18 · c^18 · c^18] ---> [c^28 · c^18 · c^18] (only one)
//│ [t^29]
//│ 	[t^29 · bb^11]
//│ 	[t^29 · aa^10]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c^28 t^29)
//│ def aa = [T [N] [L] [L]]
//│ def bb = [T [N] [L] [L]]
//│ def c = (fun x:10 -> case x:10 of {
//│ 	T n:11 l:12 r:13 => [T case n:11 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c l:12) (c r:13)]
//│ 	| L => [LL]})
//│ def c^28 = (fun x:40 -> case x:40 of {
//│ 	T n:41 l:42 r:43 => [T case n:41 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^28_c^18 l:42) (c^28_c^21 r:43)]
//│ 	| L => [LL]})
//│ def c^28_c^18 = (fun x:48 -> case x:48 of {
//│ 	T n:49 l:50 r:51 => [T case n:49 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^28_c^18_c^18 l:50) (c^28_c^18_c^21 r:51)]
//│ 	| L => [LL]})
//│ def c^28_c^18_c^18 = (fun x:24 -> case x:24 of {
//│ 	T n:25 l:26 r:27 => [T case n:25 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^28_c^18_c^18 l:26) (c^28_c^18_c^18 r:27)]
//│ 	| L => [LL]})
//│ def c^28_c^18_c^21 = (fun x:44 -> case x:44 of {
//│ 	T n:45 l:46 r:47 => [T case n:45 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^28_c^18_c^21 l:46) (c^28_c^18_c^21 r:47)]
//│ 	| L => [LL]})
//│ def c^28_c^21 = (fun x:36 -> case x:36 of {
//│ 	T n:37 l:38 r:39 => [T case n:37 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^28_c^21_c^18 l:38) (c^28_c^21_c^21 r:39)]
//│ 	| L => [LL]})
//│ def c^28_c^21_c^18 = (fun x:28 -> case x:28 of {
//│ 	T n:29 l:30 r:31 => [T case n:29 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^28_c^21_c^18 l:30) (c^28_c^21_c^18 r:31)]
//│ 	| L => [LL]})
//│ def c^28_c^21_c^21 = (fun x:32 -> case x:32 of {
//│ 	T n:33 l:34 r:35 => [T case n:33 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^28_c^21_c^21 l:34) (c^28_c^21_c^21 r:35)]
//│ 	| L => [LL]})
//│ def t = [T [K] aa bb]
//│ def t^29 = [T [K] t^29_aa^10 t^29_bb^11]
//│ def t^29_aa^10 = [T [N] [L] [L]]
//│ def t^29_bb^11 = [T [N] [L] [L]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 46: [K]
//│ [K] --->
//│ 	case n:41 of {K => [KK] | N => [NN]}
//│ 49: [T 46: [K] 47: t^29_aa^10 48: t^29_bb^11]
//│ [T [K] t^29_aa^10 t^29_bb^11] --->
//│ 	case x:40 of {T n:41 l:42 r:43 => [T case n:41 of {K => [KK] | N => [NN]} (c^28_c^18 l:42) (c^28_c^21 r:43)] | L => [LL]}
//│ 50: [N]
//│ [N] --->
//│ 	case n:37 of {K => [KK] | N => [NN]}
//│ 51: [L]
//│ [L] --->
//│ 	case x:28 of {T n:29 l:30 r:31 => [T case n:29 of {K => [KK] | N => [NN]} (c^28_c^21_c^18 l:30) (c^28_c^21_c^18 r:31)] | L => [LL]}
//│ 52: [L]
//│ [L] --->
//│ 	case x:32 of {T n:33 l:34 r:35 => [T case n:33 of {K => [KK] | N => [NN]} (c^28_c^21_c^21 l:34) (c^28_c^21_c^21 r:35)] | L => [LL]}
//│ 53: [T 50: [N] 51: [L] 52: [L]]
//│ [T [N] [L] [L]] --->
//│ 	case x:36 of {T n:37 l:38 r:39 => [T case n:37 of {K => [KK] | N => [NN]} (c^28_c^21_c^18 l:38) (c^28_c^21_c^21 r:39)] | L => [LL]}
//│ 84: [N]
//│ [N] --->
//│ 	case n:49 of {K => [KK] | N => [NN]}
//│ 85: [L]
//│ [L] --->
//│ 	case x:24 of {T n:25 l:26 r:27 => [T case n:25 of {K => [KK] | N => [NN]} (c^28_c^18_c^18 l:26) (c^28_c^18_c^18 r:27)] | L => [LL]}
//│ 86: [L]
//│ [L] --->
//│ 	case x:44 of {T n:45 l:46 r:47 => [T case n:45 of {K => [KK] | N => [NN]} (c^28_c^18_c^21 l:46) (c^28_c^18_c^21 r:47)] | L => [LL]}
//│ 87: [T 84: [N] 85: [L] 86: [L]]
//│ [T [N] [L] [L]] --->
//│ 	case x:48 of {T n:49 l:50 r:51 => [T case n:49 of {K => [KK] | N => [NN]} (c^28_c^18_c^18 l:50) (c^28_c^18_c^21 r:51)] | L => [LL]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c^28 t^29)
//│ def aa = [T [N] [L] [L]]
//│ def bb = [T [N] [L] [L]]
//│ def c = (fun x:10 -> case x:10 of {
//│ 	T n:11 l:12 r:13 => [T case n:11 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c l:12) (c r:13)]
//│ 	| L => [LL]})
//│ def c^28 = (fun x:40 -> x:40)
//│ def c^28_c^18 = (fun x:48 -> x:48)
//│ def c^28_c^18_c^18 = (fun x:24 -> x:24)
//│ def c^28_c^18_c^21 = (fun x:44 -> x:44)
//│ def c^28_c^21 = (fun x:36 -> x:36)
//│ def c^28_c^21_c^18 = (fun x:28 -> x:28)
//│ def c^28_c^21_c^21 = (fun x:32 -> x:32)
//│ def t = [T [K] aa bb]
//│ def t^29 = let n:41 = [KK]
//│ in let l:42 = t^29_aa^10
//│ in let r:43 = t^29_bb^11
//│ in [T n:41 (c^28_c^18 l:42) (c^28_c^21 r:43)]
//│ def t^29_aa^10 = let n:49 = [NN]
//│ in let l:50 = [LL]
//│ in let r:51 = [LL]
//│ in [T n:49 (c^28_c^18_c^18 l:50) (c^28_c^18_c^21 r:51)]
//│ def t^29_bb^11 = let n:37 = [NN]
//│ in let l:38 = [LL]
//│ in let r:39 = [LL]
//│ in [T n:37 (c^28_c^21_c^18 l:38) (c^28_c^21_c^21 r:39)]
//│ <<<<<<< after fusion <<<<<<<


fun map(ls) = if ls is
    C(h, t) then f => C(f(h), map(t)(f))
    N then f => N
let l = C(K, N)
map(l)(
    x => if x is
        K then T
)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#let| |l| |#=| |C|(|K|,| |N|)|↵|map|(|l|)|(|→|x| |=>| |#if| |x| |is|→|K| |#then| |T|←|←|↵|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then f, => C (f (h,), map (t,) (f,),); (N) then f, => N›; let l = C (K, N,); map (l,) (x, => if x is ‹(K) then T›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((map^19 l^20) (fun x:13 -> case x:13 of {
//│ 	K => [T]}))
//│ def l = [C [K] [N]]
//│ def map = (fun ls:8 -> case ls:8 of {
//│ 	C h:9 t:10 => (fun f:11 -> [C (f:11 h:9) ((map^5 t:10) f:11)])
//│ 	| N => (fun f:12 -> [N])})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 't:10
//│ 	[-l^20 · +map^19 · +map^5 · +map^5]  --->  [-l^20 · +map^19 · +map^5]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [map^19 · map^5 · map^5] --> [map^19 · map^5]
//│ [l^20] --> [l^20]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^20]
//│ [map^19]
//│ 	[map^19 · map^5]
//│ 		[map^19 · map^5 · map^5] ---> [map^19 · map^5] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((map^19 l^20) (fun x:27 -> case x:27 of {
//│ 	K => [T]}))
//│ def l = [C [K] [N]]
//│ def l^20 = [C [K] [N]]
//│ def map = (fun ls:9 -> case ls:9 of {
//│ 	C h:10 t:11 => (fun f:12 -> [C (f:12 h:10) ((map t:11) f:12)])
//│ 	| N => (fun f:13 -> [N])})
//│ def map^19 = (fun ls:17 -> case ls:17 of {
//│ 	C h:18 t:19 => (fun f:20 -> [C (f:20 h:18) ((map^19_map^5 t:19) f:20)])
//│ 	| N => (fun f:21 -> [N])})
//│ def map^19_map^5 = (fun ls:22 -> case ls:22 of {
//│ 	C h:23 t:24 => (fun f:25 -> [C (f:25 h:23) ((map^19_map^5 t:24) f:25)])
//│ 	| N => (fun f:26 -> [N])})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 42: [K]
//│ [K] --->
//│ 	case x:27 of {K => [T]}
//│ 43: [N]
//│ [N] --->
//│ 	case ls:22 of {C h:23 t:24 => (fun f:25 -> [C (f:25 h:23) ((map^19_map^5 t:24) f:25)]) | N => (fun f:26 -> [N])}
//│ 44: [C 42: [K] 43: [N]]
//│ [C [K] [N]] --->
//│ 	case ls:17 of {C h:18 t:19 => (fun f:20 -> [C (f:20 h:18) ((map^19_map^5 t:19) f:20)]) | N => (fun f:21 -> [N])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((map^19 l^20) (fun x:27 -> x:27))
//│ def l = [C [K] [N]]
//│ def l^20 = let h:18 = [T]
//│ in let t:19 = (fun f:26 -> [N])
//│ in (fun f:20 -> [C (f:20 h:18) ((map^19_map^5 t:19) f:20)])
//│ def map = (fun ls:9 -> case ls:9 of {
//│ 	C h:10 t:11 => (fun f:12 -> [C (f:12 h:10) ((map t:11) f:12)])
//│ 	| N => (fun f:13 -> [N])})
//│ def map^19 = (fun ls:17 -> ls:17)
//│ def map^19_map^5 = (fun ls:22 -> ls:22)
//│ <<<<<<< after fusion <<<<<<<


fun inter(xs) = if xs is
    N then ys => ys
    C(h, t) then ys => C(h, inter(ys)(t))
let rec l1 = C(1, C(2, l1))
let rec l2 = C(9, C(8, l2))
inter(l1)(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |#rec| |l1| |#=| |C|(|1|,| |C|(|2|,| |l1|)|)|↵|#let| |#rec| |l2| |#=| |C|(|9|,| |C|(|8|,| |l2|)|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let rec l1 = C (1, C (2, l1,),); let rec l2 = C (9, C (8, l2,),); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter^24 l1^25) l2^27)
//│ def inter = (fun xs:9 -> case xs:9 of {
//│ 	N => (fun ys:10 -> ys:10)
//│ 	| C h:11 t:12 => (fun ys:13 -> [C h:11 ((inter^5 ys:13) t:12)])})
//│ def l1 = [C 1 [C 2 l1^16]]
//│ def l2 = [C 9 [C 8 l2^21]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(Int, 'l1:7) <: 'ys:13
//│ 	[-l1^16 · -l1^25 · +inter^24 · +inter^5 · +inter^5 · +inter^5 · +inter^5 · +inter^5]  --->  [-l1^25 · +inter^24 · +inter^5]
//│ C(Int, 'l2:8) <: 'ys:13
//│ 	[-l2^21 · -l2^27 · +inter^24 · +inter^5 · +inter^5 · +inter^5 · +inter^5 · +inter^5 · +inter^5]  --->  [-l2^27 · +inter^24 · +inter^5 · +inter^5]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [inter^24 · inter^5 · inter^5 · inter^5 · inter^5 · inter^5 · inter^5] --> [inter^24 · inter^5 · inter^5]
//│ [inter^24 · inter^5 · inter^5 · inter^5 · inter^5 · inter^5] --> [inter^24 · inter^5]
//│ [l1^25 · l1^16] --> [l1^25]
//│ [l2^27 · l2^21] --> [l2^27]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^24]
//│ 	[inter^24 · inter^5]
//│ 		[inter^24 · inter^5 · inter^5]
//│ 			[inter^24 · inter^5 · inter^5 · inter^5]
//│ 				[inter^24 · inter^5 · inter^5 · inter^5 · inter^5]
//│ 					[inter^24 · inter^5 · inter^5 · inter^5 · inter^5 · inter^5] ---> [inter^24 · inter^5] (only one)
//│ [l1^25]
//│ 	[l1^25 · l1^16] ---> [l1^25] (only one)
//│ [l2^27]
//│ 	[l2^27 · l2^21] ---> [l2^27] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((inter^24 l1^25) l2^27)
//│ def inter = (fun xs:9 -> case xs:9 of {
//│ 	N => (fun ys:10 -> ys:10)
//│ 	| C h:11 t:12 => (fun ys:13 -> [C h:11 ((inter ys:13) t:12)])})
//│ def inter^24 = (fun xs:21 -> case xs:21 of {
//│ 	N => (fun ys:22 -> ys:22)
//│ 	| C h:23 t:24 => (fun ys:25 -> [C h:23 ((inter^24_inter^5 ys:25) t:24)])})
//│ def inter^24_inter^5 = (fun xs:36 -> case xs:36 of {
//│ 	N => (fun ys:37 -> ys:37)
//│ 	| C h:38 t:39 => (fun ys:40 -> [C h:38 ((inter^24_inter^5_inter^5 ys:40) t:39)])})
//│ def inter^24_inter^5_inter^5 = (fun xs:41 -> case xs:41 of {
//│ 	N => (fun ys:42 -> ys:42)
//│ 	| C h:43 t:44 => (fun ys:45 -> [C h:43 ((inter^24_inter^5_inter^5_inter^5 ys:45) t:44)])})
//│ def inter^24_inter^5_inter^5_inter^5 = (fun xs:26 -> case xs:26 of {
//│ 	N => (fun ys:27 -> ys:27)
//│ 	| C h:28 t:29 => (fun ys:30 -> [C h:28 ((inter^24_inter^5_inter^5_inter^5_inter^5 ys:30) t:29)])})
//│ def inter^24_inter^5_inter^5_inter^5_inter^5 = (fun xs:31 -> case xs:31 of {
//│ 	N => (fun ys:32 -> ys:32)
//│ 	| C h:33 t:34 => (fun ys:35 -> [C h:33 ((inter^24_inter^5 ys:35) t:34)])})
//│ def l1 = [C 1 [C 2 l1]]
//│ def l1^25 = [C 1 [C 2 l1^25]]
//│ def l2 = [C 9 [C 8 l2]]
//│ def l2^27 = [C 9 [C 8 l2^27]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 45: [C 43: 8 44: l2^27]
//│ [C 8 l2^27] --->
//│ 	case xs:26 of {N => (fun ys:27 -> ys:27) | C h:28 t:29 => (fun ys:30 -> [C h:28 ((inter^24_inter^5_inter^5_inter^5_inter^5 ys:30) t:29)])}
//│ 46: [C 42: 9 45: [C 43: 8 44: l2^27]]
//│ [C 9 [C 8 l2^27]] --->
//│ 	case xs:36 of {N => (fun ys:37 -> ys:37) | C h:38 t:39 => (fun ys:40 -> [C h:38 ((inter^24_inter^5_inter^5 ys:40) t:39)])}
//│ 89: [C 87: 2 88: l1^25]
//│ [C 2 l1^25] --->
//│ 	case xs:41 of {N => (fun ys:42 -> ys:42) | C h:43 t:44 => (fun ys:45 -> [C h:43 ((inter^24_inter^5_inter^5_inter^5 ys:45) t:44)])}
//│ 90: [C 86: 1 89: [C 87: 2 88: l1^25]]
//│ [C 1 [C 2 l1^25]] --->
//│ 	case xs:21 of {N => (fun ys:22 -> ys:22) | C h:23 t:24 => (fun ys:25 -> [C h:23 ((inter^24_inter^5 ys:25) t:24)])}
//│ 	case xs:31 of {N => (fun ys:32 -> ys:32) | C h:33 t:34 => (fun ys:35 -> [C h:33 ((inter^24_inter^5 ys:35) t:34)])}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((inter^24 l1^25) l2^27)
//│ def inter = (fun xs:9 -> case xs:9 of {
//│ 	N => (fun ys:10 -> ys:10)
//│ 	| C h:11 t:12 => (fun ys:13 -> [C h:11 ((inter ys:13) t:12)])})
//│ def inter^24 = (fun xs:21 -> xs:21)
//│ def inter^24_inter^5 = (fun xs:36 -> xs:36)
//│ def inter^24_inter^5_inter^5 = (fun xs:41 -> xs:41)
//│ def inter^24_inter^5_inter^5_inter^5 = (fun xs:26 -> xs:26)
//│ def inter^24_inter^5_inter^5_inter^5_inter^5 = (fun xs:31 -> case xs:31 of {
//│ 	N => (fun ys:32 -> ys:32)
//│ 	| C h:33 t:34 => (fun ys:35 -> [C h:33 ((inter^24_inter^5 ys:35) t:34)])})
//│ def l1 = [C 1 [C 2 l1]]
//│ def l1^25 = let h:23 = 1
//│ in let t:24 = 
//│ 	let h:43 = 2
//│ 	in let t:44 = l1^25
//│ 	in (fun ys:45 -> [C h:43 ((inter^24_inter^5_inter^5_inter^5 ys:45) t:44)])
//│ in (fun ys:25 -> [C h:23 ((inter^24_inter^5 ys:25) t:24)])
//│ def l2 = [C 9 [C 8 l2]]
//│ def l2^27 = let h:38 = 9
//│ in let t:39 = 
//│ 	let h:28 = 8
//│ 	in let t:29 = l2^27
//│ 	in (fun ys:30 -> [C h:28 ((inter^24_inter^5_inter^5_inter^5_inter^5 ys:30) t:29)])
//│ in (fun ys:40 -> [C h:38 ((inter^24_inter^5_inter^5 ys:40) t:39)])
//│ <<<<<<< after fusion <<<<<<<


fun last(ys) = if ys is
    N then x => x
    C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
    N then None
    C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (lastDrive^22 [C 1 [C 2 [N]]])
//│ def last = (fun ys:8 -> case ys:8 of {
//│ 	N => (fun x:9 -> x:9)
//│ 	| C h:10 t:11 => (fun x:12 -> ((last^4 t:11) h:10))})
//│ def lastDrive = (fun xs:13 -> case xs:13 of {
//│ 	N => [None]
//│ 	| C hh:14 tt:15 => [Some ((last^14 tt:15) hh:14)]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 't:11
//│ 	[+lastDrive^22 · +last^14 · +last^4 · +last^4]  --->  [+lastDrive^22 · +last^14 · +last^4]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [lastDrive^22 · last^14 · last^4 · last^4] --> [lastDrive^22 · last^14 · last^4]
//│ [] --> []
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive^22]
//│ 	[lastDrive^22 · last^14]
//│ 		[lastDrive^22 · last^14 · last^4]
//│ 			[lastDrive^22 · last^14 · last^4 · last^4] ---> [lastDrive^22 · last^14 · last^4] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (lastDrive^22 [C 1 [C 2 [N]]])
//│ def last = (fun ys:8 -> case ys:8 of {
//│ 	N => (fun x:9 -> x:9)
//│ 	| C h:10 t:11 => (fun x:12 -> ((last t:11) h:10))})
//│ def lastDrive = (fun xs:13 -> case xs:13 of {
//│ 	N => [None]
//│ 	| C hh:14 tt:15 => [Some ((last tt:15) hh:14)]})
//│ def lastDrive^22 = (fun xs:19 -> case xs:19 of {
//│ 	N => [None]
//│ 	| C hh:20 tt:21 => [Some ((lastDrive^22_last^14 tt:21) hh:20)]})
//│ def lastDrive^22_last^14 = (fun ys:22 -> case ys:22 of {
//│ 	N => (fun x:23 -> x:23)
//│ 	| C h:24 t:25 => (fun x:26 -> ((lastDrive^22_last^14_last^4 t:25) h:24))})
//│ def lastDrive^22_last^14_last^4 = (fun ys:27 -> case ys:27 of {
//│ 	N => (fun x:28 -> x:28)
//│ 	| C h:29 t:30 => (fun x:31 -> ((lastDrive^22_last^14_last^4 t:30) h:29))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 64: [N]
//│ [N] --->
//│ 	case ys:27 of {N => (fun x:28 -> x:28) | C h:29 t:30 => (fun x:31 -> ((lastDrive^22_last^14_last^4 t:30) h:29))}
//│ 65: [C 63: 2 64: [N]]
//│ [C 2 [N]] --->
//│ 	case ys:22 of {N => (fun x:23 -> x:23) | C h:24 t:25 => (fun x:26 -> ((lastDrive^22_last^14_last^4 t:25) h:24))}
//│ 66: [C 62: 1 65: [C 63: 2 64: [N]]]
//│ [C 1 [C 2 [N]]] --->
//│ 	case xs:19 of {N => [None] | C hh:20 tt:21 => [Some ((lastDrive^22_last^14 tt:21) hh:20)]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (lastDrive^22 let hh:20 = 1
//│ in let tt:21 = 
//│ 	let h:24 = 2
//│ 	in let t:25 = (fun x:28 -> x:28)
//│ 	in (fun x:26 -> ((lastDrive^22_last^14_last^4 t:25) h:24))
//│ in [Some ((lastDrive^22_last^14 tt:21) hh:20)])
//│ def last = (fun ys:8 -> case ys:8 of {
//│ 	N => (fun x:9 -> x:9)
//│ 	| C h:10 t:11 => (fun x:12 -> ((last t:11) h:10))})
//│ def lastDrive = (fun xs:13 -> case xs:13 of {
//│ 	N => [None]
//│ 	| C hh:14 tt:15 => [Some ((last tt:15) hh:14)]})
//│ def lastDrive^22 = (fun xs:19 -> xs:19)
//│ def lastDrive^22_last^14 = (fun ys:22 -> ys:22)
//│ def lastDrive^22_last^14_last^4 = (fun ys:27 -> ys:27)
//│ <<<<<<< after fusion <<<<<<<
