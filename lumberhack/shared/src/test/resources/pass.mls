:NewParser
:ParseOnly



// CORRECT:
let p = C(1, C(2, N))
fun e(z) = if z is
  C(aaa, bbb) then bbb
  N then 7
fun d(y) = if y is
  C(aa, bb) then e(bb)
  N then 5
fun c(x) = if x is
  C(a, b) then d(b)
  N then 3
c(p)
//│ |#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#fun| |e|(|z|)| |#=| |#if| |z| |is|→|C|(|aaa|,| |bbb|)| |#then| |bbb|↵|N| |#then| |7|←|↵|#fun| |d|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|,| |bb|)| |#then| |e|(|bb|)|↵|N| |#then| |5|←|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|,| |b|)| |#then| |d|(|b|)|↵|N| |#then| |3|←|↵|c|(|p|)|
//│ Parsed: {let p = C (1, C (2, N,),); fun e = z, => if z is ‹(C (aaa, bbb,)) then bbb; (N) then 7›; fun d = y, => if y is ‹(C (aa, bb,)) then e (bb,); (N) then 5›; fun c = x, => if x is ‹(C (a, b,)) then d (b,); (N) then 3›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^25(p^26)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ b⁰ => d^19(b⁰)
//│ 	| N  => 3}
//│ def d(y⁰) = case y⁰ of {
//│ 	C aa⁰ bb⁰ => e^12(bb⁰)
//│ 	| N  => 5}
//│ def e(z⁰) = case z⁰ of {
//│ 	C aaa⁰ bbb⁰ => bbb⁰
//│ 	| N  => 7}
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^25] (hopeless to continue)
//│ 	[c^25 · d^19] (using original def)
//│ 		[c^25 · d^19 · e^12] (using original def)
//│ [p^26] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c₀(p₀)
//│ def c₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ b¹ => d₀(b¹)
//│ 		| N  => 3}
//│ 	where
//│ 	def d₀(y¹) = 
//│ 		case y¹ of {
//│ 			C aa¹ bb¹ => e₀(bb¹)
//│ 			| N  => 5}
//│ 		where
//│ 		def e₀(z¹) = 
//│ 			case z¹ of {
//│ 				C aaa¹ bbb¹ => bbb¹
//│ 				| N  => 7}
//│ def p₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 37 --->
//│ 	case z¹ of {C aaa¹ bbb¹ => bbb¹ | N  => 7}: 43
//│ [C 2 [N]]: 38 --->
//│ 	case y¹ of {C aa¹ bb¹ => e₀(bb¹) | N  => 5}: 50
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case x¹ of {C a¹ b¹ => d₀(b¹) | N  => 3}: 33
//│ ------------------
//│ case x¹ of {C a¹ b¹ => d₀(b¹) | N  => 3}: 33 --->
//│ 	[C 1 [C 2 [N]]]: 39
//│ case z¹ of {C aaa¹ bbb¹ => bbb¹ | N  => 7}: 43 --->
//│ 	[N]: 37
//│ case y¹ of {C aa¹ bb¹ => e₀(bb¹) | N  => 5}: 50 --->
//│ 	[C 2 [N]]: 38
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 37 --->
//│ 	case z¹ of {C aaa¹ bbb¹ => bbb¹ | N  => 7}: 43
//│ [C 2 [N]]: 38 --->
//│ 	case y¹ of {C aa¹ bb¹ => e₀(bb¹) | N  => 5}: 50
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case x¹ of {C a¹ b¹ => d₀(b¹) | N  => 3}: 33
//│ ------------------
//│ case x¹ of {C a¹ b¹ => d₀(b¹) | N  => 3}: 33 --->
//│ 	[C 1 [C 2 [N]]]: 39
//│ case z¹ of {C aaa¹ bbb¹ => bbb¹ | N  => 7}: 43 --->
//│ 	[N]: 37
//│ case y¹ of {C aa¹ bb¹ => e₀(bb¹) | N  => 5}: 50 --->
//│ 	[C 2 [N]]: 38
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c₀(p₀)
//│ def c₀(x²) = 
//│ 	x²(99)
//│ 	where
//│ 	def d₀(y²) = 
//│ 		y²(99)
//│ 		where
//│ 		def e₀(z²) = 
//│ 			z²
//│ def p₀ = 
//│ 	let b² = 	
//│ 		let bb² = 7
//│ 		in (fun _lh_dummy¹ -> e₀(bb²))
//│ 	in (fun _lh_dummy⁰ -> d₀(b²))
//│ <<<<<<< after fusion <<<<<<<



// CORRECT:
fun sum(ls) = if ls is
  C(h, t) then S(N, sum(t))
fun mapa(lsa) = if lsa is
  C(ha, ta) then C(primitive(ha), mapa(ta))
fun mapb(lsb) = if lsb is
  C(hb, tb) then C(primitive(hb), mapb(tb))
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),)›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),)›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),)›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ sum^29(mapa^30(mapb^31(primitive⁰)))
//│ def mapa(lsa⁰) = case lsa⁰ of {
//│ 	C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa^13(ta⁰)]}
//│ def mapb(lsb⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => [C primitive⁰(hb⁰) mapb^23(tb⁰)]}
//│ def sum(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [S [N] sum^3(t⁰)]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa^30]
//│ 	[mapa^30 · mapa^13] ---> [mapa^30] (only one)
//│ [mapb^31]
//│ 	[mapb^31 · mapb^23] ---> [mapb^31] (only one)
//│ [sum^29]
//│ 	[sum^29 · sum^3] ---> [sum^29] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ sum₀(mapa₀(mapb₀(primitive⁰)))
//│ def mapa₀(lsa¹) = 
//│ 	case lsa¹ of {
//│ 		C ha¹ ta¹ => [C primitive⁰(ha¹) mapa₀(ta¹)]}
//│ def mapb₀(lsb¹) = 
//│ 	case lsb¹ of {
//│ 		C hb¹ tb¹ => [C primitive⁰(hb¹) mapb₀(tb¹)]}
//│ def sum₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => [S [N] sum₀(t¹)]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰(hb¹) mapb₀(tb¹)]: 51 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa₀(ta¹)]}: 62
//│ [C primitive⁰(ha¹) mapa₀(ta¹)]: 61 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum₀(t¹)]}: 42
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] sum₀(t¹)]}: 42 --->
//│ 	[C primitive⁰(ha¹) mapa₀(ta¹)]: 61
//│ case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa₀(ta¹)]}: 62 --->
//│ 	[C primitive⁰(hb¹) mapb₀(tb¹)]: 51
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C primitive⁰(hb¹) mapb₀(tb¹)]: 51 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa₀(ta¹)]}: 62
//│ [C primitive⁰(ha¹) mapa₀(ta¹)]: 61 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum₀(t¹)]}: 42
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] sum₀(t¹)]}: 42 --->
//│ 	[C primitive⁰(ha¹) mapa₀(ta¹)]: 61
//│ case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa₀(ta¹)]}: 62 --->
//│ 	[C primitive⁰(hb¹) mapb₀(tb¹)]: 51
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ sum₀(mapa₀(mapb₀(primitive⁰)))
//│ def mapa₀(lsa²) = 
//│ 	lsa²(99)
//│ def mapb₀(lsb²) = 
//│ 	case lsb² of {
//│ 		C hb¹ tb¹ => 
//│ 			let ha² = primitive⁰(hb¹)
//│ 			in let ta² = mapb₀(tb¹)
//│ 			in (fun _lh_dummy¹ -> 
//│ 				let t² = mapa₀(ta²)
//│ 				in (fun _lh_dummy⁰ -> [S [N] sum₀(t²)]))}
//│ def sum₀(ls²) = 
//│ 	ls²(99)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
if C(A, B(C)) is
  C(a, b) then D(b)
//│ |#if| |C|(|A|,| |B|(|C|)|)| |is|→|C|(|a|,| |b|)| |#then| |D|(|b|)|←|
//│ Parsed: {if C (A, B (C,),) is ‹(C (a, b,)) then D (b,)›}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a⁰ b⁰ => [D b⁰]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a¹ b¹ => [D b¹]}
//│ 
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A] [B [C]]]: 11 --->
//│ 	case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14
//│ ------------------
//│ case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14 --->
//│ 	[C [A] [B [C]]]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [A] [B [C]]]: 11 --->
//│ 	case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14
//│ ------------------
//│ case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14 --->
//│ 	[C [A] [B [C]]]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let b² = [B [C]]
//│ 	in [D b²]
//│ 
//│ <<<<<<< after fusion <<<<<<<
//│




// def p:6^18 =
//      ... p:6^1 ~> p:6^18.p:6^1 ...

// def p:6^18.p:6^1 =
//      ... p:6^1 ~> p:6^18 ...

// def ca:7^17
//      ... 



// CORRECT: every element is handled
fun ff(x) = if x is
  K then T
  KK then TT
  KKKK then TTTT
fun map(ls) = if ls is
  C(h, t) then C(ff(h), map(t))
  N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|ff|(|h|)|,| |map|(|t|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; fun map = ls, => if ls is ‹(C (h, t,)) then C (ff (h,), map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^25(l^26)
//│ def ff(x⁰) = case x⁰ of {
//│ 	K  => [T]
//│ 	| KK  => [TT]
//│ 	| KKKK  => [TTTT]}
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C ff^8(h⁰) map^11(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^26] (hopeless to continue)
//│ [map^25]
//│ 	[map^25 · ff^8] (hopeless to continue)
//│ 	[map^25 · map^11] ---> [map^25] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map₀(l₀)
//│ def l₀ = 
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => [C ff₀(h¹) map₀(t¹)]
//│ 		| N  => [N]}
//│ 	where
//│ 	def ff₀(x¹) = 
//│ 		case x¹ of {
//│ 			K  => [T]
//│ 			| KK  => [TT]
//│ 			| KKKK  => [TTTT]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 39 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [KK]: 40 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [KKKK]: 41 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [N]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff₀(h¹) map₀(t¹)] | N  => [N]}: 37
//│ [C [KKKK] [N]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff₀(h¹) map₀(t¹)] | N  => [N]}: 37
//│ [C [KK] [C [KKKK] [N]]]: 44 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff₀(h¹) map₀(t¹)] | N  => [N]}: 37
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 45 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff₀(h¹) map₀(t¹)] | N  => [N]}: 37
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C ff₀(h¹) map₀(t¹)] | N  => [N]}: 37 --->
//│ 	[N]: 42
//│ 	[C [KKKK] [N]]: 43
//│ 	[C [KK] [C [KKKK] [N]]]: 44
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 45
//│ case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50 --->
//│ 	[K]: 39
//│ 	[KK]: 40
//│ 	[KKKK]: 41
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 39 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [KK]: 40 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [KKKK]: 41 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [N]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff₀(h¹) map₀(t¹)] | N  => [N]}: 37
//│ [C [KKKK] [N]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff₀(h¹) map₀(t¹)] | N  => [N]}: 37
//│ [C [KK] [C [KKKK] [N]]]: 44 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff₀(h¹) map₀(t¹)] | N  => [N]}: 37
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 45 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff₀(h¹) map₀(t¹)] | N  => [N]}: 37
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C ff₀(h¹) map₀(t¹)] | N  => [N]}: 37 --->
//│ 	[N]: 42
//│ 	[C [KKKK] [N]]: 43
//│ 	[C [KK] [C [KKKK] [N]]]: 44
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 45
//│ case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50 --->
//│ 	[K]: 39
//│ 	[KK]: 40
//│ 	[KKKK]: 41
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map₀(l₀)
//│ def l₀ = 
//│ 	let h² = [T]
//│ 	in let t² = 	
//│ 		let h³ = [TT]
//│ 		in let t³ = 	
//│ 			let h⁴ = [TTTT]
//│ 			in let t⁴ = (fun _lh_dummy³ -> [N])
//│ 			in (fun _lh_dummy² -> [C ff₀(h⁴) map₀(t⁴)])
//│ 		in (fun _lh_dummy¹ -> [C ff₀(h³) map₀(t³)])
//│ 	in (fun _lh_dummy⁰ -> [C ff₀(h²) map₀(t²)])
//│ def map₀(ls²) = 
//│ 	ls²(99)
//│ 	where
//│ 	def ff₀(x²) = 
//│ 		x²
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: every element is handled
fun map(ls) = if ls is
  C(h, t) then C(
    (if h is
      K then T
      KK then TT
      KKKK then TTTT
    ),
    map(t)
  )
  N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›, ')', map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^21(l^22)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C case h⁰ of {
//│ 		K  => [T]
//│ 		| KK  => [TT]
//│ 		| KKKK  => [TTTT]} map^7(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^22] (hopeless to continue)
//│ [map^21]
//│ 	[map^21 · map^7] ---> [map^21] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map₀(l₀)
//│ def l₀ = 
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => [C case h¹ of {
//│ 			K  => [T]
//│ 			| KK  => [TT]
//│ 			| KKKK  => [TTTT]} map₀(t¹)]
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 37 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [KK]: 38 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [KKKK]: 39 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [N]: 40 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map₀(t¹)] | N  => [N]}: 35
//│ [C [KKKK] [N]]: 41 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map₀(t¹)] | N  => [N]}: 35
//│ [C [KK] [C [KKKK] [N]]]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map₀(t¹)] | N  => [N]}: 35
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map₀(t¹)] | N  => [N]}: 35
//│ ------------------
//│ case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29 --->
//│ 	[K]: 37
//│ 	[KK]: 38
//│ 	[KKKK]: 39
//│ case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map₀(t¹)] | N  => [N]}: 35 --->
//│ 	[N]: 40
//│ 	[C [KKKK] [N]]: 41
//│ 	[C [KK] [C [KKKK] [N]]]: 42
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 43
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 37 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [KK]: 38 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [KKKK]: 39 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [N]: 40 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map₀(t¹)] | N  => [N]}: 35
//│ [C [KKKK] [N]]: 41 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map₀(t¹)] | N  => [N]}: 35
//│ [C [KK] [C [KKKK] [N]]]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map₀(t¹)] | N  => [N]}: 35
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map₀(t¹)] | N  => [N]}: 35
//│ ------------------
//│ case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29 --->
//│ 	[K]: 37
//│ 	[KK]: 38
//│ 	[KKKK]: 39
//│ case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map₀(t¹)] | N  => [N]}: 35 --->
//│ 	[N]: 40
//│ 	[C [KKKK] [N]]: 41
//│ 	[C [KK] [C [KKKK] [N]]]: 42
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 43
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map₀(l₀)
//│ def l₀ = 
//│ 	let h² = [T]
//│ 	in let t² = 	
//│ 		let h³ = [TT]
//│ 		in let t³ = 	
//│ 			let h⁴ = [TTTT]
//│ 			in let t⁴ = (fun _lh_dummy³ -> [N])
//│ 			in (fun _lh_dummy² -> [C h⁴ map₀(t⁴)])
//│ 		in (fun _lh_dummy¹ -> [C h³ map₀(t³)])
//│ 	in (fun _lh_dummy⁰ -> [C h² map₀(t²)])
//│ def map₀(ls²) = 
//│ 	ls²(99)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
fun sum(ls) = if ls is
  C(h, t) then S(N, sum(t))
  N then N
fun mapa(lsa) = if lsa is
  C(ha, ta) then C(primitive(ha), mapa(ta))
  N then N
fun mapb(lsb) = if lsb is
  C(hb, tb) then C(primitive(hb), mapb(tb))
  N then N
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|↵|N| |#then| |N|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|↵|N| |#then| |N|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),); (N) then N›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),); (N) then N›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),); (N) then N›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ sum^32(mapa^33(mapb^34(primitive⁰)))
//│ def mapa(lsa⁰) = case lsa⁰ of {
//│ 	C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa^14(ta⁰)]
//│ 	| N  => [N]}
//│ def mapb(lsb⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => [C primitive⁰(hb⁰) mapb^25(tb⁰)]
//│ 	| N  => [N]}
//│ def sum(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [S [N] sum^3(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa^33]
//│ 	[mapa^33 · mapa^14] ---> [mapa^33] (only one)
//│ [mapb^34]
//│ 	[mapb^34 · mapb^25] ---> [mapb^34] (only one)
//│ [sum^32]
//│ 	[sum^32 · sum^3] ---> [sum^32] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ sum₀(mapa₀(mapb₀(primitive⁰)))
//│ def mapa₀(lsa¹) = 
//│ 	case lsa¹ of {
//│ 		C ha¹ ta¹ => [C primitive⁰(ha¹) mapa₀(ta¹)]
//│ 		| N  => [N]}
//│ def mapb₀(lsb¹) = 
//│ 	case lsb¹ of {
//│ 		C hb¹ tb¹ => [C primitive⁰(hb¹) mapb₀(tb¹)]
//│ 		| N  => [N]}
//│ def sum₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => [S [N] sum₀(t¹)]
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰(ha¹) mapa₀(ta¹)]: 55 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum₀(t¹)] | N  => [N]}: 46
//│ [N]: 56 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum₀(t¹)] | N  => [N]}: 46
//│ [C primitive⁰(hb¹) mapb₀(tb¹)]: 66 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa₀(ta¹)] | N  => [N]}: 57
//│ [N]: 67 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa₀(ta¹)] | N  => [N]}: 57
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] sum₀(t¹)] | N  => [N]}: 46 --->
//│ 	[C primitive⁰(ha¹) mapa₀(ta¹)]: 55
//│ 	[N]: 56
//│ case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa₀(ta¹)] | N  => [N]}: 57 --->
//│ 	[C primitive⁰(hb¹) mapb₀(tb¹)]: 66
//│ 	[N]: 67
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C primitive⁰(ha¹) mapa₀(ta¹)]: 55 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum₀(t¹)] | N  => [N]}: 46
//│ [N]: 56 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum₀(t¹)] | N  => [N]}: 46
//│ [C primitive⁰(hb¹) mapb₀(tb¹)]: 66 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa₀(ta¹)] | N  => [N]}: 57
//│ [N]: 67 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa₀(ta¹)] | N  => [N]}: 57
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] sum₀(t¹)] | N  => [N]}: 46 --->
//│ 	[C primitive⁰(ha¹) mapa₀(ta¹)]: 55
//│ 	[N]: 56
//│ case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa₀(ta¹)] | N  => [N]}: 57 --->
//│ 	[C primitive⁰(hb¹) mapb₀(tb¹)]: 66
//│ 	[N]: 67
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ sum₀(mapa₀(mapb₀(primitive⁰)))
//│ def mapa₀(lsa²) = 
//│ 	lsa²(99)
//│ def mapb₀(lsb²) = 
//│ 	case lsb² of {
//│ 		C hb¹ tb¹ => 
//│ 			let ha² = primitive⁰(hb¹)
//│ 			in let ta² = mapb₀(tb¹)
//│ 			in (fun _lh_dummy¹ -> 
//│ 				let t² = mapa₀(ta²)
//│ 				in (fun _lh_dummy⁰ -> [S [N] sum₀(t²)]))
//│ 		| N  => (fun _lh_dummy³ -> (fun _lh_dummy² -> [N]))}
//│ def sum₀(ls²) = 
//│ 	ls²(99)
//│ <<<<<<< after fusion <<<<<<<




// CORRECT:
let p = C(N)
fun c(x) = if C(x) is
  C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|N|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (N,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^10(p^11)
//│ def c(x⁰) = case [C x⁰] of {
//│ 	C a⁰ => c^5(a⁰)}
//│ def p = [C [N]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^10]
//│ 	[c^10 · c^5] ---> [c^10] (only one)
//│ [p^11] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c₀(p₀)
//│ def c₀(x¹) = 
//│ 	case [C x¹] of {
//│ 		C a¹ => c₀(a¹)}
//│ def p₀ = 
//│ 	[C [N]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => c₀(a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => c₀(a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => c₀(a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => c₀(a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c₀(p₀)
//│ def c₀(x²) = 
//│ 	
//│ 		let a² = x²
//│ 		in (fun _lh_dummy⁰ -> c₀(a²))(99)
//│ def p₀ = 
//│ 	[C [N]]
//│ <<<<<<< after fusion <<<<<<<


// let rec p = C(p)
// let q = p
// fun c(x) = if x is
//     C(a) then a
// fun c2(z) = if z is
//     C(b) then c2(b)
// let main = c(q)
// c2(main)



// CORRECT:
_LUMBERHACK_EVAL
let t = T(K, T(N, L, L), T(N, L, L))
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |_LUMBERHACK_EVAL|↵|#let| |t| |#=| |T|(|K|,| |T|(|N|,| |L|,| |L|)|,| |T|(|N|,| |L|,| |L|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {_LUMBERHACK_EVAL; let t = T (K, T (N, L, L,), T (N, L, L,),); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^26(t^27)
//│ def c(x⁰) = case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K  => [KK]
//│ 		| N  => [NN]} c^16(l⁰) c^19(r⁰)]
//│ 	| L  => [LL]}
//│ def t = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^26]
//│ 	[c^26 · c^16] ---> [c^26] (only one)
//│ 	[c^26 · c^19] ---> [c^26] (only one)
//│ [t^27] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c₀(t₀)
//│ def c₀(x¹) = 
//│ 	case x¹ of {
//│ 		T n¹ l¹ r¹ => [T case n¹ of {
//│ 			K  => [KK]
//│ 			| N  => [NN]} c₀(l¹) c₀(r¹)]
//│ 		| L  => [LL]}
//│ def t₀ = 
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 44 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [N]: 45 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [L]: 46 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42
//│ [L]: 47 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42
//│ [T [N] [L] [L]]: 48 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42
//│ [N]: 49 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [L]: 50 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42
//│ [L]: 51 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42
//│ [T [N] [L] [L]]: 52 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42
//│ [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 33 --->
//│ 	[K]: 44
//│ 	[N]: 45
//│ 	[N]: 49
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42 --->
//│ 	[L]: 46
//│ 	[L]: 47
//│ 	[T [N] [L] [L]]: 48
//│ 	[L]: 50
//│ 	[L]: 51
//│ 	[T [N] [L] [L]]: 52
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 44 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [N]: 45 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [L]: 46 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42
//│ [L]: 47 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42
//│ [T [N] [L] [L]]: 48 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42
//│ [N]: 49 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [L]: 50 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42
//│ [L]: 51 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42
//│ [T [N] [L] [L]]: 52 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42
//│ [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 33 --->
//│ 	[K]: 44
//│ 	[N]: 45
//│ 	[N]: 49
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 42 --->
//│ 	[L]: 46
//│ 	[L]: 47
//│ 	[T [N] [L] [L]]: 48
//│ 	[L]: 50
//│ 	[L]: 51
//│ 	[T [N] [L] [L]]: 52
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c₀(t₀)
//│ def c₀(x²) = 
//│ 	x²(99)
//│ def t₀ = 
//│ 	let n² = [KK]
//│ 	in let l² = 	
//│ 		let n⁴ = [NN]
//│ 		in let l⁴ = (fun _lh_dummy⁶ -> [LL])
//│ 		in let r⁴ = (fun _lh_dummy⁵ -> [LL])
//│ 		in (fun _lh_dummy⁴ -> [T n⁴ c₀(l⁴) c₀(r⁴)])
//│ 	in let r² = 	
//│ 		let n³ = [NN]
//│ 		in let l³ = (fun _lh_dummy³ -> [LL])
//│ 		in let r³ = (fun _lh_dummy² -> [LL])
//│ 		in (fun _lh_dummy¹ -> [T n³ c₀(l³) c₀(r³)])
//│ 	in (fun _lh_dummy⁰ -> [T n² c₀(l²) c₀(r²)])
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |_LUMBERHACK_EVAL|↵|#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {_LUMBERHACK_EVAL; let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^28(t^29)
//│ def aa = [T [N] [L] [L]]
//│ def bb = [T [N] [L] [L]]
//│ def c(x⁰) = case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K  => [KK]
//│ 		| N  => [NN]} c^18(l⁰) c^21(r⁰)]
//│ 	| L  => [LL]}
//│ def t = [T [K] aa^10 bb^11]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^28]
//│ 	[c^28 · c^18] ---> [c^28] (only one)
//│ 	[c^28 · c^21] ---> [c^28] (only one)
//│ [t^29] (hopeless to continue)
//│ 	[t^29 · aa^10] (using original def)
//│ 	[t^29 · bb^11] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c₀(t₀)
//│ def c₀(x¹) = 
//│ 	case x¹ of {
//│ 		T n¹ l¹ r¹ => [T case n¹ of {
//│ 			K  => [KK]
//│ 			| N  => [NN]} c₀(l¹) c₀(r¹)]
//│ 		| L  => [LL]}
//│ def t₀ = 
//│ 	[T [K] aa₀ bb₀]
//│ 	where
//│ 	def aa₀ = 
//│ 		[T [N] [L] [L]]
//│ 	def bb₀ = 
//│ 		[T [N] [L] [L]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 31 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [L]: 32 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48
//│ [L]: 33 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48
//│ [T [N] [L] [L]]: 34 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48
//│ [K]: 50 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [T [K] aa₀ bb₀]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48
//│ [N]: 54 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [L]: 55 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48
//│ [L]: 56 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48
//│ [T [N] [L] [L]]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 39 --->
//│ 	[N]: 31
//│ 	[K]: 50
//│ 	[N]: 54
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48 --->
//│ 	[L]: 32
//│ 	[L]: 33
//│ 	[T [N] [L] [L]]: 34
//│ 	[T [K] aa₀ bb₀]: 53
//│ 	[L]: 55
//│ 	[L]: 56
//│ 	[T [N] [L] [L]]: 57
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 31 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [L]: 32 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48
//│ [L]: 33 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48
//│ [T [N] [L] [L]]: 34 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48
//│ [K]: 50 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [T [K] aa₀ bb₀]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48
//│ [N]: 54 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [L]: 55 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48
//│ [L]: 56 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48
//│ [T [N] [L] [L]]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 39 --->
//│ 	[N]: 31
//│ 	[K]: 50
//│ 	[N]: 54
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 48 --->
//│ 	[L]: 32
//│ 	[L]: 33
//│ 	[T [N] [L] [L]]: 34
//│ 	[T [K] aa₀ bb₀]: 53
//│ 	[L]: 55
//│ 	[L]: 56
//│ 	[T [N] [L] [L]]: 57
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c₀(t₀)
//│ def c₀(x²) = 
//│ 	x²(99)
//│ def t₀ = 
//│ 	let n³ = [KK]
//│ 	in let l³ = aa₀
//│ 	in let r³ = bb₀
//│ 	in (fun _lh_dummy³ -> [T n³ c₀(l³) c₀(r³)])
//│ 	where
//│ 	def aa₀ = 
//│ 		let n⁴ = [NN]
//│ 		in let l⁴ = (fun _lh_dummy⁶ -> [LL])
//│ 		in let r⁴ = (fun _lh_dummy⁵ -> [LL])
//│ 		in (fun _lh_dummy⁴ -> [T n⁴ c₀(l⁴) c₀(r⁴)])
//│ 	def bb₀ = 
//│ 		let n² = [NN]
//│ 		in let l² = (fun _lh_dummy² -> [LL])
//│ 		in let r² = (fun _lh_dummy¹ -> [LL])
//│ 		in (fun _lh_dummy⁰ -> [T n² c₀(l²) c₀(r²)])
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
fun map(ls) = if ls is
  C(h, t) then f => C(f(h), map(t)(f))
  N then f => N
let l = C(K, N)
map(l)(
  x => if x is
    K then T
)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#let| |l| |#=| |C|(|K|,| |N|)|↵|map|(|l|)|(|→|x| |=>| |#if| |x| |is|→|K| |#then| |T|←|←|↵|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, => if ls is ‹(C (h, t,)) then f, => C (f (h,), map (t,) (f,),); (N) then f, => N›; let l = C (K, N,); map (l,) (x, => if x is ‹(K) then T›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^19(l^20, (fun x⁰ -> case x⁰ of {
//│ 	K  => [T]}))
//│ def l = [C [K] [N]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map^5(t⁰, f⁰)])
//│ 	| N  => (fun f¹ -> [N])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [T] [N]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^20] (hopeless to continue)
//│ [map^19]
//│ 	[map^19 · map^5] ---> [map^19] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map₀(l₀, (fun x¹ -> case x¹ of {
//│ 	K  => [T]}))
//│ def l₀ = 
//│ 	[C [K] [N]]
//│ def map₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => (fun f² -> [C f²(h¹) map₀(t¹, f²)])
//│ 		| N  => (fun f³ -> [N])}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 27 --->
//│ 	case x¹ of {K  => [T]}: 50
//│ [N]: 28 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43
//│ [C [K] [N]]: 29 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43 --->
//│ 	[N]: 28
//│ 	[C [K] [N]]: 29
//│ case x¹ of {K  => [T]}: 50 --->
//│ 	DeadCodeProd
//│ 	[K]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 28 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43
//│ [C [K] [N]]: 29 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43 --->
//│ 	[N]: 28
//│ 	[C [K] [N]]: 29
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map₀(l₀, (fun x² -> case x² of {
//│ 	K  => [T]}))
//│ def l₀ = 
//│ 	let h² = [K]
//│ 	in let t² = (fun f⁵ -> [N])
//│ 	in (fun f⁴ -> [C f⁴(h²) map₀(t², f⁴)])
//│ def map₀(ls²) = 
//│ 	ls²
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [T] [N]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
fun last(ys) = if ys is
  N then x => x
  C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
  N then None
  C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastDrive^22([C 1 [C 2 [N]]])
//│ def last(ys⁰) = case ys⁰ of {
//│ 	N  => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> last^4(t⁰, h⁰))}
//│ def lastDrive(xs⁰) = case xs⁰ of {
//│ 	N  => [None]
//│ 	| C hh⁰ tt⁰ => [Some last^14(tt⁰, hh⁰)]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [Some 2]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive^22]
//│ 	[lastDrive^22 · last^14]
//│ 		[lastDrive^22 · last^14 · last^4] ---> [lastDrive^22 · last^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastDrive₀([C 1 [C 2 [N]]])
//│ def lastDrive₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => [None]
//│ 		| C hh¹ tt¹ => [Some last₀(tt¹, hh¹)]}
//│ 	where
//│ 	def last₀(ys¹) = 
//│ 		case ys¹ of {
//│ 			N  => (fun x² -> x²)
//│ 			| C h¹ t¹ => (fun x³ -> last₀(t¹, h¹))}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last₀(t¹, h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last₀(t¹, h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last₀(tt¹, hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last₀(tt¹, hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last₀(t¹, h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last₀(t¹, h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last₀(t¹, h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last₀(tt¹, hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last₀(tt¹, hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last₀(t¹, h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastDrive₀(
//│ 	let hh² = 1
//│ 	in let tt² = 	
//│ 		let h² = 2
//│ 		in let t² = (fun x⁵ -> x⁵)
//│ 		in (fun x⁴ -> last₀(t², h²))
//│ 	in (fun _lh_dummy⁰ -> [Some last₀(tt², hh²)]))
//│ def lastDrive₀(xs²) = 
//│ 	xs²(99)
//│ 	where
//│ 	def last₀(ys²) = 
//│ 		ys²
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 2]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT: with expanding termination
let p = C(p)
fun c(x) = if C(x) is
  C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^10(p^11)
//│ def c(x⁰) = case [C x⁰] of {
//│ 	C a⁰ => c^5(a⁰)}
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^10]
//│ 	[c^10 · c^5] ---> [c^10] (only one)
//│ [p^11] (hopeless to continue)
//│ 	[p^11 · p^1] ---> [p^11] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c₀(p₀)
//│ def c₀(x¹) = 
//│ 	case [C x¹] of {
//│ 		C a¹ => c₀(a¹)}
//│ def p₀ = 
//│ 	[C p₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => c₀(a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => c₀(a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => c₀(a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => c₀(a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c₀(p₀)
//│ def c₀(x²) = 
//│ 	
//│ 		let a² = x²
//│ 		in (fun _lh_dummy⁰ -> c₀(a²))(99)
//│ def p₀ = 
//│ 	[C p₀]
//│ <<<<<<< after fusion <<<<<<<



// CORRECT: although multiple matches
// top level definitions as producers can be duplicated
fun c1(x1) = if x1 is
  A then AA
  B then BB
fun c2(x2) = if x2 is
  A then AAA
  B then BBB
let a = A
c1(a)
c2(a)
c2(B)
//│ |#fun| |c1|(|x1|)| |#=| |#if| |x1| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|#fun| |c2|(|x2|)| |#=| |#if| |x2| |is|→|A| |#then| |AAA|↵|B| |#then| |BBB|←|↵|#let| |a| |#=| |A|↵|c1|(|a|)|↵|c2|(|a|)|↵|c2|(|B|)|
//│ Parsed: {fun c1 = x1, => if x1 is ‹(A) then AA; (B) then BB›; fun c2 = x2, => if x2 is ‹(A) then AAA; (B) then BBB›; let a = A; c1 (a,); c2 (a,); c2 (B,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c1^12(a^13)
//│ c2^15(a^16)
//│ c2^18([B])
//│ def a = [A]
//│ def c1(x1⁰) = case x1⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def c2(x2⁰) = case x2⁰ of {
//│ 	A  => [AAA]
//│ 	| B  => [BBB]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [a^13] (hopeless to continue)
//│ [a^16] (hopeless to continue)
//│ [c1^12] (hopeless to continue)
//│ [c2^15] (hopeless to continue)
//│ [c2^18] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c1₀(a₀)
//│ c2₀(a₁)
//│ c2₁([B])
//│ def a₀ = 
//│ 	[A]
//│ def a₁ = 
//│ 	[A]
//│ def c1₀(x1¹) = 
//│ 	case x1¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def c2₀(x2¹) = 
//│ 	case x2¹ of {
//│ 		A  => [AAA]
//│ 		| B  => [BBB]}
//│ def c2₁(x2²) = 
//│ 	case x2² of {
//│ 		A  => [AAA]
//│ 		| B  => [BBB]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 21 --->
//│ 	case x1¹ of {A  => [AA] | B  => [BB]}: 25
//│ [A]: 27 --->
//│ 	case x2¹ of {A  => [AAA] | B  => [BBB]}: 31
//│ [B]: 45 --->
//│ 	case x2² of {A  => [AAA] | B  => [BBB]}: 36
//│ ------------------
//│ case x1¹ of {A  => [AA] | B  => [BB]}: 25 --->
//│ 	[A]: 21
//│ case x2¹ of {A  => [AAA] | B  => [BBB]}: 31 --->
//│ 	[A]: 27
//│ case x2² of {A  => [AAA] | B  => [BBB]}: 36 --->
//│ 	[B]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 21 --->
//│ 	case x1¹ of {A  => [AA] | B  => [BB]}: 25
//│ [A]: 27 --->
//│ 	case x2¹ of {A  => [AAA] | B  => [BBB]}: 31
//│ [B]: 45 --->
//│ 	case x2² of {A  => [AAA] | B  => [BBB]}: 36
//│ ------------------
//│ case x1¹ of {A  => [AA] | B  => [BB]}: 25 --->
//│ 	[A]: 21
//│ case x2¹ of {A  => [AAA] | B  => [BBB]}: 31 --->
//│ 	[A]: 27
//│ case x2² of {A  => [AAA] | B  => [BBB]}: 36 --->
//│ 	[B]: 45
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c1₀(a₀)
//│ c2₀(a₁)
//│ c2₁([BBB])
//│ def a₀ = 
//│ 	[AA]
//│ def a₁ = 
//│ 	[AAA]
//│ def c1₀(x1²) = 
//│ 	x1²
//│ def c2₀(x2⁴) = 
//│ 	x2⁴
//│ def c2₁(x2³) = 
//│ 	x2³
//│ <<<<<<< after fusion <<<<<<<





// CORRECT:
fun last(ys) = if ys is
  N then x => x
  C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
  N then None
  C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastDrive^22([C 1 [C 2 [N]]])
//│ def last(ys⁰) = case ys⁰ of {
//│ 	N  => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> last^4(t⁰, h⁰))}
//│ def lastDrive(xs⁰) = case xs⁰ of {
//│ 	N  => [None]
//│ 	| C hh⁰ tt⁰ => [Some last^14(tt⁰, hh⁰)]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive^22]
//│ 	[lastDrive^22 · last^14]
//│ 		[lastDrive^22 · last^14 · last^4] ---> [lastDrive^22 · last^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastDrive₀([C 1 [C 2 [N]]])
//│ def lastDrive₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => [None]
//│ 		| C hh¹ tt¹ => [Some last₀(tt¹, hh¹)]}
//│ 	where
//│ 	def last₀(ys¹) = 
//│ 		case ys¹ of {
//│ 			N  => (fun x² -> x²)
//│ 			| C h¹ t¹ => (fun x³ -> last₀(t¹, h¹))}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last₀(t¹, h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last₀(t¹, h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last₀(tt¹, hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last₀(tt¹, hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last₀(t¹, h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last₀(t¹, h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last₀(t¹, h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last₀(tt¹, hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last₀(tt¹, hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last₀(t¹, h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastDrive₀(
//│ 	let hh² = 1
//│ 	in let tt² = 	
//│ 		let h² = 2
//│ 		in let t² = (fun x⁵ -> x⁵)
//│ 		in (fun x⁴ -> last₀(t², h²))
//│ 	in (fun _lh_dummy⁰ -> [Some last₀(tt², hh²)]))
//│ def lastDrive₀(xs²) = 
//│ 	xs²(99)
//│ 	where
//│ 	def last₀(ys²) = 
//│ 		ys²
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: the time of unrolling is correct
fun id(k) = k
fun id1(x) = id(x)
fun id2(y) = y
fun id3(z) = z
let rec p = C(C(C(id7(C(C(id1(p)))))))
fun c(xx) = if xx is
  C(a) then c(a)
fun id4(k) = k
fun id5(j) = j
fun id6(l) = l
fun id7(i) = i
id6(id4)(c)(id5(id2)(id3(p)))
//│ |#fun| |id|(|k|)| |#=| |k|↵|#fun| |id1|(|x|)| |#=| |id|(|x|)|↵|#fun| |id2|(|y|)| |#=| |y|↵|#fun| |id3|(|z|)| |#=| |z|↵|#let| |#rec| |p| |#=| |C|(|C|(|C|(|id7|(|C|(|C|(|id1|(|p|)|)|)|)|)|)|)|↵|#fun| |c|(|xx|)| |#=| |#if| |xx| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id4|(|k|)| |#=| |k|↵|#fun| |id5|(|j|)| |#=| |j|↵|#fun| |id6|(|l|)| |#=| |l|↵|#fun| |id7|(|i|)| |#=| |i|↵|id6|(|id4|)|(|c|)|(|id5|(|id2|)|(|id3|(|p|)|)|)|
//│ Parsed: {fun id = k, => k; fun id1 = x, => id (x,); fun id2 = y, => y; fun id3 = z, => z; let rec p = C (C (C (id7 (C (C (id1 (p,),),),),),),); fun c = xx, => if xx is ‹(C (a,)) then c (a,)›; fun id4 = k, => k; fun id5 = j, => j; fun id6 = l, => l; fun id7 = i, => i; id6 (id4,) (c,) (id5 (id2,) (id3 (p,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ id6^35(id4^36, c^38, id5^40(id2^41, id3^43(p^44)))
//│ def c(xx⁰) = case xx⁰ of {
//│ 	C a⁰ => c^22(a⁰)}
//│ def id(k⁰) = k⁰
//│ def id1(x⁰) = id^3(x⁰)
//│ def id2(y⁰) = y⁰
//│ def id3(z⁰) = z⁰
//│ def id4(k¹) = k¹
//│ def id5(j⁰) = j⁰
//│ def id6(l⁰) = l⁰
//│ def id7(i⁰) = i⁰
//│ def p = [C [C [C id7^11([C [C id1^12(p^13)]])]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^38]
//│ 	[c^38 · c^22]
//│ 		[c^38 · c^22 · c^22]
//│ 			[c^38 · c^22 · c^22 · c^22]
//│ 				[c^38 · c^22 · c^22 · c^22 · c^22]
//│ 					[c^38 · c^22 · c^22 · c^22 · c^22 · c^22] ---> [c^38] (only one)
//│ [id2^41] (hopeless to continue)
//│ [id3^43] (hopeless to continue)
//│ [id4^36] (hopeless to continue)
//│ [id5^40] (hopeless to continue)
//│ [id6^35] (hopeless to continue)
//│ [p^44]
//│ 	[p^44 · id1^12] (hopeless to continue)
//│ 		[p^44 · id1^12 · id^3] (using original def)
//│ 	[p^44 · id7^11] (hopeless to continue)
//│ 	[p^44 · p^13] ---> [p^44] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ id6₀(id4₀, c₀, id5₀(id2₀, id3₀(p₀)))
//│ def c₀(xx⁴) = 
//│ 	case xx⁴ of {
//│ 		C a⁴ => c₁(a⁴)}
//│ 	where
//│ 	def c₁(xx¹) = 
//│ 		case xx¹ of {
//│ 			C a¹ => c₂(a¹)}
//│ 		where
//│ 		def c₂(xx⁵) = 
//│ 			case xx⁵ of {
//│ 				C a⁵ => c₃(a⁵)}
//│ 			where
//│ 			def c₃(xx²) = 
//│ 				case xx² of {
//│ 					C a² => c₄(a²)}
//│ 				where
//│ 				def c₄(xx³) = 
//│ 					case xx³ of {
//│ 						C a³ => c₀(a³)}
//│ def id2₀(y¹) = 
//│ 	y¹
//│ def id3₀(z¹) = 
//│ 	z¹
//│ def id4₀(k²) = 
//│ 	k²
//│ def id5₀(j¹) = 
//│ 	j¹
//│ def id6₀(l¹) = 
//│ 	l¹
//│ def p₀ = 
//│ 	[C [C [C id7₀([C [C id1₀(p₀)]])]]]
//│ 	where
//│ 	def id1₀(x¹) = 
//│ 		id₀(x¹)
//│ 		where
//│ 		def id₀(k³) = 
//│ 			k³
//│ 	def id7₀(i¹) = 
//│ 		i¹
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C id1₀(p₀)]: 98 --->
//│ 	case xx³ of {C a³ => c₀(a³)}: 72
//│ [C [C id1₀(p₀)]]: 99 --->
//│ 	case xx² of {C a² => c₄(a²)}: 58
//│ [C id7₀([C [C id1₀(p₀)]])]: 101 --->
//│ 	case xx⁵ of {C a⁵ => c₃(a⁵)}: 92
//│ [C [C id7₀([C [C id1₀(p₀)]])]]: 102 --->
//│ 	case xx¹ of {C a¹ => c₂(a¹)}: 52
//│ [C [C [C id7₀([C [C id1₀(p₀)]])]]]: 103 --->
//│ 	case xx⁴ of {C a⁴ => c₁(a⁴)}: 78
//│ ------------------
//│ case xx¹ of {C a¹ => c₂(a¹)}: 52 --->
//│ 	[C [C id7₀([C [C id1₀(p₀)]])]]: 102
//│ case xx² of {C a² => c₄(a²)}: 58 --->
//│ 	[C [C id1₀(p₀)]]: 99
//│ case xx³ of {C a³ => c₀(a³)}: 72 --->
//│ 	[C id1₀(p₀)]: 98
//│ case xx⁴ of {C a⁴ => c₁(a⁴)}: 78 --->
//│ 	[C [C [C id7₀([C [C id1₀(p₀)]])]]]: 103
//│ case xx⁵ of {C a⁵ => c₃(a⁵)}: 92 --->
//│ 	[C id7₀([C [C id1₀(p₀)]])]: 101
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C id1₀(p₀)]: 98 --->
//│ 	case xx³ of {C a³ => c₀(a³)}: 72
//│ [C [C id1₀(p₀)]]: 99 --->
//│ 	case xx² of {C a² => c₄(a²)}: 58
//│ [C id7₀([C [C id1₀(p₀)]])]: 101 --->
//│ 	case xx⁵ of {C a⁵ => c₃(a⁵)}: 92
//│ [C [C id7₀([C [C id1₀(p₀)]])]]: 102 --->
//│ 	case xx¹ of {C a¹ => c₂(a¹)}: 52
//│ [C [C [C id7₀([C [C id1₀(p₀)]])]]]: 103 --->
//│ 	case xx⁴ of {C a⁴ => c₁(a⁴)}: 78
//│ ------------------
//│ case xx¹ of {C a¹ => c₂(a¹)}: 52 --->
//│ 	[C [C id7₀([C [C id1₀(p₀)]])]]: 102
//│ case xx² of {C a² => c₄(a²)}: 58 --->
//│ 	[C [C id1₀(p₀)]]: 99
//│ case xx³ of {C a³ => c₀(a³)}: 72 --->
//│ 	[C id1₀(p₀)]: 98
//│ case xx⁴ of {C a⁴ => c₁(a⁴)}: 78 --->
//│ 	[C [C [C id7₀([C [C id1₀(p₀)]])]]]: 103
//│ case xx⁵ of {C a⁵ => c₃(a⁵)}: 92 --->
//│ 	[C id7₀([C [C id1₀(p₀)]])]: 101
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ id6₀(id4₀, c₀, id5₀(id2₀, id3₀(p₀)))
//│ def c₀(xx⁹) = 
//│ 	xx⁹(99)
//│ 	where
//│ 	def c₁(xx⁶) = 
//│ 		xx⁶(99)
//│ 		where
//│ 		def c₂(xx¹⁰) = 
//│ 			xx¹⁰(99)
//│ 			where
//│ 			def c₃(xx⁷) = 
//│ 				xx⁷(99)
//│ 				where
//│ 				def c₄(xx⁸) = 
//│ 					xx⁸(99)
//│ def id2₀(y²) = 
//│ 	y²
//│ def id3₀(z²) = 
//│ 	z²
//│ def id4₀(k⁵) = 
//│ 	k⁵
//│ def id5₀(j²) = 
//│ 	j²
//│ def id6₀(l²) = 
//│ 	l²
//│ def p₀ = 
//│ 	let a⁶ = 	
//│ 		let a⁷ = 	
//│ 			let a⁸ = id7₀(
//│ 				let a⁹ = 	
//│ 					let a¹⁰ = id1₀(p₀)
//│ 					in (fun _lh_dummy⁴ -> c₀(a¹⁰))
//│ 				in (fun _lh_dummy³ -> c₄(a⁹)))
//│ 			in (fun _lh_dummy² -> c₃(a⁸))
//│ 		in (fun _lh_dummy¹ -> c₂(a⁷))
//│ 	in (fun _lh_dummy⁰ -> c₁(a⁶))
//│ 	where
//│ 	def id1₀(x²) = 
//│ 		id₀(x²)
//│ 		where
//│ 		def id₀(k⁴) = 
//│ 			k⁴
//│ 	def id7₀(i²) = 
//│ 		i²
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
fun id(x) = if x is
  ID(b) then b
  C(a) then id(ID(C(a)))
let p = C(p)
fun c(y) = if y is
  C(aa) then c(aa)
c(id(p))
//│ |#fun| |id|(|x|)| |#=| |#if| |x| |is|→|ID|(|b|)| |#then| |b|↵|C|(|a|)| |#then| |id|(|ID|(|C|(|a|)|)|)|←|↵|#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |c|(|aa|)|←|↵|c|(|id|(|p|)|)|
//│ Parsed: {fun id = x, => if x is ‹(ID (b,)) then b; (C (a,)) then id (ID (C (a,),),)›; let p = C (p,); fun c = y, => if y is ‹(C (aa,)) then c (aa,)›; c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^18(id^19(p^20))
//│ def c(y⁰) = case y⁰ of {
//│ 	C aa⁰ => c^13(aa⁰)}
//│ def id(x⁰) = case x⁰ of {
//│ 	ID b⁰ => b⁰
//│ 	| C a⁰ => id^3([ID [C a⁰]])}
//│ def p = [C p^10]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^18] (hopeless to continue)
//│ 	[c^18 · c^13] ---> [c^18] (using original def)
//│ [id^19] (hopeless to continue)
//│ 	[id^19 · id^3] ---> [id^19] (using original def)
//│ [p^20] (hopeless to continue)
//│ 	[p^20 · p^10] ---> [p^20] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c₀(id₀(p₀))
//│ def c₀(y¹) = 
//│ 	case y¹ of {
//│ 		C aa¹ => c₀(aa¹)}
//│ def id₀(x¹) = 
//│ 	case x¹ of {
//│ 		ID b¹ => b¹
//│ 		| C a¹ => id₀([ID [C a¹]])}
//│ def p₀ = 
//│ 	[C p₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p₀]: 30 --->
//│ 	case y¹ of {C aa¹ => c₀(aa¹)}: 27
//│ 	case x¹ of {ID b¹ => b¹ | C a¹ => id₀([ID [C a¹]])}: 38
//│ [C a¹]: 35 --->
//│ 	case y¹ of {C aa¹ => c₀(aa¹)}: 27
//│ [ID [C a¹]]: 36 --->
//│ 	case x¹ of {ID b¹ => b¹ | C a¹ => id₀([ID [C a¹]])}: 38
//│ ------------------
//│ case y¹ of {C aa¹ => c₀(aa¹)}: 27 --->
//│ 	[C p₀]: 30
//│ 	[C a¹]: 35
//│ case x¹ of {ID b¹ => b¹ | C a¹ => id₀([ID [C a¹]])}: 38 --->
//│ 	[C p₀]: 30
//│ 	[ID [C a¹]]: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c₀(id₀(p₀))
//│ def c₀(y²) = 
//│ 	case y² of {
//│ 		C aa¹ => c₀(aa¹)}
//│ def id₀(x²) = 
//│ 	case x² of {
//│ 		ID b¹ => b¹
//│ 		| C a¹ => id₀([ID [C a¹]])}
//│ def p₀ = 
//│ 	[C p₀]
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: unlike the rev rev case, TODO: why?
fun map(ls) = if ls is
  C(h, t) then C(
    (if h is
      A then AA
      B then BB
    ),
    map(t)
  )
  N then N
fun len(ls) = if ls is
  C(h, t) then 1 + len(t)
  N then 0
len(map(C(A, C(B, N))))
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#fun| |len|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |1| |+| |len|(|t|)|↵|N| |#then| |0|←|↵|len|(|map|(|C|(|A|,| |C|(|B|,| |N|)|)|)|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(A) then AA; (B) then BB›, ')', map (t,),); (N) then N›; fun len = ls, => if ls is ‹(C (h, t,)) then + (1,) (len (t,),); (N) then 0›; len (map (C (A, C (B, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ len^24(map^25([C [A] [C [B] [N]]]))
//│ def len(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => (1 + len^17(t¹))
//│ 	| N  => 0}
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C case h⁰ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]} map^6(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [len^24]
//│ 	[len^24 · len^17] ---> [len^24] (only one)
//│ [map^25]
//│ 	[map^25 · map^6] ---> [map^25] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ len₀(map₀([C [A] [C [B] [N]]]))
//│ def len₀(ls³) = 
//│ 	case ls³ of {
//│ 		C h³ t³ => (1 + len₀(t³))
//│ 		| N  => 0}
//│ def map₀(ls²) = 
//│ 	case ls² of {
//│ 		C h² t² => [C case h² of {
//│ 			A  => [AA]
//│ 			| B  => [BB]} map₀(t²)]
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C case h² of {A  => [AA] | B  => [BB]} map₀(t²)]: 41 --->
//│ 	case ls³ of {C h³ t³ => (1 + len₀(t³)) | N  => 0}: 54
//│ [N]: 42 --->
//│ 	case ls³ of {C h³ t³ => (1 + len₀(t³)) | N  => 0}: 54
//│ [A]: 58 --->
//│ 	case h² of {A  => [AA] | B  => [BB]}: 37
//│ [B]: 59 --->
//│ 	case h² of {A  => [AA] | B  => [BB]}: 37
//│ [N]: 60 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map₀(t²)] | N  => [N]}: 43
//│ [C [B] [N]]: 61 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map₀(t²)] | N  => [N]}: 43
//│ [C [A] [C [B] [N]]]: 62 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map₀(t²)] | N  => [N]}: 43
//│ ------------------
//│ case h² of {A  => [AA] | B  => [BB]}: 37 --->
//│ 	[A]: 58
//│ 	[B]: 59
//│ case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map₀(t²)] | N  => [N]}: 43 --->
//│ 	[N]: 60
//│ 	[C [B] [N]]: 61
//│ 	[C [A] [C [B] [N]]]: 62
//│ case ls³ of {C h³ t³ => (1 + len₀(t³)) | N  => 0}: 54 --->
//│ 	[C case h² of {A  => [AA] | B  => [BB]} map₀(t²)]: 41
//│ 	[N]: 42
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C case h² of {A  => [AA] | B  => [BB]} map₀(t²)]: 41 --->
//│ 	case ls³ of {C h³ t³ => (1 + len₀(t³)) | N  => 0}: 54
//│ [N]: 42 --->
//│ 	case ls³ of {C h³ t³ => (1 + len₀(t³)) | N  => 0}: 54
//│ [A]: 58 --->
//│ 	case h² of {A  => [AA] | B  => [BB]}: 37
//│ [B]: 59 --->
//│ 	case h² of {A  => [AA] | B  => [BB]}: 37
//│ [N]: 60 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map₀(t²)] | N  => [N]}: 43
//│ [C [B] [N]]: 61 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map₀(t²)] | N  => [N]}: 43
//│ [C [A] [C [B] [N]]]: 62 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map₀(t²)] | N  => [N]}: 43
//│ ------------------
//│ case h² of {A  => [AA] | B  => [BB]}: 37 --->
//│ 	[A]: 58
//│ 	[B]: 59
//│ case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map₀(t²)] | N  => [N]}: 43 --->
//│ 	[N]: 60
//│ 	[C [B] [N]]: 61
//│ 	[C [A] [C [B] [N]]]: 62
//│ case ls³ of {C h³ t³ => (1 + len₀(t³)) | N  => 0}: 54 --->
//│ 	[C case h² of {A  => [AA] | B  => [BB]} map₀(t²)]: 41
//│ 	[N]: 42
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ len₀(map₀(
//│ 	let h⁴ = [AA]
//│ 	in let t⁴ = 	
//│ 		let h⁵ = [BB]
//│ 		in let t⁶ = (fun _lh_dummy⁵ -> (fun _lh_dummy⁴ -> 0))
//│ 		in (fun _lh_dummy³ -> 
//│ 			let t⁷ = map₀(t⁶)
//│ 			in (fun _lh_dummy² -> (1 + len₀(t⁷))))
//│ 	in (fun _lh_dummy¹ -> 
//│ 		let t⁵ = map₀(t⁴)
//│ 		in (fun _lh_dummy⁰ -> (1 + len₀(t⁵))))))
//│ def len₀(ls⁵) = 
//│ 	ls⁵(99)
//│ def map₀(ls⁴) = 
//│ 	ls⁴(99)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: multiple match, but correct
fun f(x) = if x is
  C(a) then f
f(C(A))(C(B))(C(D))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |f|←|↵|f|(|C|(|A|)|)|(|C|(|B|)|)|(|C|(|D|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then f›; f (C (A,),) (C (B,),) (C (D,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^5([C [A]], [C [B]], [C [D]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => f^2}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^5]
//│ 	[f^5 · f^2]
//│ 		[f^5 · f^2 · f^2]
//│ 			[f^5 · f^2 · f^2 · f^2]
//│ 				[f^5 · f^2 · f^2 · f^2 · f^2] ---> [f^5 · f^2 · f^2 · f^2] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C [A]], [C [B]], [C [D]])
//│ def f₀(x²) = 
//│ 	case x² of {
//│ 		C a² => f₁}
//│ 	where
//│ 	def f₁(x⁴) = 
//│ 		case x⁴ of {
//│ 			C a⁴ => f₂}
//│ 		where
//│ 		def f₂(x¹) = 
//│ 			case x¹ of {
//│ 				C a¹ => f₃}
//│ 			where
//│ 			def f₃(x³) = 
//│ 				case x³ of {
//│ 					C a³ => f₃}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 33 --->
//│ 	case x² of {C a² => f₁}: 21
//│ [C [B]]: 36 --->
//│ 	case x⁴ of {C a⁴ => f₂}: 29
//│ [C [D]]: 39 --->
//│ 	case x¹ of {C a¹ => f₃}: 17
//│ ------------------
//│ case x¹ of {C a¹ => f₃}: 17 --->
//│ 	[C [D]]: 39
//│ case x² of {C a² => f₁}: 21 --->
//│ 	[C [A]]: 33
//│ case x⁴ of {C a⁴ => f₂}: 29 --->
//│ 	[C [B]]: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [A]]: 33 --->
//│ 	case x² of {C a² => f₁}: 21
//│ [C [B]]: 36 --->
//│ 	case x⁴ of {C a⁴ => f₂}: 29
//│ [C [D]]: 39 --->
//│ 	case x¹ of {C a¹ => f₃}: 17
//│ ------------------
//│ case x¹ of {C a¹ => f₃}: 17 --->
//│ 	[C [D]]: 39
//│ case x² of {C a² => f₁}: 21 --->
//│ 	[C [A]]: 33
//│ case x⁴ of {C a⁴ => f₂}: 29 --->
//│ 	[C [B]]: 36
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀(f₁, f₂, f₃)
//│ def f₀(x⁶) = 
//│ 	x⁶
//│ 	where
//│ 	def f₁(x⁸) = 
//│ 		x⁸
//│ 		where
//│ 		def f₂(x⁵) = 
//│ 			x⁵
//│ 			where
//│ 			def f₃(x⁷) = 
//│ 				case x⁷ of {
//│ 					C a³ => f₃}
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
let aa = T(N, t, t)
let t = T(K, aa, aa)
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |t|,| |t|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |aa|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, t, t,); let t = T (K, aa, aa,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^24(t^25)
//│ def aa = [T [N] t^2 t^3]
//│ def c(x⁰) = case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K  => [KK]
//│ 		| N  => [NN]} c^14(l⁰) c^17(r⁰)]
//│ 	| L  => [LL]}
//│ def t = [T [K] aa^6 aa^7]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^24]
//│ 	[c^24 · c^14] ---> [c^24] (only one)
//│ 	[c^24 · c^17] ---> [c^24] (only one)
//│ [t^25]
//│ 	[t^25 · aa^6] (hopeless to continue)
//│ 		[t^25 · aa^6 · t^2] (using original def)
//│ 			[t^25 · aa^6 · t^2 · aa^6] ---> [t^25 · aa^6] (using original def)
//│ 			[t^25 · aa^6 · t^2 · aa^7] ---> [t^25 · aa^6] (using original def)
//│ 		[t^25 · aa^6 · t^3] (using original def)
//│ 			[t^25 · aa^6 · t^3 · aa^6] ---> [t^25 · aa^6] (using original def)
//│ 			[t^25 · aa^6 · t^3 · aa^7] ---> [t^25 · aa^6] (using original def)
//│ 	[t^25 · aa^7]
//│ 		[t^25 · aa^7 · t^2] ---> [t^25] (only one)
//│ 		[t^25 · aa^7 · t^3] ---> [t^25] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c₀(t₀)
//│ def c₀(x¹) = 
//│ 	case x¹ of {
//│ 		T n¹ l¹ r¹ => [T case n¹ of {
//│ 			K  => [KK]
//│ 			| N  => [NN]} c₀(l¹) c₀(r¹)]
//│ 		| L  => [LL]}
//│ def t₀ = 
//│ 	[T [K] aa₀ aa₁]
//│ 	where
//│ 	def aa₀ = 
//│ 		[T [N] t₁ t₂]
//│ 		where
//│ 		def t₁ = 
//│ 			[T [K] aa₀ aa₀]
//│ 		def t₂ = 
//│ 			[T [K] aa₀ aa₀]
//│ 	def aa₁ = 
//│ 		[T [N] t₀ t₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 42 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [N] t₀ t₀]: 45 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 40
//│ [K]: 46 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [K] aa₀ aa₀]: 49 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 40
//│ [K]: 50 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [K] aa₀ aa₀]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 40
//│ [K]: 54 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [K] aa₀ aa₁]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 40
//│ [N]: 58 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [N] t₁ t₂]: 61 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 40
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 31 --->
//│ 	[N]: 42
//│ 	[K]: 46
//│ 	[K]: 50
//│ 	[K]: 54
//│ 	[N]: 58
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 40 --->
//│ 	[T [N] t₀ t₀]: 45
//│ 	[T [K] aa₀ aa₀]: 49
//│ 	[T [K] aa₀ aa₀]: 53
//│ 	[T [K] aa₀ aa₁]: 57
//│ 	[T [N] t₁ t₂]: 61
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 42 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [N] t₀ t₀]: 45 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 40
//│ [K]: 46 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [K] aa₀ aa₀]: 49 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 40
//│ [K]: 50 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [K] aa₀ aa₀]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 40
//│ [K]: 54 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [K] aa₀ aa₁]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 40
//│ [N]: 58 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [N] t₁ t₂]: 61 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 40
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 31 --->
//│ 	[N]: 42
//│ 	[K]: 46
//│ 	[K]: 50
//│ 	[K]: 54
//│ 	[N]: 58
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c₀(l¹) c₀(r¹)] | L  => [LL]}: 40 --->
//│ 	[T [N] t₀ t₀]: 45
//│ 	[T [K] aa₀ aa₀]: 49
//│ 	[T [K] aa₀ aa₀]: 53
//│ 	[T [K] aa₀ aa₁]: 57
//│ 	[T [N] t₁ t₂]: 61
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c₀(t₀)
//│ def c₀(x²) = 
//│ 	x²(99)
//│ def t₀ = 
//│ 	let n² = [KK]
//│ 	in let l² = aa₀
//│ 	in let r² = aa₁
//│ 	in (fun _lh_dummy⁰ -> [T n² c₀(l²) c₀(r²)])
//│ 	where
//│ 	def aa₀ = 
//│ 		let n⁶ = [NN]
//│ 		in let l⁶ = t₁
//│ 		in let r⁶ = t₂
//│ 		in (fun _lh_dummy⁴ -> [T n⁶ c₀(l⁶) c₀(r⁶)])
//│ 		where
//│ 		def t₁ = 
//│ 			let n⁵ = [KK]
//│ 			in let l⁵ = aa₀
//│ 			in let r⁵ = aa₀
//│ 			in (fun _lh_dummy³ -> [T n⁵ c₀(l⁵) c₀(r⁵)])
//│ 		def t₂ = 
//│ 			let n⁴ = [KK]
//│ 			in let l⁴ = aa₀
//│ 			in let r⁴ = aa₀
//│ 			in (fun _lh_dummy² -> [T n⁴ c₀(l⁴) c₀(r⁴)])
//│ 	def aa₁ = 
//│ 		let n³ = [NN]
//│ 		in let l³ = t₀
//│ 		in let r³ = t₀
//│ 		in (fun _lh_dummy¹ -> [T n³ c₀(l³) c₀(r³)])
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: but explode on branches
fun filter(ls) = if ls is
  C(h, t) then if h > 1 is
    True then C(h, filter(t))
    False then filter(t)
  N then N
filter(C(1, C(2, C(3, N))))
//│ |#fun| |filter|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |>| |1| |is|→|True| |#then| |C|(|h|,| |filter|(|t|)|)|↵|False| |#then| |filter|(|t|)|←|↵|N| |#then| |N|←|↵|filter|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {fun filter = ls, => if ls is ‹(C (h, t,)) then if > (h,) (1,) is ‹(True) then C (h, filter (t,),); (False) then filter (t,)›; (N) then N›; filter (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ filter^19([C 1 [C 2 [C 3 [N]]]])
//│ def filter(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case (h⁰ > 1) of {
//│ 		True  => [C h⁰ filter^8(t⁰)]
//│ 		| False  => filter^12(t⁰)}
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [filter^19]
//│ 	[filter^19 · filter^12] ---> [filter^19] (only one)
//│ 	[filter^19 · filter^8] ---> [filter^19] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ filter₀([C 1 [C 2 [C 3 [N]]]])
//│ def filter₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => case (h¹ > 1) of {
//│ 			True  => [C h¹ filter₀(t¹)]
//│ 			| False  => filter₀(t¹)}
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 50 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter₀(t¹)] | False  => filter₀(t¹)} | N  => [N]}: 44
//│ [C 3 [N]]: 51 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter₀(t¹)] | False  => filter₀(t¹)} | N  => [N]}: 44
//│ [C 2 [C 3 [N]]]: 52 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter₀(t¹)] | False  => filter₀(t¹)} | N  => [N]}: 44
//│ [C 1 [C 2 [C 3 [N]]]]: 53 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter₀(t¹)] | False  => filter₀(t¹)} | N  => [N]}: 44
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter₀(t¹)] | False  => filter₀(t¹)} | N  => [N]}: 44 --->
//│ 	[N]: 50
//│ 	[C 3 [N]]: 51
//│ 	[C 2 [C 3 [N]]]: 52
//│ 	[C 1 [C 2 [C 3 [N]]]]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 50 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter₀(t¹)] | False  => filter₀(t¹)} | N  => [N]}: 44
//│ [C 3 [N]]: 51 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter₀(t¹)] | False  => filter₀(t¹)} | N  => [N]}: 44
//│ [C 2 [C 3 [N]]]: 52 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter₀(t¹)] | False  => filter₀(t¹)} | N  => [N]}: 44
//│ [C 1 [C 2 [C 3 [N]]]]: 53 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter₀(t¹)] | False  => filter₀(t¹)} | N  => [N]}: 44
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter₀(t¹)] | False  => filter₀(t¹)} | N  => [N]}: 44 --->
//│ 	[N]: 50
//│ 	[C 3 [N]]: 51
//│ 	[C 2 [C 3 [N]]]: 52
//│ 	[C 1 [C 2 [C 3 [N]]]]: 53
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ filter₀(
//│ 	let h² = 1
//│ 	in let t² = 	
//│ 		let h³ = 2
//│ 		in let t³ = 	
//│ 			let h⁴ = 3
//│ 			in let t⁴ = (fun _lh_dummy³ -> [N])
//│ 			in (fun _lh_dummy² -> case (h⁴ > 1) of {
//│ 				True  => [C h⁴ filter₀(t⁴)]
//│ 				| False  => filter₀(t⁴)})
//│ 		in (fun _lh_dummy¹ -> case (h³ > 1) of {
//│ 			True  => [C h³ filter₀(t³)]
//│ 			| False  => filter₀(t³)})
//│ 	in (fun _lh_dummy⁰ -> case (h² > 1) of {
//│ 		True  => [C h² filter₀(t²)]
//│ 		| False  => filter₀(t²)}))
//│ def filter₀(ls²) = 
//│ 	ls²(99)
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: top level defs used multiple times are fine
// but top level producers used multiple times may result in duplicated computation
let p = C(p)
let pp = C(C(pp))
fun c(x) = if x is
  C(a) then if a is
    C(b) then c(b)
    N then a
  N then x
P(c(pp), c(p))
//│ |#let| |p| |#=| |C|(|p|)|↵|#let| |pp| |#=| |C|(|C|(|pp|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |c|(|b|)|↵|N| |#then| |a|←|↵|N| |#then| |x|←|↵|P|(|c|(|pp|)|,| |c|(|p|)|)|
//│ Parsed: {let p = C (p,); let pp = C (C (pp,),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then c (b,); (N) then a›; (N) then x›; P (c (pp,), c (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ [P c^16(pp^17) c^19(p^20)]
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => c^8(b⁰)
//│ 		| N  => a⁰}
//│ 	| N  => x⁰}
//│ def p = [C p^1]
//│ def pp = [C [C pp^3]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^16]
//│ 	[c^16 · c^8] ---> [c^16] (only one)
//│ [c^19]
//│ 	[c^19 · c^8] ---> [c^19] (only one)
//│ [p^20]
//│ 	[p^20 · p^1]
//│ 		[p^20 · p^1 · p^1] ---> [p^20 · p^1] ([p · p] OR [p])
//│ [pp^17]
//│ 	[pp^17 · pp^3] ---> [pp^17] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ [P c₀(pp₀) c₁(p₀)]
//│ def c₀(x²) = 
//│ 	case x² of {
//│ 		C a² => case a² of {
//│ 			C b² => c₀(b²)
//│ 			| N  => a²}
//│ 		| N  => x²}
//│ def c₁(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => case a¹ of {
//│ 			C b¹ => c₁(b¹)
//│ 			| N  => a¹}
//│ 		| N  => x¹}
//│ def p₀ = 
//│ 	[C p₁]
//│ 	where
//│ 	def p₁ = 
//│ 		[C p₁]
//│ def pp₀ = 
//│ 	[C [C pp₀]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C pp₀]: 24 --->
//│ 	NoCons
//│ 	case a² of {C b² => c₀(b²) | N  => a²}: 46
//│ [C [C pp₀]]: 25 --->
//│ 	NoCons
//│ 	case x² of {C a² => case a² of {C b² => c₀(b²) | N  => a²} | N  => x²}: 48
//│ [C p₁]: 37 --->
//│ 	NoCons
//│ 	case a¹ of {C b¹ => c₁(b¹) | N  => a¹}: 32
//│ 	case x¹ of {C a¹ => case a¹ of {C b¹ => c₁(b¹) | N  => a¹} | N  => x¹}: 34
//│ [C p₁]: 39 --->
//│ 	NoCons
//│ 	case x¹ of {C a¹ => case a¹ of {C b¹ => c₁(b¹) | N  => a¹} | N  => x¹}: 34
//│ ------------------
//│ case a¹ of {C b¹ => c₁(b¹) | N  => a¹}: 32 --->
//│ 	[C p₁]: 37
//│ case x¹ of {C a¹ => case a¹ of {C b¹ => c₁(b¹) | N  => a¹} | N  => x¹}: 34 --->
//│ 	[C p₁]: 37
//│ 	[C p₁]: 39
//│ case a² of {C b² => c₀(b²) | N  => a²}: 46 --->
//│ 	[C pp₀]: 24
//│ case x² of {C a² => case a² of {C b² => c₀(b²) | N  => a²} | N  => x²}: 48 --->
//│ 	[C [C pp₀]]: 25
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ [P c₀(pp₀) c₁(p₀)]
//│ def c₀(x³) = 
//│ 	case x³ of {
//│ 		C a² => case a² of {
//│ 			C b² => c₀(b²)
//│ 			| N  => a²}
//│ 		| N  => x³}
//│ def c₁(x⁴) = 
//│ 	case x⁴ of {
//│ 		C a¹ => case a¹ of {
//│ 			C b¹ => c₁(b¹)
//│ 			| N  => a¹}
//│ 		| N  => x⁴}
//│ def p₀ = 
//│ 	[C p₁]
//│ 	where
//│ 	def p₁ = 
//│ 		[C p₁]
//│ def pp₀ = 
//│ 	[C [C pp₀]]
//│ <<<<<<< after fusion <<<<<<<


// CORRECT:
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  N then a => a
  C(h, t) then a => rev(t, C(h, a))
fun rev2(ls2) = if ls2 is
  N then a2 => a2
  C(h2, t2) then a2 => rev2(t2, C(h2, a2))
rev2(rev(C(1, C(2, N)))(N))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a| |=>| |a|↵|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|,| |C|(|h|,| |a|)|)|←|↵|#fun| |rev2|(|ls2|)| |#=| |#if| |ls2| |is|→|N| |#then| |a2| |=>| |a2|↵|C|(|h2|,| |t2|)| |#then| |a2| |=>| |rev2|(|t2|,| |C|(|h2|,| |a2|)|)|←|↵|rev2|(|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|N|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(N) then a, => a; (C (h, t,)) then a, => rev (t, C (h, a,),)›; fun rev2 = ls2, => if ls2 is ‹(N) then a2, => a2; (C (h2, t2,)) then a2, => rev2 (t2, C (h2, a2,),)›; rev2 (rev (C (1, C (2, N,),),) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev2^27(rev^28([C 1 [C 2 [N]]], [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	N  => (fun a⁰ -> a⁰)
//│ 	| C h⁰ t⁰ => (fun a¹ -> rev^4(t⁰, [C h⁰ a¹]))}
//│ def rev2(ls2⁰) = case ls2⁰ of {
//│ 	N  => (fun a2⁰ -> a2⁰)
//│ 	| C h2⁰ t2⁰ => (fun a2¹ -> rev2^17(t2⁰, [C h2⁰ a2¹]))}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev2^27] (hopeless to continue)
//│ 	[rev2^27 · rev2^17] ---> [rev2^27] (using original def)
//│ [rev^28]
//│ 	[rev^28 · rev^4] ---> [rev^28] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev2₀(rev₀([C 1 [C 2 [N]]], [N]), [N])
//│ def rev2₀(ls2¹) = 
//│ 	case ls2¹ of {
//│ 		N  => (fun a2² -> a2²)
//│ 		| C h2¹ t2¹ => (fun a2³ -> rev2₀(t2¹, [C h2¹ a2³]))}
//│ def rev₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		N  => (fun a² -> a²)
//│ 		| C h¹ t¹ => (fun a³ -> rev₀(t¹, [C h¹ a³]))}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ a³]: 61 --->
//│ 	case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2₀(t2¹, [C h2¹ a2³]))}: 51
//│ [N]: 70 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev₀(t¹, [C h¹ a³]))}: 64
//│ [C 2 [N]]: 71 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev₀(t¹, [C h¹ a³]))}: 64
//│ [C 1 [C 2 [N]]]: 72 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev₀(t¹, [C h¹ a³]))}: 64
//│ [N]: 74 --->
//│ 	case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2₀(t2¹, [C h2¹ a2³]))}: 51
//│ ------------------
//│ case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2₀(t2¹, [C h2¹ a2³]))}: 51 --->
//│ 	[C h¹ a³]: 61
//│ 	[N]: 74
//│ case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev₀(t¹, [C h¹ a³]))}: 64 --->
//│ 	[N]: 70
//│ 	[C 2 [N]]: 71
//│ 	[C 1 [C 2 [N]]]: 72
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a³]: 61 --->
//│ 	case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2₀(t2¹, [C h2¹ a2³]))}: 51
//│ [N]: 70 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev₀(t¹, [C h¹ a³]))}: 64
//│ [C 2 [N]]: 71 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev₀(t¹, [C h¹ a³]))}: 64
//│ [C 1 [C 2 [N]]]: 72 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev₀(t¹, [C h¹ a³]))}: 64
//│ [N]: 74 --->
//│ 	case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2₀(t2¹, [C h2¹ a2³]))}: 51
//│ ------------------
//│ case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2₀(t2¹, [C h2¹ a2³]))}: 51 --->
//│ 	[C h¹ a³]: 61
//│ 	[N]: 74
//│ case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev₀(t¹, [C h¹ a³]))}: 64 --->
//│ 	[N]: 70
//│ 	[C 2 [N]]: 71
//│ 	[C 1 [C 2 [N]]]: 72
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev2₀(rev₀(
//│ 	let h² = 1
//│ 	in let t² = 	
//│ 		let h³ = 2
//│ 		in let t³ = (fun a⁶ -> a⁶)
//│ 		in (fun a⁵ -> rev₀(t³, 
//│ 			let h2³ = h³
//│ 			in let t2³ = a⁵
//│ 			in (fun a2⁵ -> rev2₀(t2³, [C h2³ a2⁵]))))
//│ 	in (fun a⁴ -> rev₀(t², 
//│ 		let h2² = h²
//│ 		in let t2² = a⁴
//│ 		in (fun a2⁴ -> rev2₀(t2², [C h2² a2⁴])))), (fun a2⁶ -> a2⁶)), [N])
//│ def rev2₀(ls2²) = 
//│ 	ls2²
//│ def rev₀(ls²) = 
//│ 	ls²
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [N]]]
//│ <<<<<<< evaluate <<<<<<<


// CORRECT: rev actually works (despite the fact that there are some match clash),
// and duplicated usage of toplevel things are alright
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
rev(C(A, C(B, N)))(N)
rev(rev(C(A, C(B, N)))(N))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|rev|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|N|)|↵|rev|(|rev|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|N|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; rev (C (A, C (B, N,),),) (N,); rev (rev (C (A, C (B, N,),),) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^14([C [A] [C [B] [N]]], [N])
//│ rev^23(rev^24([C [A] [C [B] [N]]], [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev^2(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [B] [C [A] [N]]]
//│ [C [A] [C [B] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14]
//│ 	[rev^14 · rev^2] ---> [rev^14] (only one)
//│ [rev^23]
//│ 	[rev^23 · rev^2] ---> [rev^23] (only one)
//│ [rev^24]
//│ 	[rev^24 · rev^2] ---> [rev^24] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev₀([C [A] [C [B] [N]]], [N])
//│ rev₁(rev₂([C [A] [C [B] [N]]], [N]), [N])
//│ def rev₀(ls²) = 
//│ 	case ls² of {
//│ 		C h² t² => (fun a⁴ -> rev₀(t², [C h² a⁴]))
//│ 		| N  => (fun a⁵ -> a⁵)}
//│ def rev₁(ls³) = 
//│ 	case ls³ of {
//│ 		C h³ t³ => (fun a⁶ -> rev₁(t³, [C h³ a⁶]))
//│ 		| N  => (fun a⁷ -> a⁷)}
//│ def rev₂(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => (fun a² -> rev₂(t¹, [C h¹ a²]))
//│ 		| N  => (fun a³ -> a³)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ a²]: 42 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> rev₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73
//│ [N]: 78 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [C [B] [N]]: 79 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [C [A] [C [B] [N]]]: 80 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [N]: 88 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [C [B] [N]]: 89 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [C [A] [C [B] [N]]]: 90 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [N]: 92 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> rev₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> rev₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47 --->
//│ 	[N]: 88
//│ 	[C [B] [N]]: 89
//│ 	[C [A] [C [B] [N]]]: 90
//│ case ls² of {C h² t² => (fun a⁴ -> rev₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60 --->
//│ 	[N]: 78
//│ 	[C [B] [N]]: 79
//│ 	[C [A] [C [B] [N]]]: 80
//│ case ls³ of {C h³ t³ => (fun a⁶ -> rev₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73 --->
//│ 	[C h¹ a²]: 42
//│ 	[N]: 92
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a²]: 42 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> rev₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73
//│ [N]: 78 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [C [B] [N]]: 79 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [C [A] [C [B] [N]]]: 80 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [N]: 88 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [C [B] [N]]: 89 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [C [A] [C [B] [N]]]: 90 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [N]: 92 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> rev₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> rev₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47 --->
//│ 	[N]: 88
//│ 	[C [B] [N]]: 89
//│ 	[C [A] [C [B] [N]]]: 90
//│ case ls² of {C h² t² => (fun a⁴ -> rev₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60 --->
//│ 	[N]: 78
//│ 	[C [B] [N]]: 79
//│ 	[C [A] [C [B] [N]]]: 80
//│ case ls³ of {C h³ t³ => (fun a⁶ -> rev₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73 --->
//│ 	[C h¹ a²]: 42
//│ 	[N]: 92
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev₀(
//│ 	let h⁴ = [A]
//│ 	in let t⁴ = 	
//│ 		let h⁵ = [B]
//│ 		in let t⁵ = (fun a¹⁰ -> a¹⁰)
//│ 		in (fun a⁹ -> rev₀(t⁵, [C h⁵ a⁹]))
//│ 	in (fun a⁸ -> rev₀(t⁴, [C h⁴ a⁸])), [N])
//│ rev₁(rev₂(
//│ 	let h⁶ = [A]
//│ 	in let t⁶ = 	
//│ 		let h⁸ = [B]
//│ 		in let t⁸ = (fun a¹⁵ -> a¹⁵)
//│ 		in (fun a¹³ -> rev₂(t⁸, 
//│ 			let h⁹ = h⁸
//│ 			in let t⁹ = a¹³
//│ 			in (fun a¹⁴ -> rev₁(t⁹, [C h⁹ a¹⁴]))))
//│ 	in (fun a¹¹ -> rev₂(t⁶, 
//│ 		let h⁷ = h⁶
//│ 		in let t⁷ = a¹¹
//│ 		in (fun a¹² -> rev₁(t⁷, [C h⁷ a¹²])))), (fun a¹⁶ -> a¹⁶)), [N])
//│ def rev₀(ls⁵) = 
//│ 	ls⁵
//│ def rev₁(ls⁶) = 
//│ 	ls⁶
//│ def rev₂(ls⁴) = 
//│ 	ls⁴
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [B] [C [A] [N]]]
//│ [C [A] [C [B] [N]]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT: using primitive is also correct
fun rev(ls) = if ls is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
rev(rev(primitive)(N))(N)
//│ |#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|rev|(|rev|(|primitive|)|(|N|)|)|(|N|)|
//│ Parsed: {fun rev = ls, => if ls is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; rev (rev (primitive,) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^14(rev^15(primitive⁰, [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev^2(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14]
//│ 	[rev^14 · rev^2] ---> [rev^14] (only one)
//│ [rev^15]
//│ 	[rev^15 · rev^2] ---> [rev^15] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev₀(rev₁(primitive⁰, [N]), [N])
//│ def rev₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => (fun a² -> rev₀(t¹, [C h¹ a²]))
//│ 		| N  => (fun a³ -> a³)}
//│ def rev₁(ls²) = 
//│ 	case ls² of {
//│ 		C h² t² => (fun a⁴ -> rev₁(t², [C h² a⁴]))
//│ 		| N  => (fun a⁵ -> a⁵)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h² a⁴]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ [N]: 53 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> rev₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34 --->
//│ 	[C h² a⁴]: 42
//│ 	[N]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h² a⁴]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ [N]: 53 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> rev₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34 --->
//│ 	[C h² a⁴]: 42
//│ 	[N]: 53
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev₀(rev₁(primitive⁰, (fun a⁶ -> a⁶)), [N])
//│ def rev₀(ls³) = 
//│ 	ls³
//│ def rev₁(ls⁴) = 
//│ 	case ls⁴ of {
//│ 		C h² t² => (fun a⁷ -> rev₁(t², 
//│ 			let h³ = h²
//│ 			in let t³ = a⁷
//│ 			in (fun a⁸ -> rev₀(t³, [C h³ a⁸]))))
//│ 		| N  => (fun a⁹ -> a⁹)}
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: even normal rev can be optimized?
// NOTE: may be only out of luck: we choose 
_LUMBERHACK_EVAL
fun concat(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(C(1, C(2, N)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^27([C 1 [C 2 [N]]])
//│ def concat(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat^5(t⁰, ys¹)])}
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^15(rev^16(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^27]
//│ 	[rev^27 · concat^15]
//│ 		[rev^27 · concat^15 · concat^5] ---> [rev^27 · concat^15] (only one)
//│ 	[rev^27 · rev^16] ---> [rev^27] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev₀([C 1 [C 2 [N]]])
//│ def rev₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h³ t³ => concat₀(rev₀(t³), [C h³ [N]])
//│ 		| N  => [N]}
//│ 	where
//│ 	def concat₀(xs¹) = 
//│ 		case xs¹ of {
//│ 			N  => (fun ys² -> ys²)
//│ 			| C h² t² => (fun ys³ -> [C h² concat₀(t², ys³)])}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h² concat₀(t², ys³)]: 43 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat₀(t², ys³)])}: 45
//│ [N]: 54 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat₀(t², ys³)])}: 45
//│ [C h³ [N]]: 55 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat₀(t², ys³)])}: 45
//│ [N]: 57 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat₀(t², ys³)])}: 45
//│ [N]: 63 --->
//│ 	case ls¹ of {C h³ t³ => concat₀(rev₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ [C 2 [N]]: 64 --->
//│ 	case ls¹ of {C h³ t³ => concat₀(rev₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ [C 1 [C 2 [N]]]: 65 --->
//│ 	case ls¹ of {C h³ t³ => concat₀(rev₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat₀(t², ys³)])}: 45 --->
//│ 	[C h² concat₀(t², ys³)]: 43
//│ 	[N]: 54
//│ 	[C h³ [N]]: 55
//│ 	[N]: 57
//│ case ls¹ of {C h³ t³ => concat₀(rev₀(t³), [C h³ [N]]) | N  => [N]}: 58 --->
//│ 	[N]: 63
//│ 	[C 2 [N]]: 64
//│ 	[C 1 [C 2 [N]]]: 65
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 63 --->
//│ 	case ls¹ of {C h³ t³ => concat₀(rev₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ [C 2 [N]]: 64 --->
//│ 	case ls¹ of {C h³ t³ => concat₀(rev₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ [C 1 [C 2 [N]]]: 65 --->
//│ 	case ls¹ of {C h³ t³ => concat₀(rev₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ ------------------
//│ case ls¹ of {C h³ t³ => concat₀(rev₀(t³), [C h³ [N]]) | N  => [N]}: 58 --->
//│ 	[N]: 63
//│ 	[C 2 [N]]: 64
//│ 	[C 1 [C 2 [N]]]: 65
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev₀(
//│ 	let h⁴ = 1
//│ 	in let t⁴ = 	
//│ 		let h⁵ = 2
//│ 		in let t⁵ = (fun _lh_dummy² -> [N])
//│ 		in (fun _lh_dummy¹ -> concat₀(rev₀(t⁵), [C h⁵ [N]]))
//│ 	in (fun _lh_dummy⁰ -> concat₀(rev₀(t⁴), [C h⁴ [N]])))
//│ def rev₀(ls²) = 
//│ 	ls²(99)
//│ 	where
//│ 	def concat₀(xs²) = 
//│ 		case xs² of {
//│ 			N  => (fun ys⁴ -> ys⁴)
//│ 			| C h² t² => (fun ys⁵ -> [C h² concat₀(t², ys⁵)])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [concat₀^18]
//│ 	[concat₀^18 · concat₀^35] ---> [concat₀^18] (only one)
//│ [concat₀^6]
//│ 	[concat₀^6 · concat₀^35] ---> [concat₀^6] (only one)
//│ [rev₀^19] (hopeless to continue)
//│ [rev₀^1] (hopeless to continue)
//│ [rev₀^7] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev₀₁(
//│ 	let h⁵ = 1
//│ 	in let t⁵ = 	
//│ 		let h⁶ = 2
//│ 		in let t⁶ = (fun _lh_dummy³ -> [N])
//│ 		in (fun _lh_dummy⁴ -> concat₀₁(rev₀₂(t⁶), [C h⁶ [N]]))
//│ 	in (fun _lh_dummy⁵ -> concat₀₀(rev₀₀(t⁵), [C h⁵ [N]])))
//│ def concat₀₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => (fun ys² -> ys²)
//│ 		| C h³ t³ => (fun ys³ -> [C h³ concat₀₀(t³, ys³)])}
//│ def concat₀₁(xs²) = 
//│ 	case xs² of {
//│ 		N  => (fun ys⁴ -> ys⁴)
//│ 		| C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ concat₀₁(t⁴, ys⁵)])}
//│ def rev₀₀(ls³) = 
//│ 	ls³(99)
//│ def rev₀₁(ls²) = 
//│ 	ls²(99)
//│ def rev₀₂(ls¹) = 
//│ 	ls¹(99)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁴ concat₀₁(t⁴, ys⁵)]: 74 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat₀₀(t³, ys³)])}: 59
//│ [N]: 89 --->
//│ 	case xs² of {N  => (fun ys⁴ -> ys⁴) | C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ concat₀₁(t⁴, ys⁵)])}: 76
//│ [N]: 97 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat₀₀(t³, ys³)])}: 59
//│ [C h⁶ [N]]: 98 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat₀₀(t³, ys³)])}: 59
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat₀₀(t³, ys³)])}: 59 --->
//│ 	[C h⁴ concat₀₁(t⁴, ys⁵)]: 74
//│ 	[N]: 97
//│ 	[C h⁶ [N]]: 98
//│ case xs² of {N  => (fun ys⁴ -> ys⁴) | C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ concat₀₁(t⁴, ys⁵)])}: 76 --->
//│ 	DeadCodeProd
//│ 	[N]: 89
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h⁴ concat₀₁(t⁴, ys⁵)]: 74 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat₀₀(t³, ys³)])}: 59
//│ [N]: 97 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat₀₀(t³, ys³)])}: 59
//│ [C h⁶ [N]]: 98 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat₀₀(t³, ys³)])}: 59
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat₀₀(t³, ys³)])}: 59 --->
//│ 	[C h⁴ concat₀₁(t⁴, ys⁵)]: 74
//│ 	[N]: 97
//│ 	[C h⁶ [N]]: 98
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev₀₁(
//│ 	let h⁷ = 1
//│ 	in let t⁷ = 	
//│ 		let h⁸ = 2
//│ 		in let t⁸ = (fun _lh_dummy⁶ -> [N])
//│ 		in (fun _lh_dummy⁷ -> concat₀₁(rev₀₂(t⁸), 
//│ 			let h⁹ = h⁸
//│ 			in let t⁹ = (fun ys⁷ -> ys⁷)
//│ 			in (fun ys⁶ -> [C h⁹ concat₀₀(t⁹, ys⁶)])))
//│ 	in (fun _lh_dummy⁸ -> concat₀₀(rev₀₀(t⁷), [C h⁷ [N]])))
//│ def concat₀₀(xs³) = 
//│ 	xs³
//│ def concat₀₁(xs⁴) = 
//│ 	case xs⁴ of {
//│ 		N  => (fun ys⁸ -> ys⁸)
//│ 		| C h⁴ t⁴ => (fun ys⁹ -> 
//│ 			let h¹⁰ = h⁴
//│ 			in let t¹⁰ = concat₀₁(t⁴, ys⁹)
//│ 			in (fun ys¹⁰ -> [C h¹⁰ concat₀₀(t¹⁰, ys¹⁰)]))}
//│ def rev₀₀(ls⁵) = 
//│ 	ls⁵(99)
//│ def rev₀₁(ls⁶) = 
//│ 	ls⁶(99)
//│ def rev₀₂(ls⁴) = 
//│ 	ls⁴(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<


// CORRECT: but will be WRONG: if strategy-filtering is strict, since y is a destination of [C 1 N]
fun f(x) = if A(x) is
  A(y) then if x is
    C(h, t) then t
f(C(1, N))
//│ |#fun| |f|(|x|)| |#=| |#if| |A|(|x|)| |is|→|A|(|y|)| |#then| |#if| |x| |is|→|C|(|h|,| |t|)| |#then| |t|←|←|↵|f|(|C|(|1|,| |N|)|)|
//│ Parsed: {fun f = x, => if A (x,) is ‹(A (y,)) then if x is ‹(C (h, t,)) then t››; f (C (1, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^8([C 1 [N]])
//│ def f(x⁰) = case [A x⁰] of {
//│ 	A y⁰ => case x⁰ of {
//│ 		C h⁰ t⁰ => t⁰}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^8] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀([C 1 [N]])
//│ def f₀(x¹) = 
//│ 	case [A x¹] of {
//│ 		A y¹ => case x¹ of {
//│ 			C h¹ t¹ => t¹}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A x¹]: 14 --->
//│ 	case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18
//│ [C 1 [N]]: 23 --->
//│ 	DeadCodeCons
//│ 	case x¹ of {C h¹ t¹ => t¹}: 17
//│ ------------------
//│ case x¹ of {C h¹ t¹ => t¹}: 17 --->
//│ 	[C 1 [N]]: 23
//│ case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18 --->
//│ 	[A x¹]: 14
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A x¹]: 14 --->
//│ 	case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18
//│ ------------------
//│ case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18 --->
//│ 	[A x¹]: 14
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀([C 1 [N]])
//│ def f₀(x²) = 
//│ 	(fun x³ -> case x³ of {
//│ 		C h¹ t¹ => t¹})(x²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f₀₀([C 1 [N]])
//│ def f₀₀(x²) = 
//│ 	(fun x³ -> case x³ of {
//│ 		C h¹ t¹ => t¹})(x²)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 23 --->
//│ 	case x³ of {C h¹ t¹ => t¹}: 15
//│ ------------------
//│ case x³ of {C h¹ t¹ => t¹}: 15 --->
//│ 	[C 1 [N]]: 23
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 [N]]: 23 --->
//│ 	case x³ of {C h¹ t¹ => t¹}: 15
//│ ------------------
//│ case x³ of {C h¹ t¹ => t¹}: 15 --->
//│ 	[C 1 [N]]: 23
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f₀₀(
//│ 	let t² = [N]
//│ 	in t²)
//│ def f₀₀(x⁴) = 
//│ 	(fun x⁵ -> x⁵)(x⁴)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: after using `last(C(hh, tt))` instead of `last(t)` and pushing in of parameters
_LUMBERHACK_EVAL
fun last(ls) = if ls is
  C(h, t) then
    (
      if t is
        N then h => Some(h)
        C(hh, tt) then h => last(C(hh, tt))
    )(h)
  N then None
last(C(1, C(2, C(3, N))))
//│ |_LUMBERHACK_EVAL|↵|#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then|→|(|→|#if| |t| |is|→|N| |#then| |h| |=>| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |h| |=>| |last|(|C|(|hh|,| |tt|)|)|←|←|↵|)|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun last = ls, => if ls is ‹(C (h, t,)) then {'(' if t is ‹(N) then h, => Some (h,); (C (hh, tt,)) then h, => last (C (hh, tt,),)›, ')' (h,)}; (N) then None›; last (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ last^18([C 1 [C 2 [C 3 [N]]]])
//│ def last(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N  => (fun h¹ -> [Some h¹])
//│ 		| C hh⁰ tt⁰ => (fun h² -> last^6([C hh⁰ tt⁰]))}(h⁰)
//│ 	| N  => [None]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [Some 3]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^18]
//│ 	[last^18 · last^6] ---> [last^18] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ last₀([C 1 [C 2 [C 3 [N]]]])
//│ def last₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h³ t¹ => case t¹ of {
//│ 			N  => (fun h⁴ -> [Some h⁴])
//│ 			| C hh¹ tt¹ => (fun h⁵ -> last₀([C hh¹ tt¹]))}(h³)
//│ 		| N  => [None]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 35 --->
//│ 	case ls¹ of {C h³ t¹ => case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last₀([C hh¹ tt¹]))}(h³) | N  => [None]}: 42
//│ [N]: 48 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last₀([C hh¹ tt¹]))}: 38
//│ [C 3 [N]]: 49 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last₀([C hh¹ tt¹]))}: 38
//│ [C 2 [C 3 [N]]]: 50 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last₀([C hh¹ tt¹]))}: 38
//│ [C 1 [C 2 [C 3 [N]]]]: 51 --->
//│ 	case ls¹ of {C h³ t¹ => case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last₀([C hh¹ tt¹]))}(h³) | N  => [None]}: 42
//│ ------------------
//│ case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last₀([C hh¹ tt¹]))}: 38 --->
//│ 	[N]: 48
//│ 	[C 3 [N]]: 49
//│ 	[C 2 [C 3 [N]]]: 50
//│ case ls¹ of {C h³ t¹ => case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last₀([C hh¹ tt¹]))}(h³) | N  => [None]}: 42 --->
//│ 	[C hh¹ tt¹]: 35
//│ 	[C 1 [C 2 [C 3 [N]]]]: 51
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 48 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last₀([C hh¹ tt¹]))}: 38
//│ [C 3 [N]]: 49 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last₀([C hh¹ tt¹]))}: 38
//│ [C 2 [C 3 [N]]]: 50 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last₀([C hh¹ tt¹]))}: 38
//│ ------------------
//│ case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last₀([C hh¹ tt¹]))}: 38 --->
//│ 	[N]: 48
//│ 	[C 3 [N]]: 49
//│ 	[C 2 [C 3 [N]]]: 50
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ last₀([C 1 
//│ 	let hh² = 2
//│ 	in let tt² = 	
//│ 		let hh³ = 3
//│ 		in let tt³ = (fun h⁸ -> [Some h⁸])
//│ 		in (fun h⁷ -> last₀([C hh³ tt³]))
//│ 	in (fun h⁶ -> last₀([C hh² tt²]))])
//│ def last₀(ls²) = 
//│ 	case ls² of {
//│ 		C h³ t¹ => t¹(h³)
//│ 		| N  => [None]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 3]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last₀^16] (hopeless to continue)
//│ [last₀^1] (hopeless to continue)
//│ [last₀^8] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ last₀₁([C 1 
//│ 	let hh² = 2
//│ 	in let tt² = 	
//│ 		let hh³ = 3
//│ 		in let tt³ = (fun h⁷ -> [Some h⁷])
//│ 		in (fun h⁸ -> last₀₂([C hh³ tt³]))
//│ 	in (fun h⁹ -> last₀₀([C hh² tt²]))])
//│ def last₀₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h⁴ t¹ => t¹(h⁴)
//│ 		| N  => [None]}
//│ def last₀₁(ls²) = 
//│ 	case ls² of {
//│ 		C h⁵ t² => t²(h⁵)
//│ 		| N  => [None]}
//│ def last₀₂(ls³) = 
//│ 	case ls³ of {
//│ 		C h⁶ t³ => t³(h⁶)
//│ 		| N  => [None]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh³ tt³]: 64 --->
//│ 	case ls³ of {C h⁶ t³ => t³(h⁶) | N  => [None]}: 52
//│ [C hh² tt²]: 72 --->
//│ 	case ls¹ of {C h⁴ t¹ => t¹(h⁴) | N  => [None]}: 38
//│ [C 1 let hh² = 2
//│ in let tt² = let hh³ = 3
//│ in let tt³ = (fun h⁷ -> [Some h⁷])
//│ in (fun h⁸ -> last₀₂([C hh³ tt³]))
//│ in (fun h⁹ -> last₀₀([C hh² tt²]))]: 77 --->
//│ 	case ls² of {C h⁵ t² => t²(h⁵) | N  => [None]}: 45
//│ ------------------
//│ case ls¹ of {C h⁴ t¹ => t¹(h⁴) | N  => [None]}: 38 --->
//│ 	[C hh² tt²]: 72
//│ case ls² of {C h⁵ t² => t²(h⁵) | N  => [None]}: 45 --->
//│ 	[C 1 let hh² = 2
//│ in let tt² = let hh³ = 3
//│ in let tt³ = (fun h⁷ -> [Some h⁷])
//│ in (fun h⁸ -> last₀₂([C hh³ tt³]))
//│ in (fun h⁹ -> last₀₀([C hh² tt²]))]: 77
//│ case ls³ of {C h⁶ t³ => t³(h⁶) | N  => [None]}: 52 --->
//│ 	[C hh³ tt³]: 64
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C hh³ tt³]: 64 --->
//│ 	case ls³ of {C h⁶ t³ => t³(h⁶) | N  => [None]}: 52
//│ [C hh² tt²]: 72 --->
//│ 	case ls¹ of {C h⁴ t¹ => t¹(h⁴) | N  => [None]}: 38
//│ [C 1 let hh² = 2
//│ in let tt² = let hh³ = 3
//│ in let tt³ = (fun h⁷ -> [Some h⁷])
//│ in (fun h⁸ -> last₀₂([C hh³ tt³]))
//│ in (fun h⁹ -> last₀₀([C hh² tt²]))]: 77 --->
//│ 	case ls² of {C h⁵ t² => t²(h⁵) | N  => [None]}: 45
//│ ------------------
//│ case ls¹ of {C h⁴ t¹ => t¹(h⁴) | N  => [None]}: 38 --->
//│ 	[C hh² tt²]: 72
//│ case ls² of {C h⁵ t² => t²(h⁵) | N  => [None]}: 45 --->
//│ 	[C 1 let hh² = 2
//│ in let tt² = let hh³ = 3
//│ in let tt³ = (fun h⁷ -> [Some h⁷])
//│ in (fun h⁸ -> last₀₂([C hh³ tt³]))
//│ in (fun h⁹ -> last₀₀([C hh² tt²]))]: 77
//│ case ls³ of {C h⁶ t³ => t³(h⁶) | N  => [None]}: 52 --->
//│ 	[C hh³ tt³]: 64
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ last₀₁(
//│ 	let h¹⁰ = 1
//│ 	in let t⁴ = 	
//│ 		let hh⁴ = 2
//│ 		in let tt⁴ = 	
//│ 			let hh⁵ = 3
//│ 			in let tt⁵ = (fun h¹¹ -> [Some h¹¹])
//│ 			in (fun h¹² -> last₀₂(
//│ 				let h¹³ = hh⁵
//│ 				in let t⁵ = tt⁵
//│ 				in (fun _lh_dummy¹ -> t⁵(h¹³))))
//│ 		in (fun h¹⁴ -> last₀₀(
//│ 			let h¹⁵ = hh⁴
//│ 			in let t⁶ = tt⁴
//│ 			in (fun _lh_dummy² -> t⁶(h¹⁵))))
//│ 	in (fun _lh_dummy⁰ -> t⁴(h¹⁰)))
//│ def last₀₀(ls⁴) = 
//│ 	ls⁴(99)
//│ def last₀₁(ls⁵) = 
//│ 	ls⁵(99)
//│ def last₀₂(ls⁶) = 
//│ 	ls⁶(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 3]
//│ <<<<<<< evaluate <<<<<<<


fun f(x) = if primitive(x) then A(x) else B(x + 1)
fun g(scrut, y) = if scrut is
  A(n) then y + n + 1
  B(m) then y + m
g(f(1), 2)
//│ |#fun| |f|(|x|)| |#=| |#if| |primitive|(|x|)| |#then| |A|(|x|)| |#else| |B|(|x| |+| |1|)|↵|#fun| |g|(|scrut|,| |y|)| |#=| |#if| |scrut| |is|→|A|(|n|)| |#then| |y| |+| |n| |+| |1|↵|B|(|m|)| |#then| |y| |+| |m|←|↵|g|(|f|(|1|)|,| |2|)|
//│ Parsed: {fun f = x, => if (primitive (x,)) then A (x,) else B (+ (x,) (1,),); fun g = scrut, y, => if scrut is ‹(A (n,)) then + (+ (y,) (n,),) (1,); (B (m,)) then + (y,) (m,)›; g (f (1,), 2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ g^32(f^33(1), 2)
//│ def f(x⁰) = if primitive⁰(x⁰) then [A x⁰] else [B (x⁰ + 1)]
//│ def g(scrut⁰, y⁰) = case scrut⁰ of {
//│ 	A n⁰ => ((y⁰ + n⁰) + 1)
//│ 	| B m⁰ => (y⁰ + m⁰)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^33] (hopeless to continue)
//│ [g^32] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ g₀(f₀(1), 2)
//│ def f₀(x¹) = 
//│ 	if primitive⁰(x¹) then [A x¹] else [B (x¹ + 1)]
//│ def g₀(scrut¹, y¹) = 
//│ 	case scrut¹ of {
//│ 		A n¹ => ((y¹ + n¹) + 1)
//│ 		| B m¹ => (y¹ + m¹)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A x¹]: 61 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ [B (x¹ + 1)]: 67 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ ------------------
//│ case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54 --->
//│ 	[A x¹]: 61
//│ 	[B (x¹ + 1)]: 67
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A x¹]: 61 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ [B (x¹ + 1)]: 67 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ ------------------
//│ case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54 --->
//│ 	[A x¹]: 61
//│ 	[B (x¹ + 1)]: 67
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ g₀(f₀(1), 2)
//│ def f₀(x²) = 
//│ 	if primitive⁰(x²) then 
//│ 		let n² = x²
//│ 		in (fun y³ -> ((y³ + n²) + 1)) else 
//│ 		let m² = (x² + 1)
//│ 		in (fun y⁴ -> (y⁴ + m²))
//│ def g₀(scrut², y²) = 
//│ 	scrut²(y²)
//│ <<<<<<< after fusion <<<<<<<


:lhInHaskell
ack m n = case m of
          Z -> S n
          S m' -> case n of
                    Z -> ack m' (S Z)
                    S n' -> ack m' (ack m n')
ack (S (S (S Z))) (S (S Z))
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ack₀^670([S [S [S [Z]]]], [S [S [Z]]])
//│ def ack₀(_lh_ack_arg1¹, _lh_ack_arg2¹) = 
//│ 	let _lh_matchIdent² = _lh_ack_arg1¹
//│ 	in case _lh_matchIdent² of {
//│ 		Z  => [S _lh_ack_arg2¹]
//│ 		| S _lh_ack_S_0² => 
//│ 			let _lh_matchIdent³ = _lh_ack_arg2¹
//│ 			in case _lh_matchIdent³ of {
//│ 				Z  => ack₀^647(_lh_ack_S_0², [S [Z]])
//│ 				| S _lh_ack_S_0³ => ack₀^653(_lh_ack_S_0², ack₀^656(_lh_ack_arg1¹, _lh_ack_S_0³))
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ack₀^670]
//│ 	[ack₀^670 · ack₀^647] (hopeless to continue)
//│ 		[ack₀^670 · ack₀^647 · ack₀^647] ---> [ack₀^670 · ack₀^647] (using original def)
//│ 		[ack₀^670 · ack₀^647 · ack₀^653] ---> [ack₀^670 · ack₀^647] (using original def)
//│ 		[ack₀^670 · ack₀^647 · ack₀^656] ---> [ack₀^670 · ack₀^647] (using original def)
//│ 	[ack₀^670 · ack₀^653] ---> [ack₀^670] (only one)
//│ 	[ack₀^670 · ack₀^656] ---> [ack₀^670] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ack₀₀([S [S [S [Z]]]], [S [S [Z]]])
//│ def ack₀₀(_lh_ack_arg1¹, _lh_ack_arg2¹) = 
//│ 	let _lh_matchIdent² = _lh_ack_arg1¹
//│ 	in case _lh_matchIdent² of {
//│ 		Z  => [S _lh_ack_arg2¹]
//│ 		| S _lh_ack_S_0² => 
//│ 			let _lh_matchIdent³ = _lh_ack_arg2¹
//│ 			in case _lh_matchIdent³ of {
//│ 				Z  => ack₀₁(_lh_ack_S_0², [S [Z]])
//│ 				| S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³))
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ 	where
//│ 	def ack₀₁(_lh_ack_arg1², _lh_ack_arg2²) = 
//│ 		let _lh_matchIdent⁴ = _lh_ack_arg1²
//│ 		in case _lh_matchIdent⁴ of {
//│ 			Z  => [S _lh_ack_arg2²]
//│ 			| S _lh_ack_S_0⁴ => 
//│ 				let _lh_matchIdent⁵ = _lh_ack_arg2²
//│ 				in case _lh_matchIdent⁵ of {
//│ 					Z  => ack₀₁(_lh_ack_S_0⁴, [S [Z]])
//│ 					| S _lh_ack_S_0⁵ => ack₀₁(_lh_ack_S_0⁴, ack₀₁(_lh_ack_arg1², _lh_ack_S_0⁵))
//│ 					| _  => error⁰}
//│ 			| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S _lh_ack_arg2¹]: 43 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ [Z]: 49 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ 	case _lh_matchIdent⁵ of {Z  => ack₀₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack₀₁(_lh_ack_S_0⁴, ack₀₁(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91
//│ [S [Z]]: 50 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ 	case _lh_matchIdent⁵ of {Z  => ack₀₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack₀₁(_lh_ack_S_0⁴, ack₀₁(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91
//│ [S _lh_ack_arg2²]: 72 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ 	case _lh_matchIdent⁵ of {Z  => ack₀₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack₀₁(_lh_ack_S_0⁴, ack₀₁(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91
//│ [Z]: 78 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ 	case _lh_matchIdent⁵ of {Z  => ack₀₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack₀₁(_lh_ack_S_0⁴, ack₀₁(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91
//│ [S [Z]]: 79 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ 	case _lh_matchIdent⁵ of {Z  => ack₀₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack₀₁(_lh_ack_S_0⁴, ack₀₁(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91
//│ [Z]: 99 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ 	case _lh_matchIdent⁴ of {Z  => [S _lh_ack_arg2²] | S _lh_ack_S_0⁴ => let _lh_matchIdent⁵ = _lh_ack_arg2²
//│ in case _lh_matchIdent⁵ of {Z  => ack₀₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack₀₁(_lh_ack_S_0⁴, ack₀₁(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰} | _  => error⁰}: 94
//│ [S [Z]]: 100 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ 	case _lh_matchIdent⁴ of {Z  => [S _lh_ack_arg2²] | S _lh_ack_S_0⁴ => let _lh_matchIdent⁵ = _lh_ack_arg2²
//│ in case _lh_matchIdent⁵ of {Z  => ack₀₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack₀₁(_lh_ack_S_0⁴, ack₀₁(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰} | _  => error⁰}: 94
//│ [S [S [Z]]]: 101 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ 	case _lh_matchIdent⁴ of {Z  => [S _lh_ack_arg2²] | S _lh_ack_S_0⁴ => let _lh_matchIdent⁵ = _lh_ack_arg2²
//│ in case _lh_matchIdent⁵ of {Z  => ack₀₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack₀₁(_lh_ack_S_0⁴, ack₀₁(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰} | _  => error⁰}: 94
//│ [S [S [S [Z]]]]: 102 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ [Z]: 104 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ [S [Z]]: 105 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ [S [S [Z]]]: 106 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ ------------------
//│ case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62 --->
//│ 	[S _lh_ack_arg2¹]: 43
//│ 	[Z]: 49
//│ 	[S [Z]]: 50
//│ 	[S _lh_ack_arg2²]: 72
//│ 	[Z]: 78
//│ 	[S [Z]]: 79
//│ 	[Z]: 104
//│ 	[S [Z]]: 105
//│ 	[S [S [Z]]]: 106
//│ case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack₀₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65 --->
//│ 	[Z]: 99
//│ 	[S [Z]]: 100
//│ 	[S [S [Z]]]: 101
//│ 	[S [S [S [Z]]]]: 102
//│ case _lh_matchIdent⁵ of {Z  => ack₀₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack₀₁(_lh_ack_S_0⁴, ack₀₁(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91 --->
//│ 	[Z]: 49
//│ 	[S [Z]]: 50
//│ 	[S _lh_ack_arg2²]: 72
//│ 	[Z]: 78
//│ 	[S [Z]]: 79
//│ case _lh_matchIdent⁴ of {Z  => [S _lh_ack_arg2²] | S _lh_ack_S_0⁴ => let _lh_matchIdent⁵ = _lh_ack_arg2²
//│ in case _lh_matchIdent⁵ of {Z  => ack₀₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack₀₁(_lh_ack_S_0⁴, ack₀₁(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰} | _  => error⁰}: 94 --->
//│ 	[Z]: 99
//│ 	[S [Z]]: 100
//│ 	[S [S [Z]]]: 101
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ack₀₀([S [S [S [Z]]]], [S [S [Z]]])
//│ def ack₀₀(_lh_ack_arg1³, _lh_ack_arg2³) = 
//│ 	let _lh_matchIdent⁶ = _lh_ack_arg1³
//│ 	in case _lh_matchIdent⁶ of {
//│ 		Z  => [S _lh_ack_arg2³]
//│ 		| S _lh_ack_S_0² => 
//│ 			let _lh_matchIdent⁷ = _lh_ack_arg2³
//│ 			in case _lh_matchIdent⁷ of {
//│ 				Z  => ack₀₁(_lh_ack_S_0², [S [Z]])
//│ 				| S _lh_ack_S_0³ => ack₀₀(_lh_ack_S_0², ack₀₀(_lh_ack_arg1³, _lh_ack_S_0³))
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ 	where
//│ 	def ack₀₁(_lh_ack_arg1⁴, _lh_ack_arg2⁴) = 
//│ 		let _lh_matchIdent⁸ = _lh_ack_arg1⁴
//│ 		in case _lh_matchIdent⁸ of {
//│ 			Z  => [S _lh_ack_arg2⁴]
//│ 			| S _lh_ack_S_0⁴ => 
//│ 				let _lh_matchIdent⁹ = _lh_ack_arg2⁴
//│ 				in case _lh_matchIdent⁹ of {
//│ 					Z  => ack₀₁(_lh_ack_S_0⁴, [S [Z]])
//│ 					| S _lh_ack_S_0⁵ => ack₀₁(_lh_ack_S_0⁴, ack₀₁(_lh_ack_arg1⁴, _lh_ack_S_0⁵))
//│ 					| _  => error⁰}
//│ 			| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<

:lhInHaskell
:lhEval
test n = foldl (\a b -> a + b) 0 [1..n]
test $ primId 10
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ test₀^680(primId⁰(10))
//│ def enumFromTo₀(a⁷, b⁴) = if (a⁷ <= b⁴) then [LH_C a⁷ enumFromTo₀^649((a⁷ + 1), b⁴)] else [LH_N]
//│ def foldl₀(f¹², i³, ls¹⁹) = case ls¹⁹ of {
//│ 	LH_C h²⁰ t²² => foldl₀^664(f¹², f¹²(i³, h²⁰), t²²)
//│ 	| LH_N  => i³}
//│ def test₀(_lh_test_arg1¹) = foldl₀^625((fun a⁶ -> (fun b³ -> (a⁶ + b³))), 0, enumFromTo₀^636(1, _lh_test_arg1¹))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 55
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [test₀^680] (hopeless to continue)
//│ 	[test₀^680 · enumFromTo₀^636] (using original def)
//│ 		[test₀^680 · enumFromTo₀^636 · enumFromTo₀^649] ---> [test₀^680 · enumFromTo₀^636] (using original def)
//│ 	[test₀^680 · foldl₀^625] (using original def)
//│ 		[test₀^680 · foldl₀^625 · foldl₀^664] ---> [test₀^680 · foldl₀^625] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ test₀₀(primId⁰(10))
//│ def test₀₀(_lh_test_arg1¹) = 
//│ 	foldl₀₀((fun a³ -> (fun b³ -> (a³ + b³))), 0, enumFromTo₀₀(1, _lh_test_arg1¹))
//│ 	where
//│ 	def enumFromTo₀₀(a², b²) = 
//│ 		if (a² <= b²) then [LH_C a² enumFromTo₀₀((a² + 1), b²)] else [LH_N]
//│ 	def foldl₀₀(f¹, i¹, ls¹) = 
//│ 		case ls¹ of {
//│ 			LH_C h¹ t¹ => foldl₀₀(f¹, f¹(i¹, h¹), t¹)
//│ 			| LH_N  => i¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a² enumFromTo₀₀((a² + 1), b²)]: 93 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl₀₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 74
//│ [LH_N]: 94 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl₀₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 74
//│ ------------------
//│ case ls¹ of {LH_C h¹ t¹ => foldl₀₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 74 --->
//│ 	[LH_C a² enumFromTo₀₀((a² + 1), b²)]: 93
//│ 	[LH_N]: 94
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a² enumFromTo₀₀((a² + 1), b²)]: 93 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl₀₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 74
//│ [LH_N]: 94 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl₀₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 74
//│ ------------------
//│ case ls¹ of {LH_C h¹ t¹ => foldl₀₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 74 --->
//│ 	[LH_C a² enumFromTo₀₀((a² + 1), b²)]: 93
//│ 	[LH_N]: 94
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ test₀₀(primId⁰(10))
//│ def test₀₀(_lh_test_arg1²) = 
//│ 	foldl₀₀((fun a⁵ -> (fun b⁵ -> (a⁵ + b⁵))), 0, enumFromTo₀₀(1, _lh_test_arg1²))
//│ 	where
//│ 	def enumFromTo₀₀(a⁴, b⁴) = 
//│ 		if (a⁴ <= b⁴) then 
//│ 			let h² = a⁴
//│ 			in let t² = enumFromTo₀₀((a⁴ + 1), b⁴)
//│ 			in (fun f³ -> (fun i³ -> foldl₀₀(f³, f³(i³, h²), t²))) else (fun f⁴ -> (fun i⁴ -> i⁴))
//│ 	def foldl₀₀(f², i², ls²) = 
//│ 		ls²(f², i²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 55
//│ <<<<<<< evaluate <<<<<<<

:lhInHaskell
:lhEval
:lhGenDistill
test n = sum $ zipWith (\a b -> a * b) (primId [1..n]) (primId [n..(2*n)])
test $ primId 10
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ test₀^744(primId⁰(10))
//│ def enumFromTo₀(a⁷, b⁴) = if (a⁷ <= b⁴) then [LH_C a⁷ enumFromTo₀^710((a⁷ + 1), b⁴)] else [LH_N]
//│ def enumFromTo₁(a⁸, b⁵) = if (a⁸ <= b⁵) then [LH_C a⁸ enumFromTo₁^730((a⁸ + 1), b⁵)] else [LH_N]
//│ def sum₀(ls¹⁹) = case ls¹⁹ of {
//│ 	LH_C h²⁰ t²² => (h²⁰ + sum₀^665(t²²))
//│ 	| LH_N  => 0}
//│ def test₀(_lh_test_arg1¹) = sum₀^672(zipWith₀^673((fun a⁶ -> (fun b³ -> (a⁶ * b³))), primId⁰(enumFromTo₀^683(1, _lh_test_arg1¹)), primId⁰(enumFromTo₁^691(_lh_test_arg1¹, (2 * _lh_test_arg1¹)))))
//│ def zipWith₀(f¹², xs⁹, ys⁹) = case xs⁹ of {
//│ 	LH_C hx⁸ tx⁸ => case ys⁹ of {
//│ 		LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith₀^646(f¹², tx⁸, ty⁸)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized distiller gen ----------
//│ 		main = (test_d0 10);
//│ 		enumFromTo_d0 a_7 b_4 =
//│ 		  (case (le a_7 b_4) of True -> ((LH_C(a_7, ((enumFromTo_d0 (plus a_7 1)) b_4)))) | False -> ((LH_N)));
//│ 		enumFromTo_d1 a_8 b_5 =
//│ 		  (case (le a_8 b_5) of True -> ((LH_C(a_8, ((enumFromTo_d1 (plus a_8 1)) b_5)))) | False -> ((LH_N)));
//│ 		sum_d0 ls_1_9 =
//│ 		  (case ls_1_9 of LH_C(h_2_0, t_2_2) -> (plus h_2_0 (sum_d0 t_2_2)) | LH_N -> 0);
//│ 		test_d0 _lh_test_arg1_1 =
//│ 		  (sum_d0 (((zipWith_d0 (\a_6 b_3 -> (mul a_6 b_3))) ((enumFromTo_d0 1) _lh_test_arg1_1)) ((enumFromTo_d1 _lh_test_arg1_1) (mul 2 _lh_test_arg1_1))));
//│ 		zipWith_d0 f_1_2 xs_9 ys_9 =
//│ 		  (case xs_9 of LH_C(hx_8, tx_8) -> (case ys_9 of LH_C(hy_8, ty_8) -> (LH_C(((f_1_2 hx_8) hy_8), (((zipWith_d0 f_1_2) tx_8) ty_8))) | LH_N -> (LH_N)) | LH_N -> (LH_N))
//│ 		---------- unoptimized distiller gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 880
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [test₀^744] (hopeless to continue)
//│ 	[test₀^744 · enumFromTo₀^683] (using original def)
//│ 		[test₀^744 · enumFromTo₀^683 · enumFromTo₀^710] ---> [test₀^744 · enumFromTo₀^683] (using original def)
//│ 	[test₀^744 · enumFromTo₁^691] (using original def)
//│ 		[test₀^744 · enumFromTo₁^691 · enumFromTo₁^730] ---> [test₀^744 · enumFromTo₁^691] (using original def)
//│ 	[test₀^744 · sum₀^672] (using original def)
//│ 		[test₀^744 · sum₀^672 · sum₀^665] ---> [test₀^744 · sum₀^672] (using original def)
//│ 	[test₀^744 · zipWith₀^673] (using original def)
//│ 		[test₀^744 · zipWith₀^673 · zipWith₀^646] ---> [test₀^744 · zipWith₀^673] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ test₀₀(primId⁰(10))
//│ def test₀₀(_lh_test_arg1¹) = 
//│ 	sum₀₀(zipWith₀₀((fun a⁴ -> (fun b⁴ -> (a⁴ * b⁴))), primId⁰(enumFromTo₀₀(1, _lh_test_arg1¹)), primId⁰(enumFromTo₁₀(_lh_test_arg1¹, (2 * _lh_test_arg1¹)))))
//│ 	where
//│ 	def enumFromTo₀₀(a³, b³) = 
//│ 		if (a³ <= b³) then [LH_C a³ enumFromTo₀₀((a³ + 1), b³)] else [LH_N]
//│ 	def enumFromTo₁₀(a⁵, b⁵) = 
//│ 		if (a⁵ <= b⁵) then [LH_C a⁵ enumFromTo₁₀((a⁵ + 1), b⁵)] else [LH_N]
//│ 	def sum₀₀(ls¹) = 
//│ 		case ls¹ of {
//│ 			LH_C h¹ t¹ => (h¹ + sum₀₀(t¹))
//│ 			| LH_N  => 0}
//│ 	def zipWith₀₀(f¹, xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			LH_C hx¹ tx¹ => case ys¹ of {
//│ 				LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith₀₀(f¹, tx¹, ty¹)]
//│ 				| LH_N  => [LH_N]}
//│ 			| LH_N  => [LH_N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f¹(hx¹, hy¹) zipWith₀₀(f¹, tx¹, ty¹)]: 177 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum₀₀(t¹)) | LH_N  => 0}: 194
//│ [LH_N]: 178 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum₀₀(t¹)) | LH_N  => 0}: 194
//│ [LH_N]: 180 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum₀₀(t¹)) | LH_N  => 0}: 194
//│ ------------------
//│ case ls¹ of {LH_C h¹ t¹ => (h¹ + sum₀₀(t¹)) | LH_N  => 0}: 194 --->
//│ 	[LH_C f¹(hx¹, hy¹) zipWith₀₀(f¹, tx¹, ty¹)]: 177
//│ 	[LH_N]: 178
//│ 	[LH_N]: 180
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f¹(hx¹, hy¹) zipWith₀₀(f¹, tx¹, ty¹)]: 177 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum₀₀(t¹)) | LH_N  => 0}: 194
//│ [LH_N]: 178 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum₀₀(t¹)) | LH_N  => 0}: 194
//│ [LH_N]: 180 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum₀₀(t¹)) | LH_N  => 0}: 194
//│ ------------------
//│ case ls¹ of {LH_C h¹ t¹ => (h¹ + sum₀₀(t¹)) | LH_N  => 0}: 194 --->
//│ 	[LH_C f¹(hx¹, hy¹) zipWith₀₀(f¹, tx¹, ty¹)]: 177
//│ 	[LH_N]: 178
//│ 	[LH_N]: 180
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ test₀₀(primId⁰(10))
//│ def test₀₀(_lh_test_arg1²) = 
//│ 	sum₀₀(zipWith₀₀((fun a⁶ -> (fun b⁶ -> (a⁶ * b⁶))), primId⁰(enumFromTo₀₀(1, _lh_test_arg1²)), primId⁰(enumFromTo₁₀(_lh_test_arg1², (2 * _lh_test_arg1²)))))
//│ 	where
//│ 	def enumFromTo₀₀(a⁷, b⁷) = 
//│ 		if (a⁷ <= b⁷) then [LH_C a⁷ enumFromTo₀₀((a⁷ + 1), b⁷)] else [LH_N]
//│ 	def enumFromTo₁₀(a⁸, b⁸) = 
//│ 		if (a⁸ <= b⁸) then [LH_C a⁸ enumFromTo₁₀((a⁸ + 1), b⁸)] else [LH_N]
//│ 	def sum₀₀(ls²) = 
//│ 		ls²(99)
//│ 	def zipWith₀₀(f², xs², ys²) = 
//│ 		case xs² of {
//│ 			LH_C hx¹ tx¹ => case ys² of {
//│ 				LH_C hy¹ ty¹ => 
//│ 					let h² = f²(hx¹, hy¹)
//│ 					in let t² = zipWith₀₀(f², tx¹, ty¹)
//│ 					in (fun _lh_dummy⁰ -> (h² + sum₀₀(t²)))
//│ 				| LH_N  => (fun _lh_dummy¹ -> 0)}
//│ 			| LH_N  => (fun _lh_dummy² -> 0)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 880
//│ <<<<<<< evaluate <<<<<<<

:lhInHaskell
:lhEval
fact r Z = S Z
fact r (S a) = mmul (S a) (r (mmin (S a) (S Z)))
pplus Z b = b
pplus (S a) b = S (pplus a b)
mmul Z b = Z
mmul (S a) b = pplus b (mmul a b)
mmin a b = case b of {
  Z -> a;
  (S bb) -> case a of {
    Z -> Z;
    (S aa) -> mmin aa bb
  }
}
let mainFact = (\x -> fact (\y -> x x y)) (\x -> fact (\y -> x x y)) in mainFact (primId (S (S (S Z))))
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ let mainFact¹ = (fun x⁴ -> fact₀^831((fun y² -> x⁴(x⁴, y²))))((fun x⁵ -> fact₁^840((fun y³ -> x⁵(x⁵, y³)))))
//│ in mainFact¹(primId⁰([S [S [S [Z]]]]))
//│ def fact₀(_lh_fact_arg1², _lh_fact_arg2²) = case _lh_fact_arg2² of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_fact_S_0² => mmul₀^813([S _lh_fact_S_0²], _lh_fact_arg1²(mmin₀^818([S _lh_fact_S_0²], [S [Z]])))
//│ 	| _  => error⁰}
//│ def fact₁(_lh_fact_arg1¹, _lh_fact_arg2¹) = case _lh_fact_arg2¹ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_fact_S_0¹ => mmul₁^715([S _lh_fact_S_0¹], _lh_fact_arg1¹(mmin₁^720([S _lh_fact_S_0¹], [S [Z]])))
//│ 	| _  => error⁰}
//│ def mmin₀(_lh_mmin_arg1², _lh_mmin_arg2²) = 
//│ 	let _lh_matchIdent⁴ = _lh_mmin_arg2²
//│ 	in case _lh_matchIdent⁴ of {
//│ 		Z  => _lh_mmin_arg1²
//│ 		| S _lh_mmin_S_0⁴ => 
//│ 			let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ 			in case _lh_matchIdent⁵ of {
//│ 				Z  => [Z]
//│ 				| S _lh_mmin_S_0⁵ => mmin₀^797(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴)
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ def mmin₁(_lh_mmin_arg1¹, _lh_mmin_arg2¹) = 
//│ 	let _lh_matchIdent² = _lh_mmin_arg2¹
//│ 	in case _lh_matchIdent² of {
//│ 		Z  => _lh_mmin_arg1¹
//│ 		| S _lh_mmin_S_0² => 
//│ 			let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ 			in case _lh_matchIdent³ of {
//│ 				Z  => [Z]
//│ 				| S _lh_mmin_S_0³ => mmin₁^739(_lh_mmin_S_0³, _lh_mmin_S_0²)
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ def mmul₀(_lh_mmul_arg1¹, _lh_mmul_arg2¹) = case _lh_mmul_arg1¹ of {
//│ 	Z  => [Z]
//│ 	| S _lh_mmul_S_0¹ => pplus₀^699(_lh_mmul_arg2¹, mmul₀^702(_lh_mmul_S_0¹, _lh_mmul_arg2¹))
//│ 	| _  => error⁰}
//│ def mmul₁(_lh_mmul_arg1², _lh_mmul_arg2²) = case _lh_mmul_arg1² of {
//│ 	Z  => [Z]
//│ 	| S _lh_mmul_S_0² => pplus₁^766(_lh_mmul_arg2², mmul₁^769(_lh_mmul_S_0², _lh_mmul_arg2²))
//│ 	| _  => error⁰}
//│ def pplus₀(_lh_pplus_arg1¹, _lh_pplus_arg2¹) = case _lh_pplus_arg1¹ of {
//│ 	Z  => _lh_pplus_arg2¹
//│ 	| S _lh_pplus_S_0¹ => [S pplus₀^754(_lh_pplus_S_0¹, _lh_pplus_arg2¹)]
//│ 	| _  => error⁰}
//│ def pplus₁(_lh_pplus_arg1², _lh_pplus_arg2²) = case _lh_pplus_arg1² of {
//│ 	Z  => _lh_pplus_arg2²
//│ 	| S _lh_pplus_S_0² => [S pplus₁^781(_lh_pplus_S_0², _lh_pplus_arg2²)]
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [S [S [S [S [S [S [Z]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fact₀^831]
//│ 	[fact₀^831 · mmin₀^818]
//│ 		[fact₀^831 · mmin₀^818 · mmin₀^797] ---> [fact₀^831 · mmin₀^818] (only one)
//│ 	[fact₀^831 · mmul₀^813]
//│ 		[fact₀^831 · mmul₀^813 · mmul₀^702] ---> [fact₀^831 · mmul₀^813] (only one)
//│ 		[fact₀^831 · mmul₀^813 · pplus₀^699]
//│ 			[fact₀^831 · mmul₀^813 · pplus₀^699 · pplus₀^754] ---> [fact₀^831 · mmul₀^813 · pplus₀^699] (only one)
//│ [fact₁^840]
//│ 	[fact₁^840 · mmin₁^720] (hopeless to continue)
//│ 		[fact₁^840 · mmin₁^720 · mmin₁^739] ---> [fact₁^840 · mmin₁^720] (using original def)
//│ 	[fact₁^840 · mmul₁^715]
//│ 		[fact₁^840 · mmul₁^715 · mmul₁^769] (hopeless to continue)
//│ 			[fact₁^840 · mmul₁^715 · mmul₁^769 · mmul₁^769] ---> [fact₁^840 · mmul₁^715 · mmul₁^769] (using original def)
//│ 			[fact₁^840 · mmul₁^715 · mmul₁^769 · pplus₁^766] (using original def)
//│ 				[fact₁^840 · mmul₁^715 · mmul₁^769 · pplus₁^766 · pplus₁^781] ---> [fact₁^840 · mmul₁^715 · mmul₁^769 · pplus₁^766] (using original def)
//│ 		[fact₁^840 · mmul₁^715 · pplus₁^766]
//│ 			[fact₁^840 · mmul₁^715 · pplus₁^766 · pplus₁^781] ---> [fact₁^840 · mmul₁^715 · pplus₁^766] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ 
//│ 	let mainFact¹ = (fun x² -> fact₀₀((fun y² -> x²(x², y²))))((fun x³ -> fact₁₀((fun y³ -> x³(x³, y³)))))
//│ 	in mainFact¹(primId⁰([S [S [S [Z]]]]))
//│ def fact₀₀(_lh_fact_arg1², _lh_fact_arg2²) = 
//│ 	case _lh_fact_arg2² of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0² => mmul₀₀([S _lh_fact_S_0²], _lh_fact_arg1²(mmin₀₀([S _lh_fact_S_0²], [S [Z]])))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin₀₀(_lh_mmin_arg1², _lh_mmin_arg2²) = 
//│ 		let _lh_matchIdent⁴ = _lh_mmin_arg2²
//│ 		in case _lh_matchIdent⁴ of {
//│ 			Z  => _lh_mmin_arg1²
//│ 			| S _lh_mmin_S_0⁴ => 
//│ 				let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ 				in case _lh_matchIdent⁵ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁵ => mmin₀₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴)
//│ 					| _  => error⁰}
//│ 			| _  => error⁰}
//│ 	def mmul₀₀(_lh_mmul_arg1⁴, _lh_mmul_arg2⁴) = 
//│ 		case _lh_mmul_arg1⁴ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0⁴ => pplus₀₀(_lh_mmul_arg2⁴, mmul₀₀(_lh_mmul_S_0⁴, _lh_mmul_arg2⁴))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus₀₀(_lh_pplus_arg1², _lh_pplus_arg2²) = 
//│ 			case _lh_pplus_arg1² of {
//│ 				Z  => _lh_pplus_arg2²
//│ 				| S _lh_pplus_S_0² => [S pplus₀₀(_lh_pplus_S_0², _lh_pplus_arg2²)]
//│ 				| _  => error⁰}
//│ def fact₁₀(_lh_fact_arg1³, _lh_fact_arg2³) = 
//│ 	case _lh_fact_arg2³ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0³ => mmul₁₀([S _lh_fact_S_0³], _lh_fact_arg1³(mmin₁₀([S _lh_fact_S_0³], [S [Z]])))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin₁₀(_lh_mmin_arg1³, _lh_mmin_arg2³) = 
//│ 		let _lh_matchIdent⁶ = _lh_mmin_arg2³
//│ 		in case _lh_matchIdent⁶ of {
//│ 			Z  => _lh_mmin_arg1³
//│ 			| S _lh_mmin_S_0⁶ => 
//│ 				let _lh_matchIdent⁷ = _lh_mmin_arg1³
//│ 				in case _lh_matchIdent⁷ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁷ => mmin₁₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶)
//│ 					| _  => error⁰}
//│ 			| _  => error⁰}
//│ 	def mmul₁₀(_lh_mmul_arg1³, _lh_mmul_arg2³) = 
//│ 		case _lh_mmul_arg1³ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0³ => pplus₁₁(_lh_mmul_arg2³, mmul₁₁(_lh_mmul_S_0³, _lh_mmul_arg2³))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def mmul₁₁(_lh_mmul_arg1², _lh_mmul_arg2²) = 
//│ 			case _lh_mmul_arg1² of {
//│ 				Z  => [Z]
//│ 				| S _lh_mmul_S_0² => pplus₁₀(_lh_mmul_arg2², mmul₁₁(_lh_mmul_S_0², _lh_mmul_arg2²))
//│ 				| _  => error⁰}
//│ 			where
//│ 			def pplus₁₀(_lh_pplus_arg1⁴, _lh_pplus_arg2⁴) = 
//│ 				case _lh_pplus_arg1⁴ of {
//│ 					Z  => _lh_pplus_arg2⁴
//│ 					| S _lh_pplus_S_0⁴ => [S pplus₁₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]
//│ 					| _  => error⁰}
//│ 		def pplus₁₁(_lh_pplus_arg1³, _lh_pplus_arg2³) = 
//│ 			case _lh_pplus_arg1³ of {
//│ 				Z  => _lh_pplus_arg2³
//│ 				| S _lh_pplus_S_0³ => [S pplus₁₁(_lh_pplus_S_0³, _lh_pplus_arg2³)]
//│ 				| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S pplus₁₁(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 182 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus₀₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 172
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus₁₁(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 184
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus₁₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 196
//│ [S pplus₁₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]: 194 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus₀₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 172
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus₁₁(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 184
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus₁₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 196
//│ [Z]: 200 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus₀₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 172
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus₁₁(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 184
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus₁₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 196
//│ [S _lh_fact_S_0²]: 219 --->
//│ 	case _lh_mmul_arg1⁴ of {Z  => [Z] | S _lh_mmul_S_0⁴ => pplus₀₀(_lh_mmul_arg2⁴, mmul₀₀(_lh_mmul_S_0⁴, _lh_mmul_arg2⁴)) | _  => error⁰}: 321
//│ [S _lh_fact_S_0²]: 224 --->
//│ 	case _lh_fact_arg2³ of {Z  => [S [Z]] | S _lh_fact_S_0³ => mmul₁₀([S _lh_fact_S_0³], _lh_fact_arg1³(mmin₁₀([S _lh_fact_S_0³], [S [Z]]))) | _  => error⁰}: 253
//│ 	case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₀₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 283
//│ [Z]: 226 --->
//│ 	case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₀₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 286
//│ [S [Z]]: 227 --->
//│ 	case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₀₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 286
//│ [Z]: 236 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus₀₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 172
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus₁₁(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 184
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus₁₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 196
//│ [S [Z]]: 237 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus₀₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 172
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus₁₁(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 184
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus₁₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 196
//│ [S _lh_fact_S_0³]: 240 --->
//│ 	case _lh_mmul_arg1³ of {Z  => [Z] | S _lh_mmul_S_0³ => pplus₁₁(_lh_mmul_arg2³, mmul₁₁(_lh_mmul_S_0³, _lh_mmul_arg2³)) | _  => error⁰}: 268
//│ [S _lh_fact_S_0³]: 245 --->
//│ 	case _lh_fact_arg2³ of {Z  => [S [Z]] | S _lh_fact_S_0³ => mmul₁₀([S _lh_fact_S_0³], _lh_fact_arg1³(mmin₁₀([S _lh_fact_S_0³], [S [Z]]))) | _  => error⁰}: 253
//│ 	case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin₁₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 302
//│ [Z]: 247 --->
//│ 	case _lh_matchIdent⁶ of {Z  => _lh_mmin_arg1³ | S _lh_mmin_S_0⁶ => let _lh_matchIdent⁷ = _lh_mmin_arg1³
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin₁₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰} | _  => error⁰}: 305
//│ [S [Z]]: 248 --->
//│ 	case _lh_matchIdent⁶ of {Z  => _lh_mmin_arg1³ | S _lh_mmin_S_0⁶ => let _lh_matchIdent⁷ = _lh_mmin_arg1³
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin₁₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰} | _  => error⁰}: 305
//│ [Z]: 257 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus₀₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 172
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus₁₁(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 184
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus₁₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 196
//│ [Z]: 276 --->
//│ 	case _lh_fact_arg2³ of {Z  => [S [Z]] | S _lh_fact_S_0³ => mmul₁₀([S _lh_fact_S_0³], _lh_fact_arg1³(mmin₁₀([S _lh_fact_S_0³], [S [Z]]))) | _  => error⁰}: 253
//│ [Z]: 295 --->
//│ 	case _lh_fact_arg2³ of {Z  => [S [Z]] | S _lh_fact_S_0³ => mmul₁₀([S _lh_fact_S_0³], _lh_fact_arg1³(mmin₁₀([S _lh_fact_S_0³], [S [Z]]))) | _  => error⁰}: 253
//│ ------------------
//│ case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus₀₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 172 --->
//│ 	[S pplus₁₁(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 182
//│ 	[S pplus₁₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]: 194
//│ 	[Z]: 200
//│ 	[Z]: 236
//│ 	[S [Z]]: 237
//│ 	[Z]: 257
//│ case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus₁₁(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 184 --->
//│ 	[S pplus₁₁(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 182
//│ 	[S pplus₁₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]: 194
//│ 	[Z]: 200
//│ 	[Z]: 236
//│ 	[S [Z]]: 237
//│ 	[Z]: 257
//│ case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus₁₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 196 --->
//│ 	[S pplus₁₁(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 182
//│ 	[S pplus₁₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]: 194
//│ 	[Z]: 200
//│ 	[Z]: 236
//│ 	[S [Z]]: 237
//│ 	[Z]: 257
//│ case _lh_fact_arg2³ of {Z  => [S [Z]] | S _lh_fact_S_0³ => mmul₁₀([S _lh_fact_S_0³], _lh_fact_arg1³(mmin₁₀([S _lh_fact_S_0³], [S [Z]]))) | _  => error⁰}: 253 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0²]: 224
//│ 	[S _lh_fact_S_0³]: 245
//│ 	[Z]: 276
//│ 	[Z]: 295
//│ case _lh_mmul_arg1³ of {Z  => [Z] | S _lh_mmul_S_0³ => pplus₁₁(_lh_mmul_arg2³, mmul₁₁(_lh_mmul_S_0³, _lh_mmul_arg2³)) | _  => error⁰}: 268 --->
//│ 	[S _lh_fact_S_0³]: 240
//│ case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₀₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 283 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0²]: 224
//│ case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₀₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 286 --->
//│ 	[Z]: 226
//│ 	[S [Z]]: 227
//│ case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin₁₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 302 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0³]: 245
//│ case _lh_matchIdent⁶ of {Z  => _lh_mmin_arg1³ | S _lh_mmin_S_0⁶ => let _lh_matchIdent⁷ = _lh_mmin_arg1³
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin₁₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰} | _  => error⁰}: 305 --->
//│ 	[Z]: 247
//│ 	[S [Z]]: 248
//│ case _lh_mmul_arg1⁴ of {Z  => [Z] | S _lh_mmul_S_0⁴ => pplus₀₀(_lh_mmul_arg2⁴, mmul₀₀(_lh_mmul_S_0⁴, _lh_mmul_arg2⁴)) | _  => error⁰}: 321 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0²]: 219
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Z]: 226 --->
//│ 	case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₀₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 286
//│ [S [Z]]: 227 --->
//│ 	case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₀₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 286
//│ [S _lh_fact_S_0³]: 240 --->
//│ 	case _lh_mmul_arg1³ of {Z  => [Z] | S _lh_mmul_S_0³ => pplus₁₁(_lh_mmul_arg2³, mmul₁₁(_lh_mmul_S_0³, _lh_mmul_arg2³)) | _  => error⁰}: 268
//│ [Z]: 247 --->
//│ 	case _lh_matchIdent⁶ of {Z  => _lh_mmin_arg1³ | S _lh_mmin_S_0⁶ => let _lh_matchIdent⁷ = _lh_mmin_arg1³
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin₁₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰} | _  => error⁰}: 305
//│ [S [Z]]: 248 --->
//│ 	case _lh_matchIdent⁶ of {Z  => _lh_mmin_arg1³ | S _lh_mmin_S_0⁶ => let _lh_matchIdent⁷ = _lh_mmin_arg1³
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin₁₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰} | _  => error⁰}: 305
//│ ------------------
//│ case _lh_mmul_arg1³ of {Z  => [Z] | S _lh_mmul_S_0³ => pplus₁₁(_lh_mmul_arg2³, mmul₁₁(_lh_mmul_S_0³, _lh_mmul_arg2³)) | _  => error⁰}: 268 --->
//│ 	[S _lh_fact_S_0³]: 240
//│ case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₀₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 286 --->
//│ 	[Z]: 226
//│ 	[S [Z]]: 227
//│ case _lh_matchIdent⁶ of {Z  => _lh_mmin_arg1³ | S _lh_mmin_S_0⁶ => let _lh_matchIdent⁷ = _lh_mmin_arg1³
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin₁₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰} | _  => error⁰}: 305 --->
//│ 	[Z]: 247
//│ 	[S [Z]]: 248
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let mainFact² = (fun x⁴ -> fact₀₀((fun y⁴ -> x⁴(x⁴, y⁴))))((fun x⁵ -> fact₁₀((fun y⁵ -> x⁵(x⁵, y⁵)))))
//│ 	in mainFact²(primId⁰([S [S [S [Z]]]]))
//│ def fact₀₀(_lh_fact_arg1⁵, _lh_fact_arg2⁵) = 
//│ 	case _lh_fact_arg2⁵ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0² => mmul₀₀([S _lh_fact_S_0²], _lh_fact_arg1⁵(mmin₀₀([S _lh_fact_S_0²], 
//│ 			let _lh_mmin_S_0⁹ = (fun _lh_mmin_arg1⁹ -> _lh_mmin_arg1⁹)
//│ 			in (fun _lh_mmin_arg1⁸ -> 
//│ 				let _lh_matchIdent¹¹ = _lh_mmin_arg1⁸
//│ 				in case _lh_matchIdent¹¹ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁵ => mmin₀₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁹)
//│ 					| _  => error⁰}))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin₀₀(_lh_mmin_arg1⁴, _lh_mmin_arg2⁴) = 
//│ 		let _lh_matchIdent⁸ = _lh_mmin_arg2⁴
//│ 		in _lh_matchIdent⁸(_lh_mmin_arg1⁴)
//│ 	def mmul₀₀(_lh_mmul_arg1⁷, _lh_mmul_arg2⁸) = 
//│ 		case _lh_mmul_arg1⁷ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0⁴ => pplus₀₀(_lh_mmul_arg2⁸, mmul₀₀(_lh_mmul_S_0⁴, _lh_mmul_arg2⁸))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus₀₀(_lh_pplus_arg1⁵, _lh_pplus_arg2⁵) = 
//│ 			case _lh_pplus_arg1⁵ of {
//│ 				Z  => _lh_pplus_arg2⁵
//│ 				| S _lh_pplus_S_0² => [S pplus₀₀(_lh_pplus_S_0², _lh_pplus_arg2⁵)]
//│ 				| _  => error⁰}
//│ def fact₁₀(_lh_fact_arg1⁴, _lh_fact_arg2⁴) = 
//│ 	case _lh_fact_arg2⁴ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0³ => mmul₁₀(
//│ 			let _lh_mmul_S_0⁵ = _lh_fact_S_0³
//│ 			in (fun _lh_mmul_arg2⁶ -> pplus₁₁(_lh_mmul_arg2⁶, mmul₁₁(_lh_mmul_S_0⁵, _lh_mmul_arg2⁶))), _lh_fact_arg1⁴(mmin₁₀([S _lh_fact_S_0³], 
//│ 			let _lh_mmin_S_0⁸ = (fun _lh_mmin_arg1⁶ -> _lh_mmin_arg1⁶)
//│ 			in (fun _lh_mmin_arg1⁵ -> 
//│ 				let _lh_matchIdent⁹ = _lh_mmin_arg1⁵
//│ 				in case _lh_matchIdent⁹ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁷ => mmin₁₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁸)
//│ 					| _  => error⁰}))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin₁₀(_lh_mmin_arg1⁷, _lh_mmin_arg2⁵) = 
//│ 		let _lh_matchIdent¹⁰ = _lh_mmin_arg2⁵
//│ 		in _lh_matchIdent¹⁰(_lh_mmin_arg1⁷)
//│ 	def mmul₁₀(_lh_mmul_arg1⁵, _lh_mmul_arg2⁵) = 
//│ 		_lh_mmul_arg1⁵(_lh_mmul_arg2⁵)
//│ 		where
//│ 		def mmul₁₁(_lh_mmul_arg1⁶, _lh_mmul_arg2⁷) = 
//│ 			case _lh_mmul_arg1⁶ of {
//│ 				Z  => [Z]
//│ 				| S _lh_mmul_S_0² => pplus₁₀(_lh_mmul_arg2⁷, mmul₁₁(_lh_mmul_S_0², _lh_mmul_arg2⁷))
//│ 				| _  => error⁰}
//│ 			where
//│ 			def pplus₁₀(_lh_pplus_arg1⁶, _lh_pplus_arg2⁶) = 
//│ 				case _lh_pplus_arg1⁶ of {
//│ 					Z  => _lh_pplus_arg2⁶
//│ 					| S _lh_pplus_S_0⁴ => [S pplus₁₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁶)]
//│ 					| _  => error⁰}
//│ 		def pplus₁₁(_lh_pplus_arg1⁷, _lh_pplus_arg2⁷) = 
//│ 			case _lh_pplus_arg1⁷ of {
//│ 				Z  => _lh_pplus_arg2⁷
//│ 				| S _lh_pplus_S_0³ => [S pplus₁₁(_lh_pplus_S_0³, _lh_pplus_arg2⁷)]
//│ 				| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [S [S [S [S [S [S [Z]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fact₀₀^1]
//│ 	[fact₀₀^1 · mmin₀₀^166] (hopeless to continue)
//│ 	[fact₀₀^1 · mmin₀₀^175] (hopeless to continue)
//│ 	[fact₀₀^1 · mmul₀₀^161]
//│ 		[fact₀₀^1 · mmul₀₀^161 · mmul₀₀^148] ---> [fact₀₀^1 · mmul₀₀^161] (only one)
//│ 		[fact₀₀^1 · mmul₀₀^161 · pplus₀₀^145]
//│ 			[fact₀₀^1 · mmul₀₀^161 · pplus₀₀^145 · pplus₀₀^36] ---> [fact₀₀^1 · mmul₀₀^161 · pplus₀₀^145] (only one)
//│ [fact₁₀^10]
//│ 	[fact₁₀^10 · mmin₁₀^83] (hopeless to continue)
//│ 	[fact₁₀^10 · mmin₁₀^92] (hopeless to continue)
//│ 	[fact₁₀^10 · mmul₁₀^68] (hopeless to continue)
//│ 	[fact₁₀^10 · mmul₁₁^73] (hopeless to continue)
//│ 		[fact₁₀^10 · mmul₁₁^73 · mmul₁₁^121] ---> [fact₁₀^10 · mmul₁₁^73] (using original def)
//│ 		[fact₁₀^10 · mmul₁₁^73 · pplus₁₀^118] (using original def)
//│ 			[fact₁₀^10 · mmul₁₁^73 · pplus₁₀^118 · pplus₁₀^48] ---> [fact₁₀^10 · mmul₁₁^73 · pplus₁₀^118] (using original def)
//│ 	[fact₁₀^10 · pplus₁₁^70]
//│ 		[fact₁₀^10 · pplus₁₁^70 · pplus₁₁^133] ---> [fact₁₀^10 · pplus₁₁^70] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ 
//│ 	let mainFact¹ = (fun x² -> fact₀₀₀((fun y² -> x²(x², y²))))((fun x³ -> fact₁₀₀((fun y³ -> x³(x³, y³)))))
//│ 	in mainFact¹(primId⁰([S [S [S [Z]]]]))
//│ def fact₀₀₀(_lh_fact_arg1³, _lh_fact_arg2³) = 
//│ 	case _lh_fact_arg2³ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0³ => mmul₀₀₀([S _lh_fact_S_0³], _lh_fact_arg1³(mmin₀₀₀([S _lh_fact_S_0³], 
//│ 			let _lh_mmin_S_0⁶ = (fun _lh_mmin_arg1¹¹ -> _lh_mmin_arg1¹¹)
//│ 			in (fun _lh_mmin_arg1¹² -> 
//│ 				let _lh_matchIdent⁸ = _lh_mmin_arg1¹²
//│ 				in case _lh_matchIdent⁸ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁷ => mmin₀₀₁(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶)
//│ 					| _  => error⁰}))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin₀₀₀(_lh_mmin_arg1¹³, _lh_mmin_arg2⁵) = 
//│ 		let _lh_matchIdent⁹ = _lh_mmin_arg2⁵
//│ 		in _lh_matchIdent⁹(_lh_mmin_arg1¹³)
//│ 	def mmin₀₀₁(_lh_mmin_arg1⁷, _lh_mmin_arg2³) = 
//│ 		let _lh_matchIdent⁵ = _lh_mmin_arg2³
//│ 		in _lh_matchIdent⁵(_lh_mmin_arg1⁷)
//│ 	def mmul₀₀₀(_lh_mmul_arg1⁵, _lh_mmul_arg2⁶) = 
//│ 		case _lh_mmul_arg1⁵ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0⁴ => pplus₀₀₀(_lh_mmul_arg2⁶, mmul₀₀₀(_lh_mmul_S_0⁴, _lh_mmul_arg2⁶))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus₀₀₀(_lh_pplus_arg1⁴, _lh_pplus_arg2⁴) = 
//│ 			case _lh_pplus_arg1⁴ of {
//│ 				Z  => _lh_pplus_arg2⁴
//│ 				| S _lh_pplus_S_0⁴ => [S pplus₀₀₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]
//│ 				| _  => error⁰}
//│ def fact₁₀₀(_lh_fact_arg1², _lh_fact_arg2²) = 
//│ 	case _lh_fact_arg2² of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0² => mmul₁₀₀(
//│ 			let _lh_mmul_S_0⁵ = _lh_fact_S_0²
//│ 			in (fun _lh_mmul_arg2⁷ -> pplus₁₁₀(_lh_mmul_arg2⁷, mmul₁₁₀(_lh_mmul_S_0⁵, _lh_mmul_arg2⁷))), _lh_fact_arg1²(mmin₁₀₀([S _lh_fact_S_0²], 
//│ 			let _lh_mmin_S_0⁴ = (fun _lh_mmin_arg1⁹ -> _lh_mmin_arg1⁹)
//│ 			in (fun _lh_mmin_arg1¹⁰ -> 
//│ 				let _lh_matchIdent⁷ = _lh_mmin_arg1¹⁰
//│ 				in case _lh_matchIdent⁷ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁵ => mmin₁₀₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴)
//│ 					| _  => error⁰}))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin₁₀₀(_lh_mmin_arg1⁶, _lh_mmin_arg2²) = 
//│ 		let _lh_matchIdent⁴ = _lh_mmin_arg2²
//│ 		in _lh_matchIdent⁴(_lh_mmin_arg1⁶)
//│ 	def mmin₁₀₁(_lh_mmin_arg1⁸, _lh_mmin_arg2⁴) = 
//│ 		let _lh_matchIdent⁶ = _lh_mmin_arg2⁴
//│ 		in _lh_matchIdent⁶(_lh_mmin_arg1⁸)
//│ 	def mmul₁₀₀(_lh_mmul_arg1³, _lh_mmul_arg2⁴) = 
//│ 		_lh_mmul_arg1³(_lh_mmul_arg2⁴)
//│ 	def mmul₁₁₀(_lh_mmul_arg1⁴, _lh_mmul_arg2⁵) = 
//│ 		case _lh_mmul_arg1⁴ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0³ => pplus₁₀₀(_lh_mmul_arg2⁵, mmul₁₁₀(_lh_mmul_S_0³, _lh_mmul_arg2⁵))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus₁₀₀(_lh_pplus_arg1³, _lh_pplus_arg2³) = 
//│ 			case _lh_pplus_arg1³ of {
//│ 				Z  => _lh_pplus_arg2³
//│ 				| S _lh_pplus_S_0³ => [S pplus₁₀₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]
//│ 				| _  => error⁰}
//│ 	def pplus₁₁₀(_lh_pplus_arg1⁵, _lh_pplus_arg2⁵) = 
//│ 		case _lh_pplus_arg1⁵ of {
//│ 			Z  => _lh_pplus_arg2⁵
//│ 			| S _lh_pplus_S_0⁵ => [S pplus₁₁₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)]
//│ 			| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Z]: 212 --->
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus₁₀₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 235
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus₀₀₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 254
//│ 	case _lh_pplus_arg1⁵ of {Z  => _lh_pplus_arg2⁵ | S _lh_pplus_S_0⁵ => [S pplus₁₁₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)] | _  => error⁰}: 325
//│ [S pplus₁₀₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 233 --->
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus₁₀₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 235
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus₀₀₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 254
//│ 	case _lh_pplus_arg1⁵ of {Z  => _lh_pplus_arg2⁵ | S _lh_pplus_S_0⁵ => [S pplus₁₁₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)] | _  => error⁰}: 325
//│ [Z]: 273 --->
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus₁₀₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 235
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus₀₀₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 254
//│ 	case _lh_pplus_arg1⁵ of {Z  => _lh_pplus_arg2⁵ | S _lh_pplus_S_0⁵ => [S pplus₁₁₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)] | _  => error⁰}: 325
//│ [S [Z]]: 274 --->
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus₁₀₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 235
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus₀₀₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 254
//│ 	case _lh_pplus_arg1⁵ of {Z  => _lh_pplus_arg2⁵ | S _lh_pplus_S_0⁵ => [S pplus₁₁₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)] | _  => error⁰}: 325
//│ [S _lh_fact_S_0²]: 292 --->
//│ 	case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₁₀₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 305
//│ [Z]: 298 --->
//│ 	case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul₁₀₀(let _lh_mmul_S_0⁵ = _lh_fact_S_0²
//│ in (fun _lh_mmul_arg2⁷ -> pplus₁₁₀(_lh_mmul_arg2⁷, mmul₁₁₀(_lh_mmul_S_0⁵, _lh_mmul_arg2⁷))), _lh_fact_arg1²(mmin₁₀₀([S _lh_fact_S_0²], let _lh_mmin_S_0⁴ = (fun _lh_mmin_arg1⁹ -> _lh_mmin_arg1⁹)
//│ in (fun _lh_mmin_arg1¹⁰ -> let _lh_matchIdent⁷ = _lh_mmin_arg1¹⁰
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₁₀₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰})))) | _  => error⁰}: 313
//│ [S pplus₁₁₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)]: 323 --->
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus₁₀₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 235
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus₀₀₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 254
//│ 	case _lh_pplus_arg1⁵ of {Z  => _lh_pplus_arg2⁵ | S _lh_pplus_S_0⁵ => [S pplus₁₁₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)] | _  => error⁰}: 325
//│ [S _lh_fact_S_0³]: 333 --->
//│ 	case _lh_mmul_arg1⁵ of {Z  => [Z] | S _lh_mmul_S_0⁴ => pplus₀₀₀(_lh_mmul_arg2⁶, mmul₀₀₀(_lh_mmul_S_0⁴, _lh_mmul_arg2⁶)) | _  => error⁰}: 269
//│ [S _lh_fact_S_0³]: 338 --->
//│ 	case _lh_matchIdent⁸ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin₀₀₁(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 351
//│ [Z]: 344 --->
//│ 	case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul₁₀₀(let _lh_mmul_S_0⁵ = _lh_fact_S_0²
//│ in (fun _lh_mmul_arg2⁷ -> pplus₁₁₀(_lh_mmul_arg2⁷, mmul₁₁₀(_lh_mmul_S_0⁵, _lh_mmul_arg2⁷))), _lh_fact_arg1²(mmin₁₀₀([S _lh_fact_S_0²], let _lh_mmin_S_0⁴ = (fun _lh_mmin_arg1⁹ -> _lh_mmin_arg1⁹)
//│ in (fun _lh_mmin_arg1¹⁰ -> let _lh_matchIdent⁷ = _lh_mmin_arg1¹⁰
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₁₀₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰})))) | _  => error⁰}: 313
//│ ------------------
//│ case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus₁₀₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 235 --->
//│ 	[Z]: 212
//│ 	[S pplus₁₀₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 233
//│ 	[Z]: 273
//│ 	[S [Z]]: 274
//│ 	[S pplus₁₁₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)]: 323
//│ case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus₀₀₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 254 --->
//│ 	[Z]: 212
//│ 	[S pplus₁₀₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 233
//│ 	[Z]: 273
//│ 	[S [Z]]: 274
//│ 	[S pplus₁₁₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)]: 323
//│ case _lh_mmul_arg1⁵ of {Z  => [Z] | S _lh_mmul_S_0⁴ => pplus₀₀₀(_lh_mmul_arg2⁶, mmul₀₀₀(_lh_mmul_S_0⁴, _lh_mmul_arg2⁶)) | _  => error⁰}: 269 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0³]: 333
//│ case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₁₀₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 305 --->
//│ 	[S _lh_fact_S_0²]: 292
//│ case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul₁₀₀(let _lh_mmul_S_0⁵ = _lh_fact_S_0²
//│ in (fun _lh_mmul_arg2⁷ -> pplus₁₁₀(_lh_mmul_arg2⁷, mmul₁₁₀(_lh_mmul_S_0⁵, _lh_mmul_arg2⁷))), _lh_fact_arg1²(mmin₁₀₀([S _lh_fact_S_0²], let _lh_mmin_S_0⁴ = (fun _lh_mmin_arg1⁹ -> _lh_mmin_arg1⁹)
//│ in (fun _lh_mmin_arg1¹⁰ -> let _lh_matchIdent⁷ = _lh_mmin_arg1¹⁰
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₁₀₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰})))) | _  => error⁰}: 313 --->
//│ 	NoProd
//│ 	[Z]: 298
//│ 	[Z]: 344
//│ case _lh_pplus_arg1⁵ of {Z  => _lh_pplus_arg2⁵ | S _lh_pplus_S_0⁵ => [S pplus₁₁₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)] | _  => error⁰}: 325 --->
//│ 	[Z]: 212
//│ 	[S pplus₁₀₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 233
//│ 	[Z]: 273
//│ 	[S [Z]]: 274
//│ 	[S pplus₁₁₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)]: 323
//│ case _lh_matchIdent⁸ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin₀₀₁(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 351 --->
//│ 	[S _lh_fact_S_0³]: 338
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [S _lh_fact_S_0²]: 292 --->
//│ 	case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₁₀₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 305
//│ [S _lh_fact_S_0³]: 338 --->
//│ 	case _lh_matchIdent⁸ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin₀₀₁(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 351
//│ ------------------
//│ case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin₁₀₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 305 --->
//│ 	[S _lh_fact_S_0²]: 292
//│ case _lh_matchIdent⁸ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin₀₀₁(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 351 --->
//│ 	[S _lh_fact_S_0³]: 338
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let mainFact² = (fun x⁴ -> fact₀₀₀((fun y⁴ -> x⁴(x⁴, y⁴))))((fun x⁵ -> fact₁₀₀((fun y⁵ -> x⁵(x⁵, y⁵)))))
//│ 	in mainFact²(primId⁰([S [S [S [Z]]]]))
//│ def fact₀₀₀(_lh_fact_arg1⁴, _lh_fact_arg2⁴) = 
//│ 	case _lh_fact_arg2⁴ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0³ => mmul₀₀₀([S _lh_fact_S_0³], _lh_fact_arg1⁴(mmin₀₀₀(
//│ 			let _lh_mmin_S_0⁸ = _lh_fact_S_0³
//│ 			in (fun _lh_mmin_S_0⁹ -> mmin₀₀₁(_lh_mmin_S_0⁸, _lh_mmin_S_0⁹)), 
//│ 			let _lh_mmin_S_0¹⁰ = (fun _lh_mmin_arg1¹⁵ -> _lh_mmin_arg1¹⁵)
//│ 			in (fun _lh_mmin_arg1¹⁶ -> 
//│ 				let _lh_matchIdent¹¹ = _lh_mmin_arg1¹⁶
//│ 				in _lh_matchIdent¹¹(_lh_mmin_S_0¹⁰)))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin₀₀₀(_lh_mmin_arg1²¹, _lh_mmin_arg2⁹) = 
//│ 		let _lh_matchIdent¹⁵ = _lh_mmin_arg2⁹
//│ 		in _lh_matchIdent¹⁵(_lh_mmin_arg1²¹)
//│ 	def mmin₀₀₁(_lh_mmin_arg1¹⁸, _lh_mmin_arg2⁸) = 
//│ 		let _lh_matchIdent¹³ = _lh_mmin_arg2⁸
//│ 		in _lh_matchIdent¹³(_lh_mmin_arg1¹⁸)
//│ 	def mmul₀₀₀(_lh_mmul_arg1⁶, _lh_mmul_arg2⁸) = 
//│ 		case _lh_mmul_arg1⁶ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0⁴ => pplus₀₀₀(_lh_mmul_arg2⁸, mmul₀₀₀(_lh_mmul_S_0⁴, _lh_mmul_arg2⁸))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus₀₀₀(_lh_pplus_arg1⁸, _lh_pplus_arg2⁸) = 
//│ 			case _lh_pplus_arg1⁸ of {
//│ 				Z  => _lh_pplus_arg2⁸
//│ 				| S _lh_pplus_S_0⁴ => [S pplus₀₀₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁸)]
//│ 				| _  => error⁰}
//│ def fact₁₀₀(_lh_fact_arg1⁵, _lh_fact_arg2⁵) = 
//│ 	case _lh_fact_arg2⁵ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0² => mmul₁₀₀(
//│ 			let _lh_mmul_S_0⁶ = _lh_fact_S_0²
//│ 			in (fun _lh_mmul_arg2¹⁰ -> pplus₁₁₀(_lh_mmul_arg2¹⁰, mmul₁₁₀(_lh_mmul_S_0⁶, _lh_mmul_arg2¹⁰))), _lh_fact_arg1⁵(mmin₁₀₀(
//│ 			let _lh_mmin_S_0¹¹ = _lh_fact_S_0²
//│ 			in (fun _lh_mmin_S_0¹² -> mmin₁₀₁(_lh_mmin_S_0¹¹, _lh_mmin_S_0¹²)), 
//│ 			let _lh_mmin_S_0¹³ = (fun _lh_mmin_arg1¹⁹ -> _lh_mmin_arg1¹⁹)
//│ 			in (fun _lh_mmin_arg1²⁰ -> 
//│ 				let _lh_matchIdent¹⁴ = _lh_mmin_arg1²⁰
//│ 				in _lh_matchIdent¹⁴(_lh_mmin_S_0¹³)))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin₁₀₀(_lh_mmin_arg1¹⁴, _lh_mmin_arg2⁶) = 
//│ 		let _lh_matchIdent¹⁰ = _lh_mmin_arg2⁶
//│ 		in _lh_matchIdent¹⁰(_lh_mmin_arg1¹⁴)
//│ 	def mmin₁₀₁(_lh_mmin_arg1¹⁷, _lh_mmin_arg2⁷) = 
//│ 		let _lh_matchIdent¹² = _lh_mmin_arg2⁷
//│ 		in _lh_matchIdent¹²(_lh_mmin_arg1¹⁷)
//│ 	def mmul₁₀₀(_lh_mmul_arg1⁷, _lh_mmul_arg2⁹) = 
//│ 		_lh_mmul_arg1⁷(_lh_mmul_arg2⁹)
//│ 	def mmul₁₁₀(_lh_mmul_arg1⁸, _lh_mmul_arg2¹¹) = 
//│ 		case _lh_mmul_arg1⁸ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0³ => pplus₁₀₀(_lh_mmul_arg2¹¹, mmul₁₁₀(_lh_mmul_S_0³, _lh_mmul_arg2¹¹))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus₁₀₀(_lh_pplus_arg1⁷, _lh_pplus_arg2⁷) = 
//│ 			case _lh_pplus_arg1⁷ of {
//│ 				Z  => _lh_pplus_arg2⁷
//│ 				| S _lh_pplus_S_0³ => [S pplus₁₀₀(_lh_pplus_S_0³, _lh_pplus_arg2⁷)]
//│ 				| _  => error⁰}
//│ 	def pplus₁₁₀(_lh_pplus_arg1⁶, _lh_pplus_arg2⁶) = 
//│ 		case _lh_pplus_arg1⁶ of {
//│ 			Z  => _lh_pplus_arg2⁶
//│ 			| S _lh_pplus_S_0⁵ => [S pplus₁₁₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁶)]
//│ 			| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [S [S [S [S [S [S [Z]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
