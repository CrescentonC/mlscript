:NewParser
:ParseOnly



// CORRECT:
let p = C(1, C(2, N))
fun e(z) = if z is
  C(aaa, bbb) then bbb
  N then 7
fun d(y) = if y is
  C(aa, bb) then e(bb)
  N then 5
fun c(x) = if x is
  C(a, b) then d(b)
  N then 3
c(p)
//│ |#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#fun| |e|(|z|)| |#=| |#if| |z| |is|→|C|(|aaa|,| |bbb|)| |#then| |bbb|↵|N| |#then| |7|←|↵|#fun| |d|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|,| |bb|)| |#then| |e|(|bb|)|↵|N| |#then| |5|←|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|,| |b|)| |#then| |d|(|b|)|↵|N| |#then| |3|←|↵|c|(|p|)|
//│ Parsed: {let p = C (1, C (2, N,),); fun e = z, => if z is ‹(C (aaa, bbb,)) then bbb; (N) then 7›; fun d = y, => if y is ‹(C (aa, bb,)) then e (bb,); (N) then 5›; fun c = x, => if x is ‹(C (a, b,)) then d (b,); (N) then 3›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^25(p^26)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ b⁰ => d^19(b⁰)
//│ 	| N  => 3}
//│ def d(y⁰) = case y⁰ of {
//│ 	C aa⁰ bb⁰ => e^12(bb⁰)
//│ 	| N  => 5}
//│ def e(z⁰) = case z⁰ of {
//│ 	C aaa⁰ bbb⁰ => bbb⁰
//│ 	| N  => 7}
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^25] (hopeless to continue)
//│ 	[c^25 · d^19] (using original def)
//│ 		[c^25 · d^19 · e^12] (using original def)
//│ [p^26] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ b¹ => d_₀(b¹)
//│ 		| N  => 3}
//│ 	where
//│ 	def d_₀(y¹) = 
//│ 		case y¹ of {
//│ 			C aa¹ bb¹ => e_₀(bb¹)
//│ 			| N  => 5}
//│ 		where
//│ 		def e_₀(z¹) = 
//│ 			case z¹ of {
//│ 				C aaa¹ bbb¹ => bbb¹
//│ 				| N  => 7}
//│ def p_₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 37 --->
//│ 	case z¹ of {C aaa¹ bbb¹ => bbb¹ | N  => 7}: 43
//│ [C 2 [N]]: 38 --->
//│ 	case y¹ of {C aa¹ bb¹ => e_₀(bb¹) | N  => 5}: 50
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case x¹ of {C a¹ b¹ => d_₀(b¹) | N  => 3}: 33
//│ ------------------
//│ case x¹ of {C a¹ b¹ => d_₀(b¹) | N  => 3}: 33 --->
//│ 	[C 1 [C 2 [N]]]: 39
//│ case z¹ of {C aaa¹ bbb¹ => bbb¹ | N  => 7}: 43 --->
//│ 	[N]: 37
//│ case y¹ of {C aa¹ bb¹ => e_₀(bb¹) | N  => 5}: 50 --->
//│ 	[C 2 [N]]: 38
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 37 --->
//│ 	case z¹ of {C aaa¹ bbb¹ => bbb¹ | N  => 7}: 43
//│ [C 2 [N]]: 38 --->
//│ 	case y¹ of {C aa¹ bb¹ => e_₀(bb¹) | N  => 5}: 50
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case x¹ of {C a¹ b¹ => d_₀(b¹) | N  => 3}: 33
//│ ------------------
//│ case x¹ of {C a¹ b¹ => d_₀(b¹) | N  => 3}: 33 --->
//│ 	[C 1 [C 2 [N]]]: 39
//│ case z¹ of {C aaa¹ bbb¹ => bbb¹ | N  => 7}: 43 --->
//│ 	[N]: 37
//│ case y¹ of {C aa¹ bb¹ => e_₀(bb¹) | N  => 5}: 50 --->
//│ 	[C 2 [N]]: 38
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x²) = 
//│ 	x²(99)
//│ 	where
//│ 	def d_₀(y²) = 
//│ 		y²(99)
//│ 		where
//│ 		def e_₀(z²) = 
//│ 			z²
//│ def p_₀ = 
//│ 	let b² = 	
//│ 		let bb² = 7
//│ 		in (fun _lh_dummy¹ -> e_₀(bb²))
//│ 	in (fun _lh_dummy⁰ -> d_₀(b²))
//│ <<<<<<< after fusion <<<<<<<



// CORRECT:
fun sum(ls) = if ls is
  C(h, t) then S(N, sum(t))
fun mapa(lsa) = if lsa is
  C(ha, ta) then C(primitive(ha), mapa(ta))
fun mapb(lsb) = if lsb is
  C(hb, tb) then C(primitive(hb), mapb(tb))
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),)›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),)›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),)›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ sum^29(mapa^30(mapb^31(primitive⁰)))
//│ def mapa(lsa⁰) = case lsa⁰ of {
//│ 	C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa^13(ta⁰)]}
//│ def mapb(lsb⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => [C primitive⁰(hb⁰) mapb^23(tb⁰)]}
//│ def sum(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [S [N] sum^3(t⁰)]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa^30]
//│ 	[mapa^30 · mapa^13] ---> [mapa^30] (only one)
//│ [mapb^31]
//│ 	[mapb^31 · mapb^23] ---> [mapb^31] (only one)
//│ [sum^29]
//│ 	[sum^29 · sum^3] ---> [sum^29] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ sum_₀(mapa_₀(mapb_₀(primitive⁰)))
//│ def mapa_₀(lsa¹) = 
//│ 	case lsa¹ of {
//│ 		C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)]}
//│ def mapb_₀(lsb¹) = 
//│ 	case lsb¹ of {
//│ 		C hb¹ tb¹ => [C primitive⁰(hb¹) mapb_₀(tb¹)]}
//│ def sum_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => [S [N] sum_₀(t¹)]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰(hb¹) mapb_₀(tb¹)]: 51 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)]}: 62
//│ [C primitive⁰(ha¹) mapa_₀(ta¹)]: 61 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)]}: 42
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)]}: 42 --->
//│ 	[C primitive⁰(ha¹) mapa_₀(ta¹)]: 61
//│ case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)]}: 62 --->
//│ 	[C primitive⁰(hb¹) mapb_₀(tb¹)]: 51
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C primitive⁰(hb¹) mapb_₀(tb¹)]: 51 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)]}: 62
//│ [C primitive⁰(ha¹) mapa_₀(ta¹)]: 61 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)]}: 42
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)]}: 42 --->
//│ 	[C primitive⁰(ha¹) mapa_₀(ta¹)]: 61
//│ case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)]}: 62 --->
//│ 	[C primitive⁰(hb¹) mapb_₀(tb¹)]: 51
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ sum_₀(mapa_₀(mapb_₀(primitive⁰)))
//│ def mapa_₀(lsa²) = 
//│ 	lsa²(99)
//│ def mapb_₀(lsb²) = 
//│ 	case lsb² of {
//│ 		C hb¹ tb¹ => 
//│ 			let ta² = mapb_₀(tb¹)
//│ 			in let ha² = primitive⁰(hb¹)
//│ 			in (fun _lh_dummy¹ -> 
//│ 				let t² = mapa_₀(ta²)
//│ 				in (fun _lh_dummy⁰ -> [S [N] sum_₀(t²)]))}
//│ def sum_₀(ls²) = 
//│ 	ls²(99)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
if C(A, B(C)) is
  C(a, b) then D(b)
//│ |#if| |C|(|A|,| |B|(|C|)|)| |is|→|C|(|a|,| |b|)| |#then| |D|(|b|)|←|
//│ Parsed: {if C (A, B (C,),) is ‹(C (a, b,)) then D (b,)›}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a⁰ b⁰ => [D b⁰]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a¹ b¹ => [D b¹]}
//│ 
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A] [B [C]]]: 11 --->
//│ 	case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14
//│ ------------------
//│ case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14 --->
//│ 	[C [A] [B [C]]]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [A] [B [C]]]: 11 --->
//│ 	case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14
//│ ------------------
//│ case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14 --->
//│ 	[C [A] [B [C]]]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let b² = [B [C]]
//│ 	in [D b²]
//│ 
//│ <<<<<<< after fusion <<<<<<<
//│




// def p:6^18 =
//      ... p:6^1 ~> p:6^18.p:6^1 ...

// def p:6^18.p:6^1 =
//      ... p:6^1 ~> p:6^18 ...

// def ca:7^17
//      ... 



// CORRECT: every element is handled
fun ff(x) = if x is
  K then T
  KK then TT
  KKKK then TTTT
fun map(ls) = if ls is
  C(h, t) then C(ff(h), map(t))
  N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|ff|(|h|)|,| |map|(|t|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; fun map = ls, => if ls is ‹(C (h, t,)) then C (ff (h,), map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^25(l^26)
//│ def ff(x⁰) = case x⁰ of {
//│ 	K  => [T]
//│ 	| KK  => [TT]
//│ 	| KKKK  => [TTTT]}
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C ff^8(h⁰) map^11(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^26] (hopeless to continue)
//│ [map^25]
//│ 	[map^25 · ff^8] (hopeless to continue)
//│ 	[map^25 · map^11] ---> [map^25] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map_₀(l_₀)
//│ def l_₀ = 
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)]
//│ 		| N  => [N]}
//│ 	where
//│ 	def ff_₀(x¹) = 
//│ 		case x¹ of {
//│ 			K  => [T]
//│ 			| KK  => [TT]
//│ 			| KKKK  => [TTTT]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 39 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [KK]: 40 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [KKKK]: 41 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [N]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ [C [KKKK] [N]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ [C [KK] [C [KKKK] [N]]]: 44 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 45 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37 --->
//│ 	[N]: 42
//│ 	[C [KKKK] [N]]: 43
//│ 	[C [KK] [C [KKKK] [N]]]: 44
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 45
//│ case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50 --->
//│ 	[K]: 39
//│ 	[KK]: 40
//│ 	[KKKK]: 41
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 39 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [KK]: 40 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [KKKK]: 41 --->
//│ 	case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50
//│ [N]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ [C [KKKK] [N]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ [C [KK] [C [KKKK] [N]]]: 44 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 45 --->
//│ 	case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C ff_₀(h¹) map_₀(t¹)] | N  => [N]}: 37 --->
//│ 	[N]: 42
//│ 	[C [KKKK] [N]]: 43
//│ 	[C [KK] [C [KKKK] [N]]]: 44
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 45
//│ case x¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 50 --->
//│ 	[K]: 39
//│ 	[KK]: 40
//│ 	[KKKK]: 41
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map_₀(l_₀)
//│ def l_₀ = 
//│ 	let t² = 	
//│ 		let t³ = 	
//│ 			let t⁴ = (fun _lh_dummy³ -> [N])
//│ 			in let h⁴ = [TTTT]
//│ 			in (fun _lh_dummy² -> [C ff_₀(h⁴) map_₀(t⁴)])
//│ 		in let h³ = [TT]
//│ 		in (fun _lh_dummy¹ -> [C ff_₀(h³) map_₀(t³)])
//│ 	in let h² = [T]
//│ 	in (fun _lh_dummy⁰ -> [C ff_₀(h²) map_₀(t²)])
//│ def map_₀(ls²) = 
//│ 	ls²(99)
//│ 	where
//│ 	def ff_₀(x²) = 
//│ 		x²
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: every element is handled
fun map(ls) = if ls is
  C(h, t) then C(
    (if h is
      K then T
      KK then TT
      KKKK then TTTT
    ),
    map(t)
  )
  N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›, ')', map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^21(l^22)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C case h⁰ of {
//│ 		K  => [T]
//│ 		| KK  => [TT]
//│ 		| KKKK  => [TTTT]} map^7(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^22] (hopeless to continue)
//│ [map^21]
//│ 	[map^21 · map^7] ---> [map^21] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map_₀(l_₀)
//│ def l_₀ = 
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => [C case h¹ of {
//│ 			K  => [T]
//│ 			| KK  => [TT]
//│ 			| KKKK  => [TTTT]} map_₀(t¹)]
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 37 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [KK]: 38 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [KKKK]: 39 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [N]: 40 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ [C [KKKK] [N]]: 41 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ [C [KK] [C [KKKK] [N]]]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ ------------------
//│ case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29 --->
//│ 	[K]: 37
//│ 	[KK]: 38
//│ 	[KKKK]: 39
//│ case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35 --->
//│ 	[N]: 40
//│ 	[C [KKKK] [N]]: 41
//│ 	[C [KK] [C [KKKK] [N]]]: 42
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 43
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 37 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [KK]: 38 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [KKKK]: 39 --->
//│ 	case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29
//│ [N]: 40 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ [C [KKKK] [N]]: 41 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ [C [KK] [C [KKKK] [N]]]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35
//│ ------------------
//│ case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 29 --->
//│ 	[K]: 37
//│ 	[KK]: 38
//│ 	[KKKK]: 39
//│ case ls¹ of {C h¹ t¹ => [C case h¹ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map_₀(t¹)] | N  => [N]}: 35 --->
//│ 	[N]: 40
//│ 	[C [KKKK] [N]]: 41
//│ 	[C [KK] [C [KKKK] [N]]]: 42
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 43
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map_₀(l_₀)
//│ def l_₀ = 
//│ 	let t² = 	
//│ 		let t³ = 	
//│ 			let t⁴ = (fun _lh_dummy³ -> [N])
//│ 			in let h⁴ = [TTTT]
//│ 			in (fun _lh_dummy² -> [C h⁴ map_₀(t⁴)])
//│ 		in let h³ = [TT]
//│ 		in (fun _lh_dummy¹ -> [C h³ map_₀(t³)])
//│ 	in let h² = [T]
//│ 	in (fun _lh_dummy⁰ -> [C h² map_₀(t²)])
//│ def map_₀(ls²) = 
//│ 	ls²(99)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
fun sum(ls) = if ls is
  C(h, t) then S(N, sum(t))
  N then N
fun mapa(lsa) = if lsa is
  C(ha, ta) then C(primitive(ha), mapa(ta))
  N then N
fun mapb(lsb) = if lsb is
  C(hb, tb) then C(primitive(hb), mapb(tb))
  N then N
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|↵|N| |#then| |N|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|↵|N| |#then| |N|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),); (N) then N›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),); (N) then N›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),); (N) then N›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ sum^32(mapa^33(mapb^34(primitive⁰)))
//│ def mapa(lsa⁰) = case lsa⁰ of {
//│ 	C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa^14(ta⁰)]
//│ 	| N  => [N]}
//│ def mapb(lsb⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => [C primitive⁰(hb⁰) mapb^25(tb⁰)]
//│ 	| N  => [N]}
//│ def sum(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [S [N] sum^3(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa^33]
//│ 	[mapa^33 · mapa^14] ---> [mapa^33] (only one)
//│ [mapb^34]
//│ 	[mapb^34 · mapb^25] ---> [mapb^34] (only one)
//│ [sum^32]
//│ 	[sum^32 · sum^3] ---> [sum^32] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ sum_₀(mapa_₀(mapb_₀(primitive⁰)))
//│ def mapa_₀(lsa¹) = 
//│ 	case lsa¹ of {
//│ 		C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)]
//│ 		| N  => [N]}
//│ def mapb_₀(lsb¹) = 
//│ 	case lsb¹ of {
//│ 		C hb¹ tb¹ => [C primitive⁰(hb¹) mapb_₀(tb¹)]
//│ 		| N  => [N]}
//│ def sum_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => [S [N] sum_₀(t¹)]
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰(ha¹) mapa_₀(ta¹)]: 55 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)] | N  => [N]}: 46
//│ [N]: 56 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)] | N  => [N]}: 46
//│ [C primitive⁰(hb¹) mapb_₀(tb¹)]: 66 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)] | N  => [N]}: 57
//│ [N]: 67 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)] | N  => [N]}: 57
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)] | N  => [N]}: 46 --->
//│ 	[C primitive⁰(ha¹) mapa_₀(ta¹)]: 55
//│ 	[N]: 56
//│ case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)] | N  => [N]}: 57 --->
//│ 	[C primitive⁰(hb¹) mapb_₀(tb¹)]: 66
//│ 	[N]: 67
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C primitive⁰(ha¹) mapa_₀(ta¹)]: 55 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)] | N  => [N]}: 46
//│ [N]: 56 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)] | N  => [N]}: 46
//│ [C primitive⁰(hb¹) mapb_₀(tb¹)]: 66 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)] | N  => [N]}: 57
//│ [N]: 67 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)] | N  => [N]}: 57
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] sum_₀(t¹)] | N  => [N]}: 46 --->
//│ 	[C primitive⁰(ha¹) mapa_₀(ta¹)]: 55
//│ 	[N]: 56
//│ case lsa¹ of {C ha¹ ta¹ => [C primitive⁰(ha¹) mapa_₀(ta¹)] | N  => [N]}: 57 --->
//│ 	[C primitive⁰(hb¹) mapb_₀(tb¹)]: 66
//│ 	[N]: 67
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ sum_₀(mapa_₀(mapb_₀(primitive⁰)))
//│ def mapa_₀(lsa²) = 
//│ 	lsa²(99)
//│ def mapb_₀(lsb²) = 
//│ 	case lsb² of {
//│ 		C hb¹ tb¹ => 
//│ 			let ta² = mapb_₀(tb¹)
//│ 			in let ha² = primitive⁰(hb¹)
//│ 			in (fun _lh_dummy¹ -> 
//│ 				let t² = mapa_₀(ta²)
//│ 				in (fun _lh_dummy⁰ -> [S [N] sum_₀(t²)]))
//│ 		| N  => (fun _lh_dummy³ -> (fun _lh_dummy² -> [N]))}
//│ def sum_₀(ls²) = 
//│ 	ls²(99)
//│ <<<<<<< after fusion <<<<<<<




// CORRECT:
let p = C(N)
fun c(x) = if C(x) is
  C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|N|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (N,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^10(p^11)
//│ def c(x⁰) = case [C x⁰] of {
//│ 	C a⁰ => c^5(a⁰)}
//│ def p = [C [N]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^10]
//│ 	[c^10 · c^5] ---> [c^10] (only one)
//│ [p^11] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x¹) = 
//│ 	case [C x¹] of {
//│ 		C a¹ => c_₀(a¹)}
//│ def p_₀ = 
//│ 	[C [N]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => c_₀(a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => c_₀(a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => c_₀(a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => c_₀(a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x²) = 
//│ 	
//│ 		let a² = x²
//│ 		in (fun _lh_dummy⁰ -> c_₀(a²))(99)
//│ def p_₀ = 
//│ 	[C [N]]
//│ <<<<<<< after fusion <<<<<<<


// let rec p = C(p)
// let q = p
// fun c(x) = if x is
//     C(a) then a
// fun c2(z) = if z is
//     C(b) then c2(b)
// let main = c(q)
// c2(main)



// CORRECT:
_LUMBERHACK_EVAL
let t = T(K, T(N, L, L), T(N, L, L))
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |_LUMBERHACK_EVAL|↵|#let| |t| |#=| |T|(|K|,| |T|(|N|,| |L|,| |L|)|,| |T|(|N|,| |L|,| |L|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {_LUMBERHACK_EVAL; let t = T (K, T (N, L, L,), T (N, L, L,),); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^26(t^27)
//│ def c(x⁰) = case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K  => [KK]
//│ 		| N  => [NN]} c^16(l⁰) c^19(r⁰)]
//│ 	| L  => [LL]}
//│ def t = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^26]
//│ 	[c^26 · c^16] ---> [c^26] (only one)
//│ 	[c^26 · c^19] ---> [c^26] (only one)
//│ [t^27] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(t_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		T n¹ l¹ r¹ => [T case n¹ of {
//│ 			K  => [KK]
//│ 			| N  => [NN]} c_₀(l¹) c_₀(r¹)]
//│ 		| L  => [LL]}
//│ def t_₀ = 
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 44 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [N]: 45 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [L]: 46 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [L]: 47 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [T [N] [L] [L]]: 48 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [N]: 49 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [L]: 50 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [L]: 51 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [T [N] [L] [L]]: 52 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 33 --->
//│ 	[K]: 44
//│ 	[N]: 45
//│ 	[N]: 49
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42 --->
//│ 	[L]: 46
//│ 	[L]: 47
//│ 	[T [N] [L] [L]]: 48
//│ 	[L]: 50
//│ 	[L]: 51
//│ 	[T [N] [L] [L]]: 52
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 44 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [N]: 45 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [L]: 46 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [L]: 47 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [T [N] [L] [L]]: 48 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [N]: 49 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 33
//│ [L]: 50 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [L]: 51 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [T [N] [L] [L]]: 52 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 33 --->
//│ 	[K]: 44
//│ 	[N]: 45
//│ 	[N]: 49
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 42 --->
//│ 	[L]: 46
//│ 	[L]: 47
//│ 	[T [N] [L] [L]]: 48
//│ 	[L]: 50
//│ 	[L]: 51
//│ 	[T [N] [L] [L]]: 52
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(t_₀)
//│ def c_₀(x²) = 
//│ 	x²(99)
//│ def t_₀ = 
//│ 	let r² = 	
//│ 		let r⁴ = (fun _lh_dummy⁶ -> [LL])
//│ 		in let l⁴ = (fun _lh_dummy⁵ -> [LL])
//│ 		in let n⁴ = [NN]
//│ 		in (fun _lh_dummy⁴ -> [T n⁴ c_₀(l⁴) c_₀(r⁴)])
//│ 	in let l² = 	
//│ 		let r³ = (fun _lh_dummy³ -> [LL])
//│ 		in let l³ = (fun _lh_dummy² -> [LL])
//│ 		in let n³ = [NN]
//│ 		in (fun _lh_dummy¹ -> [T n³ c_₀(l³) c_₀(r³)])
//│ 	in let n² = [KK]
//│ 	in (fun _lh_dummy⁰ -> [T n² c_₀(l²) c_₀(r²)])
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |_LUMBERHACK_EVAL|↵|#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {_LUMBERHACK_EVAL; let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^28(t^29)
//│ def aa = [T [N] [L] [L]]
//│ def bb = [T [N] [L] [L]]
//│ def c(x⁰) = case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K  => [KK]
//│ 		| N  => [NN]} c^18(l⁰) c^21(r⁰)]
//│ 	| L  => [LL]}
//│ def t = [T [K] aa^10 bb^11]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^28]
//│ 	[c^28 · c^18] ---> [c^28] (only one)
//│ 	[c^28 · c^21] ---> [c^28] (only one)
//│ [t^29] (hopeless to continue)
//│ 	[t^29 · aa^10] (using original def)
//│ 	[t^29 · bb^11] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(t_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		T n¹ l¹ r¹ => [T case n¹ of {
//│ 			K  => [KK]
//│ 			| N  => [NN]} c_₀(l¹) c_₀(r¹)]
//│ 		| L  => [LL]}
//│ def t_₀ = 
//│ 	[T [K] aa_₀ bb_₀]
//│ 	where
//│ 	def aa_₀ = 
//│ 		[T [N] [L] [L]]
//│ 	def bb_₀ = 
//│ 		[T [N] [L] [L]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 31 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [L]: 32 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [L]: 33 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [T [N] [L] [L]]: 34 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [K]: 50 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [T [K] aa_₀ bb_₀]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [N]: 54 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [L]: 55 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [L]: 56 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [T [N] [L] [L]]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 39 --->
//│ 	[N]: 31
//│ 	[K]: 50
//│ 	[N]: 54
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48 --->
//│ 	[L]: 32
//│ 	[L]: 33
//│ 	[T [N] [L] [L]]: 34
//│ 	[T [K] aa_₀ bb_₀]: 53
//│ 	[L]: 55
//│ 	[L]: 56
//│ 	[T [N] [L] [L]]: 57
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 31 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [L]: 32 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [L]: 33 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [T [N] [L] [L]]: 34 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [K]: 50 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [T [K] aa_₀ bb_₀]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [N]: 54 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 39
//│ [L]: 55 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [L]: 56 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ [T [N] [L] [L]]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 39 --->
//│ 	[N]: 31
//│ 	[K]: 50
//│ 	[N]: 54
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 48 --->
//│ 	[L]: 32
//│ 	[L]: 33
//│ 	[T [N] [L] [L]]: 34
//│ 	[T [K] aa_₀ bb_₀]: 53
//│ 	[L]: 55
//│ 	[L]: 56
//│ 	[T [N] [L] [L]]: 57
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(t_₀)
//│ def c_₀(x²) = 
//│ 	x²(99)
//│ def t_₀ = 
//│ 	let r³ = bb_₀
//│ 	in let l³ = aa_₀
//│ 	in let n³ = [KK]
//│ 	in (fun _lh_dummy³ -> [T n³ c_₀(l³) c_₀(r³)])
//│ 	where
//│ 	def aa_₀ = 
//│ 		let r⁴ = (fun _lh_dummy⁶ -> [LL])
//│ 		in let l⁴ = (fun _lh_dummy⁵ -> [LL])
//│ 		in let n⁴ = [NN]
//│ 		in (fun _lh_dummy⁴ -> [T n⁴ c_₀(l⁴) c_₀(r⁴)])
//│ 	def bb_₀ = 
//│ 		let r² = (fun _lh_dummy² -> [LL])
//│ 		in let l² = (fun _lh_dummy¹ -> [LL])
//│ 		in let n² = [NN]
//│ 		in (fun _lh_dummy⁰ -> [T n² c_₀(l²) c_₀(r²)])
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
fun map(ls) = if ls is
  C(h, t) then f => C(f(h), map(t)(f))
  N then f => N
let l = C(K, N)
map(l)(
  x => if x is
    K then T
)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#let| |l| |#=| |C|(|K|,| |N|)|↵|map|(|l|)|(|→|x| |=>| |#if| |x| |is|→|K| |#then| |T|←|←|↵|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, => if ls is ‹(C (h, t,)) then f, => C (f (h,), map (t,) (f,),); (N) then f, => N›; let l = C (K, N,); map (l,) (x, => if x is ‹(K) then T›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^19(l^20, (fun x⁰ -> case x⁰ of {
//│ 	K  => [T]}))
//│ def l = [C [K] [N]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map^5(t⁰, f⁰)])
//│ 	| N  => (fun f¹ -> [N])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [T] [N]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^20] (hopeless to continue)
//│ [map^19]
//│ 	[map^19 · map^5] ---> [map^19] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map_₀(l_₀, (fun x¹ -> case x¹ of {
//│ 	K  => [T]}))
//│ def l_₀ = 
//│ 	[C [K] [N]]
//│ def map_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => (fun f² -> [C f²(h¹) map_₀(t¹, f²)])
//│ 		| N  => (fun f³ -> [N])}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 27 --->
//│ 	case x¹ of {K  => [T]}: 50
//│ [N]: 28 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map_₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43
//│ [C [K] [N]]: 29 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map_₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map_₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43 --->
//│ 	[N]: 28
//│ 	[C [K] [N]]: 29
//│ case x¹ of {K  => [T]}: 50 --->
//│ 	DeadCodeProd
//│ 	[K]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 28 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map_₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43
//│ [C [K] [N]]: 29 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map_₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun f² -> [C f²(h¹) map_₀(t¹, f²)]) | N  => (fun f³ -> [N])}: 43 --->
//│ 	[N]: 28
//│ 	[C [K] [N]]: 29
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map_₀(l_₀, (fun x² -> case x² of {
//│ 	K  => [T]}))
//│ def l_₀ = 
//│ 	let t² = (fun f⁵ -> [N])
//│ 	in let h² = [K]
//│ 	in (fun f⁴ -> [C f⁴(h²) map_₀(t², f⁴)])
//│ def map_₀(ls²) = 
//│ 	ls²
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [T] [N]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
fun last(ys) = if ys is
  N then x => x
  C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
  N then None
  C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastDrive^22([C 1 [C 2 [N]]])
//│ def last(ys⁰) = case ys⁰ of {
//│ 	N  => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> last^4(t⁰, h⁰))}
//│ def lastDrive(xs⁰) = case xs⁰ of {
//│ 	N  => [None]
//│ 	| C hh⁰ tt⁰ => [Some last^14(tt⁰, hh⁰)]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [Some 2]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive^22]
//│ 	[lastDrive^22 · last^14]
//│ 		[lastDrive^22 · last^14 · last^4] ---> [lastDrive^22 · last^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastDrive_₀([C 1 [C 2 [N]]])
//│ def lastDrive_₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => [None]
//│ 		| C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}
//│ 	where
//│ 	def last_₀(ys¹) = 
//│ 		case ys¹ of {
//│ 			N  => (fun x² -> x²)
//│ 			| C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastDrive_₀(
//│ 	let tt² = 	
//│ 		let t² = (fun x⁵ -> x⁵)
//│ 		in let h² = 2
//│ 		in (fun x⁴ -> last_₀(t², h²))
//│ 	in let hh² = 1
//│ 	in (fun _lh_dummy⁰ -> [Some last_₀(tt², hh²)]))
//│ def lastDrive_₀(xs²) = 
//│ 	xs²(99)
//│ 	where
//│ 	def last_₀(ys²) = 
//│ 		ys²
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 2]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT: with expanding termination
let p = C(p)
fun c(x) = if C(x) is
  C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^10(p^11)
//│ def c(x⁰) = case [C x⁰] of {
//│ 	C a⁰ => c^5(a⁰)}
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^10]
//│ 	[c^10 · c^5] ---> [c^10] (only one)
//│ [p^11] (hopeless to continue)
//│ 	[p^11 · p^1] ---> [p^11] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x¹) = 
//│ 	case [C x¹] of {
//│ 		C a¹ => c_₀(a¹)}
//│ def p_₀ = 
//│ 	[C p_₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => c_₀(a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => c_₀(a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => c_₀(a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => c_₀(a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x²) = 
//│ 	
//│ 		let a² = x²
//│ 		in (fun _lh_dummy⁰ -> c_₀(a²))(99)
//│ def p_₀ = 
//│ 	[C p_₀]
//│ <<<<<<< after fusion <<<<<<<



// CORRECT: although multiple matches
// top level definitions as producers can be duplicated
fun c1(x1) = if x1 is
  A then AA
  B then BB
fun c2(x2) = if x2 is
  A then AAA
  B then BBB
let a = A
c1(a)
c2(a)
c2(B)
//│ |#fun| |c1|(|x1|)| |#=| |#if| |x1| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|#fun| |c2|(|x2|)| |#=| |#if| |x2| |is|→|A| |#then| |AAA|↵|B| |#then| |BBB|←|↵|#let| |a| |#=| |A|↵|c1|(|a|)|↵|c2|(|a|)|↵|c2|(|B|)|
//│ Parsed: {fun c1 = x1, => if x1 is ‹(A) then AA; (B) then BB›; fun c2 = x2, => if x2 is ‹(A) then AAA; (B) then BBB›; let a = A; c1 (a,); c2 (a,); c2 (B,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c1^12(a^13)
//│ c2^15(a^16)
//│ c2^18([B])
//│ def a = [A]
//│ def c1(x1⁰) = case x1⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def c2(x2⁰) = case x2⁰ of {
//│ 	A  => [AAA]
//│ 	| B  => [BBB]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [a^13] (hopeless to continue)
//│ [a^16] (hopeless to continue)
//│ [c1^12] (hopeless to continue)
//│ [c2^15] (hopeless to continue)
//│ [c2^18] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c1_₀(a_₀)
//│ c2_₀(a_₁)
//│ c2_₁([B])
//│ def a_₀ = 
//│ 	[A]
//│ def a_₁ = 
//│ 	[A]
//│ def c1_₀(x1¹) = 
//│ 	case x1¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def c2_₀(x2¹) = 
//│ 	case x2¹ of {
//│ 		A  => [AAA]
//│ 		| B  => [BBB]}
//│ def c2_₁(x2²) = 
//│ 	case x2² of {
//│ 		A  => [AAA]
//│ 		| B  => [BBB]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 21 --->
//│ 	case x1¹ of {A  => [AA] | B  => [BB]}: 25
//│ [A]: 27 --->
//│ 	case x2¹ of {A  => [AAA] | B  => [BBB]}: 31
//│ [B]: 45 --->
//│ 	case x2² of {A  => [AAA] | B  => [BBB]}: 36
//│ ------------------
//│ case x1¹ of {A  => [AA] | B  => [BB]}: 25 --->
//│ 	[A]: 21
//│ case x2¹ of {A  => [AAA] | B  => [BBB]}: 31 --->
//│ 	[A]: 27
//│ case x2² of {A  => [AAA] | B  => [BBB]}: 36 --->
//│ 	[B]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 21 --->
//│ 	case x1¹ of {A  => [AA] | B  => [BB]}: 25
//│ [A]: 27 --->
//│ 	case x2¹ of {A  => [AAA] | B  => [BBB]}: 31
//│ [B]: 45 --->
//│ 	case x2² of {A  => [AAA] | B  => [BBB]}: 36
//│ ------------------
//│ case x1¹ of {A  => [AA] | B  => [BB]}: 25 --->
//│ 	[A]: 21
//│ case x2¹ of {A  => [AAA] | B  => [BBB]}: 31 --->
//│ 	[A]: 27
//│ case x2² of {A  => [AAA] | B  => [BBB]}: 36 --->
//│ 	[B]: 45
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c1_₀(a_₀)
//│ c2_₀(a_₁)
//│ c2_₁([BBB])
//│ def a_₀ = 
//│ 	[AA]
//│ def a_₁ = 
//│ 	[AAA]
//│ def c1_₀(x1²) = 
//│ 	x1²
//│ def c2_₀(x2⁴) = 
//│ 	x2⁴
//│ def c2_₁(x2³) = 
//│ 	x2³
//│ <<<<<<< after fusion <<<<<<<





// CORRECT:
fun last(ys) = if ys is
  N then x => x
  C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
  N then None
  C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastDrive^22([C 1 [C 2 [N]]])
//│ def last(ys⁰) = case ys⁰ of {
//│ 	N  => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> last^4(t⁰, h⁰))}
//│ def lastDrive(xs⁰) = case xs⁰ of {
//│ 	N  => [None]
//│ 	| C hh⁰ tt⁰ => [Some last^14(tt⁰, hh⁰)]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive^22]
//│ 	[lastDrive^22 · last^14]
//│ 		[lastDrive^22 · last^14 · last^4] ---> [lastDrive^22 · last^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastDrive_₀([C 1 [C 2 [N]]])
//│ def lastDrive_₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => [None]
//│ 		| C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}
//│ 	where
//│ 	def last_₀(ys¹) = 
//│ 		case ys¹ of {
//│ 			N  => (fun x² -> x²)
//│ 			| C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N  => [None] | C hh¹ tt¹ => [Some last_₀(tt¹, hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N  => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> last_₀(t¹, h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastDrive_₀(
//│ 	let tt² = 	
//│ 		let t² = (fun x⁵ -> x⁵)
//│ 		in let h² = 2
//│ 		in (fun x⁴ -> last_₀(t², h²))
//│ 	in let hh² = 1
//│ 	in (fun _lh_dummy⁰ -> [Some last_₀(tt², hh²)]))
//│ def lastDrive_₀(xs²) = 
//│ 	xs²(99)
//│ 	where
//│ 	def last_₀(ys²) = 
//│ 		ys²
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: the time of unrolling is correct
fun id(k) = k
fun id1(x) = id(x)
fun id2(y) = y
fun id3(z) = z
let rec p = C(C(C(id7(C(C(id1(p)))))))
fun c(xx) = if xx is
  C(a) then c(a)
fun id4(k) = k
fun id5(j) = j
fun id6(l) = l
fun id7(i) = i
id6(id4)(c)(id5(id2)(id3(p)))
//│ |#fun| |id|(|k|)| |#=| |k|↵|#fun| |id1|(|x|)| |#=| |id|(|x|)|↵|#fun| |id2|(|y|)| |#=| |y|↵|#fun| |id3|(|z|)| |#=| |z|↵|#let| |#rec| |p| |#=| |C|(|C|(|C|(|id7|(|C|(|C|(|id1|(|p|)|)|)|)|)|)|)|↵|#fun| |c|(|xx|)| |#=| |#if| |xx| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id4|(|k|)| |#=| |k|↵|#fun| |id5|(|j|)| |#=| |j|↵|#fun| |id6|(|l|)| |#=| |l|↵|#fun| |id7|(|i|)| |#=| |i|↵|id6|(|id4|)|(|c|)|(|id5|(|id2|)|(|id3|(|p|)|)|)|
//│ Parsed: {fun id = k, => k; fun id1 = x, => id (x,); fun id2 = y, => y; fun id3 = z, => z; let rec p = C (C (C (id7 (C (C (id1 (p,),),),),),),); fun c = xx, => if xx is ‹(C (a,)) then c (a,)›; fun id4 = k, => k; fun id5 = j, => j; fun id6 = l, => l; fun id7 = i, => i; id6 (id4,) (c,) (id5 (id2,) (id3 (p,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ id6^35(id4^36, c^38, id5^40(id2^41, id3^43(p^44)))
//│ def c(xx⁰) = case xx⁰ of {
//│ 	C a⁰ => c^22(a⁰)}
//│ def id(k⁰) = k⁰
//│ def id1(x⁰) = id^3(x⁰)
//│ def id2(y⁰) = y⁰
//│ def id3(z⁰) = z⁰
//│ def id4(k¹) = k¹
//│ def id5(j⁰) = j⁰
//│ def id6(l⁰) = l⁰
//│ def id7(i⁰) = i⁰
//│ def p = [C [C [C id7^11([C [C id1^12(p^13)]])]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^38]
//│ 	[c^38 · c^22]
//│ 		[c^38 · c^22 · c^22]
//│ 			[c^38 · c^22 · c^22 · c^22]
//│ 				[c^38 · c^22 · c^22 · c^22 · c^22]
//│ 					[c^38 · c^22 · c^22 · c^22 · c^22 · c^22] ---> [c^38] (only one)
//│ [id2^41] (hopeless to continue)
//│ [id3^43] (hopeless to continue)
//│ [id4^36] (hopeless to continue)
//│ [id5^40] (hopeless to continue)
//│ [id6^35] (hopeless to continue)
//│ [p^44]
//│ 	[p^44 · id1^12] (hopeless to continue)
//│ 		[p^44 · id1^12 · id^3] (using original def)
//│ 	[p^44 · id7^11] (hopeless to continue)
//│ 	[p^44 · p^13] ---> [p^44] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ id6_₀(id4_₀, c_₀, id5_₀(id2_₀, id3_₀(p_₀)))
//│ def c_₀(xx⁴) = 
//│ 	case xx⁴ of {
//│ 		C a⁴ => c_₁(a⁴)}
//│ 	where
//│ 	def c_₁(xx¹) = 
//│ 		case xx¹ of {
//│ 			C a¹ => c_₂(a¹)}
//│ 		where
//│ 		def c_₂(xx⁵) = 
//│ 			case xx⁵ of {
//│ 				C a⁵ => c_₃(a⁵)}
//│ 			where
//│ 			def c_₃(xx²) = 
//│ 				case xx² of {
//│ 					C a² => c_₄(a²)}
//│ 				where
//│ 				def c_₄(xx³) = 
//│ 					case xx³ of {
//│ 						C a³ => c_₀(a³)}
//│ def id2_₀(y¹) = 
//│ 	y¹
//│ def id3_₀(z¹) = 
//│ 	z¹
//│ def id4_₀(k²) = 
//│ 	k²
//│ def id5_₀(j¹) = 
//│ 	j¹
//│ def id6_₀(l¹) = 
//│ 	l¹
//│ def p_₀ = 
//│ 	[C [C [C id7_₀([C [C id1_₀(p_₀)]])]]]
//│ 	where
//│ 	def id1_₀(x¹) = 
//│ 		id_₀(x¹)
//│ 		where
//│ 		def id_₀(k³) = 
//│ 			k³
//│ 	def id7_₀(i¹) = 
//│ 		i¹
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C id1_₀(p_₀)]: 98 --->
//│ 	case xx³ of {C a³ => c_₀(a³)}: 72
//│ [C [C id1_₀(p_₀)]]: 99 --->
//│ 	case xx² of {C a² => c_₄(a²)}: 58
//│ [C id7_₀([C [C id1_₀(p_₀)]])]: 101 --->
//│ 	case xx⁵ of {C a⁵ => c_₃(a⁵)}: 92
//│ [C [C id7_₀([C [C id1_₀(p_₀)]])]]: 102 --->
//│ 	case xx¹ of {C a¹ => c_₂(a¹)}: 52
//│ [C [C [C id7_₀([C [C id1_₀(p_₀)]])]]]: 103 --->
//│ 	case xx⁴ of {C a⁴ => c_₁(a⁴)}: 78
//│ ------------------
//│ case xx¹ of {C a¹ => c_₂(a¹)}: 52 --->
//│ 	[C [C id7_₀([C [C id1_₀(p_₀)]])]]: 102
//│ case xx² of {C a² => c_₄(a²)}: 58 --->
//│ 	[C [C id1_₀(p_₀)]]: 99
//│ case xx³ of {C a³ => c_₀(a³)}: 72 --->
//│ 	[C id1_₀(p_₀)]: 98
//│ case xx⁴ of {C a⁴ => c_₁(a⁴)}: 78 --->
//│ 	[C [C [C id7_₀([C [C id1_₀(p_₀)]])]]]: 103
//│ case xx⁵ of {C a⁵ => c_₃(a⁵)}: 92 --->
//│ 	[C id7_₀([C [C id1_₀(p_₀)]])]: 101
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C id1_₀(p_₀)]: 98 --->
//│ 	case xx³ of {C a³ => c_₀(a³)}: 72
//│ [C [C id1_₀(p_₀)]]: 99 --->
//│ 	case xx² of {C a² => c_₄(a²)}: 58
//│ [C id7_₀([C [C id1_₀(p_₀)]])]: 101 --->
//│ 	case xx⁵ of {C a⁵ => c_₃(a⁵)}: 92
//│ [C [C id7_₀([C [C id1_₀(p_₀)]])]]: 102 --->
//│ 	case xx¹ of {C a¹ => c_₂(a¹)}: 52
//│ [C [C [C id7_₀([C [C id1_₀(p_₀)]])]]]: 103 --->
//│ 	case xx⁴ of {C a⁴ => c_₁(a⁴)}: 78
//│ ------------------
//│ case xx¹ of {C a¹ => c_₂(a¹)}: 52 --->
//│ 	[C [C id7_₀([C [C id1_₀(p_₀)]])]]: 102
//│ case xx² of {C a² => c_₄(a²)}: 58 --->
//│ 	[C [C id1_₀(p_₀)]]: 99
//│ case xx³ of {C a³ => c_₀(a³)}: 72 --->
//│ 	[C id1_₀(p_₀)]: 98
//│ case xx⁴ of {C a⁴ => c_₁(a⁴)}: 78 --->
//│ 	[C [C [C id7_₀([C [C id1_₀(p_₀)]])]]]: 103
//│ case xx⁵ of {C a⁵ => c_₃(a⁵)}: 92 --->
//│ 	[C id7_₀([C [C id1_₀(p_₀)]])]: 101
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ id6_₀(id4_₀, c_₀, id5_₀(id2_₀, id3_₀(p_₀)))
//│ def c_₀(xx¹⁰) = 
//│ 	xx¹⁰(99)
//│ 	where
//│ 	def c_₁(xx⁷) = 
//│ 		xx⁷(99)
//│ 		where
//│ 		def c_₂(xx⁸) = 
//│ 			xx⁸(99)
//│ 			where
//│ 			def c_₃(xx⁹) = 
//│ 				xx⁹(99)
//│ 				where
//│ 				def c_₄(xx⁶) = 
//│ 					xx⁶(99)
//│ def id2_₀(y²) = 
//│ 	y²
//│ def id3_₀(z²) = 
//│ 	z²
//│ def id4_₀(k⁴) = 
//│ 	k⁴
//│ def id5_₀(j²) = 
//│ 	j²
//│ def id6_₀(l²) = 
//│ 	l²
//│ def p_₀ = 
//│ 	let a⁶ = 	
//│ 		let a⁷ = 	
//│ 			let a⁸ = id7_₀(
//│ 				let a⁹ = 	
//│ 					let a¹⁰ = id1_₀(p_₀)
//│ 					in (fun _lh_dummy⁴ -> c_₀(a¹⁰))
//│ 				in (fun _lh_dummy³ -> c_₄(a⁹)))
//│ 			in (fun _lh_dummy² -> c_₃(a⁸))
//│ 		in (fun _lh_dummy¹ -> c_₂(a⁷))
//│ 	in (fun _lh_dummy⁰ -> c_₁(a⁶))
//│ 	where
//│ 	def id1_₀(x²) = 
//│ 		id_₀(x²)
//│ 		where
//│ 		def id_₀(k⁵) = 
//│ 			k⁵
//│ 	def id7_₀(i²) = 
//│ 		i²
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
fun id(x) = if x is
  ID(b) then b
  C(a) then id(ID(C(a)))
let p = C(p)
fun c(y) = if y is
  C(aa) then c(aa)
c(id(p))
//│ |#fun| |id|(|x|)| |#=| |#if| |x| |is|→|ID|(|b|)| |#then| |b|↵|C|(|a|)| |#then| |id|(|ID|(|C|(|a|)|)|)|←|↵|#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |c|(|aa|)|←|↵|c|(|id|(|p|)|)|
//│ Parsed: {fun id = x, => if x is ‹(ID (b,)) then b; (C (a,)) then id (ID (C (a,),),)›; let p = C (p,); fun c = y, => if y is ‹(C (aa,)) then c (aa,)›; c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^18(id^19(p^20))
//│ def c(y⁰) = case y⁰ of {
//│ 	C aa⁰ => c^13(aa⁰)}
//│ def id(x⁰) = case x⁰ of {
//│ 	ID b⁰ => b⁰
//│ 	| C a⁰ => id^3([ID [C a⁰]])}
//│ def p = [C p^10]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^18] (hopeless to continue)
//│ 	[c^18 · c^13] ---> [c^18] (using original def)
//│ [id^19] (hopeless to continue)
//│ 	[id^19 · id^3] ---> [id^19] (using original def)
//│ [p^20] (hopeless to continue)
//│ 	[p^20 · p^10] ---> [p^20] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(id_₀(p_₀))
//│ def c_₀(y¹) = 
//│ 	case y¹ of {
//│ 		C aa¹ => c_₀(aa¹)}
//│ def id_₀(x¹) = 
//│ 	case x¹ of {
//│ 		ID b¹ => b¹
//│ 		| C a¹ => id_₀([ID [C a¹]])}
//│ def p_₀ = 
//│ 	[C p_₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p_₀]: 30 --->
//│ 	case y¹ of {C aa¹ => c_₀(aa¹)}: 27
//│ 	case x¹ of {ID b¹ => b¹ | C a¹ => id_₀([ID [C a¹]])}: 38
//│ [C a¹]: 35 --->
//│ 	case y¹ of {C aa¹ => c_₀(aa¹)}: 27
//│ [ID [C a¹]]: 36 --->
//│ 	case x¹ of {ID b¹ => b¹ | C a¹ => id_₀([ID [C a¹]])}: 38
//│ ------------------
//│ case y¹ of {C aa¹ => c_₀(aa¹)}: 27 --->
//│ 	[C p_₀]: 30
//│ 	[C a¹]: 35
//│ case x¹ of {ID b¹ => b¹ | C a¹ => id_₀([ID [C a¹]])}: 38 --->
//│ 	[C p_₀]: 30
//│ 	[ID [C a¹]]: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(id_₀(p_₀))
//│ def c_₀(y²) = 
//│ 	case y² of {
//│ 		C aa¹ => c_₀(aa¹)}
//│ def id_₀(x²) = 
//│ 	case x² of {
//│ 		ID b¹ => b¹
//│ 		| C a¹ => id_₀([ID [C a¹]])}
//│ def p_₀ = 
//│ 	[C p_₀]
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: unlike the rev rev case, TODO: why?
fun map(ls) = if ls is
  C(h, t) then C(
    (if h is
      A then AA
      B then BB
    ),
    map(t)
  )
  N then N
fun len(ls) = if ls is
  C(h, t) then 1 + len(t)
  N then 0
len(map(C(A, C(B, N))))
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#fun| |len|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |1| |+| |len|(|t|)|↵|N| |#then| |0|←|↵|len|(|map|(|C|(|A|,| |C|(|B|,| |N|)|)|)|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(A) then AA; (B) then BB›, ')', map (t,),); (N) then N›; fun len = ls, => if ls is ‹(C (h, t,)) then + (1,) (len (t,),); (N) then 0›; len (map (C (A, C (B, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ len^24(map^25([C [A] [C [B] [N]]]))
//│ def len(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => (1 + len^17(t¹))
//│ 	| N  => 0}
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C case h⁰ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]} map^6(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [len^24]
//│ 	[len^24 · len^17] ---> [len^24] (only one)
//│ [map^25]
//│ 	[map^25 · map^6] ---> [map^25] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ len_₀(map_₀([C [A] [C [B] [N]]]))
//│ def len_₀(ls³) = 
//│ 	case ls³ of {
//│ 		C h³ t³ => (1 + len_₀(t³))
//│ 		| N  => 0}
//│ def map_₀(ls²) = 
//│ 	case ls² of {
//│ 		C h² t² => [C case h² of {
//│ 			A  => [AA]
//│ 			| B  => [BB]} map_₀(t²)]
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)]: 41 --->
//│ 	case ls³ of {C h³ t³ => (1 + len_₀(t³)) | N  => 0}: 54
//│ [N]: 42 --->
//│ 	case ls³ of {C h³ t³ => (1 + len_₀(t³)) | N  => 0}: 54
//│ [A]: 58 --->
//│ 	case h² of {A  => [AA] | B  => [BB]}: 37
//│ [B]: 59 --->
//│ 	case h² of {A  => [AA] | B  => [BB]}: 37
//│ [N]: 60 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43
//│ [C [B] [N]]: 61 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43
//│ [C [A] [C [B] [N]]]: 62 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43
//│ ------------------
//│ case h² of {A  => [AA] | B  => [BB]}: 37 --->
//│ 	[A]: 58
//│ 	[B]: 59
//│ case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43 --->
//│ 	[N]: 60
//│ 	[C [B] [N]]: 61
//│ 	[C [A] [C [B] [N]]]: 62
//│ case ls³ of {C h³ t³ => (1 + len_₀(t³)) | N  => 0}: 54 --->
//│ 	[C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)]: 41
//│ 	[N]: 42
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)]: 41 --->
//│ 	case ls³ of {C h³ t³ => (1 + len_₀(t³)) | N  => 0}: 54
//│ [N]: 42 --->
//│ 	case ls³ of {C h³ t³ => (1 + len_₀(t³)) | N  => 0}: 54
//│ [A]: 58 --->
//│ 	case h² of {A  => [AA] | B  => [BB]}: 37
//│ [B]: 59 --->
//│ 	case h² of {A  => [AA] | B  => [BB]}: 37
//│ [N]: 60 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43
//│ [C [B] [N]]: 61 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43
//│ [C [A] [C [B] [N]]]: 62 --->
//│ 	case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43
//│ ------------------
//│ case h² of {A  => [AA] | B  => [BB]}: 37 --->
//│ 	[A]: 58
//│ 	[B]: 59
//│ case ls² of {C h² t² => [C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)] | N  => [N]}: 43 --->
//│ 	[N]: 60
//│ 	[C [B] [N]]: 61
//│ 	[C [A] [C [B] [N]]]: 62
//│ case ls³ of {C h³ t³ => (1 + len_₀(t³)) | N  => 0}: 54 --->
//│ 	[C case h² of {A  => [AA] | B  => [BB]} map_₀(t²)]: 41
//│ 	[N]: 42
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ len_₀(map_₀(
//│ 	let t⁴ = 	
//│ 		let t⁶ = (fun _lh_dummy⁵ -> (fun _lh_dummy⁴ -> 0))
//│ 		in let h⁵ = [BB]
//│ 		in (fun _lh_dummy³ -> 
//│ 			let t⁷ = map_₀(t⁶)
//│ 			in (fun _lh_dummy² -> (1 + len_₀(t⁷))))
//│ 	in let h⁴ = [AA]
//│ 	in (fun _lh_dummy¹ -> 
//│ 		let t⁵ = map_₀(t⁴)
//│ 		in (fun _lh_dummy⁰ -> (1 + len_₀(t⁵))))))
//│ def len_₀(ls⁵) = 
//│ 	ls⁵(99)
//│ def map_₀(ls⁴) = 
//│ 	ls⁴(99)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: multiple match, but correct
fun f(x) = if x is
  C(a) then f
f(C(A))(C(B))(C(D))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |f|←|↵|f|(|C|(|A|)|)|(|C|(|B|)|)|(|C|(|D|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then f›; f (C (A,),) (C (B,),) (C (D,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^5([C [A]], [C [B]], [C [D]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => f^2}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^5]
//│ 	[f^5 · f^2]
//│ 		[f^5 · f^2 · f^2]
//│ 			[f^5 · f^2 · f^2 · f^2]
//│ 				[f^5 · f^2 · f^2 · f^2 · f^2] ---> [f^5 · f^2 · f^2 · f^2] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([C [A]], [C [B]], [C [D]])
//│ def f_₀(x²) = 
//│ 	case x² of {
//│ 		C a² => f_₁}
//│ 	where
//│ 	def f_₁(x⁴) = 
//│ 		case x⁴ of {
//│ 			C a⁴ => f_₂}
//│ 		where
//│ 		def f_₂(x¹) = 
//│ 			case x¹ of {
//│ 				C a¹ => f_₃}
//│ 			where
//│ 			def f_₃(x³) = 
//│ 				case x³ of {
//│ 					C a³ => f_₃}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 33 --->
//│ 	case x² of {C a² => f_₁}: 21
//│ [C [B]]: 36 --->
//│ 	case x⁴ of {C a⁴ => f_₂}: 29
//│ [C [D]]: 39 --->
//│ 	case x¹ of {C a¹ => f_₃}: 17
//│ ------------------
//│ case x¹ of {C a¹ => f_₃}: 17 --->
//│ 	[C [D]]: 39
//│ case x² of {C a² => f_₁}: 21 --->
//│ 	[C [A]]: 33
//│ case x⁴ of {C a⁴ => f_₂}: 29 --->
//│ 	[C [B]]: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [A]]: 33 --->
//│ 	case x² of {C a² => f_₁}: 21
//│ [C [B]]: 36 --->
//│ 	case x⁴ of {C a⁴ => f_₂}: 29
//│ [C [D]]: 39 --->
//│ 	case x¹ of {C a¹ => f_₃}: 17
//│ ------------------
//│ case x¹ of {C a¹ => f_₃}: 17 --->
//│ 	[C [D]]: 39
//│ case x² of {C a² => f_₁}: 21 --->
//│ 	[C [A]]: 33
//│ case x⁴ of {C a⁴ => f_₂}: 29 --->
//│ 	[C [B]]: 36
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀(f_₁, f_₂, f_₃)
//│ def f_₀(x⁶) = 
//│ 	x⁶
//│ 	where
//│ 	def f_₁(x⁸) = 
//│ 		x⁸
//│ 		where
//│ 		def f_₂(x⁵) = 
//│ 			x⁵
//│ 			where
//│ 			def f_₃(x⁷) = 
//│ 				case x⁷ of {
//│ 					C a³ => f_₃}
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
let aa = T(N, t, t)
let t = T(K, aa, aa)
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |t|,| |t|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |aa|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, t, t,); let t = T (K, aa, aa,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^24(t^25)
//│ def aa = [T [N] t^2 t^3]
//│ def c(x⁰) = case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K  => [KK]
//│ 		| N  => [NN]} c^14(l⁰) c^17(r⁰)]
//│ 	| L  => [LL]}
//│ def t = [T [K] aa^6 aa^7]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^24]
//│ 	[c^24 · c^14] ---> [c^24] (only one)
//│ 	[c^24 · c^17] ---> [c^24] (only one)
//│ [t^25]
//│ 	[t^25 · aa^6] (hopeless to continue)
//│ 		[t^25 · aa^6 · t^2] (using original def)
//│ 			[t^25 · aa^6 · t^2 · aa^6] ---> [t^25 · aa^6] (using original def)
//│ 			[t^25 · aa^6 · t^2 · aa^7] ---> [t^25 · aa^6] (using original def)
//│ 		[t^25 · aa^6 · t^3] (using original def)
//│ 			[t^25 · aa^6 · t^3 · aa^6] ---> [t^25 · aa^6] (using original def)
//│ 			[t^25 · aa^6 · t^3 · aa^7] ---> [t^25 · aa^6] (using original def)
//│ 	[t^25 · aa^7]
//│ 		[t^25 · aa^7 · t^2] ---> [t^25] (only one)
//│ 		[t^25 · aa^7 · t^3] ---> [t^25] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(t_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		T n¹ l¹ r¹ => [T case n¹ of {
//│ 			K  => [KK]
//│ 			| N  => [NN]} c_₀(l¹) c_₀(r¹)]
//│ 		| L  => [LL]}
//│ def t_₀ = 
//│ 	[T [K] aa_₀ aa_₁]
//│ 	where
//│ 	def aa_₀ = 
//│ 		[T [N] t_₁ t_₂]
//│ 		where
//│ 		def t_₁ = 
//│ 			[T [K] aa_₀ aa_₀]
//│ 		def t_₂ = 
//│ 			[T [K] aa_₀ aa_₀]
//│ 	def aa_₁ = 
//│ 		[T [N] t_₀ t_₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 42 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [N] t_₀ t_₀]: 45 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ [K]: 46 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [K] aa_₀ aa_₀]: 49 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ [K]: 50 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [K] aa_₀ aa_₀]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ [K]: 54 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [K] aa_₀ aa_₁]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ [N]: 58 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [N] t_₁ t_₂]: 61 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 31 --->
//│ 	[N]: 42
//│ 	[K]: 46
//│ 	[K]: 50
//│ 	[K]: 54
//│ 	[N]: 58
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40 --->
//│ 	[T [N] t_₀ t_₀]: 45
//│ 	[T [K] aa_₀ aa_₀]: 49
//│ 	[T [K] aa_₀ aa_₀]: 53
//│ 	[T [K] aa_₀ aa_₁]: 57
//│ 	[T [N] t_₁ t_₂]: 61
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 42 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [N] t_₀ t_₀]: 45 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ [K]: 46 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [K] aa_₀ aa_₀]: 49 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ [K]: 50 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [K] aa_₀ aa_₀]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ [K]: 54 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [K] aa_₀ aa_₁]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ [N]: 58 --->
//│ 	case n¹ of {K  => [KK] | N  => [NN]}: 31
//│ [T [N] t_₁ t_₂]: 61 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40
//│ ------------------
//│ case n¹ of {K  => [KK] | N  => [NN]}: 31 --->
//│ 	[N]: 42
//│ 	[K]: 46
//│ 	[K]: 50
//│ 	[K]: 54
//│ 	[N]: 58
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K  => [KK] | N  => [NN]} c_₀(l¹) c_₀(r¹)] | L  => [LL]}: 40 --->
//│ 	[T [N] t_₀ t_₀]: 45
//│ 	[T [K] aa_₀ aa_₀]: 49
//│ 	[T [K] aa_₀ aa_₀]: 53
//│ 	[T [K] aa_₀ aa_₁]: 57
//│ 	[T [N] t_₁ t_₂]: 61
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(t_₀)
//│ def c_₀(x²) = 
//│ 	x²(99)
//│ def t_₀ = 
//│ 	let r⁴ = aa_₁
//│ 	in let l⁴ = aa_₀
//│ 	in let n⁴ = [KK]
//│ 	in (fun _lh_dummy² -> [T n⁴ c_₀(l⁴) c_₀(r⁴)])
//│ 	where
//│ 	def aa_₀ = 
//│ 		let r² = t_₂
//│ 		in let l² = t_₁
//│ 		in let n² = [NN]
//│ 		in (fun _lh_dummy⁰ -> [T n² c_₀(l²) c_₀(r²)])
//│ 		where
//│ 		def t_₁ = 
//│ 			let r⁶ = aa_₀
//│ 			in let l⁶ = aa_₀
//│ 			in let n⁶ = [KK]
//│ 			in (fun _lh_dummy⁴ -> [T n⁶ c_₀(l⁶) c_₀(r⁶)])
//│ 		def t_₂ = 
//│ 			let r⁵ = aa_₀
//│ 			in let l⁵ = aa_₀
//│ 			in let n⁵ = [KK]
//│ 			in (fun _lh_dummy³ -> [T n⁵ c_₀(l⁵) c_₀(r⁵)])
//│ 	def aa_₁ = 
//│ 		let r³ = t_₀
//│ 		in let l³ = t_₀
//│ 		in let n³ = [NN]
//│ 		in (fun _lh_dummy¹ -> [T n³ c_₀(l³) c_₀(r³)])
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: but explode on branches
fun filter(ls) = if ls is
  C(h, t) then if h > 1 is
    True then C(h, filter(t))
    False then filter(t)
  N then N
filter(C(1, C(2, C(3, N))))
//│ |#fun| |filter|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |>| |1| |is|→|True| |#then| |C|(|h|,| |filter|(|t|)|)|↵|False| |#then| |filter|(|t|)|←|↵|N| |#then| |N|←|↵|filter|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {fun filter = ls, => if ls is ‹(C (h, t,)) then if > (h,) (1,) is ‹(True) then C (h, filter (t,),); (False) then filter (t,)›; (N) then N›; filter (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ filter^19([C 1 [C 2 [C 3 [N]]]])
//│ def filter(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case (h⁰ > 1) of {
//│ 		True  => [C h⁰ filter^8(t⁰)]
//│ 		| False  => filter^12(t⁰)}
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [filter^19]
//│ 	[filter^19 · filter^12] ---> [filter^19] (only one)
//│ 	[filter^19 · filter^8] ---> [filter^19] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ filter_₀([C 1 [C 2 [C 3 [N]]]])
//│ def filter_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => case (h¹ > 1) of {
//│ 			True  => [C h¹ filter_₀(t¹)]
//│ 			| False  => filter_₀(t¹)}
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 50 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ [C 3 [N]]: 51 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ [C 2 [C 3 [N]]]: 52 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ [C 1 [C 2 [C 3 [N]]]]: 53 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44 --->
//│ 	[N]: 50
//│ 	[C 3 [N]]: 51
//│ 	[C 2 [C 3 [N]]]: 52
//│ 	[C 1 [C 2 [C 3 [N]]]]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 50 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ [C 3 [N]]: 51 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ [C 2 [C 3 [N]]]: 52 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ [C 1 [C 2 [C 3 [N]]]]: 53 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True  => [C h¹ filter_₀(t¹)] | False  => filter_₀(t¹)} | N  => [N]}: 44 --->
//│ 	[N]: 50
//│ 	[C 3 [N]]: 51
//│ 	[C 2 [C 3 [N]]]: 52
//│ 	[C 1 [C 2 [C 3 [N]]]]: 53
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ filter_₀(
//│ 	let t² = 	
//│ 		let t³ = 	
//│ 			let t⁴ = (fun _lh_dummy³ -> [N])
//│ 			in let h⁴ = 3
//│ 			in (fun _lh_dummy² -> case (h⁴ > 1) of {
//│ 				True  => [C h⁴ filter_₀(t⁴)]
//│ 				| False  => filter_₀(t⁴)})
//│ 		in let h³ = 2
//│ 		in (fun _lh_dummy¹ -> case (h³ > 1) of {
//│ 			True  => [C h³ filter_₀(t³)]
//│ 			| False  => filter_₀(t³)})
//│ 	in let h² = 1
//│ 	in (fun _lh_dummy⁰ -> case (h² > 1) of {
//│ 		True  => [C h² filter_₀(t²)]
//│ 		| False  => filter_₀(t²)}))
//│ def filter_₀(ls²) = 
//│ 	ls²(99)
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: top level defs used multiple times are fine
// but top level producers used multiple times may result in duplicated computation
let p = C(p)
let pp = C(C(pp))
fun c(x) = if x is
  C(a) then if a is
    C(b) then c(b)
    N then a
  N then x
P(c(pp), c(p))
//│ |#let| |p| |#=| |C|(|p|)|↵|#let| |pp| |#=| |C|(|C|(|pp|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |c|(|b|)|↵|N| |#then| |a|←|↵|N| |#then| |x|←|↵|P|(|c|(|pp|)|,| |c|(|p|)|)|
//│ Parsed: {let p = C (p,); let pp = C (C (pp,),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then c (b,); (N) then a›; (N) then x›; P (c (pp,), c (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ [P c^16(pp^17) c^19(p^20)]
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => c^8(b⁰)
//│ 		| N  => a⁰}
//│ 	| N  => x⁰}
//│ def p = [C p^1]
//│ def pp = [C [C pp^3]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^16]
//│ 	[c^16 · c^8] ---> [c^16] (only one)
//│ [c^19]
//│ 	[c^19 · c^8] ---> [c^19] (only one)
//│ [p^20]
//│ 	[p^20 · p^1]
//│ 		[p^20 · p^1 · p^1] ---> [p^20 · p^1] ([p · p] OR [p])
//│ [pp^17]
//│ 	[pp^17 · pp^3] ---> [pp^17] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ [P c_₀(pp_₀) c_₁(p_₀)]
//│ def c_₀(x²) = 
//│ 	case x² of {
//│ 		C a² => case a² of {
//│ 			C b² => c_₀(b²)
//│ 			| N  => a²}
//│ 		| N  => x²}
//│ def c_₁(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => case a¹ of {
//│ 			C b¹ => c_₁(b¹)
//│ 			| N  => a¹}
//│ 		| N  => x¹}
//│ def p_₀ = 
//│ 	[C p_₁]
//│ 	where
//│ 	def p_₁ = 
//│ 		[C p_₁]
//│ def pp_₀ = 
//│ 	[C [C pp_₀]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C pp_₀]: 24 --->
//│ 	NoCons
//│ 	case a² of {C b² => c_₀(b²) | N  => a²}: 46
//│ [C [C pp_₀]]: 25 --->
//│ 	NoCons
//│ 	case x² of {C a² => case a² of {C b² => c_₀(b²) | N  => a²} | N  => x²}: 48
//│ [C p_₁]: 37 --->
//│ 	NoCons
//│ 	case a¹ of {C b¹ => c_₁(b¹) | N  => a¹}: 32
//│ 	case x¹ of {C a¹ => case a¹ of {C b¹ => c_₁(b¹) | N  => a¹} | N  => x¹}: 34
//│ [C p_₁]: 39 --->
//│ 	NoCons
//│ 	case x¹ of {C a¹ => case a¹ of {C b¹ => c_₁(b¹) | N  => a¹} | N  => x¹}: 34
//│ ------------------
//│ case a¹ of {C b¹ => c_₁(b¹) | N  => a¹}: 32 --->
//│ 	[C p_₁]: 37
//│ case x¹ of {C a¹ => case a¹ of {C b¹ => c_₁(b¹) | N  => a¹} | N  => x¹}: 34 --->
//│ 	[C p_₁]: 37
//│ 	[C p_₁]: 39
//│ case a² of {C b² => c_₀(b²) | N  => a²}: 46 --->
//│ 	[C pp_₀]: 24
//│ case x² of {C a² => case a² of {C b² => c_₀(b²) | N  => a²} | N  => x²}: 48 --->
//│ 	[C [C pp_₀]]: 25
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ [P c_₀(pp_₀) c_₁(p_₀)]
//│ def c_₀(x⁴) = 
//│ 	case x⁴ of {
//│ 		C a² => case a² of {
//│ 			C b² => c_₀(b²)
//│ 			| N  => a²}
//│ 		| N  => x⁴}
//│ def c_₁(x³) = 
//│ 	case x³ of {
//│ 		C a¹ => case a¹ of {
//│ 			C b¹ => c_₁(b¹)
//│ 			| N  => a¹}
//│ 		| N  => x³}
//│ def p_₀ = 
//│ 	[C p_₁]
//│ 	where
//│ 	def p_₁ = 
//│ 		[C p_₁]
//│ def pp_₀ = 
//│ 	[C [C pp_₀]]
//│ <<<<<<< after fusion <<<<<<<


// CORRECT:
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  N then a => a
  C(h, t) then a => rev(t, C(h, a))
fun rev2(ls2) = if ls2 is
  N then a2 => a2
  C(h2, t2) then a2 => rev2(t2, C(h2, a2))
rev2(rev(C(1, C(2, N)))(N))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a| |=>| |a|↵|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|,| |C|(|h|,| |a|)|)|←|↵|#fun| |rev2|(|ls2|)| |#=| |#if| |ls2| |is|→|N| |#then| |a2| |=>| |a2|↵|C|(|h2|,| |t2|)| |#then| |a2| |=>| |rev2|(|t2|,| |C|(|h2|,| |a2|)|)|←|↵|rev2|(|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|N|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(N) then a, => a; (C (h, t,)) then a, => rev (t, C (h, a,),)›; fun rev2 = ls2, => if ls2 is ‹(N) then a2, => a2; (C (h2, t2,)) then a2, => rev2 (t2, C (h2, a2,),)›; rev2 (rev (C (1, C (2, N,),),) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev2^27(rev^28([C 1 [C 2 [N]]], [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	N  => (fun a⁰ -> a⁰)
//│ 	| C h⁰ t⁰ => (fun a¹ -> rev^4(t⁰, [C h⁰ a¹]))}
//│ def rev2(ls2⁰) = case ls2⁰ of {
//│ 	N  => (fun a2⁰ -> a2⁰)
//│ 	| C h2⁰ t2⁰ => (fun a2¹ -> rev2^17(t2⁰, [C h2⁰ a2¹]))}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev2^27] (hopeless to continue)
//│ 	[rev2^27 · rev2^17] ---> [rev2^27] (using original def)
//│ [rev^28]
//│ 	[rev^28 · rev^4] ---> [rev^28] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev2_₀(rev_₀([C 1 [C 2 [N]]], [N]), [N])
//│ def rev2_₀(ls2¹) = 
//│ 	case ls2¹ of {
//│ 		N  => (fun a2² -> a2²)
//│ 		| C h2¹ t2¹ => (fun a2³ -> rev2_₀(t2¹, [C h2¹ a2³]))}
//│ def rev_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		N  => (fun a² -> a²)
//│ 		| C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ a³]: 61 --->
//│ 	case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2_₀(t2¹, [C h2¹ a2³]))}: 51
//│ [N]: 70 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64
//│ [C 2 [N]]: 71 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64
//│ [C 1 [C 2 [N]]]: 72 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64
//│ [N]: 74 --->
//│ 	case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2_₀(t2¹, [C h2¹ a2³]))}: 51
//│ ------------------
//│ case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2_₀(t2¹, [C h2¹ a2³]))}: 51 --->
//│ 	[C h¹ a³]: 61
//│ 	[N]: 74
//│ case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64 --->
//│ 	[N]: 70
//│ 	[C 2 [N]]: 71
//│ 	[C 1 [C 2 [N]]]: 72
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a³]: 61 --->
//│ 	case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2_₀(t2¹, [C h2¹ a2³]))}: 51
//│ [N]: 70 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64
//│ [C 2 [N]]: 71 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64
//│ [C 1 [C 2 [N]]]: 72 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64
//│ [N]: 74 --->
//│ 	case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2_₀(t2¹, [C h2¹ a2³]))}: 51
//│ ------------------
//│ case ls2¹ of {N  => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> rev2_₀(t2¹, [C h2¹ a2³]))}: 51 --->
//│ 	[C h¹ a³]: 61
//│ 	[N]: 74
//│ case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 64 --->
//│ 	[N]: 70
//│ 	[C 2 [N]]: 71
//│ 	[C 1 [C 2 [N]]]: 72
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev2_₀(rev_₀(
//│ 	let t² = 	
//│ 		let t³ = (fun a⁶ -> a⁶)
//│ 		in let h³ = 2
//│ 		in (fun a⁵ -> rev_₀(t³, 
//│ 			let t2³ = a⁵
//│ 			in let h2³ = h³
//│ 			in (fun a2⁵ -> rev2_₀(t2³, [C h2³ a2⁵]))))
//│ 	in let h² = 1
//│ 	in (fun a⁴ -> rev_₀(t², 
//│ 		let t2² = a⁴
//│ 		in let h2² = h²
//│ 		in (fun a2⁴ -> rev2_₀(t2², [C h2² a2⁴])))), (fun a2⁶ -> a2⁶)), [N])
//│ def rev2_₀(ls2²) = 
//│ 	ls2²
//│ def rev_₀(ls²) = 
//│ 	ls²
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [N]]]
//│ <<<<<<< evaluate <<<<<<<


// CORRECT: rev actually works (despite the fact that there are some match clash),
// and duplicated usage of toplevel things are alright
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
rev(C(A, C(B, N)))(N)
rev(rev(C(A, C(B, N)))(N))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|rev|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|N|)|↵|rev|(|rev|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|N|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; rev (C (A, C (B, N,),),) (N,); rev (rev (C (A, C (B, N,),),) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^14([C [A] [C [B] [N]]], [N])
//│ rev^23(rev^24([C [A] [C [B] [N]]], [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev^2(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [B] [C [A] [N]]]
//│ [C [A] [C [B] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14]
//│ 	[rev^14 · rev^2] ---> [rev^14] (only one)
//│ [rev^23]
//│ 	[rev^23 · rev^2] ---> [rev^23] (only one)
//│ [rev^24]
//│ 	[rev^24 · rev^2] ---> [rev^24] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀([C [A] [C [B] [N]]], [N])
//│ rev_₁(rev_₂([C [A] [C [B] [N]]], [N]), [N])
//│ def rev_₀(ls²) = 
//│ 	case ls² of {
//│ 		C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴]))
//│ 		| N  => (fun a⁵ -> a⁵)}
//│ def rev_₁(ls³) = 
//│ 	case ls³ of {
//│ 		C h³ t³ => (fun a⁶ -> rev_₁(t³, [C h³ a⁶]))
//│ 		| N  => (fun a⁷ -> a⁷)}
//│ def rev_₂(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²]))
//│ 		| N  => (fun a³ -> a³)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ a²]: 42 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> rev_₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73
//│ [N]: 78 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [C [B] [N]]: 79 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [C [A] [C [B] [N]]]: 80 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [N]: 88 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [C [B] [N]]: 89 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [C [A] [C [B] [N]]]: 90 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [N]: 92 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> rev_₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47 --->
//│ 	[N]: 88
//│ 	[C [B] [N]]: 89
//│ 	[C [A] [C [B] [N]]]: 90
//│ case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60 --->
//│ 	[N]: 78
//│ 	[C [B] [N]]: 79
//│ 	[C [A] [C [B] [N]]]: 80
//│ case ls³ of {C h³ t³ => (fun a⁶ -> rev_₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73 --->
//│ 	[C h¹ a²]: 42
//│ 	[N]: 92
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a²]: 42 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> rev_₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73
//│ [N]: 78 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [C [B] [N]]: 79 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [C [A] [C [B] [N]]]: 80 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60
//│ [N]: 88 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [C [B] [N]]: 89 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [C [A] [C [B] [N]]]: 90 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47
//│ [N]: 92 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> rev_₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> rev_₂(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 47 --->
//│ 	[N]: 88
//│ 	[C [B] [N]]: 89
//│ 	[C [A] [C [B] [N]]]: 90
//│ case ls² of {C h² t² => (fun a⁴ -> rev_₀(t², [C h² a⁴])) | N  => (fun a⁵ -> a⁵)}: 60 --->
//│ 	[N]: 78
//│ 	[C [B] [N]]: 79
//│ 	[C [A] [C [B] [N]]]: 80
//│ case ls³ of {C h³ t³ => (fun a⁶ -> rev_₁(t³, [C h³ a⁶])) | N  => (fun a⁷ -> a⁷)}: 73 --->
//│ 	[C h¹ a²]: 42
//│ 	[N]: 92
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(
//│ 	let t⁴ = 	
//│ 		let t⁵ = (fun a¹⁰ -> a¹⁰)
//│ 		in let h⁵ = [B]
//│ 		in (fun a⁹ -> rev_₀(t⁵, [C h⁵ a⁹]))
//│ 	in let h⁴ = [A]
//│ 	in (fun a⁸ -> rev_₀(t⁴, [C h⁴ a⁸])), [N])
//│ rev_₁(rev_₂(
//│ 	let t⁶ = 	
//│ 		let t⁸ = (fun a¹⁵ -> a¹⁵)
//│ 		in let h⁸ = [B]
//│ 		in (fun a¹³ -> rev_₂(t⁸, 
//│ 			let t⁹ = a¹³
//│ 			in let h⁹ = h⁸
//│ 			in (fun a¹⁴ -> rev_₁(t⁹, [C h⁹ a¹⁴]))))
//│ 	in let h⁶ = [A]
//│ 	in (fun a¹¹ -> rev_₂(t⁶, 
//│ 		let t⁷ = a¹¹
//│ 		in let h⁷ = h⁶
//│ 		in (fun a¹² -> rev_₁(t⁷, [C h⁷ a¹²])))), (fun a¹⁶ -> a¹⁶)), [N])
//│ def rev_₀(ls⁵) = 
//│ 	ls⁵
//│ def rev_₁(ls⁶) = 
//│ 	ls⁶
//│ def rev_₂(ls⁴) = 
//│ 	ls⁴
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [B] [C [A] [N]]]
//│ [C [A] [C [B] [N]]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT: using primitive is also correct
fun rev(ls) = if ls is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
rev(rev(primitive)(N))(N)
//│ |#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|rev|(|rev|(|primitive|)|(|N|)|)|(|N|)|
//│ Parsed: {fun rev = ls, => if ls is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; rev (rev (primitive,) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^14(rev^15(primitive⁰, [N]), [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev^2(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14]
//│ 	[rev^14 · rev^2] ---> [rev^14] (only one)
//│ [rev^15]
//│ 	[rev^15 · rev^2] ---> [rev^15] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀(rev_₁(primitive⁰, [N]), [N])
//│ def rev_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²]))
//│ 		| N  => (fun a³ -> a³)}
//│ def rev_₁(ls²) = 
//│ 	case ls² of {
//│ 		C h² t² => (fun a⁴ -> rev_₁(t², [C h² a⁴]))
//│ 		| N  => (fun a⁵ -> a⁵)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h² a⁴]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ [N]: 53 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34 --->
//│ 	[C h² a⁴]: 42
//│ 	[N]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h² a⁴]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ [N]: 53 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 34 --->
//│ 	[C h² a⁴]: 42
//│ 	[N]: 53
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(rev_₁(primitive⁰, (fun a⁶ -> a⁶)), [N])
//│ def rev_₀(ls³) = 
//│ 	ls³
//│ def rev_₁(ls⁴) = 
//│ 	case ls⁴ of {
//│ 		C h² t² => (fun a⁷ -> rev_₁(t², 
//│ 			let t³ = a⁷
//│ 			in let h³ = h²
//│ 			in (fun a⁸ -> rev_₀(t³, [C h³ a⁸]))))
//│ 		| N  => (fun a⁹ -> a⁹)}
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: even normal rev can be optimized?
// NOTE: may be only out of luck: we choose 
_LUMBERHACK_EVAL
fun concat(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(C(1, C(2, N)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^27([C 1 [C 2 [N]]])
//│ def concat(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat^5(t⁰, ys¹)])}
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^15(rev^16(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^27]
//│ 	[rev^27 · concat^15]
//│ 		[rev^27 · concat^15 · concat^5] ---> [rev^27 · concat^15] (only one)
//│ 	[rev^27 · rev^16] ---> [rev^27] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀([C 1 [C 2 [N]]])
//│ def rev_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]])
//│ 		| N  => [N]}
//│ 	where
//│ 	def concat_₀(xs¹) = 
//│ 		case xs¹ of {
//│ 			N  => (fun ys² -> ys²)
//│ 			| C h² t² => (fun ys³ -> [C h² concat_₀(t², ys³)])}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h² concat_₀(t², ys³)]: 43 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat_₀(t², ys³)])}: 45
//│ [N]: 54 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat_₀(t², ys³)])}: 45
//│ [C h³ [N]]: 55 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat_₀(t², ys³)])}: 45
//│ [N]: 57 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat_₀(t², ys³)])}: 45
//│ [N]: 63 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ [C 2 [N]]: 64 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ [C 1 [C 2 [N]]]: 65 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² concat_₀(t², ys³)])}: 45 --->
//│ 	[C h² concat_₀(t², ys³)]: 43
//│ 	[N]: 54
//│ 	[C h³ [N]]: 55
//│ 	[N]: 57
//│ case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58 --->
//│ 	[N]: 63
//│ 	[C 2 [N]]: 64
//│ 	[C 1 [C 2 [N]]]: 65
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 63 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ [C 2 [N]]: 64 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ [C 1 [C 2 [N]]]: 65 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58
//│ ------------------
//│ case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 58 --->
//│ 	[N]: 63
//│ 	[C 2 [N]]: 64
//│ 	[C 1 [C 2 [N]]]: 65
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(
//│ 	let t⁴ = 	
//│ 		let t⁵ = (fun _lh_dummy² -> [N])
//│ 		in let h⁵ = 2
//│ 		in (fun _lh_dummy¹ -> concat_₀(rev_₀(t⁵), [C h⁵ [N]]))
//│ 	in let h⁴ = 1
//│ 	in (fun _lh_dummy⁰ -> concat_₀(rev_₀(t⁴), [C h⁴ [N]])))
//│ def rev_₀(ls²) = 
//│ 	ls²(99)
//│ 	where
//│ 	def concat_₀(xs²) = 
//│ 		case xs² of {
//│ 			N  => (fun ys⁴ -> ys⁴)
//│ 			| C h² t² => (fun ys⁵ -> [C h² concat_₀(t², ys⁵)])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [concat_₀^18]
//│ 	[concat_₀^18 · concat_₀^35] ---> [concat_₀^18] (only one)
//│ [concat_₀^5]
//│ 	[concat_₀^5 · concat_₀^35] ---> [concat_₀^5] (only one)
//│ [rev_₀^19] (hopeless to continue)
//│ [rev_₀^1] (hopeless to continue)
//│ [rev_₀^6] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀_₁(
//│ 	let t⁵ = 	
//│ 		let t⁶ = (fun _lh_dummy³ -> [N])
//│ 		in let h⁵ = 2
//│ 		in (fun _lh_dummy⁴ -> concat_₀_₁(rev_₀_₂(t⁶), [C h⁵ [N]]))
//│ 	in let h⁶ = 1
//│ 	in (fun _lh_dummy⁵ -> concat_₀_₀(rev_₀_₀(t⁵), [C h⁶ [N]])))
//│ def concat_₀_₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => (fun ys² -> ys²)
//│ 		| C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}
//│ def concat_₀_₁(xs²) = 
//│ 	case xs² of {
//│ 		N  => (fun ys⁴ -> ys⁴)
//│ 		| C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ concat_₀_₁(t⁴, ys⁵)])}
//│ def rev_₀_₀(ls¹) = 
//│ 	ls¹(99)
//│ def rev_₀_₁(ls²) = 
//│ 	ls²(99)
//│ def rev_₀_₂(ls³) = 
//│ 	ls³(99)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁴ concat_₀_₁(t⁴, ys⁵)]: 70 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59
//│ [N]: 87 --->
//│ 	case xs² of {N  => (fun ys⁴ -> ys⁴) | C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ concat_₀_₁(t⁴, ys⁵)])}: 72
//│ [N]: 96 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59
//│ [C h⁵ [N]]: 97 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59 --->
//│ 	[C h⁴ concat_₀_₁(t⁴, ys⁵)]: 70
//│ 	[N]: 96
//│ 	[C h⁵ [N]]: 97
//│ case xs² of {N  => (fun ys⁴ -> ys⁴) | C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ concat_₀_₁(t⁴, ys⁵)])}: 72 --->
//│ 	DeadCodeProd
//│ 	[N]: 87
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h⁴ concat_₀_₁(t⁴, ys⁵)]: 70 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59
//│ [N]: 96 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59
//│ [C h⁵ [N]]: 97 --->
//│ 	case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59
//│ ------------------
//│ case xs¹ of {N  => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ concat_₀_₀(t³, ys³)])}: 59 --->
//│ 	[C h⁴ concat_₀_₁(t⁴, ys⁵)]: 70
//│ 	[N]: 96
//│ 	[C h⁵ [N]]: 97
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀_₁(
//│ 	let t⁷ = 	
//│ 		let t⁸ = (fun _lh_dummy⁶ -> [N])
//│ 		in let h⁷ = 2
//│ 		in (fun _lh_dummy⁷ -> concat_₀_₁(rev_₀_₂(t⁸), 
//│ 			let t⁹ = (fun ys⁷ -> ys⁷)
//│ 			in let h⁸ = h⁷
//│ 			in (fun ys⁶ -> [C h⁸ concat_₀_₀(t⁹, ys⁶)])))
//│ 	in let h⁹ = 1
//│ 	in (fun _lh_dummy⁸ -> concat_₀_₀(rev_₀_₀(t⁷), [C h⁹ [N]])))
//│ def concat_₀_₀(xs⁴) = 
//│ 	xs⁴
//│ def concat_₀_₁(xs³) = 
//│ 	case xs³ of {
//│ 		N  => (fun ys⁸ -> ys⁸)
//│ 		| C h⁴ t⁴ => (fun ys⁹ -> 
//│ 			let t¹⁰ = concat_₀_₁(t⁴, ys⁹)
//│ 			in let h¹⁰ = h⁴
//│ 			in (fun ys¹⁰ -> [C h¹⁰ concat_₀_₀(t¹⁰, ys¹⁰)]))}
//│ def rev_₀_₀(ls⁴) = 
//│ 	ls⁴(99)
//│ def rev_₀_₁(ls⁵) = 
//│ 	ls⁵(99)
//│ def rev_₀_₂(ls⁶) = 
//│ 	ls⁶(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<


// CORRECT: but will be WRONG: if strategy-filtering is strict, since y is a destination of [C 1 N]
fun f(x) = if A(x) is
  A(y) then if x is
    C(h, t) then t
f(C(1, N))
//│ |#fun| |f|(|x|)| |#=| |#if| |A|(|x|)| |is|→|A|(|y|)| |#then| |#if| |x| |is|→|C|(|h|,| |t|)| |#then| |t|←|←|↵|f|(|C|(|1|,| |N|)|)|
//│ Parsed: {fun f = x, => if A (x,) is ‹(A (y,)) then if x is ‹(C (h, t,)) then t››; f (C (1, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^8([C 1 [N]])
//│ def f(x⁰) = case [A x⁰] of {
//│ 	A y⁰ => case x⁰ of {
//│ 		C h⁰ t⁰ => t⁰}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^8] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([C 1 [N]])
//│ def f_₀(x¹) = 
//│ 	case [A x¹] of {
//│ 		A y¹ => case x¹ of {
//│ 			C h¹ t¹ => t¹}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A x¹]: 14 --->
//│ 	case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18
//│ [C 1 [N]]: 23 --->
//│ 	DeadCodeCons
//│ 	case x¹ of {C h¹ t¹ => t¹}: 17
//│ ------------------
//│ case x¹ of {C h¹ t¹ => t¹}: 17 --->
//│ 	[C 1 [N]]: 23
//│ case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18 --->
//│ 	[A x¹]: 14
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A x¹]: 14 --->
//│ 	case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18
//│ ------------------
//│ case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18 --->
//│ 	[A x¹]: 14
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀([C 1 [N]])
//│ def f_₀(x²) = 
//│ 	(fun x³ -> case x³ of {
//│ 		C h¹ t¹ => t¹})(x²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f_₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀_₀([C 1 [N]])
//│ def f_₀_₀(x²) = 
//│ 	(fun x³ -> case x³ of {
//│ 		C h¹ t¹ => t¹})(x²)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 23 --->
//│ 	case x³ of {C h¹ t¹ => t¹}: 15
//│ ------------------
//│ case x³ of {C h¹ t¹ => t¹}: 15 --->
//│ 	[C 1 [N]]: 23
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 [N]]: 23 --->
//│ 	case x³ of {C h¹ t¹ => t¹}: 15
//│ ------------------
//│ case x³ of {C h¹ t¹ => t¹}: 15 --->
//│ 	[C 1 [N]]: 23
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀_₀(
//│ 	let t² = [N]
//│ 	in t²)
//│ def f_₀_₀(x⁴) = 
//│ 	(fun x⁵ -> x⁵)(x⁴)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: after using `last(C(hh, tt))` instead of `last(t)` and pushing in of parameters
_LUMBERHACK_EVAL
fun last(ls) = if ls is
  C(h, t) then
    (
      if t is
        N then h => Some(h)
        C(hh, tt) then h => last(C(hh, tt))
    )(h)
  N then None
last(C(1, C(2, C(3, N))))
//│ |_LUMBERHACK_EVAL|↵|#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then|→|(|→|#if| |t| |is|→|N| |#then| |h| |=>| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |h| |=>| |last|(|C|(|hh|,| |tt|)|)|←|←|↵|)|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun last = ls, => if ls is ‹(C (h, t,)) then {'(' if t is ‹(N) then h, => Some (h,); (C (hh, tt,)) then h, => last (C (hh, tt,),)›, ')' (h,)}; (N) then None›; last (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ last^18([C 1 [C 2 [C 3 [N]]]])
//│ def last(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N  => (fun h¹ -> [Some h¹])
//│ 		| C hh⁰ tt⁰ => (fun h² -> last^6([C hh⁰ tt⁰]))}(h⁰)
//│ 	| N  => [None]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [Some 3]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^18]
//│ 	[last^18 · last^6] ---> [last^18] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ last_₀([C 1 [C 2 [C 3 [N]]]])
//│ def last_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h³ t¹ => case t¹ of {
//│ 			N  => (fun h⁴ -> [Some h⁴])
//│ 			| C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}(h³)
//│ 		| N  => [None]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 35 --->
//│ 	case ls¹ of {C h³ t¹ => case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}(h³) | N  => [None]}: 42
//│ [N]: 48 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38
//│ [C 3 [N]]: 49 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38
//│ [C 2 [C 3 [N]]]: 50 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38
//│ [C 1 [C 2 [C 3 [N]]]]: 51 --->
//│ 	case ls¹ of {C h³ t¹ => case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}(h³) | N  => [None]}: 42
//│ ------------------
//│ case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38 --->
//│ 	[N]: 48
//│ 	[C 3 [N]]: 49
//│ 	[C 2 [C 3 [N]]]: 50
//│ case ls¹ of {C h³ t¹ => case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}(h³) | N  => [None]}: 42 --->
//│ 	[C hh¹ tt¹]: 35
//│ 	[C 1 [C 2 [C 3 [N]]]]: 51
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 48 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38
//│ [C 3 [N]]: 49 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38
//│ [C 2 [C 3 [N]]]: 50 --->
//│ 	case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38
//│ ------------------
//│ case t¹ of {N  => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> last_₀([C hh¹ tt¹]))}: 38 --->
//│ 	[N]: 48
//│ 	[C 3 [N]]: 49
//│ 	[C 2 [C 3 [N]]]: 50
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ last_₀([C 1 
//│ 	let tt² = 	
//│ 		let tt³ = (fun h⁸ -> [Some h⁸])
//│ 		in let hh³ = 3
//│ 		in (fun h⁷ -> last_₀([C hh³ tt³]))
//│ 	in let hh² = 2
//│ 	in (fun h⁶ -> last_₀([C hh² tt²]))])
//│ def last_₀(ls²) = 
//│ 	case ls² of {
//│ 		C h³ t¹ => t¹(h³)
//│ 		| N  => [None]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 3]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last_₀^16] (hopeless to continue)
//│ [last_₀^1] (hopeless to continue)
//│ [last_₀^7] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ last_₀_₁([C 1 
//│ 	let tt² = 	
//│ 		let tt³ = (fun h⁷ -> [Some h⁷])
//│ 		in let hh² = 3
//│ 		in (fun h⁸ -> last_₀_₂([C hh² tt³]))
//│ 	in let hh³ = 2
//│ 	in (fun h⁹ -> last_₀_₀([C hh³ tt²]))])
//│ def last_₀_₀(ls³) = 
//│ 	case ls³ of {
//│ 		C h⁶ t³ => t³(h⁶)
//│ 		| N  => [None]}
//│ def last_₀_₁(ls²) = 
//│ 	case ls² of {
//│ 		C h⁵ t² => t²(h⁵)
//│ 		| N  => [None]}
//│ def last_₀_₂(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h⁴ t¹ => t¹(h⁴)
//│ 		| N  => [None]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh² tt³]: 63 --->
//│ 	case ls¹ of {C h⁴ t¹ => t¹(h⁴) | N  => [None]}: 38
//│ [C hh³ tt²]: 72 --->
//│ 	case ls³ of {C h⁶ t³ => t³(h⁶) | N  => [None]}: 52
//│ [C 1 let tt² = let tt³ = (fun h⁷ -> [Some h⁷])
//│ in let hh² = 3
//│ in (fun h⁸ -> last_₀_₂([C hh² tt³]))
//│ in let hh³ = 2
//│ in (fun h⁹ -> last_₀_₀([C hh³ tt²]))]: 77 --->
//│ 	case ls² of {C h⁵ t² => t²(h⁵) | N  => [None]}: 45
//│ ------------------
//│ case ls¹ of {C h⁴ t¹ => t¹(h⁴) | N  => [None]}: 38 --->
//│ 	[C hh² tt³]: 63
//│ case ls² of {C h⁵ t² => t²(h⁵) | N  => [None]}: 45 --->
//│ 	[C 1 let tt² = let tt³ = (fun h⁷ -> [Some h⁷])
//│ in let hh² = 3
//│ in (fun h⁸ -> last_₀_₂([C hh² tt³]))
//│ in let hh³ = 2
//│ in (fun h⁹ -> last_₀_₀([C hh³ tt²]))]: 77
//│ case ls³ of {C h⁶ t³ => t³(h⁶) | N  => [None]}: 52 --->
//│ 	[C hh³ tt²]: 72
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C hh² tt³]: 63 --->
//│ 	case ls¹ of {C h⁴ t¹ => t¹(h⁴) | N  => [None]}: 38
//│ [C hh³ tt²]: 72 --->
//│ 	case ls³ of {C h⁶ t³ => t³(h⁶) | N  => [None]}: 52
//│ [C 1 let tt² = let tt³ = (fun h⁷ -> [Some h⁷])
//│ in let hh² = 3
//│ in (fun h⁸ -> last_₀_₂([C hh² tt³]))
//│ in let hh³ = 2
//│ in (fun h⁹ -> last_₀_₀([C hh³ tt²]))]: 77 --->
//│ 	case ls² of {C h⁵ t² => t²(h⁵) | N  => [None]}: 45
//│ ------------------
//│ case ls¹ of {C h⁴ t¹ => t¹(h⁴) | N  => [None]}: 38 --->
//│ 	[C hh² tt³]: 63
//│ case ls² of {C h⁵ t² => t²(h⁵) | N  => [None]}: 45 --->
//│ 	[C 1 let tt² = let tt³ = (fun h⁷ -> [Some h⁷])
//│ in let hh² = 3
//│ in (fun h⁸ -> last_₀_₂([C hh² tt³]))
//│ in let hh³ = 2
//│ in (fun h⁹ -> last_₀_₀([C hh³ tt²]))]: 77
//│ case ls³ of {C h⁶ t³ => t³(h⁶) | N  => [None]}: 52 --->
//│ 	[C hh³ tt²]: 72
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ last_₀_₁(
//│ 	let t⁴ = 	
//│ 		let tt⁴ = 	
//│ 			let tt⁵ = (fun h¹¹ -> [Some h¹¹])
//│ 			in let hh⁴ = 3
//│ 			in (fun h¹² -> last_₀_₂(
//│ 				let t⁵ = tt⁵
//│ 				in let h¹³ = hh⁴
//│ 				in (fun _lh_dummy¹ -> t⁵(h¹³))))
//│ 		in let hh⁵ = 2
//│ 		in (fun h¹⁴ -> last_₀_₀(
//│ 			let t⁶ = tt⁴
//│ 			in let h¹⁵ = hh⁵
//│ 			in (fun _lh_dummy² -> t⁶(h¹⁵))))
//│ 	in let h¹⁰ = 1
//│ 	in (fun _lh_dummy⁰ -> t⁴(h¹⁰)))
//│ def last_₀_₀(ls⁶) = 
//│ 	ls⁶(99)
//│ def last_₀_₁(ls⁵) = 
//│ 	ls⁵(99)
//│ def last_₀_₂(ls⁴) = 
//│ 	ls⁴(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 3]
//│ <<<<<<< evaluate <<<<<<<


fun f(x) = if primitive(x) then A(x) else B(x + 1)
fun g(scrut, y) = if scrut is
  A(n) then y + n + 1
  B(m) then y + m
g(f(1), 2)
//│ |#fun| |f|(|x|)| |#=| |#if| |primitive|(|x|)| |#then| |A|(|x|)| |#else| |B|(|x| |+| |1|)|↵|#fun| |g|(|scrut|,| |y|)| |#=| |#if| |scrut| |is|→|A|(|n|)| |#then| |y| |+| |n| |+| |1|↵|B|(|m|)| |#then| |y| |+| |m|←|↵|g|(|f|(|1|)|,| |2|)|
//│ Parsed: {fun f = x, => if (primitive (x,)) then A (x,) else B (+ (x,) (1,),); fun g = scrut, y, => if scrut is ‹(A (n,)) then + (+ (y,) (n,),) (1,); (B (m,)) then + (y,) (m,)›; g (f (1,), 2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ g^32(f^33(1), 2)
//│ def f(x⁰) = if primitive⁰(x⁰) then [A x⁰] else [B (x⁰ + 1)]
//│ def g(scrut⁰, y⁰) = case scrut⁰ of {
//│ 	A n⁰ => ((y⁰ + n⁰) + 1)
//│ 	| B m⁰ => (y⁰ + m⁰)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^33] (hopeless to continue)
//│ [g^32] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ g_₀(f_₀(1), 2)
//│ def f_₀(x¹) = 
//│ 	if primitive⁰(x¹) then [A x¹] else [B (x¹ + 1)]
//│ def g_₀(scrut¹, y¹) = 
//│ 	case scrut¹ of {
//│ 		A n¹ => ((y¹ + n¹) + 1)
//│ 		| B m¹ => (y¹ + m¹)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A x¹]: 61 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ [B (x¹ + 1)]: 67 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ ------------------
//│ case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54 --->
//│ 	[A x¹]: 61
//│ 	[B (x¹ + 1)]: 67
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A x¹]: 61 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ [B (x¹ + 1)]: 67 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ ------------------
//│ case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54 --->
//│ 	[A x¹]: 61
//│ 	[B (x¹ + 1)]: 67
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ g_₀(f_₀(1), 2)
//│ def f_₀(x²) = 
//│ 	if primitive⁰(x²) then 
//│ 		let n² = x²
//│ 		in (fun y³ -> ((y³ + n²) + 1)) else 
//│ 		let m² = (x² + 1)
//│ 		in (fun y⁴ -> (y⁴ + m²))
//│ def g_₀(scrut², y²) = 
//│ 	scrut²(y²)
//│ <<<<<<< after fusion <<<<<<<


:lhInHaskell
ack m n = case m of
          Z -> S n
          S m' -> case n of
                    Z -> ack m' (S Z)
                    S n' -> ack m' (ack m n')
ack (S (S (S Z))) (S (S Z))
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ack_₀^672([S [S [S [Z]]]], [S [S [Z]]])
//│ def ack_₀(_lh_ack_arg1¹, _lh_ack_arg2¹) = 
//│ 	let _lh_matchIdent² = _lh_ack_arg1¹
//│ 	in case _lh_matchIdent² of {
//│ 		Z  => [S _lh_ack_arg2¹]
//│ 		| S _lh_ack_S_0² => 
//│ 			let _lh_matchIdent³ = _lh_ack_arg2¹
//│ 			in case _lh_matchIdent³ of {
//│ 				Z  => ack_₀^649(_lh_ack_S_0², [S [Z]])
//│ 				| S _lh_ack_S_0³ => ack_₀^655(_lh_ack_S_0², ack_₀^658(_lh_ack_arg1¹, _lh_ack_S_0³))
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ack_₀^672]
//│ 	[ack_₀^672 · ack_₀^649] (hopeless to continue)
//│ 		[ack_₀^672 · ack_₀^649 · ack_₀^649] ---> [ack_₀^672 · ack_₀^649] (using original def)
//│ 		[ack_₀^672 · ack_₀^649 · ack_₀^655] ---> [ack_₀^672 · ack_₀^649] (using original def)
//│ 		[ack_₀^672 · ack_₀^649 · ack_₀^658] ---> [ack_₀^672 · ack_₀^649] (using original def)
//│ 	[ack_₀^672 · ack_₀^655] ---> [ack_₀^672] (only one)
//│ 	[ack_₀^672 · ack_₀^658] ---> [ack_₀^672] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ack_₀_₀([S [S [S [Z]]]], [S [S [Z]]])
//│ def ack_₀_₀(_lh_ack_arg1², _lh_ack_arg2²) = 
//│ 	let _lh_matchIdent⁴ = _lh_ack_arg1²
//│ 	in case _lh_matchIdent⁴ of {
//│ 		Z  => [S _lh_ack_arg2²]
//│ 		| S _lh_ack_S_0⁴ => 
//│ 			let _lh_matchIdent⁵ = _lh_ack_arg2²
//│ 			in case _lh_matchIdent⁵ of {
//│ 				Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]])
//│ 				| S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵))
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ 	where
//│ 	def ack_₀_₁(_lh_ack_arg1¹, _lh_ack_arg2¹) = 
//│ 		let _lh_matchIdent² = _lh_ack_arg1¹
//│ 		in case _lh_matchIdent² of {
//│ 			Z  => [S _lh_ack_arg2¹]
//│ 			| S _lh_ack_S_0² => 
//│ 				let _lh_matchIdent³ = _lh_ack_arg2¹
//│ 				in case _lh_matchIdent³ of {
//│ 					Z  => ack_₀_₁(_lh_ack_S_0², [S [Z]])
//│ 					| S _lh_ack_S_0³ => ack_₀_₁(_lh_ack_S_0², ack_₀_₁(_lh_ack_arg1¹, _lh_ack_S_0³))
//│ 					| _  => error⁰}
//│ 			| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S _lh_ack_arg2¹]: 43 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack_₀_₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_₀_₁(_lh_ack_S_0², ack_₀_₁(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ 	case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91
//│ [Z]: 49 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack_₀_₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_₀_₁(_lh_ack_S_0², ack_₀_₁(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ 	case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91
//│ [S [Z]]: 50 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack_₀_₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_₀_₁(_lh_ack_S_0², ack_₀_₁(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ 	case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91
//│ [S _lh_ack_arg2²]: 72 --->
//│ 	NoCons
//│ 	case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91
//│ [Z]: 78 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack_₀_₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_₀_₁(_lh_ack_S_0², ack_₀_₁(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ 	case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91
//│ [S [Z]]: 79 --->
//│ 	NoCons
//│ 	case _lh_matchIdent³ of {Z  => ack_₀_₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_₀_₁(_lh_ack_S_0², ack_₀_₁(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62
//│ 	case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91
//│ [Z]: 99 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack_₀_₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_₀_₁(_lh_ack_S_0², ack_₀_₁(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ 	case _lh_matchIdent⁴ of {Z  => [S _lh_ack_arg2²] | S _lh_ack_S_0⁴ => let _lh_matchIdent⁵ = _lh_ack_arg2²
//│ in case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰} | _  => error⁰}: 94
//│ [S [Z]]: 100 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack_₀_₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_₀_₁(_lh_ack_S_0², ack_₀_₁(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ 	case _lh_matchIdent⁴ of {Z  => [S _lh_ack_arg2²] | S _lh_ack_S_0⁴ => let _lh_matchIdent⁵ = _lh_ack_arg2²
//│ in case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰} | _  => error⁰}: 94
//│ [S [S [Z]]]: 101 --->
//│ 	case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack_₀_₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_₀_₁(_lh_ack_S_0², ack_₀_₁(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65
//│ 	case _lh_matchIdent⁴ of {Z  => [S _lh_ack_arg2²] | S _lh_ack_S_0⁴ => let _lh_matchIdent⁵ = _lh_ack_arg2²
//│ in case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰} | _  => error⁰}: 94
//│ [S [S [S [Z]]]]: 102 --->
//│ 	case _lh_matchIdent⁴ of {Z  => [S _lh_ack_arg2²] | S _lh_ack_S_0⁴ => let _lh_matchIdent⁵ = _lh_ack_arg2²
//│ in case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰} | _  => error⁰}: 94
//│ [Z]: 104 --->
//│ 	NoCons
//│ 	case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91
//│ [S [Z]]: 105 --->
//│ 	NoCons
//│ 	case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91
//│ [S [S [Z]]]: 106 --->
//│ 	NoCons
//│ 	case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91
//│ ------------------
//│ case _lh_matchIdent³ of {Z  => ack_₀_₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_₀_₁(_lh_ack_S_0², ack_₀_₁(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰}: 62 --->
//│ 	[S _lh_ack_arg2¹]: 43
//│ 	[Z]: 49
//│ 	[S [Z]]: 50
//│ 	[Z]: 78
//│ 	[S [Z]]: 79
//│ case _lh_matchIdent² of {Z  => [S _lh_ack_arg2¹] | S _lh_ack_S_0² => let _lh_matchIdent³ = _lh_ack_arg2¹
//│ in case _lh_matchIdent³ of {Z  => ack_₀_₁(_lh_ack_S_0², [S [Z]]) | S _lh_ack_S_0³ => ack_₀_₁(_lh_ack_S_0², ack_₀_₁(_lh_ack_arg1¹, _lh_ack_S_0³)) | _  => error⁰} | _  => error⁰}: 65 --->
//│ 	[Z]: 99
//│ 	[S [Z]]: 100
//│ 	[S [S [Z]]]: 101
//│ case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰}: 91 --->
//│ 	[S _lh_ack_arg2¹]: 43
//│ 	[Z]: 49
//│ 	[S [Z]]: 50
//│ 	[S _lh_ack_arg2²]: 72
//│ 	[Z]: 78
//│ 	[S [Z]]: 79
//│ 	[Z]: 104
//│ 	[S [Z]]: 105
//│ 	[S [S [Z]]]: 106
//│ case _lh_matchIdent⁴ of {Z  => [S _lh_ack_arg2²] | S _lh_ack_S_0⁴ => let _lh_matchIdent⁵ = _lh_ack_arg2²
//│ in case _lh_matchIdent⁵ of {Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]]) | S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1², _lh_ack_S_0⁵)) | _  => error⁰} | _  => error⁰}: 94 --->
//│ 	[Z]: 99
//│ 	[S [Z]]: 100
//│ 	[S [S [Z]]]: 101
//│ 	[S [S [S [Z]]]]: 102
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ack_₀_₀([S [S [S [Z]]]], [S [S [Z]]])
//│ def ack_₀_₀(_lh_ack_arg1⁴, _lh_ack_arg2⁴) = 
//│ 	let _lh_matchIdent⁸ = _lh_ack_arg1⁴
//│ 	in case _lh_matchIdent⁸ of {
//│ 		Z  => [S _lh_ack_arg2⁴]
//│ 		| S _lh_ack_S_0⁴ => 
//│ 			let _lh_matchIdent⁹ = _lh_ack_arg2⁴
//│ 			in case _lh_matchIdent⁹ of {
//│ 				Z  => ack_₀_₁(_lh_ack_S_0⁴, [S [Z]])
//│ 				| S _lh_ack_S_0⁵ => ack_₀_₀(_lh_ack_S_0⁴, ack_₀_₀(_lh_ack_arg1⁴, _lh_ack_S_0⁵))
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ 	where
//│ 	def ack_₀_₁(_lh_ack_arg1³, _lh_ack_arg2³) = 
//│ 		let _lh_matchIdent⁶ = _lh_ack_arg1³
//│ 		in case _lh_matchIdent⁶ of {
//│ 			Z  => [S _lh_ack_arg2³]
//│ 			| S _lh_ack_S_0² => 
//│ 				let _lh_matchIdent⁷ = _lh_ack_arg2³
//│ 				in case _lh_matchIdent⁷ of {
//│ 					Z  => ack_₀_₁(_lh_ack_S_0², [S [Z]])
//│ 					| S _lh_ack_S_0³ => ack_₀_₁(_lh_ack_S_0², ack_₀_₁(_lh_ack_arg1³, _lh_ack_S_0³))
//│ 					| _  => error⁰}
//│ 			| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<

:lhInHaskell
:lhEval
test n = foldl (\a b -> a + b) 0 [1..n]
test $ primId 10
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ test_₀^682(primId⁰(10))
//│ def enumFromTo_₀(a⁷, b⁴) = if (a⁷ <= b⁴) then [LH_C a⁷ enumFromTo_₀^668((a⁷ + 1), b⁴)] else [LH_N]
//│ def foldl_₀(f¹², i³, ls¹⁹) = case ls¹⁹ of {
//│ 	LH_C h²⁰ t²² => foldl_₀^646(f¹², f¹²(i³, h²⁰), t²²)
//│ 	| LH_N  => i³}
//│ def test_₀(_lh_test_arg1¹) = foldl_₀^627((fun a⁶ -> (fun b³ -> (a⁶ + b³))), 0, enumFromTo_₀^638(1, _lh_test_arg1¹))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 55
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [test_₀^682] (hopeless to continue)
//│ 	[test_₀^682 · enumFromTo_₀^638] (using original def)
//│ 		[test_₀^682 · enumFromTo_₀^638 · enumFromTo_₀^668] ---> [test_₀^682 · enumFromTo_₀^638] (using original def)
//│ 	[test_₀^682 · foldl_₀^627] (using original def)
//│ 		[test_₀^682 · foldl_₀^627 · foldl_₀^646] ---> [test_₀^682 · foldl_₀^627] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ test_₀_₀(primId⁰(10))
//│ def test_₀_₀(_lh_test_arg1¹) = 
//│ 	foldl_₀_₀((fun a³ -> (fun b³ -> (a³ + b³))), 0, enumFromTo_₀_₀(1, _lh_test_arg1¹))
//│ 	where
//│ 	def enumFromTo_₀_₀(a², b²) = 
//│ 		if (a² <= b²) then [LH_C a² enumFromTo_₀_₀((a² + 1), b²)] else [LH_N]
//│ 	def foldl_₀_₀(f¹, i¹, ls¹) = 
//│ 		case ls¹ of {
//│ 			LH_C h¹ t¹ => foldl_₀_₀(f¹, f¹(i¹, h¹), t¹)
//│ 			| LH_N  => i¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a² enumFromTo_₀_₀((a² + 1), b²)]: 76 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_₀_₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 112
//│ [LH_N]: 77 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_₀_₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 112
//│ ------------------
//│ case ls¹ of {LH_C h¹ t¹ => foldl_₀_₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 112 --->
//│ 	[LH_C a² enumFromTo_₀_₀((a² + 1), b²)]: 76
//│ 	[LH_N]: 77
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a² enumFromTo_₀_₀((a² + 1), b²)]: 76 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_₀_₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 112
//│ [LH_N]: 77 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_₀_₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 112
//│ ------------------
//│ case ls¹ of {LH_C h¹ t¹ => foldl_₀_₀(f¹, f¹(i¹, h¹), t¹) | LH_N  => i¹}: 112 --->
//│ 	[LH_C a² enumFromTo_₀_₀((a² + 1), b²)]: 76
//│ 	[LH_N]: 77
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ test_₀_₀(primId⁰(10))
//│ def test_₀_₀(_lh_test_arg1²) = 
//│ 	foldl_₀_₀((fun a⁵ -> (fun b⁵ -> (a⁵ + b⁵))), 0, enumFromTo_₀_₀(1, _lh_test_arg1²))
//│ 	where
//│ 	def enumFromTo_₀_₀(a⁴, b⁴) = 
//│ 		if (a⁴ <= b⁴) then 
//│ 			let t² = enumFromTo_₀_₀((a⁴ + 1), b⁴)
//│ 			in let h² = a⁴
//│ 			in (fun f² -> (fun i² -> foldl_₀_₀(f², f²(i², h²), t²))) else (fun f³ -> (fun i³ -> i³))
//│ 	def foldl_₀_₀(f⁴, i⁴, ls²) = 
//│ 		ls²(f⁴, i⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 55
//│ <<<<<<< evaluate <<<<<<<

:lhInHaskell
:lhEval
:lhGenDistill
test n = sum $ zipWith (\a b -> a * b) (primId [1..n]) (primId [n..(2*n)])
test $ primId 10
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ test_₀^746(primId⁰(10))
//│ def enumFromTo_₀(a⁶, b³) = if (a⁶ <= b³) then [LH_C a⁶ enumFromTo_₀^647((a⁶ + 1), b³)] else [LH_N]
//│ def enumFromTo_₁(a⁸, b⁵) = if (a⁸ <= b⁵) then [LH_C a⁸ enumFromTo_₁^732((a⁸ + 1), b⁵)] else [LH_N]
//│ def sum_₀(ls¹⁹) = case ls¹⁹ of {
//│ 	LH_C h²⁰ t²² => (h²⁰ + sum_₀^697(t²²))
//│ 	| LH_N  => 0}
//│ def test_₀(_lh_test_arg1¹) = sum_₀^661(zipWith_₀^662((fun a⁷ -> (fun b⁴ -> (a⁷ * b⁴))), primId⁰(enumFromTo_₀^672(1, _lh_test_arg1¹)), primId⁰(enumFromTo_₁^680(_lh_test_arg1¹, (2 * _lh_test_arg1¹)))))
//│ def zipWith_₀(f¹², xs⁹, ys⁹) = case xs⁹ of {
//│ 	LH_C hx⁸ tx⁸ => case ys⁹ of {
//│ 		LH_C hy⁸ ty⁸ => [LH_C f¹²(hx⁸, hy⁸) zipWith_₀^711(f¹², tx⁸, ty⁸)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized distiller gen ----------
//│ 		main = (test__d0 10);
//│ 		enumFromTo__d0 a_6 b_3 =
//│ 		  (case (le a_6 b_3) of True -> ((LH_C(a_6, ((enumFromTo__d0 (plus a_6 1)) b_3)))) | False -> ((LH_N)));
//│ 		enumFromTo__d1 a_8 b_5 =
//│ 		  (case (le a_8 b_5) of True -> ((LH_C(a_8, ((enumFromTo__d1 (plus a_8 1)) b_5)))) | False -> ((LH_N)));
//│ 		sum__d0 ls_1_9 =
//│ 		  (case ls_1_9 of LH_C(h_2_0, t_2_2) -> (plus h_2_0 (sum__d0 t_2_2)) | LH_N -> 0);
//│ 		test__d0 _lh_test_arg1_1 =
//│ 		  (sum__d0 (((zipWith__d0 (\a_7 b_4 -> (mul a_7 b_4))) ((enumFromTo__d0 1) _lh_test_arg1_1)) ((enumFromTo__d1 _lh_test_arg1_1) (mul 2 _lh_test_arg1_1))));
//│ 		zipWith__d0 f_1_2 xs_9 ys_9 =
//│ 		  (case xs_9 of LH_C(hx_8, tx_8) -> (case ys_9 of LH_C(hy_8, ty_8) -> (LH_C(((f_1_2 hx_8) hy_8), (((zipWith__d0 f_1_2) tx_8) ty_8))) | LH_N -> (LH_N)) | LH_N -> (LH_N))
//│ 		---------- unoptimized distiller gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 880
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [test_₀^746] (hopeless to continue)
//│ 	[test_₀^746 · enumFromTo_₀^672] (using original def)
//│ 		[test_₀^746 · enumFromTo_₀^672 · enumFromTo_₀^647] ---> [test_₀^746 · enumFromTo_₀^672] (using original def)
//│ 	[test_₀^746 · enumFromTo_₁^680] (using original def)
//│ 		[test_₀^746 · enumFromTo_₁^680 · enumFromTo_₁^732] ---> [test_₀^746 · enumFromTo_₁^680] (using original def)
//│ 	[test_₀^746 · sum_₀^661] (using original def)
//│ 		[test_₀^746 · sum_₀^661 · sum_₀^697] ---> [test_₀^746 · sum_₀^661] (using original def)
//│ 	[test_₀^746 · zipWith_₀^662] (using original def)
//│ 		[test_₀^746 · zipWith_₀^662 · zipWith_₀^711] ---> [test_₀^746 · zipWith_₀^662] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ test_₀_₀(primId⁰(10))
//│ def test_₀_₀(_lh_test_arg1¹) = 
//│ 	sum_₀_₀(zipWith_₀_₀((fun a⁵ -> (fun b⁵ -> (a⁵ * b⁵))), primId⁰(enumFromTo_₀_₀(1, _lh_test_arg1¹)), primId⁰(enumFromTo_₁_₀(_lh_test_arg1¹, (2 * _lh_test_arg1¹)))))
//│ 	where
//│ 	def enumFromTo_₀_₀(a³, b³) = 
//│ 		if (a³ <= b³) then [LH_C a³ enumFromTo_₀_₀((a³ + 1), b³)] else [LH_N]
//│ 	def enumFromTo_₁_₀(a⁴, b⁴) = 
//│ 		if (a⁴ <= b⁴) then [LH_C a⁴ enumFromTo_₁_₀((a⁴ + 1), b⁴)] else [LH_N]
//│ 	def sum_₀_₀(ls¹) = 
//│ 		case ls¹ of {
//│ 			LH_C h¹ t¹ => (h¹ + sum_₀_₀(t¹))
//│ 			| LH_N  => 0}
//│ 	def zipWith_₀_₀(f¹, xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			LH_C hx¹ tx¹ => case ys¹ of {
//│ 				LH_C hy¹ ty¹ => [LH_C f¹(hx¹, hy¹) zipWith_₀_₀(f¹, tx¹, ty¹)]
//│ 				| LH_N  => [LH_N]}
//│ 			| LH_N  => [LH_N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f¹(hx¹, hy¹) zipWith_₀_₀(f¹, tx¹, ty¹)]: 125 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_₀_₀(t¹)) | LH_N  => 0}: 162
//│ [LH_N]: 126 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_₀_₀(t¹)) | LH_N  => 0}: 162
//│ [LH_N]: 128 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_₀_₀(t¹)) | LH_N  => 0}: 162
//│ ------------------
//│ case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_₀_₀(t¹)) | LH_N  => 0}: 162 --->
//│ 	[LH_C f¹(hx¹, hy¹) zipWith_₀_₀(f¹, tx¹, ty¹)]: 125
//│ 	[LH_N]: 126
//│ 	[LH_N]: 128
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f¹(hx¹, hy¹) zipWith_₀_₀(f¹, tx¹, ty¹)]: 125 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_₀_₀(t¹)) | LH_N  => 0}: 162
//│ [LH_N]: 126 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_₀_₀(t¹)) | LH_N  => 0}: 162
//│ [LH_N]: 128 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_₀_₀(t¹)) | LH_N  => 0}: 162
//│ ------------------
//│ case ls¹ of {LH_C h¹ t¹ => (h¹ + sum_₀_₀(t¹)) | LH_N  => 0}: 162 --->
//│ 	[LH_C f¹(hx¹, hy¹) zipWith_₀_₀(f¹, tx¹, ty¹)]: 125
//│ 	[LH_N]: 126
//│ 	[LH_N]: 128
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ test_₀_₀(primId⁰(10))
//│ def test_₀_₀(_lh_test_arg1²) = 
//│ 	sum_₀_₀(zipWith_₀_₀((fun a⁷ -> (fun b⁷ -> (a⁷ * b⁷))), primId⁰(enumFromTo_₀_₀(1, _lh_test_arg1²)), primId⁰(enumFromTo_₁_₀(_lh_test_arg1², (2 * _lh_test_arg1²)))))
//│ 	where
//│ 	def enumFromTo_₀_₀(a⁸, b⁸) = 
//│ 		if (a⁸ <= b⁸) then [LH_C a⁸ enumFromTo_₀_₀((a⁸ + 1), b⁸)] else [LH_N]
//│ 	def enumFromTo_₁_₀(a⁶, b⁶) = 
//│ 		if (a⁶ <= b⁶) then [LH_C a⁶ enumFromTo_₁_₀((a⁶ + 1), b⁶)] else [LH_N]
//│ 	def sum_₀_₀(ls²) = 
//│ 		ls²(99)
//│ 	def zipWith_₀_₀(f², xs², ys²) = 
//│ 		case xs² of {
//│ 			LH_C hx¹ tx¹ => case ys² of {
//│ 				LH_C hy¹ ty¹ => 
//│ 					let t² = zipWith_₀_₀(f², tx¹, ty¹)
//│ 					in let h² = f²(hx¹, hy¹)
//│ 					in (fun _lh_dummy⁰ -> (h² + sum_₀_₀(t²)))
//│ 				| LH_N  => (fun _lh_dummy¹ -> 0)}
//│ 			| LH_N  => (fun _lh_dummy² -> 0)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 880
//│ <<<<<<< evaluate <<<<<<<

:lhInHaskell
:lhEval
fact r Z = S Z
fact r (S a) = mmul (S a) (r (mmin (S a) (S Z)))
pplus Z b = b
pplus (S a) b = S (pplus a b)
mmul Z b = Z
mmul (S a) b = pplus b (mmul a b)
mmin a b = case b of {
  Z -> a;
  (S bb) -> case a of {
    Z -> Z;
    (S aa) -> mmin aa bb
  }
}
let mainFact = (\x -> fact (\y -> x x y)) (\x -> fact (\y -> x x y)) in mainFact (primId (S (S (S Z))))
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ let mainFact¹ = (fun x⁴ -> fact_₀^833((fun y² -> x⁴(x⁴, y²))))((fun x⁵ -> fact_₁^842((fun y³ -> x⁵(x⁵, y³)))))
//│ in mainFact¹(primId⁰([S [S [S [Z]]]]))
//│ def fact_₀(_lh_fact_arg1¹, _lh_fact_arg2¹) = case _lh_fact_arg2¹ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_fact_S_0¹ => mmul_₀^767([S _lh_fact_S_0¹], _lh_fact_arg1¹(mmin_₀^772([S _lh_fact_S_0¹], [S [Z]])))
//│ 	| _  => error⁰}
//│ def fact_₁(_lh_fact_arg1², _lh_fact_arg2²) = case _lh_fact_arg2² of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_fact_S_0² => mmul_₁^788([S _lh_fact_S_0²], _lh_fact_arg1²(mmin_₁^793([S _lh_fact_S_0²], [S [Z]])))
//│ 	| _  => error⁰}
//│ def mmin_₀(_lh_mmin_arg1², _lh_mmin_arg2²) = 
//│ 	let _lh_matchIdent⁴ = _lh_mmin_arg2²
//│ 	in case _lh_matchIdent⁴ of {
//│ 		Z  => _lh_mmin_arg1²
//│ 		| S _lh_mmin_S_0⁴ => 
//│ 			let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ 			in case _lh_matchIdent⁵ of {
//│ 				Z  => [Z]
//│ 				| S _lh_mmin_S_0⁵ => mmin_₀^724(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴)
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ def mmin_₁(_lh_mmin_arg1¹, _lh_mmin_arg2¹) = 
//│ 	let _lh_matchIdent² = _lh_mmin_arg2¹
//│ 	in case _lh_matchIdent² of {
//│ 		Z  => _lh_mmin_arg1¹
//│ 		| S _lh_mmin_S_0² => 
//│ 			let _lh_matchIdent³ = _lh_mmin_arg1¹
//│ 			in case _lh_matchIdent³ of {
//│ 				Z  => [Z]
//│ 				| S _lh_mmin_S_0³ => mmin_₁^705(_lh_mmin_S_0³, _lh_mmin_S_0²)
//│ 				| _  => error⁰}
//│ 		| _  => error⁰}
//│ def mmul_₀(_lh_mmul_arg1¹, _lh_mmul_arg2¹) = case _lh_mmul_arg1¹ of {
//│ 	Z  => [Z]
//│ 	| S _lh_mmul_S_0¹ => pplus_₀^751(_lh_mmul_arg2¹, mmul_₀^754(_lh_mmul_S_0¹, _lh_mmul_arg2¹))
//│ 	| _  => error⁰}
//│ def mmul_₁(_lh_mmul_arg1², _lh_mmul_arg2²) = case _lh_mmul_arg1² of {
//│ 	Z  => [Z]
//│ 	| S _lh_mmul_S_0² => pplus_₁^808(_lh_mmul_arg2², mmul_₁^811(_lh_mmul_S_0², _lh_mmul_arg2²))
//│ 	| _  => error⁰}
//│ def pplus_₀(_lh_pplus_arg1², _lh_pplus_arg2²) = case _lh_pplus_arg1² of {
//│ 	Z  => _lh_pplus_arg2²
//│ 	| S _lh_pplus_S_0² => [S pplus_₀^823(_lh_pplus_S_0², _lh_pplus_arg2²)]
//│ 	| _  => error⁰}
//│ def pplus_₁(_lh_pplus_arg1¹, _lh_pplus_arg2¹) = case _lh_pplus_arg1¹ of {
//│ 	Z  => _lh_pplus_arg2¹
//│ 	| S _lh_pplus_S_0¹ => [S pplus_₁^739(_lh_pplus_S_0¹, _lh_pplus_arg2¹)]
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [S [S [S [S [S [S [Z]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fact_₀^833]
//│ 	[fact_₀^833 · mmin_₀^772]
//│ 		[fact_₀^833 · mmin_₀^772 · mmin_₀^724] ---> [fact_₀^833 · mmin_₀^772] (only one)
//│ 	[fact_₀^833 · mmul_₀^767]
//│ 		[fact_₀^833 · mmul_₀^767 · mmul_₀^754] ---> [fact_₀^833 · mmul_₀^767] (only one)
//│ 		[fact_₀^833 · mmul_₀^767 · pplus_₀^751]
//│ 			[fact_₀^833 · mmul_₀^767 · pplus_₀^751 · pplus_₀^823] ---> [fact_₀^833 · mmul_₀^767 · pplus_₀^751] (only one)
//│ [fact_₁^842]
//│ 	[fact_₁^842 · mmin_₁^793] (hopeless to continue)
//│ 		[fact_₁^842 · mmin_₁^793 · mmin_₁^705] ---> [fact_₁^842 · mmin_₁^793] (using original def)
//│ 	[fact_₁^842 · mmul_₁^788]
//│ 		[fact_₁^842 · mmul_₁^788 · mmul_₁^811] (hopeless to continue)
//│ 			[fact_₁^842 · mmul_₁^788 · mmul_₁^811 · mmul_₁^811] ---> [fact_₁^842 · mmul_₁^788 · mmul_₁^811] (using original def)
//│ 			[fact_₁^842 · mmul_₁^788 · mmul_₁^811 · pplus_₁^808] (using original def)
//│ 				[fact_₁^842 · mmul_₁^788 · mmul_₁^811 · pplus_₁^808 · pplus_₁^739] ---> [fact_₁^842 · mmul_₁^788 · mmul_₁^811 · pplus_₁^808] (using original def)
//│ 		[fact_₁^842 · mmul_₁^788 · pplus_₁^808]
//│ 			[fact_₁^842 · mmul_₁^788 · pplus_₁^808 · pplus_₁^739] ---> [fact_₁^842 · mmul_₁^788 · pplus_₁^808] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ 
//│ 	let mainFact¹ = (fun x² -> fact_₀_₀((fun y² -> x²(x², y²))))((fun x³ -> fact_₁_₀((fun y³ -> x³(x³, y³)))))
//│ 	in mainFact¹(primId⁰([S [S [S [Z]]]]))
//│ def fact_₀_₀(_lh_fact_arg1³, _lh_fact_arg2³) = 
//│ 	case _lh_fact_arg2³ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0³ => mmul_₀_₀([S _lh_fact_S_0³], _lh_fact_arg1³(mmin_₀_₀([S _lh_fact_S_0³], [S [Z]])))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_₀_₀(_lh_mmin_arg1³, _lh_mmin_arg2³) = 
//│ 		let _lh_matchIdent⁶ = _lh_mmin_arg2³
//│ 		in case _lh_matchIdent⁶ of {
//│ 			Z  => _lh_mmin_arg1³
//│ 			| S _lh_mmin_S_0⁶ => 
//│ 				let _lh_matchIdent⁷ = _lh_mmin_arg1³
//│ 				in case _lh_matchIdent⁷ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁷ => mmin_₀_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶)
//│ 					| _  => error⁰}
//│ 			| _  => error⁰}
//│ 	def mmul_₀_₀(_lh_mmul_arg1³, _lh_mmul_arg2³) = 
//│ 		case _lh_mmul_arg1³ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0³ => pplus_₀_₀(_lh_mmul_arg2³, mmul_₀_₀(_lh_mmul_S_0³, _lh_mmul_arg2³))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus_₀_₀(_lh_pplus_arg1², _lh_pplus_arg2²) = 
//│ 			case _lh_pplus_arg1² of {
//│ 				Z  => _lh_pplus_arg2²
//│ 				| S _lh_pplus_S_0² => [S pplus_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2²)]
//│ 				| _  => error⁰}
//│ def fact_₁_₀(_lh_fact_arg1², _lh_fact_arg2²) = 
//│ 	case _lh_fact_arg2² of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0² => mmul_₁_₀([S _lh_fact_S_0²], _lh_fact_arg1²(mmin_₁_₀([S _lh_fact_S_0²], [S [Z]])))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_₁_₀(_lh_mmin_arg1², _lh_mmin_arg2²) = 
//│ 		let _lh_matchIdent⁴ = _lh_mmin_arg2²
//│ 		in case _lh_matchIdent⁴ of {
//│ 			Z  => _lh_mmin_arg1²
//│ 			| S _lh_mmin_S_0⁴ => 
//│ 				let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ 				in case _lh_matchIdent⁵ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁵ => mmin_₁_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴)
//│ 					| _  => error⁰}
//│ 			| _  => error⁰}
//│ 	def mmul_₁_₀(_lh_mmul_arg1⁴, _lh_mmul_arg2⁴) = 
//│ 		case _lh_mmul_arg1⁴ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0⁴ => pplus_₁_₁(_lh_mmul_arg2⁴, mmul_₁_₁(_lh_mmul_S_0⁴, _lh_mmul_arg2⁴))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def mmul_₁_₁(_lh_mmul_arg1², _lh_mmul_arg2²) = 
//│ 			case _lh_mmul_arg1² of {
//│ 				Z  => [Z]
//│ 				| S _lh_mmul_S_0² => pplus_₁_₀(_lh_mmul_arg2², mmul_₁_₁(_lh_mmul_S_0², _lh_mmul_arg2²))
//│ 				| _  => error⁰}
//│ 			where
//│ 			def pplus_₁_₀(_lh_pplus_arg1³, _lh_pplus_arg2³) = 
//│ 				case _lh_pplus_arg1³ of {
//│ 					Z  => _lh_pplus_arg2³
//│ 					| S _lh_pplus_S_0³ => [S pplus_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]
//│ 					| _  => error⁰}
//│ 		def pplus_₁_₁(_lh_pplus_arg1⁴, _lh_pplus_arg2⁴) = 
//│ 			case _lh_pplus_arg1⁴ of {
//│ 				Z  => _lh_pplus_arg2⁴
//│ 				| S _lh_pplus_S_0⁴ => [S pplus_₁_₁(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]
//│ 				| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Z]: 164 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 212
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 224
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus_₁_₁(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 321
//│ [S [Z]]: 165 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 212
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 224
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus_₁_₁(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 321
//│ [S _lh_fact_S_0²]: 168 --->
//│ 	case _lh_mmul_arg1⁴ of {Z  => [Z] | S _lh_mmul_S_0⁴ => pplus_₁_₁(_lh_mmul_arg2⁴, mmul_₁_₁(_lh_mmul_S_0⁴, _lh_mmul_arg2⁴)) | _  => error⁰}: 290
//│ [S _lh_fact_S_0²]: 173 --->
//│ 	case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul_₁_₀([S _lh_fact_S_0²], _lh_fact_arg1²(mmin_₁_₀([S _lh_fact_S_0²], [S [Z]]))) | _  => error⁰}: 181
//│ 	case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 196
//│ [Z]: 175 --->
//│ 	case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 199
//│ [S [Z]]: 176 --->
//│ 	case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 199
//│ [Z]: 189 --->
//│ 	case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul_₁_₀([S _lh_fact_S_0²], _lh_fact_arg1²(mmin_₁_₀([S _lh_fact_S_0²], [S [Z]]))) | _  => error⁰}: 181
//│ [S pplus_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 222 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 212
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 224
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus_₁_₁(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 321
//│ [Z]: 228 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 212
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 224
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus_₁_₁(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 321
//│ [S _lh_fact_S_0³]: 247 --->
//│ 	case _lh_mmul_arg1³ of {Z  => [Z] | S _lh_mmul_S_0³ => pplus_₀_₀(_lh_mmul_arg2³, mmul_₀_₀(_lh_mmul_S_0³, _lh_mmul_arg2³)) | _  => error⁰}: 275
//│ [S _lh_fact_S_0³]: 252 --->
//│ 	case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul_₁_₀([S _lh_fact_S_0²], _lh_fact_arg1²(mmin_₁_₀([S _lh_fact_S_0²], [S [Z]]))) | _  => error⁰}: 181
//│ 	case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_₀_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 305
//│ [Z]: 254 --->
//│ 	case _lh_matchIdent⁶ of {Z  => _lh_mmin_arg1³ | S _lh_mmin_S_0⁶ => let _lh_matchIdent⁷ = _lh_mmin_arg1³
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_₀_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰} | _  => error⁰}: 308
//│ [S [Z]]: 255 --->
//│ 	case _lh_matchIdent⁶ of {Z  => _lh_mmin_arg1³ | S _lh_mmin_S_0⁶ => let _lh_matchIdent⁷ = _lh_mmin_arg1³
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_₀_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰} | _  => error⁰}: 308
//│ [Z]: 279 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 212
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 224
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus_₁_₁(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 321
//│ [Z]: 298 --->
//│ 	case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul_₁_₀([S _lh_fact_S_0²], _lh_fact_arg1²(mmin_₁_₀([S _lh_fact_S_0²], [S [Z]]))) | _  => error⁰}: 181
//│ [S pplus_₁_₁(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]: 319 --->
//│ 	case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 212
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 224
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus_₁_₁(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 321
//│ ------------------
//│ case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul_₁_₀([S _lh_fact_S_0²], _lh_fact_arg1²(mmin_₁_₀([S _lh_fact_S_0²], [S [Z]]))) | _  => error⁰}: 181 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0²]: 173
//│ 	[Z]: 189
//│ 	[S _lh_fact_S_0³]: 252
//│ 	[Z]: 298
//│ case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 196 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0²]: 173
//│ case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 199 --->
//│ 	[Z]: 175
//│ 	[S [Z]]: 176
//│ case _lh_pplus_arg1² of {Z  => _lh_pplus_arg2² | S _lh_pplus_S_0² => [S pplus_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2²)] | _  => error⁰}: 212 --->
//│ 	[Z]: 164
//│ 	[S [Z]]: 165
//│ 	[S pplus_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 222
//│ 	[Z]: 228
//│ 	[Z]: 279
//│ 	[S pplus_₁_₁(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]: 319
//│ case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 224 --->
//│ 	[Z]: 164
//│ 	[S [Z]]: 165
//│ 	[S pplus_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 222
//│ 	[Z]: 228
//│ 	[Z]: 279
//│ 	[S pplus_₁_₁(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]: 319
//│ case _lh_mmul_arg1³ of {Z  => [Z] | S _lh_mmul_S_0³ => pplus_₀_₀(_lh_mmul_arg2³, mmul_₀_₀(_lh_mmul_S_0³, _lh_mmul_arg2³)) | _  => error⁰}: 275 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0³]: 247
//│ case _lh_mmul_arg1⁴ of {Z  => [Z] | S _lh_mmul_S_0⁴ => pplus_₁_₁(_lh_mmul_arg2⁴, mmul_₁_₁(_lh_mmul_S_0⁴, _lh_mmul_arg2⁴)) | _  => error⁰}: 290 --->
//│ 	[S _lh_fact_S_0²]: 168
//│ case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_₀_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 305 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0³]: 252
//│ case _lh_matchIdent⁶ of {Z  => _lh_mmin_arg1³ | S _lh_mmin_S_0⁶ => let _lh_matchIdent⁷ = _lh_mmin_arg1³
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_₀_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰} | _  => error⁰}: 308 --->
//│ 	[Z]: 254
//│ 	[S [Z]]: 255
//│ case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus_₁_₁(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 321 --->
//│ 	[Z]: 164
//│ 	[S [Z]]: 165
//│ 	[S pplus_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]: 222
//│ 	[Z]: 228
//│ 	[Z]: 279
//│ 	[S pplus_₁_₁(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]: 319
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [S _lh_fact_S_0²]: 168 --->
//│ 	case _lh_mmul_arg1⁴ of {Z  => [Z] | S _lh_mmul_S_0⁴ => pplus_₁_₁(_lh_mmul_arg2⁴, mmul_₁_₁(_lh_mmul_S_0⁴, _lh_mmul_arg2⁴)) | _  => error⁰}: 290
//│ [Z]: 175 --->
//│ 	case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 199
//│ [S [Z]]: 176 --->
//│ 	case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 199
//│ [Z]: 254 --->
//│ 	case _lh_matchIdent⁶ of {Z  => _lh_mmin_arg1³ | S _lh_mmin_S_0⁶ => let _lh_matchIdent⁷ = _lh_mmin_arg1³
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_₀_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰} | _  => error⁰}: 308
//│ [S [Z]]: 255 --->
//│ 	case _lh_matchIdent⁶ of {Z  => _lh_mmin_arg1³ | S _lh_mmin_S_0⁶ => let _lh_matchIdent⁷ = _lh_mmin_arg1³
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_₀_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰} | _  => error⁰}: 308
//│ ------------------
//│ case _lh_matchIdent⁴ of {Z  => _lh_mmin_arg1² | S _lh_mmin_S_0⁴ => let _lh_matchIdent⁵ = _lh_mmin_arg1²
//│ in case _lh_matchIdent⁵ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰} | _  => error⁰}: 199 --->
//│ 	[Z]: 175
//│ 	[S [Z]]: 176
//│ case _lh_mmul_arg1⁴ of {Z  => [Z] | S _lh_mmul_S_0⁴ => pplus_₁_₁(_lh_mmul_arg2⁴, mmul_₁_₁(_lh_mmul_S_0⁴, _lh_mmul_arg2⁴)) | _  => error⁰}: 290 --->
//│ 	[S _lh_fact_S_0²]: 168
//│ case _lh_matchIdent⁶ of {Z  => _lh_mmin_arg1³ | S _lh_mmin_S_0⁶ => let _lh_matchIdent⁷ = _lh_mmin_arg1³
//│ in case _lh_matchIdent⁷ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_₀_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰} | _  => error⁰}: 308 --->
//│ 	[Z]: 254
//│ 	[S [Z]]: 255
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let mainFact² = (fun x⁴ -> fact_₀_₀((fun y⁴ -> x⁴(x⁴, y⁴))))((fun x⁵ -> fact_₁_₀((fun y⁵ -> x⁵(x⁵, y⁵)))))
//│ 	in mainFact²(primId⁰([S [S [S [Z]]]]))
//│ def fact_₀_₀(_lh_fact_arg1⁵, _lh_fact_arg2⁵) = 
//│ 	case _lh_fact_arg2⁵ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0³ => mmul_₀_₀([S _lh_fact_S_0³], _lh_fact_arg1⁵(mmin_₀_₀([S _lh_fact_S_0³], 
//│ 			let _lh_mmin_S_0⁹ = (fun _lh_mmin_arg1⁸ -> _lh_mmin_arg1⁸)
//│ 			in (fun _lh_mmin_arg1⁷ -> 
//│ 				let _lh_matchIdent¹⁰ = _lh_mmin_arg1⁷
//│ 				in case _lh_matchIdent¹⁰ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁷ => mmin_₀_₀(_lh_mmin_S_0⁷, _lh_mmin_S_0⁹)
//│ 					| _  => error⁰}))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_₀_₀(_lh_mmin_arg1⁹, _lh_mmin_arg2⁵) = 
//│ 		let _lh_matchIdent¹¹ = _lh_mmin_arg2⁵
//│ 		in _lh_matchIdent¹¹(_lh_mmin_arg1⁹)
//│ 	def mmul_₀_₀(_lh_mmul_arg1⁶, _lh_mmul_arg2⁷) = 
//│ 		case _lh_mmul_arg1⁶ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0³ => pplus_₀_₀(_lh_mmul_arg2⁷, mmul_₀_₀(_lh_mmul_S_0³, _lh_mmul_arg2⁷))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus_₀_₀(_lh_pplus_arg1⁵, _lh_pplus_arg2⁵) = 
//│ 			case _lh_pplus_arg1⁵ of {
//│ 				Z  => _lh_pplus_arg2⁵
//│ 				| S _lh_pplus_S_0² => [S pplus_₀_₀(_lh_pplus_S_0², _lh_pplus_arg2⁵)]
//│ 				| _  => error⁰}
//│ def fact_₁_₀(_lh_fact_arg1⁴, _lh_fact_arg2⁴) = 
//│ 	case _lh_fact_arg2⁴ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0² => mmul_₁_₀(
//│ 			let _lh_mmul_S_0⁵ = _lh_fact_S_0²
//│ 			in (fun _lh_mmul_arg2⁵ -> pplus_₁_₁(_lh_mmul_arg2⁵, mmul_₁_₁(_lh_mmul_S_0⁵, _lh_mmul_arg2⁵))), _lh_fact_arg1⁴(mmin_₁_₀([S _lh_fact_S_0²], 
//│ 			let _lh_mmin_S_0⁸ = (fun _lh_mmin_arg1⁵ -> _lh_mmin_arg1⁵)
//│ 			in (fun _lh_mmin_arg1⁴ -> 
//│ 				let _lh_matchIdent⁸ = _lh_mmin_arg1⁴
//│ 				in case _lh_matchIdent⁸ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁵ => mmin_₁_₀(_lh_mmin_S_0⁵, _lh_mmin_S_0⁸)
//│ 					| _  => error⁰}))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_₁_₀(_lh_mmin_arg1⁶, _lh_mmin_arg2⁴) = 
//│ 		let _lh_matchIdent⁹ = _lh_mmin_arg2⁴
//│ 		in _lh_matchIdent⁹(_lh_mmin_arg1⁶)
//│ 	def mmul_₁_₀(_lh_mmul_arg1⁷, _lh_mmul_arg2⁸) = 
//│ 		_lh_mmul_arg1⁷(_lh_mmul_arg2⁸)
//│ 		where
//│ 		def mmul_₁_₁(_lh_mmul_arg1⁵, _lh_mmul_arg2⁶) = 
//│ 			case _lh_mmul_arg1⁵ of {
//│ 				Z  => [Z]
//│ 				| S _lh_mmul_S_0² => pplus_₁_₀(_lh_mmul_arg2⁶, mmul_₁_₁(_lh_mmul_S_0², _lh_mmul_arg2⁶))
//│ 				| _  => error⁰}
//│ 			where
//│ 			def pplus_₁_₀(_lh_pplus_arg1⁷, _lh_pplus_arg2⁷) = 
//│ 				case _lh_pplus_arg1⁷ of {
//│ 					Z  => _lh_pplus_arg2⁷
//│ 					| S _lh_pplus_S_0³ => [S pplus_₁_₀(_lh_pplus_S_0³, _lh_pplus_arg2⁷)]
//│ 					| _  => error⁰}
//│ 		def pplus_₁_₁(_lh_pplus_arg1⁶, _lh_pplus_arg2⁶) = 
//│ 			case _lh_pplus_arg1⁶ of {
//│ 				Z  => _lh_pplus_arg2⁶
//│ 				| S _lh_pplus_S_0⁴ => [S pplus_₁_₁(_lh_pplus_S_0⁴, _lh_pplus_arg2⁶)]
//│ 				| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [S [S [S [S [S [S [Z]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fact_₀_₀^1]
//│ 	[fact_₀_₀^1 · mmin_₀_₀^103] (hopeless to continue)
//│ 	[fact_₀_₀^1 · mmin_₀_₀^112] (hopeless to continue)
//│ 	[fact_₀_₀^1 · mmul_₀_₀^98]
//│ 		[fact_₀_₀^1 · mmul_₀_₀^98 · mmul_₀_₀^153] ---> [fact_₀_₀^1 · mmul_₀_₀^98] (only one)
//│ 		[fact_₀_₀^1 · mmul_₀_₀^98 · pplus_₀_₀^150]
//│ 			[fact_₀_₀^1 · mmul_₀_₀^98 · pplus_₀_₀^150 · pplus_₀_₀^138] ---> [fact_₀_₀^1 · mmul_₀_₀^98 · pplus_₀_₀^150] (only one)
//│ [fact_₁_₀^10]
//│ 	[fact_₁_₀^10 · mmin_₁_₀^47] (hopeless to continue)
//│ 	[fact_₁_₀^10 · mmin_₁_₀^56] (hopeless to continue)
//│ 	[fact_₁_₀^10 · mmul_₁_₀^32] (hopeless to continue)
//│ 	[fact_₁_₀^10 · mmul_₁_₁^37] (hopeless to continue)
//│ 		[fact_₁_₀^10 · mmul_₁_₁^37 · mmul_₁_₁^78] ---> [fact_₁_₀^10 · mmul_₁_₁^37] (using original def)
//│ 		[fact_₁_₀^10 · mmul_₁_₁^37 · pplus_₁_₀^75] (using original def)
//│ 			[fact_₁_₀^10 · mmul_₁_₁^37 · pplus_₁_₀^75 · pplus_₁_₀^182] ---> [fact_₁_₀^10 · mmul_₁_₁^37 · pplus_₁_₀^75] (using original def)
//│ 	[fact_₁_₀^10 · pplus_₁_₁^34]
//│ 		[fact_₁_₀^10 · pplus_₁_₁^34 · pplus_₁_₁^170] ---> [fact_₁_₀^10 · pplus_₁_₁^34] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ 
//│ 	let mainFact¹ = (fun x² -> fact_₀_₀_₀((fun y² -> x²(x², y²))))((fun x³ -> fact_₁_₀_₀((fun y³ -> x³(x³, y³)))))
//│ 	in mainFact¹(primId⁰([S [S [S [Z]]]]))
//│ def fact_₀_₀_₀(_lh_fact_arg1³, _lh_fact_arg2³) = 
//│ 	case _lh_fact_arg2³ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0³ => mmul_₀_₀_₀([S _lh_fact_S_0³], _lh_fact_arg1³(mmin_₀_₀_₀([S _lh_fact_S_0³], 
//│ 			let _lh_mmin_S_0⁶ = (fun _lh_mmin_arg1¹¹ -> _lh_mmin_arg1¹¹)
//│ 			in (fun _lh_mmin_arg1¹² -> 
//│ 				let _lh_matchIdent⁸ = _lh_mmin_arg1¹²
//│ 				in case _lh_matchIdent⁸ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁷ => mmin_₀_₀_₁(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶)
//│ 					| _  => error⁰}))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_₀_₀_₀(_lh_mmin_arg1⁷, _lh_mmin_arg2³) = 
//│ 		let _lh_matchIdent⁵ = _lh_mmin_arg2³
//│ 		in _lh_matchIdent⁵(_lh_mmin_arg1⁷)
//│ 	def mmin_₀_₀_₁(_lh_mmin_arg1¹⁰, _lh_mmin_arg2⁴) = 
//│ 		let _lh_matchIdent⁷ = _lh_mmin_arg2⁴
//│ 		in _lh_matchIdent⁷(_lh_mmin_arg1¹⁰)
//│ 	def mmul_₀_₀_₀(_lh_mmul_arg1³, _lh_mmul_arg2⁴) = 
//│ 		case _lh_mmul_arg1³ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0³ => pplus_₀_₀_₀(_lh_mmul_arg2⁴, mmul_₀_₀_₀(_lh_mmul_S_0³, _lh_mmul_arg2⁴))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus_₀_₀_₀(_lh_pplus_arg1³, _lh_pplus_arg2³) = 
//│ 			case _lh_pplus_arg1³ of {
//│ 				Z  => _lh_pplus_arg2³
//│ 				| S _lh_pplus_S_0³ => [S pplus_₀_₀_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)]
//│ 				| _  => error⁰}
//│ def fact_₁_₀_₀(_lh_fact_arg1², _lh_fact_arg2²) = 
//│ 	case _lh_fact_arg2² of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0² => mmul_₁_₀_₀(
//│ 			let _lh_mmul_S_0⁴ = _lh_fact_S_0²
//│ 			in (fun _lh_mmul_arg2⁵ -> pplus_₁_₁_₀(_lh_mmul_arg2⁵, mmul_₁_₁_₀(_lh_mmul_S_0⁴, _lh_mmul_arg2⁵))), _lh_fact_arg1²(mmin_₁_₀_₀([S _lh_fact_S_0²], 
//│ 			let _lh_mmin_S_0⁴ = (fun _lh_mmin_arg1⁸ -> _lh_mmin_arg1⁸)
//│ 			in (fun _lh_mmin_arg1⁹ -> 
//│ 				let _lh_matchIdent⁶ = _lh_mmin_arg1⁹
//│ 				in case _lh_matchIdent⁶ of {
//│ 					Z  => [Z]
//│ 					| S _lh_mmin_S_0⁵ => mmin_₁_₀_₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴)
//│ 					| _  => error⁰}))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_₁_₀_₀(_lh_mmin_arg1⁶, _lh_mmin_arg2²) = 
//│ 		let _lh_matchIdent⁴ = _lh_mmin_arg2²
//│ 		in _lh_matchIdent⁴(_lh_mmin_arg1⁶)
//│ 	def mmin_₁_₀_₁(_lh_mmin_arg1¹³, _lh_mmin_arg2⁵) = 
//│ 		let _lh_matchIdent⁹ = _lh_mmin_arg2⁵
//│ 		in _lh_matchIdent⁹(_lh_mmin_arg1¹³)
//│ 	def mmul_₁_₀_₀(_lh_mmul_arg1⁵, _lh_mmul_arg2⁷) = 
//│ 		_lh_mmul_arg1⁵(_lh_mmul_arg2⁷)
//│ 	def mmul_₁_₁_₀(_lh_mmul_arg1⁴, _lh_mmul_arg2⁶) = 
//│ 		case _lh_mmul_arg1⁴ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0⁵ => pplus_₁_₀_₀(_lh_mmul_arg2⁶, mmul_₁_₁_₀(_lh_mmul_S_0⁵, _lh_mmul_arg2⁶))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus_₁_₀_₀(_lh_pplus_arg1⁴, _lh_pplus_arg2⁴) = 
//│ 			case _lh_pplus_arg1⁴ of {
//│ 				Z  => _lh_pplus_arg2⁴
//│ 				| S _lh_pplus_S_0⁴ => [S pplus_₁_₀_₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]
//│ 				| _  => error⁰}
//│ 	def pplus_₁_₁_₀(_lh_pplus_arg1⁵, _lh_pplus_arg2⁵) = 
//│ 		case _lh_pplus_arg1⁵ of {
//│ 			Z  => _lh_pplus_arg2⁵
//│ 			| S _lh_pplus_S_0⁵ => [S pplus_₁_₁_₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)]
//│ 			| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S pplus_₁_₀_₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]: 218 --->
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_₀_₀_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 201
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus_₁_₀_₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 220
//│ 	case _lh_pplus_arg1⁵ of {Z  => _lh_pplus_arg2⁵ | S _lh_pplus_S_0⁵ => [S pplus_₁_₁_₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)] | _  => error⁰}: 305
//│ [Z]: 246 --->
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_₀_₀_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 201
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus_₁_₀_₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 220
//│ 	case _lh_pplus_arg1⁵ of {Z  => _lh_pplus_arg2⁵ | S _lh_pplus_S_0⁵ => [S pplus_₁_₁_₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)] | _  => error⁰}: 305
//│ [S [Z]]: 247 --->
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_₀_₀_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 201
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus_₁_₀_₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 220
//│ 	case _lh_pplus_arg1⁵ of {Z  => _lh_pplus_arg2⁵ | S _lh_pplus_S_0⁵ => [S pplus_₁_₁_₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)] | _  => error⁰}: 305
//│ [S _lh_fact_S_0²]: 265 --->
//│ 	case _lh_matchIdent⁶ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀_₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 278
//│ [Z]: 271 --->
//│ 	case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul_₁_₀_₀(let _lh_mmul_S_0⁴ = _lh_fact_S_0²
//│ in (fun _lh_mmul_arg2⁵ -> pplus_₁_₁_₀(_lh_mmul_arg2⁵, mmul_₁_₁_₀(_lh_mmul_S_0⁴, _lh_mmul_arg2⁵))), _lh_fact_arg1²(mmin_₁_₀_₀([S _lh_fact_S_0²], let _lh_mmin_S_0⁴ = (fun _lh_mmin_arg1⁸ -> _lh_mmin_arg1⁸)
//│ in (fun _lh_mmin_arg1⁹ -> let _lh_matchIdent⁶ = _lh_mmin_arg1⁹
//│ in case _lh_matchIdent⁶ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀_₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰})))) | _  => error⁰}: 286
//│ [S pplus_₁_₁_₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)]: 303 --->
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_₀_₀_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 201
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus_₁_₀_₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 220
//│ 	case _lh_pplus_arg1⁵ of {Z  => _lh_pplus_arg2⁵ | S _lh_pplus_S_0⁵ => [S pplus_₁_₁_₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)] | _  => error⁰}: 305
//│ [S _lh_fact_S_0³]: 313 --->
//│ 	case _lh_mmul_arg1³ of {Z  => [Z] | S _lh_mmul_S_0³ => pplus_₀_₀_₀(_lh_mmul_arg2⁴, mmul_₀_₀_₀(_lh_mmul_S_0³, _lh_mmul_arg2⁴)) | _  => error⁰}: 242
//│ [S _lh_fact_S_0³]: 318 --->
//│ 	case _lh_matchIdent⁸ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_₀_₀_₁(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 331
//│ [Z]: 324 --->
//│ 	case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul_₁_₀_₀(let _lh_mmul_S_0⁴ = _lh_fact_S_0²
//│ in (fun _lh_mmul_arg2⁵ -> pplus_₁_₁_₀(_lh_mmul_arg2⁵, mmul_₁_₁_₀(_lh_mmul_S_0⁴, _lh_mmul_arg2⁵))), _lh_fact_arg1²(mmin_₁_₀_₀([S _lh_fact_S_0²], let _lh_mmin_S_0⁴ = (fun _lh_mmin_arg1⁸ -> _lh_mmin_arg1⁸)
//│ in (fun _lh_mmin_arg1⁹ -> let _lh_matchIdent⁶ = _lh_mmin_arg1⁹
//│ in case _lh_matchIdent⁶ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀_₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰})))) | _  => error⁰}: 286
//│ [Z]: 343 --->
//│ 	case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_₀_₀_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 201
//│ 	case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus_₁_₀_₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 220
//│ 	case _lh_pplus_arg1⁵ of {Z  => _lh_pplus_arg2⁵ | S _lh_pplus_S_0⁵ => [S pplus_₁_₁_₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)] | _  => error⁰}: 305
//│ ------------------
//│ case _lh_pplus_arg1³ of {Z  => _lh_pplus_arg2³ | S _lh_pplus_S_0³ => [S pplus_₀_₀_₀(_lh_pplus_S_0³, _lh_pplus_arg2³)] | _  => error⁰}: 201 --->
//│ 	[S pplus_₁_₀_₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]: 218
//│ 	[Z]: 246
//│ 	[S [Z]]: 247
//│ 	[S pplus_₁_₁_₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)]: 303
//│ 	[Z]: 343
//│ case _lh_pplus_arg1⁴ of {Z  => _lh_pplus_arg2⁴ | S _lh_pplus_S_0⁴ => [S pplus_₁_₀_₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)] | _  => error⁰}: 220 --->
//│ 	[S pplus_₁_₀_₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]: 218
//│ 	[Z]: 246
//│ 	[S [Z]]: 247
//│ 	[S pplus_₁_₁_₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)]: 303
//│ 	[Z]: 343
//│ case _lh_mmul_arg1³ of {Z  => [Z] | S _lh_mmul_S_0³ => pplus_₀_₀_₀(_lh_mmul_arg2⁴, mmul_₀_₀_₀(_lh_mmul_S_0³, _lh_mmul_arg2⁴)) | _  => error⁰}: 242 --->
//│ 	NoProd
//│ 	[S _lh_fact_S_0³]: 313
//│ case _lh_matchIdent⁶ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀_₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 278 --->
//│ 	[S _lh_fact_S_0²]: 265
//│ case _lh_fact_arg2² of {Z  => [S [Z]] | S _lh_fact_S_0² => mmul_₁_₀_₀(let _lh_mmul_S_0⁴ = _lh_fact_S_0²
//│ in (fun _lh_mmul_arg2⁵ -> pplus_₁_₁_₀(_lh_mmul_arg2⁵, mmul_₁_₁_₀(_lh_mmul_S_0⁴, _lh_mmul_arg2⁵))), _lh_fact_arg1²(mmin_₁_₀_₀([S _lh_fact_S_0²], let _lh_mmin_S_0⁴ = (fun _lh_mmin_arg1⁸ -> _lh_mmin_arg1⁸)
//│ in (fun _lh_mmin_arg1⁹ -> let _lh_matchIdent⁶ = _lh_mmin_arg1⁹
//│ in case _lh_matchIdent⁶ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀_₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰})))) | _  => error⁰}: 286 --->
//│ 	NoProd
//│ 	[Z]: 271
//│ 	[Z]: 324
//│ case _lh_pplus_arg1⁵ of {Z  => _lh_pplus_arg2⁵ | S _lh_pplus_S_0⁵ => [S pplus_₁_₁_₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)] | _  => error⁰}: 305 --->
//│ 	[S pplus_₁_₀_₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁴)]: 218
//│ 	[Z]: 246
//│ 	[S [Z]]: 247
//│ 	[S pplus_₁_₁_₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁵)]: 303
//│ 	[Z]: 343
//│ case _lh_matchIdent⁸ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_₀_₀_₁(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 331 --->
//│ 	[S _lh_fact_S_0³]: 318
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [S _lh_fact_S_0²]: 265 --->
//│ 	case _lh_matchIdent⁶ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀_₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 278
//│ [S _lh_fact_S_0³]: 318 --->
//│ 	case _lh_matchIdent⁸ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_₀_₀_₁(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 331
//│ ------------------
//│ case _lh_matchIdent⁶ of {Z  => [Z] | S _lh_mmin_S_0⁵ => mmin_₁_₀_₁(_lh_mmin_S_0⁵, _lh_mmin_S_0⁴) | _  => error⁰}: 278 --->
//│ 	[S _lh_fact_S_0²]: 265
//│ case _lh_matchIdent⁸ of {Z  => [Z] | S _lh_mmin_S_0⁷ => mmin_₀_₀_₁(_lh_mmin_S_0⁷, _lh_mmin_S_0⁶) | _  => error⁰}: 331 --->
//│ 	[S _lh_fact_S_0³]: 318
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let mainFact² = (fun x⁴ -> fact_₀_₀_₀((fun y⁴ -> x⁴(x⁴, y⁴))))((fun x⁵ -> fact_₁_₀_₀((fun y⁵ -> x⁵(x⁵, y⁵)))))
//│ 	in mainFact²(primId⁰([S [S [S [Z]]]]))
//│ def fact_₀_₀_₀(_lh_fact_arg1⁵, _lh_fact_arg2⁵) = 
//│ 	case _lh_fact_arg2⁵ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0³ => mmul_₀_₀_₀([S _lh_fact_S_0³], _lh_fact_arg1⁵(mmin_₀_₀_₀(
//│ 			let _lh_mmin_S_0¹¹ = _lh_fact_S_0³
//│ 			in (fun _lh_mmin_S_0¹² -> mmin_₀_₀_₁(_lh_mmin_S_0¹¹, _lh_mmin_S_0¹²)), 
//│ 			let _lh_mmin_S_0¹³ = (fun _lh_mmin_arg1¹⁶ -> _lh_mmin_arg1¹⁶)
//│ 			in (fun _lh_mmin_arg1¹⁷ -> 
//│ 				let _lh_matchIdent¹¹ = _lh_mmin_arg1¹⁷
//│ 				in _lh_matchIdent¹¹(_lh_mmin_S_0¹³)))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_₀_₀_₀(_lh_mmin_arg1¹⁹, _lh_mmin_arg2⁷) = 
//│ 		let _lh_matchIdent¹³ = _lh_mmin_arg2⁷
//│ 		in _lh_matchIdent¹³(_lh_mmin_arg1¹⁹)
//│ 	def mmin_₀_₀_₁(_lh_mmin_arg1²⁰, _lh_mmin_arg2⁸) = 
//│ 		let _lh_matchIdent¹⁴ = _lh_mmin_arg2⁸
//│ 		in _lh_matchIdent¹⁴(_lh_mmin_arg1²⁰)
//│ 	def mmul_₀_₀_₀(_lh_mmul_arg1⁷, _lh_mmul_arg2¹⁰) = 
//│ 		case _lh_mmul_arg1⁷ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0³ => pplus_₀_₀_₀(_lh_mmul_arg2¹⁰, mmul_₀_₀_₀(_lh_mmul_S_0³, _lh_mmul_arg2¹⁰))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus_₀_₀_₀(_lh_pplus_arg1⁶, _lh_pplus_arg2⁶) = 
//│ 			case _lh_pplus_arg1⁶ of {
//│ 				Z  => _lh_pplus_arg2⁶
//│ 				| S _lh_pplus_S_0³ => [S pplus_₀_₀_₀(_lh_pplus_S_0³, _lh_pplus_arg2⁶)]
//│ 				| _  => error⁰}
//│ def fact_₁_₀_₀(_lh_fact_arg1⁴, _lh_fact_arg2⁴) = 
//│ 	case _lh_fact_arg2⁴ of {
//│ 		Z  => [S [Z]]
//│ 		| S _lh_fact_S_0² => mmul_₁_₀_₀(
//│ 			let _lh_mmul_S_0⁶ = _lh_fact_S_0²
//│ 			in (fun _lh_mmul_arg2⁸ -> pplus_₁_₁_₀(_lh_mmul_arg2⁸, mmul_₁_₁_₀(_lh_mmul_S_0⁶, _lh_mmul_arg2⁸))), _lh_fact_arg1⁴(mmin_₁_₀_₀(
//│ 			let _lh_mmin_S_0⁸ = _lh_fact_S_0²
//│ 			in (fun _lh_mmin_S_0⁹ -> mmin_₁_₀_₁(_lh_mmin_S_0⁸, _lh_mmin_S_0⁹)), 
//│ 			let _lh_mmin_S_0¹⁰ = (fun _lh_mmin_arg1¹⁴ -> _lh_mmin_arg1¹⁴)
//│ 			in (fun _lh_mmin_arg1¹⁵ -> 
//│ 				let _lh_matchIdent¹⁰ = _lh_mmin_arg1¹⁵
//│ 				in _lh_matchIdent¹⁰(_lh_mmin_S_0¹⁰)))))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mmin_₁_₀_₀(_lh_mmin_arg1¹⁸, _lh_mmin_arg2⁶) = 
//│ 		let _lh_matchIdent¹² = _lh_mmin_arg2⁶
//│ 		in _lh_matchIdent¹²(_lh_mmin_arg1¹⁸)
//│ 	def mmin_₁_₀_₁(_lh_mmin_arg1²¹, _lh_mmin_arg2⁹) = 
//│ 		let _lh_matchIdent¹⁵ = _lh_mmin_arg2⁹
//│ 		in _lh_matchIdent¹⁵(_lh_mmin_arg1²¹)
//│ 	def mmul_₁_₀_₀(_lh_mmul_arg1⁶, _lh_mmul_arg2⁹) = 
//│ 		_lh_mmul_arg1⁶(_lh_mmul_arg2⁹)
//│ 	def mmul_₁_₁_₀(_lh_mmul_arg1⁸, _lh_mmul_arg2¹¹) = 
//│ 		case _lh_mmul_arg1⁸ of {
//│ 			Z  => [Z]
//│ 			| S _lh_mmul_S_0⁵ => pplus_₁_₀_₀(_lh_mmul_arg2¹¹, mmul_₁_₁_₀(_lh_mmul_S_0⁵, _lh_mmul_arg2¹¹))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def pplus_₁_₀_₀(_lh_pplus_arg1⁸, _lh_pplus_arg2⁸) = 
//│ 			case _lh_pplus_arg1⁸ of {
//│ 				Z  => _lh_pplus_arg2⁸
//│ 				| S _lh_pplus_S_0⁴ => [S pplus_₁_₀_₀(_lh_pplus_S_0⁴, _lh_pplus_arg2⁸)]
//│ 				| _  => error⁰}
//│ 	def pplus_₁_₁_₀(_lh_pplus_arg1⁷, _lh_pplus_arg2⁷) = 
//│ 		case _lh_pplus_arg1⁷ of {
//│ 			Z  => _lh_pplus_arg2⁷
//│ 			| S _lh_pplus_S_0⁵ => [S pplus_₁_₁_₀(_lh_pplus_S_0⁵, _lh_pplus_arg2⁷)]
//│ 			| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [S [S [S [S [S [S [Z]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
