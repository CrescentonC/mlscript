:NewParser
:ParseOnly

let rec p = C(p)
fun c(x) = if x is
    C(a) then c(a)
c(p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:6 = 2: [C 1: p:6]
//│ def c:7 = 8: (fun x:8 -> 7: case 3: x:8 of {C a:9 -> 6: (4: c:7 5: a:9)})
//│ 11: (9: c:7 10: p:6)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([-p:6^1]: 0'p)) <: 2'x
//│ 	[-p:6^1 · -p:6^10 · +c:7^9 · +c:7^4]  --->  [-p:6^10 · +c:7^9]



let p = C(1, C(2, N))
fun e(z) = if z is
    C(aaa, bbb) then bbb
    N then 7
fun d(y) = if y is
    C(aa, bb) then e(bb)
    N then 5
fun c(x) = if x is
    C(a, b) then d(b)
    N then 3
c(p)
//│ |#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#fun| |e|(|z|)| |#=| |#if| |z| |is|→|C|(|aaa|,| |bbb|)| |#then| |bbb|↵|N| |#then| |7|←|↵|#fun| |d|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|,| |bb|)| |#then| |e|(|bb|)|↵|N| |#then| |5|←|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|,| |b|)| |#then| |d|(|b|)|↵|N| |#then| |3|←|↵|c|(|p|)|
//│ Parsed: {let p = C (1, C (2, N,),); fun e = z, => if z is ‹(C (aaa, bbb,)) then bbb; (N) then 7›; fun d = y, => if y is ‹(C (aa, bb,)) then e (bb,); (N) then 5›; fun c = x, => if x is ‹(C (a, b,)) then d (b,); (N) then 3›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:6 = 5: [C 1: 1 4: [C 2: 2 3: [N]]]
//│ def e:7 = 10: (fun z:10 -> 9: case 6: z:10 of {C aaa:11 bbb:12 -> 7: bbb:12 | N -> 8: 7})
//│ def d:8 = 17: (fun y:13 -> 16: case 11: y:13 of {C aa:14 bb:15 -> 14: (12: e:7 13: bb:15) | N -> 15: 5})
//│ def c:9 = 24: (fun x:16 -> 23: case 18: x:16 of {C a:17 b:18 -> 21: (19: d:8 20: b:18) | N -> 22: 3})
//│ 27: (25: c:9 26: p:6)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------


let rec p = C(C(p))
fun c(x) = if x is
    C(a) then if a is
        C(b) then if b is
            C(y) then c(y)
c(p)
//│ |#let| |#rec| |p| |#=| |C|(|C|(|p|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |#if| |b| |is|→|C|(|y|)| |#then| |c|(|y|)|←|←|←|↵|c|(|p|)|
//│ Parsed: {let rec p = C (C (p,),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then if b is ‹(C (y,)) then c (y,)›››; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:6 = 3: [C 2: [C 1: p:6]]
//│ def c:7 = 13: (fun x:8 -> 12: case 4: x:8 of {C a:9 -> 11: case 5: a:9 of {C b:10 -> 10: case 6: b:10 of {C y:11 -> 9: (7: c:7 8: y:11)}}})
//│ 16: (14: c:7 15: p:6)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([]: C(([-p:6^1]: 0'p)))) <: 2'x
//│ 	[-p:6^1 · -p:6^1 · -p:6^1 · -p:6^15 · +c:7^14 · +c:7^7 · +c:7^7]  --->  [-p:6^15 · +c:7^14]




let rec p = C(C(p))
fun c(x) = if x is
    C(a) then c(a)
fun id2(yy) = yy
fun id(y) = id2(y)
c(id(p))
//│ |#let| |#rec| |p| |#=| |C|(|C|(|p|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id2|(|yy|)| |#=| |yy|↵|#fun| |id|(|y|)| |#=| |id2|(|y|)|↵|c|(|id|(|p|)|)|
//│ Parsed: {let rec p = C (C (p,),); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun id2 = yy, => yy; fun id = y, => id2 (y,); c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:6 = 3: [C 2: [C 1: p:6]]
//│ def c:7 = 9: (fun x:10 -> 8: case 4: x:10 of {C a:11 -> 7: (5: c:7 6: a:11)})
//│ def id2:8 = 11: (fun yy:12 -> 10: yy:12)
//│ def id:9 = 15: (fun y:13 -> 14: (12: id2:8 13: y:13))
//│ 20: (16: c:7 19: (17: id:9 18: p:6))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([]: C(([-p:6^1]: 0'p)))) <: 4'x
//│ 	[-p:6^1 · -p:6^18 · +id:9^17 · +id2:8^12 · -id2:8^12 · -id:9^17 · +c:7^16 · +c:7^5 · +c:7^5]  --->  [-p:6^18 · +id:9^17 · +id2:8^12 · -id2:8^12 · -id:9^17 · +c:7^16]
//│ 		[-p:6^1 · -p:6^18 · +c:7^16 · +c:7^5 · +c:7^5]  --->  [-p:6^18 · +c:7^16]

fun sum(ls) = if ls is
    C(h, t) then S(N, sum(t))
fun mapa(lsa) = if lsa is
    C(ha, ta) then C(primitive(ha), mapa(ta))
fun mapb(lsb) = if lsb is
    C(hb, tb) then C(primitive(hb), mapb(tb))
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),)›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),)›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),)›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def sum:6 = 8: (fun ls:9 -> 7: case 1: ls:9 of {C h:10 t:11 -> 6: [S 2: [N] 5: (3: sum:6 4: t:11)]})
//│ def mapa:7 = 18: (fun lsa:12 -> 17: case 9: lsa:12 of {C ha:13 ta:14 -> 16: [C 12: (10: primitive:3 11: ha:13) 15: (13: mapa:7 14: ta:14)]})
//│ def mapb:8 = 28: (fun lsb:15 -> 27: case 19: lsb:15 of {C hb:16 tb:17 -> 26: [C 22: (20: primitive:3 21: hb:16) 25: (23: mapb:8 24: tb:17)]})
//│ 35: (29: sum:6 34: (30: mapa:7 33: (31: mapb:8 32: primitive:3)))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([]: 11'12_callres), ([]: 12'15_callres)) <: 3'ls
//│ 	[-mapa:7^13 · -mapa:7^13 · -mapa:7^30 · +sum:6^29 · +sum:6^3 · +sum:6^3]  --->  [-mapa:7^13 · -mapa:7^30 · +sum:6^29 · +sum:6^3]
//│ C(([]: 17'22_callres), ([]: 18'25_callres)) <: 8'lsa
//│ 	[-mapb:8^23 · -mapb:8^23 · -mapb:8^31 · +mapa:7^30 · +mapa:7^13 · +mapa:7^13]  --->  [-mapb:8^23 · -mapb:8^31 · +mapa:7^30 · +mapa:7^13]


if C(A, B(C)) is
    C(a, b) then D(b)
//│ |#if| |C|(|A|,| |B|(|C|)|)| |is|→|C|(|a|,| |b|)| |#then| |D|(|b|)|←|
//│ Parsed: {if C (A, B (C,),) is ‹(C (a, b,)) then D (b,)›}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ 7: case 4: [C 1: [A] 3: [B 2: [C]]] of {C a:6 b:7 -> 6: [D 5: b:7]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│



let rec p = C(C(C(p)))
fun ca(x) = if x is
    C(a) then cb(a)
fun cb(x) = if x is
    C(b) then ca(b)
ca(p)
//│ |#let| |#rec| |p| |#=| |C|(|C|(|C|(|p|)|)|)|↵|#fun| |ca|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |cb|(|a|)|←|↵|#fun| |cb|(|x|)| |#=| |#if| |x| |is|→|C|(|b|)| |#then| |ca|(|b|)|←|↵|ca|(|p|)|
//│ Parsed: {let rec p = C (C (C (p,),),); fun ca = x, => if x is ‹(C (a,)) then cb (a,)›; fun cb = x, => if x is ‹(C (b,)) then ca (b,)›; ca (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:6 = 4: [C 3: [C 2: [C 1: p:6]]]
//│ def ca:7 = 10: (fun x:9 -> 9: case 5: x:9 of {C a:10 -> 8: (6: cb:8 7: a:10)})
//│ def cb:8 = 16: (fun x:11 -> 15: case 11: x:11 of {C b:12 -> 14: (12: ca:7 13: b:12)})
//│ 19: (17: ca:7 18: p:6)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([]: C(([]: C(([-p:6^1]: 0'p)))))) <: 3'x
//│ 	[-p:6^1 · -p:6^1 · -p:6^18 · +ca:7^17 · +cb:8^6 · +ca:7^12 · +cb:8^6 · +ca:7^12 · +cb:8^6 · +ca:7^12]  --->  [-p:6^18 · +ca:7^17]


fun c1(x1) = if x1 is
    C(a) then c2(a)
fun c2(x2) = if x2 is
    C(b) then c1(b)
let p1 = C(C(C(p2)))
let p2 = C(p1)
c1(p1)
//│ |#fun| |c1|(|x1|)| |#=| |#if| |x1| |is|→|C|(|a|)| |#then| |c2|(|a|)|←|↵|#fun| |c2|(|x2|)| |#=| |#if| |x2| |is|→|C|(|b|)| |#then| |c1|(|b|)|←|↵|#let| |p1| |#=| |C|(|C|(|C|(|p2|)|)|)|↵|#let| |p2| |#=| |C|(|p1|)|↵|c1|(|p1|)|
//│ Parsed: {fun c1 = x1, => if x1 is ‹(C (a,)) then c2 (a,)›; fun c2 = x2, => if x2 is ‹(C (b,)) then c1 (b,)›; let p1 = C (C (C (p2,),),); let p2 = C (p1,); c1 (p1,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def c1:6 = 6: (fun x1:10 -> 5: case 1: x1:10 of {C a:11 -> 4: (2: c2:7 3: a:11)})
//│ def c2:7 = 12: (fun x2:12 -> 11: case 7: x2:12 of {C b:13 -> 10: (8: c1:6 9: b:13)})
//│ def p1:8 = 16: [C 15: [C 14: [C 13: p2:9]]]
//│ def p2:9 = 18: [C 17: p1:8]
//│ 21: (19: c1:6 20: p1:8)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([]: C(([-p2:9^13]: 3'p2)))) <: 8'x2
//│ 	[-p1:8^17 · -p2:9^13 · -p1:8^20 · +c1:6^19 · +c2:7^2 · +c1:6^8 · +c2:7^2 · +c1:6^8 · +c2:7^2]  --->  [-p1:8^20 · +c1:6^19 · +c2:7^2]


fun ff(x) = if x is
    K then T
    KK then TT
    KKKK then TTTT
fun map(ls) = if ls is
    C(h, t) then C(ff(h), map(t))
    N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|ff|(|h|)|,| |map|(|t|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; fun map = ls, => if ls is ‹(C (h, t,)) then C (ff (h,), map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def ff:6 = 6: (fun x:9 -> 5: case 1: x:9 of {K -> 2: [T] | KK -> 3: [TT] | KKKK -> 4: [TTTT]})
//│ def map:7 = 17: (fun ls:10 -> 16: case 7: ls:10 of {C h:11 t:12 -> 14: [C 10: (8: ff:6 9: h:11) 13: (11: map:7 12: t:12)] | N -> 15: [N]})
//│ def l:8 = 24: [C 18: [K] 23: [C 19: [KK] 22: [C 20: [KKKK] 21: [N]]]]
//│ 27: (25: map:7 26: l:8)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------


fun map(ls) = if ls is
    C(h, t) then C(
        (if h is
            K then T
            KK then TT
            KKKK then TTTT
        ),
        map(t)
    )
    N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›, ')', map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def map:6 = 13: (fun ls:8 -> 12: case 1: ls:8 of {C h:9 t:10 -> 10: [C 6: case 2: h:9 of {K -> 3: [T] | KK -> 4: [TT] | KKKK -> 5: [TTTT]} 9: (7: map:6 8: t:10)] | N -> 11: [N]})
//│ def l:7 = 20: [C 14: [K] 19: [C 15: [KK] 18: [C 16: [KKKK] 17: [N]]]]
//│ 23: (21: map:6 22: l:7)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------


fun sum(ls) = if ls is
    C(h, t) then S(N, sum(t))
    N then N
fun mapa(lsa) = if lsa is
    C(ha, ta) then C(primitive(ha), mapa(ta))
    N then N
fun mapb(lsb) = if lsb is
    C(hb, tb) then C(primitive(hb), mapb(tb))
    N then N
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|↵|N| |#then| |N|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|↵|N| |#then| |N|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),); (N) then N›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),); (N) then N›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),); (N) then N›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def sum:6 = 9: (fun ls:9 -> 8: case 1: ls:9 of {C h:10 t:11 -> 6: [S 2: [N] 5: (3: sum:6 4: t:11)] | N -> 7: [N]})
//│ def mapa:7 = 20: (fun lsa:12 -> 19: case 10: lsa:12 of {C ha:13 ta:14 -> 17: [C 13: (11: primitive:3 12: ha:13) 16: (14: mapa:7 15: ta:14)] | N -> 18: [N]})
//│ def mapb:8 = 31: (fun lsb:15 -> 30: case 21: lsb:15 of {C hb:16 tb:17 -> 28: [C 24: (22: primitive:3 23: hb:16) 27: (25: mapb:8 26: tb:17)] | N -> 29: [N]})
//│ 38: (32: sum:6 37: (33: mapa:7 36: (34: mapb:8 35: primitive:3)))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([]: 11'13_callres), ([]: 12'16_callres)) <: 3'ls
//│ 	[-mapa:7^14 · -mapa:7^14 · -mapa:7^33 · +sum:6^32 · +sum:6^3 · +sum:6^3]  --->  [-mapa:7^14 · -mapa:7^33 · +sum:6^32 · +sum:6^3]
//│ C(([]: 17'24_callres), ([]: 18'27_callres)) <: 8'lsa
//│ 	[-mapb:8^25 · -mapb:8^25 · -mapb:8^34 · +mapa:7^33 · +mapa:7^14 · +mapa:7^14]  --->  [-mapb:8^25 · -mapb:8^34 · +mapa:7^33 · +mapa:7^14]



let rec p = C(p)
fun c(x) = if x is
    C(a) then c(a)
fun main(cc) = cc(p)
main(c)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|cc|)| |#=| |cc|(|p|)|↵|main|(|c|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = cc, => cc (p,); main (c,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:6 = 2: [C 1: p:6]
//│ def c:7 = 8: (fun x:9 -> 7: case 3: x:9 of {C a:10 -> 6: (4: c:7 5: a:10)})
//│ def main:8 = 12: (fun cc:11 -> 11: (9: cc:11 10: p:6))
//│ 15: (13: main:8 14: c:7)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([-p:6^1]: 0'p)) <: 3'x
//│ 	[-p:6^1 · -p:6^10 · -main:8^13 · +c:7^14 · +c:7^4]  --->  [-p:6^10 · -main:8^13 · +c:7^14]


// this path seems also to be sensible
let rec p = C(p)
fun c(x) = if x is
    C(a) then c(a)
fun main(pp) = if pp is
    C(b) then if b is
        C(d) then c(d)
main(p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|pp|)| |#=| |#if| |pp| |is|→|C|(|b|)| |#then| |#if| |b| |is|→|C|(|d|)| |#then| |c|(|d|)|←|←|↵|main|(|p|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = pp, => if pp is ‹(C (b,)) then if b is ‹(C (d,)) then c (d,)››; main (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:6 = 2: [C 1: p:6]
//│ def c:7 = 8: (fun x:9 -> 7: case 3: x:9 of {C a:10 -> 6: (4: c:7 5: a:10)})
//│ def main:8 = 16: (fun pp:11 -> 15: case 9: pp:11 of {C b:12 -> 14: case 10: b:12 of {C d:13 -> 13: (11: c:7 12: d:13)}})
//│ 19: (17: main:8 18: p:6)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([-p:6^1]: 0'p)) <: 3'x
//│ 	[-p:6^1 · -p:6^1 · -p:6^1 · -p:6^18 · +main:8^17 · +c:7^11 · +c:7^4]  --->  [-p:6^1 · -p:6^1 · -p:6^18 · +main:8^17 · +c:7^11]


let rec p = C(p)
let c(x) = if x is
    C(a) then c(a)
fun main(cc, pp) = cc(pp)
main(c, p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#let| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|cc|,| |pp|)| |#=| |cc|(|pp|)|↵|main|(|c|,| |p|)|
//│ Parsed: {let rec p = C (p,); let c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = cc, pp, => cc (pp,); main (c, p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:6 = 2: [C 1: p:6]
//│ def c:7 = 8: (fun x:9 -> 7: case 3: x:9 of {C a:10 -> 6: (4: c:7 5: a:10)})
//│ def main:8 = 13: (fun cc:11 -> 12: (fun pp:12 -> 11: (9: cc:11 10: pp:12)))
//│ 18: (16: (14: main:8 15: c:7) 17: p:6)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([-p:6^1]: 0'p)) <: 3'x
//│ 	[-p:6^1 · -p:6^17 · +main:8^14 · -main:8^14 · +c:7^15 · +c:7^4]  --->  [-p:6^17 · +main:8^14 · -main:8^14 · +c:7^15]
//│ 		[-p:6^1 · -p:6^17 · +c:7^15 · +c:7^4]  --->  [-p:6^17 · +c:7^15]


fun cons(y) = if y is
    C(aa) then cons(aa)
fun a(x) = b(x)
fun b(x) = c(x)
fun c(x) = d(cons, x)
fun d(cc, x) = cc(x)
let p = C(p)
a(p)
//│ |#fun| |cons|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |cons|(|aa|)|←|↵|#fun| |a|(|x|)| |#=| |b|(|x|)|↵|#fun| |b|(|x|)| |#=| |c|(|x|)|↵|#fun| |c|(|x|)| |#=| |d|(|cons|,| |x|)|↵|#fun| |d|(|cc|,| |x|)| |#=| |cc|(|x|)|↵|#let| |p| |#=| |C|(|p|)|↵|a|(|p|)|
//│ Parsed: {fun cons = y, => if y is ‹(C (aa,)) then cons (aa,)›; fun a = x, => b (x,); fun b = x, => c (x,); fun c = x, => d (cons, x,); fun d = cc, x, => cc (x,); let p = C (p,); a (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def cons:6 = 6: (fun y:12 -> 5: case 1: y:12 of {C aa:13 -> 4: (2: cons:6 3: aa:13)})
//│ def a:7 = 10: (fun x:14 -> 9: (7: b:8 8: x:14))
//│ def b:8 = 14: (fun x:15 -> 13: (11: c:9 12: x:15))
//│ def c:9 = 20: (fun x:16 -> 19: (17: (15: d:10 16: cons:6) 18: x:16))
//│ def d:10 = 25: (fun cc:17 -> 24: (fun x:18 -> 23: (21: cc:17 22: x:18)))
//│ def p:11 = 27: [C 26: p:11]
//│ 30: (28: a:7 29: p:11)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([-p:11^26]: 5'p)) <: 6'y
//│ 	[-p:11^26 · -p:11^26 · -p:11^29 · +a:7^28 · +b:8^7 · +c:9^11 · +d:10^15 · -d:10^15 · +cons:6^16 · +cons:6^2 · +cons:6^2]  --->  [-p:11^26 · -p:11^29 · +a:7^28 · +b:8^7 · +c:9^11 · +d:10^15 · -d:10^15 · +cons:6^16 · +cons:6^2]
//│ 		[-p:11^26 · -p:11^26 · -p:11^29 · +a:7^28 · +b:8^7 · +c:9^11 · +cons:6^16 · +cons:6^2 · +cons:6^2]  --->  [-p:11^26 · -p:11^29 · +a:7^28 · +b:8^7 · +c:9^11 · +cons:6^16 · +cons:6^2]


let p = C(N)
fun c(x) = if C(x) is
    C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|N|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (N,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:6 = 2: [C 1: [N]]
//│ def c:7 = 9: (fun x:8 -> 8: case 4: [C 3: x:8] of {C a:9 -> 7: (5: c:7 6: a:9)})
//│ 12: (10: c:7 11: p:6)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([]: N)) <: 2'x
//│ 	[-p:6^11 · +c:7^10 · +c:7^5]  --->  [-p:6^11 · +c:7^10]


let rec p = C(p)
let q = p
fun c(x) = if x is
    C(a) then a
fun c2(z) = if z is
    C(b) then c2(b)
let main = c(q)
c2(main)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#let| |q| |#=| |p|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |a|←|↵|#fun| |c2|(|z|)| |#=| |#if| |z| |is|→|C|(|b|)| |#then| |c2|(|b|)|←|↵|#let| |main| |#=| |c|(|q|)|↵|c2|(|main|)|
//│ Parsed: {let rec p = C (p,); let q = p; fun c = x, => if x is ‹(C (a,)) then a›; fun c2 = z, => if z is ‹(C (b,)) then c2 (b,)›; let main = c (q,); c2 (main,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:6 = 2: [C 1: p:6]
//│ def q:7 = 3: p:6
//│ def c:8 = 7: (fun x:11 -> 6: case 4: x:11 of {C a:12 -> 5: a:12})
//│ def c2:9 = 13: (fun z:13 -> 12: case 8: z:13 of {C b:14 -> 11: (9: c2:9 10: b:14)})
//│ def main:10 = 16: (14: c:8 15: q:7)
//│ 19: (17: c2:9 18: main:10)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([-p:6^1]: 0'p)) <: 8'z
//│ 	[-p:6^1 · -p:6^1 · -p:6^3 · -q:7^15 · +c:8^14 · -c:8^14 · -main:10^18 · +c2:9^17 · +c2:9^9]  --->  [-p:6^1 · -p:6^3 · -q:7^15 · +c:8^14 · -c:8^14 · -main:10^18 · +c2:9^17]
//│ 		[-p:6^1 · -p:6^1 · -p:6^3 · -q:7^15 · -main:10^18 · +c2:9^17 · +c2:9^9]  --->  [-p:6^1 · -p:6^3 · -q:7^15 · -main:10^18 · +c2:9^17]


let rec p = C(p)
fun c(x) = if x is
    C(a) then a
fun c1(xx) = if xx is
    C(aa) then aa
fun c2(z) = if z is
    C(b) then c2(b)
let main = c(p)
fun id(y) = c1(C(y))
c2(id(main))
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |a|←|↵|#fun| |c1|(|xx|)| |#=| |#if| |xx| |is|→|C|(|aa|)| |#then| |aa|←|↵|#fun| |c2|(|z|)| |#=| |#if| |z| |is|→|C|(|b|)| |#then| |c2|(|b|)|←|↵|#let| |main| |#=| |c|(|p|)|↵|#fun| |id|(|y|)| |#=| |c1|(|C|(|y|)|)|↵|c2|(|id|(|main|)|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then a›; fun c1 = xx, => if xx is ‹(C (aa,)) then aa›; fun c2 = z, => if z is ‹(C (b,)) then c2 (b,)›; let main = c (p,); fun id = y, => c1 (C (y,),); c2 (id (main,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:6 = 2: [C 1: p:6]
//│ def c:7 = 6: (fun x:12 -> 5: case 3: x:12 of {C a:13 -> 4: a:13})
//│ def c1:8 = 10: (fun xx:14 -> 9: case 7: xx:14 of {C aa:15 -> 8: aa:15})
//│ def c2:9 = 16: (fun z:16 -> 15: case 11: z:16 of {C b:17 -> 14: (12: c2:9 13: b:17)})
//│ def main:10 = 19: (17: c:7 18: p:6)
//│ def id:11 = 24: (fun y:18 -> 23: (20: c1:8 22: [C 21: y:18]))
//│ 29: (25: c2:9 28: (26: id:11 27: main:10))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([-p:6^1]: 0'p)) <: 12'z
//│ 	[-p:6^1 · -p:6^1 · -p:6^18 · +c:7^17 · -c:7^17 · -main:10^27 · +id:11^26 · +c1:8^20 · -c1:8^20 · -id:11^26 · +c2:9^25 · +c2:9^12]  --->  [-p:6^1 · -p:6^18 · +c:7^17 · -c:7^17 · -main:10^27 · +id:11^26 · +c1:8^20 · -c1:8^20 · -id:11^26 · +c2:9^25]
//│ 		[-p:6^1 · -p:6^1 · -p:6^18 · -main:10^27 · +c2:9^25 · +c2:9^12]  --->  [-p:6^1 · -p:6^18 · -main:10^27 · +c2:9^25]


let t = T(K, T(N, L, L), T(N, L, L))
fun c(x) = if x is
    T(n, l, r) then T(
        (if n is
            K then KK
            N then NN
        ),
        c(l),
        c(r)
    )
    L then LL
c(t)
//│ |#let| |t| |#=| |T|(|K|,| |T|(|N|,| |L|,| |L|)|,| |T|(|N|,| |L|,| |L|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let t = T (K, T (N, L, L,), T (N, L, L,),); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def t:6 = 10: [T 1: [K] 5: [T 2: [N] 3: [L] 4: [L]] 9: [T 6: [N] 7: [L] 8: [L]]]
//│ def c:7 = 25: (fun x:8 -> 24: case 11: x:8 of {T n:9 l:10 r:11 -> 22: [T 15: case 12: n:9 of {K -> 13: [KK] | N -> 14: [NN]} 18: (16: c:7 17: l:10) 21: (19: c:7 20: r:11)] | L -> 23: [LL]})
//│ 28: (26: c:7 27: t:6)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------


let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
    T(n, l, r) then T(
        (if n is
            K then KK
            N then NN
        ),
        c(l),
        c(r)
    )
    L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def aa:6 = 4: [T 1: [N] 2: [L] 3: [L]]
//│ def bb:7 = 8: [T 5: [N] 6: [L] 7: [L]]
//│ def t:8 = 12: [T 9: [K] 10: aa:6 11: bb:7]
//│ def c:9 = 27: (fun x:10 -> 26: case 13: x:10 of {T n:11 l:12 r:13 -> 24: [T 17: case 14: n:11 of {K -> 15: [KK] | N -> 16: [NN]} 20: (18: c:9 19: l:12) 23: (21: c:9 22: r:13)] | L -> 25: [LL]})
//│ 30: (28: c:9 29: t:8)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------


fun map(ls) = if ls is
    C(h, t) then f => C(f(h), map(t)(f))
    N then f => N
let l = C(K, N)
map(l)(
    x => if x is
        K then T
)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#let| |l| |#=| |C|(|K|,| |N|)|↵|map|(|l|)|(|→|x| |=>| |#if| |x| |is|→|K| |#then| |T|←|←|↵|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then f, => C (f (h,), map (t,) (f,),); (N) then f, => N›; let l = C (K, N,); map (l,) (x, => if x is ‹(K) then T›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def map:6 = 15: (fun ls:8 -> 14: case 1: ls:8 of {C h:9 t:10 -> 11: (fun f:11 -> 10: [C 4: (2: f:11 3: h:9) 9: (7: (5: map:6 6: t:10) 8: f:11)]) | N -> 13: (fun f:12 -> 12: [N])})
//│ def l:7 = 18: [C 16: [K] 17: [N]]
//│ 26: (21: (19: map:6 20: l:7) 25: (fun x:13 -> 24: case 22: x:13 of {K -> 23: [T]}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ([]: 12'x) => ([]: 13'24_matchres) <: 5'f
//│ 	[+map:6^19 · +map:6^5 · +map:6^5]  --->  [+map:6^19 · +map:6^5]


fun inter(xs) = if xs is
    N then ys => ys
    C(h, t) then ys => C(h, inter(ys)(t))
let rec l1 = C(1, C(2, l1))
let rec l2 = C(9, C(8, l2))
inter(l1)(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |#rec| |l1| |#=| |C|(|1|,| |C|(|2|,| |l1|)|)|↵|#let| |#rec| |l2| |#=| |C|(|9|,| |C|(|8|,| |l2|)|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let rec l1 = C (1, C (2, l1,),); let rec l2 = C (9, C (8, l2,),); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def inter:6 = 13: (fun xs:9 -> 12: case 1: xs:9 of {N -> 3: (fun ys:10 -> 2: ys:10) | C h:11 t:12 -> 11: (fun ys:13 -> 10: [C 4: h:11 9: (7: (5: inter:6 6: ys:13) 8: t:12)])})
//│ def l1:7 = 18: [C 14: 1 17: [C 15: 2 16: l1:7]]
//│ def l2:8 = 23: [C 19: 9 22: [C 20: 8 21: l2:8]]
//│ 28: (26: (24: inter:6 25: l1:7) 27: l2:8)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ C(([]: Int), ([-l1:7^16]: 1'l1)) <: 7'ys
//│ 	[-l1:7^16 · -l1:7^25 · +inter:6^24 · +inter:6^5 · +inter:6^5 · +inter:6^5 · +inter:6^5 · +inter:6^5]  --->  [-l1:7^25 · +inter:6^24 · +inter:6^5]
//│ C(([]: Int), ([-l2:8^21]: 2'l2)) <: 7'ys
//│ 	[-l2:8^21 · -l2:8^27 · +inter:6^24 · +inter:6^5 · +inter:6^5 · +inter:6^5 · +inter:6^5 · +inter:6^5 · +inter:6^5]  --->  [-l2:8^27 · +inter:6^24 · +inter:6^5 · +inter:6^5]


fun last(ys) = if ys is
    N then x => x
    C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
    N then None
    C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def last:6 = 11: (fun ys:8 -> 10: case 1: ys:8 of {N -> 3: (fun x:9 -> 2: x:9) | C h:10 t:11 -> 9: (fun x:12 -> 8: (6: (4: last:6 5: t:11) 7: h:10))})
//│ def lastDrive:7 = 21: (fun xs:13 -> 20: case 12: xs:13 of {N -> 13: [None] | C hh:14 tt:15 -> 19: [Some 18: (16: (14: last:6 15: tt:15) 17: hh:14)]})
//│ 28: (22: lastDrive:7 27: [C 23: 1 26: [C 24: 2 25: [N]]])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ Int <: 8'8_callres
//│ 	[+lastDrive:7^22 · +last:6^14 · -last:6^4 · -last:6^4 · -last:6^4]  --->  [+lastDrive:7^22 · +last:6^14 · -last:6^4 · -last:6^4]
//│ 	[+lastDrive:7^22 · +last:6^14 · +last:6^4 · -last:6^4 · -last:6^4 · -last:6^4]  --->  [+lastDrive:7^22 · +last:6^14 · +last:6^4 · -last:6^4 · -last:6^4]
//│ 		[+lastDrive:7^22 · +last:6^14 · -last:6^4 · -last:6^4]  --->  [+lastDrive:7^22 · +last:6^14 · -last:6^4]
