:NewParser
:ParseOnly



// CORRECT:
let p = C(1, C(2, N))
fun e(z) = if z is
  C(aaa, bbb) then bbb
  N then 7
fun d(y) = if y is
  C(aa, bb) then e(bb)
  N then 5
fun c(x) = if x is
  C(a, b) then d(b)
  N then 3
c(p)
//│ |#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#fun| |e|(|z|)| |#=| |#if| |z| |is|→|C|(|aaa|,| |bbb|)| |#then| |bbb|↵|N| |#then| |7|←|↵|#fun| |d|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|,| |bb|)| |#then| |e|(|bb|)|↵|N| |#then| |5|←|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|,| |b|)| |#then| |d|(|b|)|↵|N| |#then| |3|←|↵|c|(|p|)|
//│ Parsed: {let p = C (1, C (2, N,),); fun e = z, => if z is ‹(C (aaa, bbb,)) then bbb; (N) then 7›; fun d = y, => if y is ‹(C (aa, bb,)) then e (bb,); (N) then 5›; fun c = x, => if x is ‹(C (a, b,)) then d (b,); (N) then 3›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^25 p^26)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ b⁰ => (d^19 b⁰)
//│ 	| N => 3})
//│ def d = (fun y⁰ -> case y⁰ of {
//│ 	C aa⁰ bb⁰ => (e^12 bb⁰)
//│ 	| N => 5})
//│ def e = (fun z⁰ -> case z⁰ of {
//│ 	C aaa⁰ bbb⁰ => bbb⁰
//│ 	| N => 7})
//│ def p = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^25] (hopeless to continue)
//│ 	[c^25 · d^19] (using original def)
//│ 		[c^25 · d^19 · e^12] (using original def)
//│ [p^26] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C a¹ b¹ => (d₀ b¹)
//│ 		| N => 3})
//│ 	where
//│ 	def d₀ = 
//│ 		(fun y¹ -> case y¹ of {
//│ 			C aa¹ bb¹ => (e₀ bb¹)
//│ 			| N => 5})
//│ 		where
//│ 		def e₀ = 
//│ 			(fun z¹ -> case z¹ of {
//│ 				C aaa¹ bbb¹ => bbb¹
//│ 				| N => 7})
//│ def p₀ = 
//│ 	[C 1 [C 2 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 37 --->
//│ 	case z¹ of {C aaa¹ bbb¹ => bbb¹ | N => 7}: 43
//│ [C 2 [N]]: 38 --->
//│ 	case y¹ of {C aa¹ bb¹ => (e₀ bb¹) | N => 5}: 50
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case x¹ of {C a¹ b¹ => (d₀ b¹) | N => 3}: 33
//│ ------------------
//│ case x¹ of {C a¹ b¹ => (d₀ b¹) | N => 3}: 33 --->
//│ 	[C 1 [C 2 [N]]]: 39
//│ case z¹ of {C aaa¹ bbb¹ => bbb¹ | N => 7}: 43 --->
//│ 	[N]: 37
//│ case y¹ of {C aa¹ bb¹ => (e₀ bb¹) | N => 5}: 50 --->
//│ 	[C 2 [N]]: 38
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 37 --->
//│ 	case z¹ of {C aaa¹ bbb¹ => bbb¹ | N => 7}: 43
//│ [C 2 [N]]: 38 --->
//│ 	case y¹ of {C aa¹ bb¹ => (e₀ bb¹) | N => 5}: 50
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case x¹ of {C a¹ b¹ => (d₀ b¹) | N => 3}: 33
//│ ------------------
//│ case x¹ of {C a¹ b¹ => (d₀ b¹) | N => 3}: 33 --->
//│ 	[C 1 [C 2 [N]]]: 39
//│ case z¹ of {C aaa¹ bbb¹ => bbb¹ | N => 7}: 43 --->
//│ 	[N]: 37
//│ case y¹ of {C aa¹ bb¹ => (e₀ bb¹) | N => 5}: 50 --->
//│ 	[C 2 [N]]: 38
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x² -> x²)
//│ 	where
//│ 	def d₀ = 
//│ 		(fun y² -> y²)
//│ 		where
//│ 		def e₀ = 
//│ 			(fun z² -> z²)
//│ def p₀ = 
//│ 	let a² = 1
//│ 	in let b² = 	
//│ 		let aa² = 2
//│ 		in let bb² = 7
//│ 		in (e₀ bb²)
//│ 	in (d₀ b²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c₀^1] (hopeless to continue)
//│ [p₀^2] (hopeless to continue)
//│ 	[p₀^2 · d₀^14] (using original def)
//│ 	[p₀^2 · e₀^9] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀₀ p₀₀)
//│ def c₀₀ = 
//│ 	(fun x¹ -> x¹)
//│ def p₀₀ = 
//│ 	let a¹ = 1
//│ 	in let b¹ = 	
//│ 		let aa¹ = 2
//│ 		in let bb¹ = 7
//│ 		in (e₀₀ bb¹)
//│ 	in (d₀₀ b¹)
//│ 	where
//│ 	def d₀₀ = 
//│ 		(fun y¹ -> y¹)
//│ 	def e₀₀ = 
//│ 		(fun z¹ -> z¹)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀₀ p₀₀)
//│ def c₀₀ = 
//│ 	(fun x² -> x²)
//│ def p₀₀ = 
//│ 	let a¹ = 1
//│ 	in let b¹ = 	
//│ 		let aa¹ = 2
//│ 		in let bb¹ = 7
//│ 		in (e₀₀ bb¹)
//│ 	in (d₀₀ b¹)
//│ 	where
//│ 	def d₀₀ = 
//│ 		(fun y² -> y²)
//│ 	def e₀₀ = 
//│ 		(fun z² -> z²)
//│ <<<<<<< after fusion <<<<<<<



// CORRECT:
fun sum(ls) = if ls is
  C(h, t) then S(N, sum(t))
fun mapa(lsa) = if lsa is
  C(ha, ta) then C(primitive(ha), mapa(ta))
fun mapb(lsb) = if lsb is
  C(hb, tb) then C(primitive(hb), mapb(tb))
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),)›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),)›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),)›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (sum^29 (mapa^30 (mapb^31 primitive⁰)))
//│ def mapa = (fun lsa⁰ -> case lsa⁰ of {
//│ 	C ha⁰ ta⁰ => [C (primitive⁰ ha⁰) (mapa^13 ta⁰)]})
//│ def mapb = (fun lsb⁰ -> case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => [C (primitive⁰ hb⁰) (mapb^23 tb⁰)]})
//│ def sum = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [S [N] (sum^3 t⁰)]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa^30]
//│ 	[mapa^30 · mapa^13] ---> [mapa^30] (only one)
//│ [mapb^31]
//│ 	[mapb^31 · mapb^23] ---> [mapb^31] (only one)
//│ [sum^29]
//│ 	[sum^29 · sum^3] ---> [sum^29] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (sum₀ (mapa₀ (mapb₀ primitive⁰)))
//│ def mapa₀ = 
//│ 	(fun lsa¹ -> case lsa¹ of {
//│ 		C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₀ ta¹)]})
//│ def mapb₀ = 
//│ 	(fun lsb¹ -> case lsb¹ of {
//│ 		C hb¹ tb¹ => [C (primitive⁰ hb¹) (mapb₀ tb¹)]})
//│ def sum₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => [S [N] (sum₀ t¹)]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C (primitive⁰ hb¹) (mapb₀ tb¹)]: 51 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₀ ta¹)]}: 62
//│ [C (primitive⁰ ha¹) (mapa₀ ta¹)]: 61 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] (sum₀ t¹)]}: 42
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] (sum₀ t¹)]}: 42 --->
//│ 	[C (primitive⁰ ha¹) (mapa₀ ta¹)]: 61
//│ case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₀ ta¹)]}: 62 --->
//│ 	[C (primitive⁰ hb¹) (mapb₀ tb¹)]: 51
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C (primitive⁰ hb¹) (mapb₀ tb¹)]: 51 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₀ ta¹)]}: 62
//│ [C (primitive⁰ ha¹) (mapa₀ ta¹)]: 61 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] (sum₀ t¹)]}: 42
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] (sum₀ t¹)]}: 42 --->
//│ 	[C (primitive⁰ ha¹) (mapa₀ ta¹)]: 61
//│ case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₀ ta¹)]}: 62 --->
//│ 	[C (primitive⁰ hb¹) (mapb₀ tb¹)]: 51
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (sum₀ (mapa₀ (mapb₀ primitive⁰)))
//│ def mapa₀ = 
//│ 	(fun lsa² -> lsa²)
//│ def mapb₀ = 
//│ 	(fun lsb² -> case lsb² of {
//│ 		C hb¹ tb¹ => 
//│ 			let ha² = (primitive⁰ hb¹)
//│ 			in let ta² = (mapb₀ tb¹)
//│ 			in let h² = (primitive⁰ ha²)
//│ 			in let t² = (mapa₀ ta²)
//│ 			in [S [N] (sum₀ t²)]})
//│ def sum₀ = 
//│ 	(fun ls² -> ls²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa₀^2] (hopeless to continue)
//│ [mapb₀^3] (hopeless to continue)
//│ 	[mapb₀^3 · mapa₀^20] (using original def)
//│ 	[mapb₀^3 · mapb₀^14] ---> [mapb₀^3] (using original def)
//│ 	[mapb₀^3 · sum₀^24] (using original def)
//│ [sum₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (sum₀₁ (mapa₀₀ (mapb₀₀ primitive⁰)))
//│ def mapa₀₀ = 
//│ 	(fun lsa² -> lsa²)
//│ def mapb₀₀ = 
//│ 	(fun lsb¹ -> case lsb¹ of {
//│ 		C hb¹ tb¹ => 
//│ 			let ha¹ = (primitive⁰ hb¹)
//│ 			in let ta¹ = (mapb₀₀ tb¹)
//│ 			in let h¹ = (primitive⁰ ha¹)
//│ 			in let t¹ = (mapa₀₁ ta¹)
//│ 			in [S [N] (sum₀₀ t¹)]})
//│ 	where
//│ 	def mapa₀₁ = 
//│ 		(fun lsa¹ -> lsa¹)
//│ 	def sum₀₀ = 
//│ 		(fun ls² -> ls²)
//│ def sum₀₁ = 
//│ 	(fun ls¹ -> ls¹)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (sum₀₁ (mapa₀₀ (mapb₀₀ primitive⁰)))
//│ def mapa₀₀ = 
//│ 	(fun lsa⁴ -> lsa⁴)
//│ def mapb₀₀ = 
//│ 	(fun lsb² -> case lsb² of {
//│ 		C hb¹ tb¹ => 
//│ 			let ha¹ = (primitive⁰ hb¹)
//│ 			in let ta¹ = (mapb₀₀ tb¹)
//│ 			in let h¹ = (primitive⁰ ha¹)
//│ 			in let t¹ = (mapa₀₁ ta¹)
//│ 			in [S [N] (sum₀₀ t¹)]})
//│ 	where
//│ 	def mapa₀₁ = 
//│ 		(fun lsa³ -> lsa³)
//│ 	def sum₀₀ = 
//│ 		(fun ls⁴ -> ls⁴)
//│ def sum₀₁ = 
//│ 	(fun ls³ -> ls³)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
if C(A, B(C)) is
  C(a, b) then D(b)
//│ |#if| |C|(|A|,| |B|(|C|)|)| |is|→|C|(|a|,| |b|)| |#then| |D|(|b|)|←|
//│ Parsed: {if C (A, B (C,),) is ‹(C (a, b,)) then D (b,)›}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a⁰ b⁰ => [D b⁰]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a¹ b¹ => [D b¹]}
//│ 
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A] [B [C]]]: 11 --->
//│ 	case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14
//│ ------------------
//│ case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14 --->
//│ 	[C [A] [B [C]]]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [A] [B [C]]]: 11 --->
//│ 	case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14
//│ ------------------
//│ case [C [A] [B [C]]] of {C a¹ b¹ => [D b¹]}: 14 --->
//│ 	[C [A] [B [C]]]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let a² = [A]
//│ 	in let b² = [B [C]]
//│ 	in [D b²]
//│ 
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ 
//│ 	let a¹ = [A]
//│ 	in let b¹ = [B [C]]
//│ 	in [D b¹]
//│ 
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let a¹ = [A]
//│ 	in let b¹ = [B [C]]
//│ 	in [D b¹]
//│ 
//│ <<<<<<< after fusion <<<<<<<
//│




// def p:6^18 =
//      ... p:6^1 ~> p:6^18.p:6^1 ...

// def p:6^18.p:6^1 =
//      ... p:6^1 ~> p:6^18 ...

// def ca:7^17
//      ... 



// CORRECT: every element is handled
fun ff(x) = if x is
  K then T
  KK then TT
  KKKK then TTTT
fun map(ls) = if ls is
  C(h, t) then C(ff(h), map(t))
  N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|ff|(|h|)|,| |map|(|t|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; fun map = ls, => if ls is ‹(C (h, t,)) then C (ff (h,), map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^25 l^26)
//│ def ff = (fun x⁰ -> case x⁰ of {
//│ 	K => [T]
//│ 	| KK => [TT]
//│ 	| KKKK => [TTTT]})
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C (ff^8 h⁰) (map^11 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^26] (hopeless to continue)
//│ [map^25] (hopeless to continue)
//│ 	[map^25 · ff^8] (using original def)
//│ 	[map^25 · map^11] ---> [map^25] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => [C (ff₀ h¹) (map₀ t¹)]
//│ 		| N => [N]})
//│ 	where
//│ 	def ff₀ = 
//│ 		(fun x¹ -> case x¹ of {
//│ 			K => [T]
//│ 			| KK => [TT]
//│ 			| KKKK => [TTTT]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 39 --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 50
//│ [KK]: 40 --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 50
//│ [KKKK]: 41 --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 50
//│ [N]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (ff₀ h¹) (map₀ t¹)] | N => [N]}: 37
//│ [C [KKKK] [N]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (ff₀ h¹) (map₀ t¹)] | N => [N]}: 37
//│ [C [KK] [C [KKKK] [N]]]: 44 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (ff₀ h¹) (map₀ t¹)] | N => [N]}: 37
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 45 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (ff₀ h¹) (map₀ t¹)] | N => [N]}: 37
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C (ff₀ h¹) (map₀ t¹)] | N => [N]}: 37 --->
//│ 	[N]: 42
//│ 	[C [KKKK] [N]]: 43
//│ 	[C [KK] [C [KKKK] [N]]]: 44
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 45
//│ case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 50 --->
//│ 	[K]: 39
//│ 	[KK]: 40
//│ 	[KKKK]: 41
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 39 --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 50
//│ [KK]: 40 --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 50
//│ [KKKK]: 41 --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 50
//│ [N]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (ff₀ h¹) (map₀ t¹)] | N => [N]}: 37
//│ [C [KKKK] [N]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (ff₀ h¹) (map₀ t¹)] | N => [N]}: 37
//│ [C [KK] [C [KKKK] [N]]]: 44 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (ff₀ h¹) (map₀ t¹)] | N => [N]}: 37
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 45 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (ff₀ h¹) (map₀ t¹)] | N => [N]}: 37
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [C (ff₀ h¹) (map₀ t¹)] | N => [N]}: 37 --->
//│ 	[N]: 42
//│ 	[C [KKKK] [N]]: 43
//│ 	[C [KK] [C [KKKK] [N]]]: 44
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 45
//│ case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 50 --->
//│ 	[K]: 39
//│ 	[KK]: 40
//│ 	[KKKK]: 41
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	let h² = [T]
//│ 	in let t² = 	
//│ 		let h³ = [TT]
//│ 		in let t³ = 	
//│ 			let h⁴ = [TTTT]
//│ 			in let t⁴ = [N]
//│ 			in [C (ff₀ h⁴) (map₀ t⁴)]
//│ 		in [C (ff₀ h³) (map₀ t³)]
//│ 	in [C (ff₀ h²) (map₀ t²)]
//│ def map₀ = 
//│ 	(fun ls² -> ls²)
//│ 	where
//│ 	def ff₀ = 
//│ 		(fun x² -> x²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l₀^2] (hopeless to continue)
//│ 	[l₀^2 · ff₀^10] (using original def)
//│ 	[l₀^2 · ff₀^19] (using original def)
//│ 	[l₀^2 · ff₀^28] (using original def)
//│ 	[l₀^2 · map₀^13] (using original def)
//│ 	[l₀^2 · map₀^22] (using original def)
//│ 	[l₀^2 · map₀^31] (using original def)
//│ [map₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀₃ l₀₀)
//│ def l₀₀ = 
//│ 	let h³ = [T]
//│ 	in let t³ = 	
//│ 		let h⁴ = [TT]
//│ 		in let t⁴ = 	
//│ 			let h⁵ = [TTTT]
//│ 			in let t⁵ = [N]
//│ 			in [C (ff₀₀ h⁵) (map₀₀ t⁵)]
//│ 		in [C (ff₀₁ h⁴) (map₀₁ t⁴)]
//│ 	in [C (ff₀₂ h³) (map₀₂ t³)]
//│ 	where
//│ 	def ff₀₀ = 
//│ 		(fun x² -> x²)
//│ 	def ff₀₁ = 
//│ 		(fun x³ -> x³)
//│ 	def ff₀₂ = 
//│ 		(fun x¹ -> x¹)
//│ 	def map₀₀ = 
//│ 		(fun ls³ -> ls³)
//│ 	def map₀₁ = 
//│ 		(fun ls¹ -> ls¹)
//│ 	def map₀₂ = 
//│ 		(fun ls² -> ls²)
//│ def map₀₃ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀₃ l₀₀)
//│ def l₀₀ = 
//│ 	let h³ = [T]
//│ 	in let t³ = 	
//│ 		let h⁴ = [TT]
//│ 		in let t⁴ = 	
//│ 			let h⁵ = [TTTT]
//│ 			in let t⁵ = [N]
//│ 			in [C (ff₀₀ h⁵) (map₀₀ t⁵)]
//│ 		in [C (ff₀₁ h⁴) (map₀₁ t⁴)]
//│ 	in [C (ff₀₂ h³) (map₀₂ t³)]
//│ 	where
//│ 	def ff₀₀ = 
//│ 		(fun x⁴ -> x⁴)
//│ 	def ff₀₁ = 
//│ 		(fun x⁵ -> x⁵)
//│ 	def ff₀₂ = 
//│ 		(fun x⁶ -> x⁶)
//│ 	def map₀₀ = 
//│ 		(fun ls⁵ -> ls⁵)
//│ 	def map₀₁ = 
//│ 		(fun ls⁸ -> ls⁸)
//│ 	def map₀₂ = 
//│ 		(fun ls⁷ -> ls⁷)
//│ def map₀₃ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: every element is handled
fun map(ls) = if ls is
  C(h, t) then C(
    (if h is
      K then T
      KK then TT
      KKKK then TTTT
    ),
    map(t)
  )
  N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›, ')', map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^21 l^22)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C case h⁰ of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} (map^7 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^22] (hopeless to continue)
//│ [map^21] (hopeless to continue)
//│ 	[map^21 · map^7] ---> [map^21] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => [C case h¹ of {
//│ 			K => [T]
//│ 			| KK => [TT]
//│ 			| KKKK => [TTTT]} (map₀ t¹)]
//│ 		| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 37 --->
//│ 	case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 29
//│ [KK]: 38 --->
//│ 	case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 29
//│ [KKKK]: 39 --->
//│ 	case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 29
//│ [N]: 40 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₀ t¹)] | N => [N]}: 35
//│ [C [KKKK] [N]]: 41 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₀ t¹)] | N => [N]}: 35
//│ [C [KK] [C [KKKK] [N]]]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₀ t¹)] | N => [N]}: 35
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₀ t¹)] | N => [N]}: 35
//│ ------------------
//│ case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 29 --->
//│ 	[K]: 37
//│ 	[KK]: 38
//│ 	[KKKK]: 39
//│ case ls¹ of {C h¹ t¹ => [C case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₀ t¹)] | N => [N]}: 35 --->
//│ 	[N]: 40
//│ 	[C [KKKK] [N]]: 41
//│ 	[C [KK] [C [KKKK] [N]]]: 42
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 43
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 37 --->
//│ 	case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 29
//│ [KK]: 38 --->
//│ 	case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 29
//│ [KKKK]: 39 --->
//│ 	case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 29
//│ [N]: 40 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₀ t¹)] | N => [N]}: 35
//│ [C [KKKK] [N]]: 41 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₀ t¹)] | N => [N]}: 35
//│ [C [KK] [C [KKKK] [N]]]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₀ t¹)] | N => [N]}: 35
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 43 --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₀ t¹)] | N => [N]}: 35
//│ ------------------
//│ case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 29 --->
//│ 	[K]: 37
//│ 	[KK]: 38
//│ 	[KKKK]: 39
//│ case ls¹ of {C h¹ t¹ => [C case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₀ t¹)] | N => [N]}: 35 --->
//│ 	[N]: 40
//│ 	[C [KKKK] [N]]: 41
//│ 	[C [KK] [C [KKKK] [N]]]: 42
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 43
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	let h² = [T]
//│ 	in let t² = 	
//│ 		let h³ = [TT]
//│ 		in let t³ = 	
//│ 			let h⁴ = [TTTT]
//│ 			in let t⁴ = [N]
//│ 			in [C h⁴ (map₀ t⁴)]
//│ 		in [C h³ (map₀ t³)]
//│ 	in [C h² (map₀ t²)]
//│ def map₀ = 
//│ 	(fun ls² -> ls²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l₀^2] (hopeless to continue)
//│ 	[l₀^2 · map₀^11] (using original def)
//│ 	[l₀^2 · map₀^18] (using original def)
//│ 	[l₀^2 · map₀^25] (using original def)
//│ [map₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀₃ l₀₀)
//│ def l₀₀ = 
//│ 	let h³ = [T]
//│ 	in let t³ = 	
//│ 		let h⁴ = [TT]
//│ 		in let t⁴ = 	
//│ 			let h⁵ = [TTTT]
//│ 			in let t⁵ = [N]
//│ 			in [C h⁵ (map₀₀ t⁵)]
//│ 		in [C h⁴ (map₀₁ t⁴)]
//│ 	in [C h³ (map₀₂ t³)]
//│ 	where
//│ 	def map₀₀ = 
//│ 		(fun ls² -> ls²)
//│ 	def map₀₁ = 
//│ 		(fun ls¹ -> ls¹)
//│ 	def map₀₂ = 
//│ 		(fun ls³ -> ls³)
//│ def map₀₃ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀₃ l₀₀)
//│ def l₀₀ = 
//│ 	let h³ = [T]
//│ 	in let t³ = 	
//│ 		let h⁴ = [TT]
//│ 		in let t⁴ = 	
//│ 			let h⁵ = [TTTT]
//│ 			in let t⁵ = [N]
//│ 			in [C h⁵ (map₀₀ t⁵)]
//│ 		in [C h⁴ (map₀₁ t⁴)]
//│ 	in [C h³ (map₀₂ t³)]
//│ 	where
//│ 	def map₀₀ = 
//│ 		(fun ls⁵ -> ls⁵)
//│ 	def map₀₁ = 
//│ 		(fun ls⁸ -> ls⁸)
//│ 	def map₀₂ = 
//│ 		(fun ls⁷ -> ls⁷)
//│ def map₀₃ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
fun sum(ls) = if ls is
  C(h, t) then S(N, sum(t))
  N then N
fun mapa(lsa) = if lsa is
  C(ha, ta) then C(primitive(ha), mapa(ta))
  N then N
fun mapb(lsb) = if lsb is
  C(hb, tb) then C(primitive(hb), mapb(tb))
  N then N
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|↵|N| |#then| |N|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|↵|N| |#then| |N|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),); (N) then N›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),); (N) then N›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),); (N) then N›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (sum^32 (mapa^33 (mapb^34 primitive⁰)))
//│ def mapa = (fun lsa⁰ -> case lsa⁰ of {
//│ 	C ha⁰ ta⁰ => [C (primitive⁰ ha⁰) (mapa^14 ta⁰)]
//│ 	| N => [N]})
//│ def mapb = (fun lsb⁰ -> case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => [C (primitive⁰ hb⁰) (mapb^25 tb⁰)]
//│ 	| N => [N]})
//│ def sum = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [S [N] (sum^3 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa^33]
//│ 	[mapa^33 · mapa^14] ---> [mapa^33] (only one)
//│ [mapb^34]
//│ 	[mapb^34 · mapb^25] ---> [mapb^34] (only one)
//│ [sum^32]
//│ 	[sum^32 · sum^3] ---> [sum^32] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (sum₀ (mapa₀ (mapb₀ primitive⁰)))
//│ def mapa₀ = 
//│ 	(fun lsa¹ -> case lsa¹ of {
//│ 		C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₀ ta¹)]
//│ 		| N => [N]})
//│ def mapb₀ = 
//│ 	(fun lsb¹ -> case lsb¹ of {
//│ 		C hb¹ tb¹ => [C (primitive⁰ hb¹) (mapb₀ tb¹)]
//│ 		| N => [N]})
//│ def sum₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => [S [N] (sum₀ t¹)]
//│ 		| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C (primitive⁰ ha¹) (mapa₀ ta¹)]: 55 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] (sum₀ t¹)] | N => [N]}: 46
//│ [N]: 56 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] (sum₀ t¹)] | N => [N]}: 46
//│ [C (primitive⁰ hb¹) (mapb₀ tb¹)]: 66 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₀ ta¹)] | N => [N]}: 57
//│ [N]: 67 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₀ ta¹)] | N => [N]}: 57
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] (sum₀ t¹)] | N => [N]}: 46 --->
//│ 	[C (primitive⁰ ha¹) (mapa₀ ta¹)]: 55
//│ 	[N]: 56
//│ case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₀ ta¹)] | N => [N]}: 57 --->
//│ 	[C (primitive⁰ hb¹) (mapb₀ tb¹)]: 66
//│ 	[N]: 67
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C (primitive⁰ ha¹) (mapa₀ ta¹)]: 55 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] (sum₀ t¹)] | N => [N]}: 46
//│ [N]: 56 --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] (sum₀ t¹)] | N => [N]}: 46
//│ [C (primitive⁰ hb¹) (mapb₀ tb¹)]: 66 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₀ ta¹)] | N => [N]}: 57
//│ [N]: 67 --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₀ ta¹)] | N => [N]}: 57
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [S [N] (sum₀ t¹)] | N => [N]}: 46 --->
//│ 	[C (primitive⁰ ha¹) (mapa₀ ta¹)]: 55
//│ 	[N]: 56
//│ case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₀ ta¹)] | N => [N]}: 57 --->
//│ 	[C (primitive⁰ hb¹) (mapb₀ tb¹)]: 66
//│ 	[N]: 67
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (sum₀ (mapa₀ (mapb₀ primitive⁰)))
//│ def mapa₀ = 
//│ 	(fun lsa² -> lsa²)
//│ def mapb₀ = 
//│ 	(fun lsb² -> case lsb² of {
//│ 		C hb¹ tb¹ => 
//│ 			let ha² = (primitive⁰ hb¹)
//│ 			in let ta² = (mapb₀ tb¹)
//│ 			in let h² = (primitive⁰ ha²)
//│ 			in let t² = (mapa₀ ta²)
//│ 			in [S [N] (sum₀ t²)]
//│ 		| N => [N]})
//│ def sum₀ = 
//│ 	(fun ls² -> ls²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa₀^2] (hopeless to continue)
//│ [mapb₀^3] (hopeless to continue)
//│ 	[mapb₀^3 · mapa₀^22] (using original def)
//│ 	[mapb₀^3 · mapb₀^16] ---> [mapb₀^3] (using original def)
//│ 	[mapb₀^3 · sum₀^26] (using original def)
//│ [sum₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (sum₀₁ (mapa₀₀ (mapb₀₀ primitive⁰)))
//│ def mapa₀₀ = 
//│ 	(fun lsa² -> lsa²)
//│ def mapb₀₀ = 
//│ 	(fun lsb¹ -> case lsb¹ of {
//│ 		C hb¹ tb¹ => 
//│ 			let ha¹ = (primitive⁰ hb¹)
//│ 			in let ta¹ = (mapb₀₀ tb¹)
//│ 			in let h¹ = (primitive⁰ ha¹)
//│ 			in let t¹ = (mapa₀₁ ta¹)
//│ 			in [S [N] (sum₀₀ t¹)]
//│ 		| N => [N]})
//│ 	where
//│ 	def mapa₀₁ = 
//│ 		(fun lsa¹ -> lsa¹)
//│ 	def sum₀₀ = 
//│ 		(fun ls¹ -> ls¹)
//│ def sum₀₁ = 
//│ 	(fun ls² -> ls²)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (sum₀₁ (mapa₀₀ (mapb₀₀ primitive⁰)))
//│ def mapa₀₀ = 
//│ 	(fun lsa⁴ -> lsa⁴)
//│ def mapb₀₀ = 
//│ 	(fun lsb² -> case lsb² of {
//│ 		C hb¹ tb¹ => 
//│ 			let ha¹ = (primitive⁰ hb¹)
//│ 			in let ta¹ = (mapb₀₀ tb¹)
//│ 			in let h¹ = (primitive⁰ ha¹)
//│ 			in let t¹ = (mapa₀₁ ta¹)
//│ 			in [S [N] (sum₀₀ t¹)]
//│ 		| N => [N]})
//│ 	where
//│ 	def mapa₀₁ = 
//│ 		(fun lsa³ -> lsa³)
//│ 	def sum₀₀ = 
//│ 		(fun ls⁴ -> ls⁴)
//│ def sum₀₁ = 
//│ 	(fun ls³ -> ls³)
//│ <<<<<<< after fusion <<<<<<<




// CORRECT:
let p = C(N)
fun c(x) = if C(x) is
  C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|N|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (N,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^10 p^11)
//│ def c = (fun x⁰ -> case [C x⁰] of {
//│ 	C a⁰ => (c^5 a⁰)})
//│ def p = [C [N]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^10]
//│ 	[c^10 · c^5] ---> [c^10] (only one)
//│ [p^11] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case [C x¹] of {
//│ 		C a¹ => (c₀ a¹)})
//│ def p₀ = 
//│ 	[C [N]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => (c₀ a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => (c₀ a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => (c₀ a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => (c₀ a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x² -> 
//│ 		let a² = x²
//│ 		in (c₀ a²))
//│ def p₀ = 
//│ 	[C [N]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c₀^1]
//│ 	[c₀^1 · c₀^7] ---> [c₀^1] (only one)
//│ [p₀^2] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀₀ p₀₀)
//│ def c₀₀ = 
//│ 	(fun x¹ -> 
//│ 		let a¹ = x¹
//│ 		in (c₀₀ a¹))
//│ def p₀₀ = 
//│ 	[C [N]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀₀ p₀₀)
//│ def c₀₀ = 
//│ 	(fun x² -> 
//│ 		let a¹ = x²
//│ 		in (c₀₀ a¹))
//│ def p₀₀ = 
//│ 	[C [N]]
//│ <<<<<<< after fusion <<<<<<<


// let rec p = C(p)
// let q = p
// fun c(x) = if x is
//     C(a) then a
// fun c2(z) = if z is
//     C(b) then c2(b)
// let main = c(q)
// c2(main)



// CORRECT:
_LUMBERHACK_EVAL
let t = T(K, T(N, L, L), T(N, L, L))
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |_LUMBERHACK_EVAL|↵|#let| |t| |#=| |T|(|K|,| |T|(|N|,| |L|,| |L|)|,| |T|(|N|,| |L|,| |L|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {_LUMBERHACK_EVAL; let t = T (K, T (N, L, L,), T (N, L, L,),); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^26 t^27)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^16 l⁰) (c^19 r⁰)]
//│ 	| L => [LL]})
//│ def t = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^26] (hopeless to continue)
//│ 	[c^26 · c^16] ---> [c^26] (using original def)
//│ 	[c^26 · c^19] ---> [c^26] (using original def)
//│ [t^27] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ t₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		T n¹ l¹ r¹ => [T case n¹ of {
//│ 			K => [KK]
//│ 			| N => [NN]} (c₀ l¹) (c₀ r¹)]
//│ 		| L => [LL]})
//│ def t₀ = 
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 44 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 33
//│ [N]: 45 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 33
//│ [L]: 46 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42
//│ [L]: 47 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42
//│ [T [N] [L] [L]]: 48 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42
//│ [N]: 49 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 33
//│ [L]: 50 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42
//│ [L]: 51 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42
//│ [T [N] [L] [L]]: 52 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42
//│ [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42
//│ ------------------
//│ case n¹ of {K => [KK] | N => [NN]}: 33 --->
//│ 	[K]: 44
//│ 	[N]: 45
//│ 	[N]: 49
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42 --->
//│ 	[L]: 46
//│ 	[L]: 47
//│ 	[T [N] [L] [L]]: 48
//│ 	[L]: 50
//│ 	[L]: 51
//│ 	[T [N] [L] [L]]: 52
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 44 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 33
//│ [N]: 45 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 33
//│ [L]: 46 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42
//│ [L]: 47 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42
//│ [T [N] [L] [L]]: 48 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42
//│ [N]: 49 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 33
//│ [L]: 50 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42
//│ [L]: 51 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42
//│ [T [N] [L] [L]]: 52 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42
//│ [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42
//│ ------------------
//│ case n¹ of {K => [KK] | N => [NN]}: 33 --->
//│ 	[K]: 44
//│ 	[N]: 45
//│ 	[N]: 49
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 42 --->
//│ 	[L]: 46
//│ 	[L]: 47
//│ 	[T [N] [L] [L]]: 48
//│ 	[L]: 50
//│ 	[L]: 51
//│ 	[T [N] [L] [L]]: 52
//│ 	[T [K] [T [N] [L] [L]] [T [N] [L] [L]]]: 53
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ t₀)
//│ def c₀ = 
//│ 	(fun x² -> x²)
//│ def t₀ = 
//│ 	let n² = [KK]
//│ 	in let l² = 	
//│ 		let n⁴ = [NN]
//│ 		in let l⁴ = [LL]
//│ 		in let r⁴ = [LL]
//│ 		in [T n⁴ (c₀ l⁴) (c₀ r⁴)]
//│ 	in let r² = 	
//│ 		let n³ = [NN]
//│ 		in let l³ = [LL]
//│ 		in let r³ = [LL]
//│ 		in [T n³ (c₀ l³) (c₀ r³)]
//│ 	in [T n² (c₀ l²) (c₀ r²)]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c₀^1] (hopeless to continue)
//│ [t₀^2] (hopeless to continue)
//│ 	[t₀^2 · c₀^11] (using original def)
//│ 	[t₀^2 · c₀^14] (using original def)
//│ 	[t₀^2 · c₀^25] (using original def)
//│ 	[t₀^2 · c₀^28] (using original def)
//│ 	[t₀^2 · c₀^36] (using original def)
//│ 	[t₀^2 · c₀^39] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀₀ t₀₀)
//│ def c₀₀ = 
//│ 	(fun x⁷ -> x⁷)
//│ def t₀₀ = 
//│ 	let n³ = [KK]
//│ 	in let l³ = 	
//│ 		let n⁴ = [NN]
//│ 		in let l⁴ = [LL]
//│ 		in let r³ = [LL]
//│ 		in [T n⁴ (c₀₁ l⁴) (c₀₂ r³)]
//│ 	in let r⁴ = 	
//│ 		let n⁵ = [NN]
//│ 		in let l⁵ = [LL]
//│ 		in let r⁵ = [LL]
//│ 		in [T n⁵ (c₀₃ l⁵) (c₀₄ r⁵)]
//│ 	in [T n³ (c₀₅ l³) (c₀₆ r⁴)]
//│ 	where
//│ 	def c₀₁ = 
//│ 		(fun x⁵ -> x⁵)
//│ 	def c₀₂ = 
//│ 		(fun x⁴ -> x⁴)
//│ 	def c₀₃ = 
//│ 		(fun x² -> x²)
//│ 	def c₀₄ = 
//│ 		(fun x³ -> x³)
//│ 	def c₀₅ = 
//│ 		(fun x¹ -> x¹)
//│ 	def c₀₆ = 
//│ 		(fun x⁶ -> x⁶)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀₀ t₀₀)
//│ def c₀₀ = 
//│ 	(fun x¹³ -> x¹³)
//│ def t₀₀ = 
//│ 	let n³ = [KK]
//│ 	in let l³ = 	
//│ 		let n⁴ = [NN]
//│ 		in let l⁴ = [LL]
//│ 		in let r³ = [LL]
//│ 		in [T n⁴ (c₀₁ l⁴) (c₀₂ r³)]
//│ 	in let r⁴ = 	
//│ 		let n⁵ = [NN]
//│ 		in let l⁵ = [LL]
//│ 		in let r⁵ = [LL]
//│ 		in [T n⁵ (c₀₃ l⁵) (c₀₄ r⁵)]
//│ 	in [T n³ (c₀₅ l³) (c₀₆ r⁴)]
//│ 	where
//│ 	def c₀₁ = 
//│ 		(fun x¹⁴ -> x¹⁴)
//│ 	def c₀₂ = 
//│ 		(fun x¹² -> x¹²)
//│ 	def c₀₃ = 
//│ 		(fun x⁹ -> x⁹)
//│ 	def c₀₄ = 
//│ 		(fun x⁸ -> x⁸)
//│ 	def c₀₅ = 
//│ 		(fun x¹⁰ -> x¹⁰)
//│ 	def c₀₆ = 
//│ 		(fun x¹¹ -> x¹¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |_LUMBERHACK_EVAL|↵|#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {_LUMBERHACK_EVAL; let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^28 t^29)
//│ def aa = [T [N] [L] [L]]
//│ def bb = [T [N] [L] [L]]
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^18 l⁰) (c^21 r⁰)]
//│ 	| L => [LL]})
//│ def t = [T [K] aa^10 bb^11]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^28] (hopeless to continue)
//│ 	[c^28 · c^18] ---> [c^28] (using original def)
//│ 	[c^28 · c^21] ---> [c^28] (using original def)
//│ [t^29] (hopeless to continue)
//│ 	[t^29 · aa^10] (using original def)
//│ 	[t^29 · bb^11] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ t₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		T n¹ l¹ r¹ => [T case n¹ of {
//│ 			K => [KK]
//│ 			| N => [NN]} (c₀ l¹) (c₀ r¹)]
//│ 		| L => [LL]})
//│ def t₀ = 
//│ 	[T [K] aa₀ bb₀]
//│ 	where
//│ 	def aa₀ = 
//│ 		[T [N] [L] [L]]
//│ 	def bb₀ = 
//│ 		[T [N] [L] [L]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 31 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 39
//│ [L]: 32 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48
//│ [L]: 33 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48
//│ [T [N] [L] [L]]: 34 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48
//│ [K]: 50 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 39
//│ [T [K] aa₀ bb₀]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48
//│ [N]: 54 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 39
//│ [L]: 55 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48
//│ [L]: 56 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48
//│ [T [N] [L] [L]]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48
//│ ------------------
//│ case n¹ of {K => [KK] | N => [NN]}: 39 --->
//│ 	[N]: 31
//│ 	[K]: 50
//│ 	[N]: 54
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48 --->
//│ 	[L]: 32
//│ 	[L]: 33
//│ 	[T [N] [L] [L]]: 34
//│ 	[T [K] aa₀ bb₀]: 53
//│ 	[L]: 55
//│ 	[L]: 56
//│ 	[T [N] [L] [L]]: 57
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 31 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 39
//│ [L]: 32 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48
//│ [L]: 33 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48
//│ [T [N] [L] [L]]: 34 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48
//│ [K]: 50 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 39
//│ [T [K] aa₀ bb₀]: 53 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48
//│ [N]: 54 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 39
//│ [L]: 55 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48
//│ [L]: 56 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48
//│ [T [N] [L] [L]]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48
//│ ------------------
//│ case n¹ of {K => [KK] | N => [NN]}: 39 --->
//│ 	[N]: 31
//│ 	[K]: 50
//│ 	[N]: 54
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₀ l¹) (c₀ r¹)] | L => [LL]}: 48 --->
//│ 	[L]: 32
//│ 	[L]: 33
//│ 	[T [N] [L] [L]]: 34
//│ 	[T [K] aa₀ bb₀]: 53
//│ 	[L]: 55
//│ 	[L]: 56
//│ 	[T [N] [L] [L]]: 57
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ t₀)
//│ def c₀ = 
//│ 	(fun x² -> x²)
//│ def t₀ = 
//│ 	let n³ = [KK]
//│ 	in let l³ = aa₀
//│ 	in let r³ = bb₀
//│ 	in [T n³ (c₀ l³) (c₀ r³)]
//│ 	where
//│ 	def aa₀ = 
//│ 		let n⁴ = [NN]
//│ 		in let l⁴ = [LL]
//│ 		in let r⁴ = [LL]
//│ 		in [T n⁴ (c₀ l⁴) (c₀ r⁴)]
//│ 	def bb₀ = 
//│ 		let n² = [NN]
//│ 		in let l² = [LL]
//│ 		in let r² = [LL]
//│ 		in [T n² (c₀ l²) (c₀ r²)]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c₀^1] (hopeless to continue)
//│ [t₀^2] (hopeless to continue)
//│ 	[t₀^2 · aa₀^21] (using original def)
//│ 		[t₀^2 · aa₀^21 · c₀^38] (using original def)
//│ 		[t₀^2 · aa₀^21 · c₀^41] (using original def)
//│ 	[t₀^2 · bb₀^22] (using original def)
//│ 		[t₀^2 · bb₀^22 · c₀^11] (using original def)
//│ 		[t₀^2 · bb₀^22 · c₀^8] (using original def)
//│ 	[t₀^2 · c₀^24] (using original def)
//│ 	[t₀^2 · c₀^27] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀₀ t₀₀)
//│ def c₀₀ = 
//│ 	(fun x⁶ -> x⁶)
//│ def t₀₀ = 
//│ 	let n⁵ = [KK]
//│ 	in let l⁵ = aa₀₀
//│ 	in let r⁵ = bb₀₀
//│ 	in [T n⁵ (c₀₅ l⁵) (c₀₆ r⁵)]
//│ 	where
//│ 	def aa₀₀ = 
//│ 		let n³ = [NN]
//│ 		in let l³ = [LL]
//│ 		in let r³ = [LL]
//│ 		in [T n³ (c₀₁ l³) (c₀₂ r³)]
//│ 		where
//│ 		def c₀₁ = 
//│ 			(fun x³ -> x³)
//│ 		def c₀₂ = 
//│ 			(fun x¹ -> x¹)
//│ 	def bb₀₀ = 
//│ 		let n⁴ = [NN]
//│ 		in let l⁴ = [LL]
//│ 		in let r⁴ = [LL]
//│ 		in [T n⁴ (c₀₄ l⁴) (c₀₃ r⁴)]
//│ 		where
//│ 		def c₀₃ = 
//│ 			(fun x² -> x²)
//│ 		def c₀₄ = 
//│ 			(fun x⁴ -> x⁴)
//│ 	def c₀₅ = 
//│ 		(fun x⁷ -> x⁷)
//│ 	def c₀₆ = 
//│ 		(fun x⁵ -> x⁵)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀₀ t₀₀)
//│ def c₀₀ = 
//│ 	(fun x¹³ -> x¹³)
//│ def t₀₀ = 
//│ 	let n⁵ = [KK]
//│ 	in let l⁵ = aa₀₀
//│ 	in let r⁵ = bb₀₀
//│ 	in [T n⁵ (c₀₅ l⁵) (c₀₆ r⁵)]
//│ 	where
//│ 	def aa₀₀ = 
//│ 		let n³ = [NN]
//│ 		in let l³ = [LL]
//│ 		in let r³ = [LL]
//│ 		in [T n³ (c₀₁ l³) (c₀₂ r³)]
//│ 		where
//│ 		def c₀₁ = 
//│ 			(fun x¹⁴ -> x¹⁴)
//│ 		def c₀₂ = 
//│ 			(fun x¹² -> x¹²)
//│ 	def bb₀₀ = 
//│ 		let n⁴ = [NN]
//│ 		in let l⁴ = [LL]
//│ 		in let r⁴ = [LL]
//│ 		in [T n⁴ (c₀₄ l⁴) (c₀₃ r⁴)]
//│ 		where
//│ 		def c₀₃ = 
//│ 			(fun x⁹ -> x⁹)
//│ 		def c₀₄ = 
//│ 			(fun x⁸ -> x⁸)
//│ 	def c₀₅ = 
//│ 		(fun x¹⁰ -> x¹⁰)
//│ 	def c₀₆ = 
//│ 		(fun x¹¹ -> x¹¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [T [KK] [T [NN] [LL] [LL]] [T [NN] [LL] [LL]]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
fun map(ls) = if ls is
  C(h, t) then f => C(f(h), map(t)(f))
  N then f => N
let l = C(K, N)
map(l)(
  x => if x is
    K then T
)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#let| |l| |#=| |C|(|K|,| |N|)|↵|map|(|l|)|(|→|x| |=>| |#if| |x| |is|→|K| |#then| |T|←|←|↵|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, => if ls is ‹(C (h, t,)) then f, => C (f (h,), map (t,) (f,),); (N) then f, => N›; let l = C (K, N,); map (l,) (x, => if x is ‹(K) then T›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((map^19 l^20) (fun x⁰ -> case x⁰ of {
//│ 	K => [T]}))
//│ def l = [C [K] [N]]
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> [C (f⁰ h⁰) ((map^5 t⁰) f⁰)])
//│ 	| N => (fun f¹ -> [N])})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^20] (hopeless to continue)
//│ [map^19]
//│ 	[map^19 · map^5] ---> [map^19] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((map₀ l₀) (fun x¹ -> case x¹ of {
//│ 	K => [T]}))
//│ def l₀ = 
//│ 	[C [K] [N]]
//│ def map₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => (fun f² -> [C (f² h¹) ((map₀ t¹) f²)])
//│ 		| N => (fun f³ -> [N])})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 27 --->
//│ 	case x¹ of {K => [T]}: 50
//│ [N]: 28 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C (f² h¹) ((map₀ t¹) f²)]) | N => (fun f³ -> [N])}: 43
//│ [C [K] [N]]: 29 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C (f² h¹) ((map₀ t¹) f²)]) | N => (fun f³ -> [N])}: 43
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun f² -> [C (f² h¹) ((map₀ t¹) f²)]) | N => (fun f³ -> [N])}: 43 --->
//│ 	[N]: 28
//│ 	[C [K] [N]]: 29
//│ case x¹ of {K => [T]}: 50 --->
//│ 	[K]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 27 --->
//│ 	case x¹ of {K => [T]}: 50
//│ [N]: 28 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C (f² h¹) ((map₀ t¹) f²)]) | N => (fun f³ -> [N])}: 43
//│ [C [K] [N]]: 29 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C (f² h¹) ((map₀ t¹) f²)]) | N => (fun f³ -> [N])}: 43
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun f² -> [C (f² h¹) ((map₀ t¹) f²)]) | N => (fun f³ -> [N])}: 43 --->
//│ 	[N]: 28
//│ 	[C [K] [N]]: 29
//│ case x¹ of {K => [T]}: 50 --->
//│ 	[K]: 27
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((map₀ l₀) (fun x² -> x²))
//│ def l₀ = 
//│ 	let h² = [T]
//│ 	in let t² = (fun f⁵ -> [N])
//│ 	in (fun f⁴ -> [C (f⁴ h²) ((map₀ t²) f⁴)])
//│ def map₀ = 
//│ 	(fun ls² -> ls²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [T] [N]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l₀^2] (hopeless to continue)
//│ 	[l₀^2 · map₀^13] (using original def)
//│ [map₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((map₀₁ l₀₀) (fun x¹ -> x¹))
//│ def l₀₀ = 
//│ 	let h¹ = [T]
//│ 	in let t¹ = (fun f² -> [N])
//│ 	in (fun f³ -> [C (f³ h¹) ((map₀₀ t¹) f³)])
//│ 	where
//│ 	def map₀₀ = 
//│ 		(fun ls¹ -> ls¹)
//│ def map₀₁ = 
//│ 	(fun ls² -> ls²)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((map₀₁ l₀₀) (fun x² -> x²))
//│ def l₀₀ = 
//│ 	let h¹ = [T]
//│ 	in let t¹ = (fun f⁴ -> [N])
//│ 	in (fun f⁵ -> [C (f⁵ h¹) ((map₀₀ t¹) f⁵)])
//│ 	where
//│ 	def map₀₀ = 
//│ 		(fun ls³ -> ls³)
//│ def map₀₁ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [T] [N]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT:
_LUMBERHACK_EVAL
fun last(ys) = if ys is
  N then x => x
  C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
  N then None
  C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (lastDrive^22 [C 1 [C 2 [N]]])
//│ def last = (fun ys⁰ -> case ys⁰ of {
//│ 	N => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> ((last^4 t⁰) h⁰))})
//│ def lastDrive = (fun xs⁰ -> case xs⁰ of {
//│ 	N => [None]
//│ 	| C hh⁰ tt⁰ => [Some ((last^14 tt⁰) hh⁰)]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive^22]
//│ 	[lastDrive^22 · last^14]
//│ 		[lastDrive^22 · last^14 · last^4] ---> [lastDrive^22 · last^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (lastDrive₀ [C 1 [C 2 [N]]])
//│ def lastDrive₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		N => [None]
//│ 		| C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]})
//│ 	where
//│ 	def last₀ = 
//│ 		(fun ys¹ -> case ys¹ of {
//│ 			N => (fun x² -> x²)
//│ 			| C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N => [None] | C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N => [None] | C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N => [None] | C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N => [None] | C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (lastDrive₀ 
//│ 	let hh² = 1
//│ 	in let tt² = 	
//│ 		let h² = 2
//│ 		in let t² = (fun x⁵ -> x⁵)
//│ 		in (fun x⁴ -> ((last₀ t²) h²))
//│ 	in [Some ((last₀ tt²) hh²)])
//│ def lastDrive₀ = 
//│ 	(fun xs² -> xs²)
//│ 	where
//│ 	def last₀ = 
//│ 		(fun ys² -> ys²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 2]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive₀^1] (hopeless to continue)
//│ [last₀^14] (hopeless to continue)
//│ [last₀^6] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (lastDrive₀₀ 
//│ 	let hh¹ = 1
//│ 	in let tt¹ = 	
//│ 		let h¹ = 2
//│ 		in let t¹ = (fun x² -> x²)
//│ 		in (fun x³ -> ((last₀₁ t¹) h¹))
//│ 	in [Some ((last₀₀ tt¹) hh¹)])
//│ def lastDrive₀₀ = 
//│ 	(fun xs¹ -> xs¹)
//│ def last₀₀ = 
//│ 	(fun ys¹ -> ys¹)
//│ def last₀₁ = 
//│ 	(fun ys² -> ys²)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (lastDrive₀₀ 
//│ 	let hh¹ = 1
//│ 	in let tt¹ = 	
//│ 		let h¹ = 2
//│ 		in let t¹ = (fun x⁴ -> x⁴)
//│ 		in (fun x⁵ -> ((last₀₁ t¹) h¹))
//│ 	in [Some ((last₀₀ tt¹) hh¹)])
//│ def lastDrive₀₀ = 
//│ 	(fun xs² -> xs²)
//│ def last₀₀ = 
//│ 	(fun ys³ -> ys³)
//│ def last₀₁ = 
//│ 	(fun ys⁴ -> ys⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 2]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT: with expanding termination
let p = C(p)
fun c(x) = if C(x) is
  C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^10 p^11)
//│ def c = (fun x⁰ -> case [C x⁰] of {
//│ 	C a⁰ => (c^5 a⁰)})
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^10]
//│ 	[c^10 · c^5] ---> [c^10] (only one)
//│ [p^11] (hopeless to continue)
//│ 	[p^11 · p^1] ---> [p^11] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case [C x¹] of {
//│ 		C a¹ => (c₀ a¹)})
//│ def p₀ = 
//│ 	[C p₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => (c₀ a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => (c₀ a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C x¹]: 16 --->
//│ 	case [C x¹] of {C a¹ => (c₀ a¹)}: 20
//│ ------------------
//│ case [C x¹] of {C a¹ => (c₀ a¹)}: 20 --->
//│ 	[C x¹]: 16
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x² -> 
//│ 		let a² = x²
//│ 		in (c₀ a²))
//│ def p₀ = 
//│ 	[C p₀]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c₀^1]
//│ 	[c₀^1 · c₀^7] ---> [c₀^1] (only one)
//│ [p₀^2] (hopeless to continue)
//│ 	[p₀^2 · p₀^4] ---> [p₀^2] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀₀ p₀₀)
//│ def c₀₀ = 
//│ 	(fun x¹ -> 
//│ 		let a¹ = x¹
//│ 		in (c₀₀ a¹))
//│ def p₀₀ = 
//│ 	[C p₀₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀₀ p₀₀)
//│ def c₀₀ = 
//│ 	(fun x² -> 
//│ 		let a¹ = x²
//│ 		in (c₀₀ a¹))
//│ def p₀₀ = 
//│ 	[C p₀₀]
//│ <<<<<<< after fusion <<<<<<<



// CORRECT: although multiple matches
// top level definitions as producers can be duplicated
fun c1(x1) = if x1 is
  A then AA
  B then BB
fun c2(x2) = if x2 is
  A then AAA
  B then BBB
let a = A
c1(a)
c2(a)
c2(B)
//│ |#fun| |c1|(|x1|)| |#=| |#if| |x1| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|#fun| |c2|(|x2|)| |#=| |#if| |x2| |is|→|A| |#then| |AAA|↵|B| |#then| |BBB|←|↵|#let| |a| |#=| |A|↵|c1|(|a|)|↵|c2|(|a|)|↵|c2|(|B|)|
//│ Parsed: {fun c1 = x1, => if x1 is ‹(A) then AA; (B) then BB›; fun c2 = x2, => if x2 is ‹(A) then AAA; (B) then BBB›; let a = A; c1 (a,); c2 (a,); c2 (B,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c1^12 a^13)
//│ (c2^15 a^16)
//│ (c2^18 [B])
//│ def a = [A]
//│ def c1 = (fun x1⁰ -> case x1⁰ of {
//│ 	A => [AA]
//│ 	| B => [BB]})
//│ def c2 = (fun x2⁰ -> case x2⁰ of {
//│ 	A => [AAA]
//│ 	| B => [BBB]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [a^13] (hopeless to continue)
//│ [a^16] (hopeless to continue)
//│ [c1^12] (hopeless to continue)
//│ [c2^15] (hopeless to continue)
//│ [c2^18] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c1₀ a₀)
//│ (c2₀ a₁)
//│ (c2₁ [B])
//│ def a₀ = 
//│ 	[A]
//│ def a₁ = 
//│ 	[A]
//│ def c1₀ = 
//│ 	(fun x1¹ -> case x1¹ of {
//│ 		A => [AA]
//│ 		| B => [BB]})
//│ def c2₀ = 
//│ 	(fun x2¹ -> case x2¹ of {
//│ 		A => [AAA]
//│ 		| B => [BBB]})
//│ def c2₁ = 
//│ 	(fun x2² -> case x2² of {
//│ 		A => [AAA]
//│ 		| B => [BBB]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 21 --->
//│ 	case x1¹ of {A => [AA] | B => [BB]}: 25
//│ [A]: 27 --->
//│ 	case x2¹ of {A => [AAA] | B => [BBB]}: 31
//│ [B]: 45 --->
//│ 	case x2² of {A => [AAA] | B => [BBB]}: 36
//│ ------------------
//│ case x1¹ of {A => [AA] | B => [BB]}: 25 --->
//│ 	[A]: 21
//│ case x2¹ of {A => [AAA] | B => [BBB]}: 31 --->
//│ 	[A]: 27
//│ case x2² of {A => [AAA] | B => [BBB]}: 36 --->
//│ 	[B]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 21 --->
//│ 	case x1¹ of {A => [AA] | B => [BB]}: 25
//│ [A]: 27 --->
//│ 	case x2¹ of {A => [AAA] | B => [BBB]}: 31
//│ [B]: 45 --->
//│ 	case x2² of {A => [AAA] | B => [BBB]}: 36
//│ ------------------
//│ case x1¹ of {A => [AA] | B => [BB]}: 25 --->
//│ 	[A]: 21
//│ case x2¹ of {A => [AAA] | B => [BBB]}: 31 --->
//│ 	[A]: 27
//│ case x2² of {A => [AAA] | B => [BBB]}: 36 --->
//│ 	[B]: 45
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c1₀ a₀)
//│ (c2₀ a₁)
//│ (c2₁ [BBB])
//│ def a₀ = 
//│ 	[AA]
//│ def a₁ = 
//│ 	[AAA]
//│ def c1₀ = 
//│ 	(fun x1² -> x1²)
//│ def c2₀ = 
//│ 	(fun x2⁴ -> x2⁴)
//│ def c2₁ = 
//│ 	(fun x2³ -> x2³)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [a₀^2] (hopeless to continue)
//│ [a₁^5] (hopeless to continue)
//│ [c1₀^1] (hopeless to continue)
//│ [c2₀^4] (hopeless to continue)
//│ [c2₁^7] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c1₀₀ a₀₀)
//│ (c2₀₀ a₁₀)
//│ (c2₁₀ [BBB])
//│ def a₀₀ = 
//│ 	[AA]
//│ def a₁₀ = 
//│ 	[AAA]
//│ def c1₀₀ = 
//│ 	(fun x1¹ -> x1¹)
//│ def c2₀₀ = 
//│ 	(fun x2² -> x2²)
//│ def c2₁₀ = 
//│ 	(fun x2³ -> x2³)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c1₀₀ a₀₀)
//│ (c2₀₀ a₁₀)
//│ (c2₁₀ [BBB])
//│ def a₀₀ = 
//│ 	[AA]
//│ def a₁₀ = 
//│ 	[AAA]
//│ def c1₀₀ = 
//│ 	(fun x1² -> x1²)
//│ def c2₀₀ = 
//│ 	(fun x2⁵ -> x2⁵)
//│ def c2₁₀ = 
//│ 	(fun x2⁴ -> x2⁴)
//│ <<<<<<< after fusion <<<<<<<





// CORRECT:
fun last(ys) = if ys is
  N then x => x
  C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
  N then None
  C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (lastDrive^22 [C 1 [C 2 [N]]])
//│ def last = (fun ys⁰ -> case ys⁰ of {
//│ 	N => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> ((last^4 t⁰) h⁰))})
//│ def lastDrive = (fun xs⁰ -> case xs⁰ of {
//│ 	N => [None]
//│ 	| C hh⁰ tt⁰ => [Some ((last^14 tt⁰) hh⁰)]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive^22]
//│ 	[lastDrive^22 · last^14]
//│ 		[lastDrive^22 · last^14 · last^4] ---> [lastDrive^22 · last^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (lastDrive₀ [C 1 [C 2 [N]]])
//│ def lastDrive₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		N => [None]
//│ 		| C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]})
//│ 	where
//│ 	def last₀ = 
//│ 		(fun ys¹ -> case ys¹ of {
//│ 			N => (fun x² -> x²)
//│ 			| C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N => [None] | C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N => [None] | C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 53 --->
//│ 	case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))}: 48
//│ [C 2 [N]]: 54 --->
//│ 	case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))}: 48
//│ [C 1 [C 2 [N]]]: 55 --->
//│ 	case xs¹ of {N => [None] | C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]}: 37
//│ ------------------
//│ case xs¹ of {N => [None] | C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]}: 37 --->
//│ 	[C 1 [C 2 [N]]]: 55
//│ case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))}: 48 --->
//│ 	[N]: 53
//│ 	[C 2 [N]]: 54
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (lastDrive₀ 
//│ 	let hh² = 1
//│ 	in let tt² = 	
//│ 		let h² = 2
//│ 		in let t² = (fun x⁵ -> x⁵)
//│ 		in (fun x⁴ -> ((last₀ t²) h²))
//│ 	in [Some ((last₀ tt²) hh²)])
//│ def lastDrive₀ = 
//│ 	(fun xs² -> xs²)
//│ 	where
//│ 	def last₀ = 
//│ 		(fun ys² -> ys²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive₀^1] (hopeless to continue)
//│ [last₀^14] (hopeless to continue)
//│ [last₀^6] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (lastDrive₀₀ 
//│ 	let hh¹ = 1
//│ 	in let tt¹ = 	
//│ 		let h¹ = 2
//│ 		in let t¹ = (fun x² -> x²)
//│ 		in (fun x³ -> ((last₀₁ t¹) h¹))
//│ 	in [Some ((last₀₀ tt¹) hh¹)])
//│ def lastDrive₀₀ = 
//│ 	(fun xs¹ -> xs¹)
//│ def last₀₀ = 
//│ 	(fun ys¹ -> ys¹)
//│ def last₀₁ = 
//│ 	(fun ys² -> ys²)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (lastDrive₀₀ 
//│ 	let hh¹ = 1
//│ 	in let tt¹ = 	
//│ 		let h¹ = 2
//│ 		in let t¹ = (fun x⁴ -> x⁴)
//│ 		in (fun x⁵ -> ((last₀₁ t¹) h¹))
//│ 	in [Some ((last₀₀ tt¹) hh¹)])
//│ def lastDrive₀₀ = 
//│ 	(fun xs² -> xs²)
//│ def last₀₀ = 
//│ 	(fun ys³ -> ys³)
//│ def last₀₁ = 
//│ 	(fun ys⁴ -> ys⁴)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: the time of unrolling is correct
fun id(k) = k
fun id1(x) = id(x)
fun id2(y) = y
fun id3(z) = z
let rec p = C(C(C(id7(C(C(id1(p)))))))
fun c(xx) = if xx is
  C(a) then c(a)
fun id4(k) = k
fun id5(j) = j
fun id6(l) = l
fun id7(i) = i
id6(id4)(c)(id5(id2)(id3(p)))
//│ |#fun| |id|(|k|)| |#=| |k|↵|#fun| |id1|(|x|)| |#=| |id|(|x|)|↵|#fun| |id2|(|y|)| |#=| |y|↵|#fun| |id3|(|z|)| |#=| |z|↵|#let| |#rec| |p| |#=| |C|(|C|(|C|(|id7|(|C|(|C|(|id1|(|p|)|)|)|)|)|)|)|↵|#fun| |c|(|xx|)| |#=| |#if| |xx| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id4|(|k|)| |#=| |k|↵|#fun| |id5|(|j|)| |#=| |j|↵|#fun| |id6|(|l|)| |#=| |l|↵|#fun| |id7|(|i|)| |#=| |i|↵|id6|(|id4|)|(|c|)|(|id5|(|id2|)|(|id3|(|p|)|)|)|
//│ Parsed: {fun id = k, => k; fun id1 = x, => id (x,); fun id2 = y, => y; fun id3 = z, => z; let rec p = C (C (C (id7 (C (C (id1 (p,),),),),),),); fun c = xx, => if xx is ‹(C (a,)) then c (a,)›; fun id4 = k, => k; fun id5 = j, => j; fun id6 = l, => l; fun id7 = i, => i; id6 (id4,) (c,) (id5 (id2,) (id3 (p,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (((id6^35 id4^36) c^38) ((id5^40 id2^41) (id3^43 p^44)))
//│ def c = (fun xx⁰ -> case xx⁰ of {
//│ 	C a⁰ => (c^22 a⁰)})
//│ def id = (fun k⁰ -> k⁰)
//│ def id1 = (fun x⁰ -> (id^3 x⁰))
//│ def id2 = (fun y⁰ -> y⁰)
//│ def id3 = (fun z⁰ -> z⁰)
//│ def id4 = (fun k¹ -> k¹)
//│ def id5 = (fun j⁰ -> j⁰)
//│ def id6 = (fun l⁰ -> l⁰)
//│ def id7 = (fun i⁰ -> i⁰)
//│ def p = [C [C [C (id7^11 [C [C (id1^12 p^13)]])]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^38]
//│ 	[c^38 · c^22]
//│ 		[c^38 · c^22 · c^22]
//│ 			[c^38 · c^22 · c^22 · c^22]
//│ 				[c^38 · c^22 · c^22 · c^22 · c^22]
//│ 					[c^38 · c^22 · c^22 · c^22 · c^22 · c^22] ---> [c^38] (only one)
//│ [id2^41] (hopeless to continue)
//│ [id3^43] (hopeless to continue)
//│ [id4^36] (hopeless to continue)
//│ [id5^40] (hopeless to continue)
//│ [id6^35] (hopeless to continue)
//│ [p^44]
//│ 	[p^44 · id1^12] (hopeless to continue)
//│ 		[p^44 · id1^12 · id^3] (using original def)
//│ 	[p^44 · id7^11] (hopeless to continue)
//│ 	[p^44 · p^13] ---> [p^44] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (((id6₀ id4₀) c₀) ((id5₀ id2₀) (id3₀ p₀)))
//│ def c₀ = 
//│ 	(fun xx⁴ -> case xx⁴ of {
//│ 		C a⁴ => (c₁ a⁴)})
//│ 	where
//│ 	def c₁ = 
//│ 		(fun xx¹ -> case xx¹ of {
//│ 			C a¹ => (c₂ a¹)})
//│ 		where
//│ 		def c₂ = 
//│ 			(fun xx⁵ -> case xx⁵ of {
//│ 				C a⁵ => (c₃ a⁵)})
//│ 			where
//│ 			def c₃ = 
//│ 				(fun xx² -> case xx² of {
//│ 					C a² => (c₄ a²)})
//│ 				where
//│ 				def c₄ = 
//│ 					(fun xx³ -> case xx³ of {
//│ 						C a³ => (c₀ a³)})
//│ def id2₀ = 
//│ 	(fun y¹ -> y¹)
//│ def id3₀ = 
//│ 	(fun z¹ -> z¹)
//│ def id4₀ = 
//│ 	(fun k² -> k²)
//│ def id5₀ = 
//│ 	(fun j¹ -> j¹)
//│ def id6₀ = 
//│ 	(fun l¹ -> l¹)
//│ def p₀ = 
//│ 	[C [C [C (id7₀ [C [C (id1₀ p₀)]])]]]
//│ 	where
//│ 	def id1₀ = 
//│ 		(fun x¹ -> (id₀ x¹))
//│ 		where
//│ 		def id₀ = 
//│ 			(fun k³ -> k³)
//│ 	def id7₀ = 
//│ 		(fun i¹ -> i¹)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C (id1₀ p₀)]: 98 --->
//│ 	case xx³ of {C a³ => (c₀ a³)}: 72
//│ [C [C (id1₀ p₀)]]: 99 --->
//│ 	case xx² of {C a² => (c₄ a²)}: 58
//│ [C (id7₀ [C [C (id1₀ p₀)]])]: 101 --->
//│ 	case xx⁵ of {C a⁵ => (c₃ a⁵)}: 92
//│ [C [C (id7₀ [C [C (id1₀ p₀)]])]]: 102 --->
//│ 	case xx¹ of {C a¹ => (c₂ a¹)}: 52
//│ [C [C [C (id7₀ [C [C (id1₀ p₀)]])]]]: 103 --->
//│ 	case xx⁴ of {C a⁴ => (c₁ a⁴)}: 78
//│ ------------------
//│ case xx¹ of {C a¹ => (c₂ a¹)}: 52 --->
//│ 	[C [C (id7₀ [C [C (id1₀ p₀)]])]]: 102
//│ case xx² of {C a² => (c₄ a²)}: 58 --->
//│ 	[C [C (id1₀ p₀)]]: 99
//│ case xx³ of {C a³ => (c₀ a³)}: 72 --->
//│ 	[C (id1₀ p₀)]: 98
//│ case xx⁴ of {C a⁴ => (c₁ a⁴)}: 78 --->
//│ 	[C [C [C (id7₀ [C [C (id1₀ p₀)]])]]]: 103
//│ case xx⁵ of {C a⁵ => (c₃ a⁵)}: 92 --->
//│ 	[C (id7₀ [C [C (id1₀ p₀)]])]: 101
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C (id1₀ p₀)]: 98 --->
//│ 	case xx³ of {C a³ => (c₀ a³)}: 72
//│ [C [C (id1₀ p₀)]]: 99 --->
//│ 	case xx² of {C a² => (c₄ a²)}: 58
//│ [C (id7₀ [C [C (id1₀ p₀)]])]: 101 --->
//│ 	case xx⁵ of {C a⁵ => (c₃ a⁵)}: 92
//│ [C [C (id7₀ [C [C (id1₀ p₀)]])]]: 102 --->
//│ 	case xx¹ of {C a¹ => (c₂ a¹)}: 52
//│ [C [C [C (id7₀ [C [C (id1₀ p₀)]])]]]: 103 --->
//│ 	case xx⁴ of {C a⁴ => (c₁ a⁴)}: 78
//│ ------------------
//│ case xx¹ of {C a¹ => (c₂ a¹)}: 52 --->
//│ 	[C [C (id7₀ [C [C (id1₀ p₀)]])]]: 102
//│ case xx² of {C a² => (c₄ a²)}: 58 --->
//│ 	[C [C (id1₀ p₀)]]: 99
//│ case xx³ of {C a³ => (c₀ a³)}: 72 --->
//│ 	[C (id1₀ p₀)]: 98
//│ case xx⁴ of {C a⁴ => (c₁ a⁴)}: 78 --->
//│ 	[C [C [C (id7₀ [C [C (id1₀ p₀)]])]]]: 103
//│ case xx⁵ of {C a⁵ => (c₃ a⁵)}: 92 --->
//│ 	[C (id7₀ [C [C (id1₀ p₀)]])]: 101
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (((id6₀ id4₀) c₀) ((id5₀ id2₀) (id3₀ p₀)))
//│ def c₀ = 
//│ 	(fun xx⁹ -> xx⁹)
//│ 	where
//│ 	def c₁ = 
//│ 		(fun xx⁶ -> xx⁶)
//│ 		where
//│ 		def c₂ = 
//│ 			(fun xx¹⁰ -> xx¹⁰)
//│ 			where
//│ 			def c₃ = 
//│ 				(fun xx⁷ -> xx⁷)
//│ 				where
//│ 				def c₄ = 
//│ 					(fun xx⁸ -> xx⁸)
//│ def id2₀ = 
//│ 	(fun y² -> y²)
//│ def id3₀ = 
//│ 	(fun z² -> z²)
//│ def id4₀ = 
//│ 	(fun k⁵ -> k⁵)
//│ def id5₀ = 
//│ 	(fun j² -> j²)
//│ def id6₀ = 
//│ 	(fun l² -> l²)
//│ def p₀ = 
//│ 	let a⁶ = 	
//│ 		let a⁷ = 	
//│ 			let a⁸ = (id7₀ 
//│ 				let a⁹ = 	
//│ 					let a¹⁰ = (id1₀ p₀)
//│ 					in (c₀ a¹⁰)
//│ 				in (c₄ a⁹))
//│ 			in (c₃ a⁸)
//│ 		in (c₂ a⁷)
//│ 	in (c₁ a⁶)
//│ 	where
//│ 	def id1₀ = 
//│ 		(fun x² -> (id₀ x²))
//│ 		where
//│ 		def id₀ = 
//│ 			(fun k⁴ -> k⁴)
//│ 	def id7₀ = 
//│ 		(fun i² -> i²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c₀^4] (hopeless to continue)
//│ [id2₀^7] (hopeless to continue)
//│ [id3₀^9] (hopeless to continue)
//│ [id4₀^2] (hopeless to continue)
//│ [id5₀^6] (hopeless to continue)
//│ [id6₀^1] (hopeless to continue)
//│ [p₀^10] (hopeless to continue)
//│ 	[p₀^10 · c₀^30] (using original def)
//│ 	[p₀^10 · c₁^47] (using original def)
//│ 	[p₀^10 · c₂^43] (using original def)
//│ 	[p₀^10 · c₃^39] (using original def)
//│ 	[p₀^10 · c₄^34] (using original def)
//│ 	[p₀^10 · id1₀^27] (using original def)
//│ 		[p₀^10 · id1₀^27 · id₀^22] (using original def)
//│ 	[p₀^10 · id7₀^26] (using original def)
//│ 	[p₀^10 · p₀^28] ---> [p₀^10] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (((id6₀₀ id4₀₀) c₀₀) ((id5₀₀ id2₀₀) (id3₀₀ p₀₀)))
//│ def c₀₀ = 
//│ 	(fun xx¹⁰ -> xx¹⁰)
//│ def id2₀₀ = 
//│ 	(fun y¹ -> y¹)
//│ def id3₀₀ = 
//│ 	(fun z¹ -> z¹)
//│ def id4₀₀ = 
//│ 	(fun k³ -> k³)
//│ def id5₀₀ = 
//│ 	(fun j¹ -> j¹)
//│ def id6₀₀ = 
//│ 	(fun l¹ -> l¹)
//│ def p₀₀ = 
//│ 	let a⁵ = 	
//│ 		let a⁶ = 	
//│ 			let a⁷ = (id7₀₀ 
//│ 				let a⁸ = 	
//│ 					let a⁹ = (id1₀₀ p₀₀)
//│ 					in (c₀₁ a⁹)
//│ 				in (c₄₀ a⁸))
//│ 			in (c₃₀ a⁷)
//│ 		in (c₂₀ a⁶)
//│ 	in (c₁₀ a⁵)
//│ 	where
//│ 	def c₀₁ = 
//│ 		(fun xx⁷ -> xx⁷)
//│ 	def c₁₀ = 
//│ 		(fun xx⁵ -> xx⁵)
//│ 	def c₂₀ = 
//│ 		(fun xx⁶ -> xx⁶)
//│ 	def c₃₀ = 
//│ 		(fun xx⁸ -> xx⁸)
//│ 	def c₄₀ = 
//│ 		(fun xx⁹ -> xx⁹)
//│ 	def id1₀₀ = 
//│ 		(fun x¹ -> (id₀₀ x¹))
//│ 		where
//│ 		def id₀₀ = 
//│ 			(fun k² -> k²)
//│ 	def id7₀₀ = 
//│ 		(fun i¹ -> i¹)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (((id6₀₀ id4₀₀) c₀₀) ((id5₀₀ id2₀₀) (id3₀₀ p₀₀)))
//│ def c₀₀ = 
//│ 	(fun xx¹⁵ -> xx¹⁵)
//│ def id2₀₀ = 
//│ 	(fun y² -> y²)
//│ def id3₀₀ = 
//│ 	(fun z² -> z²)
//│ def id4₀₀ = 
//│ 	(fun k⁴ -> k⁴)
//│ def id5₀₀ = 
//│ 	(fun j² -> j²)
//│ def id6₀₀ = 
//│ 	(fun l² -> l²)
//│ def p₀₀ = 
//│ 	let a⁵ = 	
//│ 		let a⁶ = 	
//│ 			let a⁷ = (id7₀₀ 
//│ 				let a⁸ = 	
//│ 					let a⁹ = (id1₀₀ p₀₀)
//│ 					in (c₀₁ a⁹)
//│ 				in (c₄₀ a⁸))
//│ 			in (c₃₀ a⁷)
//│ 		in (c₂₀ a⁶)
//│ 	in (c₁₀ a⁵)
//│ 	where
//│ 	def c₀₁ = 
//│ 		(fun xx¹⁶ -> xx¹⁶)
//│ 	def c₁₀ = 
//│ 		(fun xx¹⁴ -> xx¹⁴)
//│ 	def c₂₀ = 
//│ 		(fun xx¹² -> xx¹²)
//│ 	def c₃₀ = 
//│ 		(fun xx¹¹ -> xx¹¹)
//│ 	def c₄₀ = 
//│ 		(fun xx¹³ -> xx¹³)
//│ 	def id1₀₀ = 
//│ 		(fun x² -> (id₀₀ x²))
//│ 		where
//│ 		def id₀₀ = 
//│ 			(fun k⁵ -> k⁵)
//│ 	def id7₀₀ = 
//│ 		(fun i² -> i²)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
fun id(x) = if x is
  ID(b) then b
  C(a) then id(ID(C(a)))
let p = C(p)
fun c(y) = if y is
  C(aa) then c(aa)
c(id(p))
//│ |#fun| |id|(|x|)| |#=| |#if| |x| |is|→|ID|(|b|)| |#then| |b|↵|C|(|a|)| |#then| |id|(|ID|(|C|(|a|)|)|)|←|↵|#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |c|(|aa|)|←|↵|c|(|id|(|p|)|)|
//│ Parsed: {fun id = x, => if x is ‹(ID (b,)) then b; (C (a,)) then id (ID (C (a,),),)›; let p = C (p,); fun c = y, => if y is ‹(C (aa,)) then c (aa,)›; c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^18 (id^19 p^20))
//│ def c = (fun y⁰ -> case y⁰ of {
//│ 	C aa⁰ => (c^13 aa⁰)})
//│ def id = (fun x⁰ -> case x⁰ of {
//│ 	ID b⁰ => b⁰
//│ 	| C a⁰ => (id^3 [ID [C a⁰]])})
//│ def p = [C p^10]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^18] (hopeless to continue)
//│ 	[c^18 · c^13] ---> [c^18] (using original def)
//│ [id^19] (hopeless to continue)
//│ 	[id^19 · id^3] ---> [id^19] (using original def)
//│ [p^20] (hopeless to continue)
//│ 	[p^20 · p^10] ---> [p^20] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ (id₀ p₀))
//│ def c₀ = 
//│ 	(fun y¹ -> case y¹ of {
//│ 		C aa¹ => (c₀ aa¹)})
//│ def id₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		ID b¹ => b¹
//│ 		| C a¹ => (id₀ [ID [C a¹]])})
//│ def p₀ = 
//│ 	[C p₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p₀]: 30 --->
//│ 	case y¹ of {C aa¹ => (c₀ aa¹)}: 27
//│ 	case x¹ of {ID b¹ => b¹ | C a¹ => (id₀ [ID [C a¹]])}: 38
//│ [C a¹]: 35 --->
//│ 	case y¹ of {C aa¹ => (c₀ aa¹)}: 27
//│ [ID [C a¹]]: 36 --->
//│ 	case x¹ of {ID b¹ => b¹ | C a¹ => (id₀ [ID [C a¹]])}: 38
//│ ------------------
//│ case y¹ of {C aa¹ => (c₀ aa¹)}: 27 --->
//│ 	[C p₀]: 30
//│ 	[C a¹]: 35
//│ case x¹ of {ID b¹ => b¹ | C a¹ => (id₀ [ID [C a¹]])}: 38 --->
//│ 	[C p₀]: 30
//│ 	[ID [C a¹]]: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ (id₀ p₀))
//│ def c₀ = 
//│ 	(fun y² -> case y² of {
//│ 		C aa¹ => (c₀ aa¹)})
//│ def id₀ = 
//│ 	(fun x² -> case x² of {
//│ 		ID b¹ => b¹
//│ 		| C a¹ => (id₀ [ID [C a¹]])})
//│ def p₀ = 
//│ 	[C p₀]
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: unlike the rev rev case, TODO: why?
fun map(ls) = if ls is
  C(h, t) then C(
    (if h is
      A then AA
      B then BB
    ),
    map(t)
  )
  N then N
fun len(ls) = if ls is
  C(h, t) then 1 + len(t)
  N then 0
len(map(C(A, C(B, N))))
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#fun| |len|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |1| |+| |len|(|t|)|↵|N| |#then| |0|←|↵|len|(|map|(|C|(|A|,| |C|(|B|,| |N|)|)|)|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(A) then AA; (B) then BB›, ')', map (t,),); (N) then N›; fun len = ls, => if ls is ‹(C (h, t,)) then + (1,) (len (t,),); (N) then 0›; len (map (C (A, C (B, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (len^24 (map^25 [C [A] [C [B] [N]]]))
//│ def len = (fun ls¹ -> case ls¹ of {
//│ 	C h¹ t¹ => (1 + (len^17 t¹))
//│ 	| N => 0})
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C case h⁰ of {
//│ 		A => [AA]
//│ 		| B => [BB]} (map^6 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [len^24]
//│ 	[len^24 · len^17] ---> [len^24] (only one)
//│ [map^25]
//│ 	[map^25 · map^6] ---> [map^25] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (len₀ (map₀ [C [A] [C [B] [N]]]))
//│ def len₀ = 
//│ 	(fun ls³ -> case ls³ of {
//│ 		C h³ t³ => (1 + (len₀ t³))
//│ 		| N => 0})
//│ def map₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h² t² => [C case h² of {
//│ 			A => [AA]
//│ 			| B => [BB]} (map₀ t²)]
//│ 		| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C case h² of {A => [AA] | B => [BB]} (map₀ t²)]: 41 --->
//│ 	case ls³ of {C h³ t³ => (1 + (len₀ t³)) | N => 0}: 54
//│ [N]: 42 --->
//│ 	case ls³ of {C h³ t³ => (1 + (len₀ t³)) | N => 0}: 54
//│ [A]: 58 --->
//│ 	case h² of {A => [AA] | B => [BB]}: 37
//│ [B]: 59 --->
//│ 	case h² of {A => [AA] | B => [BB]}: 37
//│ [N]: 60 --->
//│ 	case ls² of {C h² t² => [C case h² of {A => [AA] | B => [BB]} (map₀ t²)] | N => [N]}: 43
//│ [C [B] [N]]: 61 --->
//│ 	case ls² of {C h² t² => [C case h² of {A => [AA] | B => [BB]} (map₀ t²)] | N => [N]}: 43
//│ [C [A] [C [B] [N]]]: 62 --->
//│ 	case ls² of {C h² t² => [C case h² of {A => [AA] | B => [BB]} (map₀ t²)] | N => [N]}: 43
//│ ------------------
//│ case h² of {A => [AA] | B => [BB]}: 37 --->
//│ 	[A]: 58
//│ 	[B]: 59
//│ case ls² of {C h² t² => [C case h² of {A => [AA] | B => [BB]} (map₀ t²)] | N => [N]}: 43 --->
//│ 	[N]: 60
//│ 	[C [B] [N]]: 61
//│ 	[C [A] [C [B] [N]]]: 62
//│ case ls³ of {C h³ t³ => (1 + (len₀ t³)) | N => 0}: 54 --->
//│ 	[C case h² of {A => [AA] | B => [BB]} (map₀ t²)]: 41
//│ 	[N]: 42
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C case h² of {A => [AA] | B => [BB]} (map₀ t²)]: 41 --->
//│ 	case ls³ of {C h³ t³ => (1 + (len₀ t³)) | N => 0}: 54
//│ [N]: 42 --->
//│ 	case ls³ of {C h³ t³ => (1 + (len₀ t³)) | N => 0}: 54
//│ [A]: 58 --->
//│ 	case h² of {A => [AA] | B => [BB]}: 37
//│ [B]: 59 --->
//│ 	case h² of {A => [AA] | B => [BB]}: 37
//│ [N]: 60 --->
//│ 	case ls² of {C h² t² => [C case h² of {A => [AA] | B => [BB]} (map₀ t²)] | N => [N]}: 43
//│ [C [B] [N]]: 61 --->
//│ 	case ls² of {C h² t² => [C case h² of {A => [AA] | B => [BB]} (map₀ t²)] | N => [N]}: 43
//│ [C [A] [C [B] [N]]]: 62 --->
//│ 	case ls² of {C h² t² => [C case h² of {A => [AA] | B => [BB]} (map₀ t²)] | N => [N]}: 43
//│ ------------------
//│ case h² of {A => [AA] | B => [BB]}: 37 --->
//│ 	[A]: 58
//│ 	[B]: 59
//│ case ls² of {C h² t² => [C case h² of {A => [AA] | B => [BB]} (map₀ t²)] | N => [N]}: 43 --->
//│ 	[N]: 60
//│ 	[C [B] [N]]: 61
//│ 	[C [A] [C [B] [N]]]: 62
//│ case ls³ of {C h³ t³ => (1 + (len₀ t³)) | N => 0}: 54 --->
//│ 	[C case h² of {A => [AA] | B => [BB]} (map₀ t²)]: 41
//│ 	[N]: 42
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (len₀ (map₀ 
//│ 	let h⁴ = [AA]
//│ 	in let t⁴ = 	
//│ 		let h⁶ = [BB]
//│ 		in let t⁶ = 0
//│ 		in let h⁷ = h⁶
//│ 		in let t⁷ = (map₀ t⁶)
//│ 		in (1 + (len₀ t⁷))
//│ 	in let h⁵ = h⁴
//│ 	in let t⁵ = (map₀ t⁴)
//│ 	in (1 + (len₀ t⁵))))
//│ def len₀ = 
//│ 	(fun ls⁵ -> ls⁵)
//│ def map₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [len₀^13] (hopeless to continue)
//│ [len₀^1] (hopeless to continue)
//│ [len₀^28] (hopeless to continue)
//│ [map₀^22] (hopeless to continue)
//│ [map₀^2] (hopeless to continue)
//│ [map₀^7] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (len₀₁ (map₀₁ 
//│ 	let h⁴ = [AA]
//│ 	in let t⁴ = 	
//│ 		let h⁵ = [BB]
//│ 		in let t⁵ = 0
//│ 		in let h⁶ = h⁵
//│ 		in let t⁶ = (map₀₂ t⁵)
//│ 		in (1 + (len₀₀ t⁶))
//│ 	in let h⁷ = h⁴
//│ 	in let t⁷ = (map₀₀ t⁴)
//│ 	in (1 + (len₀₂ t⁷))))
//│ def len₀₀ = 
//│ 	(fun ls³ -> ls³)
//│ def len₀₁ = 
//│ 	(fun ls⁷ -> ls⁷)
//│ def len₀₂ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ def map₀₀ = 
//│ 	(fun ls² -> ls²)
//│ def map₀₁ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ def map₀₂ = 
//│ 	(fun ls⁵ -> ls⁵)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (len₀₁ (map₀₁ 
//│ 	let h⁴ = [AA]
//│ 	in let t⁴ = 	
//│ 		let h⁵ = [BB]
//│ 		in let t⁵ = 0
//│ 		in let h⁶ = h⁵
//│ 		in let t⁶ = (map₀₂ t⁵)
//│ 		in (1 + (len₀₀ t⁶))
//│ 	in let h⁷ = h⁴
//│ 	in let t⁷ = (map₀₀ t⁴)
//│ 	in (1 + (len₀₂ t⁷))))
//│ def len₀₀ = 
//│ 	(fun ls¹³ -> ls¹³)
//│ def len₀₁ = 
//│ 	(fun ls⁸ -> ls⁸)
//│ def len₀₂ = 
//│ 	(fun ls¹² -> ls¹²)
//│ def map₀₀ = 
//│ 	(fun ls⁹ -> ls⁹)
//│ def map₀₁ = 
//│ 	(fun ls¹¹ -> ls¹¹)
//│ def map₀₂ = 
//│ 	(fun ls¹⁰ -> ls¹⁰)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: multiple match, but correct
fun f(x) = if x is
  C(a) then f
f(C(A))(C(B))(C(D))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |f|←|↵|f|(|C|(|A|)|)|(|C|(|B|)|)|(|C|(|D|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then f›; f (C (A,),) (C (B,),) (C (D,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (((f^5 [C [A]]) [C [B]]) [C [D]])
//│ def f = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => f^2})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^5] (hopeless to continue)
//│ 	[f^5 · f^2] ---> [f^5] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (((f₀ [C [A]]) [C [B]]) [C [D]])
//│ def f₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C a¹ => f₀})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 21 --->
//│ 	case x¹ of {C a¹ => f₀}: 17
//│ [C [B]]: 24 --->
//│ 	case x¹ of {C a¹ => f₀}: 17
//│ [C [D]]: 27 --->
//│ 	case x¹ of {C a¹ => f₀}: 17
//│ ------------------
//│ case x¹ of {C a¹ => f₀}: 17 --->
//│ 	[C [A]]: 21
//│ 	[C [B]]: 24
//│ 	[C [D]]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [A]]: 21 --->
//│ 	case x¹ of {C a¹ => f₀}: 17
//│ [C [B]]: 24 --->
//│ 	case x¹ of {C a¹ => f₀}: 17
//│ [C [D]]: 27 --->
//│ 	case x¹ of {C a¹ => f₀}: 17
//│ ------------------
//│ case x¹ of {C a¹ => f₀}: 17 --->
//│ 	[C [A]]: 21
//│ 	[C [B]]: 24
//│ 	[C [D]]: 27
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (((f₀ 
//│ 	let a² = [A]
//│ 	in f₀) 
//│ 	let a³ = [B]
//│ 	in f₀) 
//│ 	let a⁴ = [D]
//│ 	in f₀)
//│ def f₀ = 
//│ 	(fun x² -> x²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f₀^11] (hopeless to continue)
//│ [f₀^1] (hopeless to continue)
//│ [f₀^3] (hopeless to continue)
//│ [f₀^7] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (((f₀₁ 
//│ 	let a³ = [A]
//│ 	in f₀₂) 
//│ 	let a⁴ = [B]
//│ 	in f₀₃) 
//│ 	let a⁵ = [D]
//│ 	in f₀₀)
//│ def f₀₀ = 
//│ 	(fun x³ -> x³)
//│ def f₀₁ = 
//│ 	(fun x¹ -> x¹)
//│ def f₀₂ = 
//│ 	(fun x⁴ -> x⁴)
//│ def f₀₃ = 
//│ 	(fun x² -> x²)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (((f₀₁ 
//│ 	let a³ = [A]
//│ 	in f₀₂) 
//│ 	let a⁴ = [B]
//│ 	in f₀₃) 
//│ 	let a⁵ = [D]
//│ 	in f₀₀)
//│ def f₀₀ = 
//│ 	(fun x⁷ -> x⁷)
//│ def f₀₁ = 
//│ 	(fun x⁵ -> x⁵)
//│ def f₀₂ = 
//│ 	(fun x⁸ -> x⁸)
//│ def f₀₃ = 
//│ 	(fun x⁶ -> x⁶)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
let aa = T(N, t, t)
let t = T(K, aa, aa)
fun c(x) = if x is
  T(n, l, r) then T(
    (if n is
      K then KK
      N then NN
    ),
    c(l),
    c(r)
  )
  L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |t|,| |t|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |aa|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, t, t,); let t = T (K, aa, aa,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^24 t^25)
//│ def aa = [T [N] t^2 t^3]
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^14 l⁰) (c^17 r⁰)]
//│ 	| L => [LL]})
//│ def t = [T [K] aa^6 aa^7]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^24]
//│ 	[c^24 · c^14] (hopeless to continue)
//│ 		[c^24 · c^14 · c^14] ---> [c^24 · c^14] (using original def)
//│ 		[c^24 · c^14 · c^17] ---> [c^24 · c^14] (using original def)
//│ 	[c^24 · c^17]
//│ 		[c^24 · c^17 · c^14] ---> [c^24] (only one)
//│ 		[c^24 · c^17 · c^17] ---> [c^24] (only one)
//│ [t^25]
//│ 	[t^25 · aa^6] (hopeless to continue)
//│ 		[t^25 · aa^6 · t^2] (using original def)
//│ 			[t^25 · aa^6 · t^2 · aa^6] ---> [t^25 · aa^6] (using original def)
//│ 			[t^25 · aa^6 · t^2 · aa^7] ---> [t^25 · aa^6] (using original def)
//│ 		[t^25 · aa^6 · t^3] (using original def)
//│ 			[t^25 · aa^6 · t^3 · aa^6] ---> [t^25 · aa^6] (using original def)
//│ 			[t^25 · aa^6 · t^3 · aa^7] ---> [t^25 · aa^6] (using original def)
//│ 	[t^25 · aa^7]
//│ 		[t^25 · aa^7 · t^2] ---> [t^25] (only one)
//│ 		[t^25 · aa^7 · t^3] ---> [t^25] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ t₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		T n¹ l¹ r¹ => [T case n¹ of {
//│ 			K => [KK]
//│ 			| N => [NN]} (c₁ l¹) (c₂ r¹)]
//│ 		| L => [LL]})
//│ 	where
//│ 	def c₁ = 
//│ 		(fun x² -> case x² of {
//│ 			T n² l² r² => [T case n² of {
//│ 				K => [KK]
//│ 				| N => [NN]} (c₁ l²) (c₁ r²)]
//│ 			| L => [LL]})
//│ 	def c₂ = 
//│ 		(fun x³ -> case x³ of {
//│ 			T n³ l³ r³ => [T case n³ of {
//│ 				K => [KK]
//│ 				| N => [NN]} (c₀ l³) (c₀ r³)]
//│ 			| L => [LL]})
//│ def t₀ = 
//│ 	[T [K] aa₀ aa₁]
//│ 	where
//│ 	def aa₀ = 
//│ 		[T [N] t₁ t₂]
//│ 		where
//│ 		def t₁ = 
//│ 			[T [K] aa₀ aa₀]
//│ 		def t₂ = 
//│ 			[T [K] aa₀ aa₀]
//│ 	def aa₁ = 
//│ 		[T [N] t₀ t₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 42 --->
//│ 	case n³ of {K => [KK] | N => [NN]}: 81
//│ [T [N] t₀ t₀]: 45 --->
//│ 	case x³ of {T n³ l³ r³ => [T case n³ of {K => [KK] | N => [NN]} (c₀ l³) (c₀ r³)] | L => [LL]}: 90
//│ [K]: 46 --->
//│ 	case n² of {K => [KK] | N => [NN]}: 62
//│ [T [K] aa₀ aa₀]: 49 --->
//│ 	case x² of {T n² l² r² => [T case n² of {K => [KK] | N => [NN]} (c₁ l²) (c₁ r²)] | L => [LL]}: 71
//│ [K]: 50 --->
//│ 	case n² of {K => [KK] | N => [NN]}: 62
//│ [T [K] aa₀ aa₀]: 53 --->
//│ 	case x² of {T n² l² r² => [T case n² of {K => [KK] | N => [NN]} (c₁ l²) (c₁ r²)] | L => [LL]}: 71
//│ [K]: 54 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 31
//│ [T [K] aa₀ aa₁]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₁ l¹) (c₂ r¹)] | L => [LL]}: 40
//│ [N]: 73 --->
//│ 	case n² of {K => [KK] | N => [NN]}: 62
//│ [T [N] t₁ t₂]: 76 --->
//│ 	case x² of {T n² l² r² => [T case n² of {K => [KK] | N => [NN]} (c₁ l²) (c₁ r²)] | L => [LL]}: 71
//│ ------------------
//│ case n¹ of {K => [KK] | N => [NN]}: 31 --->
//│ 	[K]: 54
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₁ l¹) (c₂ r¹)] | L => [LL]}: 40 --->
//│ 	[T [K] aa₀ aa₁]: 57
//│ case n² of {K => [KK] | N => [NN]}: 62 --->
//│ 	[K]: 46
//│ 	[K]: 50
//│ 	[N]: 73
//│ case x² of {T n² l² r² => [T case n² of {K => [KK] | N => [NN]} (c₁ l²) (c₁ r²)] | L => [LL]}: 71 --->
//│ 	[T [K] aa₀ aa₀]: 49
//│ 	[T [K] aa₀ aa₀]: 53
//│ 	[T [N] t₁ t₂]: 76
//│ case n³ of {K => [KK] | N => [NN]}: 81 --->
//│ 	[N]: 42
//│ case x³ of {T n³ l³ r³ => [T case n³ of {K => [KK] | N => [NN]} (c₀ l³) (c₀ r³)] | L => [LL]}: 90 --->
//│ 	[T [N] t₀ t₀]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 42 --->
//│ 	case n³ of {K => [KK] | N => [NN]}: 81
//│ [T [N] t₀ t₀]: 45 --->
//│ 	case x³ of {T n³ l³ r³ => [T case n³ of {K => [KK] | N => [NN]} (c₀ l³) (c₀ r³)] | L => [LL]}: 90
//│ [K]: 46 --->
//│ 	case n² of {K => [KK] | N => [NN]}: 62
//│ [T [K] aa₀ aa₀]: 49 --->
//│ 	case x² of {T n² l² r² => [T case n² of {K => [KK] | N => [NN]} (c₁ l²) (c₁ r²)] | L => [LL]}: 71
//│ [K]: 50 --->
//│ 	case n² of {K => [KK] | N => [NN]}: 62
//│ [T [K] aa₀ aa₀]: 53 --->
//│ 	case x² of {T n² l² r² => [T case n² of {K => [KK] | N => [NN]} (c₁ l²) (c₁ r²)] | L => [LL]}: 71
//│ [K]: 54 --->
//│ 	case n¹ of {K => [KK] | N => [NN]}: 31
//│ [T [K] aa₀ aa₁]: 57 --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₁ l¹) (c₂ r¹)] | L => [LL]}: 40
//│ [N]: 73 --->
//│ 	case n² of {K => [KK] | N => [NN]}: 62
//│ [T [N] t₁ t₂]: 76 --->
//│ 	case x² of {T n² l² r² => [T case n² of {K => [KK] | N => [NN]} (c₁ l²) (c₁ r²)] | L => [LL]}: 71
//│ ------------------
//│ case n¹ of {K => [KK] | N => [NN]}: 31 --->
//│ 	[K]: 54
//│ case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₁ l¹) (c₂ r¹)] | L => [LL]}: 40 --->
//│ 	[T [K] aa₀ aa₁]: 57
//│ case n² of {K => [KK] | N => [NN]}: 62 --->
//│ 	[K]: 46
//│ 	[K]: 50
//│ 	[N]: 73
//│ case x² of {T n² l² r² => [T case n² of {K => [KK] | N => [NN]} (c₁ l²) (c₁ r²)] | L => [LL]}: 71 --->
//│ 	[T [K] aa₀ aa₀]: 49
//│ 	[T [K] aa₀ aa₀]: 53
//│ 	[T [N] t₁ t₂]: 76
//│ case n³ of {K => [KK] | N => [NN]}: 81 --->
//│ 	[N]: 42
//│ case x³ of {T n³ l³ r³ => [T case n³ of {K => [KK] | N => [NN]} (c₀ l³) (c₀ r³)] | L => [LL]}: 90 --->
//│ 	[T [N] t₀ t₀]: 45
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ t₀)
//│ def c₀ = 
//│ 	(fun x⁵ -> x⁵)
//│ 	where
//│ 	def c₁ = 
//│ 		(fun x⁴ -> x⁴)
//│ 	def c₂ = 
//│ 		(fun x⁶ -> x⁶)
//│ def t₀ = 
//│ 	let n⁴ = [KK]
//│ 	in let l⁴ = aa₀
//│ 	in let r⁴ = aa₁
//│ 	in [T n⁴ (c₁ l⁴) (c₂ r⁴)]
//│ 	where
//│ 	def aa₀ = 
//│ 		let n⁸ = [NN]
//│ 		in let l⁸ = t₁
//│ 		in let r⁸ = t₂
//│ 		in [T n⁸ (c₁ l⁸) (c₁ r⁸)]
//│ 		where
//│ 		def t₁ = 
//│ 			let n⁷ = [KK]
//│ 			in let l⁷ = aa₀
//│ 			in let r⁷ = aa₀
//│ 			in [T n⁷ (c₁ l⁷) (c₁ r⁷)]
//│ 		def t₂ = 
//│ 			let n⁶ = [KK]
//│ 			in let l⁶ = aa₀
//│ 			in let r⁶ = aa₀
//│ 			in [T n⁶ (c₁ l⁶) (c₁ r⁶)]
//│ 	def aa₁ = 
//│ 		let n⁵ = [NN]
//│ 		in let l⁵ = t₀
//│ 		in let r⁵ = t₀
//│ 		in [T n⁵ (c₀ l⁵) (c₀ r⁵)]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c₀^1] (hopeless to continue)
//│ [t₀^2] (hopeless to continue)
//│ 	[t₀^2 · aa₀^9] (using original def)
//│ 		[t₀^2 · aa₀^9 · c₁^70] (using original def)
//│ 		[t₀^2 · aa₀^9 · c₁^73] (using original def)
//│ 		[t₀^2 · aa₀^9 · t₁^67] (using original def)
//│ 			[t₀^2 · aa₀^9 · t₁^67 · aa₀^53] ---> [t₀^2 · aa₀^9] (using original def)
//│ 			[t₀^2 · aa₀^9 · t₁^67 · aa₀^54] ---> [t₀^2 · aa₀^9] (using original def)
//│ 			[t₀^2 · aa₀^9 · t₁^67 · c₁^56] (using original def)
//│ 			[t₀^2 · aa₀^9 · t₁^67 · c₁^59] (using original def)
//│ 		[t₀^2 · aa₀^9 · t₂^68] (using original def)
//│ 			[t₀^2 · aa₀^9 · t₂^68 · aa₀^39] ---> [t₀^2 · aa₀^9] (using original def)
//│ 			[t₀^2 · aa₀^9 · t₂^68 · aa₀^40] ---> [t₀^2 · aa₀^9] (using original def)
//│ 			[t₀^2 · aa₀^9 · t₂^68 · c₁^42] (using original def)
//│ 			[t₀^2 · aa₀^9 · t₂^68 · c₁^45] (using original def)
//│ 	[t₀^2 · aa₁^10] (using original def)
//│ 		[t₀^2 · aa₁^10 · c₀^28] (using original def)
//│ 		[t₀^2 · aa₁^10 · c₀^31] (using original def)
//│ 		[t₀^2 · aa₁^10 · t₀^25] ---> [t₀^2] (using original def)
//│ 		[t₀^2 · aa₁^10 · t₀^26] ---> [t₀^2] (using original def)
//│ 	[t₀^2 · c₁^12] (using original def)
//│ 	[t₀^2 · c₂^15] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀₀ t₀₀)
//│ def c₀₀ = 
//│ 	(fun x⁶ -> x⁶)
//│ def t₀₀ = 
//│ 	let n⁸ = [KK]
//│ 	in let l⁸ = aa₀₀
//│ 	in let r⁸ = aa₁₀
//│ 	in [T n⁸ (c₁₆ l⁸) (c₂₀ r⁸)]
//│ 	where
//│ 	def aa₀₀ = 
//│ 		let n⁷ = [NN]
//│ 		in let l⁷ = t₁₀
//│ 		in let r⁷ = t₂₀
//│ 		in [T n⁷ (c₁₀ l⁷) (c₁₁ r⁷)]
//│ 		where
//│ 		def c₁₀ = 
//│ 			(fun x¹² -> x¹²)
//│ 		def c₁₁ = 
//│ 			(fun x¹³ -> x¹³)
//│ 		def t₁₀ = 
//│ 			let n⁵ = [KK]
//│ 			in let l⁵ = aa₀₀
//│ 			in let r⁵ = aa₀₀
//│ 			in [T n⁵ (c₁₂ l⁵) (c₁₃ r⁵)]
//│ 			where
//│ 			def c₁₂ = 
//│ 				(fun x⁹ -> x⁹)
//│ 			def c₁₃ = 
//│ 				(fun x⁴ -> x⁴)
//│ 		def t₂₀ = 
//│ 			let n⁹ = [KK]
//│ 			in let l⁹ = aa₀₀
//│ 			in let r⁹ = aa₀₀
//│ 			in [T n⁹ (c₁₄ l⁹) (c₁₅ r⁹)]
//│ 			where
//│ 			def c₁₄ = 
//│ 				(fun x⁵ -> x⁵)
//│ 			def c₁₅ = 
//│ 				(fun x¹¹ -> x¹¹)
//│ 	def aa₁₀ = 
//│ 		let n⁶ = [NN]
//│ 		in let l⁶ = t₀₀
//│ 		in let r⁶ = t₀₀
//│ 		in [T n⁶ (c₀₁ l⁶) (c₀₂ r⁶)]
//│ 		where
//│ 		def c₀₁ = 
//│ 			(fun x⁷ -> x⁷)
//│ 		def c₀₂ = 
//│ 			(fun x³ -> x³)
//│ 	def c₁₆ = 
//│ 		(fun x¹⁰ -> x¹⁰)
//│ 	def c₂₀ = 
//│ 		(fun x⁸ -> x⁸)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀₀ t₀₀)
//│ def c₀₀ = 
//│ 	(fun x²³ -> x²³)
//│ def t₀₀ = 
//│ 	let n⁸ = [KK]
//│ 	in let l⁸ = aa₀₀
//│ 	in let r⁸ = aa₁₀
//│ 	in [T n⁸ (c₁₆ l⁸) (c₂₀ r⁸)]
//│ 	where
//│ 	def aa₀₀ = 
//│ 		let n⁷ = [NN]
//│ 		in let l⁷ = t₁₀
//│ 		in let r⁷ = t₂₀
//│ 		in [T n⁷ (c₁₀ l⁷) (c₁₁ r⁷)]
//│ 		where
//│ 		def c₁₀ = 
//│ 			(fun x¹⁹ -> x¹⁹)
//│ 		def c₁₁ = 
//│ 			(fun x¹⁴ -> x¹⁴)
//│ 		def t₁₀ = 
//│ 			let n⁵ = [KK]
//│ 			in let l⁵ = aa₀₀
//│ 			in let r⁵ = aa₀₀
//│ 			in [T n⁵ (c₁₂ l⁵) (c₁₃ r⁵)]
//│ 			where
//│ 			def c₁₂ = 
//│ 				(fun x¹⁸ -> x¹⁸)
//│ 			def c₁₃ = 
//│ 				(fun x¹⁶ -> x¹⁶)
//│ 		def t₂₀ = 
//│ 			let n⁹ = [KK]
//│ 			in let l⁹ = aa₀₀
//│ 			in let r⁹ = aa₀₀
//│ 			in [T n⁹ (c₁₄ l⁹) (c₁₅ r⁹)]
//│ 			where
//│ 			def c₁₄ = 
//│ 				(fun x²⁰ -> x²⁰)
//│ 			def c₁₅ = 
//│ 				(fun x¹⁷ -> x¹⁷)
//│ 	def aa₁₀ = 
//│ 		let n⁶ = [NN]
//│ 		in let l⁶ = t₀₀
//│ 		in let r⁶ = t₀₀
//│ 		in [T n⁶ (c₀₁ l⁶) (c₀₂ r⁶)]
//│ 		where
//│ 		def c₀₁ = 
//│ 			(fun x²⁴ -> x²⁴)
//│ 		def c₀₂ = 
//│ 			(fun x²² -> x²²)
//│ 	def c₁₆ = 
//│ 		(fun x¹⁵ -> x¹⁵)
//│ 	def c₂₀ = 
//│ 		(fun x²¹ -> x²¹)
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: but explode on branches
fun filter(ls) = if ls is
  C(h, t) then if h > 1 is
    True then C(h, filter(t))
    False then filter(t)
  N then N
filter(C(1, C(2, C(3, N))))
//│ |#fun| |filter|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |>| |1| |is|→|True| |#then| |C|(|h|,| |filter|(|t|)|)|↵|False| |#then| |filter|(|t|)|←|↵|N| |#then| |N|←|↵|filter|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {fun filter = ls, => if ls is ‹(C (h, t,)) then if > (h,) (1,) is ‹(True) then C (h, filter (t,),); (False) then filter (t,)›; (N) then N›; filter (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (filter^19 [C 1 [C 2 [C 3 [N]]]])
//│ def filter = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => case (h⁰ > 1) of {
//│ 		True => [C h⁰ (filter^8 t⁰)]
//│ 		| False => (filter^12 t⁰)}
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [filter^19]
//│ 	[filter^19 · filter^12] ---> [filter^19] (only one)
//│ 	[filter^19 · filter^8] (hopeless to continue)
//│ 		[filter^19 · filter^8 · filter^12] ---> [filter^19 · filter^8] (using original def)
//│ 		[filter^19 · filter^8 · filter^8] ---> [filter^19 · filter^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (filter₀ [C 1 [C 2 [C 3 [N]]]])
//│ def filter₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => case (h¹ > 1) of {
//│ 			True => [C h¹ (filter₁ t¹)]
//│ 			| False => (filter₀ t¹)}
//│ 		| N => [N]})
//│ 	where
//│ 	def filter₁ = 
//│ 		(fun ls² -> case ls² of {
//│ 			C h² t² => case (h² > 1) of {
//│ 				True => [C h² (filter₁ t²)]
//│ 				| False => (filter₁ t²)}
//│ 			| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 68 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True => [C h¹ (filter₁ t¹)] | False => (filter₀ t¹)} | N => [N]}: 44
//│ 	case ls² of {C h² t² => case (h² > 1) of {True => [C h² (filter₁ t²)] | False => (filter₁ t²)} | N => [N]}: 62
//│ [C 3 [N]]: 69 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True => [C h¹ (filter₁ t¹)] | False => (filter₀ t¹)} | N => [N]}: 44
//│ 	case ls² of {C h² t² => case (h² > 1) of {True => [C h² (filter₁ t²)] | False => (filter₁ t²)} | N => [N]}: 62
//│ [C 2 [C 3 [N]]]: 70 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True => [C h¹ (filter₁ t¹)] | False => (filter₀ t¹)} | N => [N]}: 44
//│ 	case ls² of {C h² t² => case (h² > 1) of {True => [C h² (filter₁ t²)] | False => (filter₁ t²)} | N => [N]}: 62
//│ [C 1 [C 2 [C 3 [N]]]]: 71 --->
//│ 	case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True => [C h¹ (filter₁ t¹)] | False => (filter₀ t¹)} | N => [N]}: 44
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => case (h¹ > 1) of {True => [C h¹ (filter₁ t¹)] | False => (filter₀ t¹)} | N => [N]}: 44 --->
//│ 	[N]: 68
//│ 	[C 3 [N]]: 69
//│ 	[C 2 [C 3 [N]]]: 70
//│ 	[C 1 [C 2 [C 3 [N]]]]: 71
//│ case ls² of {C h² t² => case (h² > 1) of {True => [C h² (filter₁ t²)] | False => (filter₁ t²)} | N => [N]}: 62 --->
//│ 	[N]: 68
//│ 	[C 3 [N]]: 69
//│ 	[C 2 [C 3 [N]]]: 70
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (filter₀ [C 1 [C 2 [C 3 [N]]]])
//│ def filter₀ = 
//│ 	(fun ls³ -> case ls³ of {
//│ 		C h¹ t¹ => case (h¹ > 1) of {
//│ 			True => [C h¹ (filter₁ t¹)]
//│ 			| False => (filter₀ t¹)}
//│ 		| N => [N]})
//│ 	where
//│ 	def filter₁ = 
//│ 		(fun ls⁴ -> case ls⁴ of {
//│ 			C h² t² => case (h² > 1) of {
//│ 				True => [C h² (filter₁ t²)]
//│ 				| False => (filter₁ t²)}
//│ 			| N => [N]})
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: top level defs used multiple times are fine
// but top level producers used multiple times may result in duplicated computation
let p = C(p)
let pp = C(C(pp))
fun c(x) = if x is
  C(a) then if a is
    C(b) then c(b)
    N then a
  N then x
P(c(pp), c(p))
//│ |#let| |p| |#=| |C|(|p|)|↵|#let| |pp| |#=| |C|(|C|(|pp|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |c|(|b|)|↵|N| |#then| |a|←|↵|N| |#then| |x|←|↵|P|(|c|(|pp|)|,| |c|(|p|)|)|
//│ Parsed: {let p = C (p,); let pp = C (C (pp,),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then c (b,); (N) then a›; (N) then x›; P (c (pp,), c (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ [P (c^16 pp^17) (c^19 p^20)]
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => (c^8 b⁰)
//│ 		| N => a⁰}
//│ 	| N => x⁰})
//│ def p = [C p^1]
//│ def pp = [C [C pp^3]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^16]
//│ 	[c^16 · c^8] ---> [c^16] (only one)
//│ [c^19]
//│ 	[c^19 · c^8] ---> [c^19] (only one)
//│ [p^20]
//│ 	[p^20 · p^1]
//│ 		[p^20 · p^1 · p^1] ---> [p^20] (only one)
//│ [pp^17]
//│ 	[pp^17 · pp^3] ---> [pp^17] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ [P (c₀ pp₀) (c₁ p₀)]
//│ def c₀ = 
//│ 	(fun x² -> case x² of {
//│ 		C a² => case a² of {
//│ 			C b² => (c₀ b²)
//│ 			| N => a²}
//│ 		| N => x²})
//│ def c₁ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C a¹ => case a¹ of {
//│ 			C b¹ => (c₁ b¹)
//│ 			| N => a¹}
//│ 		| N => x¹})
//│ def p₀ = 
//│ 	[C p₁]
//│ 	where
//│ 	def p₁ = 
//│ 		[C p₀]
//│ def pp₀ = 
//│ 	[C [C pp₀]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C pp₀]: 24 --->
//│ 	case a² of {C b² => (c₀ b²) | N => a²}: 46
//│ 	'52_callres
//│ [C [C pp₀]]: 25 --->
//│ 	case x² of {C a² => case a² of {C b² => (c₀ b²) | N => a²} | N => x²}: 48
//│ 	'52_callres
//│ [C p₀]: 37 --->
//│ 	case a¹ of {C b¹ => (c₁ b¹) | N => a¹}: 32
//│ 	'55_callres
//│ [C p₁]: 39 --->
//│ 	case x¹ of {C a¹ => case a¹ of {C b¹ => (c₁ b¹) | N => a¹} | N => x¹}: 34
//│ 	'55_callres
//│ ------------------
//│ case a¹ of {C b¹ => (c₁ b¹) | N => a¹}: 32 --->
//│ 	[C p₀]: 37
//│ case x¹ of {C a¹ => case a¹ of {C b¹ => (c₁ b¹) | N => a¹} | N => x¹}: 34 --->
//│ 	[C p₁]: 39
//│ case a² of {C b² => (c₀ b²) | N => a²}: 46 --->
//│ 	[C pp₀]: 24
//│ case x² of {C a² => case a² of {C b² => (c₀ b²) | N => a²} | N => x²}: 48 --->
//│ 	[C [C pp₀]]: 25
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ [P (c₀ pp₀) (c₁ p₀)]
//│ def c₀ = 
//│ 	(fun x³ -> case x³ of {
//│ 		C a² => case a² of {
//│ 			C b² => (c₀ b²)
//│ 			| N => a²}
//│ 		| N => x³})
//│ def c₁ = 
//│ 	(fun x⁴ -> case x⁴ of {
//│ 		C a¹ => case a¹ of {
//│ 			C b¹ => (c₁ b¹)
//│ 			| N => a¹}
//│ 		| N => x⁴})
//│ def p₀ = 
//│ 	[C p₁]
//│ 	where
//│ 	def p₁ = 
//│ 		[C p₀]
//│ def pp₀ = 
//│ 	[C [C pp₀]]
//│ <<<<<<< after fusion <<<<<<<


// CORRECT:
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  N then a => a
  C(h, t) then a => rev(t, C(h, a))
fun rev2(ls2) = if ls2 is
  N then a2 => a2
  C(h2, t2) then a2 => rev2(t2, C(h2, a2))
rev2(rev(C(1, C(2, N)))(N))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a| |=>| |a|↵|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|,| |C|(|h|,| |a|)|)|←|↵|#fun| |rev2|(|ls2|)| |#=| |#if| |ls2| |is|→|N| |#then| |a2| |=>| |a2|↵|C|(|h2|,| |t2|)| |#then| |a2| |=>| |rev2|(|t2|,| |C|(|h2|,| |a2|)|)|←|↵|rev2|(|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|N|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(N) then a, => a; (C (h, t,)) then a, => rev (t, C (h, a,),)›; fun rev2 = ls2, => if ls2 is ‹(N) then a2, => a2; (C (h2, t2,)) then a2, => rev2 (t2, C (h2, a2,),)›; rev2 (rev (C (1, C (2, N,),),) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev2^27 ((rev^28 [C 1 [C 2 [N]]]) [N])) [N])
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	N => (fun a⁰ -> a⁰)
//│ 	| C h⁰ t⁰ => (fun a¹ -> ((rev^4 t⁰) [C h⁰ a¹]))})
//│ def rev2 = (fun ls2⁰ -> case ls2⁰ of {
//│ 	N => (fun a2⁰ -> a2⁰)
//│ 	| C h2⁰ t2⁰ => (fun a2¹ -> ((rev2^17 t2⁰) [C h2⁰ a2¹]))})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev2^27] (hopeless to continue)
//│ 	[rev2^27 · rev2^17] ---> [rev2^27] (using original def)
//│ [rev^28] (hopeless to continue)
//│ 	[rev^28 · rev^4] ---> [rev^28] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev2₀ ((rev₀ [C 1 [C 2 [N]]]) [N])) [N])
//│ def rev2₀ = 
//│ 	(fun ls2¹ -> case ls2¹ of {
//│ 		N => (fun a2² -> a2²)
//│ 		| C h2¹ t2¹ => (fun a2³ -> ((rev2₀ t2¹) [C h2¹ a2³]))})
//│ def rev₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		N => (fun a² -> a²)
//│ 		| C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ a³]: 61 --->
//│ 	case ls2¹ of {N => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> ((rev2₀ t2¹) [C h2¹ a2³]))}: 51
//│ [N]: 70 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 64
//│ [C 2 [N]]: 71 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 64
//│ [C 1 [C 2 [N]]]: 72 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 64
//│ [N]: 74 --->
//│ 	case ls2¹ of {N => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> ((rev2₀ t2¹) [C h2¹ a2³]))}: 51
//│ ------------------
//│ case ls2¹ of {N => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> ((rev2₀ t2¹) [C h2¹ a2³]))}: 51 --->
//│ 	[C h¹ a³]: 61
//│ 	[N]: 74
//│ case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 64 --->
//│ 	[N]: 70
//│ 	[C 2 [N]]: 71
//│ 	[C 1 [C 2 [N]]]: 72
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a³]: 61 --->
//│ 	case ls2¹ of {N => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> ((rev2₀ t2¹) [C h2¹ a2³]))}: 51
//│ [N]: 70 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 64
//│ [C 2 [N]]: 71 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 64
//│ [C 1 [C 2 [N]]]: 72 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 64
//│ [N]: 74 --->
//│ 	case ls2¹ of {N => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> ((rev2₀ t2¹) [C h2¹ a2³]))}: 51
//│ ------------------
//│ case ls2¹ of {N => (fun a2² -> a2²) | C h2¹ t2¹ => (fun a2³ -> ((rev2₀ t2¹) [C h2¹ a2³]))}: 51 --->
//│ 	[C h¹ a³]: 61
//│ 	[N]: 74
//│ case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 64 --->
//│ 	[N]: 70
//│ 	[C 2 [N]]: 71
//│ 	[C 1 [C 2 [N]]]: 72
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev2₀ ((rev₀ 
//│ 	let h² = 1
//│ 	in let t² = 	
//│ 		let h³ = 2
//│ 		in let t³ = (fun a⁶ -> a⁶)
//│ 		in (fun a⁵ -> ((rev₀ t³) 
//│ 			let h2³ = h³
//│ 			in let t2³ = a⁵
//│ 			in (fun a2⁵ -> ((rev2₀ t2³) [C h2³ a2⁵]))))
//│ 	in (fun a⁴ -> ((rev₀ t²) 
//│ 		let h2² = h²
//│ 		in let t2² = a⁴
//│ 		in (fun a2⁴ -> ((rev2₀ t2²) [C h2² a2⁴]))))) (fun a2⁶ -> a2⁶))) [N])
//│ def rev2₀ = 
//│ 	(fun ls2² -> ls2²)
//│ def rev₀ = 
//│ 	(fun ls² -> ls²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev2₀^12] (hopeless to continue)
//│ [rev2₀^1] (hopeless to continue)
//│ [rev2₀^31] (hopeless to continue)
//│ [rev₀^26] (hopeless to continue)
//│ [rev₀^2] (hopeless to continue)
//│ [rev₀^7] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev2₀₁ ((rev₀₁ 
//│ 	let h² = 1
//│ 	in let t² = 	
//│ 		let h³ = 2
//│ 		in let t³ = (fun a³ -> a³)
//│ 		in (fun a⁴ -> ((rev₀₂ t³) 
//│ 			let h2² = h³
//│ 			in let t2² = a⁴
//│ 			in (fun a2³ -> ((rev2₀₀ t2²) [C h2² a2³]))))
//│ 	in (fun a⁵ -> ((rev₀₀ t²) 
//│ 		let h2³ = h²
//│ 		in let t2³ = a⁵
//│ 		in (fun a2⁴ -> ((rev2₀₂ t2³) [C h2³ a2⁴]))))) (fun a2⁵ -> a2⁵))) [N])
//│ def rev2₀₀ = 
//│ 	(fun ls2² -> ls2²)
//│ def rev2₀₁ = 
//│ 	(fun ls2³ -> ls2³)
//│ def rev2₀₂ = 
//│ 	(fun ls2¹ -> ls2¹)
//│ def rev₀₀ = 
//│ 	(fun ls² -> ls²)
//│ def rev₀₁ = 
//│ 	(fun ls³ -> ls³)
//│ def rev₀₂ = 
//│ 	(fun ls¹ -> ls¹)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev2₀₁ ((rev₀₁ 
//│ 	let h² = 1
//│ 	in let t² = 	
//│ 		let h³ = 2
//│ 		in let t³ = (fun a⁶ -> a⁶)
//│ 		in (fun a⁷ -> ((rev₀₂ t³) 
//│ 			let h2² = h³
//│ 			in let t2² = a⁷
//│ 			in (fun a2⁶ -> ((rev2₀₀ t2²) [C h2² a2⁶]))))
//│ 	in (fun a⁸ -> ((rev₀₀ t²) 
//│ 		let h2³ = h²
//│ 		in let t2³ = a⁸
//│ 		in (fun a2⁷ -> ((rev2₀₂ t2³) [C h2³ a2⁷]))))) (fun a2⁸ -> a2⁸))) [N])
//│ def rev2₀₀ = 
//│ 	(fun ls2⁵ -> ls2⁵)
//│ def rev2₀₁ = 
//│ 	(fun ls2⁴ -> ls2⁴)
//│ def rev2₀₂ = 
//│ 	(fun ls2⁶ -> ls2⁶)
//│ def rev₀₀ = 
//│ 	(fun ls⁵ -> ls⁵)
//│ def rev₀₁ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ def rev₀₂ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [N]]]
//│ <<<<<<< evaluate <<<<<<<


// CORRECT: rev actually works (despite the fact that there are some match clash),
// and duplicated usage of toplevel things are alright
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
rev(C(A, C(B, N)))(N)
rev(rev(C(A, C(B, N)))(N))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|rev|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|N|)|↵|rev|(|rev|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|N|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; rev (C (A, C (B, N,),),) (N,); rev (rev (C (A, C (B, N,),),) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev^14 [C [A] [C [B] [N]]]) [N])
//│ ((rev^23 ((rev^24 [C [A] [C [B] [N]]]) [N])) [N])
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> ((rev^2 t⁰) [C h⁰ a⁰]))
//│ 	| N => (fun a¹ -> a¹)})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14] (hopeless to continue)
//│ 	[rev^14 · rev^2] ---> [rev^14] (using original def)
//│ [rev^23] (hopeless to continue)
//│ 	[rev^23 · rev^2] ---> [rev^23] (using original def)
//│ [rev^24] (hopeless to continue)
//│ 	[rev^24 · rev^2] ---> [rev^24] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev₀ [C [A] [C [B] [N]]]) [N])
//│ ((rev₁ ((rev₂ [C [A] [C [B] [N]]]) [N])) [N])
//│ def rev₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h² t² => (fun a⁴ -> ((rev₀ t²) [C h² a⁴]))
//│ 		| N => (fun a⁵ -> a⁵)})
//│ def rev₁ = 
//│ 	(fun ls³ -> case ls³ of {
//│ 		C h³ t³ => (fun a⁶ -> ((rev₁ t³) [C h³ a⁶]))
//│ 		| N => (fun a⁷ -> a⁷)})
//│ def rev₂ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => (fun a² -> ((rev₂ t¹) [C h¹ a²]))
//│ 		| N => (fun a³ -> a³)})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ a²]: 42 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> ((rev₁ t³) [C h³ a⁶])) | N => (fun a⁷ -> a⁷)}: 73
//│ [N]: 78 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> ((rev₀ t²) [C h² a⁴])) | N => (fun a⁵ -> a⁵)}: 60
//│ [C [B] [N]]: 79 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> ((rev₀ t²) [C h² a⁴])) | N => (fun a⁵ -> a⁵)}: 60
//│ [C [A] [C [B] [N]]]: 80 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> ((rev₀ t²) [C h² a⁴])) | N => (fun a⁵ -> a⁵)}: 60
//│ [N]: 88 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₂ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 47
//│ [C [B] [N]]: 89 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₂ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 47
//│ [C [A] [C [B] [N]]]: 90 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₂ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 47
//│ [N]: 92 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> ((rev₁ t³) [C h³ a⁶])) | N => (fun a⁷ -> a⁷)}: 73
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₂ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 47 --->
//│ 	[N]: 88
//│ 	[C [B] [N]]: 89
//│ 	[C [A] [C [B] [N]]]: 90
//│ case ls² of {C h² t² => (fun a⁴ -> ((rev₀ t²) [C h² a⁴])) | N => (fun a⁵ -> a⁵)}: 60 --->
//│ 	[N]: 78
//│ 	[C [B] [N]]: 79
//│ 	[C [A] [C [B] [N]]]: 80
//│ case ls³ of {C h³ t³ => (fun a⁶ -> ((rev₁ t³) [C h³ a⁶])) | N => (fun a⁷ -> a⁷)}: 73 --->
//│ 	[C h¹ a²]: 42
//│ 	[N]: 92
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a²]: 42 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> ((rev₁ t³) [C h³ a⁶])) | N => (fun a⁷ -> a⁷)}: 73
//│ [N]: 78 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> ((rev₀ t²) [C h² a⁴])) | N => (fun a⁵ -> a⁵)}: 60
//│ [C [B] [N]]: 79 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> ((rev₀ t²) [C h² a⁴])) | N => (fun a⁵ -> a⁵)}: 60
//│ [C [A] [C [B] [N]]]: 80 --->
//│ 	case ls² of {C h² t² => (fun a⁴ -> ((rev₀ t²) [C h² a⁴])) | N => (fun a⁵ -> a⁵)}: 60
//│ [N]: 88 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₂ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 47
//│ [C [B] [N]]: 89 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₂ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 47
//│ [C [A] [C [B] [N]]]: 90 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₂ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 47
//│ [N]: 92 --->
//│ 	case ls³ of {C h³ t³ => (fun a⁶ -> ((rev₁ t³) [C h³ a⁶])) | N => (fun a⁷ -> a⁷)}: 73
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₂ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 47 --->
//│ 	[N]: 88
//│ 	[C [B] [N]]: 89
//│ 	[C [A] [C [B] [N]]]: 90
//│ case ls² of {C h² t² => (fun a⁴ -> ((rev₀ t²) [C h² a⁴])) | N => (fun a⁵ -> a⁵)}: 60 --->
//│ 	[N]: 78
//│ 	[C [B] [N]]: 79
//│ 	[C [A] [C [B] [N]]]: 80
//│ case ls³ of {C h³ t³ => (fun a⁶ -> ((rev₁ t³) [C h³ a⁶])) | N => (fun a⁷ -> a⁷)}: 73 --->
//│ 	[C h¹ a²]: 42
//│ 	[N]: 92
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev₀ 
//│ 	let h⁴ = [A]
//│ 	in let t⁴ = 	
//│ 		let h⁵ = [B]
//│ 		in let t⁵ = (fun a¹⁰ -> a¹⁰)
//│ 		in (fun a⁹ -> ((rev₀ t⁵) [C h⁵ a⁹]))
//│ 	in (fun a⁸ -> ((rev₀ t⁴) [C h⁴ a⁸]))) [N])
//│ ((rev₁ ((rev₂ 
//│ 	let h⁶ = [A]
//│ 	in let t⁶ = 	
//│ 		let h⁸ = [B]
//│ 		in let t⁸ = (fun a¹⁵ -> a¹⁵)
//│ 		in (fun a¹³ -> ((rev₂ t⁸) 
//│ 			let h⁹ = h⁸
//│ 			in let t⁹ = a¹³
//│ 			in (fun a¹⁴ -> ((rev₁ t⁹) [C h⁹ a¹⁴]))))
//│ 	in (fun a¹¹ -> ((rev₂ t⁶) 
//│ 		let h⁷ = h⁶
//│ 		in let t⁷ = a¹¹
//│ 		in (fun a¹² -> ((rev₁ t⁷) [C h⁷ a¹²]))))) (fun a¹⁶ -> a¹⁶))) [N])
//│ def rev₀ = 
//│ 	(fun ls⁵ -> ls⁵)
//│ def rev₁ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ def rev₂ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [B] [C [A] [N]]]
//│ [C [A] [C [B] [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev₀^16] (hopeless to continue)
//│ [rev₀^1] (hopeless to continue)
//│ [rev₀^6] (hopeless to continue)
//│ [rev₁^29] (hopeless to continue)
//│ [rev₁^40] (hopeless to continue)
//│ [rev₁^59] (hopeless to continue)
//│ [rev₂^30] (hopeless to continue)
//│ [rev₂^35] (hopeless to continue)
//│ [rev₂^54] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev₀₁ 
//│ 	let h⁶ = [A]
//│ 	in let t⁶ = 	
//│ 		let h⁷ = [B]
//│ 		in let t⁷ = (fun a⁹ -> a⁹)
//│ 		in (fun a¹⁰ -> ((rev₀₂ t⁷) [C h⁷ a¹⁰]))
//│ 	in (fun a¹¹ -> ((rev₀₀ t⁶) [C h⁶ a¹¹]))) [N])
//│ ((rev₁₀ ((rev₂₀ 
//│ 	let h⁸ = [A]
//│ 	in let t⁸ = 	
//│ 		let h⁹ = [B]
//│ 		in let t⁹ = (fun a¹² -> a¹²)
//│ 		in (fun a¹³ -> ((rev₂₁ t⁹) 
//│ 			let h¹⁰ = h⁹
//│ 			in let t¹⁰ = a¹³
//│ 			in (fun a¹⁴ -> ((rev₁₁ t¹⁰) [C h¹⁰ a¹⁴]))))
//│ 	in (fun a¹⁵ -> ((rev₂₂ t⁸) 
//│ 		let h¹¹ = h⁸
//│ 		in let t¹¹ = a¹⁵
//│ 		in (fun a¹⁶ -> ((rev₁₂ t¹¹) [C h¹¹ a¹⁶]))))) (fun a¹⁷ -> a¹⁷))) [N])
//│ def rev₀₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ def rev₀₁ = 
//│ 	(fun ls⁷ -> ls⁷)
//│ def rev₀₂ = 
//│ 	(fun ls¹⁰ -> ls¹⁰)
//│ def rev₁₀ = 
//│ 	(fun ls⁵ -> ls⁵)
//│ def rev₁₁ = 
//│ 	(fun ls¹¹ -> ls¹¹)
//│ def rev₁₂ = 
//│ 	(fun ls⁸ -> ls⁸)
//│ def rev₂₀ = 
//│ 	(fun ls³ -> ls³)
//│ def rev₂₁ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ def rev₂₂ = 
//│ 	(fun ls⁹ -> ls⁹)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev₀₁ 
//│ 	let h⁶ = [A]
//│ 	in let t⁶ = 	
//│ 		let h⁷ = [B]
//│ 		in let t⁷ = (fun a¹⁸ -> a¹⁸)
//│ 		in (fun a¹⁹ -> ((rev₀₂ t⁷) [C h⁷ a¹⁹]))
//│ 	in (fun a²⁰ -> ((rev₀₀ t⁶) [C h⁶ a²⁰]))) [N])
//│ ((rev₁₀ ((rev₂₀ 
//│ 	let h⁸ = [A]
//│ 	in let t⁸ = 	
//│ 		let h⁹ = [B]
//│ 		in let t⁹ = (fun a²¹ -> a²¹)
//│ 		in (fun a²² -> ((rev₂₁ t⁹) 
//│ 			let h¹⁰ = h⁹
//│ 			in let t¹⁰ = a²²
//│ 			in (fun a²³ -> ((rev₁₁ t¹⁰) [C h¹⁰ a²³]))))
//│ 	in (fun a²⁴ -> ((rev₂₂ t⁸) 
//│ 		let h¹¹ = h⁸
//│ 		in let t¹¹ = a²⁴
//│ 		in (fun a²⁵ -> ((rev₁₂ t¹¹) [C h¹¹ a²⁵]))))) (fun a²⁶ -> a²⁶))) [N])
//│ def rev₀₀ = 
//│ 	(fun ls¹⁸ -> ls¹⁸)
//│ def rev₀₁ = 
//│ 	(fun ls¹⁹ -> ls¹⁹)
//│ def rev₀₂ = 
//│ 	(fun ls¹⁶ -> ls¹⁶)
//│ def rev₁₀ = 
//│ 	(fun ls²⁰ -> ls²⁰)
//│ def rev₁₁ = 
//│ 	(fun ls¹⁴ -> ls¹⁴)
//│ def rev₁₂ = 
//│ 	(fun ls¹² -> ls¹²)
//│ def rev₂₀ = 
//│ 	(fun ls¹³ -> ls¹³)
//│ def rev₂₁ = 
//│ 	(fun ls¹⁵ -> ls¹⁵)
//│ def rev₂₂ = 
//│ 	(fun ls¹⁷ -> ls¹⁷)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [B] [C [A] [N]]]
//│ [C [A] [C [B] [N]]]
//│ <<<<<<< evaluate <<<<<<<

// CORRECT: using primitive is also correct
fun rev(ls) = if ls is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
rev(rev(primitive)(N))(N)
//│ |#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|rev|(|rev|(|primitive|)|(|N|)|)|(|N|)|
//│ Parsed: {fun rev = ls, => if ls is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; rev (rev (primitive,) (N,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev^14 ((rev^15 primitive⁰) [N])) [N])
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> ((rev^2 t⁰) [C h⁰ a⁰]))
//│ 	| N => (fun a¹ -> a¹)})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14] (hopeless to continue)
//│ 	[rev^14 · rev^2] ---> [rev^14] (using original def)
//│ [rev^15] (hopeless to continue)
//│ 	[rev^15 · rev^2] ---> [rev^15] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev₀ ((rev₁ primitive⁰) [N])) [N])
//│ def rev₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²]))
//│ 		| N => (fun a³ -> a³)})
//│ def rev₁ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h² t² => (fun a⁴ -> ((rev₁ t²) [C h² a⁴]))
//│ 		| N => (fun a⁵ -> a⁵)})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h² a⁴]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 34
//│ [N]: 53 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 34
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 34 --->
//│ 	[C h² a⁴]: 42
//│ 	[N]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h² a⁴]: 42 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 34
//│ [N]: 53 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 34
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 34 --->
//│ 	[C h² a⁴]: 42
//│ 	[N]: 53
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev₀ ((rev₁ primitive⁰) (fun a⁶ -> a⁶))) [N])
//│ def rev₀ = 
//│ 	(fun ls³ -> ls³)
//│ def rev₁ = 
//│ 	(fun ls⁴ -> case ls⁴ of {
//│ 		C h² t² => (fun a⁷ -> ((rev₁ t²) 
//│ 			let h³ = h²
//│ 			in let t³ = a⁷
//│ 			in (fun a⁸ -> ((rev₀ t³) [C h³ a⁸]))))
//│ 		| N => (fun a⁹ -> a⁹)})
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev₀^1] (hopeless to continue)
//│ [rev₁^2] (hopeless to continue)
//│ 	[rev₁^2 · rev₀^19] (using original def)
//│ 	[rev₁^2 · rev₁^14] ---> [rev₁^2] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev₀₀ ((rev₁₀ primitive⁰) (fun a⁷ -> a⁷))) [N])
//│ def rev₀₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ def rev₁₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h² t² => (fun a⁴ -> ((rev₁₀ t²) 
//│ 			let h³ = h²
//│ 			in let t³ = a⁴
//│ 			in (fun a⁵ -> ((rev₀₁ t³) [C h³ a⁵]))))
//│ 		| N => (fun a⁶ -> a⁶)})
//│ 	where
//│ 	def rev₀₁ = 
//│ 		(fun ls³ -> ls³)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev₀₀ ((rev₁₀ primitive⁰) (fun a⁸ -> a⁸))) [N])
//│ def rev₀₀ = 
//│ 	(fun ls⁷ -> ls⁷)
//│ def rev₁₀ = 
//│ 	(fun ls⁵ -> case ls⁵ of {
//│ 		C h² t² => (fun a⁹ -> ((rev₁₀ t²) 
//│ 			let h³ = h²
//│ 			in let t³ = a⁹
//│ 			in (fun a¹⁰ -> ((rev₀₁ t³) [C h³ a¹⁰]))))
//│ 		| N => (fun a¹¹ -> a¹¹)})
//│ 	where
//│ 	def rev₀₁ = 
//│ 		(fun ls⁶ -> ls⁶)
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: even normal rev can be optimized?
// NOTE: may be only out of luck: we choose 
_LUMBERHACK_EVAL
fun concat(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(C(1, C(2, N)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (rev^27 [C 1 [C 2 [N]]])
//│ def concat = (fun xs⁰ -> case xs⁰ of {
//│ 	N => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ ((concat^5 t⁰) ys¹)])})
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	C h¹ t¹ => ((concat^15 (rev^16 t¹)) [C h¹ [N]])
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^27]
//│ 	[rev^27 · concat^15] (hopeless to continue)
//│ 		[rev^27 · concat^15 · concat^5] ---> [rev^27 · concat^15] (using original def)
//│ 	[rev^27 · rev^16] ---> [rev^27] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (rev₀ [C 1 [C 2 [N]]])
//│ def rev₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]])
//│ 		| N => [N]})
//│ 	where
//│ 	def concat₀ = 
//│ 		(fun xs¹ -> case xs¹ of {
//│ 			N => (fun ys² -> ys²)
//│ 			| C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h² ((concat₀ t²) ys³)]: 43 --->
//│ 	'lumberhackTopLevelResult
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])}: 45
//│ [N]: 54 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])}: 45
//│ [C h³ [N]]: 55 --->
//│ 	'lumberhackTopLevelResult
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])}: 45
//│ [N]: 57 --->
//│ 	'lumberhackTopLevelResult
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])}: 45
//│ [N]: 63 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58
//│ [C 2 [N]]: 64 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58
//│ [C 1 [C 2 [N]]]: 65 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58
//│ ------------------
//│ case xs¹ of {N => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])}: 45 --->
//│ 	[C h² ((concat₀ t²) ys³)]: 43
//│ 	[N]: 54
//│ 	[C h³ [N]]: 55
//│ 	[N]: 57
//│ case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58 --->
//│ 	[N]: 63
//│ 	[C 2 [N]]: 64
//│ 	[C 1 [C 2 [N]]]: 65
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 63 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58
//│ [C 2 [N]]: 64 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58
//│ [C 1 [C 2 [N]]]: 65 --->
//│ 	case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58
//│ ------------------
//│ case ls¹ of {C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]]) | N => [N]}: 58 --->
//│ 	[N]: 63
//│ 	[C 2 [N]]: 64
//│ 	[C 1 [C 2 [N]]]: 65
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (rev₀ 
//│ 	let h⁴ = 1
//│ 	in let t⁴ = 	
//│ 		let h⁵ = 2
//│ 		in let t⁵ = [N]
//│ 		in ((concat₀ (rev₀ t⁵)) [C h⁵ [N]])
//│ 	in ((concat₀ (rev₀ t⁴)) [C h⁴ [N]]))
//│ def rev₀ = 
//│ 	(fun ls² -> ls²)
//│ 	where
//│ 	def concat₀ = 
//│ 		(fun xs² -> case xs² of {
//│ 			N => (fun ys⁴ -> ys⁴)
//│ 			| C h² t² => (fun ys⁵ -> [C h² ((concat₀ t²) ys⁵)])})
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [concat₀^16]
//│ 	[concat₀^16 · concat₀^32] ---> [concat₀^16] (only one)
//│ [concat₀^5]
//│ 	[concat₀^5 · concat₀^32] ---> [concat₀^5] (only one)
//│ [rev₀^17] (hopeless to continue)
//│ [rev₀^1] (hopeless to continue)
//│ [rev₀^6] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (rev₀₁ 
//│ 	let h⁵ = 1
//│ 	in let t⁵ = 	
//│ 		let h⁶ = 2
//│ 		in let t⁶ = [N]
//│ 		in ((concat₀₁ (rev₀₂ t⁶)) [C h⁶ [N]])
//│ 	in ((concat₀₀ (rev₀₀ t⁵)) [C h⁵ [N]]))
//│ def concat₀₀ = 
//│ 	(fun xs² -> case xs² of {
//│ 		N => (fun ys⁴ -> ys⁴)
//│ 		| C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ ((concat₀₀ t⁴) ys⁵)])})
//│ def concat₀₁ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		N => (fun ys² -> ys²)
//│ 		| C h³ t³ => (fun ys³ -> [C h³ ((concat₀₁ t³) ys³)])})
//│ def rev₀₀ = 
//│ 	(fun ls¹ -> ls¹)
//│ def rev₀₁ = 
//│ 	(fun ls² -> ls²)
//│ def rev₀₂ = 
//│ 	(fun ls³ -> ls³)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h³ ((concat₀₁ t³) ys³)]: 54 --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ ((concat₀₀ t⁴) ys⁵)])}: 71
//│ [N]: 78 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ ((concat₀₁ t³) ys³)])}: 56
//│ [N]: 85 --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ ((concat₀₀ t⁴) ys⁵)])}: 71
//│ [C h⁶ [N]]: 86 --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ ((concat₀₀ t⁴) ys⁵)])}: 71
//│ ------------------
//│ case xs¹ of {N => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ ((concat₀₁ t³) ys³)])}: 56 --->
//│ 	[N]: 78
//│ case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ ((concat₀₀ t⁴) ys⁵)])}: 71 --->
//│ 	[C h³ ((concat₀₁ t³) ys³)]: 54
//│ 	[N]: 85
//│ 	[C h⁶ [N]]: 86
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h³ ((concat₀₁ t³) ys³)]: 54 --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ ((concat₀₀ t⁴) ys⁵)])}: 71
//│ [N]: 78 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ ((concat₀₁ t³) ys³)])}: 56
//│ [N]: 85 --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ ((concat₀₀ t⁴) ys⁵)])}: 71
//│ [C h⁶ [N]]: 86 --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ ((concat₀₀ t⁴) ys⁵)])}: 71
//│ ------------------
//│ case xs¹ of {N => (fun ys² -> ys²) | C h³ t³ => (fun ys³ -> [C h³ ((concat₀₁ t³) ys³)])}: 56 --->
//│ 	[N]: 78
//│ case xs² of {N => (fun ys⁴ -> ys⁴) | C h⁴ t⁴ => (fun ys⁵ -> [C h⁴ ((concat₀₀ t⁴) ys⁵)])}: 71 --->
//│ 	[C h³ ((concat₀₁ t³) ys³)]: 54
//│ 	[N]: 85
//│ 	[C h⁶ [N]]: 86
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (rev₀₁ 
//│ 	let h⁵ = 1
//│ 	in let t⁵ = 	
//│ 		let h⁶ = 2
//│ 		in let t⁶ = (fun ys⁶ -> ys⁶)
//│ 		in ((concat₀₁ (rev₀₂ t⁶)) 
//│ 			let h⁷ = h⁶
//│ 			in let t⁷ = (fun ys⁸ -> ys⁸)
//│ 			in (fun ys⁷ -> [C h⁷ ((concat₀₀ t⁷) ys⁷)]))
//│ 	in ((concat₀₀ (rev₀₀ t⁵)) [C h⁵ [N]]))
//│ def concat₀₀ = 
//│ 	(fun xs³ -> xs³)
//│ def concat₀₁ = 
//│ 	(fun xs⁴ -> xs⁴)
//│ def rev₀₀ = 
//│ 	(fun ls⁵ -> ls⁵)
//│ def rev₀₁ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ def rev₀₂ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [concat₀₀^15] (hopeless to continue)
//│ [concat₀₀^27] (hopeless to continue)
//│ [concat₀₁^6] (hopeless to continue)
//│ [rev₀₀^28] (hopeless to continue)
//│ [rev₀₁^1] (hopeless to continue)
//│ [rev₀₂^7] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (rev₀₁₀ 
//│ 	let h³ = 1
//│ 	in let t³ = 	
//│ 		let h⁴ = 2
//│ 		in let t⁴ = (fun ys³ -> ys³)
//│ 		in ((concat₀₁₀ (rev₀₂₀ t⁴)) 
//│ 			let h⁵ = h⁴
//│ 			in let t⁵ = (fun ys⁴ -> ys⁴)
//│ 			in (fun ys⁵ -> [C h⁵ ((concat₀₀₀ t⁵) ys⁵)]))
//│ 	in ((concat₀₀₁ (rev₀₀₀ t³)) [C h³ [N]]))
//│ def concat₀₀₀ = 
//│ 	(fun xs⁴ -> xs⁴)
//│ def concat₀₀₁ = 
//│ 	(fun xs³ -> xs³)
//│ def concat₀₁₀ = 
//│ 	(fun xs² -> xs²)
//│ def rev₀₀₀ = 
//│ 	(fun ls³ -> ls³)
//│ def rev₀₁₀ = 
//│ 	(fun ls⁵ -> ls⁵)
//│ def rev₀₂₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (rev₀₁₀ 
//│ 	let h³ = 1
//│ 	in let t³ = 	
//│ 		let h⁴ = 2
//│ 		in let t⁴ = (fun ys⁶ -> ys⁶)
//│ 		in ((concat₀₁₀ (rev₀₂₀ t⁴)) 
//│ 			let h⁵ = h⁴
//│ 			in let t⁵ = (fun ys⁷ -> ys⁷)
//│ 			in (fun ys⁸ -> [C h⁵ ((concat₀₀₀ t⁵) ys⁸)]))
//│ 	in ((concat₀₀₁ (rev₀₀₀ t³)) [C h³ [N]]))
//│ def concat₀₀₀ = 
//│ 	(fun xs⁵ -> xs⁵)
//│ def concat₀₀₁ = 
//│ 	(fun xs⁶ -> xs⁶)
//│ def concat₀₁₀ = 
//│ 	(fun xs⁷ -> xs⁷)
//│ def rev₀₀₀ = 
//│ 	(fun ls⁸ -> ls⁸)
//│ def rev₀₁₀ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ def rev₀₂₀ = 
//│ 	(fun ls⁷ -> ls⁷)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 2 [C 1 [N]]]
//│ <<<<<<< evaluate <<<<<<<


// CORRECT: but will be WRONG: if strategy-filtering is strict, since y is a destination of [C 1 N]
fun f(x) = if A(x) is
  A(y) then if x is
    C(h, t) then t
f(C(1, N))
//│ |#fun| |f|(|x|)| |#=| |#if| |A|(|x|)| |is|→|A|(|y|)| |#then| |#if| |x| |is|→|C|(|h|,| |t|)| |#then| |t|←|←|↵|f|(|C|(|1|,| |N|)|)|
//│ Parsed: {fun f = x, => if A (x,) is ‹(A (y,)) then if x is ‹(C (h, t,)) then t››; f (C (1, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^8 [C 1 [N]])
//│ def f = (fun x⁰ -> case [A x⁰] of {
//│ 	A y⁰ => case x⁰ of {
//│ 		C h⁰ t⁰ => t⁰}})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^8] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ [C 1 [N]])
//│ def f₀ = 
//│ 	(fun x¹ -> case [A x¹] of {
//│ 		A y¹ => case x¹ of {
//│ 			C h¹ t¹ => t¹}})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A x¹]: 14 --->
//│ 	case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18
//│ [C 1 [N]]: 23 --->
//│ 	'y¹
//│ 	case x¹ of {C h¹ t¹ => t¹}: 17
//│ ------------------
//│ case x¹ of {C h¹ t¹ => t¹}: 17 --->
//│ 	[C 1 [N]]: 23
//│ case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18 --->
//│ 	[A x¹]: 14
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A x¹]: 14 --->
//│ 	case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18
//│ ------------------
//│ case [A x¹] of {A y¹ => case x¹ of {C h¹ t¹ => t¹}}: 18 --->
//│ 	[A x¹]: 14
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ [C 1 [N]])
//│ def f₀ = 
//│ 	(fun x² -> (
//│ 		let y² = x²
//│ 		in (fun x³ -> case x² of {
//│ 			C h¹ t¹ => t¹}) x²))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀₀ [C 1 [N]])
//│ def f₀₀ = 
//│ 	(fun x² -> (
//│ 		let y¹ = x²
//│ 		in (fun x³ -> case x³ of {
//│ 			C h¹ t¹ => t¹}) x²))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 27 --->
//│ 	'y¹
//│ 	case x³ of {C h¹ t¹ => t¹}: 18
//│ ------------------
//│ case x³ of {C h¹ t¹ => t¹}: 18 --->
//│ 	[C 1 [N]]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀₀ [C 1 [N]])
//│ def f₀₀ = 
//│ 	(fun x⁴ -> (
//│ 		let y¹ = x⁴
//│ 		in (fun x⁵ -> case x⁵ of {
//│ 			C h¹ t¹ => t¹}) x⁴))
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: after using `last(C(hh, tt))` instead of `last(t)` and pushing in of parameters
_LUMBERHACK_EVAL
fun last(ls) = if ls is
  C(h, t) then
    (
      if t is
        N then h => Some(h)
        C(hh, tt) then h => last(C(hh, tt))
    )(h)
  N then None
last(C(1, C(2, C(3, N))))
//│ |_LUMBERHACK_EVAL|↵|#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then|→|(|→|#if| |t| |is|→|N| |#then| |h| |=>| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |h| |=>| |last|(|C|(|hh|,| |tt|)|)|←|←|↵|)|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun last = ls, => if ls is ‹(C (h, t,)) then {'(' if t is ‹(N) then h, => Some (h,); (C (hh, tt,)) then h, => last (C (hh, tt,),)›, ')' (h,)}; (N) then None›; last (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (last^18 [C 1 [C 2 [C 3 [N]]]])
//│ def last = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => (case t⁰ of {
//│ 		N => (fun h¹ -> [Some h¹])
//│ 		| C hh⁰ tt⁰ => (fun h² -> (last^6 [C hh⁰ tt⁰]))} h⁰)
//│ 	| N => [None]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^18]
//│ 	[last^18 · last^6] ---> [last^18] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (last₀ [C 1 [C 2 [C 3 [N]]]])
//│ def last₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h³ t¹ => (case t¹ of {
//│ 			N => (fun h⁴ -> [Some h⁴])
//│ 			| C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))} h³)
//│ 		| N => [None]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 35 --->
//│ 	case ls¹ of {C h³ t¹ => (case t¹ of {N => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))} h³) | N => [None]}: 42
//│ [N]: 48 --->
//│ 	case t¹ of {N => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))}: 38
//│ [C 3 [N]]: 49 --->
//│ 	case t¹ of {N => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))}: 38
//│ [C 2 [C 3 [N]]]: 50 --->
//│ 	case t¹ of {N => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))}: 38
//│ [C 1 [C 2 [C 3 [N]]]]: 51 --->
//│ 	case ls¹ of {C h³ t¹ => (case t¹ of {N => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))} h³) | N => [None]}: 42
//│ ------------------
//│ case t¹ of {N => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))}: 38 --->
//│ 	[N]: 48
//│ 	[C 3 [N]]: 49
//│ 	[C 2 [C 3 [N]]]: 50
//│ case ls¹ of {C h³ t¹ => (case t¹ of {N => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))} h³) | N => [None]}: 42 --->
//│ 	[C hh¹ tt¹]: 35
//│ 	[C 1 [C 2 [C 3 [N]]]]: 51
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C hh¹ tt¹]: 35 --->
//│ 	case ls¹ of {C h³ t¹ => (case t¹ of {N => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))} h³) | N => [None]}: 42
//│ [N]: 48 --->
//│ 	case t¹ of {N => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))}: 38
//│ [C 3 [N]]: 49 --->
//│ 	case t¹ of {N => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))}: 38
//│ [C 2 [C 3 [N]]]: 50 --->
//│ 	case t¹ of {N => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))}: 38
//│ [C 1 [C 2 [C 3 [N]]]]: 51 --->
//│ 	case ls¹ of {C h³ t¹ => (case t¹ of {N => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))} h³) | N => [None]}: 42
//│ ------------------
//│ case t¹ of {N => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))}: 38 --->
//│ 	[N]: 48
//│ 	[C 3 [N]]: 49
//│ 	[C 2 [C 3 [N]]]: 50
//│ case ls¹ of {C h³ t¹ => (case t¹ of {N => (fun h⁴ -> [Some h⁴]) | C hh¹ tt¹ => (fun h⁵ -> (last₀ [C hh¹ tt¹]))} h³) | N => [None]}: 42 --->
//│ 	[C hh¹ tt¹]: 35
//│ 	[C 1 [C 2 [C 3 [N]]]]: 51
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (last₀ 
//│ 	let h⁶ = 1
//│ 	in let t² = 	
//│ 		let hh² = 2
//│ 		in let tt² = 	
//│ 			let hh³ = 3
//│ 			in let tt³ = (fun h¹¹ -> [Some h¹¹])
//│ 			in (fun h⁹ -> (last₀ 
//│ 				let h¹⁰ = hh³
//│ 				in let t⁴ = tt³
//│ 				in (t⁴ h¹⁰)))
//│ 		in (fun h⁷ -> (last₀ 
//│ 			let h⁸ = hh²
//│ 			in let t³ = tt²
//│ 			in (t³ h⁸)))
//│ 	in (t² h⁶))
//│ def last₀ = 
//│ 	(fun ls² -> ls²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 3]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last₀^1] (hopeless to continue)
//│ [last₀^20] (hopeless to continue)
//│ [last₀^8] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (last₀₀ 
//│ 	let h⁶ = 1
//│ 	in let t³ = 	
//│ 		let hh² = 2
//│ 		in let tt² = 	
//│ 			let hh³ = 3
//│ 			in let tt³ = (fun h⁷ -> [Some h⁷])
//│ 			in (fun h⁸ -> (last₀₂ 
//│ 				let h⁹ = hh³
//│ 				in let t⁴ = tt³
//│ 				in (t⁴ h⁹)))
//│ 		in (fun h¹⁰ -> (last₀₁ 
//│ 			let h¹¹ = hh²
//│ 			in let t⁵ = tt²
//│ 			in (t⁵ h¹¹)))
//│ 	in (t³ h⁶))
//│ def last₀₀ = 
//│ 	(fun ls¹ -> ls¹)
//│ def last₀₁ = 
//│ 	(fun ls² -> ls²)
//│ def last₀₂ = 
//│ 	(fun ls³ -> ls³)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (last₀₀ 
//│ 	let h⁶ = 1
//│ 	in let t³ = 	
//│ 		let hh² = 2
//│ 		in let tt² = 	
//│ 			let hh³ = 3
//│ 			in let tt³ = (fun h¹² -> [Some h¹²])
//│ 			in (fun h¹³ -> (last₀₂ 
//│ 				let h⁹ = hh³
//│ 				in let t⁴ = tt³
//│ 				in (t⁴ h¹³)))
//│ 		in (fun h¹⁴ -> (last₀₁ 
//│ 			let h¹¹ = hh²
//│ 			in let t⁵ = tt²
//│ 			in (t⁵ h¹⁴)))
//│ 	in (t³ h⁶))
//│ def last₀₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ def last₀₁ = 
//│ 	(fun ls⁵ -> ls⁵)
//│ def last₀₂ = 
//│ 	(fun ls⁶ -> ls⁶)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some 1]
//│ <<<<<<< evaluate <<<<<<<


_LUMBERHACK_EVAL
fun f(x) = if primitive(x) then A(x) else B(x + 1)
fun g(scrut, y) = if scrut is
  A(n) then y + n + 1
  B(m) then y + m
g(f(1), 2)
//│ |_LUMBERHACK_EVAL|↵|#fun| |f|(|x|)| |#=| |#if| |primitive|(|x|)| |#then| |A|(|x|)| |#else| |B|(|x| |+| |1|)|↵|#fun| |g|(|scrut|,| |y|)| |#=| |#if| |scrut| |is|→|A|(|n|)| |#then| |y| |+| |n| |+| |1|↵|B|(|m|)| |#then| |y| |+| |m|←|↵|g|(|f|(|1|)|,| |2|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun f = x, => if (primitive (x,)) then A (x,) else B (+ (x,) (1,),); fun g = scrut, y, => if scrut is ‹(A (n,)) then + (+ (y,) (n,),) (1,); (B (m,)) then + (y,) (m,)›; g (f (1,), 2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((g^32 (f^33 1)) 2)
//│ def f = (fun x⁰ -> if (primitive⁰ x⁰) then [A x⁰] else [B (x⁰ + 1)])
//│ def g = (fun scrut⁰ -> (fun y⁰ -> case scrut⁰ of {
//│ 	A n⁰ => ((y⁰ + n⁰) + 1)
//│ 	| B m⁰ => (y⁰ + m⁰)}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^33] (hopeless to continue)
//│ [g^32] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((g₀ (f₀ 1)) 2)
//│ def f₀ = 
//│ 	(fun x¹ -> if (primitive⁰ x¹) then [A x¹] else [B (x¹ + 1)])
//│ def g₀ = 
//│ 	(fun scrut¹ -> (fun y¹ -> case scrut¹ of {
//│ 		A n¹ => ((y¹ + n¹) + 1)
//│ 		| B m¹ => (y¹ + m¹)}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A x¹]: 61 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ [B (x¹ + 1)]: 67 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ ------------------
//│ case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54 --->
//│ 	[A x¹]: 61
//│ 	[B (x¹ + 1)]: 67
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A x¹]: 61 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ [B (x¹ + 1)]: 67 --->
//│ 	case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54
//│ ------------------
//│ case scrut¹ of {A n¹ => ((y¹ + n¹) + 1) | B m¹ => (y¹ + m¹)}: 54 --->
//│ 	[A x¹]: 61
//│ 	[B (x¹ + 1)]: 67
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((g₀ (f₀ 1)) 2)
//│ def f₀ = 
//│ 	(fun x² -> if (primitive⁰ x²) then 
//│ 		let n² = x²
//│ 		in (fun y³ -> ((y³ + n²) + 1)) else 
//│ 		let m² = (x² + 1)
//│ 		in (fun y⁴ -> (y⁴ + m²)))
//│ def g₀ = 
//│ 	(fun scrut² -> (fun y² -> (scrut² y²)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ (if (primitive⁰ 1) then 
//│ 	let n² = 1
//│ 	in (fun y³ -> ((y³ + n²) + 1)) else 
//│ 	let m² = (1 + 1)
//│ 	in (fun y⁴ -> (y⁴ + m²)) 2)
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f₀^2] (hopeless to continue)
//│ [g₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((g₀₀ (f₀₀ 1)) 2)
//│ def f₀₀ = 
//│ 	(fun x¹ -> if (primitive⁰ x¹) then 
//│ 		let n¹ = x¹
//│ 		in (fun y⁴ -> ((y⁴ + n¹) + 1)) else 
//│ 		let m¹ = (x¹ + 1)
//│ 		in (fun y⁵ -> (y⁵ + m¹)))
//│ def g₀₀ = 
//│ 	(fun scrut¹ -> (fun y³ -> (scrut¹ y³)))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((g₀₀ (f₀₀ 1)) 2)
//│ def f₀₀ = 
//│ 	(fun x² -> if (primitive⁰ x²) then 
//│ 		let n¹ = x²
//│ 		in (fun y⁷ -> ((y⁷ + n¹) + 1)) else 
//│ 		let m¹ = (x² + 1)
//│ 		in (fun y⁸ -> (y⁸ + m¹)))
//│ def g₀₀ = 
//│ 	(fun scrut² -> (fun y⁶ -> (scrut² y⁶)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ (if (primitive⁰ 1) then 
//│ 	let n¹ = 1
//│ 	in (fun y⁷ -> ((y⁷ + n¹) + 1)) else 
//│ 	let m¹ = (1 + 1)
//│ 	in (fun y⁸ -> (y⁸ + m¹)) 2)
//│ <<<<<<< evaluate <<<<<<<
