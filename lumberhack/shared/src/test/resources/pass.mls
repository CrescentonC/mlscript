:NewParser
:ParseOnly

let rec p = C(p)
fun c(x) = if x is
    C(a) then c(a)
c(p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c:7^9 p:6^10)
//│ def c:7 = (fun x:8 -> case x:8^3 of {
//│ 	C a:9 => (c:7^4 a:9^5)})
//│ def p:6 = [C p:6^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(0'p_6^1) <: 2'x
//│ 	[-p:6^1 · -p:6^10 · +c:7^9 · +c:7^4]  --->  [-p:6^10 · +c:7^9]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c:7^9 · c:7^4] --> [c:7^9]
//│ [p:6^10 · p:6^1] --> [p:6^10]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c:7^9]
//│ 	[c:7^9 · c:7^4] ---> [c:7^9] (only one)
//│ [p:6^10]
//│ 	[p:6^10 · p:6^1] ---> [p:6^10] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([c:7^9]:11^20 [p:6^10]:10^21)
//│ def [c:7^9]:11 = (fun x:18 -> case x:18^12 of {
//│ 	C a:19 => ([c:7^9]:11^13 a:19^14)})
//│ def [p:6^10]:10 = [C [p:6^10]:10^18]
//│ def c:7 = (fun x:8 -> case x:8^6 of {
//│ 	C a:9 => (c:7^7 a:9^8)})
//│ def p:6 = [C p:6^4]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 19: [C 18: [p:6^10]:10^18]
//│ [C [p:6^10]:10^18] --->
//│ 	case x:18^12 of {C a:19 => ([c:7^9]:11^13 a:19^14)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([c:7^9]:11^23 [p:6^10]:10^24)
//│ def [c:7^9]:11 = (fun x:18 -> x:18^34)
//│ def [p:6^10]:10 = let a:19 = [p:6^10]:10^39
//│ in ([c:7^9]:11^36 a:19^37)
//│ def c:7 = (fun x:8 -> case x:8^28 of {
//│ 	C a:9 => (c:7^29 a:9^30)})
//│ def p:6 = [C p:6^26]
//│ <<<<<<< after fusion <<<<<<<



let p = C(1, C(2, N))
fun e(z) = if z is
    C(aaa, bbb) then bbb
    N then 7
fun d(y) = if y is
    C(aa, bb) then e(bb)
    N then 5
fun c(x) = if x is
    C(a, b) then d(b)
    N then 3
c(p)
//│ |#let| |p| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#fun| |e|(|z|)| |#=| |#if| |z| |is|→|C|(|aaa|,| |bbb|)| |#then| |bbb|↵|N| |#then| |7|←|↵|#fun| |d|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|,| |bb|)| |#then| |e|(|bb|)|↵|N| |#then| |5|←|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|,| |b|)| |#then| |d|(|b|)|↵|N| |#then| |3|←|↵|c|(|p|)|
//│ Parsed: {let p = C (1, C (2, N,),); fun e = z, => if z is ‹(C (aaa, bbb,)) then bbb; (N) then 7›; fun d = y, => if y is ‹(C (aa, bb,)) then e (bb,); (N) then 5›; fun c = x, => if x is ‹(C (a, b,)) then d (b,); (N) then 3›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c:9^25 p:6^26)
//│ def c:9 = (fun x:16 -> case x:16^18 of {
//│ 	C a:17 b:18 => (d:8^19 b:18^20)
//│ 	| N => 3})
//│ def d:8 = (fun y:13 -> case y:13^11 of {
//│ 	C aa:14 bb:15 => (e:7^12 bb:15^13)
//│ 	| N => 5})
//│ def e:7 = (fun z:10 -> case z:10^6 of {
//│ 	C aaa:11 bbb:12 => bbb:12^7
//│ 	| N => 7})
//│ def p:6 = [C 1 [C 2 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c:9^25] ---> [c:9^25] (hopeless to continue)
//│ [p:6^26] ---> [p:6^26] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c:9^28 p:6^29)
//│ def c:9 = (fun x:16 -> case x:16^21 of {
//│ 	C a:17 b:18 => (d:8^22 b:18^23)
//│ 	| N => 3})
//│ def d:8 = (fun y:13 -> case y:13^14 of {
//│ 	C aa:14 bb:15 => (e:7^15 bb:15^16)
//│ 	| N => 5})
//│ def e:7 = (fun z:10 -> case z:10^9 of {
//│ 	C aaa:11 bbb:12 => bbb:12^10
//│ 	| N => 7})
//│ def p:6 = [C 1 [C 2 [N]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 6: [N]
//│ [N] --->
//│ 	case z:10^9 of {C aaa:11 bbb:12 => bbb:12^10 | N => 7}
//│ 7: [C 5: 2 6: [N]]
//│ [C 2 [N]] --->
//│ 	case y:13^14 of {C aa:14 bb:15 => (e:7^15 bb:15^16) | N => 5}
//│ 8: [C 4: 1 7: [C 5: 2 6: [N]]]
//│ [C 1 [C 2 [N]]] --->
//│ 	case x:16^21 of {C a:17 b:18 => (d:8^22 b:18^23) | N => 3}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c:9^31 p:6^32)
//│ def c:9 = (fun x:16 -> x:16^51)
//│ def d:8 = (fun y:13 -> y:13^49)
//│ def e:7 = (fun z:10 -> z:10^47)
//│ def p:6 = let a:17 = 1
//│ in let b:18 = 
//│ 	let aa:14 = 2
//│ 	in let bb:15 = 7
//│ 	in (e:7^37 bb:15^38)
//│ in (d:8^34 b:18^35)
//│ <<<<<<< after fusion <<<<<<<


let rec p = C(C(p))
fun c(x) = if x is
    C(a) then if a is
        C(b) then if b is
            C(y) then c(y)
c(p)
//│ |#let| |#rec| |p| |#=| |C|(|C|(|p|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |#if| |b| |is|→|C|(|y|)| |#then| |c|(|y|)|←|←|←|↵|c|(|p|)|
//│ Parsed: {let rec p = C (C (p,),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then if b is ‹(C (y,)) then c (y,)›››; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c:7^14 p:6^15)
//│ def c:7 = (fun x:8 -> case x:8^4 of {
//│ 	C a:9 => case a:9^5 of {
//│ 		C b:10 => case b:10^6 of {
//│ 			C y:11 => (c:7^7 y:11^8)}}})
//│ def p:6 = [C [C p:6^1]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(C(0'p_6^1)) <: 2'x
//│ 	[-p:6^1 · -p:6^1 · -p:6^1 · -p:6^15 · +c:7^14 · +c:7^7 · +c:7^7]  --->  [-p:6^15 · +c:7^14]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c:7^14 · c:7^7 · c:7^7] --> [c:7^14]
//│ [p:6^15 · p:6^1 · p:6^1 · p:6^1] --> [p:6^15]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c:7^14]
//│ 	[c:7^14 · c:7^7]
//│ 		[c:7^14 · c:7^7 · c:7^7] ---> [c:7^14] (only one)
//│ [p:6^15]
//│ 	[p:6^15 · p:6^1]
//│ 		[p:6^15 · p:6^1 · p:6^1]
//│ 			[p:6^15 · p:6^1 · p:6^1 · p:6^1] ---> [p:6^15] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([c:7^14]:12^46 [p:6^15]:14^47)
//│ def [c:7^14 · c:7^7]:13 = (fun x:27 -> case x:27^30 of {
//│ 	C a:28 => case a:28^31 of {
//│ 		C b:29 => case b:29^32 of {
//│ 			C y:30 => ([c:7^14]:12^33 y:30^34)}}})
//│ def [c:7^14]:12 = (fun x:23 -> case x:23^20 of {
//│ 	C a:24 => case a:24^21 of {
//│ 		C b:25 => case b:25^22 of {
//│ 			C y:26 => ([c:7^14 · c:7^7]:13^23 y:26^24)}}})
//│ def [p:6^15 · p:6^1 · p:6^1]:16 = [C [C [p:6^15]:14^43]]
//│ def [p:6^15 · p:6^1]:15 = [C [C [p:6^15 · p:6^1 · p:6^1]:16^17]]
//│ def [p:6^15]:14 = [C [C [p:6^15 · p:6^1]:15^40]]
//│ def c:7 = (fun x:8 -> case x:8^7 of {
//│ 	C a:9 => case a:9^8 of {
//│ 		C b:10 => case b:10^9 of {
//│ 			C y:11 => (c:7^10 y:11^11)}}})
//│ def p:6 = [C [C p:6^4]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 18: [C 17: [p:6^15 · p:6^1 · p:6^1]:16^17]
//│ [C [p:6^15 · p:6^1 · p:6^1]:16^17] --->
//│ 	case x:27^30 of {C a:28 => case a:28^31 of {C b:29 => case b:29^32 of {C y:30 => ([c:7^14]:12^33 y:30^34)}}}
//│ 19: [C 18: [C 17: [p:6^15 · p:6^1 · p:6^1]:16^17]]
//│ [C [C [p:6^15 · p:6^1 · p:6^1]:16^17]] --->
//│ 	case b:25^22 of {C y:26 => ([c:7^14 · c:7^7]:13^23 y:26^24)}
//│ 41: [C 40: [p:6^15 · p:6^1]:15^40]
//│ [C [p:6^15 · p:6^1]:15^40] --->
//│ 	case a:24^21 of {C b:25 => case b:25^22 of {C y:26 => ([c:7^14 · c:7^7]:13^23 y:26^24)}}
//│ 42: [C 41: [C 40: [p:6^15 · p:6^1]:15^40]]
//│ [C [C [p:6^15 · p:6^1]:15^40]] --->
//│ 	case x:23^20 of {C a:24 => case a:24^21 of {C b:25 => case b:25^22 of {C y:26 => ([c:7^14 · c:7^7]:13^23 y:26^24)}}}
//│ 44: [C 43: [p:6^15]:14^43]
//│ [C [p:6^15]:14^43] --->
//│ 	case b:29^32 of {C y:30 => ([c:7^14]:12^33 y:30^34)}
//│ 45: [C 44: [C 43: [p:6^15]:14^43]]
//│ [C [C [p:6^15]:14^43]] --->
//│ 	case a:28^31 of {C b:29 => case b:29^32 of {C y:30 => ([c:7^14]:12^33 y:30^34)}}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([c:7^14]:12^49 [p:6^15]:14^50)
//│ def [c:7^14 · c:7^7]:13 = (fun x:27 -> x:27^64)
//│ def [c:7^14]:12 = (fun x:23 -> x:23^66)
//│ def [p:6^15 · p:6^1 · p:6^1]:16 = let b:29 = 
//│ 	let y:30 = [p:6^15]:14^72
//│ 	in ([c:7^14]:12^69 y:30^70)
//│ in b:29^68
//│ def [p:6^15 · p:6^1]:15 = let y:26 = 
//│ 	let a:28 = [p:6^15 · p:6^1 · p:6^1]:16^56
//│ 	in a:28^55
//│ in ([c:7^14 · c:7^7]:13^52 y:26^53)
//│ def [p:6^15]:14 = let a:24 = 
//│ 	let b:25 = [p:6^15 · p:6^1]:15^61
//│ 	in b:25^60
//│ in a:24^59
//│ def c:7 = (fun x:8 -> case x:8^78 of {
//│ 	C a:9 => case a:9^79 of {
//│ 		C b:10 => case b:10^80 of {
//│ 			C y:11 => (c:7^81 y:11^82)}}})
//│ def p:6 = [C [C p:6^75]]
//│ <<<<<<< after fusion <<<<<<<




let rec p = C(C(p))
fun c(x) = if x is
    C(a) then c(a)
fun id2(yy) = yy
fun id(y) = id2(y)
c(id(p))
//│ |#let| |#rec| |p| |#=| |C|(|C|(|p|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id2|(|yy|)| |#=| |yy|↵|#fun| |id|(|y|)| |#=| |id2|(|y|)|↵|c|(|id|(|p|)|)|
//│ Parsed: {let rec p = C (C (p,),); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun id2 = yy, => yy; fun id = y, => id2 (y,); c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c:7^16 (id:9^17 p:6^18))
//│ def c:7 = (fun x:10 -> case x:10^4 of {
//│ 	C a:11 => (c:7^5 a:11^6)})
//│ def id:9 = (fun y:13 -> (id2:8^12 y:13^13))
//│ def id2:8 = (fun yy:12 -> yy:12^10)
//│ def p:6 = [C [C p:6^1]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(C(0'p_6^1)) <: 4'x
//│ 	[-p:6^1 · -p:6^18 · +id:9^17 · +id2:8^12 · -id2:8^12 · -id:9^17 · +c:7^16 · +c:7^5 · +c:7^5]  --->  [-p:6^18 · +id:9^17 · +id2:8^12 · -id2:8^12 · -id:9^17 · +c:7^16]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c:7^16 · c:7^5 · c:7^5] --> [c:7^16]
//│ [p:6^18 · p:6^1] --> [p:6^18]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c:7^16]
//│ 	[c:7^16 · c:7^5]
//│ 		[c:7^16 · c:7^5 · c:7^5] ---> [c:7^16] (only one)
//│ [id:9^17] ---> [id:9^17] (hopeless to continue)
//│ [p:6^18]
//│ 	[p:6^18 · p:6^1] ---> [p:6^18] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([c:7^16]:14^36 (id:9^37 [p:6^18]:16^38))
//│ def [c:7^16 · c:7^5]:15 = (fun x:25 -> case x:25^30 of {
//│ 	C a:26 => ([c:7^16]:14^31 a:26^32)})
//│ def [c:7^16]:14 = (fun x:23 -> case x:23^21 of {
//│ 	C a:24 => ([c:7^16 · c:7^5]:15^22 a:24^23)})
//│ def [p:6^18]:16 = [C [C [p:6^18]:16^27]]
//│ def c:7 = (fun x:10 -> case x:10^9 of {
//│ 	C a:11 => (c:7^10 a:11^11)})
//│ def id:9 = (fun y:13 -> (id2:8^17 y:13^18))
//│ def id2:8 = (fun yy:12 -> yy:12^15)
//│ def p:6 = [C [C p:6^6]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 28: [C 27: [p:6^18]:16^27]
//│ [C [p:6^18]:16^27] --->
//│ 	case x:25^30 of {C a:26 => ([c:7^16]:14^31 a:26^32)}
//│ 29: [C 28: [C 27: [p:6^18]:16^27]]
//│ [C [C [p:6^18]:16^27]] --->
//│ 	case x:23^21 of {C a:24 => ([c:7^16 · c:7^5]:15^22 a:24^23)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([c:7^16]:14^41 (id:9^42 [p:6^18]:16^43))
//│ def [c:7^16 · c:7^5]:15 = (fun x:25 -> x:25^46)
//│ def [c:7^16]:14 = (fun x:23 -> x:23^48)
//│ def [p:6^18]:16 = let a:24 = 
//│ 	let a:26 = [p:6^18]:16^62
//│ 	in ([c:7^16]:14^59 a:26^60)
//│ in ([c:7^16 · c:7^5]:15^56 a:24^57)
//│ def c:7 = (fun x:10 -> case x:10^68 of {
//│ 	C a:11 => (c:7^69 a:11^70)})
//│ def id:9 = (fun y:13 -> (id2:8^52 y:13^53))
//│ def id2:8 = (fun yy:12 -> yy:12^50)
//│ def p:6 = [C [C p:6^65]]
//│ <<<<<<< after fusion <<<<<<<

fun sum(ls) = if ls is
    C(h, t) then S(N, sum(t))
fun mapa(lsa) = if lsa is
    C(ha, ta) then C(primitive(ha), mapa(ta))
fun mapb(lsb) = if lsb is
    C(hb, tb) then C(primitive(hb), mapb(tb))
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),)›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),)›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),)›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (sum:6^29 (mapa:7^30 (mapb:8^31 primitive:3^32)))
//│ def mapa:7 = (fun lsa:12 -> case lsa:12^9 of {
//│ 	C ha:13 ta:14 => [C (primitive:3^10 ha:13^11) (mapa:7^13 ta:14^14)]})
//│ def mapb:8 = (fun lsb:15 -> case lsb:15^19 of {
//│ 	C hb:16 tb:17 => [C (primitive:3^20 hb:16^21) (mapb:8^23 tb:17^24)]})
//│ def sum:6 = (fun ls:9 -> case ls:9^1 of {
//│ 	C h:10 t:11 => [S [N] (sum:6^3 t:11^4)]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(11'12_callres, 12'15_callres) <: 3'ls
//│ 	[-mapa:7^13 · -mapa:7^13 · -mapa:7^30 · +sum:6^29 · +sum:6^3 · +sum:6^3]  --->  [-mapa:7^13 · -mapa:7^30 · +sum:6^29 · +sum:6^3]
//│ C(17'22_callres, 18'25_callres) <: 8'lsa
//│ 	[-mapb:8^23 · -mapb:8^23 · -mapb:8^31 · +mapa:7^30 · +mapa:7^13 · +mapa:7^13]  --->  [-mapb:8^23 · -mapb:8^31 · +mapa:7^30 · +mapa:7^13]
//│ NoProd <: 14'lsb
//│ 	[+mapb:8^31 · +mapb:8^23 · +mapb:8^23]  --->  [+mapb:8^31 · +mapb:8^23]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [mapb:8^31 · mapb:8^23 · mapb:8^23] --> [mapb:8^31 · mapb:8^23]
//│ [sum:6^29 · sum:6^3 · sum:6^3] --> [sum:6^29 · sum:6^3]
//│ [mapa:7^30 · mapa:7^13 · mapa:7^13] --> [mapa:7^30 · mapa:7^13]
//│ [] --> []
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa:7^30]
//│ 	[mapa:7^30 · mapa:7^13]
//│ 		[mapa:7^30 · mapa:7^13 · mapa:7^13] ---> [mapa:7^30 · mapa:7^13] (only one)
//│ [mapb:8^31]
//│ 	[mapb:8^31 · mapb:8^23]
//│ 		[mapb:8^31 · mapb:8^23 · mapb:8^23] ---> [mapb:8^31 · mapb:8^23] (only one)
//│ [sum:6^29]
//│ 	[sum:6^29 · sum:6^3]
//│ 		[sum:6^29 · sum:6^3 · sum:6^3] ---> [sum:6^29 · sum:6^3] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([sum:6^29]:22^92 ([mapa:7^30]:18^93 ([mapb:8^31]:20^94 primitive:27^95)))
//│ def [mapa:7^30 · mapa:7^13]:19 = (fun lsa:42 -> case lsa:42^72 of {
//│ 	C ha:43 ta:44 => [C (primitive:27^73 ha:43^74) ([mapa:7^30 · mapa:7^13]:19^76 ta:44^77)]})
//│ def [mapa:7^30]:18 = (fun lsa:39 -> case lsa:39^62 of {
//│ 	C ha:40 ta:41 => [C (primitive:27^63 ha:40^64) ([mapa:7^30 · mapa:7^13]:19^66 ta:41^67)]})
//│ def [mapb:8^31 · mapb:8^23]:21 = (fun lsb:36 -> case lsb:36^52 of {
//│ 	C hb:37 tb:38 => [C (primitive:27^53 hb:37^54) ([mapb:8^31 · mapb:8^23]:21^56 tb:38^57)]})
//│ def [mapb:8^31]:20 = (fun lsb:45 -> case lsb:45^82 of {
//│ 	C hb:46 tb:47 => [C (primitive:27^83 hb:46^84) ([mapb:8^31 · mapb:8^23]:21^86 tb:47^87)]})
//│ def [sum:6^29 · sum:6^3]:23 = (fun ls:33 -> case ls:33^44 of {
//│ 	C h:34 t:35 => [S [N] ([sum:6^29 · sum:6^3]:23^46 t:35^47)]})
//│ def [sum:6^29]:22 = (fun ls:30 -> case ls:30^36 of {
//│ 	C h:31 t:32 => [S [N] ([sum:6^29 · sum:6^3]:23^38 t:32^39)]})
//│ def mapa:7 = (fun lsa:12 -> case lsa:12^16 of {
//│ 	C ha:13 ta:14 => [C (primitive:3^17 ha:13^18) (mapa:7^20 ta:14^21)]})
//│ def mapb:8 = (fun lsb:15 -> case lsb:15^26 of {
//│ 	C hb:16 tb:17 => [C (primitive:3^27 hb:16^28) (mapb:8^30 tb:17^31)]})
//│ def sum:6 = (fun ls:9 -> case ls:9^8 of {
//│ 	C h:10 t:11 => [S [N] (sum:6^10 t:11^11)]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 59: [C 55: (53: primitive:27^53 54: hb:37^54) 58: (56: [mapb:8^31 · mapb:8^23]:21^56 57: tb:38^57)]
//│ [C (primitive:27^53 hb:37^54) ([mapb:8^31 · mapb:8^23]:21^56 tb:38^57)] --->
//│ 	case lsa:42^72 of {C ha:43 ta:44 => [C (primitive:27^73 ha:43^74) ([mapa:7^30 · mapa:7^13]:19^76 ta:44^77)]}
//│ 69: [C 65: (63: primitive:27^63 64: ha:40^64) 68: (66: [mapa:7^30 · mapa:7^13]:19^66 67: ta:41^67)]
//│ [C (primitive:27^63 ha:40^64) ([mapa:7^30 · mapa:7^13]:19^66 ta:41^67)] --->
//│ 	case ls:30^36 of {C h:31 t:32 => [S [N] ([sum:6^29 · sum:6^3]:23^38 t:32^39)]}
//│ 79: [C 75: (73: primitive:27^73 74: ha:43^74) 78: (76: [mapa:7^30 · mapa:7^13]:19^76 77: ta:44^77)]
//│ [C (primitive:27^73 ha:43^74) ([mapa:7^30 · mapa:7^13]:19^76 ta:44^77)] --->
//│ 	case ls:33^44 of {C h:34 t:35 => [S [N] ([sum:6^29 · sum:6^3]:23^46 t:35^47)]}
//│ 89: [C 85: (83: primitive:27^83 84: hb:46^84) 88: (86: [mapb:8^31 · mapb:8^23]:21^86 87: tb:47^87)]
//│ [C (primitive:27^83 hb:46^84) ([mapb:8^31 · mapb:8^23]:21^86 tb:47^87)] --->
//│ 	case lsa:39^62 of {C ha:40 ta:41 => [C (primitive:27^63 ha:40^64) ([mapa:7^30 · mapa:7^13]:19^66 ta:41^67)]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([sum:6^29]:22^99 ([mapa:7^30]:18^100 ([mapb:8^31]:20^101 primitive:27^102)))
//│ def [mapa:7^30 · mapa:7^13]:19 = (fun lsa:42 -> lsa:42^188)
//│ def [mapa:7^30]:18 = (fun lsa:39 -> lsa:39^142)
//│ def [mapb:8^31 · mapb:8^23]:21 = (fun lsb:36 -> case lsb:36^108 of {
//│ 	C hb:37 tb:38 => let ha:43 = (primitive:27^126 hb:37^127)
//│ 	in let ta:44 = ([mapb:8^31 · mapb:8^23]:21^122 tb:38^123)
//│ 	in let h:34 = (primitive:27^118 ha:43^119)
//│ 	in let t:35 = ([mapa:7^30 · mapa:7^13]:19^114 ta:44^115)
//│ 	in [S [N] ([sum:6^29 · sum:6^3]:23^110 t:35^111)]})
//│ def [mapb:8^31]:20 = (fun lsb:45 -> case lsb:45^162 of {
//│ 	C hb:46 tb:47 => let ha:40 = (primitive:27^180 hb:46^181)
//│ 	in let ta:41 = ([mapb:8^31 · mapb:8^23]:21^176 tb:47^177)
//│ 	in let h:31 = (primitive:27^172 ha:40^173)
//│ 	in let t:32 = ([mapa:7^30 · mapa:7^13]:19^168 ta:41^169)
//│ 	in [S [N] ([sum:6^29 · sum:6^3]:23^164 t:32^165)]})
//│ def [sum:6^29 · sum:6^3]:23 = (fun ls:33 -> ls:33^106)
//│ def [sum:6^29]:22 = (fun ls:30 -> ls:30^186)
//│ def mapa:7 = (fun lsa:12 -> case lsa:12^132 of {
//│ 	C ha:13 ta:14 => [C (primitive:3^133 ha:13^134) (mapa:7^136 ta:14^137)]})
//│ def mapb:8 = (fun lsb:15 -> case lsb:15^144 of {
//│ 	C hb:16 tb:17 => [C (primitive:3^145 hb:16^146) (mapb:8^148 tb:17^149)]})
//│ def sum:6 = (fun ls:9 -> case ls:9^154 of {
//│ 	C h:10 t:11 => [S [N] (sum:6^156 t:11^157)]})
//│ <<<<<<< after fusion <<<<<<<


if C(A, B(C)) is
    C(a, b) then D(b)
//│ |#if| |C|(|A|,| |B|(|C|)|)| |is|→|C|(|a|,| |b|)| |#then| |D|(|b|)|←|
//│ Parsed: {if C (A, B (C,),) is ‹(C (a, b,)) then D (b,)›}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a:6 b:7 => [D b:7^5]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ case [C [A] [B [C]]] of {
//│ 	C a:14 b:15 => [D b:15^12]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 11: [C 8: [A] 10: [B 9: [C]]]
//│ [C [A] [B [C]]] --->
//│ 	case [C [A] [B [C]]] of {C a:14 b:15 => [D b:15^12]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ let a:14 = [A]
//│ in let b:15 = [B [C]]
//│ in [D b:15^15]
//│ <<<<<<< after fusion <<<<<<<
//│



let rec p = C(C(C(p)))
fun ca(x) = if x is
    C(a) then cb(a)
fun cb(x) = if x is
    C(b) then ca(b)
ca(p)
//│ |#let| |#rec| |p| |#=| |C|(|C|(|C|(|p|)|)|)|↵|#fun| |ca|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |cb|(|a|)|←|↵|#fun| |cb|(|x|)| |#=| |#if| |x| |is|→|C|(|b|)| |#then| |ca|(|b|)|←|↵|ca|(|p|)|
//│ Parsed: {let rec p = C (C (C (p,),),); fun ca = x, => if x is ‹(C (a,)) then cb (a,)›; fun cb = x, => if x is ‹(C (b,)) then ca (b,)›; ca (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (ca:7^17 p:6^18)
//│ def ca:7 = (fun x:9 -> case x:9^5 of {
//│ 	C a:10 => (cb:8^6 a:10^7)})
//│ def cb:8 = (fun x:11 -> case x:11^11 of {
//│ 	C b:12 => (ca:7^12 b:12^13)})
//│ def p:6 = [C [C [C p:6^1]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(C(C(0'p_6^1))) <: 3'x
//│ 	[-p:6^1 · -p:6^1 · -p:6^18 · +ca:7^17 · +cb:8^6 · +ca:7^12 · +cb:8^6 · +ca:7^12 · +cb:8^6 · +ca:7^12]  --->  [-p:6^18 · +ca:7^17]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12] --> [ca:7^17]
//│ [p:6^18 · p:6^1 · p:6^1] --> [p:6^18]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ca:7^17]
//│ 	[ca:7^17 · cb:8^6]
//│ 		[ca:7^17 · cb:8^6 · ca:7^12]
//│ 			[ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6]
//│ 				[ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12]
//│ 					[ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12 · cb:8^6]
//│ 						[ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12] ---> [ca:7^17] (only one)
//│ [p:6^18]
//│ 	[p:6^18 · p:6^1]
//│ 		[p:6^18 · p:6^1 · p:6^1] ---> [p:6^18] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([ca:7^17]:15^64 [p:6^18]:13^65)
//│ def [ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12 · cb:8^6]:20 = (fun x:33 -> case x:33^46 of {
//│ 	C b:34 => ([ca:7^17]:15^47 b:34^48)})
//│ def [ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12]:19 = (fun x:31 -> case x:31^40 of {
//│ 	C a:32 => ([ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12 · cb:8^6]:20^41 a:32^42)})
//│ def [ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6]:18 = (fun x:35 -> case x:35^52 of {
//│ 	C b:36 => ([ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12]:19^53 b:36^54)})
//│ def [ca:7^17 · cb:8^6 · ca:7^12]:17 = (fun x:37 -> case x:37^58 of {
//│ 	C a:38 => ([ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6]:18^59 a:38^60)})
//│ def [ca:7^17 · cb:8^6]:16 = (fun x:29 -> case x:29^34 of {
//│ 	C b:30 => ([ca:7^17 · cb:8^6 · ca:7^12]:17^35 b:30^36)})
//│ def [ca:7^17]:15 = (fun x:27 -> case x:27^28 of {
//│ 	C a:28 => ([ca:7^17 · cb:8^6]:16^29 a:28^30)})
//│ def [p:6^18 · p:6^1]:14 = [C [C [C [p:6^18]:13^20]]]
//│ def [p:6^18]:13 = [C [C [C [p:6^18 · p:6^1]:14^24]]]
//│ def ca:7 = (fun x:9 -> case x:9^8 of {
//│ 	C a:10 => (cb:8^9 a:10^10)})
//│ def cb:8 = (fun x:11 -> case x:11^14 of {
//│ 	C b:12 => (ca:7^15 b:12^16)})
//│ def p:6 = [C [C [C p:6^4]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 21: [C 20: [p:6^18]:13^20]
//│ [C [p:6^18]:13^20] --->
//│ 	case x:33^46 of {C b:34 => ([ca:7^17]:15^47 b:34^48)}
//│ 22: [C 21: [C 20: [p:6^18]:13^20]]
//│ [C [C [p:6^18]:13^20]] --->
//│ 	case x:31^40 of {C a:32 => ([ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12 · cb:8^6]:20^41 a:32^42)}
//│ 23: [C 22: [C 21: [C 20: [p:6^18]:13^20]]]
//│ [C [C [C [p:6^18]:13^20]]] --->
//│ 	case x:35^52 of {C b:36 => ([ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12]:19^53 b:36^54)}
//│ 25: [C 24: [p:6^18 · p:6^1]:14^24]
//│ [C [p:6^18 · p:6^1]:14^24] --->
//│ 	case x:37^58 of {C a:38 => ([ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6]:18^59 a:38^60)}
//│ 26: [C 25: [C 24: [p:6^18 · p:6^1]:14^24]]
//│ [C [C [p:6^18 · p:6^1]:14^24]] --->
//│ 	case x:29^34 of {C b:30 => ([ca:7^17 · cb:8^6 · ca:7^12]:17^35 b:30^36)}
//│ 27: [C 26: [C 25: [C 24: [p:6^18 · p:6^1]:14^24]]]
//│ [C [C [C [p:6^18 · p:6^1]:14^24]]] --->
//│ 	case x:27^28 of {C a:28 => ([ca:7^17 · cb:8^6]:16^29 a:28^30)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([ca:7^17]:15^67 [p:6^18]:13^68)
//│ def [ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12 · cb:8^6]:20 = (fun x:33 -> x:33^74)
//│ def [ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12]:19 = (fun x:31 -> x:31^72)
//│ def [ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6]:18 = (fun x:35 -> x:35^116)
//│ def [ca:7^17 · cb:8^6 · ca:7^12]:17 = (fun x:37 -> x:37^122)
//│ def [ca:7^17 · cb:8^6]:16 = (fun x:29 -> x:29^88)
//│ def [ca:7^17]:15 = (fun x:27 -> x:27^70)
//│ def [p:6^18 · p:6^1]:14 = let b:36 = 
//│ 	let a:32 = 
//│ 		let b:34 = [p:6^18]:13^112
//│ 		in ([ca:7^17]:15^109 b:34^110)
//│ 	in ([ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12 · cb:8^6]:20^106 a:32^107)
//│ in ([ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6 · ca:7^12]:19^103 b:36^104)
//│ def [p:6^18]:13 = let a:28 = 
//│ 	let b:30 = 
//│ 		let a:38 = [p:6^18 · p:6^1]:14^99
//│ 		in ([ca:7^17 · cb:8^6 · ca:7^12 · cb:8^6]:18^96 a:38^97)
//│ 	in ([ca:7^17 · cb:8^6 · ca:7^12]:17^93 b:30^94)
//│ in ([ca:7^17 · cb:8^6]:16^90 a:28^91)
//│ def ca:7 = (fun x:9 -> case x:9^82 of {
//│ 	C a:10 => (cb:8^83 a:10^84)})
//│ def cb:8 = (fun x:11 -> case x:11^76 of {
//│ 	C b:12 => (ca:7^77 b:12^78)})
//│ def p:6 = [C [C [C p:6^118]]]
//│ <<<<<<< after fusion <<<<<<<


// def p:6^18 =
//      ... p:6^1 ~> p:6^18.p:6^1 ...

// def p:6^18.p:6^1 =
//      ... p:6^1 ~> p:6^18 ...

// def ca:7^17
//      ... 



fun c1(x1) = if x1 is
    C(a) then c2(a)
fun c2(x2) = if x2 is
    C(b) then c1(b)
let p1 = C(C(C(p2)))
let p2 = C(p1)
c1(p1)
//│ |#fun| |c1|(|x1|)| |#=| |#if| |x1| |is|→|C|(|a|)| |#then| |c2|(|a|)|←|↵|#fun| |c2|(|x2|)| |#=| |#if| |x2| |is|→|C|(|b|)| |#then| |c1|(|b|)|←|↵|#let| |p1| |#=| |C|(|C|(|C|(|p2|)|)|)|↵|#let| |p2| |#=| |C|(|p1|)|↵|c1|(|p1|)|
//│ Parsed: {fun c1 = x1, => if x1 is ‹(C (a,)) then c2 (a,)›; fun c2 = x2, => if x2 is ‹(C (b,)) then c1 (b,)›; let p1 = C (C (C (p2,),),); let p2 = C (p1,); c1 (p1,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c1:6^19 p1:8^20)
//│ def c1:6 = (fun x1:10 -> case x1:10^1 of {
//│ 	C a:11 => (c2:7^2 a:11^3)})
//│ def c2:7 = (fun x2:12 -> case x2:12^7 of {
//│ 	C b:13 => (c1:6^8 b:13^9)})
//│ def p1:8 = [C [C [C p2:9^13]]]
//│ def p2:9 = [C p1:8^17]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(C(3'p2_9^13)) <: 8'x2
//│ 	[-p1:8^17 · -p2:9^13 · -p1:8^20 · +c1:6^19 · +c2:7^2 · +c1:6^8 · +c2:7^2 · +c1:6^8 · +c2:7^2]  --->  [-p1:8^20 · +c1:6^19 · +c2:7^2]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c1:6^19 · c2:7^2 · c1:6^8 · c2:7^2 · c1:6^8 · c2:7^2] --> [c1:6^19 · c2:7^2]
//│ [p1:8^20 · p2:9^13 · p1:8^17] --> [p1:8^20]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c1:6^19]
//│ 	[c1:6^19 · c2:7^2]
//│ 		[c1:6^19 · c2:7^2 · c1:6^8]
//│ 			[c1:6^19 · c2:7^2 · c1:6^8 · c2:7^2]
//│ 				[c1:6^19 · c2:7^2 · c1:6^8 · c2:7^2 · c1:6^8]
//│ 					[c1:6^19 · c2:7^2 · c1:6^8 · c2:7^2 · c1:6^8 · c2:7^2] ---> [c1:6^19 · c2:7^2] (only one)
//│ [p1:8^20]
//│ 	[p1:8^20 · p2:9^13]
//│ 		[p1:8^20 · p2:9^13 · p1:8^17] ---> [p1:8^20] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([c1:6^19]:14^58 [p1:8^20]:19^59)
//│ def [c1:6^19 · c2:7^2 · c1:6^8 · c2:7^2 · c1:6^8]:18 = (fun x1:31 -> case x1:31^34 of {
//│ 	C a:32 => ([c1:6^19 · c2:7^2]:15^35 a:32^36)})
//│ def [c1:6^19 · c2:7^2 · c1:6^8 · c2:7^2]:17 = (fun x2:27 -> case x2:27^22 of {
//│ 	C b:28 => ([c1:6^19 · c2:7^2 · c1:6^8 · c2:7^2 · c1:6^8]:18^23 b:28^24)})
//│ def [c1:6^19 · c2:7^2 · c1:6^8]:16 = (fun x1:29 -> case x1:29^28 of {
//│ 	C a:30 => ([c1:6^19 · c2:7^2 · c1:6^8 · c2:7^2]:17^29 a:30^30)})
//│ def [c1:6^19 · c2:7^2]:15 = (fun x2:33 -> case x2:33^40 of {
//│ 	C b:34 => ([c1:6^19 · c2:7^2 · c1:6^8]:16^41 b:34^42)})
//│ def [c1:6^19]:14 = (fun x1:35 -> case x1:35^46 of {
//│ 	C a:36 => ([c1:6^19 · c2:7^2]:15^47 a:36^48)})
//│ def [p1:8^20 · p2:9^13]:20 = [C [p1:8^20]:19^52]
//│ def [p1:8^20]:19 = [C [C [C [p1:8^20 · p2:9^13]:20^54]]]
//│ def c1:6 = (fun x1:10 -> case x1:10^4 of {
//│ 	C a:11 => (c2:7^5 a:11^6)})
//│ def c2:7 = (fun x2:12 -> case x2:12^10 of {
//│ 	C b:13 => (c1:6^11 b:13^12)})
//│ def p1:8 = [C [C [C p2:9^16]]]
//│ def p2:9 = [C p1:8^20]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 53: [C 52: [p1:8^20]:19^52]
//│ [C [p1:8^20]:19^52] --->
//│ 	case x2:27^22 of {C b:28 => ([c1:6^19 · c2:7^2 · c1:6^8 · c2:7^2 · c1:6^8]:18^23 b:28^24)}
//│ 55: [C 54: [p1:8^20 · p2:9^13]:20^54]
//│ [C [p1:8^20 · p2:9^13]:20^54] --->
//│ 	case x1:29^28 of {C a:30 => ([c1:6^19 · c2:7^2 · c1:6^8 · c2:7^2]:17^29 a:30^30)}
//│ 56: [C 55: [C 54: [p1:8^20 · p2:9^13]:20^54]]
//│ [C [C [p1:8^20 · p2:9^13]:20^54]] --->
//│ 	case x2:33^40 of {C b:34 => ([c1:6^19 · c2:7^2 · c1:6^8]:16^41 b:34^42)}
//│ 57: [C 56: [C 55: [C 54: [p1:8^20 · p2:9^13]:20^54]]]
//│ [C [C [C [p1:8^20 · p2:9^13]:20^54]]] --->
//│ 	case x1:31^34 of {C a:32 => ([c1:6^19 · c2:7^2]:15^35 a:32^36)}
//│ 	case x1:35^46 of {C a:36 => ([c1:6^19 · c2:7^2]:15^47 a:36^48)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([c1:6^19]:14^61 [p1:8^20]:19^62)
//│ def [c1:6^19 · c2:7^2 · c1:6^8 · c2:7^2 · c1:6^8]:18 = (fun x1:31 -> case x1:31^104 of {
//│ 	C a:32 => ([c1:6^19 · c2:7^2]:15^105 a:32^106)})
//│ def [c1:6^19 · c2:7^2 · c1:6^8 · c2:7^2]:17 = (fun x2:27 -> x2:27^110)
//│ def [c1:6^19 · c2:7^2 · c1:6^8]:16 = (fun x1:29 -> x1:29^96)
//│ def [c1:6^19 · c2:7^2]:15 = (fun x2:33 -> x2:33^112)
//│ def [c1:6^19]:14 = (fun x1:35 -> x1:35^90)
//│ def [p1:8^20 · p2:9^13]:20 = let b:28 = [p1:8^20]:19^73
//│ in ([c1:6^19 · c2:7^2 · c1:6^8 · c2:7^2 · c1:6^8]:18^70 b:28^71)
//│ def [p1:8^20]:19 = let a:36 = 
//│ 	let b:34 = 
//│ 		let a:30 = [p1:8^20 · p2:9^13]:20^84
//│ 		in ([c1:6^19 · c2:7^2 · c1:6^8 · c2:7^2]:17^81 a:30^82)
//│ 	in ([c1:6^19 · c2:7^2 · c1:6^8]:16^78 b:34^79)
//│ in ([c1:6^19 · c2:7^2]:15^75 a:36^76)
//│ def c1:6 = (fun x1:10 -> case x1:10^98 of {
//│ 	C a:11 => (c2:7^99 a:11^100)})
//│ def c2:7 = (fun x2:12 -> case x2:12^64 of {
//│ 	C b:13 => (c1:6^65 b:13^66)})
//│ def p1:8 = [C [C [C p2:9^92]]]
//│ def p2:9 = [C p1:8^88]
//│ <<<<<<< after fusion <<<<<<<


fun ff(x) = if x is
    K then T
    KK then TT
    KKKK then TTTT
fun map(ls) = if ls is
    C(h, t) then C(ff(h), map(t))
    N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|ff|(|h|)|,| |map|(|t|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; fun map = ls, => if ls is ‹(C (h, t,)) then C (ff (h,), map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map:7^25 l:8^26)
//│ def ff:6 = (fun x:9 -> case x:9^1 of {
//│ 	K => [T]
//│ 	| KK => [TT]
//│ 	| KKKK => [TTTT]})
//│ def l:8 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map:7 = (fun ls:10 -> case ls:10^7 of {
//│ 	C h:11 t:12 => [C (ff:6^8 h:11^9) (map:7^11 t:12^12)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 7't
//│ 	[-l:8^26 · +map:7^25 · +map:7^11 · +map:7^11 · +map:7^11 · +map:7^11]  --->  [-l:8^26 · +map:7^25 · +map:7^11 · +map:7^11 · +map:7^11]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [map:7^25 · map:7^11 · map:7^11 · map:7^11 · map:7^11] --> [map:7^25 · map:7^11 · map:7^11 · map:7^11]
//│ [l:8^26] --> [l:8^26]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l:8^26]
//│ 
//│ [map:7^25]
//│ 	[map:7^25 · map:7^11]
//│ 		[map:7^25 · map:7^11 · map:7^11]
//│ 			[map:7^25 · map:7^11 · map:7^11 · map:7^11]
//│ 				[map:7^25 · map:7^11 · map:7^11 · map:7^11 · map:7^11] ---> [map:7^25 · map:7^11 · map:7^11 · map:7^11] (only one)
//│ 				[map:7^25 · map:7^11 · map:7^11 · map:7^11 · ff:6^8] ---> [ff:6^8] (hopeless to continue)
//│ 			[map:7^25 · map:7^11 · map:7^11 · ff:6^8] ---> [ff:6^8] (hopeless to continue)
//│ 		[map:7^25 · map:7^11 · ff:6^8] ---> [ff:6^8] (hopeless to continue)
//│ 	[map:7^25 · ff:6^8] ---> [ff:6^8] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([map:7^25]:13^79 [l:8^26]:17^80)
//│ def [l:8^26]:17 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def [map:7^25 · map:7^11 · map:7^11 · map:7^11]:16 = (fun ls:30 -> case ls:30^57 of {
//│ 	C h:31 t:32 => [C (ff:6^58 h:31^59) ([map:7^25 · map:7^11 · map:7^11 · map:7^11]:16^61 t:32^62)]
//│ 	| N => [N]})
//│ def [map:7^25 · map:7^11 · map:7^11]:15 = (fun ls:33 -> case ls:33^68 of {
//│ 	C h:34 t:35 => [C (ff:6^69 h:34^70) ([map:7^25 · map:7^11 · map:7^11 · map:7^11]:16^72 t:35^73)]
//│ 	| N => [N]})
//│ def [map:7^25 · map:7^11]:14 = (fun ls:27 -> case ls:27^46 of {
//│ 	C h:28 t:29 => [C (ff:6^47 h:28^48) ([map:7^25 · map:7^11 · map:7^11]:15^50 t:29^51)]
//│ 	| N => [N]})
//│ def [map:7^25]:13 = (fun ls:24 -> case ls:24^35 of {
//│ 	C h:25 t:26 => [C (ff:6^36 h:25^37) ([map:7^25 · map:7^11]:14^39 t:26^40)]
//│ 	| N => [N]})
//│ def ff:6 = (fun x:9 -> case x:9^4 of {
//│ 	K => [T]
//│ 	| KK => [TT]
//│ 	| KKKK => [TTTT]})
//│ def l:8 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map:7 = (fun ls:10 -> case ls:10^10 of {
//│ 	C h:11 t:12 => [C (ff:6^11 h:11^12) (map:7^14 t:12^15)]
//│ 	| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 28: [K]
//│ [K] --->
//│ 	case x:9^4 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 29: [KK]
//│ [KK] --->
//│ 	case x:9^4 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 30: [KKKK]
//│ [KKKK] --->
//│ 	case x:9^4 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 31: [N]
//│ [N] --->
//│ 	case ls:30^57 of {C h:31 t:32 => [C (ff:6^58 h:31^59) ([map:7^25 · map:7^11 · map:7^11 · map:7^11]:16^61 t:32^62)] | N => [N]}
//│ 32: [C 30: [KKKK] 31: [N]]
//│ [C [KKKK] [N]] --->
//│ 	case ls:33^68 of {C h:34 t:35 => [C (ff:6^69 h:34^70) ([map:7^25 · map:7^11 · map:7^11 · map:7^11]:16^72 t:35^73)] | N => [N]}
//│ 33: [C 29: [KK] 32: [C 30: [KKKK] 31: [N]]]
//│ [C [KK] [C [KKKK] [N]]] --->
//│ 	case ls:27^46 of {C h:28 t:29 => [C (ff:6^47 h:28^48) ([map:7^25 · map:7^11 · map:7^11]:15^50 t:29^51)] | N => [N]}
//│ 34: [C 28: [K] 33: [C 29: [KK] 32: [C 30: [KKKK] 31: [N]]]]
//│ [C [K] [C [KK] [C [KKKK] [N]]]] --->
//│ 	case ls:24^35 of {C h:25 t:26 => [C (ff:6^36 h:25^37) ([map:7^25 · map:7^11]:14^39 t:26^40)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([map:7^25]:13^82 [l:8^26]:17^83)
//│ def [l:8^26]:17 = let h:25 = [T]
//│ in let t:26 = 
//│ 	let h:28 = [TT]
//│ 	in let t:29 = 
//│ 		let h:34 = [TTTT]
//│ 		in let t:35 = [N]
//│ 		in [C (ff:6^114 h:34^115) ([map:7^25 · map:7^11 · map:7^11 · map:7^11]:16^117 t:35^118)]
//│ 	in [C (ff:6^107 h:28^108) ([map:7^25 · map:7^11 · map:7^11]:15^110 t:29^111)]
//│ in [C (ff:6^100 h:25^101) ([map:7^25 · map:7^11]:14^103 t:26^104)]
//│ def [map:7^25 · map:7^11 · map:7^11 · map:7^11]:16 = (fun ls:30 -> ls:30^142)
//│ def [map:7^25 · map:7^11 · map:7^11]:15 = (fun ls:33 -> ls:33^98)
//│ def [map:7^25 · map:7^11]:14 = (fun ls:27 -> ls:27^85)
//│ def [map:7^25]:13 = (fun ls:24 -> ls:24^138)
//│ def ff:6 = (fun x:9 -> x:9^140)
//│ def l:8 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map:7 = (fun ls:10 -> case ls:10^87 of {
//│ 	C h:11 t:12 => [C (ff:6^88 h:11^89) (map:7^91 t:12^92)]
//│ 	| N => [N]})
//│ <<<<<<< after fusion <<<<<<<


fun map(ls) = if ls is
    C(h, t) then C(
        (if h is
            K then T
            KK then TT
            KKKK then TTTT
        ),
        map(t)
    )
    N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›, ')', map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map:6^21 l:7^22)
//│ def l:7 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map:6 = (fun ls:8 -> case ls:8^1 of {
//│ 	C h:9 t:10 => [C case h:9^2 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} (map:6^7 t:10^8)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 4't
//│ 	[-l:7^22 · +map:6^21 · +map:6^7 · +map:6^7 · +map:6^7 · +map:6^7]  --->  [-l:7^22 · +map:6^21 · +map:6^7 · +map:6^7 · +map:6^7]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [map:6^21 · map:6^7 · map:6^7 · map:6^7 · map:6^7] --> [map:6^21 · map:6^7 · map:6^7 · map:6^7]
//│ [l:7^22] --> [l:7^22]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l:7^22]
//│ 
//│ [map:6^21]
//│ 	[map:6^21 · map:6^7]
//│ 		[map:6^21 · map:6^7 · map:6^7]
//│ 			[map:6^21 · map:6^7 · map:6^7 · map:6^7]
//│ 				[map:6^21 · map:6^7 · map:6^7 · map:6^7 · map:6^7] ---> [map:6^21 · map:6^7 · map:6^7 · map:6^7] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([map:6^21]:12^83 [l:7^22]:11^84)
//│ def [l:7^22]:11 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def [map:6^21 · map:6^7 · map:6^7 · map:6^7]:15 = (fun ls:28 -> case ls:28^50 of {
//│ 	C h:29 t:30 => [C case h:29^51 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} ([map:6^21 · map:6^7 · map:6^7 · map:6^7]:15^56 t:30^57)]
//│ 	| N => [N]})
//│ def [map:6^21 · map:6^7 · map:6^7]:14 = (fun ls:31 -> case ls:31^70 of {
//│ 	C h:32 t:33 => [C case h:32^71 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} ([map:6^21 · map:6^7 · map:6^7 · map:6^7]:15^76 t:33^77)]
//│ 	| N => [N]})
//│ def [map:6^21 · map:6^7]:13 = (fun ls:25 -> case ls:25^37 of {
//│ 	C h:26 t:27 => [C case h:26^38 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} ([map:6^21 · map:6^7 · map:6^7]:14^43 t:27^44)]
//│ 	| N => [N]})
//│ def [map:6^21]:12 = (fun ls:22 -> case ls:22^24 of {
//│ 	C h:23 t:24 => [C case h:23^25 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} ([map:6^21 · map:6^7]:13^30 t:24^31)]
//│ 	| N => [N]})
//│ def l:7 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map:6 = (fun ls:8 -> case ls:8^4 of {
//│ 	C h:9 t:10 => [C case h:9^5 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} (map:6^10 t:10^11)]
//│ 	| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 63: [K]
//│ [K] --->
//│ 	case h:23^25 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 64: [KK]
//│ [KK] --->
//│ 	case h:26^38 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 65: [KKKK]
//│ [KKKK] --->
//│ 	case h:32^71 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 66: [N]
//│ [N] --->
//│ 	case ls:28^50 of {C h:29 t:30 => [C case h:29^51 of {K => [T] | KK => [TT] | KKKK => [TTTT]} ([map:6^21 · map:6^7 · map:6^7 · map:6^7]:15^56 t:30^57)] | N => [N]}
//│ 67: [C 65: [KKKK] 66: [N]]
//│ [C [KKKK] [N]] --->
//│ 	case ls:31^70 of {C h:32 t:33 => [C case h:32^71 of {K => [T] | KK => [TT] | KKKK => [TTTT]} ([map:6^21 · map:6^7 · map:6^7 · map:6^7]:15^76 t:33^77)] | N => [N]}
//│ 68: [C 64: [KK] 67: [C 65: [KKKK] 66: [N]]]
//│ [C [KK] [C [KKKK] [N]]] --->
//│ 	case ls:25^37 of {C h:26 t:27 => [C case h:26^38 of {K => [T] | KK => [TT] | KKKK => [TTTT]} ([map:6^21 · map:6^7 · map:6^7]:14^43 t:27^44)] | N => [N]}
//│ 69: [C 63: [K] 68: [C 64: [KK] 67: [C 65: [KKKK] 66: [N]]]]
//│ [C [K] [C [KK] [C [KKKK] [N]]]] --->
//│ 	case ls:22^24 of {C h:23 t:24 => [C case h:23^25 of {K => [T] | KK => [TT] | KKKK => [TTTT]} ([map:6^21 · map:6^7]:13^30 t:24^31)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([map:6^21]:12^86 [l:7^22]:11^87)
//│ def [l:7^22]:11 = let h:23 = [T]
//│ in let t:24 = 
//│ 	let h:26 = [TT]
//│ 	in let t:27 = 
//│ 		let h:32 = [TTTT]
//│ 		in let t:33 = [N]
//│ 		in [C h:32^125 ([map:6^21 · map:6^7 · map:6^7 · map:6^7]:15^126 t:33^127)]
//│ 	in [C h:26^120 ([map:6^21 · map:6^7 · map:6^7]:14^121 t:27^122)]
//│ in [C h:23^115 ([map:6^21 · map:6^7]:13^116 t:24^117)]
//│ def [map:6^21 · map:6^7 · map:6^7 · map:6^7]:15 = (fun ls:28 -> ls:28^140)
//│ def [map:6^21 · map:6^7 · map:6^7]:14 = (fun ls:31 -> ls:31^89)
//│ def [map:6^21 · map:6^7]:13 = (fun ls:25 -> ls:25^111)
//│ def [map:6^21]:12 = (fun ls:22 -> ls:22^113)
//│ def l:7 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map:6 = (fun ls:8 -> case ls:8^98 of {
//│ 	C h:9 t:10 => [C case h:9^99 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} (map:6^104 t:10^105)]
//│ 	| N => [N]})
//│ <<<<<<< after fusion <<<<<<<


fun sum(ls) = if ls is
    C(h, t) then S(N, sum(t))
    N then N
fun mapa(lsa) = if lsa is
    C(ha, ta) then C(primitive(ha), mapa(ta))
    N then N
fun mapb(lsb) = if lsb is
    C(hb, tb) then C(primitive(hb), mapb(tb))
    N then N
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|↵|N| |#then| |N|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|↵|N| |#then| |N|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),); (N) then N›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),); (N) then N›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),); (N) then N›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (sum:6^32 (mapa:7^33 (mapb:8^34 primitive:3^35)))
//│ def mapa:7 = (fun lsa:12 -> case lsa:12^10 of {
//│ 	C ha:13 ta:14 => [C (primitive:3^11 ha:13^12) (mapa:7^14 ta:14^15)]
//│ 	| N => [N]})
//│ def mapb:8 = (fun lsb:15 -> case lsb:15^21 of {
//│ 	C hb:16 tb:17 => [C (primitive:3^22 hb:16^23) (mapb:8^25 tb:17^26)]
//│ 	| N => [N]})
//│ def sum:6 = (fun ls:9 -> case ls:9^1 of {
//│ 	C h:10 t:11 => [S [N] (sum:6^3 t:11^4)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(11'13_callres, 12'16_callres) <: 3'ls
//│ 	[-mapa:7^14 · -mapa:7^14 · -mapa:7^33 · +sum:6^32 · +sum:6^3 · +sum:6^3]  --->  [-mapa:7^14 · -mapa:7^33 · +sum:6^32 · +sum:6^3]
//│ C(17'24_callres, 18'27_callres) <: 8'lsa
//│ 	[-mapb:8^25 · -mapb:8^25 · -mapb:8^34 · +mapa:7^33 · +mapa:7^14 · +mapa:7^14]  --->  [-mapb:8^25 · -mapb:8^34 · +mapa:7^33 · +mapa:7^14]
//│ NoProd <: 14'lsb
//│ 	[+mapb:8^34 · +mapb:8^25 · +mapb:8^25]  --->  [+mapb:8^34 · +mapb:8^25]
//│ NoProd <: 8'lsa
//│ 	[-mapb:8^34 · +mapa:7^33 · +mapa:7^14 · +mapa:7^14]  --->  [-mapb:8^34 · +mapa:7^33 · +mapa:7^14]
//│ NoProd <: 3'ls
//│ 	[-mapa:7^33 · +sum:6^32 · +sum:6^3 · +sum:6^3]  --->  [-mapa:7^33 · +sum:6^32 · +sum:6^3]
//│ NoProd <: 10'ta
//│ 	[-mapb:8^25 · -mapb:8^25 · -mapb:8^34 · +mapa:7^33 · +mapa:7^14 · +mapa:7^14 · +mapa:7^14]  --->  [-mapb:8^25 · -mapb:8^25 · -mapb:8^34 · +mapa:7^33 · +mapa:7^14 · +mapa:7^14]
//│ 	[-mapb:8^25 · -mapb:8^34 · +mapa:7^33 · +mapa:7^14 · +mapa:7^14]  --->  [-mapb:8^25 · -mapb:8^34 · +mapa:7^33 · +mapa:7^14]
//│ NoProd <: 5't
//│ 	[-mapa:7^14 · -mapa:7^14 · -mapa:7^33 · +sum:6^32 · +sum:6^3 · +sum:6^3 · +sum:6^3]  --->  [-mapa:7^14 · -mapa:7^14 · -mapa:7^33 · +sum:6^32 · +sum:6^3 · +sum:6^3]
//│ 	[-mapa:7^14 · -mapa:7^33 · +sum:6^32 · +sum:6^3 · +sum:6^3]  --->  [-mapa:7^14 · -mapa:7^33 · +sum:6^32 · +sum:6^3]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [mapa:7^33 · mapa:7^14 · mapa:7^14 · mapa:7^14] --> [mapa:7^33 · mapa:7^14 · mapa:7^14]
//│ [mapa:7^33 · mapa:7^14 · mapa:7^14] --> [mapa:7^33 · mapa:7^14]
//│ 	[mapa:7^33 · mapa:7^14 · mapa:7^14]
//│ 	!!MORE THAN ONE MATCH
//│ [sum:6^32 · sum:6^3 · sum:6^3 · sum:6^3] --> [sum:6^32 · sum:6^3 · sum:6^3]
//│ [sum:6^32 · sum:6^3 · sum:6^3] --> [sum:6^32 · sum:6^3]
//│ [mapa:7^33 · mapa:7^14] --> [mapa:7^33 · mapa:7^14]
//│ [mapa:7^33] --> [mapa:7^33]
//│ [mapb:8^34 · mapb:8^25 · mapb:8^25] --> [mapb:8^34 · mapb:8^25 · mapb:8^25]
//│ 	[mapb:8^34 · mapb:8^25]
//│ 	!!MORE THAN ONE MATCH
//│ [mapb:8^34 · mapb:8^25] --> [mapb:8^34 · mapb:8^25]
//│ [mapb:8^34] --> [mapb:8^34]
//│ [] --> []
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa:7^33]
//│ 	[mapa:7^33 · mapa:7^14]
//│ 		[mapa:7^33 · mapa:7^14 · mapa:7^14] ---> [mapa:7^33 · mapa:7^14] (only one)
//│ [mapb:8^34]
//│ 	[mapb:8^34 · mapb:8^25]
//│ 		[mapb:8^34 · mapb:8^25 · mapb:8^25] ---> [mapb:8^34 · mapb:8^25] (only one)
//│ [sum:6^32]
//│ 	[sum:6^32 · sum:6^3]
//│ 		[sum:6^32 · sum:6^3 · sum:6^3] ---> [sum:6^32 · sum:6^3] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([sum:6^32]:18^101 ([mapa:7^33]:20^102 ([mapb:8^34]:22^103 primitive:27^104)))
//│ def [mapa:7^33 · mapa:7^14]:21 = (fun lsa:36 -> case lsa:36^59 of {
//│ 	C ha:37 ta:38 => [C (primitive:27^60 ha:37^61) ([mapa:7^33 · mapa:7^14]:21^63 ta:38^64)]
//│ 	| N => [N]})
//│ def [mapa:7^33]:20 = (fun lsa:33 -> case lsa:33^48 of {
//│ 	C ha:34 ta:35 => [C (primitive:27^49 ha:34^50) ([mapa:7^33 · mapa:7^14]:21^52 ta:35^53)]
//│ 	| N => [N]})
//│ def [mapb:8^34 · mapb:8^25]:23 = (fun lsb:39 -> case lsb:39^70 of {
//│ 	C hb:40 tb:41 => [C (primitive:27^71 hb:40^72) ([mapb:8^34 · mapb:8^25]:23^74 tb:41^75)]
//│ 	| N => [N]})
//│ def [mapb:8^34]:22 = (fun lsb:45 -> case lsb:45^90 of {
//│ 	C hb:46 tb:47 => [C (primitive:27^91 hb:46^92) ([mapb:8^34 · mapb:8^25]:23^94 tb:47^95)]
//│ 	| N => [N]})
//│ def [sum:6^32 · sum:6^3]:19 = (fun ls:42 -> case ls:42^81 of {
//│ 	C h:43 t:44 => [S [N] ([sum:6^32 · sum:6^3]:19^83 t:44^84)]
//│ 	| N => [N]})
//│ def [sum:6^32]:18 = (fun ls:30 -> case ls:30^39 of {
//│ 	C h:31 t:32 => [S [N] ([sum:6^32 · sum:6^3]:19^41 t:32^42)]
//│ 	| N => [N]})
//│ def mapa:7 = (fun lsa:12 -> case lsa:12^17 of {
//│ 	C ha:13 ta:14 => [C (primitive:3^18 ha:13^19) (mapa:7^21 ta:14^22)]
//│ 	| N => [N]})
//│ def mapb:8 = (fun lsb:15 -> case lsb:15^28 of {
//│ 	C hb:16 tb:17 => [C (primitive:3^29 hb:16^30) (mapb:8^32 tb:17^33)]
//│ 	| N => [N]})
//│ def sum:6 = (fun ls:9 -> case ls:9^8 of {
//│ 	C h:10 t:11 => [S [N] (sum:6^10 t:11^11)]
//│ 	| N => [N]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 55: [C 51: (49: primitive:27^49 50: ha:34^50) 54: (52: [mapa:7^33 · mapa:7^14]:21^52 53: ta:35^53)]
//│ [C (primitive:27^49 ha:34^50) ([mapa:7^33 · mapa:7^14]:21^52 ta:35^53)] --->
//│ 	case ls:30^39 of {C h:31 t:32 => [S [N] ([sum:6^32 · sum:6^3]:19^41 t:32^42)] | N => [N]}
//│ 56: [N]
//│ [N] --->
//│ 	case ls:30^39 of {C h:31 t:32 => [S [N] ([sum:6^32 · sum:6^3]:19^41 t:32^42)] | N => [N]}
//│ 66: [C 62: (60: primitive:27^60 61: ha:37^61) 65: (63: [mapa:7^33 · mapa:7^14]:21^63 64: ta:38^64)]
//│ [C (primitive:27^60 ha:37^61) ([mapa:7^33 · mapa:7^14]:21^63 ta:38^64)] --->
//│ 	case ls:42^81 of {C h:43 t:44 => [S [N] ([sum:6^32 · sum:6^3]:19^83 t:44^84)] | N => [N]}
//│ 67: [N]
//│ [N] --->
//│ 	case ls:42^81 of {C h:43 t:44 => [S [N] ([sum:6^32 · sum:6^3]:19^83 t:44^84)] | N => [N]}
//│ 77: [C 73: (71: primitive:27^71 72: hb:40^72) 76: (74: [mapb:8^34 · mapb:8^25]:23^74 75: tb:41^75)]
//│ [C (primitive:27^71 hb:40^72) ([mapb:8^34 · mapb:8^25]:23^74 tb:41^75)] --->
//│ 	case lsa:36^59 of {C ha:37 ta:38 => [C (primitive:27^60 ha:37^61) ([mapa:7^33 · mapa:7^14]:21^63 ta:38^64)] | N => [N]}
//│ 78: [N]
//│ [N] --->
//│ 	case lsa:36^59 of {C ha:37 ta:38 => [C (primitive:27^60 ha:37^61) ([mapa:7^33 · mapa:7^14]:21^63 ta:38^64)] | N => [N]}
//│ 97: [C 93: (91: primitive:27^91 92: hb:46^92) 96: (94: [mapb:8^34 · mapb:8^25]:23^94 95: tb:47^95)]
//│ [C (primitive:27^91 hb:46^92) ([mapb:8^34 · mapb:8^25]:23^94 tb:47^95)] --->
//│ 	case lsa:33^48 of {C ha:34 ta:35 => [C (primitive:27^49 ha:34^50) ([mapa:7^33 · mapa:7^14]:21^52 ta:35^53)] | N => [N]}
//│ 98: [N]
//│ [N] --->
//│ 	case lsa:33^48 of {C ha:34 ta:35 => [C (primitive:27^49 ha:34^50) ([mapa:7^33 · mapa:7^14]:21^52 ta:35^53)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([sum:6^32]:18^108 ([mapa:7^33]:20^109 ([mapb:8^34]:22^110 primitive:27^111)))
//│ def [mapa:7^33 · mapa:7^14]:21 = (fun lsa:36 -> lsa:36^176)
//│ def [mapa:7^33]:20 = (fun lsa:33 -> lsa:33^178)
//│ def [mapb:8^34 · mapb:8^25]:23 = (fun lsb:39 -> case lsb:39^140 of {
//│ 	C hb:40 tb:41 => let ha:37 = (primitive:27^158 hb:40^159)
//│ 	in let ta:38 = ([mapb:8^34 · mapb:8^25]:23^154 tb:41^155)
//│ 	in let h:43 = (primitive:27^150 ha:37^151)
//│ 	in let t:44 = ([mapa:7^33 · mapa:7^14]:21^146 ta:38^147)
//│ 	in [S [N] ([sum:6^32 · sum:6^3]:19^142 t:44^143)]
//│ 	| N => [N]})
//│ def [mapb:8^34]:22 = (fun lsb:45 -> case lsb:45^115 of {
//│ 	C hb:46 tb:47 => let ha:34 = (primitive:27^133 hb:46^134)
//│ 	in let ta:35 = ([mapb:8^34 · mapb:8^25]:23^129 tb:47^130)
//│ 	in let h:31 = (primitive:27^125 ha:34^126)
//│ 	in let t:32 = ([mapa:7^33 · mapa:7^14]:21^121 ta:35^122)
//│ 	in [S [N] ([sum:6^32 · sum:6^3]:19^117 t:32^118)]
//│ 	| N => [N]})
//│ def [sum:6^32 · sum:6^3]:19 = (fun ls:42 -> ls:42^202)
//│ def [sum:6^32]:18 = (fun ls:30 -> ls:30^200)
//│ def mapa:7 = (fun lsa:12 -> case lsa:12^165 of {
//│ 	C ha:13 ta:14 => [C (primitive:3^166 ha:13^167) (mapa:7^169 ta:14^170)]
//│ 	| N => [N]})
//│ def mapb:8 = (fun lsb:15 -> case lsb:15^180 of {
//│ 	C hb:16 tb:17 => [C (primitive:3^181 hb:16^182) (mapb:8^184 tb:17^185)]
//│ 	| N => [N]})
//│ def sum:6 = (fun ls:9 -> case ls:9^191 of {
//│ 	C h:10 t:11 => [S [N] (sum:6^193 t:11^194)]
//│ 	| N => [N]})
//│ <<<<<<< after fusion <<<<<<<



let rec p = C(p)
fun c(x) = if x is
    C(a) then c(a)
fun main(cc) = cc(p)
main(c)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|cc|)| |#=| |cc|(|p|)|↵|main|(|c|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = cc, => cc (p,); main (c,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (main:8^13 c:7^14)
//│ def c:7 = (fun x:9 -> case x:9^3 of {
//│ 	C a:10 => (c:7^4 a:10^5)})
//│ def main:8 = (fun cc:11 -> (cc:11^9 p:6^10))
//│ def p:6 = [C p:6^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(0'p_6^1) <: 3'x
//│ 	[-p:6^1 · -p:6^10 · -main:8^13 · +c:7^14 · +c:7^4]  --->  [-p:6^10 · -main:8^13 · +c:7^14]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c:7^14 · c:7^4] --> [c:7^14]
//│ [main:8^13 · p:6^10 · p:6^1] --> [main:8^13 · p:6^10]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c:7^14]
//│ 	[c:7^14 · c:7^4] ---> [c:7^14] (only one)
//│ [main:8^13]
//│ 	[main:8^13 · p:6^10]
//│ 		[main:8^13 · p:6^10 · p:6^1] ---> [main:8^13 · p:6^10] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([main:8^13]:12^28 [c:7^14]:14^29)
//│ def [c:7^14]:14 = (fun x:22 -> case x:22^20 of {
//│ 	C a:23 => ([c:7^14]:14^21 a:23^22)})
//│ def [main:8^13 · p:6^10]:13 = [C [main:8^13 · p:6^10]:13^26]
//│ def [main:8^13]:12 = (fun cc:21 -> (cc:21^16 [main:8^13 · p:6^10]:13^17))
//│ def c:7 = (fun x:9 -> case x:9^6 of {
//│ 	C a:10 => (c:7^7 a:10^8)})
//│ def main:8 = (fun cc:11 -> (cc:11^12 p:6^13))
//│ def p:6 = [C p:6^4]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 27: [C 26: [main:8^13 · p:6^10]:13^26]
//│ [C [main:8^13 · p:6^10]:13^26] --->
//│ 	case x:22^20 of {C a:23 => ([c:7^14]:14^21 a:23^22)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([main:8^13]:12^31 [c:7^14]:14^32)
//│ def [c:7^14]:14 = (fun x:22 -> x:22^47)
//│ def [main:8^13 · p:6^10]:13 = let a:23 = [main:8^13 · p:6^10]:13^41
//│ in ([c:7^14]:14^38 a:23^39)
//│ def [main:8^13]:12 = (fun cc:21 -> (cc:21^34 [main:8^13 · p:6^10]:13^35))
//│ def c:7 = (fun x:9 -> case x:9^51 of {
//│ 	C a:10 => (c:7^52 a:10^53)})
//│ def main:8 = (fun cc:11 -> (cc:11^43 p:6^44))
//│ def p:6 = [C p:6^49]
//│ <<<<<<< after fusion <<<<<<<


// this path seems also to be sensible
let rec p = C(p)
fun c(x) = if x is
    C(a) then c(a)
fun main(pp) = if pp is
    C(b) then if b is
        C(d) then c(d)
main(p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|pp|)| |#=| |#if| |pp| |is|→|C|(|b|)| |#then| |#if| |b| |is|→|C|(|d|)| |#then| |c|(|d|)|←|←|↵|main|(|p|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = pp, => if pp is ‹(C (b,)) then if b is ‹(C (d,)) then c (d,)››; main (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (main:8^17 p:6^18)
//│ def c:7 = (fun x:9 -> case x:9^3 of {
//│ 	C a:10 => (c:7^4 a:10^5)})
//│ def main:8 = (fun pp:11 -> case pp:11^9 of {
//│ 	C b:12 => case b:12^10 of {
//│ 		C d:13 => (c:7^11 d:13^12)}})
//│ def p:6 = [C p:6^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(0'p_6^1) <: 3'x
//│ 	[-p:6^1 · -p:6^1 · -p:6^1 · -p:6^18 · +main:8^17 · +c:7^11 · +c:7^4]  --->  [-p:6^1 · -p:6^1 · -p:6^18 · +main:8^17 · +c:7^11]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [main:8^17 · c:7^11 · c:7^4] --> [main:8^17 · c:7^11]
//│ [p:6^18 · p:6^1 · p:6^1 · p:6^1] --> [p:6^18 · p:6^1 · p:6^1]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [main:8^17]
//│ 	[main:8^17 · c:7^11]
//│ 		[main:8^17 · c:7^11 · c:7^4] ---> [main:8^17 · c:7^11] (only one)
//│ [p:6^18]
//│ 	[p:6^18 · p:6^1]
//│ 		[p:6^18 · p:6^1 · p:6^1]
//│ 			[p:6^18 · p:6^1 · p:6^1 · p:6^1] ---> [p:6^18 · p:6^1 · p:6^1] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([main:8^17]:17^40 [p:6^18]:14^41)
//│ def [main:8^17 · c:7^11]:18 = (fun x:28 -> case x:28^34 of {
//│ 	C a:29 => ([main:8^17 · c:7^11]:18^35 a:29^36)})
//│ def [main:8^17]:17 = (fun pp:25 -> case pp:25^22 of {
//│ 	C b:26 => case b:26^23 of {
//│ 		C d:27 => ([main:8^17 · c:7^11]:18^24 d:27^25)}})
//│ def [p:6^18 · p:6^1 · p:6^1]:16 = [C [p:6^18 · p:6^1 · p:6^1]:16^32]
//│ def [p:6^18 · p:6^1]:15 = [C [p:6^18 · p:6^1 · p:6^1]:16^20]
//│ def [p:6^18]:14 = [C [p:6^18 · p:6^1]:15^30]
//│ def c:7 = (fun x:9 -> case x:9^6 of {
//│ 	C a:10 => (c:7^7 a:10^8)})
//│ def main:8 = (fun pp:11 -> case pp:11^12 of {
//│ 	C b:12 => case b:12^13 of {
//│ 		C d:13 => (c:7^14 d:13^15)}})
//│ def p:6 = [C p:6^4]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 21: [C 20: [p:6^18 · p:6^1 · p:6^1]:16^20]
//│ [C [p:6^18 · p:6^1 · p:6^1]:16^20] --->
//│ 	case b:26^23 of {C d:27 => ([main:8^17 · c:7^11]:18^24 d:27^25)}
//│ 31: [C 30: [p:6^18 · p:6^1]:15^30]
//│ [C [p:6^18 · p:6^1]:15^30] --->
//│ 	case pp:25^22 of {C b:26 => case b:26^23 of {C d:27 => ([main:8^17 · c:7^11]:18^24 d:27^25)}}
//│ 33: [C 32: [p:6^18 · p:6^1 · p:6^1]:16^32]
//│ [C [p:6^18 · p:6^1 · p:6^1]:16^32] --->
//│ 	case x:28^34 of {C a:29 => ([main:8^17 · c:7^11]:18^35 a:29^36)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([main:8^17]:17^43 [p:6^18]:14^44)
//│ def [main:8^17 · c:7^11]:18 = (fun x:28 -> x:28^48)
//│ def [main:8^17]:17 = (fun pp:25 -> pp:25^46)
//│ def [p:6^18 · p:6^1 · p:6^1]:16 = let a:29 = [p:6^18 · p:6^1 · p:6^1]:16^53
//│ in ([main:8^17 · c:7^11]:18^50 a:29^51)
//│ def [p:6^18 · p:6^1]:15 = let d:27 = [p:6^18 · p:6^1 · p:6^1]:16^69
//│ in ([main:8^17 · c:7^11]:18^66 d:27^67)
//│ def [p:6^18]:14 = let b:26 = [p:6^18 · p:6^1]:15^56
//│ in b:26^55
//│ def c:7 = (fun x:9 -> case x:9^73 of {
//│ 	C a:10 => (c:7^74 a:10^75)})
//│ def main:8 = (fun pp:11 -> case pp:11^58 of {
//│ 	C b:12 => case b:12^59 of {
//│ 		C d:13 => (c:7^60 d:13^61)}})
//│ def p:6 = [C p:6^71]
//│ <<<<<<< after fusion <<<<<<<


let rec p = C(p)
let c(x) = if x is
    C(a) then c(a)
fun main(cc, pp) = cc(pp)
main(c, p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#let| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|cc|,| |pp|)| |#=| |cc|(|pp|)|↵|main|(|c|,| |p|)|
//│ Parsed: {let rec p = C (p,); let c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = cc, pp, => cc (pp,); main (c, p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((main:8^14 c:7^15) p:6^17)
//│ def c:7 = (fun x:9 -> case x:9^3 of {
//│ 	C a:10 => (c:7^4 a:10^5)})
//│ def main:8 = (fun cc:11 -> (fun pp:12 -> (cc:11^9 pp:12^10)))
//│ def p:6 = [C p:6^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(0'p_6^1) <: 3'x
//│ 	[-p:6^1 · -p:6^17 · +main:8^14 · -main:8^14 · +c:7^15 · +c:7^4]  --->  [-p:6^17 · +main:8^14 · -main:8^14 · +c:7^15]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c:7^15 · c:7^4] --> [c:7^15]
//│ [p:6^17 · p:6^1] --> [p:6^17]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c:7^15]
//│ 	[c:7^15 · c:7^4] ---> [c:7^15] (only one)
//│ [main:8^14] ---> [main:8^14] (hopeless to continue)
//│ [p:6^17]
//│ 	[p:6^17 · p:6^1] ---> [p:6^17] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((main:8^27 [c:7^15]:14^28) [p:6^17]:13^30)
//│ def [c:7^15]:14 = (fun x:21 -> case x:21^19 of {
//│ 	C a:22 => ([c:7^15]:14^20 a:22^21)})
//│ def [p:6^17]:13 = [C [p:6^17]:13^25]
//│ def c:7 = (fun x:9 -> case x:9^8 of {
//│ 	C a:10 => (c:7^9 a:10^10)})
//│ def main:8 = (fun cc:11 -> (fun pp:12 -> (cc:11^14 pp:12^15)))
//│ def p:6 = [C p:6^6]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 26: [C 25: [p:6^17]:13^25]
//│ [C [p:6^17]:13^25] --->
//│ 	case x:21^19 of {C a:22 => ([c:7^15]:14^20 a:22^21)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((main:8^32 [c:7^15]:14^33) [p:6^17]:13^35)
//│ def [c:7^15]:14 = (fun x:21 -> x:21^47)
//│ def [p:6^17]:13 = let a:22 = [p:6^17]:13^45
//│ in ([c:7^15]:14^42 a:22^43)
//│ def c:7 = (fun x:9 -> case x:9^51 of {
//│ 	C a:10 => (c:7^52 a:10^53)})
//│ def main:8 = (fun cc:11 -> (fun pp:12 -> (cc:11^37 pp:12^38)))
//│ def p:6 = [C p:6^49]
//│ <<<<<<< after fusion <<<<<<<


fun cons(y) = if y is
    C(aa) then cons(aa)
fun a(x) = b(x)
fun b(x) = c(x)
fun c(x) = d(cons, x)
fun d(cc, x) = cc(x)
let p = C(p)
a(p)
//│ |#fun| |cons|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |cons|(|aa|)|←|↵|#fun| |a|(|x|)| |#=| |b|(|x|)|↵|#fun| |b|(|x|)| |#=| |c|(|x|)|↵|#fun| |c|(|x|)| |#=| |d|(|cons|,| |x|)|↵|#fun| |d|(|cc|,| |x|)| |#=| |cc|(|x|)|↵|#let| |p| |#=| |C|(|p|)|↵|a|(|p|)|
//│ Parsed: {fun cons = y, => if y is ‹(C (aa,)) then cons (aa,)›; fun a = x, => b (x,); fun b = x, => c (x,); fun c = x, => d (cons, x,); fun d = cc, x, => cc (x,); let p = C (p,); a (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (a:7^28 p:11^29)
//│ def a:7 = (fun x:14 -> (b:8^7 x:14^8))
//│ def b:8 = (fun x:15 -> (c:9^11 x:15^12))
//│ def c:9 = (fun x:16 -> ((d:10^15 cons:6^16) x:16^18))
//│ def cons:6 = (fun y:12 -> case y:12^1 of {
//│ 	C aa:13 => (cons:6^2 aa:13^3)})
//│ def d:10 = (fun cc:17 -> (fun x:18 -> (cc:17^21 x:18^22)))
//│ def p:11 = [C p:11^26]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(5'p_11^26) <: 6'y
//│ 	[-p:11^26 · -p:11^26 · -p:11^29 · +a:7^28 · +b:8^7 · +c:9^11 · +d:10^15 · -d:10^15 · +cons:6^16 · +cons:6^2 · +cons:6^2]  --->  [-p:11^26 · -p:11^29 · +a:7^28 · +b:8^7 · +c:9^11 · +d:10^15 · -d:10^15 · +cons:6^16 · +cons:6^2]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [a:7^28 · b:8^7 · c:9^11 · cons:6^16 · cons:6^2 · cons:6^2] --> [a:7^28 · b:8^7 · c:9^11 · cons:6^16 · cons:6^2]
//│ [p:11^29 · p:11^26 · p:11^26] --> [p:11^29 · p:11^26]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [a:7^28]
//│ 	[a:7^28 · b:8^7]
//│ 		[a:7^28 · b:8^7 · c:9^11]
//│ 			[a:7^28 · b:8^7 · c:9^11 · d:10^15] ---> [d:10^15] (hopeless to continue)
//│ 			[a:7^28 · b:8^7 · c:9^11 · cons:6^16]
//│ 				[a:7^28 · b:8^7 · c:9^11 · cons:6^16 · cons:6^2]
//│ 					[a:7^28 · b:8^7 · c:9^11 · cons:6^16 · cons:6^2 · cons:6^2] ---> [a:7^28 · b:8^7 · c:9^11 · cons:6^16 · cons:6^2] (only one)
//│ [p:11^29]
//│ 	[p:11^29 · p:11^26]
//│ 		[p:11^29 · p:11^26 · p:11^26] ---> [p:11^29 · p:11^26] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([a:7^28]:21^61 [p:11^29]:19^62)
//│ def [a:7^28 · b:8^7 · c:9^11 · cons:6^16 · cons:6^2]:25 = (fun y:34 -> case y:34^41 of {
//│ 	C aa:35 => ([a:7^28 · b:8^7 · c:9^11 · cons:6^16 · cons:6^2]:25^42 aa:35^43)})
//│ def [a:7^28 · b:8^7 · c:9^11 · cons:6^16]:24 = (fun y:36 -> case y:36^49 of {
//│ 	C aa:37 => ([a:7^28 · b:8^7 · c:9^11 · cons:6^16 · cons:6^2]:25^50 aa:37^51)})
//│ def [a:7^28 · b:8^7 · c:9^11]:23 = (fun x:38 -> ((d:10^55 [a:7^28 · b:8^7 · c:9^11 · cons:6^16]:24^56) x:38^58))
//│ def [a:7^28 · b:8^7]:22 = (fun x:33 -> ([a:7^28 · b:8^7 · c:9^11]:23^37 x:33^38))
//│ def [a:7^28]:21 = (fun x:32 -> ([a:7^28 · b:8^7]:22^33 x:32^34))
//│ def [p:11^29 · p:11^26]:20 = [C [p:11^29 · p:11^26]:20^31]
//│ def [p:11^29]:19 = [C [p:11^29 · p:11^26]:20^47]
//│ def a:6 = (fun x:12 -> (b:8^4 x:12^5))
//│ def b:8 = (fun x:15 -> (c:9^14 x:15^15))
//│ def c:9 = (fun x:16 -> ((d:10^18 cons:7^19) x:16^21))
//│ def cons:7 = (fun y:13 -> case y:13^8 of {
//│ 	C aa:14 => (cons:7^9 aa:14^10)})
//│ def d:10 = (fun cc:17 -> (fun x:18 -> (cc:17^24 x:18^25)))
//│ def p:11 = [C p:11^29]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 32: [C 31: [p:11^29 · p:11^26]:20^31]
//│ [C [p:11^29 · p:11^26]:20^31] --->
//│ 	case y:34^41 of {C aa:35 => ([a:7^28 · b:8^7 · c:9^11 · cons:6^16 · cons:6^2]:25^42 aa:35^43)}
//│ 48: [C 47: [p:11^29 · p:11^26]:20^47]
//│ [C [p:11^29 · p:11^26]:20^47] --->
//│ 	case y:13^8 of {C aa:14 => (cons:7^9 aa:14^10)}
//│ 	case y:36^49 of {C aa:37 => ([a:7^28 · b:8^7 · c:9^11 · cons:6^16 · cons:6^2]:25^50 aa:37^51)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([a:7^28]:21^64 [p:11^29]:19^65)
//│ def [a:7^28 · b:8^7 · c:9^11 · cons:6^16 · cons:6^2]:25 = (fun y:34 -> y:34^78)
//│ def [a:7^28 · b:8^7 · c:9^11 · cons:6^16]:24 = (fun y:36 -> case y:36^72 of {
//│ 	C aa:37 => ([a:7^28 · b:8^7 · c:9^11 · cons:6^16 · cons:6^2]:25^73 aa:37^74)})
//│ def [a:7^28 · b:8^7 · c:9^11]:23 = (fun x:38 -> ((d:10^84 [a:7^28 · b:8^7 · c:9^11 · cons:6^16]:24^85) x:38^87))
//│ def [a:7^28 · b:8^7]:22 = (fun x:33 -> ([a:7^28 · b:8^7 · c:9^11]:23^109 x:33^110))
//│ def [a:7^28]:21 = (fun x:32 -> ([a:7^28 · b:8^7]:22^113 x:32^114))
//│ def [p:11^29 · p:11^26]:20 = let aa:35 = [p:11^29 · p:11^26]:20^93
//│ in ([a:7^28 · b:8^7 · c:9^11 · cons:6^16 · cons:6^2]:25^90 aa:35^91)
//│ def [p:11^29]:19 = let aa:14 = [p:11^29 · p:11^26]:20^70
//│ in (cons:7^67 aa:14^68)
//│ def a:6 = (fun x:12 -> (b:8^95 x:12^96))
//│ def b:8 = (fun x:15 -> (c:9^80 x:15^81))
//│ def c:9 = (fun x:16 -> ((d:10^99 cons:7^100) x:16^102))
//│ def cons:7 = (fun y:13 -> y:13^107)
//│ def d:10 = (fun cc:17 -> (fun x:18 -> (cc:17^117 x:18^118)))
//│ def p:11 = [C p:11^105]
//│ <<<<<<< after fusion <<<<<<<


let p = C(N)
fun c(x) = if C(x) is
    C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|N|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (N,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c:7^10 p:6^11)
//│ def c:7 = (fun x:8 -> case [C x:8^3] of {
//│ 	C a:9 => (c:7^5 a:9^6)})
//│ def p:6 = [C [N]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c:7^10] ---> [c:7^10] (hopeless to continue)
//│ [p:6^11] ---> [p:6^11] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c:7^13 p:6^14)
//│ def c:7 = (fun x:8 -> case [C x:8^6] of {
//│ 	C a:9 => (c:7^8 a:9^9)})
//│ def p:6 = [C [N]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 7: [C 6: x:8^6]
//│ [C x:8^6] --->
//│ 	case [C x:8^6] of {C a:9 => (c:7^8 a:9^9)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c:7^16 p:6^17)
//│ def c:7 = (fun x:8 -> let a:9 = x:8^24
//│ in (c:7^21 a:9^22))
//│ def p:6 = [C [N]]
//│ <<<<<<< after fusion <<<<<<<


// let rec p = C(p)
// let q = p
// fun c(x) = if x is
//     C(a) then a
// fun c2(z) = if z is
//     C(b) then c2(b)
// let main = c(q)
// c2(main)


let rec p = C(p)
fun c(x) = if x is
    C(a) then a
fun c1(xx) = if xx is
    C(aa) then aa
fun c2(z) = if z is
    C(b) then c2(b)
let main = c(p)
fun id(y) = c1(C(y))
c2(id(main))
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |a|←|↵|#fun| |c1|(|xx|)| |#=| |#if| |xx| |is|→|C|(|aa|)| |#then| |aa|←|↵|#fun| |c2|(|z|)| |#=| |#if| |z| |is|→|C|(|b|)| |#then| |c2|(|b|)|←|↵|#let| |main| |#=| |c|(|p|)|↵|#fun| |id|(|y|)| |#=| |c1|(|C|(|y|)|)|↵|c2|(|id|(|main|)|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then a›; fun c1 = xx, => if xx is ‹(C (aa,)) then aa›; fun c2 = z, => if z is ‹(C (b,)) then c2 (b,)›; let main = c (p,); fun id = y, => c1 (C (y,),); c2 (id (main,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c2:9^25 (id:11^26 main:10^27))
//│ def c:7 = (fun x:12 -> case x:12^3 of {
//│ 	C a:13 => a:13^4})
//│ def c1:8 = (fun xx:14 -> case xx:14^7 of {
//│ 	C aa:15 => aa:15^8})
//│ def c2:9 = (fun z:16 -> case z:16^11 of {
//│ 	C b:17 => (c2:9^12 b:17^13)})
//│ def id:11 = (fun y:18 -> (c1:8^20 [C y:18^21]))
//│ def main:10 = (c:7^17 p:6^18)
//│ def p:6 = [C p:6^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(0'p_6^1) <: 12'z
//│ 	[-p:6^1 · -p:6^1 · -p:6^18 · +c:7^17 · -c:7^17 · -main:10^27 · +id:11^26 · +c1:8^20 · -c1:8^20 · -id:11^26 · +c2:9^25 · +c2:9^12]  --->  [-p:6^1 · -p:6^18 · +c:7^17 · -c:7^17 · -main:10^27 · +id:11^26 · +c1:8^20 · -c1:8^20 · -id:11^26 · +c2:9^25]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c2:9^25 · c2:9^12] --> [c2:9^25]
//│ [main:10^27 · p:6^18 · p:6^1 · p:6^1] --> [main:10^27 · p:6^18 · p:6^1]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c2:9^25]
//│ 	[c2:9^25 · c2:9^12] ---> [c2:9^25] (only one)
//│ [id:11^26] ---> [id:11^26] (hopeless to continue)
//│ [main:10^27]
//│ 	[main:10^27 · p:6^18]
//│ 		[main:10^27 · p:6^18 · p:6^1]
//│ 			[main:10^27 · p:6^18 · p:6^1 · p:6^1] ---> [main:10^27 · p:6^18 · p:6^1] (only one)
//│ 	[main:10^27 · c:7^17] ---> [c:7^17] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([c2:9^25]:19^43 (id:6^44 [main:10^27]:20^45))
//│ def [c2:9^25]:19 = (fun z:29 -> case z:29^30 of {
//│ 	C b:30 => ([c2:9^25]:19^31 b:30^32)})
//│ def [main:10^27 · p:6^18 · p:6^1]:22 = [C [main:10^27 · p:6^18 · p:6^1]:22^36]
//│ def [main:10^27 · p:6^18]:21 = [C [main:10^27 · p:6^18 · p:6^1]:22^41]
//│ def [main:10^27]:20 = (c:11^38 [main:10^27 · p:6^18]:21^39)
//│ def c:11 = (fun x:17 -> case x:17^26 of {
//│ 	C a:18 => a:18^27})
//│ def c1:7 = (fun xx:13 -> case xx:13^11 of {
//│ 	C aa:14 => aa:14^12})
//│ def c2:9 = (fun z:15 -> case z:15^18 of {
//│ 	C b:16 => (c2:9^19 b:16^20)})
//│ def id:6 = (fun y:12 -> (c1:7^6 [C y:12^7]))
//│ def main:8 = (c:11^15 p:10^16)
//│ def p:10 = [C p:10^24]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 25: [C 24: p:10^24]
//│ [C p:10^24] --->
//│ 	case x:17^26 of {C a:18 => a:18^27}
//│ 	case z:29^30 of {C b:30 => ([c2:9^25]:19^31 b:30^32)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 37: [C 36: [main:10^27 · p:6^18 · p:6^1]:22^36]
//│ [C [main:10^27 · p:6^18 · p:6^1]:22^36] --->
//│ 	case z:29^30 of {C b:30 => ([c2:9^25]:19^31 b:30^32)}
//│ 42: [C 41: [main:10^27 · p:6^18 · p:6^1]:22^41]
//│ [C [main:10^27 · p:6^18 · p:6^1]:22^41] --->
//│ 	case x:17^26 of {C a:18 => a:18^27}
//│ 8: [C 7: y:12^7]
//│ [C y:12^7] --->
//│ 	case xx:13^11 of {C aa:14 => aa:14^12}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([c2:9^25]:19^48 (id:6^49 [main:10^27]:20^50))
//│ def [c2:9^25]:19 = (fun z:29 -> z:29^59)
//│ def [main:10^27 · p:6^18 · p:6^1]:22 = let b:30 = [main:10^27 · p:6^18 · p:6^1]:22^64
//│ in ([c2:9^25]:19^61 b:30^62)
//│ def [main:10^27 · p:6^18]:21 = let a:18 = [main:10^27 · p:6^18 · p:6^1]:22^67
//│ in a:18^66
//│ def [main:10^27]:20 = (c:11^82 [main:10^27 · p:6^18]:21^83)
//│ def c:11 = (fun x:17 -> x:17^77)
//│ def c1:7 = (fun xx:13 -> xx:13^75)
//│ def c2:9 = (fun z:15 -> case z:15^69 of {
//│ 	C b:16 => (c2:9^70 b:16^71)})
//│ def id:6 = (fun y:12 -> (c1:7^53 let aa:14 = y:12^55
//│ in aa:14^54))
//│ def main:8 = (c:11^85 p:10^86)
//│ def p:10 = let a:18 = p:10^80
//│ in a:18^79
//│ <<<<<<< after fusion <<<<<<<


let t = T(K, T(N, L, L), T(N, L, L))
fun c(x) = if x is
    T(n, l, r) then T(
        (if n is
            K then KK
            N then NN
        ),
        c(l),
        c(r)
    )
    L then LL
c(t)
//│ |#let| |t| |#=| |T|(|K|,| |T|(|N|,| |L|,| |L|)|,| |T|(|N|,| |L|,| |L|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let t = T (K, T (N, L, L,), T (N, L, L,),); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c:7^26 t:6^27)
//│ def c:7 = (fun x:8 -> case x:8^11 of {
//│ 	T n:9 l:10 r:11 => [T case n:9^12 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c:7^16 l:10^17) (c:7^19 r:11^20)]
//│ 	| L => [LL]})
//│ def t:6 = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 2'x
//│ 	[-t:6^27 · +c:7^26 · +c:7^16 · +c:7^16 · +c:7^16 · +c:7^19]  --->  [-t:6^27 · +c:7^26 · +c:7^16 · +c:7^16 · +c:7^16]
//│ 	[-t:6^27 · +c:7^26 · +c:7^16 · +c:7^16 · +c:7^19 · +c:7^16]  --->  [-t:6^27 · +c:7^26 · +c:7^16 · +c:7^16 · +c:7^19]
//│ 	[-t:6^27 · +c:7^26 · +c:7^16 · +c:7^19 · +c:7^16 · +c:7^19]  --->  [-t:6^27 · +c:7^26 · +c:7^16 · +c:7^19 · +c:7^16]
//│ 	[-t:6^27 · +c:7^26 · +c:7^16 · +c:7^19 · +c:7^19 · +c:7^16]  --->  [-t:6^27 · +c:7^26 · +c:7^16 · +c:7^19 · +c:7^19]
//│ 	[-t:6^27 · +c:7^26 · +c:7^19 · +c:7^16 · +c:7^16 · +c:7^19]  --->  [-t:6^27 · +c:7^26 · +c:7^19 · +c:7^16 · +c:7^16]
//│ 	[-t:6^27 · +c:7^26 · +c:7^19 · +c:7^16 · +c:7^19 · +c:7^16]  --->  [-t:6^27 · +c:7^26 · +c:7^19 · +c:7^16 · +c:7^19]
//│ 	[-t:6^27 · +c:7^26 · +c:7^19 · +c:7^19 · +c:7^16 · +c:7^19]  --->  [-t:6^27 · +c:7^26 · +c:7^19 · +c:7^19 · +c:7^16]
//│ 	[-t:6^27 · +c:7^26 · +c:7^19 · +c:7^19 · +c:7^19 · +c:7^16]  --->  [-t:6^27 · +c:7^26 · +c:7^19 · +c:7^19 · +c:7^19]
//│ NoProd <: 4'l
//│ 	[-t:6^27 · +c:7^26 · +c:7^16 · +c:7^16 · +c:7^16]  --->  [-t:6^27 · +c:7^26 · +c:7^16 · +c:7^16]
//│ 	[-t:6^27 · +c:7^26 · +c:7^16 · +c:7^19 · +c:7^16]  --->  [-t:6^27 · +c:7^26 · +c:7^16 · +c:7^19]
//│ 	[-t:6^27 · +c:7^26 · +c:7^19 · +c:7^16 · +c:7^16]  --->  [-t:6^27 · +c:7^26 · +c:7^19 · +c:7^16]
//│ 	[-t:6^27 · +c:7^26 · +c:7^19 · +c:7^19 · +c:7^16]  --->  [-t:6^27 · +c:7^26 · +c:7^19 · +c:7^19]
//│ NoProd <: 5'r
//│ 	[-t:6^27 · +c:7^26 · +c:7^16 · +c:7^16 · +c:7^19]  --->  [-t:6^27 · +c:7^26 · +c:7^16 · +c:7^16]
//│ 	[-t:6^27 · +c:7^26 · +c:7^16 · +c:7^19 · +c:7^19]  --->  [-t:6^27 · +c:7^26 · +c:7^16 · +c:7^19]
//│ 	[-t:6^27 · +c:7^26 · +c:7^19 · +c:7^16 · +c:7^19]  --->  [-t:6^27 · +c:7^26 · +c:7^19 · +c:7^16]
//│ 	[-t:6^27 · +c:7^26 · +c:7^19 · +c:7^19 · +c:7^19]  --->  [-t:6^27 · +c:7^26 · +c:7^19 · +c:7^19]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c:7^26 · c:7^16 · c:7^16 · c:7^16 · c:7^19] --> [c:7^26 · c:7^16 · c:7^16 · c:7^16]
//│ [c:7^26 · c:7^16 · c:7^16 · c:7^16] --> [c:7^26 · c:7^16 · c:7^16]
//│ [c:7^26 · c:7^16 · c:7^16 · c:7^19 · c:7^16] --> [c:7^26 · c:7^16 · c:7^16 · c:7^19]
//│ [c:7^26 · c:7^16 · c:7^16 · c:7^19] --> [c:7^26 · c:7^16 · c:7^16]
//│ [c:7^26 · c:7^16 · c:7^19 · c:7^16 · c:7^19] --> [c:7^26 · c:7^16 · c:7^19 · c:7^16]
//│ [c:7^26 · c:7^16 · c:7^19 · c:7^16] --> [c:7^26 · c:7^16 · c:7^19]
//│ [c:7^26 · c:7^16 · c:7^19 · c:7^19 · c:7^16] --> [c:7^26 · c:7^16 · c:7^19 · c:7^19]
//│ [c:7^26 · c:7^16 · c:7^19 · c:7^19] --> [c:7^26 · c:7^16 · c:7^19]
//│ [c:7^26 · c:7^19 · c:7^16 · c:7^16 · c:7^19] --> [c:7^26 · c:7^19 · c:7^16 · c:7^16]
//│ [c:7^26 · c:7^19 · c:7^16 · c:7^16] --> [c:7^26 · c:7^19 · c:7^16]
//│ [c:7^26 · c:7^19 · c:7^16 · c:7^19 · c:7^16] --> [c:7^26 · c:7^19 · c:7^16 · c:7^19]
//│ [c:7^26 · c:7^19 · c:7^16 · c:7^19] --> [c:7^26 · c:7^19 · c:7^16]
//│ [c:7^26 · c:7^19 · c:7^19 · c:7^16 · c:7^19] --> [c:7^26 · c:7^19 · c:7^19 · c:7^16]
//│ [c:7^26 · c:7^19 · c:7^19 · c:7^16] --> [c:7^26 · c:7^19 · c:7^19]
//│ [c:7^26 · c:7^19 · c:7^19 · c:7^19 · c:7^16] --> [c:7^26 · c:7^19 · c:7^19 · c:7^19]
//│ [c:7^26 · c:7^19 · c:7^19 · c:7^19] --> [c:7^26 · c:7^19 · c:7^19]
//│ [t:6^27] --> [t:6^27]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c:7^26]
//│ 	[c:7^26 · c:7^16]
//│ 		[c:7^26 · c:7^16 · c:7^16]
//│ 			[c:7^26 · c:7^16 · c:7^16 · c:7^16] ---> [c:7^26 · c:7^16 · c:7^16] (only one)
//│ 			[c:7^26 · c:7^16 · c:7^16 · c:7^19] ---> [c:7^26 · c:7^16 · c:7^16] (only one)
//│ 		[c:7^26 · c:7^16 · c:7^19]
//│ 			[c:7^26 · c:7^16 · c:7^19 · c:7^16] ---> [c:7^26 · c:7^16 · c:7^19] (only one)
//│ 			[c:7^26 · c:7^16 · c:7^19 · c:7^19] ---> [c:7^26 · c:7^16 · c:7^19] (only one)
//│ 	[c:7^26 · c:7^19]
//│ 		[c:7^26 · c:7^19 · c:7^16]
//│ 			[c:7^26 · c:7^19 · c:7^16 · c:7^16] ---> [c:7^26 · c:7^19 · c:7^16] (only one)
//│ 			[c:7^26 · c:7^19 · c:7^16 · c:7^19] ---> [c:7^26 · c:7^19 · c:7^16] (only one)
//│ 		[c:7^26 · c:7^19 · c:7^19]
//│ 			[c:7^26 · c:7^19 · c:7^19 · c:7^16] ---> [c:7^26 · c:7^19 · c:7^19] (only one)
//│ 			[c:7^26 · c:7^19 · c:7^19 · c:7^19] ---> [c:7^26 · c:7^19 · c:7^19] (only one)
//│ [t:6^27]
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([c:7^26]:12^144 [t:6^27]:19^145)
//│ def [c:7^26 · c:7^16 · c:7^16]:14 = (fun x:50 -> case x:50^129 of {
//│ 	T n:51 l:52 r:53 => [T case n:51^130 of {
//│ 		K => [KK]
//│ 		| N => [NN]} ([c:7^26 · c:7^16 · c:7^16]:14^134 l:52^135) ([c:7^26 · c:7^16 · c:7^16]:14^137 r:53^138)]
//│ 	| L => [LL]})
//│ def [c:7^26 · c:7^16 · c:7^19]:15 = (fun x:30 -> case x:30^54 of {
//│ 	T n:31 l:32 r:33 => [T case n:31^55 of {
//│ 		K => [KK]
//│ 		| N => [NN]} ([c:7^26 · c:7^16 · c:7^19]:15^59 l:32^60) ([c:7^26 · c:7^16 · c:7^19]:15^62 r:33^63)]
//│ 	| L => [LL]})
//│ def [c:7^26 · c:7^16]:13 = (fun x:46 -> case x:46^114 of {
//│ 	T n:47 l:48 r:49 => [T case n:47^115 of {
//│ 		K => [KK]
//│ 		| N => [NN]} ([c:7^26 · c:7^16 · c:7^16]:14^119 l:48^120) ([c:7^26 · c:7^16 · c:7^19]:15^122 r:49^123)]
//│ 	| L => [LL]})
//│ def [c:7^26 · c:7^19 · c:7^16]:17 = (fun x:34 -> case x:34^69 of {
//│ 	T n:35 l:36 r:37 => [T case n:35^70 of {
//│ 		K => [KK]
//│ 		| N => [NN]} ([c:7^26 · c:7^19 · c:7^16]:17^74 l:36^75) ([c:7^26 · c:7^19 · c:7^16]:17^77 r:37^78)]
//│ 	| L => [LL]})
//│ def [c:7^26 · c:7^19 · c:7^19]:18 = (fun x:42 -> case x:42^99 of {
//│ 	T n:43 l:44 r:45 => [T case n:43^100 of {
//│ 		K => [KK]
//│ 		| N => [NN]} ([c:7^26 · c:7^19 · c:7^19]:18^104 l:44^105) ([c:7^26 · c:7^19 · c:7^19]:18^107 r:45^108)]
//│ 	| L => [LL]})
//│ def [c:7^26 · c:7^19]:16 = (fun x:26 -> case x:26^39 of {
//│ 	T n:27 l:28 r:29 => [T case n:27^40 of {
//│ 		K => [KK]
//│ 		| N => [NN]} ([c:7^26 · c:7^19 · c:7^16]:17^44 l:28^45) ([c:7^26 · c:7^19 · c:7^19]:18^47 r:29^48)]
//│ 	| L => [LL]})
//│ def [c:7^26]:12 = (fun x:38 -> case x:38^84 of {
//│ 	T n:39 l:40 r:41 => [T case n:39^85 of {
//│ 		K => [KK]
//│ 		| N => [NN]} ([c:7^26 · c:7^16]:13^89 l:40^90) ([c:7^26 · c:7^19]:16^92 r:41^93)]
//│ 	| L => [LL]})
//│ def [t:6^27]:19 = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ def c:7 = (fun x:8 -> case x:8^14 of {
//│ 	T n:9 l:10 r:11 => [T case n:9^15 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c:7^19 l:10^20) (c:7^22 r:11^23)]
//│ 	| L => [LL]})
//│ def t:6 = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 29: [K]
//│ [K] --->
//│ 	case n:39^85 of {K => [KK] | N => [NN]}
//│ 30: [N]
//│ [N] --->
//│ 	case n:47^115 of {K => [KK] | N => [NN]}
//│ 31: [L]
//│ [L] --->
//│ 	case x:50^129 of {T n:51 l:52 r:53 => [T case n:51^130 of {K => [KK] | N => [NN]} ([c:7^26 · c:7^16 · c:7^16]:14^134 l:52^135) ([c:7^26 · c:7^16 · c:7^16]:14^137 r:53^138)] | L => [LL]}
//│ 32: [L]
//│ [L] --->
//│ 	case x:30^54 of {T n:31 l:32 r:33 => [T case n:31^55 of {K => [KK] | N => [NN]} ([c:7^26 · c:7^16 · c:7^19]:15^59 l:32^60) ([c:7^26 · c:7^16 · c:7^19]:15^62 r:33^63)] | L => [LL]}
//│ 33: [T 30: [N] 31: [L] 32: [L]]
//│ [T [N] [L] [L]] --->
//│ 	case x:46^114 of {T n:47 l:48 r:49 => [T case n:47^115 of {K => [KK] | N => [NN]} ([c:7^26 · c:7^16 · c:7^16]:14^119 l:48^120) ([c:7^26 · c:7^16 · c:7^19]:15^122 r:49^123)] | L => [LL]}
//│ 34: [N]
//│ [N] --->
//│ 	case n:27^40 of {K => [KK] | N => [NN]}
//│ 35: [L]
//│ [L] --->
//│ 	case x:34^69 of {T n:35 l:36 r:37 => [T case n:35^70 of {K => [KK] | N => [NN]} ([c:7^26 · c:7^19 · c:7^16]:17^74 l:36^75) ([c:7^26 · c:7^19 · c:7^16]:17^77 r:37^78)] | L => [LL]}
//│ 36: [L]
//│ [L] --->
//│ 	case x:42^99 of {T n:43 l:44 r:45 => [T case n:43^100 of {K => [KK] | N => [NN]} ([c:7^26 · c:7^19 · c:7^19]:18^104 l:44^105) ([c:7^26 · c:7^19 · c:7^19]:18^107 r:45^108)] | L => [LL]}
//│ 37: [T 34: [N] 35: [L] 36: [L]]
//│ [T [N] [L] [L]] --->
//│ 	case x:26^39 of {T n:27 l:28 r:29 => [T case n:27^40 of {K => [KK] | N => [NN]} ([c:7^26 · c:7^19 · c:7^16]:17^44 l:28^45) ([c:7^26 · c:7^19 · c:7^19]:18^47 r:29^48)] | L => [LL]}
//│ 38: [T 29: [K] 33: [T 30: [N] 31: [L] 32: [L]] 37: [T 34: [N] 35: [L] 36: [L]]]
//│ [T [K] [T [N] [L] [L]] [T [N] [L] [L]]] --->
//│ 	case x:38^84 of {T n:39 l:40 r:41 => [T case n:39^85 of {K => [KK] | N => [NN]} ([c:7^26 · c:7^16]:13^89 l:40^90) ([c:7^26 · c:7^19]:16^92 r:41^93)] | L => [LL]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([c:7^26]:12^147 [t:6^27]:19^148)
//│ def [c:7^26 · c:7^16 · c:7^16]:14 = (fun x:50 -> x:50^152)
//│ def [c:7^26 · c:7^16 · c:7^19]:15 = (fun x:30 -> x:30^227)
//│ def [c:7^26 · c:7^16]:13 = (fun x:46 -> x:46^225)
//│ def [c:7^26 · c:7^19 · c:7^16]:17 = (fun x:34 -> x:34^150)
//│ def [c:7^26 · c:7^19 · c:7^19]:18 = (fun x:42 -> x:42^154)
//│ def [c:7^26 · c:7^19]:16 = (fun x:26 -> x:26^156)
//│ def [c:7^26]:12 = (fun x:38 -> x:38^208)
//│ def [t:6^27]:19 = let n:39 = [KK]
//│ in let l:40 = 
//│ 	let n:47 = [NN]
//│ 	in let l:48 = [LL]
//│ 	in let r:49 = [LL]
//│ 	in [T n:47^191 ([c:7^26 · c:7^16 · c:7^16]:14^192 l:48^193) ([c:7^26 · c:7^16 · c:7^19]:15^195 r:49^196)]
//│ in let r:41 = 
//│ 	let n:27 = [NN]
//│ 	in let l:28 = [LL]
//│ 	in let r:29 = [LL]
//│ 	in [T n:27^176 ([c:7^26 · c:7^19 · c:7^16]:17^177 l:28^178) ([c:7^26 · c:7^19 · c:7^19]:18^180 r:29^181)]
//│ in [T n:39^168 ([c:7^26 · c:7^16]:13^169 l:40^170) ([c:7^26 · c:7^19]:16^172 r:41^173)]
//│ def c:7 = (fun x:8 -> case x:8^210 of {
//│ 	T n:9 l:10 r:11 => [T case n:9^211 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c:7^215 l:10^216) (c:7^218 r:11^219)]
//│ 	| L => [LL]})
//│ def t:6 = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ <<<<<<< after fusion <<<<<<<


let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
    T(n, l, r) then T(
        (if n is
            K then KK
            N then NN
        ),
        c(l),
        c(r)
    )
    L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c:9^28 t:8^29)
//│ def aa:6 = [T [N] [L] [L]]
//│ def bb:7 = [T [N] [L] [L]]
//│ def c:9 = (fun x:10 -> case x:10^13 of {
//│ 	T n:11 l:12 r:13 => [T case n:11^14 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c:9^18 l:12^19) (c:9^21 r:13^22)]
//│ 	| L => [LL]})
//│ def t:8 = [T [K] aa:6^10 bb:7^11]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 7'r
//│ 	[-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^18 · +c:9^21]  --->  [-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^18]
//│ 	[-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^21 · +c:9^21]  --->  [-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^21]
//│ 	[-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^18 · +c:9^21]  --->  [-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^18]
//│ 	[-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^21 · +c:9^21]  --->  [-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^21]
//│ NoProd <: 6'l
//│ 	[-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^18 · +c:9^18]  --->  [-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^18]
//│ 	[-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^21 · +c:9^18]  --->  [-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^21]
//│ 	[-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^18 · +c:9^18]  --->  [-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^18]
//│ 	[-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^21 · +c:9^18]  --->  [-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^21]
//│ NoProd <: 4'x
//│ 	[-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^18 · +c:9^18 · +c:9^21]  --->  [-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^18 · +c:9^18]
//│ 	[-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^18 · +c:9^21 · +c:9^18]  --->  [-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^18 · +c:9^21]
//│ 	[-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^21 · +c:9^18 · +c:9^21]  --->  [-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^21 · +c:9^18]
//│ 	[-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^21 · +c:9^21 · +c:9^18]  --->  [-aa:6^10 · -t:8^29 · +c:9^28 · +c:9^18 · +c:9^21 · +c:9^21]
//│ 	[-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^18 · +c:9^18 · +c:9^21]  --->  [-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^18 · +c:9^18]
//│ 	[-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^18 · +c:9^21 · +c:9^18]  --->  [-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^18 · +c:9^21]
//│ 	[-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^21 · +c:9^18 · +c:9^21]  --->  [-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^21 · +c:9^18]
//│ 	[-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^21 · +c:9^21 · +c:9^18]  --->  [-bb:7^11 · -t:8^29 · +c:9^28 · +c:9^21 · +c:9^21 · +c:9^21]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c:9^28 · c:9^18 · c:9^18 · c:9^18 · c:9^21] --> [c:9^28 · c:9^18 · c:9^18 · c:9^18]
//│ [c:9^28 · c:9^18 · c:9^18 · c:9^18] --> [c:9^28 · c:9^18 · c:9^18]
//│ [c:9^28 · c:9^18 · c:9^18 · c:9^21 · c:9^18] --> [c:9^28 · c:9^18 · c:9^18 · c:9^21]
//│ [c:9^28 · c:9^18 · c:9^18 · c:9^21] --> [c:9^28 · c:9^18 · c:9^18]
//│ [c:9^28 · c:9^18 · c:9^21 · c:9^18 · c:9^21] --> [c:9^28 · c:9^18 · c:9^21 · c:9^18]
//│ [c:9^28 · c:9^18 · c:9^21 · c:9^18] --> [c:9^28 · c:9^18 · c:9^21]
//│ [c:9^28 · c:9^18 · c:9^21 · c:9^21 · c:9^18] --> [c:9^28 · c:9^18 · c:9^21 · c:9^21]
//│ [c:9^28 · c:9^18 · c:9^21 · c:9^21] --> [c:9^28 · c:9^18 · c:9^21]
//│ [c:9^28 · c:9^21 · c:9^18 · c:9^18 · c:9^21] --> [c:9^28 · c:9^21 · c:9^18 · c:9^18]
//│ [c:9^28 · c:9^21 · c:9^18 · c:9^18] --> [c:9^28 · c:9^21 · c:9^18]
//│ [c:9^28 · c:9^21 · c:9^18 · c:9^21 · c:9^18] --> [c:9^28 · c:9^21 · c:9^18 · c:9^21]
//│ [c:9^28 · c:9^21 · c:9^18 · c:9^21] --> [c:9^28 · c:9^21 · c:9^18]
//│ [c:9^28 · c:9^21 · c:9^21 · c:9^18 · c:9^21] --> [c:9^28 · c:9^21 · c:9^21 · c:9^18]
//│ [c:9^28 · c:9^21 · c:9^21 · c:9^18] --> [c:9^28 · c:9^21 · c:9^21]
//│ [c:9^28 · c:9^21 · c:9^21 · c:9^21 · c:9^18] --> [c:9^28 · c:9^21 · c:9^21 · c:9^21]
//│ [c:9^28 · c:9^21 · c:9^21 · c:9^21] --> [c:9^28 · c:9^21 · c:9^21]
//│ [t:8^29 · aa:6^10] --> [t:8^29 · aa:6^10]
//│ [t:8^29 · bb:7^11] --> [t:8^29 · bb:7^11]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c:9^28]
//│ 	[c:9^28 · c:9^18]
//│ 		[c:9^28 · c:9^18 · c:9^18]
//│ 			[c:9^28 · c:9^18 · c:9^18 · c:9^18] ---> [c:9^28 · c:9^18 · c:9^18] (only one)
//│ 			[c:9^28 · c:9^18 · c:9^18 · c:9^21] ---> [c:9^28 · c:9^18 · c:9^18] (only one)
//│ 		[c:9^28 · c:9^18 · c:9^21]
//│ 			[c:9^28 · c:9^18 · c:9^21 · c:9^18] ---> [c:9^28 · c:9^18 · c:9^21] (only one)
//│ 			[c:9^28 · c:9^18 · c:9^21 · c:9^21] ---> [c:9^28 · c:9^18 · c:9^21] (only one)
//│ 	[c:9^28 · c:9^21]
//│ 		[c:9^28 · c:9^21 · c:9^18]
//│ 			[c:9^28 · c:9^21 · c:9^18 · c:9^18] ---> [c:9^28 · c:9^21 · c:9^18] (only one)
//│ 			[c:9^28 · c:9^21 · c:9^18 · c:9^21] ---> [c:9^28 · c:9^21 · c:9^18] (only one)
//│ 		[c:9^28 · c:9^21 · c:9^21]
//│ 			[c:9^28 · c:9^21 · c:9^21 · c:9^18] ---> [c:9^28 · c:9^21 · c:9^21] (only one)
//│ 			[c:9^28 · c:9^21 · c:9^21 · c:9^21] ---> [c:9^28 · c:9^21 · c:9^21] (only one)
//│ [t:8^29]
//│ 	[t:8^29 · aa:6^10]
//│ 
//│ 	[t:8^29 · bb:7^11]
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([c:9^28]:14^148 [t:8^29]:21^149)
//│ def [c:9^28 · c:9^18 · c:9^18]:16 = (fun x:30 -> case x:30^39 of {
//│ 	T n:31 l:32 r:33 => [T case n:31^40 of {
//│ 		K => [KK]
//│ 		| N => [NN]} ([c:9^28 · c:9^18 · c:9^18]:16^44 l:32^45) ([c:9^28 · c:9^18 · c:9^18]:16^47 r:33^48)]
//│ 	| L => [LL]})
//│ def [c:9^28 · c:9^18 · c:9^21]:17 = (fun x:54 -> case x:54^133 of {
//│ 	T n:55 l:56 r:57 => [T case n:55^134 of {
//│ 		K => [KK]
//│ 		| N => [NN]} ([c:9^28 · c:9^18 · c:9^21]:17^138 l:56^139) ([c:9^28 · c:9^18 · c:9^21]:17^141 r:57^142)]
//│ 	| L => [LL]})
//│ def [c:9^28 · c:9^18]:15 = (fun x:42 -> case x:42^88 of {
//│ 	T n:43 l:44 r:45 => [T case n:43^89 of {
//│ 		K => [KK]
//│ 		| N => [NN]} ([c:9^28 · c:9^18 · c:9^18]:16^93 l:44^94) ([c:9^28 · c:9^18 · c:9^21]:17^96 r:45^97)]
//│ 	| L => [LL]})
//│ def [c:9^28 · c:9^21 · c:9^18]:19 = (fun x:38 -> case x:38^69 of {
//│ 	T n:39 l:40 r:41 => [T case n:39^70 of {
//│ 		K => [KK]
//│ 		| N => [NN]} ([c:9^28 · c:9^21 · c:9^18]:19^74 l:40^75) ([c:9^28 · c:9^21 · c:9^18]:19^77 r:41^78)]
//│ 	| L => [LL]})
//│ def [c:9^28 · c:9^21 · c:9^21]:20 = (fun x:50 -> case x:50^118 of {
//│ 	T n:51 l:52 r:53 => [T case n:51^119 of {
//│ 		K => [KK]
//│ 		| N => [NN]} ([c:9^28 · c:9^21 · c:9^21]:20^123 l:52^124) ([c:9^28 · c:9^21 · c:9^21]:20^126 r:53^127)]
//│ 	| L => [LL]})
//│ def [c:9^28 · c:9^21]:18 = (fun x:46 -> case x:46^103 of {
//│ 	T n:47 l:48 r:49 => [T case n:47^104 of {
//│ 		K => [KK]
//│ 		| N => [NN]} ([c:9^28 · c:9^21 · c:9^18]:19^108 l:48^109) ([c:9^28 · c:9^21 · c:9^21]:20^111 r:49^112)]
//│ 	| L => [LL]})
//│ def [c:9^28]:14 = (fun x:34 -> case x:34^54 of {
//│ 	T n:35 l:36 r:37 => [T case n:35^55 of {
//│ 		K => [KK]
//│ 		| N => [NN]} ([c:9^28 · c:9^18]:15^59 l:36^60) ([c:9^28 · c:9^21]:18^62 r:37^63)]
//│ 	| L => [LL]})
//│ def [t:8^29 · aa:6^10]:22 = [T [N] [L] [L]]
//│ def [t:8^29 · bb:7^11]:23 = [T [N] [L] [L]]
//│ def [t:8^29]:21 = [T [K] [t:8^29 · aa:6^10]:22^32 [t:8^29 · bb:7^11]:23^33]
//│ def aa:6 = [T [N] [L] [L]]
//│ def bb:7 = [T [N] [L] [L]]
//│ def c:9 = (fun x:10 -> case x:10^16 of {
//│ 	T n:11 l:12 r:13 => [T case n:11^17 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c:9^21 l:12^22) (c:9^24 r:13^25)]
//│ 	| L => [LL]})
//│ def t:8 = [T [K] aa:6^13 bb:7^14]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 31: [K]
//│ [K] --->
//│ 	case n:35^55 of {K => [KK] | N => [NN]}
//│ 34: [T 31: [K] 32: [t:8^29 · aa:6^10]:22^32 33: [t:8^29 · bb:7^11]:23^33]
//│ [T [K] [t:8^29 · aa:6^10]:22^32 [t:8^29 · bb:7^11]:23^33] --->
//│ 	case x:34^54 of {T n:35 l:36 r:37 => [T case n:35^55 of {K => [KK] | N => [NN]} ([c:9^28 · c:9^18]:15^59 l:36^60) ([c:9^28 · c:9^21]:18^62 r:37^63)] | L => [LL]}
//│ 35: [N]
//│ [N] --->
//│ 	case n:43^89 of {K => [KK] | N => [NN]}
//│ 36: [L]
//│ [L] --->
//│ 	case x:30^39 of {T n:31 l:32 r:33 => [T case n:31^40 of {K => [KK] | N => [NN]} ([c:9^28 · c:9^18 · c:9^18]:16^44 l:32^45) ([c:9^28 · c:9^18 · c:9^18]:16^47 r:33^48)] | L => [LL]}
//│ 37: [L]
//│ [L] --->
//│ 	case x:54^133 of {T n:55 l:56 r:57 => [T case n:55^134 of {K => [KK] | N => [NN]} ([c:9^28 · c:9^18 · c:9^21]:17^138 l:56^139) ([c:9^28 · c:9^18 · c:9^21]:17^141 r:57^142)] | L => [LL]}
//│ 38: [T 35: [N] 36: [L] 37: [L]]
//│ [T [N] [L] [L]] --->
//│ 	case x:42^88 of {T n:43 l:44 r:45 => [T case n:43^89 of {K => [KK] | N => [NN]} ([c:9^28 · c:9^18 · c:9^18]:16^93 l:44^94) ([c:9^28 · c:9^18 · c:9^21]:17^96 r:45^97)] | L => [LL]}
//│ 84: [N]
//│ [N] --->
//│ 	case n:47^104 of {K => [KK] | N => [NN]}
//│ 85: [L]
//│ [L] --->
//│ 	case x:38^69 of {T n:39 l:40 r:41 => [T case n:39^70 of {K => [KK] | N => [NN]} ([c:9^28 · c:9^21 · c:9^18]:19^74 l:40^75) ([c:9^28 · c:9^21 · c:9^18]:19^77 r:41^78)] | L => [LL]}
//│ 86: [L]
//│ [L] --->
//│ 	case x:50^118 of {T n:51 l:52 r:53 => [T case n:51^119 of {K => [KK] | N => [NN]} ([c:9^28 · c:9^21 · c:9^21]:20^123 l:52^124) ([c:9^28 · c:9^21 · c:9^21]:20^126 r:53^127)] | L => [LL]}
//│ 87: [T 84: [N] 85: [L] 86: [L]]
//│ [T [N] [L] [L]] --->
//│ 	case x:46^103 of {T n:47 l:48 r:49 => [T case n:47^104 of {K => [KK] | N => [NN]} ([c:9^28 · c:9^21 · c:9^18]:19^108 l:48^109) ([c:9^28 · c:9^21 · c:9^21]:20^111 r:49^112)] | L => [LL]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([c:9^28]:14^151 [t:8^29]:21^152)
//│ def [c:9^28 · c:9^18 · c:9^18]:16 = (fun x:30 -> x:30^229)
//│ def [c:9^28 · c:9^18 · c:9^21]:17 = (fun x:54 -> x:54^223)
//│ def [c:9^28 · c:9^18]:15 = (fun x:42 -> x:42^235)
//│ def [c:9^28 · c:9^21 · c:9^18]:19 = (fun x:38 -> x:38^225)
//│ def [c:9^28 · c:9^21 · c:9^21]:20 = (fun x:50 -> x:50^227)
//│ def [c:9^28 · c:9^21]:18 = (fun x:46 -> x:46^188)
//│ def [c:9^28]:14 = (fun x:34 -> x:34^186)
//│ def [t:8^29 · aa:6^10]:22 = let n:43 = [NN]
//│ in let l:44 = [LL]
//│ in let r:45 = [LL]
//│ in [T n:43^190 ([c:9^28 · c:9^18 · c:9^18]:16^191 l:44^192) ([c:9^28 · c:9^18 · c:9^21]:17^194 r:45^195)]
//│ def [t:8^29 · bb:7^11]:23 = let n:47 = [NN]
//│ in let l:48 = [LL]
//│ in let r:49 = [LL]
//│ in [T n:47^154 ([c:9^28 · c:9^21 · c:9^18]:19^155 l:48^156) ([c:9^28 · c:9^21 · c:9^21]:20^158 r:49^159)]
//│ def [t:8^29]:21 = let n:35 = [KK]
//│ in let l:36 = [t:8^29 · aa:6^10]:22^178
//│ in let r:37 = [t:8^29 · bb:7^11]:23^176
//│ in [T n:35^168 ([c:9^28 · c:9^18]:15^169 l:36^170) ([c:9^28 · c:9^21]:18^172 r:37^173)]
//│ def aa:6 = [T [N] [L] [L]]
//│ def bb:7 = [T [N] [L] [L]]
//│ def c:9 = (fun x:10 -> case x:10^208 of {
//│ 	T n:11 l:12 r:13 => [T case n:11^209 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c:9^213 l:12^214) (c:9^216 r:13^217)]
//│ 	| L => [LL]})
//│ def t:8 = [T [K] aa:6^232 bb:7^233]
//│ <<<<<<< after fusion <<<<<<<


fun map(ls) = if ls is
    C(h, t) then f => C(f(h), map(t)(f))
    N then f => N
let l = C(K, N)
map(l)(
    x => if x is
        K then T
)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#let| |l| |#=| |C|(|K|,| |N|)|↵|map|(|l|)|(|→|x| |=>| |#if| |x| |is|→|K| |#then| |T|←|←|↵|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then f, => C (f (h,), map (t,) (f,),); (N) then f, => N›; let l = C (K, N,); map (l,) (x, => if x is ‹(K) then T›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((map:6^19 l:7^20) (fun x:13 -> case x:13^22 of {
//│ 	K => [T]}))
//│ def l:7 = [C [K] [N]]
//│ def map:6 = (fun ls:8 -> case ls:8^1 of {
//│ 	C h:9 t:10 => (fun f:11 -> [C (f:11^2 h:9^3) ((map:6^5 t:10^6) f:11^8)])
//│ 	| N => (fun f:12 -> [N])})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 4't
//│ 	[-l:7^20 · +map:6^19 · +map:6^5 · +map:6^5]  --->  [-l:7^20 · +map:6^19 · +map:6^5]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [map:6^19 · map:6^5 · map:6^5] --> [map:6^19 · map:6^5]
//│ [l:7^20] --> [l:7^20]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l:7^20]
//│ 
//│ [map:6^19]
//│ 	[map:6^19 · map:6^5]
//│ 		[map:6^19 · map:6^5 · map:6^5] ---> [map:6^19 · map:6^5] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (([map:6^19]:15^60 [l:7^20]:14^61) (fun x:33 -> case x:33^63 of {
//│ 	K => [T]}))
//│ def [l:7^20]:14 = [C [K] [N]]
//│ def [map:6^19 · map:6^5]:16 = (fun ls:23 -> case ls:23^27 of {
//│ 	C h:24 t:25 => (fun f:26 -> [C (f:26^28 h:24^29) (([map:6^19 · map:6^5]:16^31 t:25^32) f:26^34)])
//│ 	| N => (fun f:27 -> [N])})
//│ def [map:6^19]:15 = (fun ls:28 -> case ls:28^42 of {
//│ 	C h:29 t:30 => (fun f:31 -> [C (f:31^43 h:29^44) (([map:6^19 · map:6^5]:16^46 t:30^47) f:31^49)])
//│ 	| N => (fun f:32 -> [N])})
//│ def l:7 = [C [K] [N]]
//│ def map:6 = (fun ls:9 -> case ls:9^9 of {
//│ 	C h:10 t:11 => (fun f:12 -> [C (f:12^10 h:10^11) ((map:6^13 t:11^14) f:12^16)])
//│ 	| N => (fun f:13 -> [N])})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 57: [K]
//│ [K] --->
//│ 	case x:33^63 of {K => [T]}
//│ 58: [N]
//│ [N] --->
//│ 	case ls:23^27 of {C h:24 t:25 => (fun f:26 -> [C (f:26^28 h:24^29) (([map:6^19 · map:6^5]:16^31 t:25^32) f:26^34)]) | N => (fun f:27 -> [N])}
//│ 59: [C 57: [K] 58: [N]]
//│ [C [K] [N]] --->
//│ 	case ls:28^42 of {C h:29 t:30 => (fun f:31 -> [C (f:31^43 h:29^44) (([map:6^19 · map:6^5]:16^46 t:30^47) f:31^49)]) | N => (fun f:32 -> [N])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (([map:6^19]:15^68 [l:7^20]:14^69) (fun x:33 -> x:33^71))
//│ def [l:7^20]:14 = let h:29 = [T]
//│ in let t:30 = (fun f:27 -> [N])
//│ in (fun f:31 -> [C (f:31^74 h:29^75) (([map:6^19 · map:6^5]:16^77 t:30^78) f:31^80)])
//│ def [map:6^19 · map:6^5]:16 = (fun ls:23 -> ls:23^109)
//│ def [map:6^19]:15 = (fun ls:28 -> ls:28^92)
//│ def l:7 = [C [K] [N]]
//│ def map:6 = (fun ls:9 -> case ls:9^94 of {
//│ 	C h:10 t:11 => (fun f:12 -> [C (f:12^95 h:10^96) ((map:6^98 t:11^99) f:12^101)])
//│ 	| N => (fun f:13 -> [N])})
//│ <<<<<<< after fusion <<<<<<<


fun inter(xs) = if xs is
    N then ys => ys
    C(h, t) then ys => C(h, inter(ys)(t))
let rec l1 = C(1, C(2, l1))
let rec l2 = C(9, C(8, l2))
inter(l1)(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |#rec| |l1| |#=| |C|(|1|,| |C|(|2|,| |l1|)|)|↵|#let| |#rec| |l2| |#=| |C|(|9|,| |C|(|8|,| |l2|)|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let rec l1 = C (1, C (2, l1,),); let rec l2 = C (9, C (8, l2,),); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter:6^24 l1:7^25) l2:8^27)
//│ def inter:6 = (fun xs:9 -> case xs:9^1 of {
//│ 	N => (fun ys:10 -> ys:10^2)
//│ 	| C h:11 t:12 => (fun ys:13 -> [C h:11^4 ((inter:6^5 ys:13^6) t:12^8)])})
//│ def l1:7 = [C 1 [C 2 l1:7^16]]
//│ def l2:8 = [C 9 [C 8 l2:8^21]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(Int, 1'l1_7^16) <: 7'ys
//│ 	[-l1:7^16 · -l1:7^25 · +inter:6^24 · +inter:6^5 · +inter:6^5 · +inter:6^5 · +inter:6^5 · +inter:6^5]  --->  [-l1:7^25 · +inter:6^24 · +inter:6^5]
//│ C(Int, 2'l2_8^21) <: 7'ys
//│ 	[-l2:8^21 · -l2:8^27 · +inter:6^24 · +inter:6^5 · +inter:6^5 · +inter:6^5 · +inter:6^5 · +inter:6^5 · +inter:6^5]  --->  [-l2:8^27 · +inter:6^24 · +inter:6^5 · +inter:6^5]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5 · inter:6^5 · inter:6^5 · inter:6^5] --> [inter:6^24 · inter:6^5 · inter:6^5]
//│ [inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5 · inter:6^5 · inter:6^5] --> [inter:6^24 · inter:6^5]
//│ [l1:7^25 · l1:7^16] --> [l1:7^25]
//│ [l2:8^27 · l2:8^21] --> [l2:8^27]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter:6^24]
//│ 	[inter:6^24 · inter:6^5]
//│ 		[inter:6^24 · inter:6^5 · inter:6^5]
//│ 			[inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5]
//│ 				[inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5 · inter:6^5]
//│ 					[inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5 · inter:6^5 · inter:6^5] ---> [inter:6^24 · inter:6^5] (only one)
//│ [l1:7^25]
//│ 	[l1:7^25 · l1:7^16] ---> [l1:7^25] (only one)
//│ [l2:8^27]
//│ 	[l2:8^27 · l2:8^21] ---> [l2:8^27] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (([inter:6^24]:16^104 [l1:7^25]:15^105) [l2:8^27]:14^107)
//│ def [inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5 · inter:6^5]:20 = (fun xs:47 -> case xs:47^91 of {
//│ 	N => (fun ys:48 -> ys:48^92)
//│ 	| C h:49 t:50 => (fun ys:51 -> [C h:49^94 (([inter:6^24 · inter:6^5]:17^95 ys:51^96) t:50^98)])})
//│ def [inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5]:19 = (fun xs:42 -> case xs:42^78 of {
//│ 	N => (fun ys:43 -> ys:43^79)
//│ 	| C h:44 t:45 => (fun ys:46 -> [C h:44^81 (([inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5 · inter:6^5]:20^82 ys:46^83) t:45^85)])})
//│ def [inter:6^24 · inter:6^5 · inter:6^5]:18 = (fun xs:27 -> case xs:27^34 of {
//│ 	N => (fun ys:28 -> ys:28^35)
//│ 	| C h:29 t:30 => (fun ys:31 -> [C h:29^37 (([inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5]:19^38 ys:31^39) t:30^41)])})
//│ def [inter:6^24 · inter:6^5]:17 = (fun xs:32 -> case xs:32^47 of {
//│ 	N => (fun ys:33 -> ys:33^48)
//│ 	| C h:34 t:35 => (fun ys:36 -> [C h:34^50 (([inter:6^24 · inter:6^5 · inter:6^5]:18^51 ys:36^52) t:35^54)])})
//│ def [inter:6^24]:16 = (fun xs:37 -> case xs:37^65 of {
//│ 	N => (fun ys:38 -> ys:38^66)
//│ 	| C h:39 t:40 => (fun ys:41 -> [C h:39^68 (([inter:6^24 · inter:6^5]:17^69 ys:41^70) t:40^72)])})
//│ def [l1:7^25]:15 = [C 1 [C 2 [l1:7^25]:15^31]]
//│ def [l2:8^27]:14 = [C 9 [C 8 [l2:8^27]:14^62]]
//│ def inter:6 = (fun xs:9 -> case xs:9^6 of {
//│ 	N => (fun ys:10 -> ys:10^7)
//│ 	| C h:11 t:12 => (fun ys:13 -> [C h:11^9 ((inter:6^10 ys:13^11) t:12^13)])})
//│ def l1:7 = [C 1 [C 2 l1:7^21]]
//│ def l2:8 = [C 9 [C 8 l2:8^26]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 32: [C 30: 2 31: [l1:7^25]:15^31]
//│ [C 2 [l1:7^25]:15^31] --->
//│ 	case xs:27^34 of {N => (fun ys:28 -> ys:28^35) | C h:29 t:30 => (fun ys:31 -> [C h:29^37 (([inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5]:19^38 ys:31^39) t:30^41)])}
//│ 33: [C 29: 1 32: [C 30: 2 31: [l1:7^25]:15^31]]
//│ [C 1 [C 2 [l1:7^25]:15^31]] --->
//│ 	case xs:37^65 of {N => (fun ys:38 -> ys:38^66) | C h:39 t:40 => (fun ys:41 -> [C h:39^68 (([inter:6^24 · inter:6^5]:17^69 ys:41^70) t:40^72)])}
//│ 	case xs:47^91 of {N => (fun ys:48 -> ys:48^92) | C h:49 t:50 => (fun ys:51 -> [C h:49^94 (([inter:6^24 · inter:6^5]:17^95 ys:51^96) t:50^98)])}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 63: [C 61: 8 62: [l2:8^27]:14^62]
//│ [C 8 [l2:8^27]:14^62] --->
//│ 	case xs:42^78 of {N => (fun ys:43 -> ys:43^79) | C h:44 t:45 => (fun ys:46 -> [C h:44^81 (([inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5 · inter:6^5]:20^82 ys:46^83) t:45^85)])}
//│ 64: [C 60: 9 63: [C 61: 8 62: [l2:8^27]:14^62]]
//│ [C 9 [C 8 [l2:8^27]:14^62]] --->
//│ 	case xs:32^47 of {N => (fun ys:33 -> ys:33^48) | C h:34 t:35 => (fun ys:36 -> [C h:34^50 (([inter:6^24 · inter:6^5 · inter:6^5]:18^51 ys:36^52) t:35^54)])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (([inter:6^24]:16^109 [l1:7^25]:15^110) [l2:8^27]:14^112)
//│ def [inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5 · inter:6^5]:20 = (fun xs:47 -> case xs:47^189 of {
//│ 	N => (fun ys:48 -> ys:48^190)
//│ 	| C h:49 t:50 => (fun ys:51 -> [C h:49^192 (([inter:6^24 · inter:6^5]:17^193 ys:51^194) t:50^196)])})
//│ def [inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5]:19 = (fun xs:42 -> xs:42^182)
//│ def [inter:6^24 · inter:6^5 · inter:6^5]:18 = (fun xs:27 -> xs:27^114)
//│ def [inter:6^24 · inter:6^5]:17 = (fun xs:32 -> xs:32^134)
//│ def [inter:6^24]:16 = (fun xs:37 -> xs:37^202)
//│ def [l1:7^25]:15 = let h:39 = 1
//│ in let t:40 = 
//│ 	let h:29 = 2
//│ 	in let t:30 = [l1:7^25]:15^175
//│ 	in (fun ys:31 -> [C h:29^167 (([inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5]:19^168 ys:31^169) t:30^171)])
//│ in (fun ys:41 -> [C h:39^159 (([inter:6^24 · inter:6^5]:17^160 ys:41^161) t:40^163)])
//│ def [l2:8^27]:14 = let h:34 = 9
//│ in let t:35 = 
//│ 	let h:44 = 8
//│ 	in let t:45 = [l2:8^27]:14^152
//│ 	in (fun ys:46 -> [C h:44^144 (([inter:6^24 · inter:6^5 · inter:6^5 · inter:6^5 · inter:6^5]:20^145 ys:46^146) t:45^148)])
//│ in (fun ys:36 -> [C h:34^136 (([inter:6^24 · inter:6^5 · inter:6^5]:18^137 ys:36^138) t:35^140)])
//│ def inter:6 = (fun xs:9 -> case xs:9^116 of {
//│ 	N => (fun ys:10 -> ys:10^117)
//│ 	| C h:11 t:12 => (fun ys:13 -> [C h:11^119 ((inter:6^120 ys:13^121) t:12^123)])})
//│ def l1:7 = [C 1 [C 2 l1:7^186]]
//│ def l2:8 = [C 9 [C 8 l2:8^131]]
//│ <<<<<<< after fusion <<<<<<<


fun last(ys) = if ys is
    N then x => x
    C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
    N then None
    C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (lastDrive:7^22 [C 1 [C 2 [N]]])
//│ def last:6 = (fun ys:8 -> case ys:8^1 of {
//│ 	N => (fun x:9 -> x:9^2)
//│ 	| C h:10 t:11 => (fun x:12 -> ((last:6^4 t:11^5) h:10^7))})
//│ def lastDrive:7 = (fun xs:13 -> case xs:13^12 of {
//│ 	N => [None]
//│ 	| C hh:14 tt:15 => [Some ((last:6^14 tt:15^15) hh:14^17)]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 5't
//│ 	[+lastDrive:7^22 · +last:6^14 · +last:6^4 · +last:6^4]  --->  [+lastDrive:7^22 · +last:6^14 · +last:6^4]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [lastDrive:7^22 · last:6^14 · last:6^4 · last:6^4] --> [lastDrive:7^22 · last:6^14 · last:6^4]
//│ [] --> []
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive:7^22]
//│ 	[lastDrive:7^22 · last:6^14]
//│ 		[lastDrive:7^22 · last:6^14 · last:6^4]
//│ 			[lastDrive:7^22 · last:6^14 · last:6^4 · last:6^4] ---> [lastDrive:7^22 · last:6^14 · last:6^4] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ([lastDrive:7^22]:16^61 [C 1 [C 2 [N]]])
//│ def [lastDrive:7^22 · last:6^14 · last:6^4]:18 = (fun ys:25 -> case ys:25^29 of {
//│ 	N => (fun x:26 -> x:26^30)
//│ 	| C h:27 t:28 => (fun x:29 -> (([lastDrive:7^22 · last:6^14 · last:6^4]:18^32 t:28^33) h:27^35))})
//│ def [lastDrive:7^22 · last:6^14]:17 = (fun ys:30 -> case ys:30^40 of {
//│ 	N => (fun x:31 -> x:31^41)
//│ 	| C h:32 t:33 => (fun x:34 -> (([lastDrive:7^22 · last:6^14 · last:6^4]:18^43 t:33^44) h:32^46))})
//│ def [lastDrive:7^22]:16 = (fun xs:35 -> case xs:35^51 of {
//│ 	N => [None]
//│ 	| C hh:36 tt:37 => [Some (([lastDrive:7^22 · last:6^14]:17^53 tt:37^54) hh:36^56)]})
//│ def last:6 = (fun ys:8 -> case ys:8^8 of {
//│ 	N => (fun x:9 -> x:9^9)
//│ 	| C h:10 t:11 => (fun x:12 -> ((last:6^11 t:11^12) h:10^14))})
//│ def lastDrive:7 = (fun xs:13 -> case xs:13^19 of {
//│ 	N => [None]
//│ 	| C hh:14 tt:15 => [Some ((last:6^21 tt:15^22) hh:14^24)]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 64: [N]
//│ [N] --->
//│ 	case ys:25^29 of {N => (fun x:26 -> x:26^30) | C h:27 t:28 => (fun x:29 -> (([lastDrive:7^22 · last:6^14 · last:6^4]:18^32 t:28^33) h:27^35))}
//│ 65: [C 63: 2 64: [N]]
//│ [C 2 [N]] --->
//│ 	case ys:30^40 of {N => (fun x:31 -> x:31^41) | C h:32 t:33 => (fun x:34 -> (([lastDrive:7^22 · last:6^14 · last:6^4]:18^43 t:33^44) h:32^46))}
//│ 66: [C 62: 1 65: [C 63: 2 64: [N]]]
//│ [C 1 [C 2 [N]]] --->
//│ 	case xs:35^51 of {N => [None] | C hh:36 tt:37 => [Some (([lastDrive:7^22 · last:6^14]:17^53 tt:37^54) hh:36^56)]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ([lastDrive:7^22]:16^68 let hh:36 = 1
//│ in let tt:37 = 
//│ 	let h:32 = 2
//│ 	in let t:33 = (fun x:26 -> x:26^81)
//│ 	in (fun x:34 -> (([lastDrive:7^22 · last:6^14 · last:6^4]:18^75 t:33^76) h:32^78))
//│ in [Some (([lastDrive:7^22 · last:6^14]:17^69 tt:37^70) hh:36^72)])
//│ def [lastDrive:7^22 · last:6^14 · last:6^4]:18 = (fun ys:25 -> ys:25^90)
//│ def [lastDrive:7^22 · last:6^14]:17 = (fun ys:30 -> ys:30^105)
//│ def [lastDrive:7^22]:16 = (fun xs:35 -> xs:35^92)
//│ def last:6 = (fun ys:8 -> case ys:8^94 of {
//│ 	N => (fun x:9 -> x:9^95)
//│ 	| C h:10 t:11 => (fun x:12 -> ((last:6^97 t:11^98) h:10^100))})
//│ def lastDrive:7 = (fun xs:13 -> case xs:13^107 of {
//│ 	N => [None]
//│ 	| C hh:14 tt:15 => [Some ((last:6^109 tt:15^110) hh:14^112)]})
//│ <<<<<<< after fusion <<<<<<<
