:NewParser
:ParseOnly

// CORRECT: simplest recursive length
let rec p = C(p)
fun c(x) = if x is
  C(a) then c(a)
c(p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^9(p^10)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => c^4(a⁰)}
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^9] (hopeless to continue)
//│ 	[c^9 · c^4] ---> [c^9] (using original def)
//│ [p^10] (hopeless to continue)
//│ 	[p^10 · p^1] ---> [p^10] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => c_₀(a¹)}
//│ def p_₀ = 
//│ 	[C p_₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p_₀]: 19 --->
//│ 	case x¹ of {C a¹ => c_₀(a¹)}: 16
//│ ------------------
//│ case x¹ of {C a¹ => c_₀(a¹)}: 16 --->
//│ 	[C p_₀]: 19
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C p_₀]: 19 --->
//│ 	case x¹ of {C a¹ => c_₀(a¹)}: 16
//│ ------------------
//│ case x¹ of {C a¹ => c_₀(a¹)}: 16 --->
//│ 	[C p_₀]: 19
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x²) = 
//│ 	x²(99)
//│ def p_₀ = 
//│ 	let a² = p_₀
//│ 	in (fun _lh_dummy⁰ -> c_₀(a²))
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: correctly aligned recursive length
let rec p = C(C(p))
fun c(x) = if x is
  C(a) then if a is
    C(b) then if b is
      C(y) then c(y)
c(p)
//│ |#let| |#rec| |p| |#=| |C|(|C|(|p|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |#if| |b| |is|→|C|(|y|)| |#then| |c|(|y|)|←|←|←|↵|c|(|p|)|
//│ Parsed: {let rec p = C (C (p,),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then if b is ‹(C (y,)) then c (y,)›››; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^14(p^15)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => case b⁰ of {
//│ 			C y⁰ => c^7(y⁰)}}}
//│ def p = [C [C p^1]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^14] (hopeless to continue)
//│ 	[c^14 · c^7] ---> [c^14] (using original def)
//│ [p^15] (hopeless to continue)
//│ 	[p^15 · p^1] ---> [p^15] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => case a¹ of {
//│ 			C b¹ => case b¹ of {
//│ 				C y¹ => c_₀(y¹)}}}
//│ def p_₀ = 
//│ 	[C [C p_₀]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p_₀]: 28 --->
//│ 	case b¹ of {C y¹ => c_₀(y¹)}: 23
//│ 	case a¹ of {C b¹ => case b¹ of {C y¹ => c_₀(y¹)}}: 24
//│ 	case x¹ of {C a¹ => case a¹ of {C b¹ => case b¹ of {C y¹ => c_₀(y¹)}}}: 25
//│ [C [C p_₀]]: 29 --->
//│ 	case b¹ of {C y¹ => c_₀(y¹)}: 23
//│ 	case a¹ of {C b¹ => case b¹ of {C y¹ => c_₀(y¹)}}: 24
//│ 	case x¹ of {C a¹ => case a¹ of {C b¹ => case b¹ of {C y¹ => c_₀(y¹)}}}: 25
//│ ------------------
//│ case b¹ of {C y¹ => c_₀(y¹)}: 23 --->
//│ 	[C p_₀]: 28
//│ 	[C [C p_₀]]: 29
//│ case a¹ of {C b¹ => case b¹ of {C y¹ => c_₀(y¹)}}: 24 --->
//│ 	[C p_₀]: 28
//│ 	[C [C p_₀]]: 29
//│ case x¹ of {C a¹ => case a¹ of {C b¹ => case b¹ of {C y¹ => c_₀(y¹)}}}: 25 --->
//│ 	[C p_₀]: 28
//│ 	[C [C p_₀]]: 29
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x²) = 
//│ 	case x² of {
//│ 		C a¹ => case a¹ of {
//│ 			C b¹ => case b¹ of {
//│ 				C y¹ => c_₀(y¹)}}}
//│ def p_₀ = 
//│ 	[C [C p_₀]]
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: correctly aligned recursive length (using split knot)
let rec p = C(C(p))
fun c(x) = if x is
  C(a) then c(a)
fun id2(yy) = yy
fun id(y) = id2(y)
c(id(p))
//│ |#let| |#rec| |p| |#=| |C|(|C|(|p|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id2|(|yy|)| |#=| |yy|↵|#fun| |id|(|y|)| |#=| |id2|(|y|)|↵|c|(|id|(|p|)|)|
//│ Parsed: {let rec p = C (C (p,),); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun id2 = yy, => yy; fun id = y, => id2 (y,); c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^16(id^17(p^18))
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => c^5(a⁰)}
//│ def id(y⁰) = id2^12(y⁰)
//│ def id2(yy⁰) = yy⁰
//│ def p = [C [C p^1]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^16] (hopeless to continue)
//│ 	[c^16 · c^5] ---> [c^16] (using original def)
//│ [id^17] (hopeless to continue)
//│ 	[id^17 · id2^12] (using original def)
//│ [p^18] (hopeless to continue)
//│ 	[p^18 · p^1] ---> [p^18] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(id_₀(p_₀))
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => c_₀(a¹)}
//│ def id_₀(y¹) = 
//│ 	id2_₀(y¹)
//│ 	where
//│ 	def id2_₀(yy¹) = 
//│ 		yy¹
//│ def p_₀ = 
//│ 	[C [C p_₀]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p_₀]: 28 --->
//│ 	case x¹ of {C a¹ => c_₀(a¹)}: 34
//│ [C [C p_₀]]: 29 --->
//│ 	case x¹ of {C a¹ => c_₀(a¹)}: 34
//│ ------------------
//│ case x¹ of {C a¹ => c_₀(a¹)}: 34 --->
//│ 	[C p_₀]: 28
//│ 	[C [C p_₀]]: 29
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C p_₀]: 28 --->
//│ 	case x¹ of {C a¹ => c_₀(a¹)}: 34
//│ [C [C p_₀]]: 29 --->
//│ 	case x¹ of {C a¹ => c_₀(a¹)}: 34
//│ ------------------
//│ case x¹ of {C a¹ => c_₀(a¹)}: 34 --->
//│ 	[C p_₀]: 28
//│ 	[C [C p_₀]]: 29
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(id_₀(p_₀))
//│ def c_₀(x²) = 
//│ 	x²(99)
//│ def id_₀(y²) = 
//│ 	id2_₀(y²)
//│ 	where
//│ 	def id2_₀(yy²) = 
//│ 		yy²
//│ def p_₀ = 
//│ 	let a² = 	
//│ 		let a³ = p_₀
//│ 		in (fun _lh_dummy¹ -> c_₀(a³))
//│ 	in (fun _lh_dummy⁰ -> c_₀(a²))
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: correctly aligned recursive length (using split knot)
let rec p = C(C(C(p)))
fun ca(x) = if x is
  C(a) then cb(a)
fun cb(x) = if x is
  C(b) then ca(b)
ca(p)
//│ |#let| |#rec| |p| |#=| |C|(|C|(|C|(|p|)|)|)|↵|#fun| |ca|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |cb|(|a|)|←|↵|#fun| |cb|(|x|)| |#=| |#if| |x| |is|→|C|(|b|)| |#then| |ca|(|b|)|←|↵|ca|(|p|)|
//│ Parsed: {let rec p = C (C (C (p,),),); fun ca = x, => if x is ‹(C (a,)) then cb (a,)›; fun cb = x, => if x is ‹(C (b,)) then ca (b,)›; ca (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ca^17(p^18)
//│ def ca(x⁰) = case x⁰ of {
//│ 	C a⁰ => cb^6(a⁰)}
//│ def cb(x¹) = case x¹ of {
//│ 	C b⁰ => ca^12(b⁰)}
//│ def p = [C [C [C p^1]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ca^17] (hopeless to continue)
//│ 	[ca^17 · cb^6] (using original def)
//│ 		[ca^17 · cb^6 · ca^12] ---> [ca^17] (using original def)
//│ [p^18] (hopeless to continue)
//│ 	[p^18 · p^1] ---> [p^18] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ca_₀(p_₀)
//│ def ca_₀(x³) = 
//│ 	case x³ of {
//│ 		C a¹ => cb_₀(a¹)}
//│ 	where
//│ 	def cb_₀(x²) = 
//│ 		case x² of {
//│ 			C b¹ => ca_₀(b¹)}
//│ def p_₀ = 
//│ 	[C [C [C p_₀]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p_₀]: 33 --->
//│ 	case x² of {C b¹ => ca_₀(b¹)}: 24
//│ 	case x³ of {C a¹ => cb_₀(a¹)}: 30
//│ [C [C p_₀]]: 34 --->
//│ 	case x² of {C b¹ => ca_₀(b¹)}: 24
//│ 	case x³ of {C a¹ => cb_₀(a¹)}: 30
//│ [C [C [C p_₀]]]: 35 --->
//│ 	case x² of {C b¹ => ca_₀(b¹)}: 24
//│ 	case x³ of {C a¹ => cb_₀(a¹)}: 30
//│ ------------------
//│ case x² of {C b¹ => ca_₀(b¹)}: 24 --->
//│ 	[C p_₀]: 33
//│ 	[C [C p_₀]]: 34
//│ 	[C [C [C p_₀]]]: 35
//│ case x³ of {C a¹ => cb_₀(a¹)}: 30 --->
//│ 	[C p_₀]: 33
//│ 	[C [C p_₀]]: 34
//│ 	[C [C [C p_₀]]]: 35
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ca_₀(p_₀)
//│ def ca_₀(x⁵) = 
//│ 	case x⁵ of {
//│ 		C a¹ => cb_₀(a¹)}
//│ 	where
//│ 	def cb_₀(x⁴) = 
//│ 		case x⁴ of {
//│ 			C b¹ => ca_₀(b¹)}
//│ def p_₀ = 
//│ 	[C [C [C p_₀]]]
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: correctly aligned recursive length (using split knot)
fun c1(x1) = if x1 is
  C(a) then c2(a)
fun c2(x2) = if x2 is
  C(b) then c1(b)
let p1 = C(C(C(p2)))
let p2 = C(p1)
c1(p1)
//│ |#fun| |c1|(|x1|)| |#=| |#if| |x1| |is|→|C|(|a|)| |#then| |c2|(|a|)|←|↵|#fun| |c2|(|x2|)| |#=| |#if| |x2| |is|→|C|(|b|)| |#then| |c1|(|b|)|←|↵|#let| |p1| |#=| |C|(|C|(|C|(|p2|)|)|)|↵|#let| |p2| |#=| |C|(|p1|)|↵|c1|(|p1|)|
//│ Parsed: {fun c1 = x1, => if x1 is ‹(C (a,)) then c2 (a,)›; fun c2 = x2, => if x2 is ‹(C (b,)) then c1 (b,)›; let p1 = C (C (C (p2,),),); let p2 = C (p1,); c1 (p1,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c1^19(p1^20)
//│ def c1(x1⁰) = case x1⁰ of {
//│ 	C a⁰ => c2^2(a⁰)}
//│ def c2(x2⁰) = case x2⁰ of {
//│ 	C b⁰ => c1^8(b⁰)}
//│ def p1 = [C [C [C p2^13]]]
//│ def p2 = [C p1^17]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c1^19] (hopeless to continue)
//│ 	[c1^19 · c2^2] (using original def)
//│ 		[c1^19 · c2^2 · c1^8] ---> [c1^19] (using original def)
//│ [p1^20] (hopeless to continue)
//│ 	[p1^20 · p2^13] (using original def)
//│ 		[p1^20 · p2^13 · p1^17] ---> [p1^20] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c1_₀(p1_₀)
//│ def c1_₀(x1¹) = 
//│ 	case x1¹ of {
//│ 		C a¹ => c2_₀(a¹)}
//│ 	where
//│ 	def c2_₀(x2¹) = 
//│ 		case x2¹ of {
//│ 			C b¹ => c1_₀(b¹)}
//│ def p1_₀ = 
//│ 	[C [C [C p2_₀]]]
//│ 	where
//│ 	def p2_₀ = 
//│ 		[C p1_₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p2_₀]: 29 --->
//│ 	case x1¹ of {C a¹ => c2_₀(a¹)}: 26
//│ [C [C p2_₀]]: 30 --->
//│ 	case x2¹ of {C b¹ => c1_₀(b¹)}: 36
//│ [C [C [C p2_₀]]]: 31 --->
//│ 	case x1¹ of {C a¹ => c2_₀(a¹)}: 26
//│ [C p1_₀]: 39 --->
//│ 	case x2¹ of {C b¹ => c1_₀(b¹)}: 36
//│ ------------------
//│ case x1¹ of {C a¹ => c2_₀(a¹)}: 26 --->
//│ 	[C p2_₀]: 29
//│ 	[C [C [C p2_₀]]]: 31
//│ case x2¹ of {C b¹ => c1_₀(b¹)}: 36 --->
//│ 	[C [C p2_₀]]: 30
//│ 	[C p1_₀]: 39
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C p2_₀]: 29 --->
//│ 	case x1¹ of {C a¹ => c2_₀(a¹)}: 26
//│ [C [C p2_₀]]: 30 --->
//│ 	case x2¹ of {C b¹ => c1_₀(b¹)}: 36
//│ [C [C [C p2_₀]]]: 31 --->
//│ 	case x1¹ of {C a¹ => c2_₀(a¹)}: 26
//│ [C p1_₀]: 39 --->
//│ 	case x2¹ of {C b¹ => c1_₀(b¹)}: 36
//│ ------------------
//│ case x1¹ of {C a¹ => c2_₀(a¹)}: 26 --->
//│ 	[C p2_₀]: 29
//│ 	[C [C [C p2_₀]]]: 31
//│ case x2¹ of {C b¹ => c1_₀(b¹)}: 36 --->
//│ 	[C [C p2_₀]]: 30
//│ 	[C p1_₀]: 39
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c1_₀(p1_₀)
//│ def c1_₀(x1²) = 
//│ 	x1²(99)
//│ 	where
//│ 	def c2_₀(x2²) = 
//│ 		x2²(99)
//│ def p1_₀ = 
//│ 	let a² = 	
//│ 		let b² = 	
//│ 			let a³ = p2_₀
//│ 			in (fun _lh_dummy² -> c2_₀(a³))
//│ 		in (fun _lh_dummy¹ -> c1_₀(b²))
//│ 	in (fun _lh_dummy⁰ -> c2_₀(a²))
//│ 	where
//│ 	def p2_₀ = 
//│ 		let b³ = p1_₀
//│ 		in (fun _lh_dummy³ -> c1_₀(b³))
//│ <<<<<<< after fusion <<<<<<<


// CORRECT:
let rec p = C(p)
fun c(x) = if x is
  C(a) then c(a)
fun main(cc) = cc(p)
main(c)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|cc|)| |#=| |cc|(|p|)|↵|main|(|c|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = cc, => cc (p,); main (c,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^13(c^14)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => c^4(a⁰)}
//│ def main(cc⁰) = cc⁰(p^10)
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^14] (hopeless to continue)
//│ 	[c^14 · c^4] ---> [c^14] (using original def)
//│ [main^13] (hopeless to continue)
//│ 	[main^13 · p^10] (using original def)
//│ 		[main^13 · p^10 · p^1] ---> [main^13 · p^10] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ main_₀(c_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => c_₀(a¹)}
//│ def main_₀(cc¹) = 
//│ 	cc¹(p_₀)
//│ 	where
//│ 	def p_₀ = 
//│ 		[C p_₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p_₀]: 17 --->
//│ 	case x¹ of {C a¹ => c_₀(a¹)}: 26
//│ ------------------
//│ case x¹ of {C a¹ => c_₀(a¹)}: 26 --->
//│ 	[C p_₀]: 17
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C p_₀]: 17 --->
//│ 	case x¹ of {C a¹ => c_₀(a¹)}: 26
//│ ------------------
//│ case x¹ of {C a¹ => c_₀(a¹)}: 26 --->
//│ 	[C p_₀]: 17
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main_₀(c_₀)
//│ def c_₀(x²) = 
//│ 	x²(99)
//│ def main_₀(cc²) = 
//│ 	cc²(p_₀)
//│ 	where
//│ 	def p_₀ = 
//│ 		let a² = p_₀
//│ 		in (fun _lh_dummy⁰ -> c_₀(a²))
//│ <<<<<<< after fusion <<<<<<<


// CORRECT:
let rec p = C(p)
fun c(x) = if x is
  C(a) then c(a)
fun main(pp) = if pp is
  C(b) then if b is
    C(d) then c(d)
main(p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|pp|)| |#=| |#if| |pp| |is|→|C|(|b|)| |#then| |#if| |b| |is|→|C|(|d|)| |#then| |c|(|d|)|←|←|↵|main|(|p|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = pp, => if pp is ‹(C (b,)) then if b is ‹(C (d,)) then c (d,)››; main (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^17(p^18)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => c^4(a⁰)}
//│ def main(pp⁰) = case pp⁰ of {
//│ 	C b⁰ => case b⁰ of {
//│ 		C d⁰ => c^11(d⁰)}}
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [main^17] (hopeless to continue)
//│ 	[main^17 · c^11] (using original def)
//│ 		[main^17 · c^11 · c^4] ---> [main^17 · c^11] (using original def)
//│ [p^18] (hopeless to continue)
//│ 	[p^18 · p^1] ---> [p^18] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ main_₀(p_₀)
//│ def main_₀(pp¹) = 
//│ 	case pp¹ of {
//│ 		C b¹ => case b¹ of {
//│ 			C d¹ => c_₀(d¹)}}
//│ 	where
//│ 	def c_₀(x¹) = 
//│ 		case x¹ of {
//│ 			C a¹ => c_₀(a¹)}
//│ def p_₀ = 
//│ 	[C p_₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p_₀]: 35 --->
//│ 	case b¹ of {C d¹ => c_₀(d¹)}: 25
//│ 	case pp¹ of {C b¹ => case b¹ of {C d¹ => c_₀(d¹)}}: 26
//│ 	case x¹ of {C a¹ => c_₀(a¹)}: 32
//│ ------------------
//│ case b¹ of {C d¹ => c_₀(d¹)}: 25 --->
//│ 	[C p_₀]: 35
//│ case pp¹ of {C b¹ => case b¹ of {C d¹ => c_₀(d¹)}}: 26 --->
//│ 	[C p_₀]: 35
//│ case x¹ of {C a¹ => c_₀(a¹)}: 32 --->
//│ 	[C p_₀]: 35
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main_₀(p_₀)
//│ def main_₀(pp²) = 
//│ 	case pp² of {
//│ 		C b¹ => case b¹ of {
//│ 			C d¹ => c_₀(d¹)}}
//│ 	where
//│ 	def c_₀(x²) = 
//│ 		case x² of {
//│ 			C a¹ => c_₀(a¹)}
//│ def p_₀ = 
//│ 	[C p_₀]
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
let rec p = C(p)
let c(x) = if x is
  C(a) then c(a)
fun main(cc, pp) = cc(pp)
main(c, p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#let| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|cc|,| |pp|)| |#=| |cc|(|pp|)|↵|main|(|c|,| |p|)|
//│ Parsed: {let rec p = C (p,); let c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = cc, pp, => cc (pp,); main (c, p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^14(c^15, p^17)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => c^4(a⁰)}
//│ def main(cc⁰, pp⁰) = cc⁰(pp⁰)
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^15] (hopeless to continue)
//│ 	[c^15 · c^4] ---> [c^15] (using original def)
//│ [main^14] (hopeless to continue)
//│ [p^17] (hopeless to continue)
//│ 	[p^17 · p^1] ---> [p^17] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ main_₀(c_₀, p_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => c_₀(a¹)}
//│ def main_₀(cc¹, pp¹) = 
//│ 	cc¹(pp¹)
//│ def p_₀ = 
//│ 	[C p_₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p_₀]: 26 --->
//│ 	case x¹ of {C a¹ => c_₀(a¹)}: 23
//│ ------------------
//│ case x¹ of {C a¹ => c_₀(a¹)}: 23 --->
//│ 	[C p_₀]: 26
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C p_₀]: 26 --->
//│ 	case x¹ of {C a¹ => c_₀(a¹)}: 23
//│ ------------------
//│ case x¹ of {C a¹ => c_₀(a¹)}: 23 --->
//│ 	[C p_₀]: 26
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main_₀(c_₀, p_₀)
//│ def c_₀(x²) = 
//│ 	x²(99)
//│ def main_₀(cc², pp²) = 
//│ 	cc²(pp²)
//│ def p_₀ = 
//│ 	let a² = p_₀
//│ 	in (fun _lh_dummy⁰ -> c_₀(a²))
//│ <<<<<<< after fusion <<<<<<<


// CORRECT:
fun cons(y) = if y is
  C(aa) then cons(aa)
fun a(x) = b(x)
fun b(x) = c(x)
fun c(x) = d(cons, x)
fun d(cc, x) = cc(x)
let p = C(p)
a(p)
//│ |#fun| |cons|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |cons|(|aa|)|←|↵|#fun| |a|(|x|)| |#=| |b|(|x|)|↵|#fun| |b|(|x|)| |#=| |c|(|x|)|↵|#fun| |c|(|x|)| |#=| |d|(|cons|,| |x|)|↵|#fun| |d|(|cc|,| |x|)| |#=| |cc|(|x|)|↵|#let| |p| |#=| |C|(|p|)|↵|a|(|p|)|
//│ Parsed: {fun cons = y, => if y is ‹(C (aa,)) then cons (aa,)›; fun a = x, => b (x,); fun b = x, => c (x,); fun c = x, => d (cons, x,); fun d = cc, x, => cc (x,); let p = C (p,); a (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ a^28(p^29)
//│ def a(x⁰) = b^7(x⁰)
//│ def b(x¹) = c^11(x¹)
//│ def c(x²) = d^15(cons^16, x²)
//│ def cons(y⁰) = case y⁰ of {
//│ 	C aa⁰ => cons^2(aa⁰)}
//│ def d(cc⁰, x³) = cc⁰(x³)
//│ def p = [C p^26]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [a^28] (hopeless to continue)
//│ 	[a^28 · b^7] (using original def)
//│ 		[a^28 · b^7 · c^11] (using original def)
//│ 			[a^28 · b^7 · c^11 · cons^16] (using original def)
//│ 				[a^28 · b^7 · c^11 · cons^16 · cons^2] ---> [a^28 · b^7 · c^11 · cons^16] (using original def)
//│ 			[a^28 · b^7 · c^11 · d^15] (using original def)
//│ [p^29] (hopeless to continue)
//│ 	[p^29 · p^26] ---> [p^29] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ a_₀(p_₀)
//│ def a_₀(x⁴) = 
//│ 	b_₀(x⁴)
//│ 	where
//│ 	def b_₀(x⁷) = 
//│ 		c_₀(x⁷)
//│ 		where
//│ 		def c_₀(x⁶) = 
//│ 			d_₀(cons_₀, x⁶)
//│ 			where
//│ 			def cons_₀(y¹) = 
//│ 				case y¹ of {
//│ 					C aa¹ => cons_₀(aa¹)}
//│ 			def d_₀(cc¹, x⁵) = 
//│ 				cc¹(x⁵)
//│ def p_₀ = 
//│ 	[C p_₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p_₀]: 38 --->
//│ 	case y¹ of {C aa¹ => cons_₀(aa¹)}: 35
//│ ------------------
//│ case y¹ of {C aa¹ => cons_₀(aa¹)}: 35 --->
//│ 	[C p_₀]: 38
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C p_₀]: 38 --->
//│ 	case y¹ of {C aa¹ => cons_₀(aa¹)}: 35
//│ ------------------
//│ case y¹ of {C aa¹ => cons_₀(aa¹)}: 35 --->
//│ 	[C p_₀]: 38
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ a_₀(p_₀)
//│ def a_₀(x¹⁰) = 
//│ 	b_₀(x¹⁰)
//│ 	where
//│ 	def b_₀(x⁸) = 
//│ 		c_₀(x⁸)
//│ 		where
//│ 		def c_₀(x⁹) = 
//│ 			d_₀(cons_₀, x⁹)
//│ 			where
//│ 			def cons_₀(y²) = 
//│ 				y²(99)
//│ 			def d_₀(cc², x¹¹) = 
//│ 				cc²(x¹¹)
//│ def p_₀ = 
//│ 	let aa² = p_₀
//│ 	in (fun _lh_dummy⁰ -> cons_₀(aa²))
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: `main` consumes one C, `c2` then recursively consumes one C at a time
let rec p = C(p)
fun c(x) = if x is
  C(a) then a
fun c1(xx) = if xx is
  C(aa) then aa
fun c2(z) = if z is
  C(b) then c2(b)
let main = c(p)
fun id(y) = c1(C(y))
c2(id(main))
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |a|←|↵|#fun| |c1|(|xx|)| |#=| |#if| |xx| |is|→|C|(|aa|)| |#then| |aa|←|↵|#fun| |c2|(|z|)| |#=| |#if| |z| |is|→|C|(|b|)| |#then| |c2|(|b|)|←|↵|#let| |main| |#=| |c|(|p|)|↵|#fun| |id|(|y|)| |#=| |c1|(|C|(|y|)|)|↵|c2|(|id|(|main|)|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then a›; fun c1 = xx, => if xx is ‹(C (aa,)) then aa›; fun c2 = z, => if z is ‹(C (b,)) then c2 (b,)›; let main = c (p,); fun id = y, => c1 (C (y,),); c2 (id (main,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c2^25(id^26(main^27))
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => a⁰}
//│ def c1(xx⁰) = case xx⁰ of {
//│ 	C aa⁰ => aa⁰}
//│ def c2(z⁰) = case z⁰ of {
//│ 	C b⁰ => c2^12(b⁰)}
//│ def id(y⁰) = c1^20([C y⁰])
//│ def main = c^17(p^18)
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c2^25] (hopeless to continue)
//│ 	[c2^25 · c2^12] ---> [c2^25] (using original def)
//│ [id^26] (hopeless to continue)
//│ 	[id^26 · c1^20] (using original def)
//│ [main^27] (hopeless to continue)
//│ 	[main^27 · c^17] (using original def)
//│ 	[main^27 · p^18] (using original def)
//│ 		[main^27 · p^18 · p^1] ---> [main^27 · p^18] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c2_₀(id_₀(main_₀))
//│ def c2_₀(z¹) = 
//│ 	case z¹ of {
//│ 		C b¹ => c2_₀(b¹)}
//│ def id_₀(y¹) = 
//│ 	c1_₀([C y¹])
//│ 	where
//│ 	def c1_₀(xx¹) = 
//│ 		case xx¹ of {
//│ 			C aa¹ => aa¹}
//│ def main_₀ = 
//│ 	c_₀(p_₀)
//│ 	where
//│ 	def c_₀(x¹) = 
//│ 		case x¹ of {
//│ 			C a¹ => a¹}
//│ 	def p_₀ = 
//│ 		[C p_₀]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p_₀]: 31 --->
//│ 	case x¹ of {C a¹ => a¹}: 46
//│ 	case z¹ of {C b¹ => c2_₀(b¹)}: 52
//│ [C y¹]: 34 --->
//│ 	case xx¹ of {C aa¹ => aa¹}: 42
//│ ------------------
//│ case xx¹ of {C aa¹ => aa¹}: 42 --->
//│ 	[C y¹]: 34
//│ case x¹ of {C a¹ => a¹}: 46 --->
//│ 	[C p_₀]: 31
//│ case z¹ of {C b¹ => c2_₀(b¹)}: 52 --->
//│ 	[C p_₀]: 31
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C y¹]: 34 --->
//│ 	case xx¹ of {C aa¹ => aa¹}: 42
//│ ------------------
//│ case xx¹ of {C aa¹ => aa¹}: 42 --->
//│ 	[C y¹]: 34
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c2_₀(id_₀(main_₀))
//│ def c2_₀(z²) = 
//│ 	case z² of {
//│ 		C b¹ => c2_₀(b¹)}
//│ def id_₀(y²) = 
//│ 	c1_₀(
//│ 		let aa² = y²
//│ 		in aa²)
//│ 	where
//│ 	def c1_₀(xx²) = 
//│ 		xx²
//│ def main_₀ = 
//│ 	c_₀(p_₀)
//│ 	where
//│ 	def c_₀(x²) = 
//│ 		case x² of {
//│ 			C a¹ => a¹}
//│ 	def p_₀ = 
//│ 		[C p_₀]
//│ <<<<<<< after fusion <<<<<<<
