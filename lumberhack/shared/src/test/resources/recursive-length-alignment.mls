:NewParser
:ParseOnly

// CORRECT: simplest recursive length
let rec p = C(p)
fun c(x) = if x is
  C(a) then c(a)
c(p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^9(p^10)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => c^4(a⁰)}
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p]: 2 --->
//│ 	case x⁰ of {C a⁰ => c(a⁰)}: 7
//│ ------------------
//│ case x⁰ of {C a⁰ => c(a⁰)}: 7 --->
//│ 	[C p]: 2
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C p]: 2 --->
//│ 	case x⁰ of {C a⁰ => c(a⁰)}: 7
//│ ------------------
//│ case x⁰ of {C a⁰ => c(a⁰)}: 7 --->
//│ 	[C p]: 2
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(p)
//│ def c(x¹) = x¹(99)
//│ def p = 
//│ 	let a¹ = p
//│ 	in (fun _lh_dummy⁰ -> c(a¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ c
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ p -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ p(99)
//│ def c(x⁰) = x⁰(99)
//│ def p = 
//│ 	let a⁰ = p
//│ 	in (fun _lh_dummy⁰ -> a⁰(99))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ p(99)
//│ def c(x⁰) = x⁰(99)
//│ def p = 
//│ 	let a⁰ = p
//│ 	in (fun _lh_dummy⁰ -> a⁰(99))
//│ <<<<<<< after floating out <<<<<<<

// CORRECT: correctly aligned recursive length
let rec p = C(C(p))
fun c(x) = if x is
  C(a) then if a is
    C(b) then if b is
      C(y) then c(y)
c(p)
//│ |#let| |#rec| |p| |#=| |C|(|C|(|p|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |#if| |b| |is|→|C|(|y|)| |#then| |c|(|y|)|←|←|←|↵|c|(|p|)|
//│ Parsed: {let rec p = C (C (p,),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then if b is ‹(C (y,)) then c (y,)›››; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^14(p^15)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => case b⁰ of {
//│ 			C y⁰ => c^7(y⁰)}}}
//│ def p = [C [C p^1]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p]: 2 --->
//│ 	case b⁰ of {C y⁰ => c(y⁰)}: 10
//│ 	case a⁰ of {C b⁰ => case b⁰ of {C y⁰ => c(y⁰)}}: 11
//│ 	case x⁰ of {C a⁰ => case a⁰ of {C b⁰ => case b⁰ of {C y⁰ => c(y⁰)}}}: 12
//│ [C [C p]]: 3 --->
//│ 	case b⁰ of {C y⁰ => c(y⁰)}: 10
//│ 	case a⁰ of {C b⁰ => case b⁰ of {C y⁰ => c(y⁰)}}: 11
//│ 	case x⁰ of {C a⁰ => case a⁰ of {C b⁰ => case b⁰ of {C y⁰ => c(y⁰)}}}: 12
//│ ------------------
//│ case b⁰ of {C y⁰ => c(y⁰)}: 10 --->
//│ 	[C p]: 2
//│ 	[C [C p]]: 3
//│ case a⁰ of {C b⁰ => case b⁰ of {C y⁰ => c(y⁰)}}: 11 --->
//│ 	[C p]: 2
//│ 	[C [C p]]: 3
//│ case x⁰ of {C a⁰ => case a⁰ of {C b⁰ => case b⁰ of {C y⁰ => c(y⁰)}}}: 12 --->
//│ 	[C p]: 2
//│ 	[C [C p]]: 3
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(p)
//│ def c(x¹) = case x¹ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => case b⁰ of {
//│ 			C y⁰ => c(y⁰)}}}
//│ def p = [C [C p]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ c(p)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => case b⁰ of {
//│ 			C y⁰ => c(y⁰)}}}
//│ def p = [C [C p]]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ c(p)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => case b⁰ of {
//│ 			C y⁰ => c(y⁰)}}}
//│ def p = [C [C p]]
//│ <<<<<<< after floating out <<<<<<<

// CORRECT: correctly aligned recursive length (using split knot)
let rec p = C(C(p))
fun c(x) = if x is
  C(a) then c(a)
fun id2(yy) = yy
fun id(y) = id2(y)
c(id(p))
//│ |#let| |#rec| |p| |#=| |C|(|C|(|p|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id2|(|yy|)| |#=| |yy|↵|#fun| |id|(|y|)| |#=| |id2|(|y|)|↵|c|(|id|(|p|)|)|
//│ Parsed: {let rec p = C (C (p,),); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun id2 = yy, => yy; fun id = y, => id2 (y,); c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^16(id^17(p^18))
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => c^5(a⁰)}
//│ def id(y⁰) = id2^12(y⁰)
//│ def id2(yy⁰) = yy⁰
//│ def p = [C [C p^1]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p]: 2 --->
//│ 	case x⁰ of {C a⁰ => c(a⁰)}: 8
//│ [C [C p]]: 3 --->
//│ 	case x⁰ of {C a⁰ => c(a⁰)}: 8
//│ ------------------
//│ case x⁰ of {C a⁰ => c(a⁰)}: 8 --->
//│ 	[C p]: 2
//│ 	[C [C p]]: 3
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C p]: 2 --->
//│ 	case x⁰ of {C a⁰ => c(a⁰)}: 8
//│ [C [C p]]: 3 --->
//│ 	case x⁰ of {C a⁰ => c(a⁰)}: 8
//│ ------------------
//│ case x⁰ of {C a⁰ => c(a⁰)}: 8 --->
//│ 	[C p]: 2
//│ 	[C [C p]]: 3
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(id(p))
//│ def c(x¹) = x¹(99)
//│ def id(y¹) = id2(y¹)
//│ def id2(yy¹) = yy¹
//│ def p = 
//│ 	let a¹ = 	
//│ 		let a² = p
//│ 		in (fun _lh_dummy¹ -> c(a²))
//│ 	in (fun _lh_dummy⁰ -> c(a¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ c
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ p -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ id(p, 99)
//│ def c(x⁰) = x⁰(99)
//│ def id(y⁰) = id2(y⁰)
//│ def id2(yy⁰) = yy⁰
//│ def p = 
//│ 	let a⁰ = 	
//│ 		let a¹ = p
//│ 		in (fun _lh_dummy⁰ -> a¹(99))
//│ 	in (fun _lh_dummy¹ -> a⁰(99))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ id(p, 99)
//│ def c(x⁰) = x⁰(99)
//│ def id(y⁰) = id2(y⁰)
//│ def id2(yy⁰) = yy⁰
//│ def p = 
//│ 	let a⁰ = 	
//│ 		let a¹ = p
//│ 		in (fun _lh_dummy⁰ -> a¹(99))
//│ 	in (fun _lh_dummy¹ -> a⁰(99))
//│ <<<<<<< after floating out <<<<<<<


// CORRECT: correctly aligned recursive length (using split knot)
let rec p = C(C(C(p)))
fun ca(x) = if x is
  C(a) then cb(a)
fun cb(x) = if x is
  C(b) then ca(b)
ca(p)
//│ |#let| |#rec| |p| |#=| |C|(|C|(|C|(|p|)|)|)|↵|#fun| |ca|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |cb|(|a|)|←|↵|#fun| |cb|(|x|)| |#=| |#if| |x| |is|→|C|(|b|)| |#then| |ca|(|b|)|←|↵|ca|(|p|)|
//│ Parsed: {let rec p = C (C (C (p,),),); fun ca = x, => if x is ‹(C (a,)) then cb (a,)›; fun cb = x, => if x is ‹(C (b,)) then ca (b,)›; ca (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ca^17(p^18)
//│ def ca(x⁰) = case x⁰ of {
//│ 	C a⁰ => cb^6(a⁰)}
//│ def cb(x¹) = case x¹ of {
//│ 	C b⁰ => ca^12(b⁰)}
//│ def p = [C [C [C p^1]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p]: 2 --->
//│ 	case x⁰ of {C a⁰ => cb(a⁰)}: 9
//│ 	case x¹ of {C b⁰ => ca(b⁰)}: 15
//│ [C [C p]]: 3 --->
//│ 	case x⁰ of {C a⁰ => cb(a⁰)}: 9
//│ 	case x¹ of {C b⁰ => ca(b⁰)}: 15
//│ [C [C [C p]]]: 4 --->
//│ 	case x⁰ of {C a⁰ => cb(a⁰)}: 9
//│ 	case x¹ of {C b⁰ => ca(b⁰)}: 15
//│ ------------------
//│ case x⁰ of {C a⁰ => cb(a⁰)}: 9 --->
//│ 	[C p]: 2
//│ 	[C [C p]]: 3
//│ 	[C [C [C p]]]: 4
//│ case x¹ of {C b⁰ => ca(b⁰)}: 15 --->
//│ 	[C p]: 2
//│ 	[C [C p]]: 3
//│ 	[C [C [C p]]]: 4
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ca(p)
//│ def ca(x²) = case x² of {
//│ 	C a⁰ => cb(a⁰)}
//│ def cb(x³) = case x³ of {
//│ 	C b⁰ => ca(b⁰)}
//│ def p = [C [C [C p]]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ ca(p)
//│ def ca(x⁰) = case x⁰ of {
//│ 	C a⁰ => cb(a⁰)}
//│ def cb(x¹) = case x¹ of {
//│ 	C b⁰ => ca(b⁰)}
//│ def p = [C [C [C p]]]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ ca(p)
//│ def ca(x⁰) = case x⁰ of {
//│ 	C a⁰ => cb(a⁰)}
//│ def cb(x¹) = case x¹ of {
//│ 	C b⁰ => ca(b⁰)}
//│ def p = [C [C [C p]]]
//│ <<<<<<< after floating out <<<<<<<


// CORRECT: correctly aligned recursive length (using split knot)
fun c1(x1) = if x1 is
  C(a) then c2(a)
fun c2(x2) = if x2 is
  C(b) then c1(b)
let p1 = C(C(C(p2)))
let p2 = C(p1)
c1(p1)
//│ |#fun| |c1|(|x1|)| |#=| |#if| |x1| |is|→|C|(|a|)| |#then| |c2|(|a|)|←|↵|#fun| |c2|(|x2|)| |#=| |#if| |x2| |is|→|C|(|b|)| |#then| |c1|(|b|)|←|↵|#let| |p1| |#=| |C|(|C|(|C|(|p2|)|)|)|↵|#let| |p2| |#=| |C|(|p1|)|↵|c1|(|p1|)|
//│ Parsed: {fun c1 = x1, => if x1 is ‹(C (a,)) then c2 (a,)›; fun c2 = x2, => if x2 is ‹(C (b,)) then c1 (b,)›; let p1 = C (C (C (p2,),),); let p2 = C (p1,); c1 (p1,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c1^19(p1^20)
//│ def c1(x1⁰) = case x1⁰ of {
//│ 	C a⁰ => c2^2(a⁰)}
//│ def c2(x2⁰) = case x2⁰ of {
//│ 	C b⁰ => c1^8(b⁰)}
//│ def p1 = [C [C [C p2^13]]]
//│ def p2 = [C p1^17]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p2]: 14 --->
//│ 	case x1⁰ of {C a⁰ => c2(a⁰)}: 5
//│ [C [C p2]]: 15 --->
//│ 	case x2⁰ of {C b⁰ => c1(b⁰)}: 11
//│ [C [C [C p2]]]: 16 --->
//│ 	case x1⁰ of {C a⁰ => c2(a⁰)}: 5
//│ [C p1]: 18 --->
//│ 	case x2⁰ of {C b⁰ => c1(b⁰)}: 11
//│ ------------------
//│ case x1⁰ of {C a⁰ => c2(a⁰)}: 5 --->
//│ 	[C p2]: 14
//│ 	[C [C [C p2]]]: 16
//│ case x2⁰ of {C b⁰ => c1(b⁰)}: 11 --->
//│ 	[C [C p2]]: 15
//│ 	[C p1]: 18
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C p2]: 14 --->
//│ 	case x1⁰ of {C a⁰ => c2(a⁰)}: 5
//│ [C [C p2]]: 15 --->
//│ 	case x2⁰ of {C b⁰ => c1(b⁰)}: 11
//│ [C [C [C p2]]]: 16 --->
//│ 	case x1⁰ of {C a⁰ => c2(a⁰)}: 5
//│ [C p1]: 18 --->
//│ 	case x2⁰ of {C b⁰ => c1(b⁰)}: 11
//│ ------------------
//│ case x1⁰ of {C a⁰ => c2(a⁰)}: 5 --->
//│ 	[C p2]: 14
//│ 	[C [C [C p2]]]: 16
//│ case x2⁰ of {C b⁰ => c1(b⁰)}: 11 --->
//│ 	[C [C p2]]: 15
//│ 	[C p1]: 18
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c1(p1)
//│ def c1(x1¹) = x1¹(99)
//│ def c2(x2¹) = x2¹(99)
//│ def p1 = 
//│ 	let a¹ = 	
//│ 		let b¹ = 	
//│ 			let a² = p2
//│ 			in (fun _lh_dummy² -> c2(a²))
//│ 		in (fun _lh_dummy¹ -> c1(b¹))
//│ 	in (fun _lh_dummy⁰ -> c2(a¹))
//│ def p2 = 
//│ 	let b² = p1
//│ 	in (fun _lh_dummy³ -> c1(b²))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ c2, c1
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ p1 -> 0
//│ p2 -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ p1(99)
//│ def c1(x1⁰) = x1⁰(99)
//│ def c2(x2⁰) = x2⁰(99)
//│ def p1 = 
//│ 	let a⁰ = 	
//│ 		let b⁰ = 	
//│ 			let a¹ = p2
//│ 			in (fun _lh_dummy⁰ -> a¹(99))
//│ 		in (fun _lh_dummy¹ -> b⁰(99))
//│ 	in (fun _lh_dummy² -> a⁰(99))
//│ def p2 = 
//│ 	let b¹ = p1
//│ 	in (fun _lh_dummy³ -> b¹(99))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ p1(99)
//│ def c1(x1⁰) = x1⁰(99)
//│ def c2(x2⁰) = x2⁰(99)
//│ def p1 = 
//│ 	let a⁰ = 	
//│ 		let b⁰ = 	
//│ 			let a¹ = p2
//│ 			in (fun _lh_dummy⁰ -> a¹(99))
//│ 		in (fun _lh_dummy¹ -> b⁰(99))
//│ 	in (fun _lh_dummy² -> a⁰(99))
//│ def p2 = 
//│ 	let b¹ = p1
//│ 	in (fun _lh_dummy³ -> b¹(99))
//│ <<<<<<< after floating out <<<<<<<


// CORRECT:
let rec p = C(p)
fun c(x) = if x is
  C(a) then c(a)
fun main(cc) = cc(p)
main(c)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|cc|)| |#=| |cc|(|p|)|↵|main|(|c|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = cc, => cc (p,); main (c,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^13(c^14)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => c^4(a⁰)}
//│ def main(cc⁰) = cc⁰(p^10)
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p]: 2 --->
//│ 	case x⁰ of {C a⁰ => c(a⁰)}: 7
//│ ------------------
//│ case x⁰ of {C a⁰ => c(a⁰)}: 7 --->
//│ 	[C p]: 2
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C p]: 2 --->
//│ 	case x⁰ of {C a⁰ => c(a⁰)}: 7
//│ ------------------
//│ case x⁰ of {C a⁰ => c(a⁰)}: 7 --->
//│ 	[C p]: 2
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main(c)
//│ def c(x¹) = x¹(99)
//│ def main(cc¹) = cc¹(p)
//│ def p = 
//│ 	let a¹ = p
//│ 	in (fun _lh_dummy⁰ -> c(a¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ c
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ p -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ main(c)
//│ def c(x⁰) = x⁰(99)
//│ def main(cc⁰) = cc⁰(p)
//│ def p = 
//│ 	let a⁰ = p
//│ 	in (fun _lh_dummy⁰ -> a⁰(99))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ main(c)
//│ def c(x⁰) = x⁰(99)
//│ def main(cc⁰) = cc⁰(p)
//│ def p = 
//│ 	let a⁰ = p
//│ 	in (fun _lh_dummy⁰ -> a⁰(99))
//│ <<<<<<< after floating out <<<<<<<


// CORRECT:
let rec p = C(p)
fun c(x) = if x is
  C(a) then c(a)
fun main(pp) = if pp is
  C(b) then if b is
    C(d) then c(d)
main(p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|pp|)| |#=| |#if| |pp| |is|→|C|(|b|)| |#then| |#if| |b| |is|→|C|(|d|)| |#then| |c|(|d|)|←|←|↵|main|(|p|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = pp, => if pp is ‹(C (b,)) then if b is ‹(C (d,)) then c (d,)››; main (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^17(p^18)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => c^4(a⁰)}
//│ def main(pp⁰) = case pp⁰ of {
//│ 	C b⁰ => case b⁰ of {
//│ 		C d⁰ => c^11(d⁰)}}
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p]: 2 --->
//│ 	case x⁰ of {C a⁰ => c(a⁰)}: 7
//│ 	case b⁰ of {C d⁰ => c(d⁰)}: 14
//│ 	case pp⁰ of {C b⁰ => case b⁰ of {C d⁰ => c(d⁰)}}: 15
//│ ------------------
//│ case x⁰ of {C a⁰ => c(a⁰)}: 7 --->
//│ 	[C p]: 2
//│ case b⁰ of {C d⁰ => c(d⁰)}: 14 --->
//│ 	[C p]: 2
//│ case pp⁰ of {C b⁰ => case b⁰ of {C d⁰ => c(d⁰)}}: 15 --->
//│ 	[C p]: 2
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main(p)
//│ def c(x¹) = case x¹ of {
//│ 	C a⁰ => c(a⁰)}
//│ def main(pp¹) = case pp¹ of {
//│ 	C b⁰ => case b⁰ of {
//│ 		C d⁰ => c(d⁰)}}
//│ def p = [C p]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ main(p)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => c(a⁰)}
//│ def main(pp⁰) = case pp⁰ of {
//│ 	C b⁰ => case b⁰ of {
//│ 		C d⁰ => c(d⁰)}}
//│ def p = [C p]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ main(p)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => c(a⁰)}
//│ def main(pp⁰) = case pp⁰ of {
//│ 	C b⁰ => case b⁰ of {
//│ 		C d⁰ => c(d⁰)}}
//│ def p = [C p]
//│ <<<<<<< after floating out <<<<<<<

// CORRECT:
let rec p = C(p)
let c(x) = if x is
  C(a) then c(a)
fun main(cc, pp) = cc(pp)
main(c, p)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#let| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |main|(|cc|,| |pp|)| |#=| |cc|(|pp|)|↵|main|(|c|,| |p|)|
//│ Parsed: {let rec p = C (p,); let c = x, => if x is ‹(C (a,)) then c (a,)›; fun main = cc, pp, => cc (pp,); main (c, p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^14(c^15, p^17)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => c^4(a⁰)}
//│ def main(cc⁰, pp⁰) = cc⁰(pp⁰)
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p]: 2 --->
//│ 	case x⁰ of {C a⁰ => c(a⁰)}: 7
//│ ------------------
//│ case x⁰ of {C a⁰ => c(a⁰)}: 7 --->
//│ 	[C p]: 2
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C p]: 2 --->
//│ 	case x⁰ of {C a⁰ => c(a⁰)}: 7
//│ ------------------
//│ case x⁰ of {C a⁰ => c(a⁰)}: 7 --->
//│ 	[C p]: 2
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main(c, p)
//│ def c(x¹) = x¹(99)
//│ def main(cc¹, pp¹) = cc¹(pp¹)
//│ def p = 
//│ 	let a¹ = p
//│ 	in (fun _lh_dummy⁰ -> c(a¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ c
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ p -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ main(c, p)
//│ def c(x⁰) = x⁰(99)
//│ def main(cc⁰, pp⁰) = cc⁰(pp⁰)
//│ def p = 
//│ 	let a⁰ = p
//│ 	in (fun _lh_dummy⁰ -> a⁰(99))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ main(c, p)
//│ def c(x⁰) = x⁰(99)
//│ def main(cc⁰, pp⁰) = cc⁰(pp⁰)
//│ def p = 
//│ 	let a⁰ = p
//│ 	in (fun _lh_dummy⁰ -> a⁰(99))
//│ <<<<<<< after floating out <<<<<<<


// CORRECT:
fun cons(y) = if y is
  C(aa) then cons(aa)
fun a(x) = b(x)
fun b(x) = c(x)
fun c(x) = d(cons, x)
fun d(cc, x) = cc(x)
let p = C(p)
a(p)
//│ |#fun| |cons|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |cons|(|aa|)|←|↵|#fun| |a|(|x|)| |#=| |b|(|x|)|↵|#fun| |b|(|x|)| |#=| |c|(|x|)|↵|#fun| |c|(|x|)| |#=| |d|(|cons|,| |x|)|↵|#fun| |d|(|cc|,| |x|)| |#=| |cc|(|x|)|↵|#let| |p| |#=| |C|(|p|)|↵|a|(|p|)|
//│ Parsed: {fun cons = y, => if y is ‹(C (aa,)) then cons (aa,)›; fun a = x, => b (x,); fun b = x, => c (x,); fun c = x, => d (cons, x,); fun d = cc, x, => cc (x,); let p = C (p,); a (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ a^28(p^29)
//│ def a(x⁰) = b^7(x⁰)
//│ def b(x¹) = c^11(x¹)
//│ def c(x²) = d^15(cons^16, x²)
//│ def cons(y⁰) = case y⁰ of {
//│ 	C aa⁰ => cons^2(aa⁰)}
//│ def d(cc⁰, x³) = cc⁰(x³)
//│ def p = [C p^26]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p]: 27 --->
//│ 	case y⁰ of {C aa⁰ => cons(aa⁰)}: 5
//│ ------------------
//│ case y⁰ of {C aa⁰ => cons(aa⁰)}: 5 --->
//│ 	[C p]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C p]: 27 --->
//│ 	case y⁰ of {C aa⁰ => cons(aa⁰)}: 5
//│ ------------------
//│ case y⁰ of {C aa⁰ => cons(aa⁰)}: 5 --->
//│ 	[C p]: 27
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ a(p)
//│ def a(x⁵) = b(x⁵)
//│ def b(x⁴) = c(x⁴)
//│ def c(x⁶) = d(cons, x⁶)
//│ def cons(y¹) = y¹(99)
//│ def d(cc¹, x⁷) = cc¹(x⁷)
//│ def p = 
//│ 	let aa¹ = p
//│ 	in (fun _lh_dummy⁰ -> cons(aa¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ cons
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ p -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ a(p)
//│ def a(x¹) = b(x¹)
//│ def b(x⁰) = c(x⁰)
//│ def c(x²) = d(cons, x²)
//│ def cons(y⁰) = y⁰(99)
//│ def d(cc⁰, x³) = cc⁰(x³)
//│ def p = 
//│ 	let aa⁰ = p
//│ 	in (fun _lh_dummy⁰ -> aa⁰(99))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ a(p)
//│ def a(x¹) = b(x¹)
//│ def b(x⁰) = c(x⁰)
//│ def c(x²) = d(cons, x²)
//│ def cons(y⁰) = y⁰(99)
//│ def d(cc⁰, x³) = cc⁰(x³)
//│ def p = 
//│ 	let aa⁰ = p
//│ 	in (fun _lh_dummy⁰ -> aa⁰(99))
//│ <<<<<<< after floating out <<<<<<<


// CORRECT: `main` consumes one C, `c2` then recursively consumes one C at a time
let rec p = C(p)
fun c(x) = if x is
  C(a) then a
fun c1(xx) = if xx is
  C(aa) then aa
fun c2(z) = if z is
  C(b) then c2(b)
let main = c(p)
fun id(y) = c1(C(y))
c2(id(main))
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |a|←|↵|#fun| |c1|(|xx|)| |#=| |#if| |xx| |is|→|C|(|aa|)| |#then| |aa|←|↵|#fun| |c2|(|z|)| |#=| |#if| |z| |is|→|C|(|b|)| |#then| |c2|(|b|)|←|↵|#let| |main| |#=| |c|(|p|)|↵|#fun| |id|(|y|)| |#=| |c1|(|C|(|y|)|)|↵|c2|(|id|(|main|)|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then a›; fun c1 = xx, => if xx is ‹(C (aa,)) then aa›; fun c2 = z, => if z is ‹(C (b,)) then c2 (b,)›; let main = c (p,); fun id = y, => c1 (C (y,),); c2 (id (main,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c2^25(id^26(main^27))
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => a⁰}
//│ def c1(xx⁰) = case xx⁰ of {
//│ 	C aa⁰ => aa⁰}
//│ def c2(z⁰) = case z⁰ of {
//│ 	C b⁰ => c2^12(b⁰)}
//│ def id(y⁰) = c1^20([C y⁰])
//│ def main = c^17(p^18)
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p]: 2 --->
//│ 	case x⁰ of {C a⁰ => a⁰}: 5
//│ 	case z⁰ of {C b⁰ => c2(b⁰)}: 15
//│ [C y⁰]: 22 --->
//│ 	case xx⁰ of {C aa⁰ => aa⁰}: 9
//│ ------------------
//│ case x⁰ of {C a⁰ => a⁰}: 5 --->
//│ 	[C p]: 2
//│ case xx⁰ of {C aa⁰ => aa⁰}: 9 --->
//│ 	[C y⁰]: 22
//│ case z⁰ of {C b⁰ => c2(b⁰)}: 15 --->
//│ 	[C p]: 2
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C y⁰]: 22 --->
//│ 	case xx⁰ of {C aa⁰ => aa⁰}: 9
//│ ------------------
//│ case xx⁰ of {C aa⁰ => aa⁰}: 9 --->
//│ 	[C y⁰]: 22
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c2(id(main))
//│ def c(x¹) = case x¹ of {
//│ 	C a⁰ => a⁰}
//│ def c1(xx¹) = xx¹
//│ def c2(z¹) = case z¹ of {
//│ 	C b⁰ => c2(b⁰)}
//│ def id(y¹) = c1(
//│ 	let aa¹ = y¹
//│ 	in aa¹)
//│ def main = c(p)
//│ def p = [C p]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ c1
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ id -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ c2(id(main))
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => a⁰}
//│ def c1(xx⁰) = xx⁰
//│ def c2(z⁰) = case z⁰ of {
//│ 	C b⁰ => c2(b⁰)}
//│ def id(y⁰) = 
//│ 	let aa⁰ = y⁰
//│ 	in aa⁰
//│ def main = c(p)
//│ def p = [C p]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ c2(id(main))
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => a⁰}
//│ def c1(xx⁰) = xx⁰
//│ def c2(z⁰) = case z⁰ of {
//│ 	C b⁰ => c2(b⁰)}
//│ def id(y⁰) = 
//│ 	let aa⁰ = y⁰
//│ 	in aa⁰
//│ def main = c(p)
//│ def p = [C p]
//│ <<<<<<< after floating out <<<<<<<
