:NewParser
:ParseOnly

// original one with all parameters provided: can tie the good knot and everything fused
_LUMBERHACK_EVAL
fun max(ls, n) = if ls is
  C(h, t) then if h > n then max(t, h) else max(t, n)
  N then n
max(C(1, C(2, N)), 0)
//│ |_LUMBERHACK_EVAL|↵|#fun| |max|(|ls|,| |n|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |>| |n| |#then| |max|(|t|,| |h|)| |#else| |max|(|t|,| |n|)|↵|N| |#then| |n|←|↵|max|(|C|(|1|,| |C|(|2|,| |N|)|)|,| |0|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun max = ls, n, => if ls is ‹(C (h, t,)) then if (> (h,) (n,)) then max (t, h,) else max (t, n,); (N) then n›; max (C (1, C (2, N,),), 0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ max^22([C 1 [C 2 [N]]], 0)
//│ def max(ls⁰, n⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if (h⁰ > n⁰) then max^7(t⁰, h⁰) else max^12(t⁰, n⁰)
//│ 	| N  => n⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 2
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 25 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19
//│ [C 2 [N]]: 26 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19
//│ [C 1 [C 2 [N]]]: 27 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19 --->
//│ 	[N]: 25
//│ 	[C 2 [N]]: 26
//│ 	[C 1 [C 2 [N]]]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 25 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19
//│ [C 2 [N]]: 26 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19
//│ [C 1 [C 2 [N]]]: 27 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19 --->
//│ 	[N]: 25
//│ 	[C 2 [N]]: 26
//│ 	[C 1 [C 2 [N]]]: 27
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ max(
//│ 	let t¹ = 	
//│ 		let t² = (fun n³ -> n³)
//│ 		in let h² = 2
//│ 		in (fun n² -> if (h² > n²) then max(t², h²) else max(t², n²))
//│ 	in let h¹ = 1
//│ 	in (fun n¹ -> if (h¹ > n¹) then max(t¹, h¹) else max(t¹, n¹)), 0)
//│ def max(ls¹, n⁴) = ls¹(n⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 2
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ max
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun n⁰ -> n⁰)
//│ 		in let h⁰ = 2
//│ 		in (fun n¹ -> if (h⁰ > n¹) then t¹(h⁰) else t¹(n¹))
//│ 	in let h¹ = 1
//│ 	in (fun n² -> if (h¹ > n²) then t⁰(h¹) else t⁰(n²))(0)
//│ def max(ls⁰, n³) = ls⁰(n³)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun n⁰ -> n⁰)
//│ 		in let h⁰ = 2
//│ 		in (fun n¹ -> if (h⁰ > n¹) then t¹(h⁰) else t¹(n¹))
//│ 	in let h¹ = 1
//│ 	in (fun n² -> if (h¹ > n²) then t⁰(h¹) else t⁰(n²))(0)
//│ def max(ls⁰, n³) = ls⁰(n³)
//│ <<<<<<< after floating out <<<<<<<


// original max with the initial `n` not provided: excessive expansion and no fusion due to strategy clash
_LUMBERHACK_EVAL
fun max(ls, n) = if ls is
  C(h, t) then if h > n then max(t, h) else max(t, n)
  N then n
max(C(1, C(2, N)), primId(0))
//│ |_LUMBERHACK_EVAL|↵|#fun| |max|(|ls|,| |n|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |>| |n| |#then| |max|(|t|,| |h|)| |#else| |max|(|t|,| |n|)|↵|N| |#then| |n|←|↵|max|(|C|(|1|,| |C|(|2|,| |N|)|)|,| |primId|(|0|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun max = ls, n, => if ls is ‹(C (h, t,)) then if (> (h,) (n,)) then max (t, h,) else max (t, n,); (N) then n›; max (C (1, C (2, N,),), primId (0,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ max^22([C 1 [C 2 [N]]], primId⁰(0))
//│ def max(ls⁰, n⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if (h⁰ > n⁰) then max^7(t⁰, h⁰) else max^12(t⁰, n⁰)
//│ 	| N  => n⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 2
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 25 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19
//│ [C 2 [N]]: 26 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19
//│ [C 1 [C 2 [N]]]: 27 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19 --->
//│ 	[N]: 25
//│ 	[C 2 [N]]: 26
//│ 	[C 1 [C 2 [N]]]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 25 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19
//│ [C 2 [N]]: 26 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19
//│ [C 1 [C 2 [N]]]: 27 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰) | N  => n⁰}: 19 --->
//│ 	[N]: 25
//│ 	[C 2 [N]]: 26
//│ 	[C 1 [C 2 [N]]]: 27
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ max(
//│ 	let t¹ = 	
//│ 		let t² = (fun n³ -> n³)
//│ 		in let h² = 2
//│ 		in (fun n² -> if (h² > n²) then max(t², h²) else max(t², n²))
//│ 	in let h¹ = 1
//│ 	in (fun n¹ -> if (h¹ > n¹) then max(t¹, h¹) else max(t¹, n¹)), primId⁰(0))
//│ def max(ls¹, n⁴) = ls¹(n⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 2
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ max
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun n⁰ -> n⁰)
//│ 		in let h⁰ = 2
//│ 		in (fun n¹ -> if (h⁰ > n¹) then t¹(h⁰) else t¹(n¹))
//│ 	in let h¹ = 1
//│ 	in (fun n² -> if (h¹ > n²) then t⁰(h¹) else t⁰(n²))(primId⁰(0))
//│ def max(ls⁰, n³) = ls⁰(n³)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun n⁰ -> n⁰)
//│ 		in let h⁰ = 2
//│ 		in (fun n¹ -> if (h⁰ > n¹) then t¹(h⁰) else t¹(n¹))
//│ 	in let h¹ = 1
//│ 	in (fun n² -> if (h¹ > n²) then t⁰(h¹) else t⁰(n²))(primId⁰(0))
//│ def max(ls⁰, n³) = ls⁰(n³)
//│ <<<<<<< after floating out <<<<<<<


// original max with the initial list provided as primitive: excessive expansion
_LUMBERHACK_EVAL
fun max(ls, n) = if ls is
  C(h, t) then if h > n then max(t, h) else max(t, n)
  N then n
max(primId(C(1, C(2, N))), 0)
//│ |_LUMBERHACK_EVAL|↵|#fun| |max|(|ls|,| |n|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |>| |n| |#then| |max|(|t|,| |h|)| |#else| |max|(|t|,| |n|)|↵|N| |#then| |n|←|↵|max|(|primId|(|C|(|1|,| |C|(|2|,| |N|)|)|)|,| |0|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun max = ls, n, => if ls is ‹(C (h, t,)) then if (> (h,) (n,)) then max (t, h,) else max (t, n,); (N) then n›; max (primId (C (1, C (2, N,),),), 0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ max^22(primId⁰([C 1 [C 2 [N]]]), 0)
//│ def max(ls⁰, n⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if (h⁰ > n⁰) then max^7(t⁰, h⁰) else max^12(t⁰, n⁰)
//│ 	| N  => n⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 2
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ max(primId⁰([C 1 [C 2 [N]]]), 0)
//│ def max(ls¹, n¹) = case ls¹ of {
//│ 	C h⁰ t⁰ => if (h⁰ > n¹) then max(t⁰, h⁰) else max(t⁰, n¹)
//│ 	| N  => n¹}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 2
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ max(primId⁰([C 1 [C 2 [N]]]), 0)
//│ def max(ls⁰, n⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰)
//│ 	| N  => n⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ max(primId⁰([C 1 [C 2 [N]]]), 0)
//│ def max(ls⁰, n⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰)
//│ 	| N  => n⁰}
//│ <<<<<<< after floating out <<<<<<<

// original max with nothing provided (equivalent to provide all parameters as NoProd): can tie the good knot
_LUMBERHACK_EVAL
fun max(ls, n) = if ls is
  C(h, t) then if h > n then max(t, h) else max(t, n)
  N then n
max(primId(C(1, C(2, N))), primId(0))
//│ |_LUMBERHACK_EVAL|↵|#fun| |max|(|ls|,| |n|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |>| |n| |#then| |max|(|t|,| |h|)| |#else| |max|(|t|,| |n|)|↵|N| |#then| |n|←|↵|max|(|primId|(|C|(|1|,| |C|(|2|,| |N|)|)|)|,| |primId|(|0|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun max = ls, n, => if ls is ‹(C (h, t,)) then if (> (h,) (n,)) then max (t, h,) else max (t, n,); (N) then n›; max (primId (C (1, C (2, N,),),), primId (0,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ max^22(primId⁰([C 1 [C 2 [N]]]), primId⁰(0))
//│ def max(ls⁰, n⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if (h⁰ > n⁰) then max^7(t⁰, h⁰) else max^12(t⁰, n⁰)
//│ 	| N  => n⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 2
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ max(primId⁰([C 1 [C 2 [N]]]), primId⁰(0))
//│ def max(ls¹, n¹) = case ls¹ of {
//│ 	C h⁰ t⁰ => if (h⁰ > n¹) then max(t⁰, h⁰) else max(t⁰, n¹)
//│ 	| N  => n¹}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 2
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ max(primId⁰([C 1 [C 2 [N]]]), primId⁰(0))
//│ def max(ls⁰, n⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰)
//│ 	| N  => n⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ max(primId⁰([C 1 [C 2 [N]]]), primId⁰(0))
//│ def max(ls⁰, n⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if (h⁰ > n⁰) then max(t⁰, h⁰) else max(t⁰, n⁰)
//│ 	| N  => n⁰}
//│ <<<<<<< after floating out <<<<<<<
