:NewParser
:ParseOnly

fun filter(ls, f) = if ls is
  C(h, t) then if f(h) then C(h, filter(t, f)) else filter(t, f)
  N then N
fun lastDrive(ls) = if ls is
  C(h, t) then Some(last(t, h))
  N then None
fun last(a, ls) = if ls is
  N then a
  C(h, t) then last(h, t)
fun lastFilter(ls, f) = lastDrive(filter(ls, f))
lastFilter
//│ |#fun| |filter|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |C|(|h|,| |filter|(|t|,| |f|)|)| |#else| |filter|(|t|,| |f|)|↵|N| |#then| |N|←|↵|#fun| |lastDrive|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |Some|(|last|(|t|,| |h|)|)|↵|N| |#then| |None|←|↵|#fun| |last|(|a|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a|↵|C|(|h|,| |t|)| |#then| |last|(|h|,| |t|)|←|↵|#fun| |lastFilter|(|ls|,| |f|)| |#=| |lastDrive|(|filter|(|ls|,| |f|)|)|↵|lastFilter|
//│ Parsed: {fun filter = ls, f, => if ls is ‹(C (h, t,)) then if (f (h,)) then C (h, filter (t, f,),) else filter (t, f,); (N) then N›; fun lastDrive = ls, => if ls is ‹(C (h, t,)) then Some (last (t, h,),); (N) then None›; fun last = a, ls, => if ls is ‹(N) then a; (C (h, t,)) then last (h, t,)›; fun lastFilter = ls, f, => lastDrive (filter (ls, f,),); lastFilter}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastFilter^51
//│ def filter(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter^6(t⁰, f⁰)] else filter^12(t⁰, f⁰)
//│ 	| N  => [N]}
//│ def last(a⁰, ls²) = case ls² of {
//│ 	N  => a⁰
//│ 	| C h² t² => last^34(h², t²)}
//│ def lastDrive(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => [Some last^23(t¹, h¹)]
//│ 	| N  => [None]}
//│ def lastFilter(ls³, f¹) = lastDrive^42(filter^43(ls³, f¹))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ filter(t⁰, f⁰)]: 11 --->
//│ 	NoCons
//│ 	case ls¹ of {C h¹ t¹ => [Some last(t¹, h¹)] | N  => [None]}: 30
//│ [N]: 18 --->
//│ 	NoCons
//│ 	case ls¹ of {C h¹ t¹ => [Some last(t¹, h¹)] | N  => [None]}: 30
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [Some last(t¹, h¹)] | N  => [None]}: 30 --->
//│ 	[C h⁰ filter(t⁰, f⁰)]: 11
//│ 	[N]: 18
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastFilter
//│ def filter(ls⁴, f²) = case ls⁴ of {
//│ 	C h⁰ t⁰ => if f²(h⁰) then [C h⁰ filter(t⁰, f²)] else filter(t⁰, f²)
//│ 	| N  => [N]}
//│ def last(a¹, ls⁶) = case ls⁶ of {
//│ 	N  => a¹
//│ 	| C h² t² => last(h², t²)}
//│ def lastDrive(ls⁵) = case ls⁵ of {
//│ 	C h¹ t¹ => [Some last(t¹, h¹)]
//│ 	| N  => [None]}
//│ def lastFilter(ls⁷, f³) = lastDrive(filter(ls⁷, f³))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ lastFilter
//│ def filter(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter(t⁰, f⁰)] else filter(t⁰, f⁰)
//│ 	| N  => [N]}
//│ def last(a⁰, ls²) = case ls² of {
//│ 	N  => a⁰
//│ 	| C h² t² => last(h², t²)}
//│ def lastDrive(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => [Some last(t¹, h¹)]
//│ 	| N  => [None]}
//│ def lastFilter(ls³, f¹) = lastDrive(filter(ls³, f¹))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ lastFilter
//│ def filter(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter(t⁰, f⁰)] else filter(t⁰, f⁰)
//│ 	| N  => [N]}
//│ def last(a⁰, ls²) = case ls² of {
//│ 	N  => a⁰
//│ 	| C h² t² => last(h², t²)}
//│ def lastDrive(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => [Some last(t¹, h¹)]
//│ 	| N  => [None]}
//│ def lastFilter(ls³, f¹) = lastDrive(filter(ls³, f¹))
//│ <<<<<<< after floating out <<<<<<<
