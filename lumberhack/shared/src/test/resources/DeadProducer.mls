:NewParser
:ParseOnly

// dead branch causes dead producer, which causes problem
// can be fixed by elminating dead branches, or blocking fusion when encountering
// dead producers
:lhGenOCaml
:d
fun main(x) = if x is
  C(t) then G
  n then if n is
    C(t) then if True then g(t) else h(t) // dead branch, DeadCodeCons <: 't
    N then G
fun g(x) = if x is
  N then g(C(N)) // this C(x) is fused, making g'(x) = x(99)
  C(t) then G
fun h(x) = if x is
  N then H
  C(t) then H
main(N)
//│ |#fun| |main|(|x|)| |#=| |#if| |x| |is|→|C|(|t|)| |#then| |G|↵|n| |#then| |#if| |n| |is|→|C|(|t|)| |#then| |#if| |True| |#then| |g|(|t|)| |#else| |h|(|t|)| |/* dead branch, DeadCodeCons <: 't*/|↵|N| |#then| |G|←|←|↵|#fun| |g|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |g|(|C|(|N|)|)| |/* this C(x) is fused, making g'(x) = x(99)*/|↵|C|(|t|)| |#then| |G|←|↵|#fun| |h|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |H|↵|C|(|t|)| |#then| |H|←|↵|main|(|N|)|
//│ Parsed: {fun main = x, => if x is ‹(C (t,)) then G; (n) then if n is ‹(C (t,)) then if (True) then g (t,) else h (t,); (N) then G››; fun g = x, => if x is ‹(N) then g (C (N,),); (C (t,)) then G›; fun h = x, => if x is ‹(N) then H; (C (t,)) then H›; main (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^29([N])
//│ def g(x¹) = case x¹ of {
//│ 	N  => g^17([C [N]])
//│ 	| C t² => [G]}
//│ def h(x²) = case x² of {
//│ 	N  => [H]
//│ 	| C t³ => [H]}
//│ def main(x⁰) = case x⁰ of {
//│ 	C t⁰ => [G]
//│ 	| n⁰ => case n⁰ of {
//│ 		C t¹ => if [True] then g^5(t¹) else h^8(t¹)
//│ 		| N  => [G]}}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec g x_1 =
//│ 		  (match x_1 with
//│ 		    | `N -> 
//│ 		      (g (`C((`N))))
//│ 		    | `C(t_2) -> 
//│ 		      (`G));;
//│ 		let rec h x_2 =
//│ 		  (match x_2 with
//│ 		    | `N -> 
//│ 		      (`H)
//│ 		    | `C(t_3) -> 
//│ 		      (`H));;
//│ 		let rec main x_0 =
//│ 		  (match x_0 with
//│ 		    | `C(t_0) -> 
//│ 		      (`G)
//│ 		    | n_0 -> 
//│ 		      (match n_0 with
//│ 		        | `C(t_1) -> 
//│ 		          (if true then
//│ 		            (g t_1)
//│ 		          else
//│ 		            (h t_1))
//│ 		        | `N -> 
//│ 		          (`G)));;
//│ 		(main (`N))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		          val g : [< `C of [> `N ] | `N > `C ] -> [> `G ] = <fun>
//│ 		[ok]
//│ 		            val h : [< `C of 'a | `N ] -> [> `H ] = <fun>
//│ 		[ok]
//│ 		                          val main : [< `C of [< `C of [> `N ] | `N > `C ] | `N > `C ] -> [> `G | `H ] =
//│ 		  <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [N]]: 19 --->
//│ 	case x¹ of {N  => g([C [N]]) | C t² => [G]}: 22
//│ [N]: 30 --->
//│ 	case n⁰ of {C t¹ => if [True] then g(t¹) else h(t¹) | N  => [G]}: 13
//│ 	case x⁰ of {C t⁰ => [G] | n⁰ => case n⁰ of {C t¹ => if [True] then g(t¹) else h(t¹) | N  => [G]}}: 14
//│ ------------------
//│ case n⁰ of {C t¹ => if [True] then g(t¹) else h(t¹) | N  => [G]}: 13 --->
//│ 	[N]: 30
//│ case x⁰ of {C t⁰ => [G] | n⁰ => case n⁰ of {C t¹ => if [True] then g(t¹) else h(t¹) | N  => [G]}}: 14 --->
//│ 	[N]: 30
//│ case x¹ of {N  => g([C [N]]) | C t² => [G]}: 22 --->
//│ 	DeadCodeProd
//│ 	[C [N]]: 19
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main([N])
//│ def g(x⁴) = case x⁴ of {
//│ 	N  => g([C [N]])
//│ 	| C t² => [G]}
//│ def h(x⁵) = case x⁵ of {
//│ 	N  => [H]
//│ 	| C t³ => [H]}
//│ def main(x³) = case x³ of {
//│ 	C t⁰ => [G]
//│ 	| n⁰ => case n⁰ of {
//│ 		C t¹ => if [True] then g(t¹) else h(t¹)
//│ 		| N  => [G]}}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ main :: 'main <: [] ::: true
//│ [N] :: N ::: true
//│ main([N]) :: '3_callres <: [] ::: true
//│ x :: 'x⁰ <: [] ::: true
//│ [G] :: G ::: true
//│ n :: 'n⁰ <: [] ::: true
//│ [True] :: True ::: true
//│ g :: 'g <: [] ::: true
//│ t :: 't¹ <: [] ::: true
//│ g(t) :: '10_callres <: [] ::: true
//│ h :: 'h <: [] ::: true
//│ t :: 't¹ <: [] ::: true
//│ h(t) :: '13_callres <: [] ::: true
//│ if [True] then g(t) else h(t) :: '14_ifres <: [] ::: true
//│ [G] :: G ::: true
//│ case n of {C t => if [True] then g(t) else h(t) | N  => [G]} :: '16_matchres <: [] ::: true
//│ case x of {C t => [G] | n => case n of {C t => if [True] then g(t) else h(t) | N  => [G]}} :: '17_matchres <: [] ::: true
//│ (fun x -> case x of {C t => [G] | n => case n of {C t => if [True] then g(t) else h(t) | N  => [G]}}) :: 'x⁰ => '17_matchres ::: true
//│ x :: 'x¹ <: [] ::: true
//│ g :: 'g <: [] ::: true
//│ [N] :: N ::: true
//│ [C [N]] :: C(N) ::: true
//│ g([C [N]]) :: '23_callres <: [] ::: true
//│ [G] :: G ::: true
//│ case x of {N  => g([C [N]]) | C t => [G]} :: '25_matchres <: [] ::: true
//│ (fun x -> case x of {N  => g([C [N]]) | C t => [G]}) :: 'x¹ => '25_matchres ::: true
//│ x :: 'x² <: [] ::: true
//│ [H] :: H ::: true
//│ [H] :: H ::: true
//│ case x of {N  => [H] | C t => [H]} :: '30_matchres <: [] ::: true
//│ (fun x -> case x of {N  => [H] | C t => [H]}) :: 'x² => '30_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec g x_1 =
//│   (match x_1 with
//│     | `N -> 
//│       (g (`C((`N))))
//│     | `C(t_2) -> 
//│       (`G));;
//│ let rec h x_2 =
//│   (match x_2 with
//│     | `N -> 
//│       (`H)
//│     | `C(t_3) -> 
//│       (`H));;
//│ let rec main x_0 =
//│   (match x_0 with
//│     | `C(t_0) -> 
//│       (`G)
//│     | n_0 -> 
//│       (match n_0 with
//│         | `C(t_1) -> 
//│           (if true then
//│             (g t_1)
//│           else
//│             (h t_1))
//│         | `N -> 
//│           (`G)));;
//│ (main (`N))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│   - : [> `G | `H ] = `G
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


// FIXME: the solution to only eliminate dead branches is not complete and cannot work here
// some deadbranches will not be eliminated and the type-error code is still there
:d
:lhGenOCaml
fun main(x) = if x is
  C(t) then G
  n then hiddenDeadBranch(n)
fun hiddenDeadBranch(n) = if n is
  C(t) then                               // dead branch which is more difficult to detect due to the recursive call below
    let dummy = hiddenDeadBranch(C(t))    // I think recursive calls like this makes tracking dead branches more troublesome... need to be globally flow sensitive?
    if True then g(t) else h(t)           
  N then G                                
fun g(x) = if x is
  N then g(C(N))                          // this C(N) is fused, making fun g'(x) = x(99)
  C(t) then G
fun h(x) = if x is                        // the consumer in h is not fused
  N then H
  C(t) then H
main(N)
//│ |#fun| |main|(|x|)| |#=| |#if| |x| |is|→|C|(|t|)| |#then| |G|↵|n| |#then| |hiddenDeadBranch|(|n|)|←|↵|#fun| |hiddenDeadBranch|(|n|)| |#=| |#if| |n| |is|→|C|(|t|)| |#then| |/* dead branch which is more difficult to detect due to the recursive call below*/|→|#let| |dummy| |#=| |hiddenDeadBranch|(|C|(|t|)|)| |/* I think recursive calls like this makes tracking dead branches more troublesome... need to be globally flow sensitive?*/|↵|#if| |True| |#then| |g|(|t|)| |#else| |h|(|t|)| |←|↵|N| |#then| |G| |←|↵|#fun| |g|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |g|(|C|(|N|)|)| |/* this C(N) is fused, making fun g'(x) = x(99)*/|↵|C|(|t|)| |#then| |G|←|↵|#fun| |h|(|x|)| |#=| |#if| |x| |is| |/* the consumer in h is not fused*/|→|N| |#then| |H|↵|C|(|t|)| |#then| |H|←|↵|main|(|N|)|
//│ Parsed: {fun main = x, => if x is ‹(C (t,)) then G; (n) then hiddenDeadBranch (n,)›; fun hiddenDeadBranch = n, => if n is ‹(C (t,)) then {let dummy = hiddenDeadBranch (C (t,),); if (True) then g (t,) else h (t,)}; (N) then G›; fun g = x, => if x is ‹(N) then g (C (N,),); (C (t,)) then G›; fun h = x, => if x is ‹(N) then H; (C (t,)) then H›; main (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^38([N])
//│ def g(x¹) = case x¹ of {
//│ 	N  => g^26([C [N]])
//│ 	| C t² => [G]}
//│ def h(x²) = case x² of {
//│ 	N  => [H]
//│ 	| C t³ => [H]}
//│ def hiddenDeadBranch(n¹) = case n¹ of {
//│ 	C t¹ => 
//│ 		let dummy⁰ = hiddenDeadBranch^9([C t¹])
//│ 		in if [True] then g^14(t¹) else h^17(t¹)
//│ 	| N  => [G]}
//│ def main(x⁰) = case x⁰ of {
//│ 	C t⁰ => [G]
//│ 	| n⁰ => hiddenDeadBranch^3(n⁰)}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec h x_2 =
//│ 		  (match x_2 with
//│ 		    | `N -> 
//│ 		      (`H)
//│ 		    | `C(t_3) -> 
//│ 		      (`H));;
//│ 		let rec g x_1 =
//│ 		  (match x_1 with
//│ 		    | `N -> 
//│ 		      (g (`C((`N))))
//│ 		    | `C(t_2) -> 
//│ 		      (`G));;
//│ 		let rec hiddenDeadBranch n_1 =
//│ 		  (match n_1 with
//│ 		    | `C(t_1) -> 
//│ 		      (let rec dummy_0 = (hiddenDeadBranch (`C(t_1))) in
//│ 		        (if true then
//│ 		          (g t_1)
//│ 		        else
//│ 		          (h t_1)))
//│ 		    | `N -> 
//│ 		      (`G));;
//│ 		let rec main x_0 =
//│ 		  (match x_0 with
//│ 		    | `C(t_0) -> 
//│ 		      (`G)
//│ 		    | n_0 -> 
//│ 		      (hiddenDeadBranch n_0));;
//│ 		(main (`N))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		          val h : [< `C of 'a | `N ] -> [> `H ] = <fun>
//│ 		[ok]
//│ 		            val g : [< `C of [> `N ] | `N > `C ] -> [> `G ] = <fun>
//│ 		[ok]
//│ 		                    Line 5, characters 15-22:
//│ 		5 |       (let rec dummy_0 = (hiddenDeadBranch (`C(t_1))) in
//│ 		                   ^^^^^^^
//│ 		Warning 26 [unused-var]: unused variable dummy_0.
//│ 		val hiddenDeadBranch :
//│ 		  [< `C of [< `C of [> `N ] | `N > `C ] | `N > `C ] -> [> `G | `H ] = <fun>
//│ 		[ok]
//│ 		            val main : [< `C of [< `C of [> `N ] | `N > `C ] | `N > `C ] -> [> `G | `H ] =
//│ 		  <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C t¹]: 11 --->
//│ 	case n¹ of {C t¹ => let dummy⁰ = hiddenDeadBranch([C t¹])
//│ in if [True] then g(t¹) else h(t¹) | N  => [G]}: 23
//│ [C [N]]: 28 --->
//│ 	case x¹ of {N  => g([C [N]]) | C t² => [G]}: 31
//│ [N]: 39 --->
//│ 	case x⁰ of {C t⁰ => [G] | n⁰ => hiddenDeadBranch(n⁰)}: 6
//│ 	case n¹ of {C t¹ => let dummy⁰ = hiddenDeadBranch([C t¹])
//│ in if [True] then g(t¹) else h(t¹) | N  => [G]}: 23
//│ ------------------
//│ case x⁰ of {C t⁰ => [G] | n⁰ => hiddenDeadBranch(n⁰)}: 6 --->
//│ 	[N]: 39
//│ case n¹ of {C t¹ => let dummy⁰ = hiddenDeadBranch([C t¹])
//│ in if [True] then g(t¹) else h(t¹) | N  => [G]}: 23 --->
//│ 	[C t¹]: 11
//│ 	[N]: 39
//│ case x¹ of {N  => g([C [N]]) | C t² => [G]}: 31 --->
//│ 	DeadCodeProd
//│ 	[C [N]]: 28
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main([N])
//│ def g(x⁴) = case x⁴ of {
//│ 	N  => g([C [N]])
//│ 	| C t² => [G]}
//│ def h(x⁵) = case x⁵ of {
//│ 	N  => [H]
//│ 	| C t³ => [H]}
//│ def hiddenDeadBranch(n²) = case n² of {
//│ 	C t¹ => 
//│ 		let dummy¹ = hiddenDeadBranch([C t¹])
//│ 		in if [True] then g(t¹) else h(t¹)
//│ 	| N  => [G]}
//│ def main(x³) = case x³ of {
//│ 	C t⁰ => [G]
//│ 	| n⁰ => hiddenDeadBranch(n⁰)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ main :: 'main <: [] ::: true
//│ [N] :: N ::: true
//│ main([N]) :: '3_callres <: [] ::: true
//│ x :: 'x⁰ <: [] ::: true
//│ [G] :: G ::: true
//│ hiddenDeadBranch :: 'hiddenDeadBranch <: [] ::: true
//│ n :: 'n⁰ <: [] ::: true
//│ hiddenDeadBranch(n) :: '8_callres <: [] ::: true
//│ case x of {C t => [G] | n => hiddenDeadBranch(n)} :: '9_matchres <: [] ::: true
//│ (fun x -> case x of {C t => [G] | n => hiddenDeadBranch(n)}) :: 'x⁰ => '9_matchres ::: true
//│ n :: 'n¹ <: [] ::: true
//│ hiddenDeadBranch :: 'hiddenDeadBranch <: [] ::: true
//│ t :: 't¹ <: [] ::: true
//│ [C t] :: C('t¹) ::: true
//│ hiddenDeadBranch([C t]) :: '15_callres <: [] ::: true
//│ [True] :: True ::: true
//│ g :: 'g <: [] ::: true
//│ t :: 't¹ <: [] ::: true
//│ g(t) :: '19_callres <: [] ::: true
//│ h :: 'h <: [] ::: true
//│ t :: 't¹ <: [] ::: true
//│ h(t) :: '22_callres <: [] ::: true
//│ if [True] then g(t) else h(t) :: '23_ifres <: [] ::: true
//│ let dummy = hiddenDeadBranch([C t])
//│ in if [True] then g(t) else h(t) :: '23_ifres <: [] ::: true
//│ [G] :: G ::: true
//│ case n of {C t => let dummy = hiddenDeadBranch([C t])
//│ in if [True] then g(t) else h(t) | N  => [G]} :: '26_matchres <: [] ::: true
//│ (fun n -> case n of {C t => let dummy = hiddenDeadBranch([C t])
//│ in if [True] then g(t) else h(t) | N  => [G]}) :: 'n¹ => '26_matchres ::: true
//│ x :: 'x¹ <: [] ::: true
//│ g :: 'g <: [] ::: true
//│ [N] :: N ::: true
//│ [C [N]] :: C(N) ::: true
//│ g([C [N]]) :: '32_callres <: [] ::: true
//│ [G] :: G ::: true
//│ case x of {N  => g([C [N]]) | C t => [G]} :: '34_matchres <: [] ::: true
//│ (fun x -> case x of {N  => g([C [N]]) | C t => [G]}) :: 'x¹ => '34_matchres ::: true
//│ x :: 'x² <: [] ::: true
//│ [H] :: H ::: true
//│ [H] :: H ::: true
//│ case x of {N  => [H] | C t => [H]} :: '39_matchres <: [] ::: true
//│ (fun x -> case x of {N  => [H] | C t => [H]}) :: 'x² => '39_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec g x_1 =
//│   (match x_1 with
//│     | `N -> 
//│       (g (`C((`N))))
//│     | `C(t_2) -> 
//│       (`G));;
//│ let rec h x_2 =
//│   (match x_2 with
//│     | `N -> 
//│       (`H)
//│     | `C(t_3) -> 
//│       (`H));;
//│ let rec hiddenDeadBranch n_1 =
//│   (match n_1 with
//│     | `C(t_1) -> 
//│       (let rec dummy_0 = (hiddenDeadBranch (`C(t_1))) in
//│         (if true then
//│           (g t_1)
//│         else
//│           (h t_1)))
//│     | `N -> 
//│       (`G));;
//│ let rec main x_0 =
//│   (match x_0 with
//│     | `C(t_0) -> 
//│       (`G)
//│     | n_0 -> 
//│       (hiddenDeadBranch n_0));;
//│ (main (`N))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│   - : [> `G | `H ] = `G
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


// FIXME: the solution to only eliminate dead branches is not complete and cannot work here
// some deadbranches will not be eliminated and the type-error code is still there
:lhGenOCaml
:d
fun break(p, ls) = if ls is
  N then P(N, N)
  C(x, xs) then if p(x) then P(N, C(x, xs)) else if break1(p, xs) is
    P(ys, zs) then P(C(x, ys), zs)
fun break1(p, ls) = if ls is
  N then P(N, N)
  C(x, xs) then if p(x) then P(N, C(x, xs)) else if break1(p, xs) is
    P(ys, zs) then P(C(x, ys), zs)
fun words(s) =
  let scrut = dropWhile(x => x == 1, s)
  if scrut is
    N then N
    _ then if break(x => x == 1, scrut) is
      P(w, s'') then C(w, words(s''))
fun dropWhile(f, ls) = if ls is
  N then N
  C(h, t) then if f(h) then dropWhile(f, t) else C(h, t)
words(C(2, C(1, C(2, C(1, C(2, N))))))
//│ |#fun| |break|(|p|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |P|(|N|,| |N|)|↵|C|(|x|,| |xs|)| |#then| |#if| |p|(|x|)| |#then| |P|(|N|,| |C|(|x|,| |xs|)|)| |#else| |#if| |break1|(|p|,| |xs|)| |is|→|P|(|ys|,| |zs|)| |#then| |P|(|C|(|x|,| |ys|)|,| |zs|)|←|←|↵|#fun| |break1|(|p|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |P|(|N|,| |N|)|↵|C|(|x|,| |xs|)| |#then| |#if| |p|(|x|)| |#then| |P|(|N|,| |C|(|x|,| |xs|)|)| |#else| |#if| |break1|(|p|,| |xs|)| |is|→|P|(|ys|,| |zs|)| |#then| |P|(|C|(|x|,| |ys|)|,| |zs|)|←|←|↵|#fun| |words|(|s|)| |#=|→|#let| |scrut| |#=| |dropWhile|(|x| |=>| |x| |==| |1|,| |s|)|↵|#if| |scrut| |is|→|N| |#then| |N|↵|_| |#then| |#if| |break|(|x| |=>| |x| |==| |1|,| |scrut|)| |is|→|P|(|w|,| |s''|)| |#then| |C|(|w|,| |words|(|s''|)|)|←|←|←|↵|#fun| |dropWhile|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |dropWhile|(|f|,| |t|)| |#else| |C|(|h|,| |t|)|←|↵|words|(|C|(|2|,| |C|(|1|,| |C|(|2|,| |C|(|1|,| |C|(|2|,| |N|)|)|)|)|)|)|
//│ Parsed: {fun break = p, ls, => if ls is ‹(N) then P (N, N,); (C (x, xs,)) then if (p (x,)) then P (N, C (x, xs,),) else if break1 (p, xs,) is ‹(P (ys, zs,)) then P (C (x, ys,), zs,)››; fun break1 = p, ls, => if ls is ‹(N) then P (N, N,); (C (x, xs,)) then if (p (x,)) then P (N, C (x, xs,),) else if break1 (p, xs,) is ‹(P (ys, zs,)) then P (C (x, ys,), zs,)››; fun words = s, => {let scrut = dropWhile (x, => == (x,) (1,), s,); if scrut is ‹(N) then N; (_) then if break (x, => == (x,) (1,), scrut,) is ‹(P (w, s'',)) then C (w, words (s'',),)››}; fun dropWhile = f, ls, => if ls is ‹(N) then N; (C (h, t,)) then if (f (h,)) then dropWhile (f, t,) else C (h, t,)›; words (C (2, C (1, C (2, C (1, C (2, N,),),),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ words^103([C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]])
//│ def break(p⁰, ls⁰) = case ls⁰ of {
//│ 	N  => [P [N] [N]]
//│ 	| C x⁰ xs⁰ => if p⁰(x⁰) then [P [N] [C x⁰ xs⁰]] else case break1^13(p⁰, xs⁰) of {
//│ 		P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}}
//│ def break1(p¹, ls¹) = case ls¹ of {
//│ 	N  => [P [N] [N]]
//│ 	| C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1^40(p¹, xs¹) of {
//│ 		P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}
//│ def dropWhile(f⁰, ls²) = case ls² of {
//│ 	N  => [N]
//│ 	| C h⁰ t⁰ => if f⁰(h⁰) then dropWhile^91(f⁰, t⁰) else [C h⁰ t⁰]}
//│ def words(s⁰) = 
//│ 	let scrut⁰ = dropWhile^55((fun x² -> (x² == 1)), s⁰)
//│ 	in case scrut⁰ of {
//│ 		N  => [N]
//│ 		| _  => case break^67((fun x³ -> (x³ == 1)), scrut⁰) of {
//│ 			P w⁰ s''⁰ => [C w⁰ words^78(s''⁰)]}}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec dropWhile f_0 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (f_0 h_0) then
//│ 		        ((dropWhile f_0) t_0)
//│ 		      else
//│ 		        (`C(h_0, t_0))));;
//│ 		let rec break1 p_1 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `N -> 
//│ 		      (`P((`N), (`N)))
//│ 		    | `C(x_1, xs_1) -> 
//│ 		      (if (p_1 x_1) then
//│ 		        (`P((`N), (`C(x_1, xs_1))))
//│ 		      else
//│ 		        (match ((break1 p_1) xs_1) with
//│ 		          | `P(ys_1, zs_1) -> 
//│ 		            (`P((`C(x_1, ys_1)), zs_1)))));;
//│ 		let rec break p_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`P((`N), (`N)))
//│ 		    | `C(x_0, xs_0) -> 
//│ 		      (if (p_0 x_0) then
//│ 		        (`P((`N), (`C(x_0, xs_0))))
//│ 		      else
//│ 		        (match ((break1 p_0) xs_0) with
//│ 		          | `P(ys_0, zs_0) -> 
//│ 		            (`P((`C(x_0, ys_0)), zs_0)))));;
//│ 		let rec words s_0 =
//│ 		  (let rec scrut_0 = ((dropWhile (fun x_2 -> 
//│ 		    (x_2 = 1))) s_0) in
//│ 		    (match scrut_0 with
//│ 		      | `N -> 
//│ 		        (`N)
//│ 		      | _ -> 
//│ 		        (match ((break (fun x_3 -> 
//│ 		          (x_3 = 1))) scrut_0) with
//│ 		          | `P(w_0, s''_0) -> 
//│ 		            (`C(w_0, (words s''_0))))));;
//│ 		(words (`C(2, (`C(1, (`C(2, (`C(1, (`C(2, (`N))))))))))))
//│ 		....... ocaml repl result .......
//│ 		[ok]
//│ 		                val dropWhile :
//│ 		  ('a -> bool) -> ([< `C of 'a * 'b | `N ] as 'b) -> [> `C of 'a * 'b | `N ] =
//│ 		  <fun>
//│ 		[ok]
//│ 		                      val break1 :
//│ 		  ('a -> bool) ->
//│ 		  ([< `C of 'a * 'b | `N ] as 'b) ->
//│ 		  [ `P of ([> `C of 'a * 'c | `N ] as 'c) * [> `C of 'a * 'b | `N ] ] = <fun>
//│ 		[ok]
//│ 		                      val break :
//│ 		  ('a -> bool) ->
//│ 		  [< `C of 'a * ([< `C of 'a * 'b | `N ] as 'b) | `N ] ->
//│ 		  [> `P of
//│ 		       [> `C of 'a * ([> `C of 'a * 'c | `N ] as 'c) | `N ] *
//│ 		       [> `C of 'a * 'b | `N ] ] =
//│ 		  <fun>
//│ 		[ok]
//│ 		                      val words :
//│ 		  ([ `C of int * 'a | `N ] as 'a) ->
//│ 		  ([> `C of [> `C of int * ([> `C of int * 'c | `N ] as 'c) | `N ] * 'b | `N
//│ 		   ] as 'b) =
//│ 		  <fun>
//│ 		....... ocaml repl result .......
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 3 --->
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 100
//│ [P [N] [N]]: 4 --->
//│ 	case break((fun x³ -> (x³ == 1)), scrut⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 82
//│ [C x⁰ xs⁰]: 11 --->
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 100
//│ [P [N] [C x⁰ xs⁰]]: 12 --->
//│ 	case break((fun x³ -> (x³ == 1)), scrut⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 82
//│ [P [C x⁰ ys⁰] zs⁰]: 22 --->
//│ 	case break((fun x³ -> (x³ == 1)), scrut⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 82
//│ [N]: 30 --->
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 100
//│ [P [N] [N]]: 31 --->
//│ 	case break1(p⁰, xs⁰) of {P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}: 23
//│ 	case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}: 50
//│ [C x¹ xs¹]: 38 --->
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 100
//│ [P [N] [C x¹ xs¹]]: 39 --->
//│ 	case break1(p⁰, xs⁰) of {P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}: 23
//│ 	case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}: 50
//│ [P [C x¹ ys¹] zs¹]: 49 --->
//│ 	case break1(p⁰, xs⁰) of {P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}: 23
//│ 	case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}: 50
//│ [N]: 87 --->
//│ 	case ls⁰ of {N  => [P [N] [N]] | C x⁰ xs⁰ => if p⁰(x⁰) then [P [N] [C x⁰ xs⁰]] else case break1(p⁰, xs⁰) of {P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}}: 25
//│ 	case scrut⁰ of {N  => [N] | _  => case break((fun x³ -> (x³ == 1)), scrut⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}}: 83
//│ [C h⁰ t⁰]: 98 --->
//│ 	case ls⁰ of {N  => [P [N] [N]] | C x⁰ xs⁰ => if p⁰(x⁰) then [P [N] [C x⁰ xs⁰]] else case break1(p⁰, xs⁰) of {P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}}: 25
//│ 	case scrut⁰ of {N  => [N] | _  => case break((fun x³ -> (x³ == 1)), scrut⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}}: 83
//│ [N]: 109 --->
//│ 	case ls¹ of {N  => [P [N] [N]] | C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}: 52
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 100
//│ [C 2 [N]]: 110 --->
//│ 	case ls¹ of {N  => [P [N] [N]] | C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}: 52
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 100
//│ [C 1 [C 2 [N]]]: 111 --->
//│ 	case ls¹ of {N  => [P [N] [N]] | C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}: 52
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 100
//│ [C 2 [C 1 [C 2 [N]]]]: 112 --->
//│ 	case ls¹ of {N  => [P [N] [N]] | C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}: 52
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 100
//│ [C 1 [C 2 [C 1 [C 2 [N]]]]]: 113 --->
//│ 	case ls¹ of {N  => [P [N] [N]] | C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}: 52
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 100
//│ [C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]]: 114 --->
//│ 	case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 100
//│ ------------------
//│ case break1(p⁰, xs⁰) of {P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}: 23 --->
//│ 	[P [N] [N]]: 31
//│ 	[P [N] [C x¹ xs¹]]: 39
//│ 	[P [C x¹ ys¹] zs¹]: 49
//│ case ls⁰ of {N  => [P [N] [N]] | C x⁰ xs⁰ => if p⁰(x⁰) then [P [N] [C x⁰ xs⁰]] else case break1(p⁰, xs⁰) of {P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}}: 25 --->
//│ 	[N]: 87
//│ 	[C h⁰ t⁰]: 98
//│ case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}: 50 --->
//│ 	[P [N] [N]]: 31
//│ 	[P [N] [C x¹ xs¹]]: 39
//│ 	[P [C x¹ ys¹] zs¹]: 49
//│ case ls¹ of {N  => [P [N] [N]] | C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1(p¹, xs¹) of {P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}: 52 --->
//│ 	[N]: 109
//│ 	[C 2 [N]]: 110
//│ 	[C 1 [C 2 [N]]]: 111
//│ 	[C 2 [C 1 [C 2 [N]]]]: 112
//│ 	[C 1 [C 2 [C 1 [C 2 [N]]]]]: 113
//│ case break((fun x³ -> (x³ == 1)), scrut⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 82 --->
//│ 	[P [N] [N]]: 4
//│ 	[P [N] [C x⁰ xs⁰]]: 12
//│ 	[P [C x⁰ ys⁰] zs⁰]: 22
//│ case scrut⁰ of {N  => [N] | _  => case break((fun x³ -> (x³ == 1)), scrut⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}}: 83 --->
//│ 	[N]: 87
//│ 	[C h⁰ t⁰]: 98
//│ case ls² of {N  => [N] | C h⁰ t⁰ => if f⁰(h⁰) then dropWhile(f⁰, t⁰) else [C h⁰ t⁰]}: 100 --->
//│ 	[N]: 3
//│ 	[C x⁰ xs⁰]: 11
//│ 	[N]: 30
//│ 	[C x¹ xs¹]: 38
//│ 	[N]: 109
//│ 	[C 2 [N]]: 110
//│ 	[C 1 [C 2 [N]]]: 111
//│ 	[C 2 [C 1 [C 2 [N]]]]: 112
//│ 	[C 1 [C 2 [C 1 [C 2 [N]]]]]: 113
//│ 	[C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]]: 114
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [P [N] [N]]: 4 --->
//│ 	case break((fun x³ -> (x³ == 1)), scrut⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 82
//│ [P [N] [C x⁰ xs⁰]]: 12 --->
//│ 	case break((fun x³ -> (x³ == 1)), scrut⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 82
//│ [P [C x⁰ ys⁰] zs⁰]: 22 --->
//│ 	case break((fun x³ -> (x³ == 1)), scrut⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 82
//│ ------------------
//│ case break((fun x³ -> (x³ == 1)), scrut⁰) of {P w⁰ s''⁰ => [C w⁰ words(s''⁰)]}: 82 --->
//│ 	[P [N] [N]]: 4
//│ 	[P [N] [C x⁰ xs⁰]]: 12
//│ 	[P [C x⁰ ys⁰] zs⁰]: 22
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ words([C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]])
//│ def break(p², ls³) = case ls³ of {
//│ 	N  => 
//│ 		let s''¹ = [N]
//│ 		in let w¹ = [N]
//│ 		in (fun _lh_dummy⁰ -> [C w¹ words(s''¹)])
//│ 	| C x⁰ xs⁰ => if p²(x⁰) then 
//│ 		let s''² = [C x⁰ xs⁰]
//│ 		in let w² = [N]
//│ 		in (fun _lh_dummy¹ -> [C w² words(s''²)]) else case break1(p², xs⁰) of {
//│ 		P ys⁰ zs⁰ => 
//│ 			let s''³ = zs⁰
//│ 			in let w³ = [C x⁰ ys⁰]
//│ 			in (fun _lh_dummy² -> [C w³ words(s''³)])}}
//│ def break1(p³, ls⁴) = case ls⁴ of {
//│ 	N  => [P [N] [N]]
//│ 	| C x¹ xs¹ => if p³(x¹) then [P [N] [C x¹ xs¹]] else case break1(p³, xs¹) of {
//│ 		P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}
//│ def dropWhile(f¹, ls⁵) = case ls⁵ of {
//│ 	N  => [N]
//│ 	| C h⁰ t⁰ => if f¹(h⁰) then dropWhile(f¹, t⁰) else [C h⁰ t⁰]}
//│ def words(s¹) = 
//│ 	let scrut¹ = dropWhile((fun x⁴ -> (x⁴ == 1)), s¹)
//│ 	in case scrut¹ of {
//│ 		N  => [N]
//│ 		| _  => break((fun x⁵ -> (x⁵ == 1)), scrut¹, 99)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ 
//│ >>>>>>>>>> deadcode elimination info >>>>>>>>>>
//│ words :: 'words <: [] ::: true
//│ 2 :: Int ::: false
//│ 1 :: Int ::: false
//│ 2 :: Int ::: false
//│ 1 :: Int ::: false
//│ 2 :: Int ::: false
//│ [N] :: N ::: true
//│ [C 2 [N]] :: C(Int, N) ::: true
//│ [C 1 [C 2 [N]]] :: C(Int, C(Int, N)) ::: true
//│ [C 2 [C 1 [C 2 [N]]]] :: C(Int, C(Int, C(Int, N))) ::: true
//│ [C 1 [C 2 [C 1 [C 2 [N]]]]] :: C(Int, C(Int, C(Int, C(Int, N)))) ::: true
//│ [C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]] :: C(Int, C(Int, C(Int, C(Int, C(Int, N))))) ::: true
//│ words([C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]]) :: '13_callres <: [] ::: true
//│ ls :: 'ls⁰ <: [] ::: true
//│ [N] :: N ::: true
//│ [N] :: N ::: true
//│ w :: 'w⁰ <: [] ::: true
//│ words :: 'words <: [] ::: true
//│ s'' :: 's''⁰ <: [] ::: true
//│ words(s'') :: '20_callres <: [] ::: true
//│ [C w words(s'')] :: C('w⁰, '20_callres) ::: true
//│ (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy⁰ => C('w⁰, '20_callres) ::: true
//│ let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy⁰ => C('w⁰, '20_callres) ::: true
//│ let s'' = [N]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy⁰ => C('w⁰, '20_callres) ::: true
//│ p :: 'p⁰ <: [] ::: true
//│ x :: 'x⁰ <: [] ::: true
//│ p(x) :: '27_callres <: [] ::: true
//│ x :: 'x⁰ <: [] ::: true
//│ xs :: 'xs⁰ <: [] ::: true
//│ [C x xs] :: C('x⁰, 'xs⁰) ::: true
//│ [N] :: N ::: true
//│ w :: 'w¹ <: [] ::: true
//│ words :: 'words <: [] ::: true
//│ s'' :: 's''¹ <: [] ::: true
//│ words(s'') :: '35_callres <: [] ::: true
//│ [C w words(s'')] :: C('w¹, '35_callres) ::: true
//│ (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy¹ => C('w¹, '35_callres) ::: true
//│ let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy¹ => C('w¹, '35_callres) ::: true
//│ let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy¹ => C('w¹, '35_callres) ::: true
//│ break1 :: 'break1 <: [] ::: true
//│ p :: 'p⁰ <: [] ::: true
//│ break1(p) :: '42_callres <: [] ::: true
//│ xs :: 'xs⁰ <: [] ::: true
//│ break1(p, xs) :: '44_callres <: [] ::: true
//│ zs :: 'zs⁰ <: [] ::: true
//│ x :: 'x⁰ <: [] ::: true
//│ ys :: 'ys⁰ <: [] ::: true
//│ [C x ys] :: C('x⁰, 'ys⁰) ::: true
//│ w :: 'w² <: [] ::: true
//│ words :: 'words <: [] ::: true
//│ s'' :: 's''² <: [] ::: true
//│ words(s'') :: '52_callres <: [] ::: true
//│ [C w words(s'')] :: C('w², '52_callres) ::: true
//│ (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy² => C('w², '52_callres) ::: true
//│ let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy² => C('w², '52_callres) ::: true
//│ let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words(s'')]) :: '_lh_dummy² => C('w², '52_callres) ::: true
//│ case break1(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words(s'')])} :: '57_matchres <: [] ::: true
//│ if p(x) then let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) else case break1(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words(s'')])} :: '58_ifres <: [] ::: true
//│ case ls of {N  => let s'' = [N]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) | C x xs => if p(x) then let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) else case break1(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words(s'')])}} :: '59_matchres <: [] ::: true
//│ (fun ls -> case ls of {N  => let s'' = [N]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) | C x xs => if p(x) then let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) else case break1(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words(s'')])}}) :: 'ls⁰ => '59_matchres ::: true
//│ (fun p -> (fun ls -> case ls of {N  => let s'' = [N]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) | C x xs => if p(x) then let s'' = [C x xs]
//│ in let w = [N]
//│ in (fun _lh_dummy -> [C w words(s'')]) else case break1(p, xs) of {P ys zs => let s'' = zs
//│ in let w = [C x ys]
//│ in (fun _lh_dummy -> [C w words(s'')])}})) :: 'p⁰ => 'ls⁰ => '59_matchres ::: true
//│ ls :: 'ls¹ <: [] ::: true
//│ [N] :: N ::: true
//│ [N] :: N ::: true
//│ [P [N] [N]] :: P(N, N) ::: true
//│ p :: 'p¹ <: [] ::: true
//│ x :: 'x¹ <: [] ::: true
//│ p(x) :: '68_callres <: [] ::: true
//│ [N] :: N ::: true
//│ x :: 'x¹ <: [] ::: true
//│ xs :: 'xs¹ <: [] ::: true
//│ [C x xs] :: C('x¹, 'xs¹) ::: true
//│ [P [N] [C x xs]] :: P(N, C('x¹, 'xs¹)) ::: true
//│ break1 :: 'break1 <: [] ::: true
//│ p :: 'p¹ <: [] ::: true
//│ break1(p) :: '76_callres <: [] ::: true
//│ xs :: 'xs¹ <: [] ::: true
//│ break1(p, xs) :: '78_callres <: [] ::: true
//│ x :: 'x¹ <: [] ::: true
//│ ys :: 'ys¹ <: [] ::: true
//│ [C x ys] :: C('x¹, 'ys¹) ::: true
//│ zs :: 'zs¹ <: [] ::: true
//│ [P [C x ys] zs] :: P(C('x¹, 'ys¹), 'zs¹) ::: true
//│ case break1(p, xs) of {P ys zs => [P [C x ys] zs]} :: '84_matchres <: [] ::: true
//│ if p(x) then [P [N] [C x xs]] else case break1(p, xs) of {P ys zs => [P [C x ys] zs]} :: '85_ifres <: [] ::: true
//│ case ls of {N  => [P [N] [N]] | C x xs => if p(x) then [P [N] [C x xs]] else case break1(p, xs) of {P ys zs => [P [C x ys] zs]}} :: '86_matchres <: [] ::: true
//│ (fun ls -> case ls of {N  => [P [N] [N]] | C x xs => if p(x) then [P [N] [C x xs]] else case break1(p, xs) of {P ys zs => [P [C x ys] zs]}}) :: 'ls¹ => '86_matchres ::: true
//│ (fun p -> (fun ls -> case ls of {N  => [P [N] [N]] | C x xs => if p(x) then [P [N] [C x xs]] else case break1(p, xs) of {P ys zs => [P [C x ys] zs]}})) :: 'p¹ => 'ls¹ => '86_matchres ::: true
//│ dropWhile :: 'dropWhile <: [] ::: true
//│ == :: Destruct(Int) => Destruct(Int) => Sum[True, False] ::: true
//│ x :: 'x² <: [] ::: true
//│ ==(x) :: '92_callres <: [] ::: true
//│ 1 :: Int ::: false
//│ (x == 1) :: '94_callres <: [] ::: true
//│ (fun x -> (x == 1)) :: 'x² => '94_callres ::: true
//│ dropWhile((fun x -> (x == 1))) :: '96_callres <: [] ::: true
//│ s :: 's⁰ <: [] ::: true
//│ dropWhile((fun x -> (x == 1)), s) :: '98_callres <: [] ::: true
//│ scrut :: 'scrut⁰ <: [] ::: true
//│ [N] :: N ::: true
//│ break :: 'break <: [] ::: true
//│ == :: Destruct(Int) => Destruct(Int) => Sum[True, False] ::: true
//│ x :: 'x³ <: [] ::: true
//│ ==(x) :: '104_callres <: [] ::: true
//│ 1 :: Int ::: false
//│ (x == 1) :: '106_callres <: [] ::: true
//│ (fun x -> (x == 1)) :: 'x³ => '106_callres ::: true
//│ break((fun x -> (x == 1))) :: '108_callres <: [] ::: true
//│ scrut :: 'scrut⁰ <: [] ::: true
//│ break((fun x -> (x == 1)), scrut) :: '110_callres <: [] ::: true
//│ 99 :: Int ::: false
//│ break((fun x -> (x == 1)), scrut, 99) :: '112_callres <: [] ::: true
//│ case scrut of {N  => [N] | _  => break((fun x -> (x == 1)), scrut, 99)} :: '113_matchres <: [] ::: true
//│ let scrut = dropWhile((fun x -> (x == 1)), s)
//│ in case scrut of {N  => [N] | _  => break((fun x -> (x == 1)), scrut, 99)} :: '113_matchres <: [] ::: true
//│ (fun s -> let scrut = dropWhile((fun x -> (x == 1)), s)
//│ in case scrut of {N  => [N] | _  => break((fun x -> (x == 1)), scrut, 99)}) :: 's⁰ => '113_matchres ::: true
//│ ls :: 'ls² <: [] ::: true
//│ [N] :: N ::: true
//│ f :: 'f⁰ <: [] ::: true
//│ h :: 'h⁰ <: [] ::: true
//│ f(h) :: '120_callres <: [] ::: true
//│ dropWhile :: 'dropWhile <: [] ::: true
//│ f :: 'f⁰ <: [] ::: true
//│ dropWhile(f) :: '123_callres <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ dropWhile(f, t) :: '125_callres <: [] ::: true
//│ h :: 'h⁰ <: [] ::: true
//│ t :: 't⁰ <: [] ::: true
//│ [C h t] :: C('h⁰, 't⁰) ::: true
//│ if f(h) then dropWhile(f, t) else [C h t] :: '129_ifres <: [] ::: true
//│ case ls of {N  => [N] | C h t => if f(h) then dropWhile(f, t) else [C h t]} :: '130_matchres <: [] ::: true
//│ (fun ls -> case ls of {N  => [N] | C h t => if f(h) then dropWhile(f, t) else [C h t]}) :: 'ls² => '130_matchres ::: true
//│ (fun f -> (fun ls -> case ls of {N  => [N] | C h t => if f(h) then dropWhile(f, t) else [C h t]})) :: 'f⁰ => 'ls² => '130_matchres ::: true
//│ <<<<<<<<<< deadcode elimination info <<<<<<<<<<
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ let rec break1 p_1 ls_1 =
//│   (match ls_1 with
//│     | `N -> 
//│       (`P((`N), (`N)))
//│     | `C(x_1, xs_1) -> 
//│       (if (p_1 x_1) then
//│         (`P((`N), (`C(x_1, xs_1))))
//│       else
//│         (match ((break1 p_1) xs_1) with
//│           | `P(ys_1, zs_1) -> 
//│             (`P((`C(x_1, ys_1)), zs_1)))));;
//│ let rec dropWhile f_0 ls_2 =
//│   (match ls_2 with
//│     | `N -> 
//│       (`N)
//│     | `C(h_0, t_0) -> 
//│       (if (f_0 h_0) then
//│         ((dropWhile f_0) t_0)
//│       else
//│         (`C(h_0, t_0))));;
//│ let rec break p_0 ls_0 =
//│   (match ls_0 with
//│     | `N -> 
//│       (let rec s''_0 = (`N) in
//│         (let rec w_0 = (`N) in
//│           (fun _lh_dummy_0 -> 
//│             (`C(w_0, (words s''_0))))))
//│     | `C(x_0, xs_0) -> 
//│       (if (p_0 x_0) then
//│         (let rec s''_1 = (`C(x_0, xs_0)) in
//│           (let rec w_1 = (`N) in
//│             (fun _lh_dummy_1 -> 
//│               (`C(w_1, (words s''_1))))))
//│       else
//│         (match ((break1 p_0) xs_0) with
//│           | `P(ys_0, zs_0) -> 
//│             (let rec s''_2 = zs_0 in
//│               (let rec w_2 = (`C(x_0, ys_0)) in
//│                 (fun _lh_dummy_2 -> 
//│                   (`C(w_2, (words s''_2)))))))))
//│ and
//│ words s_0 =
//│   (let rec scrut_0 = ((dropWhile (fun x_2 -> 
//│     (x_2 = 1))) s_0) in
//│     (match scrut_0 with
//│       | `N -> 
//│         (`N)
//│       | _ -> 
//│         (((break (fun x_3 -> 
//│           (x_3 = 1))) scrut_0) 99)));;
//│ (words (`C(2, (`C(1, (`C(2, (`C(1, (`C(2, (`N))))))))))))
//│ 
//│ --------------- ocaml repl result -----------------
//│ [ok]
//│   - : [> `C of [> `C of int * ([> `C of int * 'b | `N ] as 'b) | `N ] * 'a | `N
//│     ] as 'a
//│ = `C (`C (2, `N), `C (`C (2, `N), `C (`C (2, `N), `N)))
//│ 
//│ --------------- ocaml repl result -----------------
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
