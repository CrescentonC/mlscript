:NewParser
:ParseOnly

// CORRECT: the single rev can work, multiple ctor to one dtor will be no problem
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  N then a => a
  C(h, t) then a => rev(t)(C(h, a))
rev(C(AA, C(BB, C(CC, N))))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a| |=>| |a|↵|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|←|↵|rev|(|C|(|AA|,| |C|(|BB|,| |C|(|CC|,| |N|)|)|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(N) then a, => a; (C (h, t,)) then a, => rev (t,) (C (h, a,),)›; rev (C (AA, C (BB, C (CC, N,),),),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^14([C [AA] [C [BB] [C [CC] [N]]]], [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	N  => (fun a⁰ -> a⁰)
//│ 	| C h⁰ t⁰ => (fun a¹ -> rev^4(t⁰, [C h⁰ a¹]))}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [CC] [C [BB] [C [AA] [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14] (hopeless to continue)
//│ 	[rev^14 · rev^4] ---> [rev^14] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀([C [AA] [C [BB] [C [CC] [N]]]], [N])
//│ def rev_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		N  => (fun a² -> a²)
//│ 		| C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 42 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 36
//│ [C [CC] [N]]: 43 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 36
//│ [C [BB] [C [CC] [N]]]: 44 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 36
//│ [C [AA] [C [BB] [C [CC] [N]]]]: 45 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 36
//│ ------------------
//│ case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 36 --->
//│ 	[N]: 42
//│ 	[C [CC] [N]]: 43
//│ 	[C [BB] [C [CC] [N]]]: 44
//│ 	[C [AA] [C [BB] [C [CC] [N]]]]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 42 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 36
//│ [C [CC] [N]]: 43 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 36
//│ [C [BB] [C [CC] [N]]]: 44 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 36
//│ [C [AA] [C [BB] [C [CC] [N]]]]: 45 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 36
//│ ------------------
//│ case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> rev_₀(t¹, [C h¹ a³]))}: 36 --->
//│ 	[N]: 42
//│ 	[C [CC] [N]]: 43
//│ 	[C [BB] [C [CC] [N]]]: 44
//│ 	[C [AA] [C [BB] [C [CC] [N]]]]: 45
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(
//│ 	let t² = 	
//│ 		let t³ = 	
//│ 			let t⁴ = (fun a⁷ -> a⁷)
//│ 			in let h⁴ = [CC]
//│ 			in (fun a⁶ -> rev_₀(t⁴, [C h⁴ a⁶]))
//│ 		in let h³ = [BB]
//│ 		in (fun a⁵ -> rev_₀(t³, [C h³ a⁵]))
//│ 	in let h² = [AA]
//│ 	in (fun a⁴ -> rev_₀(t², [C h² a⁴])), [N])
//│ def rev_₀(ls²) = 
//│ 	ls²
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [CC] [C [BB] [C [AA] [N]]]]
//│ <<<<<<< evaluate <<<<<<<


_LUMBERHACK_EVAL
fun rev(ys) = if ys is
  N then a => a
  C(h, t) then a => rev(t)(C(h, a))
fun map(xs) = if xs is
  N then f => N
  C(h, t) then f => C(f(h), map(t)(f))
fun f(x) = if x is
  A then AA
  B then BB
rev(map(C(A, C(B, N)))(f))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |a| |=>| |a|↵|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|←|↵|#fun| |map|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |f| |=>| |N|↵|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|←|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|rev|(|map|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|f|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ys, => if ys is ‹(N) then a, => a; (C (h, t,)) then a, => rev (t,) (C (h, a,),)›; fun map = xs, => if xs is ‹(N) then f, => N; (C (h, t,)) then f, => C (f (h,), map (t,) (f,),)›; fun f = x, => if x is ‹(A) then AA; (B) then BB›; rev (map (C (A, C (B, N,),),) (f,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^34(map^35([C [A] [C [B] [N]]], f^42), [N])
//│ def f(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰) = case xs⁰ of {
//│ 	N  => (fun f¹ -> [N])
//│ 	| C h¹ t¹ => (fun f² -> [C f²(h¹) map^20(t¹, f²)])}
//│ def rev(ys⁰) = case ys⁰ of {
//│ 	N  => (fun a⁰ -> a⁰)
//│ 	| C h⁰ t⁰ => (fun a¹ -> rev^4(t⁰, [C h⁰ a¹]))}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^42] (hopeless to continue)
//│ [map^35]
//│ 	[map^35 · map^20] ---> [map^35] (only one)
//│ [rev^34]
//│ 	[rev^34 · rev^4] ---> [rev^34] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀(map_₀([C [A] [C [B] [N]]], f_₀), [N])
//│ def f_₀(x¹) = 
//│ 	case x¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def map_₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		N  => (fun f³ -> [N])
//│ 		| C h³ t³ => (fun f⁴ -> [C f⁴(h³) map_₀(t³, f⁴)])}
//│ def rev_₀(ys¹) = 
//│ 	case ys¹ of {
//│ 		N  => (fun a² -> a²)
//│ 		| C h² t² => (fun a³ -> rev_₀(t², [C h² a³]))}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 61 --->
//│ 	case ys¹ of {N  => (fun a² -> a²) | C h² t² => (fun a³ -> rev_₀(t², [C h² a³]))}: 58
//│ [C f⁴(h³) map_₀(t³, f⁴)]: 71 --->
//│ 	case ys¹ of {N  => (fun a² -> a²) | C h² t² => (fun a³ -> rev_₀(t², [C h² a³]))}: 58
//│ [A]: 82 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 78
//│ [B]: 83 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 78
//│ [N]: 84 --->
//│ 	case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C f⁴(h³) map_₀(t³, f⁴)])}: 73
//│ [C [B] [N]]: 85 --->
//│ 	case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C f⁴(h³) map_₀(t³, f⁴)])}: 73
//│ [C [A] [C [B] [N]]]: 86 --->
//│ 	case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C f⁴(h³) map_₀(t³, f⁴)])}: 73
//│ ------------------
//│ case ys¹ of {N  => (fun a² -> a²) | C h² t² => (fun a³ -> rev_₀(t², [C h² a³]))}: 58 --->
//│ 	[N]: 61
//│ 	[C f⁴(h³) map_₀(t³, f⁴)]: 71
//│ case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C f⁴(h³) map_₀(t³, f⁴)])}: 73 --->
//│ 	[N]: 84
//│ 	[C [B] [N]]: 85
//│ 	[C [A] [C [B] [N]]]: 86
//│ case x¹ of {A  => [AA] | B  => [BB]}: 78 --->
//│ 	DeadCodeProd
//│ 	[A]: 82
//│ 	[B]: 83
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 61 --->
//│ 	case ys¹ of {N  => (fun a² -> a²) | C h² t² => (fun a³ -> rev_₀(t², [C h² a³]))}: 58
//│ [C f⁴(h³) map_₀(t³, f⁴)]: 71 --->
//│ 	case ys¹ of {N  => (fun a² -> a²) | C h² t² => (fun a³ -> rev_₀(t², [C h² a³]))}: 58
//│ [N]: 84 --->
//│ 	case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C f⁴(h³) map_₀(t³, f⁴)])}: 73
//│ [C [B] [N]]: 85 --->
//│ 	case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C f⁴(h³) map_₀(t³, f⁴)])}: 73
//│ [C [A] [C [B] [N]]]: 86 --->
//│ 	case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C f⁴(h³) map_₀(t³, f⁴)])}: 73
//│ ------------------
//│ case ys¹ of {N  => (fun a² -> a²) | C h² t² => (fun a³ -> rev_₀(t², [C h² a³]))}: 58 --->
//│ 	[N]: 61
//│ 	[C f⁴(h³) map_₀(t³, f⁴)]: 71
//│ case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C f⁴(h³) map_₀(t³, f⁴)])}: 73 --->
//│ 	[N]: 84
//│ 	[C [B] [N]]: 85
//│ 	[C [A] [C [B] [N]]]: 86
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(map_₀(
//│ 	let t⁴ = 	
//│ 		let t⁶ = (fun f⁷ -> (fun a⁶ -> a⁶))
//│ 		in let h⁶ = [B]
//│ 		in (fun f⁶ -> 
//│ 			let t⁷ = map_₀(t⁶, f⁶)
//│ 			in let h⁷ = f⁶(h⁶)
//│ 			in (fun a⁵ -> rev_₀(t⁷, [C h⁷ a⁵])))
//│ 	in let h⁴ = [A]
//│ 	in (fun f⁵ -> 
//│ 		let t⁵ = map_₀(t⁴, f⁵)
//│ 		in let h⁵ = f⁵(h⁴)
//│ 		in (fun a⁴ -> rev_₀(t⁵, [C h⁵ a⁴]))), f_₀), [N])
//│ def f_₀(x²) = 
//│ 	case x² of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def map_₀(xs²) = 
//│ 	xs²
//│ def rev_₀(ys²) = 
//│ 	ys²
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<< evaluate <<<<<<<


// CORRECT:
_LUMBERHACK_EVAL
fun map(ls) = if ls is
  C(hh, tt) then C(
    (if hh is
      A then B
      AA then BB
    ),
    map(tt)
  )
  N then N
fun rev(lss) = if lss is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
map(rev(C(A, C(AA, N)))(N))
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|hh|,| |tt|)| |#then| |C|(|→|(|#if| |hh| |is|→|A| |#then| |B|↵|AA| |#then| |BB|←|↵|)|,|↵|map|(|tt|)|←|↵|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|lss|)| |#=| |#if| |lss| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|map|(|rev|(|C|(|A|,| |C|(|AA|,| |N|)|)|)|(|N|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, => if ls is ‹(C (hh, tt,)) then C ('(' if hh is ‹(A) then B; (AA) then BB›, ')', map (tt,),); (N) then N›; fun rev = lss, => if lss is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; map (rev (C (A, C (AA, N,),),) (N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^26(rev^27([C [A] [C [AA] [N]]], [N]))
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C hh⁰ tt⁰ => [C case hh⁰ of {
//│ 		A  => [B]
//│ 		| AA  => [BB]} map^6(tt⁰)]
//│ 	| N  => [N]}
//│ def rev(lss⁰) = case lss⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev^14(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [BB] [C [B] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [map^26]
//│ 	[map^26 · map^6] ---> [map^26] (only one)
//│ [rev^27] (hopeless to continue)
//│ 	[rev^27 · rev^14] ---> [rev^27] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map_₀(rev_₀([C [A] [C [AA] [N]]], [N]))
//│ def map_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C hh¹ tt¹ => [C case hh¹ of {
//│ 			A  => [B]
//│ 			| AA  => [BB]} map_₀(tt¹)]
//│ 		| N  => [N]}
//│ def rev_₀(lss¹) = 
//│ 	case lss¹ of {
//│ 		C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²]))
//│ 		| N  => (fun a³ -> a³)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ a²]: 55 --->
//│ 	case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A  => [B] | AA  => [BB]} map_₀(tt¹)] | N  => [N]}: 47
//│ [A]: 64 --->
//│ 	case hh¹ of {A  => [B] | AA  => [BB]}: 41
//│ [AA]: 65 --->
//│ 	case hh¹ of {A  => [B] | AA  => [BB]}: 41
//│ [N]: 66 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 60
//│ [C [AA] [N]]: 67 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 60
//│ [C [A] [C [AA] [N]]]: 68 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 60
//│ [N]: 70 --->
//│ 	case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A  => [B] | AA  => [BB]} map_₀(tt¹)] | N  => [N]}: 47
//│ ------------------
//│ case hh¹ of {A  => [B] | AA  => [BB]}: 41 --->
//│ 	[A]: 64
//│ 	[AA]: 65
//│ case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A  => [B] | AA  => [BB]} map_₀(tt¹)] | N  => [N]}: 47 --->
//│ 	[C h¹ a²]: 55
//│ 	[N]: 70
//│ case lss¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 60 --->
//│ 	[N]: 66
//│ 	[C [AA] [N]]: 67
//│ 	[C [A] [C [AA] [N]]]: 68
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a²]: 55 --->
//│ 	case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A  => [B] | AA  => [BB]} map_₀(tt¹)] | N  => [N]}: 47
//│ [A]: 64 --->
//│ 	case hh¹ of {A  => [B] | AA  => [BB]}: 41
//│ [AA]: 65 --->
//│ 	case hh¹ of {A  => [B] | AA  => [BB]}: 41
//│ [N]: 66 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 60
//│ [C [AA] [N]]: 67 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 60
//│ [C [A] [C [AA] [N]]]: 68 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 60
//│ [N]: 70 --->
//│ 	case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A  => [B] | AA  => [BB]} map_₀(tt¹)] | N  => [N]}: 47
//│ ------------------
//│ case hh¹ of {A  => [B] | AA  => [BB]}: 41 --->
//│ 	[A]: 64
//│ 	[AA]: 65
//│ case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A  => [B] | AA  => [BB]} map_₀(tt¹)] | N  => [N]}: 47 --->
//│ 	[C h¹ a²]: 55
//│ 	[N]: 70
//│ case lss¹ of {C h¹ t¹ => (fun a² -> rev_₀(t¹, [C h¹ a²])) | N  => (fun a³ -> a³)}: 60 --->
//│ 	[N]: 66
//│ 	[C [AA] [N]]: 67
//│ 	[C [A] [C [AA] [N]]]: 68
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map_₀(rev_₀(
//│ 	let t² = 	
//│ 		let t³ = (fun a⁶ -> a⁶)
//│ 		in let h³ = [BB]
//│ 		in (fun a⁵ -> rev_₀(t³, 
//│ 			let tt³ = a⁵
//│ 			in let hh³ = h³
//│ 			in (fun _lh_dummy¹ -> [C hh³ map_₀(tt³)])))
//│ 	in let h² = [B]
//│ 	in (fun a⁴ -> rev_₀(t², 
//│ 		let tt² = a⁴
//│ 		in let hh² = h²
//│ 		in (fun _lh_dummy⁰ -> [C hh² map_₀(tt²)]))), (fun _lh_dummy² -> [N])))
//│ def map_₀(ls²) = 
//│ 	ls²(99)
//│ def rev_₀(lss²) = 
//│ 	lss²
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [BB] [C [B] [N]]]
//│ <<<<<<< evaluate <<<<<<<

_LUMBERHACK_EVAL
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun rev(a, ys) = if ys is
  C(h, t) then rev(C(h, a), t)
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
map(rev(N, C(A, C(B, N))), ff)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|map|(|rev|(|N|,| |C|(|A|,| |C|(|B|,| |N|)|)|)|,| |ff|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun rev = a, ys, => if ys is ‹(C (h, t,)) then rev (C (h, a,), t,); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; map (rev (N, C (A, C (B, N,),),), ff,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^32(rev^33([N], [C [A] [C [B] [N]]]), ff^43)
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => rev^16([C h¹ a⁰], t¹)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^43] (hopeless to continue)
//│ [map^32]
//│ 	[map^32 · map^5] ---> [map^32] (only one)
//│ [rev^33] (hopeless to continue)
//│ 	[rev^33 · rev^16] ---> [rev^33] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map_₀(rev_₀([N], [C [A] [C [B] [N]]]), ff_₀)
//│ def ff_₀(x¹) = 
//│ 	case x¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def map_₀(xs¹, f¹) = 
//│ 	case xs¹ of {
//│ 		C h² t² => [C f¹(h²) map_₀(t², f¹)]
//│ 		| N  => [N]}
//│ def rev_₀(a¹, ys¹) = 
//│ 	case ys¹ of {
//│ 		C h³ t³ => rev_₀([C h³ a¹], t³)
//│ 		| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h³ a¹]: 68 --->
//│ 	case xs¹ of {C h² t² => [C f¹(h²) map_₀(t², f¹)] | N  => [N]}: 61
//│ [N]: 78 --->
//│ 	case xs¹ of {C h² t² => [C f¹(h²) map_₀(t², f¹)] | N  => [N]}: 61
//│ [A]: 80 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 48
//│ [B]: 81 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 48
//│ [N]: 82 --->
//│ 	case ys¹ of {C h³ t³ => rev_₀([C h³ a¹], t³) | N  => a¹}: 73
//│ [C [B] [N]]: 83 --->
//│ 	case ys¹ of {C h³ t³ => rev_₀([C h³ a¹], t³) | N  => a¹}: 73
//│ [C [A] [C [B] [N]]]: 84 --->
//│ 	case ys¹ of {C h³ t³ => rev_₀([C h³ a¹], t³) | N  => a¹}: 73
//│ ------------------
//│ case x¹ of {A  => [AA] | B  => [BB]}: 48 --->
//│ 	[A]: 80
//│ 	[B]: 81
//│ case xs¹ of {C h² t² => [C f¹(h²) map_₀(t², f¹)] | N  => [N]}: 61 --->
//│ 	[C h³ a¹]: 68
//│ 	[N]: 78
//│ case ys¹ of {C h³ t³ => rev_₀([C h³ a¹], t³) | N  => a¹}: 73 --->
//│ 	[N]: 82
//│ 	[C [B] [N]]: 83
//│ 	[C [A] [C [B] [N]]]: 84
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h³ a¹]: 68 --->
//│ 	case xs¹ of {C h² t² => [C f¹(h²) map_₀(t², f¹)] | N  => [N]}: 61
//│ [N]: 78 --->
//│ 	case xs¹ of {C h² t² => [C f¹(h²) map_₀(t², f¹)] | N  => [N]}: 61
//│ [A]: 80 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 48
//│ [B]: 81 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 48
//│ [N]: 82 --->
//│ 	case ys¹ of {C h³ t³ => rev_₀([C h³ a¹], t³) | N  => a¹}: 73
//│ [C [B] [N]]: 83 --->
//│ 	case ys¹ of {C h³ t³ => rev_₀([C h³ a¹], t³) | N  => a¹}: 73
//│ [C [A] [C [B] [N]]]: 84 --->
//│ 	case ys¹ of {C h³ t³ => rev_₀([C h³ a¹], t³) | N  => a¹}: 73
//│ ------------------
//│ case x¹ of {A  => [AA] | B  => [BB]}: 48 --->
//│ 	[A]: 80
//│ 	[B]: 81
//│ case xs¹ of {C h² t² => [C f¹(h²) map_₀(t², f¹)] | N  => [N]}: 61 --->
//│ 	[C h³ a¹]: 68
//│ 	[N]: 78
//│ case ys¹ of {C h³ t³ => rev_₀([C h³ a¹], t³) | N  => a¹}: 73 --->
//│ 	[N]: 82
//│ 	[C [B] [N]]: 83
//│ 	[C [A] [C [B] [N]]]: 84
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map_₀(rev_₀((fun f² -> [N]), 
//│ 	let t⁴ = 	
//│ 		let t⁶ = (fun a⁴ -> a⁴)
//│ 		in let h⁶ = [BB]
//│ 		in (fun a³ -> rev_₀(
//│ 			let t⁷ = a³
//│ 			in let h⁷ = h⁶
//│ 			in (fun f⁴ -> [C f⁴(h⁷) map_₀(t⁷, f⁴)]), t⁶))
//│ 	in let h⁴ = [AA]
//│ 	in (fun a² -> rev_₀(
//│ 		let t⁵ = a²
//│ 		in let h⁵ = h⁴
//│ 		in (fun f³ -> [C f³(h⁵) map_₀(t⁵, f³)]), t⁴))), ff_₀)
//│ def ff_₀(x²) = 
//│ 	x²
//│ def map_₀(xs², f⁵) = 
//│ 	xs²(f⁵)
//│ def rev_₀(a⁵, ys²) = 
//│ 	ys²(a⁵)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<< evaluate <<<<<<<

_LUMBERHACK_EVAL
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun rev(a, ys) = if ys is
  C(h, t) then rev(C(h, a), t)
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
rev(N, map(C(A, C(B, N)), ff))
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|rev|(|N|,| |map|(|C|(|A|,| |C|(|B|,| |N|)|)|,| |ff|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun rev = a, ys, => if ys is ‹(C (h, t,)) then rev (C (h, a,), t,); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; rev (N, map (C (A, C (B, N,),), ff,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^32([N], map^35([C [A] [C [B] [N]]], ff^42))
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => rev^16([C h¹ a⁰], t¹)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^42] (hopeless to continue)
//│ [map^35]
//│ 	[map^35 · map^5] ---> [map^35] (only one)
//│ [rev^32]
//│ 	[rev^32 · rev^16] ---> [rev^32] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀([N], map_₀([C [A] [C [B] [N]]], ff_₀))
//│ def ff_₀(x¹) = 
//│ 	case x¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def map_₀(xs¹, f¹) = 
//│ 	case xs¹ of {
//│ 		C h³ t³ => [C f¹(h³) map_₀(t³, f¹)]
//│ 		| N  => [N]}
//│ def rev_₀(a¹, ys¹) = 
//│ 	case ys¹ of {
//│ 		C h² t² => rev_₀([C h² a¹], t²)
//│ 		| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f¹(h³) map_₀(t³, f¹)]: 66 --->
//│ 	case ys¹ of {C h² t² => rev_₀([C h² a¹], t²) | N  => a¹}: 54
//│ [N]: 67 --->
//│ 	case ys¹ of {C h² t² => rev_₀([C h² a¹], t²) | N  => a¹}: 54
//│ [A]: 80 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 74
//│ [B]: 81 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 74
//│ [N]: 82 --->
//│ 	case xs¹ of {C h³ t³ => [C f¹(h³) map_₀(t³, f¹)] | N  => [N]}: 68
//│ [C [B] [N]]: 83 --->
//│ 	case xs¹ of {C h³ t³ => [C f¹(h³) map_₀(t³, f¹)] | N  => [N]}: 68
//│ [C [A] [C [B] [N]]]: 84 --->
//│ 	case xs¹ of {C h³ t³ => [C f¹(h³) map_₀(t³, f¹)] | N  => [N]}: 68
//│ ------------------
//│ case ys¹ of {C h² t² => rev_₀([C h² a¹], t²) | N  => a¹}: 54 --->
//│ 	[C f¹(h³) map_₀(t³, f¹)]: 66
//│ 	[N]: 67
//│ case xs¹ of {C h³ t³ => [C f¹(h³) map_₀(t³, f¹)] | N  => [N]}: 68 --->
//│ 	[N]: 82
//│ 	[C [B] [N]]: 83
//│ 	[C [A] [C [B] [N]]]: 84
//│ case x¹ of {A  => [AA] | B  => [BB]}: 74 --->
//│ 	[A]: 80
//│ 	[B]: 81
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f¹(h³) map_₀(t³, f¹)]: 66 --->
//│ 	case ys¹ of {C h² t² => rev_₀([C h² a¹], t²) | N  => a¹}: 54
//│ [N]: 67 --->
//│ 	case ys¹ of {C h² t² => rev_₀([C h² a¹], t²) | N  => a¹}: 54
//│ [A]: 80 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 74
//│ [B]: 81 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 74
//│ [N]: 82 --->
//│ 	case xs¹ of {C h³ t³ => [C f¹(h³) map_₀(t³, f¹)] | N  => [N]}: 68
//│ [C [B] [N]]: 83 --->
//│ 	case xs¹ of {C h³ t³ => [C f¹(h³) map_₀(t³, f¹)] | N  => [N]}: 68
//│ [C [A] [C [B] [N]]]: 84 --->
//│ 	case xs¹ of {C h³ t³ => [C f¹(h³) map_₀(t³, f¹)] | N  => [N]}: 68
//│ ------------------
//│ case ys¹ of {C h² t² => rev_₀([C h² a¹], t²) | N  => a¹}: 54 --->
//│ 	[C f¹(h³) map_₀(t³, f¹)]: 66
//│ 	[N]: 67
//│ case xs¹ of {C h³ t³ => [C f¹(h³) map_₀(t³, f¹)] | N  => [N]}: 68 --->
//│ 	[N]: 82
//│ 	[C [B] [N]]: 83
//│ 	[C [A] [C [B] [N]]]: 84
//│ case x¹ of {A  => [AA] | B  => [BB]}: 74 --->
//│ 	[A]: 80
//│ 	[B]: 81
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀([N], map_₀(
//│ 	let t⁴ = 	
//│ 		let t⁶ = (fun f⁴ -> (fun a⁴ -> a⁴))
//│ 		in let h⁶ = [BB]
//│ 		in (fun f³ -> 
//│ 			let t⁷ = map_₀(t⁶, f³)
//│ 			in let h⁷ = f³(h⁶)
//│ 			in (fun a³ -> rev_₀([C h⁷ a³], t⁷)))
//│ 	in let h⁴ = [AA]
//│ 	in (fun f² -> 
//│ 		let t⁵ = map_₀(t⁴, f²)
//│ 		in let h⁵ = f²(h⁴)
//│ 		in (fun a² -> rev_₀([C h⁵ a²], t⁵))), ff_₀))
//│ def ff_₀(x²) = 
//│ 	x²
//│ def map_₀(xs², f⁵) = 
//│ 	xs²(f⁵)
//│ def rev_₀(a⁵, ys²) = 
//│ 	ys²(a⁵)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<< evaluate <<<<<<<

// NOTE: this example works when no concrete input is provided
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun rev(a, ys) = if ys is
  C(h, t) then rev(C(h, a), t)
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
fun revMap(ls, f) = rev(N, map(ls, f))
revMap
//│ |#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|#fun| |revMap|(|ls|,| |f|)| |#=| |rev|(|N|,| |map|(|ls|,| |f|)|)|↵|revMap|
//│ Parsed: {fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun rev = a, ys, => if ys is ‹(C (h, t,)) then rev (C (h, a,), t,); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; fun revMap = ls, f, => rev (N, map (ls, f,),); revMap}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ revMap^43
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => rev^16([C h¹ a⁰], t¹)
//│ 	| N  => a⁰}
//│ def revMap(ls⁰, f¹) = rev^32([N], map^35(ls⁰, f¹))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [revMap^43]
//│ 	[revMap^43 · map^35]
//│ 		[revMap^43 · map^35 · map^5] ---> [revMap^43 · map^35] (only one)
//│ 	[revMap^43 · rev^32] (hopeless to continue)
//│ 		[revMap^43 · rev^32 · rev^16] ---> [revMap^43 · rev^32] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ revMap_₀
//│ def revMap_₀(ls¹, f³) = 
//│ 	rev_₀([N], map_₀(ls¹, f³))
//│ 	where
//│ 	def map_₀(xs¹, f²) = 
//│ 		case xs¹ of {
//│ 			C h² t² => [C f²(h²) map_₀(t², f²)]
//│ 			| N  => [N]}
//│ 	def rev_₀(a¹, ys¹) = 
//│ 		case ys¹ of {
//│ 			C h³ t³ => rev_₀([C h³ a¹], t³)
//│ 			| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f²(h²) map_₀(t², f²)]: 53 --->
//│ 	case ys¹ of {C h³ t³ => rev_₀([C h³ a¹], t³) | N  => a¹}: 67
//│ [N]: 54 --->
//│ 	case ys¹ of {C h³ t³ => rev_₀([C h³ a¹], t³) | N  => a¹}: 67
//│ ------------------
//│ case ys¹ of {C h³ t³ => rev_₀([C h³ a¹], t³) | N  => a¹}: 67 --->
//│ 	[C f²(h²) map_₀(t², f²)]: 53
//│ 	[N]: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f²(h²) map_₀(t², f²)]: 53 --->
//│ 	case ys¹ of {C h³ t³ => rev_₀([C h³ a¹], t³) | N  => a¹}: 67
//│ [N]: 54 --->
//│ 	case ys¹ of {C h³ t³ => rev_₀([C h³ a¹], t³) | N  => a¹}: 67
//│ ------------------
//│ case ys¹ of {C h³ t³ => rev_₀([C h³ a¹], t³) | N  => a¹}: 67 --->
//│ 	[C f²(h²) map_₀(t², f²)]: 53
//│ 	[N]: 54
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ revMap_₀
//│ def revMap_₀(ls², f⁵) = 
//│ 	rev_₀([N], map_₀(ls², f⁵))
//│ 	where
//│ 	def map_₀(xs², f⁴) = 
//│ 		case xs² of {
//│ 			C h² t² => 
//│ 				let t⁴ = map_₀(t², f⁴)
//│ 				in let h⁴ = f⁴(h²)
//│ 				in (fun a² -> rev_₀([C h⁴ a²], t⁴))
//│ 			| N  => (fun a³ -> a³)}
//│ 	def rev_₀(a⁴, ys²) = 
//│ 		ys²(a⁴)
//│ <<<<<<< after fusion <<<<<<<
