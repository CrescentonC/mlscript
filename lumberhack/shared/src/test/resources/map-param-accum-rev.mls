:NewParser
:ParseOnly

// CORRECT: the single rev can work, multiple ctor to one dtor will be no problem
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  N then a => a
  C(h, t) then a => rev(t)(C(h, a))
rev(C(AA, C(BB, C(CC, N))))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a| |=>| |a|↵|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|←|↵|rev|(|C|(|AA|,| |C|(|BB|,| |C|(|CC|,| |N|)|)|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(N) then a, => a; (C (h, t,)) then a, => rev (t,) (C (h, a,),)›; rev (C (AA, C (BB, C (CC, N,),),),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^14([C [AA] [C [BB] [C [CC] [N]]]], [N])
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	N  => (fun a⁰ -> a⁰)
//│ 	| C h⁰ t⁰ => (fun a¹ -> rev^4(t⁰, [C h⁰ a¹]))}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [CC] [C [BB] [C [AA] [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 18 --->
//│ 	case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [C [CC] [N]]: 19 --->
//│ 	case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [C [BB] [C [CC] [N]]]: 20 --->
//│ 	case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [C [AA] [C [BB] [C [CC] [N]]]]: 21 --->
//│ 	case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ ------------------
//│ case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12 --->
//│ 	[N]: 18
//│ 	[C [CC] [N]]: 19
//│ 	[C [BB] [C [CC] [N]]]: 20
//│ 	[C [AA] [C [BB] [C [CC] [N]]]]: 21
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 18 --->
//│ 	case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [C [CC] [N]]: 19 --->
//│ 	case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [C [BB] [C [CC] [N]]]: 20 --->
//│ 	case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [C [AA] [C [BB] [C [CC] [N]]]]: 21 --->
//│ 	case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ ------------------
//│ case ls⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12 --->
//│ 	[N]: 18
//│ 	[C [CC] [N]]: 19
//│ 	[C [BB] [C [CC] [N]]]: 20
//│ 	[C [AA] [C [BB] [C [CC] [N]]]]: 21
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(
//│ 	let t¹ = 	
//│ 		let t² = 	
//│ 			let t³ = (fun a⁵ -> a⁵)
//│ 			in let h³ = [CC]
//│ 			in (fun a⁴ -> rev(t³, [C h³ a⁴]))
//│ 		in let h² = [BB]
//│ 		in (fun a³ -> rev(t², [C h² a³]))
//│ 	in let h¹ = [AA]
//│ 	in (fun a² -> rev(t¹, [C h¹ a²])), [N])
//│ def rev(ls¹) = ls¹
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [CC] [C [BB] [C [AA] [N]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ let t⁰ = 	
//│ 	let t¹ = 	
//│ 		let t² = (fun a⁰ -> a⁰)
//│ 		in let h⁰ = [CC]
//│ 		in (fun a¹ -> t²([C h⁰ a¹]))
//│ 	in let h¹ = [BB]
//│ 	in (fun a² -> t¹([C h¹ a²]))
//│ in let h² = [AA]
//│ in t⁰([C h² [N]])
//│ def rev(ls⁰) = ls⁰
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ let t⁰ = 	
//│ 	let t¹ = 	
//│ 		let t² = (fun a⁰ -> a⁰)
//│ 		in let h⁰ = [CC]
//│ 		in (fun a¹ -> t²([C h⁰ a¹]))
//│ 	in let h¹ = [BB]
//│ 	in (fun a² -> t¹([C h¹ a²]))
//│ in let h² = [AA]
//│ in t⁰([C h² [N]])
//│ def rev(ls⁰) = ls⁰
//│ <<<<<<< after floating out <<<<<<<


_LUMBERHACK_EVAL
fun rev(ys) = if ys is
  N then a => a
  C(h, t) then a => rev(t)(C(h, a))
fun map(xs) = if xs is
  N then f => N
  C(h, t) then f => C(f(h), map(t)(f))
fun f(x) = if x is
  A then AA
  B then BB
rev(map(C(A, C(B, N)))(f))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |a| |=>| |a|↵|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|←|↵|#fun| |map|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |f| |=>| |N|↵|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|←|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|rev|(|map|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|f|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ys, => if ys is ‹(N) then a, => a; (C (h, t,)) then a, => rev (t,) (C (h, a,),)›; fun map = xs, => if xs is ‹(N) then f, => N; (C (h, t,)) then f, => C (f (h,), map (t,) (f,),)›; fun f = x, => if x is ‹(A) then AA; (B) then BB›; rev (map (C (A, C (B, N,),),) (f,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^34(map^35([C [A] [C [B] [N]]], f^42), [N])
//│ def f(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰) = case xs⁰ of {
//│ 	N  => (fun f¹ -> [N])
//│ 	| C h¹ t¹ => (fun f² -> [C f²(h¹) map^20(t¹, f²)])}
//│ def rev(ys⁰) = case ys⁰ of {
//│ 	N  => (fun a⁰ -> a⁰)
//│ 	| C h⁰ t⁰ => (fun a¹ -> rev^4(t⁰, [C h⁰ a¹]))}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 15 --->
//│ 	case ys⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [C f²(h¹) map(t¹, f²)]: 25 --->
//│ 	case ys⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [A]: 36 --->
//│ 	case x⁰ of {A  => [AA] | B  => [BB]}: 32
//│ [B]: 37 --->
//│ 	case x⁰ of {A  => [AA] | B  => [BB]}: 32
//│ [N]: 38 --->
//│ 	case xs⁰ of {N  => (fun f¹ -> [N]) | C h¹ t¹ => (fun f² -> [C f²(h¹) map(t¹, f²)])}: 27
//│ [C [B] [N]]: 39 --->
//│ 	case xs⁰ of {N  => (fun f¹ -> [N]) | C h¹ t¹ => (fun f² -> [C f²(h¹) map(t¹, f²)])}: 27
//│ [C [A] [C [B] [N]]]: 40 --->
//│ 	case xs⁰ of {N  => (fun f¹ -> [N]) | C h¹ t¹ => (fun f² -> [C f²(h¹) map(t¹, f²)])}: 27
//│ ------------------
//│ case ys⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12 --->
//│ 	[N]: 15
//│ 	[C f²(h¹) map(t¹, f²)]: 25
//│ case xs⁰ of {N  => (fun f¹ -> [N]) | C h¹ t¹ => (fun f² -> [C f²(h¹) map(t¹, f²)])}: 27 --->
//│ 	[N]: 38
//│ 	[C [B] [N]]: 39
//│ 	[C [A] [C [B] [N]]]: 40
//│ case x⁰ of {A  => [AA] | B  => [BB]}: 32 --->
//│ 	DeadCodeProd
//│ 	[A]: 36
//│ 	[B]: 37
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 15 --->
//│ 	case ys⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [C f²(h¹) map(t¹, f²)]: 25 --->
//│ 	case ys⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12
//│ [N]: 38 --->
//│ 	case xs⁰ of {N  => (fun f¹ -> [N]) | C h¹ t¹ => (fun f² -> [C f²(h¹) map(t¹, f²)])}: 27
//│ [C [B] [N]]: 39 --->
//│ 	case xs⁰ of {N  => (fun f¹ -> [N]) | C h¹ t¹ => (fun f² -> [C f²(h¹) map(t¹, f²)])}: 27
//│ [C [A] [C [B] [N]]]: 40 --->
//│ 	case xs⁰ of {N  => (fun f¹ -> [N]) | C h¹ t¹ => (fun f² -> [C f²(h¹) map(t¹, f²)])}: 27
//│ ------------------
//│ case ys⁰ of {N  => (fun a⁰ -> a⁰) | C h⁰ t⁰ => (fun a¹ -> rev(t⁰, [C h⁰ a¹]))}: 12 --->
//│ 	[N]: 15
//│ 	[C f²(h¹) map(t¹, f²)]: 25
//│ case xs⁰ of {N  => (fun f¹ -> [N]) | C h¹ t¹ => (fun f² -> [C f²(h¹) map(t¹, f²)])}: 27 --->
//│ 	[N]: 38
//│ 	[C [B] [N]]: 39
//│ 	[C [A] [C [B] [N]]]: 40
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(map(
//│ 	let t² = 	
//│ 		let t⁴ = (fun f⁵ -> (fun a⁴ -> a⁴))
//│ 		in let h⁴ = [B]
//│ 		in (fun f⁴ -> 
//│ 			let t⁵ = map(t⁴, f⁴)
//│ 			in let h⁵ = f⁴(h⁴)
//│ 			in (fun a³ -> rev(t⁵, [C h⁵ a³])))
//│ 	in let h² = [A]
//│ 	in (fun f³ -> 
//│ 		let t³ = map(t², f³)
//│ 		in let h³ = f³(h²)
//│ 		in (fun a² -> rev(t³, [C h³ a²]))), f), [N])
//│ def f(x¹) = case x¹ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs¹) = xs¹
//│ def rev(ys¹) = ys¹
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map, rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ let t⁰ = 	
//│ 	let t¹ = (fun f¹ -> (fun a⁰ -> a⁰))
//│ 	in let h⁰ = [B]
//│ 	in (fun f² -> 
//│ 		let t² = t¹(f²)
//│ 		in let h¹ = f²(h⁰)
//│ 		in (fun a¹ -> t²([C h¹ a¹])))
//│ in let h² = [A]
//│ in let t³ = t⁰(f)
//│ in let h³ = f(h²)
//│ in t³([C h³ [N]])
//│ def f(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰) = xs⁰
//│ def rev(ys⁰) = ys⁰
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ let t⁰ = 	
//│ 	let t¹ = (fun f¹ -> (fun a⁰ -> a⁰))
//│ 	in let h⁰ = [B]
//│ 	in (fun f² -> 
//│ 		let t² = t¹(f²)
//│ 		in let h¹ = f²(h⁰)
//│ 		in (fun a¹ -> t²([C h¹ a¹])))
//│ in let h² = [A]
//│ in let t³ = t⁰(f)
//│ in let h³ = f(h²)
//│ in t³([C h³ [N]])
//│ def f(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰) = xs⁰
//│ def rev(ys⁰) = ys⁰
//│ <<<<<<< after floating out <<<<<<<


// CORRECT:
_LUMBERHACK_EVAL
fun map(ls) = if ls is
  C(hh, tt) then C(
    (if hh is
      A then B
      AA then BB
    ),
    map(tt)
  )
  N then N
fun rev(lss) = if lss is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
map(rev(C(A, C(AA, N)))(N))
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|hh|,| |tt|)| |#then| |C|(|→|(|#if| |hh| |is|→|A| |#then| |B|↵|AA| |#then| |BB|←|↵|)|,|↵|map|(|tt|)|←|↵|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|lss|)| |#=| |#if| |lss| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|map|(|rev|(|C|(|A|,| |C|(|AA|,| |N|)|)|)|(|N|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, => if ls is ‹(C (hh, tt,)) then C ('(' if hh is ‹(A) then B; (AA) then BB›, ')', map (tt,),); (N) then N›; fun rev = lss, => if lss is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; map (rev (C (A, C (AA, N,),),) (N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^26(rev^27([C [A] [C [AA] [N]]], [N]))
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C hh⁰ tt⁰ => [C case hh⁰ of {
//│ 		A  => [B]
//│ 		| AA  => [BB]} map^6(tt⁰)]
//│ 	| N  => [N]}
//│ def rev(lss⁰) = case lss⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> rev^14(t⁰, [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [BB] [C [B] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ a⁰]: 19 --->
//│ 	case ls⁰ of {C hh⁰ tt⁰ => [C case hh⁰ of {A  => [B] | AA  => [BB]} map(tt⁰)] | N  => [N]}: 11
//│ [A]: 28 --->
//│ 	case hh⁰ of {A  => [B] | AA  => [BB]}: 5
//│ [AA]: 29 --->
//│ 	case hh⁰ of {A  => [B] | AA  => [BB]}: 5
//│ [N]: 30 --->
//│ 	case lss⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 24
//│ [C [AA] [N]]: 31 --->
//│ 	case lss⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 24
//│ [C [A] [C [AA] [N]]]: 32 --->
//│ 	case lss⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 24
//│ [N]: 34 --->
//│ 	case ls⁰ of {C hh⁰ tt⁰ => [C case hh⁰ of {A  => [B] | AA  => [BB]} map(tt⁰)] | N  => [N]}: 11
//│ ------------------
//│ case hh⁰ of {A  => [B] | AA  => [BB]}: 5 --->
//│ 	[A]: 28
//│ 	[AA]: 29
//│ case ls⁰ of {C hh⁰ tt⁰ => [C case hh⁰ of {A  => [B] | AA  => [BB]} map(tt⁰)] | N  => [N]}: 11 --->
//│ 	[C h⁰ a⁰]: 19
//│ 	[N]: 34
//│ case lss⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 24 --->
//│ 	[N]: 30
//│ 	[C [AA] [N]]: 31
//│ 	[C [A] [C [AA] [N]]]: 32
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h⁰ a⁰]: 19 --->
//│ 	case ls⁰ of {C hh⁰ tt⁰ => [C case hh⁰ of {A  => [B] | AA  => [BB]} map(tt⁰)] | N  => [N]}: 11
//│ [A]: 28 --->
//│ 	case hh⁰ of {A  => [B] | AA  => [BB]}: 5
//│ [AA]: 29 --->
//│ 	case hh⁰ of {A  => [B] | AA  => [BB]}: 5
//│ [N]: 30 --->
//│ 	case lss⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 24
//│ [C [AA] [N]]: 31 --->
//│ 	case lss⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 24
//│ [C [A] [C [AA] [N]]]: 32 --->
//│ 	case lss⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 24
//│ [N]: 34 --->
//│ 	case ls⁰ of {C hh⁰ tt⁰ => [C case hh⁰ of {A  => [B] | AA  => [BB]} map(tt⁰)] | N  => [N]}: 11
//│ ------------------
//│ case hh⁰ of {A  => [B] | AA  => [BB]}: 5 --->
//│ 	[A]: 28
//│ 	[AA]: 29
//│ case ls⁰ of {C hh⁰ tt⁰ => [C case hh⁰ of {A  => [B] | AA  => [BB]} map(tt⁰)] | N  => [N]}: 11 --->
//│ 	[C h⁰ a⁰]: 19
//│ 	[N]: 34
//│ case lss⁰ of {C h⁰ t⁰ => (fun a⁰ -> rev(t⁰, [C h⁰ a⁰])) | N  => (fun a¹ -> a¹)}: 24 --->
//│ 	[N]: 30
//│ 	[C [AA] [N]]: 31
//│ 	[C [A] [C [AA] [N]]]: 32
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(rev(
//│ 	let t¹ = 	
//│ 		let t² = (fun a⁴ -> a⁴)
//│ 		in let h² = [BB]
//│ 		in (fun a³ -> rev(t², 
//│ 			let tt² = a³
//│ 			in let hh² = h²
//│ 			in (fun _lh_dummy¹ -> [C hh² map(tt²)])))
//│ 	in let h¹ = [B]
//│ 	in (fun a² -> rev(t¹, 
//│ 		let tt¹ = a²
//│ 		in let hh¹ = h¹
//│ 		in (fun _lh_dummy⁰ -> [C hh¹ map(tt¹)]))), (fun _lh_dummy² -> [N])))
//│ def map(ls¹) = ls¹(99)
//│ def rev(lss¹) = lss¹
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [BB] [C [B] [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map, rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun a⁰ -> a⁰)
//│ 		in let h⁰ = [BB]
//│ 		in (fun a¹ -> t¹(
//│ 			let tt⁰ = a¹
//│ 			in let hh⁰ = h⁰
//│ 			in (fun _lh_dummy⁰ -> [C hh⁰ tt⁰(99)])))
//│ 	in let h¹ = [B]
//│ 	in t⁰(
//│ 		let tt¹ = (fun _lh_dummy¹ -> [N])
//│ 		in let hh¹ = h¹
//│ 		in (fun _lh_dummy² -> [C hh¹ tt¹(99)]))(99)
//│ def map(ls⁰) = ls⁰(99)
//│ def rev(lss⁰) = lss⁰
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun a⁰ -> a⁰)
//│ 		in let h⁰ = [BB]
//│ 		in (fun a¹ -> t¹(
//│ 			let tt⁰ = a¹
//│ 			in let hh⁰ = h⁰
//│ 			in (fun _lh_dummy⁰ -> [C hh⁰ tt⁰(99)])))
//│ 	in let h¹ = [B]
//│ 	in t⁰(
//│ 		let tt¹ = (fun _lh_dummy¹ -> [N])
//│ 		in let hh¹ = h¹
//│ 		in (fun _lh_dummy² -> [C hh¹ tt¹(99)]))(99)
//│ def map(ls⁰) = ls⁰(99)
//│ def rev(lss⁰) = lss⁰
//│ <<<<<<< after floating out <<<<<<<

_LUMBERHACK_EVAL
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun rev(a, ys) = if ys is
  C(h, t) then rev(C(h, a), t)
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
map(rev(N, C(A, C(B, N))), ff)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|map|(|rev|(|N|,| |C|(|A|,| |C|(|B|,| |N|)|)|)|,| |ff|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun rev = a, ys, => if ys is ‹(C (h, t,)) then rev (C (h, a,), t,); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; map (rev (N, C (A, C (B, N,),),), ff,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^32(rev^33([N], [C [A] [C [B] [N]]]), ff^43)
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => rev^16([C h¹ a⁰], t¹)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ a⁰]: 19 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [N]: 34 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [A]: 36 --->
//│ 	case x⁰ of {A  => [AA] | B  => [BB]}: 30
//│ [B]: 37 --->
//│ 	case x⁰ of {A  => [AA] | B  => [BB]}: 30
//│ [N]: 38 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ [C [B] [N]]: 39 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ [C [A] [C [B] [N]]]: 40 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12 --->
//│ 	[C h¹ a⁰]: 19
//│ 	[N]: 34
//│ case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24 --->
//│ 	[N]: 38
//│ 	[C [B] [N]]: 39
//│ 	[C [A] [C [B] [N]]]: 40
//│ case x⁰ of {A  => [AA] | B  => [BB]}: 30 --->
//│ 	[A]: 36
//│ 	[B]: 37
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a⁰]: 19 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [N]: 34 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [A]: 36 --->
//│ 	case x⁰ of {A  => [AA] | B  => [BB]}: 30
//│ [B]: 37 --->
//│ 	case x⁰ of {A  => [AA] | B  => [BB]}: 30
//│ [N]: 38 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ [C [B] [N]]: 39 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ [C [A] [C [B] [N]]]: 40 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12 --->
//│ 	[C h¹ a⁰]: 19
//│ 	[N]: 34
//│ case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24 --->
//│ 	[N]: 38
//│ 	[C [B] [N]]: 39
//│ 	[C [A] [C [B] [N]]]: 40
//│ case x⁰ of {A  => [AA] | B  => [BB]}: 30 --->
//│ 	[A]: 36
//│ 	[B]: 37
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(rev((fun f¹ -> [N]), 
//│ 	let t² = 	
//│ 		let t⁴ = (fun a³ -> a³)
//│ 		in let h⁴ = [BB]
//│ 		in (fun a² -> rev(
//│ 			let t⁵ = a²
//│ 			in let h⁵ = h⁴
//│ 			in (fun f³ -> [C f³(h⁵) map(t⁵, f³)]), t⁴))
//│ 	in let h² = [AA]
//│ 	in (fun a¹ -> rev(
//│ 		let t³ = a¹
//│ 		in let h³ = h²
//│ 		in (fun f² -> [C f²(h³) map(t³, f²)]), t²))), ff)
//│ def ff(x¹) = x¹
//│ def map(xs¹, f⁴) = xs¹(f⁴)
//│ def rev(a⁴, ys¹) = ys¹(a⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ ff, rev, map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun a⁰ -> a⁰)
//│ 		in let h⁰ = [BB]
//│ 		in (fun a¹ -> t¹(
//│ 			let t² = a¹
//│ 			in let h¹ = h⁰
//│ 			in (fun f⁰ -> [C f⁰(h¹) t²(f⁰)])))
//│ 	in let h² = [AA]
//│ 	in (fun a² -> t⁰(
//│ 		let t³ = a²
//│ 		in let h³ = h²
//│ 		in (fun f¹ -> [C f¹(h³) t³(f¹)])))((fun f² -> [N]), ff)
//│ def ff(x⁰) = x⁰
//│ def map(xs⁰, f³) = xs⁰(f³)
//│ def rev(a³, ys⁰) = ys⁰(a³)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun a⁰ -> a⁰)
//│ 		in let h⁰ = [BB]
//│ 		in (fun a¹ -> t¹(
//│ 			let t² = a¹
//│ 			in let h¹ = h⁰
//│ 			in (fun f⁰ -> [C f⁰(h¹) t²(f⁰)])))
//│ 	in let h² = [AA]
//│ 	in (fun a² -> t⁰(
//│ 		let t³ = a²
//│ 		in let h³ = h²
//│ 		in (fun f¹ -> [C f¹(h³) t³(f¹)])))((fun f² -> [N]), ff)
//│ def ff(x⁰) = x⁰
//│ def map(xs⁰, f³) = xs⁰(f³)
//│ def rev(a³, ys⁰) = ys⁰(a³)
//│ <<<<<<< after floating out <<<<<<<

_LUMBERHACK_EVAL
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun rev(a, ys) = if ys is
  C(h, t) then rev(C(h, a), t)
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
rev(N, map(C(A, C(B, N)), ff))
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|rev|(|N|,| |map|(|C|(|A|,| |C|(|B|,| |N|)|)|,| |ff|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun rev = a, ys, => if ys is ‹(C (h, t,)) then rev (C (h, a,), t,); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; rev (N, map (C (A, C (B, N,),), ff,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^32([N], map^35([C [A] [C [B] [N]]], ff^42))
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => rev^16([C h¹ a⁰], t¹)
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ [N]: 11 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ [A]: 36 --->
//│ 	case x⁰ of {A  => [AA] | B  => [BB]}: 30
//│ [B]: 37 --->
//│ 	case x⁰ of {A  => [AA] | B  => [BB]}: 30
//│ [N]: 38 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [C [B] [N]]: 39 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [C [A] [C [B] [N]]]: 40 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 38
//│ 	[C [B] [N]]: 39
//│ 	[C [A] [C [B] [N]]]: 40
//│ case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ case x⁰ of {A  => [AA] | B  => [BB]}: 30 --->
//│ 	[A]: 36
//│ 	[B]: 37
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ [N]: 11 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ [A]: 36 --->
//│ 	case x⁰ of {A  => [AA] | B  => [BB]}: 30
//│ [B]: 37 --->
//│ 	case x⁰ of {A  => [AA] | B  => [BB]}: 30
//│ [N]: 38 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [C [B] [N]]: 39 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [C [A] [C [B] [N]]]: 40 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 38
//│ 	[C [B] [N]]: 39
//│ 	[C [A] [C [B] [N]]]: 40
//│ case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ case x⁰ of {A  => [AA] | B  => [BB]}: 30 --->
//│ 	[A]: 36
//│ 	[B]: 37
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev([N], map(
//│ 	let t² = 	
//│ 		let t⁴ = (fun f³ -> (fun a³ -> a³))
//│ 		in let h⁴ = [BB]
//│ 		in (fun f² -> 
//│ 			let t⁵ = map(t⁴, f²)
//│ 			in let h⁵ = f²(h⁴)
//│ 			in (fun a² -> rev([C h⁵ a²], t⁵)))
//│ 	in let h² = [AA]
//│ 	in (fun f¹ -> 
//│ 		let t³ = map(t², f¹)
//│ 		in let h³ = f¹(h²)
//│ 		in (fun a¹ -> rev([C h³ a¹], t³))), ff))
//│ def ff(x¹) = x¹
//│ def map(xs¹, f⁴) = xs¹(f⁴)
//│ def rev(a⁴, ys¹) = ys¹(a⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ ff, rev, map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun f⁰ -> (fun a⁰ -> a⁰))
//│ 		in let h⁰ = [BB]
//│ 		in (fun f¹ -> 
//│ 			let t² = t¹(f¹)
//│ 			in let h¹ = f¹(h⁰)
//│ 			in (fun a¹ -> t²([C h¹ a¹])))
//│ 	in let h² = [AA]
//│ 	in (fun f² -> 
//│ 		let t³ = t⁰(f²)
//│ 		in let h³ = f²(h²)
//│ 		in (fun a² -> t³([C h³ a²])))(ff, [N])
//│ def ff(x⁰) = x⁰
//│ def map(xs⁰, f³) = xs⁰(f³)
//│ def rev(a³, ys⁰) = ys⁰(a³)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun f⁰ -> (fun a⁰ -> a⁰))
//│ 		in let h⁰ = [BB]
//│ 		in (fun f¹ -> 
//│ 			let t² = t¹(f¹)
//│ 			in let h¹ = f¹(h⁰)
//│ 			in (fun a¹ -> t²([C h¹ a¹])))
//│ 	in let h² = [AA]
//│ 	in (fun f² -> 
//│ 		let t³ = t⁰(f²)
//│ 		in let h³ = f²(h²)
//│ 		in (fun a² -> t³([C h³ a²])))(ff, [N])
//│ def ff(x⁰) = x⁰
//│ def map(xs⁰, f³) = xs⁰(f³)
//│ def rev(a³, ys⁰) = ys⁰(a³)
//│ <<<<<<< after floating out <<<<<<<

// NOTE: this example works when no concrete input is provided
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun rev(a, ys) = if ys is
  C(h, t) then rev(C(h, a), t)
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
fun revMap(ls, f) = rev(N, map(ls, f))
revMap
//│ |#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|#fun| |revMap|(|ls|,| |f|)| |#=| |rev|(|N|,| |map|(|ls|,| |f|)|)|↵|revMap|
//│ Parsed: {fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun rev = a, ys, => if ys is ‹(C (h, t,)) then rev (C (h, a,), t,); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; fun revMap = ls, f, => rev (N, map (ls, f,),); revMap}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ revMap^43
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ def rev(a⁰, ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => rev^16([C h¹ a⁰], t¹)
//│ 	| N  => a⁰}
//│ def revMap(ls⁰, f¹) = rev^32([N], map^35(ls⁰, f¹))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ [N]: 11 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ ------------------
//│ case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ [N]: 11 --->
//│ 	case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24
//│ ------------------
//│ case ys⁰ of {C h¹ t¹ => rev([C h¹ a⁰], t¹) | N  => a⁰}: 24 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ revMap
//│ def ff(x¹) = case x¹ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs¹, f²) = case xs¹ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t² = map(t⁰, f²)
//│ 		in let h² = f²(h⁰)
//│ 		in (fun a¹ -> rev([C h² a¹], t²))
//│ 	| N  => (fun a² -> a²)}
//│ def rev(a³, ys¹) = ys¹(a³)
//│ def revMap(ls¹, f³) = rev([N], map(ls¹, f³))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ map -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ revMap
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t¹ = map(t⁰, f⁰)
//│ 		in let h¹ = f⁰(h⁰)
//│ 		in (fun a⁰ -> t¹([C h¹ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ def rev(a², ys⁰) = ys⁰(a²)
//│ def revMap(ls⁰, f¹) = map(ls⁰, f¹, [N])
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ revMap
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def map(xs⁰, f⁰, _lh_popOutId_0⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t¹ = map(t⁰, f⁰)
//│ 		in let h¹ = f⁰(h⁰)
//│ 		in t¹([C h¹ _lh_popOutId_0⁰])
//│ 	| N  => _lh_popOutId_0⁰}
//│ def rev(a⁰, ys⁰) = ys⁰(a⁰)
//│ def revMap(ls⁰, f¹) = map(ls⁰, f¹, [N])
//│ <<<<<<< after floating out <<<<<<<
