:NewParser
:ParseOnly

fun concat(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
let l = C(1, l)
rev(l)
//│ |#fun| |concat|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|1|,| |l|)|↵|rev|(|l|)|
//│ Parsed: {fun concat = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; let l = C (1, l,); rev (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^29(l^30)
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat^4(t⁰, ys⁰)]}
//│ def l = [C 1 l^27]
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^14(rev^15(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ concat(t⁰, ys⁰)]: 9 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 20 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [C h¹ [N]]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 23 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [C 1 l]: 28 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ ------------------
//│ case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10 --->
//│ 	[C h⁰ concat(t⁰, ys⁰)]: 9
//│ 	[N]: 20
//│ 	[C h¹ [N]]: 21
//│ 	[N]: 23
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24 --->
//│ 	[C 1 l]: 28
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 l]: 28 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ ------------------
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24 --->
//│ 	[C 1 l]: 28
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(l)
//│ def concat(xs¹, ys¹) = case xs¹ of {
//│ 	N  => ys¹
//│ 	| C h⁰ t⁰ => [C h⁰ concat(t⁰, ys¹)]}
//│ def l = 
//│ 	let t² = l
//│ 	in let h² = 1
//│ 	in (fun _lh_dummy⁰ -> concat(rev(t²), [C h² [N]]))
//│ def rev(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ l -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ l(99)
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}
//│ def l = 
//│ 	let t¹ = l
//│ 	in let h¹ = 1
//│ 	in (fun _lh_dummy⁰ -> concat(t¹(99), [C h¹ [N]]))
//│ def rev(ls⁰) = ls⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ l(99)
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}
//│ def l = 
//│ 	let t¹ = l
//│ 	in let h¹ = 1
//│ 	in (fun _lh_dummy⁰ -> concat(t¹(99), [C h¹ [N]]))
//│ def rev(ls⁰) = ls⁰(99)
//│ <<<<<<< after floating out <<<<<<<


fun concat(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
let l = C(1, C(2, l))
rev(l)
//│ |#fun| |concat|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|1|,| |C|(|2|,| |l|)|)|↵|rev|(|l|)|
//│ Parsed: {fun concat = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; let l = C (1, C (2, l,),); rev (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^31(l^32)
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat^4(t⁰, ys⁰)]}
//│ def l = [C 1 [C 2 l^28]]
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^14(rev^15(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ concat(t⁰, ys⁰)]: 9 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 20 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [C h¹ [N]]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [N]: 23 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10
//│ [C 2 l]: 29 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ [C 1 [C 2 l]]: 30 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ ------------------
//│ case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}: 10 --->
//│ 	[C h⁰ concat(t⁰, ys⁰)]: 9
//│ 	[N]: 20
//│ 	[C h¹ [N]]: 21
//│ 	[N]: 23
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24 --->
//│ 	[C 2 l]: 29
//│ 	[C 1 [C 2 l]]: 30
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 2 l]: 29 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ [C 1 [C 2 l]]: 30 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24
//│ ------------------
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 24 --->
//│ 	[C 2 l]: 29
//│ 	[C 1 [C 2 l]]: 30
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(l)
//│ def concat(xs¹, ys¹) = case xs¹ of {
//│ 	N  => ys¹
//│ 	| C h⁰ t⁰ => [C h⁰ concat(t⁰, ys¹)]}
//│ def l = 
//│ 	let t² = 	
//│ 		let t³ = l
//│ 		in let h³ = 2
//│ 		in (fun _lh_dummy¹ -> concat(rev(t³), [C h³ [N]]))
//│ 	in let h² = 1
//│ 	in (fun _lh_dummy⁰ -> concat(rev(t²), [C h² [N]]))
//│ def rev(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ l -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ l(99)
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}
//│ def l = 
//│ 	let t¹ = 	
//│ 		let t² = l
//│ 		in let h¹ = 2
//│ 		in (fun _lh_dummy⁰ -> concat(t²(99), [C h¹ [N]]))
//│ 	in let h² = 1
//│ 	in (fun _lh_dummy¹ -> concat(t¹(99), [C h² [N]]))
//│ def rev(ls⁰) = ls⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ l(99)
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat(t⁰, ys⁰)]}
//│ def l = 
//│ 	let t¹ = 	
//│ 		let t² = l
//│ 		in let h¹ = 2
//│ 		in (fun _lh_dummy⁰ -> concat(t²(99), [C h¹ [N]]))
//│ 	in let h² = 1
//│ 	in (fun _lh_dummy¹ -> concat(t¹(99), [C h² [N]]))
//│ def rev(ls⁰) = ls⁰(99)
//│ <<<<<<< after floating out <<<<<<<


// above, rev using concat; below, rev using accumulating parameter

// NOTE: fuses well, as long as the producer recursive length is a multiple of the consumer recursive length?
fun rev(ls, a) = if ls is
  C(h, t) then rev(t, C(h, a))
  N then a
let l = C(1, C(2, l))
rev(l, N)
//│ |#fun| |rev|(|ls|,| |a|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a|←|↵|#let| |l| |#=| |C|(|1|,| |C|(|2|,| |l|)|)|↵|rev|(|l|,| |N|)|
//│ Parsed: {fun rev = ls, a, => if ls is ‹(C (h, t,)) then rev (t, C (h, a,),); (N) then a›; let l = C (1, C (2, l,),); rev (l, N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^18(l^19, [N])
//│ def l = [C 1 [C 2 l^15]]
//│ def rev(ls⁰, a⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => rev^2(t⁰, [C h⁰ a⁰])
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 2 l]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ [C 1 [C 2 l]]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10 --->
//│ 	[C 2 l]: 16
//│ 	[C 1 [C 2 l]]: 17
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 2 l]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ [C 1 [C 2 l]]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10 --->
//│ 	[C 2 l]: 16
//│ 	[C 1 [C 2 l]]: 17
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(l, [N])
//│ def l = 
//│ 	let t¹ = 	
//│ 		let t² = l
//│ 		in let h² = 2
//│ 		in (fun a³ -> rev(t², [C h² a³]))
//│ 	in let h¹ = 1
//│ 	in (fun a² -> rev(t¹, [C h¹ a²]))
//│ def rev(ls¹, a¹) = ls¹(a¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ l -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ l([N])
//│ def l = 
//│ 	let t⁰ = 	
//│ 		let t¹ = l
//│ 		in let h⁰ = 2
//│ 		in (fun a¹ -> t¹([C h⁰ a¹]))
//│ 	in let h¹ = 1
//│ 	in (fun a² -> t⁰([C h¹ a²]))
//│ def rev(ls⁰, a⁰) = ls⁰(a⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ l([N])
//│ def l = 
//│ 	let t⁰ = 	
//│ 		let t¹ = l
//│ 		in let h⁰ = 2
//│ 		in (fun a¹ -> t¹([C h⁰ a¹]))
//│ 	in let h¹ = 1
//│ 	in (fun a² -> t⁰([C h¹ a²]))
//│ def rev(ls⁰, a⁰) = ls⁰(a⁰)
//│ <<<<<<< after floating out <<<<<<<


fun rev(ls, a) = if ls is
  C(h, t) then rev(t, C(h, a))
  N then a
let l = C(A, C(B, l))
rev(l, N)
//│ |#fun| |rev|(|ls|,| |a|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a|←|↵|#let| |l| |#=| |C|(|A|,| |C|(|B|,| |l|)|)|↵|rev|(|l|,| |N|)|
//│ Parsed: {fun rev = ls, a, => if ls is ‹(C (h, t,)) then rev (t, C (h, a,),); (N) then a›; let l = C (A, C (B, l,),); rev (l, N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^18(l^19, [N])
//│ def l = [C [A] [C [B] l^15]]
//│ def rev(ls⁰, a⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => rev^2(t⁰, [C h⁰ a⁰])
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [B] l]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ [C [A] [C [B] l]]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10 --->
//│ 	[C [B] l]: 16
//│ 	[C [A] [C [B] l]]: 17
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [B] l]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ [C [A] [C [B] l]]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => rev(t⁰, [C h⁰ a⁰]) | N  => a⁰}: 10 --->
//│ 	[C [B] l]: 16
//│ 	[C [A] [C [B] l]]: 17
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(l, [N])
//│ def l = 
//│ 	let t¹ = 	
//│ 		let t² = l
//│ 		in let h² = [B]
//│ 		in (fun a³ -> rev(t², [C h² a³]))
//│ 	in let h¹ = [A]
//│ 	in (fun a² -> rev(t¹, [C h¹ a²]))
//│ def rev(ls¹, a¹) = ls¹(a¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ l -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ l([N])
//│ def l = 
//│ 	let t⁰ = 	
//│ 		let t¹ = l
//│ 		in let h⁰ = [B]
//│ 		in (fun a¹ -> t¹([C h⁰ a¹]))
//│ 	in let h¹ = [A]
//│ 	in (fun a² -> t⁰([C h¹ a²]))
//│ def rev(ls⁰, a⁰) = ls⁰(a⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ l([N])
//│ def l = 
//│ 	let t⁰ = 	
//│ 		let t¹ = l
//│ 		in let h⁰ = [B]
//│ 		in (fun a¹ -> t¹([C h⁰ a¹]))
//│ 	in let h¹ = [A]
//│ 	in (fun a² -> t⁰([C h¹ a²]))
//│ def rev(ls⁰, a⁰) = ls⁰(a⁰)
//│ <<<<<<< after floating out <<<<<<<
