:NewParser
:ParseOnly

fun concat(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
let l = C(1, l)
rev(l)
//│ |#fun| |concat|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|1|,| |l|)|↵|rev|(|l|)|
//│ Parsed: {fun concat = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; let l = C (1, l,); rev (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^29(l^30)
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat^4(t⁰, ys⁰)]}
//│ def l = [C 1 l^27]
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^14(rev^15(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^30]
//│ 	[l^30 · l^27] ---> [l^30] (only one)
//│ [rev^29]
//│ 	[rev^29 · concat^14]
//│ 		[rev^29 · concat^14 · concat^4] ---> [rev^29 · concat^14] (only one)
//│ 	[rev^29 · rev^15] ---> [rev^29] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀(l_₀)
//│ def l_₀ = 
//│ 	[C 1 l_₀]
//│ def rev_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h² t² => concat_₀(rev_₀(t²), [C h² [N]])
//│ 		| N  => [N]}
//│ 	where
//│ 	def concat_₀(xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			N  => ys¹
//│ 			| C h³ t³ => [C h³ concat_₀(t³, ys¹)]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 39 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 57
//│ [C h² [N]]: 40 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 57
//│ [N]: 42 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 57
//│ [C 1 l_₀]: 47 --->
//│ 	case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 43
//│ [C h³ concat_₀(t³, ys¹)]: 56 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 57
//│ ------------------
//│ case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 43 --->
//│ 	[C 1 l_₀]: 47
//│ case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀(t³, ys¹)]}: 57 --->
//│ 	[N]: 39
//│ 	[C h² [N]]: 40
//│ 	[N]: 42
//│ 	[C h³ concat_₀(t³, ys¹)]: 56
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 l_₀]: 47 --->
//│ 	case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 43
//│ ------------------
//│ case ls¹ of {C h² t² => concat_₀(rev_₀(t²), [C h² [N]]) | N  => [N]}: 43 --->
//│ 	[C 1 l_₀]: 47
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(l_₀)
//│ def l_₀ = 
//│ 	let t⁴ = l_₀
//│ 	in let h⁴ = 1
//│ 	in (fun _lh_dummy⁰ -> concat_₀(rev_₀(t⁴), [C h⁴ [N]]))
//│ def rev_₀(ls²) = 
//│ 	ls²(99)
//│ 	where
//│ 	def concat_₀(xs², ys²) = 
//│ 		case xs² of {
//│ 			N  => ys²
//│ 			| C h³ t³ => [C h³ concat_₀(t³, ys²)]}
//│ <<<<<<< after fusion <<<<<<<


fun concat(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
let l = C(1, C(2, l))
rev(l)
//│ |#fun| |concat|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|1|,| |C|(|2|,| |l|)|)|↵|rev|(|l|)|
//│ Parsed: {fun concat = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; let l = C (1, C (2, l,),); rev (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^31(l^32)
//│ def concat(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ concat^4(t⁰, ys⁰)]}
//│ def l = [C 1 [C 2 l^28]]
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^14(rev^15(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^32]
//│ 	[l^32 · l^28] ---> [l^32] (only one)
//│ [rev^31]
//│ 	[rev^31 · concat^14]
//│ 		[rev^31 · concat^14 · concat^4] ---> [rev^31 · concat^14] (only one)
//│ 	[rev^31 · rev^15] ---> [rev^31] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀(l_₀)
//│ def l_₀ = 
//│ 	[C 1 [C 2 l_₀]]
//│ def rev_₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]])
//│ 		| N  => [N]}
//│ 	where
//│ 	def concat_₀(xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			N  => ys¹
//│ 			| C h² t² => [C h² concat_₀(t², ys¹)]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 2 l_₀]: 37 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 62
//│ [C 1 [C 2 l_₀]]: 38 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 62
//│ [C h² concat_₀(t², ys¹)]: 47 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h² t² => [C h² concat_₀(t², ys¹)]}: 48
//│ [N]: 58 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h² t² => [C h² concat_₀(t², ys¹)]}: 48
//│ [C h³ [N]]: 59 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h² t² => [C h² concat_₀(t², ys¹)]}: 48
//│ [N]: 61 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h² t² => [C h² concat_₀(t², ys¹)]}: 48
//│ ------------------
//│ case xs¹ of {N  => ys¹ | C h² t² => [C h² concat_₀(t², ys¹)]}: 48 --->
//│ 	[C h² concat_₀(t², ys¹)]: 47
//│ 	[N]: 58
//│ 	[C h³ [N]]: 59
//│ 	[N]: 61
//│ case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 62 --->
//│ 	[C 2 l_₀]: 37
//│ 	[C 1 [C 2 l_₀]]: 38
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 2 l_₀]: 37 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 62
//│ [C 1 [C 2 l_₀]]: 38 --->
//│ 	case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 62
//│ ------------------
//│ case ls¹ of {C h³ t³ => concat_₀(rev_₀(t³), [C h³ [N]]) | N  => [N]}: 62 --->
//│ 	[C 2 l_₀]: 37
//│ 	[C 1 [C 2 l_₀]]: 38
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(l_₀)
//│ def l_₀ = 
//│ 	let t⁴ = 	
//│ 		let t⁵ = l_₀
//│ 		in let h⁵ = 2
//│ 		in (fun _lh_dummy¹ -> concat_₀(rev_₀(t⁵), [C h⁵ [N]]))
//│ 	in let h⁴ = 1
//│ 	in (fun _lh_dummy⁰ -> concat_₀(rev_₀(t⁴), [C h⁴ [N]]))
//│ def rev_₀(ls²) = 
//│ 	ls²(99)
//│ 	where
//│ 	def concat_₀(xs², ys²) = 
//│ 		case xs² of {
//│ 			N  => ys²
//│ 			| C h² t² => [C h² concat_₀(t², ys²)]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l_₀^2] (hopeless to continue)
//│ 	[l_₀^2 · concat_₀^19] (using original def)
//│ 		[l_₀^2 · concat_₀^19 · concat_₀^34] ---> [l_₀^2 · concat_₀^19] (using original def)
//│ 	[l_₀^2 · concat_₀^6] (using original def)
//│ 		[l_₀^2 · concat_₀^6 · concat_₀^34] ---> [l_₀^2 · concat_₀^6] (using original def)
//│ 	[l_₀^2 · l_₀^4] ---> [l_₀^2] (using original def)
//│ 	[l_₀^2 · rev_₀^20] (using original def)
//│ 	[l_₀^2 · rev_₀^7] (using original def)
//│ [rev_₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀_₂(l_₀_₀)
//│ def l_₀_₀ = 
//│ 	let t⁵ = 	
//│ 		let t⁶ = l_₀_₀
//│ 		in let h⁵ = 2
//│ 		in (fun _lh_dummy² -> concat_₀_₁(rev_₀_₁(t⁶), [C h⁵ [N]]))
//│ 	in let h⁶ = 1
//│ 	in (fun _lh_dummy³ -> concat_₀_₀(rev_₀_₀(t⁵), [C h⁶ [N]]))
//│ 	where
//│ 	def concat_₀_₀(xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			N  => ys¹
//│ 			| C h³ t³ => [C h³ concat_₀_₀(t³, ys¹)]}
//│ 	def concat_₀_₁(xs², ys²) = 
//│ 		case xs² of {
//│ 			N  => ys²
//│ 			| C h⁴ t⁴ => [C h⁴ concat_₀_₁(t⁴, ys²)]}
//│ 	def rev_₀_₀(ls¹) = 
//│ 		ls¹(99)
//│ 	def rev_₀_₁(ls²) = 
//│ 		ls²(99)
//│ def rev_₀_₂(ls³) = 
//│ 	ls³(99)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h³ concat_₀_₀(t³, ys¹)]: 63 --->
//│ 	NoCons
//│ 	case xs² of {N  => ys² | C h⁴ t⁴ => [C h⁴ concat_₀_₁(t⁴, ys²)]}: 80
//│ [C h⁴ concat_₀_₁(t⁴, ys²)]: 79 --->
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀_₀(t³, ys¹)]}: 64
//│ [N]: 91 --->
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀_₀(t³, ys¹)]}: 64
//│ [C h⁵ [N]]: 92 --->
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀_₀(t³, ys¹)]}: 64
//│ [N]: 104 --->
//│ 	NoCons
//│ 	case xs² of {N  => ys² | C h⁴ t⁴ => [C h⁴ concat_₀_₁(t⁴, ys²)]}: 80
//│ [C h⁶ [N]]: 105 --->
//│ 	NoCons
//│ 	case xs² of {N  => ys² | C h⁴ t⁴ => [C h⁴ concat_₀_₁(t⁴, ys²)]}: 80
//│ ------------------
//│ case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀_₀(t³, ys¹)]}: 64 --->
//│ 	[C h⁴ concat_₀_₁(t⁴, ys²)]: 79
//│ 	[N]: 91
//│ 	[C h⁵ [N]]: 92
//│ case xs² of {N  => ys² | C h⁴ t⁴ => [C h⁴ concat_₀_₁(t⁴, ys²)]}: 80 --->
//│ 	[C h³ concat_₀_₀(t³, ys¹)]: 63
//│ 	[N]: 104
//│ 	[C h⁶ [N]]: 105
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h⁴ concat_₀_₁(t⁴, ys²)]: 79 --->
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀_₀(t³, ys¹)]}: 64
//│ [N]: 91 --->
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀_₀(t³, ys¹)]}: 64
//│ [C h⁵ [N]]: 92 --->
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀_₀(t³, ys¹)]}: 64
//│ ------------------
//│ case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ concat_₀_₀(t³, ys¹)]}: 64 --->
//│ 	[C h⁴ concat_₀_₁(t⁴, ys²)]: 79
//│ 	[N]: 91
//│ 	[C h⁵ [N]]: 92
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀_₂(l_₀_₀)
//│ def l_₀_₀ = 
//│ 	let t⁸ = 	
//│ 		let t⁹ = l_₀_₀
//│ 		in let h⁸ = 2
//│ 		in (fun _lh_dummy⁴ -> concat_₀_₁(rev_₀_₁(t⁹), 
//│ 			let t¹⁰ = (fun ys⁷ -> ys⁷)
//│ 			in let h⁹ = h⁸
//│ 			in (fun ys⁶ -> [C h⁹ concat_₀_₀(t¹⁰, ys⁶)])))
//│ 	in let h¹⁰ = 1
//│ 	in (fun _lh_dummy⁵ -> concat_₀_₀(rev_₀_₀(t⁸), [C h¹⁰ [N]]))
//│ 	where
//│ 	def concat_₀_₀(xs⁴, ys⁵) = 
//│ 		xs⁴(ys⁵)
//│ 	def concat_₀_₁(xs³, ys³) = 
//│ 		case xs³ of {
//│ 			N  => ys³
//│ 			| C h⁴ t⁴ => 
//│ 				let t⁷ = concat_₀_₁(t⁴, ys³)
//│ 				in let h⁷ = h⁴
//│ 				in (fun ys⁴ -> [C h⁷ concat_₀_₀(t⁷, ys⁴)])}
//│ 	def rev_₀_₀(ls⁴) = 
//│ 		ls⁴(99)
//│ 	def rev_₀_₁(ls⁵) = 
//│ 		ls⁵(99)
//│ def rev_₀_₂(ls⁶) = 
//│ 	ls⁶(99)
//│ <<<<<<< after fusion <<<<<<<


// above, rev using concat; below, rev using accumulating parameter

// NOTE: fuses well, as long as the producer recursive length is a multiple of the consumer recursive length?
fun rev(ls, a) = if ls is
  C(h, t) then rev(t, C(h, a))
  N then a
let l = C(1, C(2, l))
rev(l, N)
//│ |#fun| |rev|(|ls|,| |a|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a|←|↵|#let| |l| |#=| |C|(|1|,| |C|(|2|,| |l|)|)|↵|rev|(|l|,| |N|)|
//│ Parsed: {fun rev = ls, a, => if ls is ‹(C (h, t,)) then rev (t, C (h, a,),); (N) then a›; let l = C (1, C (2, l,),); rev (l, N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^18(l^19, [N])
//│ def l = [C 1 [C 2 l^15]]
//│ def rev(ls⁰, a⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => rev^2(t⁰, [C h⁰ a⁰])
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^19]
//│ 	[l^19 · l^15] ---> [l^19] (only one)
//│ [rev^18]
//│ 	[rev^18 · rev^2] ---> [rev^18] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀(l_₀, [N])
//│ def l_₀ = 
//│ 	[C 1 [C 2 l_₀]]
//│ def rev_₀(ls¹, a¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => rev_₀(t¹, [C h¹ a¹])
//│ 		| N  => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 2 l_₀]: 26 --->
//│ 	case ls¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 37
//│ [C 1 [C 2 l_₀]]: 27 --->
//│ 	case ls¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 37
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 37 --->
//│ 	[C 2 l_₀]: 26
//│ 	[C 1 [C 2 l_₀]]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 2 l_₀]: 26 --->
//│ 	case ls¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 37
//│ [C 1 [C 2 l_₀]]: 27 --->
//│ 	case ls¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 37
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => rev_₀(t¹, [C h¹ a¹]) | N  => a¹}: 37 --->
//│ 	[C 2 l_₀]: 26
//│ 	[C 1 [C 2 l_₀]]: 27
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(l_₀, [N])
//│ def l_₀ = 
//│ 	let t² = 	
//│ 		let t³ = l_₀
//│ 		in let h³ = 2
//│ 		in (fun a³ -> rev_₀(t³, [C h³ a³]))
//│ 	in let h² = 1
//│ 	in (fun a² -> rev_₀(t², [C h² a²]))
//│ def rev_₀(ls², a⁴) = 
//│ 	ls²(a⁴)
//│ <<<<<<< after fusion <<<<<<<


fun rev(ls, a) = if ls is
  C(h, t) then rev(t, C(h, a))
  N then a
let l = C(A, C(B, l))
rev(l, N)
//│ |#fun| |rev|(|ls|,| |a|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |a|)|)|↵|N| |#then| |a|←|↵|#let| |l| |#=| |C|(|A|,| |C|(|B|,| |l|)|)|↵|rev|(|l|,| |N|)|
//│ Parsed: {fun rev = ls, a, => if ls is ‹(C (h, t,)) then rev (t, C (h, a,),); (N) then a›; let l = C (A, C (B, l,),); rev (l, N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^18(l^19, [N])
//│ def l = [C [A] [C [B] l^15]]
//│ def rev(ls⁰, a⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => rev^2(t⁰, [C h⁰ a⁰])
//│ 	| N  => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^19]
//│ 	[l^19 · l^15] ---> [l^19] (only one)
//│ [rev^18]
//│ 	[rev^18 · rev^2]
//│ 		[rev^18 · rev^2 · rev^2] ---> [rev^18] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ rev_₀(l_₀, [N])
//│ def l_₀ = 
//│ 	[C [A] [C [B] l_₀]]
//│ def rev_₀(ls¹, a¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => rev_₁(t¹, [C h¹ a¹])
//│ 		| N  => a¹}
//│ 	where
//│ 	def rev_₁(ls², a²) = 
//│ 		case ls² of {
//│ 			C h² t² => rev_₀(t², [C h² a²])
//│ 			| N  => a²}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [B] l_₀]: 38 --->
//│ 	case ls² of {C h² t² => rev_₀(t², [C h² a²]) | N  => a²}: 49
//│ [C [A] [C [B] l_₀]]: 39 --->
//│ 	case ls¹ of {C h¹ t¹ => rev_₁(t¹, [C h¹ a¹]) | N  => a¹}: 32
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => rev_₁(t¹, [C h¹ a¹]) | N  => a¹}: 32 --->
//│ 	[C [A] [C [B] l_₀]]: 39
//│ case ls² of {C h² t² => rev_₀(t², [C h² a²]) | N  => a²}: 49 --->
//│ 	[C [B] l_₀]: 38
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [B] l_₀]: 38 --->
//│ 	case ls² of {C h² t² => rev_₀(t², [C h² a²]) | N  => a²}: 49
//│ [C [A] [C [B] l_₀]]: 39 --->
//│ 	case ls¹ of {C h¹ t¹ => rev_₁(t¹, [C h¹ a¹]) | N  => a¹}: 32
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => rev_₁(t¹, [C h¹ a¹]) | N  => a¹}: 32 --->
//│ 	[C [A] [C [B] l_₀]]: 39
//│ case ls² of {C h² t² => rev_₀(t², [C h² a²]) | N  => a²}: 49 --->
//│ 	[C [B] l_₀]: 38
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev_₀(l_₀, [N])
//│ def l_₀ = 
//│ 	let t³ = 	
//│ 		let t⁴ = l_₀
//│ 		in let h⁴ = [B]
//│ 		in (fun a⁵ -> rev_₀(t⁴, [C h⁴ a⁵]))
//│ 	in let h³ = [A]
//│ 	in (fun a⁴ -> rev_₁(t³, [C h³ a⁴]))
//│ def rev_₀(ls³, a³) = 
//│ 	ls³(a³)
//│ 	where
//│ 	def rev_₁(ls⁴, a⁶) = 
//│ 		ls⁴(a⁶)
//│ <<<<<<< after fusion <<<<<<<
