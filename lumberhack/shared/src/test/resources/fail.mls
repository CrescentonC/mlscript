:NewParser
:ParseOnly

:ns
// the `p · p` is never touched (checked) by the typer, so no path leads to it, and no recusive map from it
let p = C(p)
fun c(x) = if C(x) is
    C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^10 p^11)
//│ def c = (fun x:8 -> case [C x:8] of {
//│ 	C a:9 => (c^5 a:9)})
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^10] ---> [c^10] (hopeless to continue)
//│ [p^11] ---> [p^11] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c p)
//│ def c = (fun x:8 -> case [C x:8] of {
//│ 	C a:9 => (c a:9)})
//│ def p = [C p]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 7: [C 6: x]
//│ [C x:8] --->
//│ 	case [C x:8] of {C a:9 => (c a:9)}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c p)
//│ def c = (fun x:8 -> let a:9 = x:8
//│ in (c a:9))
//│ def p = [C p]
//│ <<<<<<< after fusion <<<<<<<

// the `p · p` is never touched (checked) by the typer, so no path leads to it, and no recusive map from it
:ns
let rec p = C(p)
fun c(x) = if x is
    C(a) then a
fun main(y) = c(p)
main(0)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |a|←|↵|#fun| |main|(|y|)| |#=| |c|(|p|)|↵|main|(|0|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then a›; fun main = y, => c (p,); main (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (main^11 0)
//│ def c = (fun x:9 -> case x:9 of {
//│ 	C a:10 => a:10})
//│ def main = (fun y:11 -> (c^7 p^8))
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [main^11] ---> [main^11] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (main 0)
//│ def c = (fun x:9 -> case x:9 of {
//│ 	C a:10 => a:10})
//│ def main = (fun y:11 -> (c p))
//│ def p = [C p]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 5: [C 4: p]
//│ [C p] --->
//│ 	case x:9 of {C a:10 => a:10}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (main 0)
//│ def c = (fun x:9 -> x:9)
//│ def main = (fun y:11 -> (c p))
//│ def p = let a:10 = p
//│ in a:10
//│ <<<<<<< after fusion <<<<<<<



// NOTE: push in problem
:ns
fun map(f, ls) = if ls is
    C(h, t) then C(f(h), map(f, t))
    N then N
let l = C(K, l)
fun ff(x) = if x is
    K then T
map(ff, l)
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |l|)|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|←|↵|map|(|ff|,| |l|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; let l = C (K, l,); fun ff = x, => if x is ‹(K) then T›; map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((map^22 ff^23) l^25)
//│ def ff = (fun x:13 -> case x:13 of {
//│ 	K => [T]})
//│ def l = [C [K] l^16]
//│ def map = (fun f:9 -> (fun ls:10 -> case ls:10 of {
//│ 	C h:11 t:12 => [C (f:9 h:11) ((map^5 f:9) t:12)]
//│ 	| N => [N]}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(K, 'l:7) <: 'ls:10
//│ 	[-l^16 · -l^16 · -l^25 · +map^22 · +map^5 · +map^5]  --->  [-l^16 · -l^25 · +map^22 · +map^5]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [map^22 · map^5 · map^5] --> [map^22 · map^5]
//│ [l^25 · l^16 · l^16] --> [l^25 · l^16]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^23] ---> [ff^23] (hopeless to continue)
//│ [l^25]
//│ 	[l^25 · l^16]
//│ 		[l^25 · l^16 · l^16] ---> [l^25 · l^16] (only one)
//│ [map^22]
//│ 	[map^22 · map^5]
//│ 		[map^22 · map^5 · map^5] ---> [map^22 · map^5] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((map^22 ff) l^25)
//│ def ff = (fun x:13 -> case x:13 of {
//│ 	K => [T]})
//│ def l = [C [K] l]
//│ def l^25 = [C [K] l^25_l^16]
//│ def l^25_l^16 = [C [K] l^25_l^16]
//│ def map = (fun f:9 -> (fun ls:10 -> case ls:10 of {
//│ 	C h:11 t:12 => [C (f:9 h:11) ((map f:9) t:12)]
//│ 	| N => [N]}))
//│ def map^22 = (fun f:18 -> (fun ls:19 -> case ls:19 of {
//│ 	C h:20 t:21 => [C (f:18 h:20) ((map^22_map^5 f:18) t:21)]
//│ 	| N => [N]}))
//│ def map^22_map^5 = (fun f:22 -> (fun ls:23 -> case ls:23 of {
//│ 	C h:24 t:25 => [C (f:22 h:24) ((map^22_map^5 f:22) t:25)]
//│ 	| N => [N]}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 27: [K]
//│ [K] --->
//│ 	case x:13 of {K => [T]}
//│ 29: [C 27: [K] 28: l^25_l^16]
//│ [C [K] l^25_l^16] --->
//│ 	case ls:23 of {C h:24 t:25 => [C (f:22 h:24) ((map^22_map^5 f:22) t:25)] | N => [N]}
//│ 44: [K]
//│ [K] --->
//│ 	case x:13 of {K => [T]}
//│ 46: [C 44: [K] 45: l^25_l^16]
//│ [C [K] l^25_l^16] --->
//│ 	case ls:19 of {C h:20 t:21 => [C (f:18 h:20) ((map^22_map^5 f:18) t:21)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((map^22 ff) l^25)
//│ def ff = (fun x:13 -> x:13)
//│ def l = [C [K] l]
//│ def l^25 = let h:20 = [T]
//│ in let t:21 = l^25_l^16
//│ in [C (f:18 h:20) ((map^22_map^5 f:18) t:21)]
//│ def l^25_l^16 = let h:24 = [T]
//│ in let t:25 = l^25_l^16
//│ in [C (f:22 h:24) ((map^22_map^5 f:22) t:25)]
//│ def map = (fun f:9 -> (fun ls:10 -> case ls:10 of {
//│ 	C h:11 t:12 => [C (f:9 h:11) ((map f:9) t:12)]
//│ 	| N => [N]}))
//│ def map^22 = (fun f:18 -> (fun ls:19 -> ls:19))
//│ def map^22_map^5 = (fun f:22 -> (fun ls:23 -> ls:23))
//│ <<<<<<< after fusion <<<<<<<

// NOTE: only first two is handled
:ns
_LUMBERHACK_ERROR
fun map(f, ls) = if ls is
    C(h, t) then C(f(h), map(f, t))
    N then N
fun ff(x) = if x is
    K then T
    KK then TT
    KKKK then TTTT
let l = C(K, C(KK, C(KKKK, N)))
map(ff, l)
//│ |_LUMBERHACK_ERROR|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|ff|,| |l|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; let l = C (K, C (KK, C (KKKK, N,),),); map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((map^28 ff^29) l^31)
//│ def ff = (fun x:13 -> case x:13 of {
//│ 	K => [T]
//│ 	| KK => [TT]
//│ 	| KKKK => [TTTT]})
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun f:9 -> (fun ls:10 -> case ls:10 of {
//│ 	C h:11 t:12 => [C (f:9 h:11) ((map^5 f:9) t:12)]
//│ 	| N => [N]}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 't:12
//│ 	[-l^31 · +map^28 · +map^5 · +map^5 · +map^5 · +map^5]  --->  [-l^31 · +map^28 · +map^5 · +map^5 · +map^5]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [map^28 · map^5 · map^5 · map^5 · map^5] --> [map^28 · map^5 · map^5 · map^5]
//│ [l^31] --> [l^31]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^29] ---> [ff^29] (hopeless to continue)
//│ [l^31]
//│ [map^28]
//│ 	[map^28 · map^5]
//│ 		[map^28 · map^5 · map^5]
//│ 			[map^28 · map^5 · map^5 · map^5]
//│ 				[map^28 · map^5 · map^5 · map^5 · map^5] ---> [map^28 · map^5 · map^5 · map^5] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((map^28 ff) l^31)
//│ def ff = (fun x:13 -> case x:13 of {
//│ 	K => [T]
//│ 	| KK => [TT]
//│ 	| KKKK => [TTTT]})
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def l^31 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun f:9 -> (fun ls:10 -> case ls:10 of {
//│ 	C h:11 t:12 => [C (f:9 h:11) ((map f:9) t:12)]
//│ 	| N => [N]}))
//│ def map^28 = (fun f:27 -> (fun ls:28 -> case ls:28 of {
//│ 	C h:29 t:30 => [C (f:27 h:29) ((map^28_map^5 f:27) t:30)]
//│ 	| N => [N]}))
//│ def map^28_map^5 = (fun f:31 -> (fun ls:32 -> case ls:32 of {
//│ 	C h:33 t:34 => [C (f:31 h:33) ((map^28_map^5_map^5 f:31) t:34)]
//│ 	| N => [N]}))
//│ def map^28_map^5_map^5 = (fun f:23 -> (fun ls:24 -> case ls:24 of {
//│ 	C h:25 t:26 => [C (f:23 h:25) ((map^28_map^5_map^5_map^5 f:23) t:26)]
//│ 	| N => [N]}))
//│ def map^28_map^5_map^5_map^5 = (fun f:19 -> (fun ls:20 -> case ls:20 of {
//│ 	C h:21 t:22 => [C (f:19 h:21) ((map^28_map^5_map^5_map^5 f:19) t:22)]
//│ 	| N => [N]}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 75: [K]
//│ [K] --->
//│ 	case x:13 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 76: [KK]
//│ [KK] --->
//│ 	case x:13 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 77: [KKKK]
//│ [KKKK] --->
//│ 	case x:13 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ 78: [N]
//│ [N] --->
//│ 	case ls:20 of {C h:21 t:22 => [C (f:19 h:21) ((map^28_map^5_map^5_map^5 f:19) t:22)] | N => [N]}
//│ 79: [C 77: [KKKK] 78: [N]]
//│ [C [KKKK] [N]] --->
//│ 	case ls:24 of {C h:25 t:26 => [C (f:23 h:25) ((map^28_map^5_map^5_map^5 f:23) t:26)] | N => [N]}
//│ 80: [C 76: [KK] 79: [C 77: [KKKK] 78: [N]]]
//│ [C [KK] [C [KKKK] [N]]] --->
//│ 	case ls:32 of {C h:33 t:34 => [C (f:31 h:33) ((map^28_map^5_map^5 f:31) t:34)] | N => [N]}
//│ 81: [C 75: [K] 80: [C 76: [KK] 79: [C 77: [KKKK] 78: [N]]]]
//│ [C [K] [C [KK] [C [KKKK] [N]]]] --->
//│ 	case ls:28 of {C h:29 t:30 => [C (f:27 h:29) ((map^28_map^5 f:27) t:30)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((map^28 ff) l^31)
//│ def ff = (fun x:13 -> x:13)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def l^31 = let h:29 = [T]
//│ in let t:30 = 
//│ 	let h:33 = [TT]
//│ 	in let t:34 = 
//│ 		let h:25 = [TTTT]
//│ 		in let t:26 = [N]
//│ 		in [C (f:23 h:25) ((map^28_map^5_map^5_map^5 f:23) t:26)]
//│ 	in [C (f:31 h:33) ((map^28_map^5_map^5 f:31) t:34)]
//│ in [C (f:27 h:29) ((map^28_map^5 f:27) t:30)]
//│ def map = (fun f:9 -> (fun ls:10 -> case ls:10 of {
//│ 	C h:11 t:12 => [C (f:9 h:11) ((map f:9) t:12)]
//│ 	| N => [N]}))
//│ def map^28 = (fun f:27 -> (fun ls:28 -> ls:28))
//│ def map^28_map^5 = (fun f:31 -> (fun ls:32 -> ls:32))
//│ def map^28_map^5_map^5 = (fun f:23 -> (fun ls:24 -> ls:24))
//│ def map^28_map^5_map^5_map^5 = (fun f:19 -> (fun ls:20 -> ls:20))
//│ <<<<<<< after fusion <<<<<<<

:ns
_LUMBERHACK_ERROR
fun rev(l1, l2) = if l1 is
    C(h, t) then rev(t, C(h, l2))
    N then l2
fun rev1(l11, l22) = if l11 is
    C(h1, t1) then rev1(t1, C(h1, l22))
    N then l22
let p = C(K, N)
rev(rev1(p, N), N)
//│ |_LUMBERHACK_ERROR|↵|#fun| |rev|(|l1|,| |l2|)| |#=| |#if| |l1| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |l2|)|)|↵|N| |#then| |l2|←|↵|#fun| |rev1|(|l11|,| |l22|)| |#=| |#if| |l11| |is|→|C|(|h1|,| |t1|)| |#then| |rev1|(|t1|,| |C|(|h1|,| |l22|)|)|↵|N| |#then| |l22|←|↵|#let| |p| |#=| |C|(|K|,| |N|)|↵|rev|(|rev1|(|p|,| |N|)|,| |N|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun rev = l1, l2, => if l1 is ‹(C (h, t,)) then rev (t, C (h, l2,),); (N) then l2›; fun rev1 = l11, l22, => if l11 is ‹(C (h1, t1,)) then rev1 (t1, C (h1, l22,),); (N) then l22›; let p = C (K, N,); rev (rev1 (p, N,), N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev^28 ((rev1^29 p^30) [N])) [N])
//│ def p = [C [K] [N]]
//│ def rev = (fun l1:9 -> (fun l2:10 -> case l1:9 of {
//│ 	C h:11 t:12 => ((rev^2 t:12) [C h:11 l2:10])
//│ 	| N => l2:10}))
//│ def rev1 = (fun l11:13 -> (fun l22:14 -> case l11:13 of {
//│ 	C h1:15 t1:16 => ((rev1^14 t1:16) [C h1:15 l22:14])
//│ 	| N => l22:14}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('h1:15, 'l22:14) <: 'l1:9
//│ 	[+rev1^14 · +rev1^14 · +rev1^14 · -rev1^29 · +rev^28 · +rev^2 · +rev^2]  --->  [+rev1^14 · +rev1^14 · -rev1^29 · +rev^28 · +rev^2]
//│ 	[+rev1^14 · +rev1^14 · +rev1^14 · -rev1^14 · -rev1^29 · +rev^28 · +rev^2 · +rev^2]  --->  [+rev1^14 · +rev1^14 · -rev1^14 · -rev1^29 · +rev^28 · +rev^2]
//│ NoProd <: 't1:16
//│ 	[-p^30 · +rev1^29 · +rev1^14 · +rev1^14]  --->  [-p^30 · +rev1^29 · +rev1^14]
//│ NoProd <: 'l1:9
//│ 	[+rev1^29 · -rev1^29 · +rev^28 · +rev^2 · +rev^2]  --->  [+rev1^29 · -rev1^29 · +rev^28 · +rev^2]
//│ 	[+rev1^29 · -rev1^14 · -rev1^29 · +rev^28 · +rev^2 · +rev^2]  --->  [+rev1^29 · -rev1^14 · -rev1^29 · +rev^28 · +rev^2]
//│ NoProd <: 't:12
//│ 	[+rev1^29 · +rev1^14 · -rev1^29 · +rev^28 · +rev^2 · +rev^2]  --->  [+rev1^29 · +rev1^14 · -rev1^29 · +rev^28 · +rev^2]
//│ 	[+rev1^29 · +rev1^14 · +rev1^14 · -rev1^29 · +rev^28 · +rev^2 · +rev^2 · +rev^2]  --->  [+rev1^29 · +rev1^14 · +rev1^14 · -rev1^29 · +rev^28 · +rev^2 · +rev^2]
//│ 	[+rev1^29 · +rev1^14 · -rev1^14 · -rev1^29 · +rev^28 · +rev^2 · +rev^2]  --->  [+rev1^29 · +rev1^14 · -rev1^14 · -rev1^29 · +rev^28 · +rev^2]
//│ 	[+rev1^29 · +rev1^14 · +rev1^14 · -rev1^14 · -rev1^29 · +rev^28 · +rev^2 · +rev^2 · +rev^2]  --->  [+rev1^29 · +rev1^14 · +rev1^14 · -rev1^14 · -rev1^29 · +rev^28 · +rev^2 · +rev^2]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [rev^28 · rev^2 · rev^2] --> [rev^28 · rev^2]
//│ [rev1^29 · rev1^14 · rev1^14] --> [rev1^29 · rev1^14]
//│ [p^30] --> [p^30]
//│ [rev1^29 · rev1^14] --> [rev1^29 · rev1^14]
//│ [rev1^29] --> [rev1^29]
//│ [] --> []
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [p^30]
//│ [rev1^29]
//│ 	[rev1^29 · rev1^14]
//│ 		[rev1^29 · rev1^14 · rev1^14] ---> [rev1^29 · rev1^14] (only one)
//│ [rev^28]
//│ 	[rev^28 · rev^2]
//│ 		[rev^28 · rev^2 · rev^2] ---> [rev^28 · rev^2] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev^28 ((rev1^29 p^30) [N])) [N])
//│ def p = [C [K] [N]]
//│ def p^30 = [C [K] [N]]
//│ def rev = (fun l1:9 -> (fun l2:10 -> case l1:9 of {
//│ 	C h:11 t:12 => ((rev t:12) [C h:11 l2:10])
//│ 	| N => l2:10}))
//│ def rev1 = (fun l11:13 -> (fun l22:14 -> case l11:13 of {
//│ 	C h1:15 t1:16 => ((rev1 t1:16) [C h1:15 l22:14])
//│ 	| N => l22:14}))
//│ def rev1^29 = (fun l11:30 -> (fun l22:31 -> case l11:30 of {
//│ 	C h1:32 t1:33 => ((rev1^29_rev1^14 t1:33) [C h1:32 l22:31])
//│ 	| N => l22:31}))
//│ def rev1^29_rev1^14 = (fun l11:34 -> (fun l22:35 -> case l11:34 of {
//│ 	C h1:36 t1:37 => ((rev1^29_rev1^14 t1:37) [C h1:36 l22:35])
//│ 	| N => l22:35}))
//│ def rev^28 = (fun l1:22 -> (fun l2:23 -> case l1:22 of {
//│ 	C h:24 t:25 => ((rev^28_rev^2 t:25) [C h:24 l2:23])
//│ 	| N => l2:23}))
//│ def rev^28_rev^2 = (fun l1:26 -> (fun l2:27 -> case l1:26 of {
//│ 	C h:28 t:29 => ((rev^28_rev^2 t:29) [C h:28 l2:27])
//│ 	| N => l2:27}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 38: [N]
//│ [N] --->
//│ 	case l11:34 of {C h1:36 t1:37 => ((rev1^29_rev1^14 t1:37) [C h1:36 l22:35]) | N => l22:35}
//│ 39: [C 37: [K] 38: [N]]
//│ [C [K] [N]] --->
//│ 	case l11:30 of {C h1:32 t1:33 => ((rev1^29_rev1^14 t1:33) [C h1:32 l22:31]) | N => l22:31}
//│ 70: [C 68: h1 69: l22]
//│ [C h1:32 l22:31] --->
//│ 	case l1:22 of {C h:24 t:25 => ((rev^28_rev^2 t:25) [C h:24 l2:23]) | N => l2:23}
//│ 	case l1:26 of {C h:28 t:29 => ((rev^28_rev^2 t:29) [C h:28 l2:27]) | N => l2:27}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 82: [C 80: h1 81: l22]
//│ [C h1:36 l22:35] --->
//│ 	case l1:22 of {C h:24 t:25 => ((rev^28_rev^2 t:25) [C h:24 l2:23]) | N => l2:23}
//│ 	case l1:26 of {C h:28 t:29 => ((rev^28_rev^2 t:29) [C h:28 l2:27]) | N => l2:27}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 92: [N]
//│ [N] --->
//│ 	case l1:22 of {C h:24 t:25 => ((rev^28_rev^2 t:25) [C h:24 l2:23]) | N => l2:23}
//│ 	case l1:26 of {C h:28 t:29 => ((rev^28_rev^2 t:29) [C h:28 l2:27]) | N => l2:27}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev^28 ((rev1^29 p^30) l2:23)) [N])
//│ def p = [C [K] [N]]
//│ def p^30 = let h1:32 = [K]
//│ in let t1:33 = l22:35
//│ in ((rev1^29_rev1^14 t1:33) let h:28 = h1:32
//│ in let t:29 = l22:31
//│ in ((rev^28_rev^2 t:29) [C h:28 l2:27]))
//│ def rev = (fun l1:9 -> (fun l2:10 -> case l1:9 of {
//│ 	C h:11 t:12 => ((rev t:12) [C h:11 l2:10])
//│ 	| N => l2:10}))
//│ def rev1 = (fun l11:13 -> (fun l22:14 -> case l11:13 of {
//│ 	C h1:15 t1:16 => ((rev1 t1:16) [C h1:15 l22:14])
//│ 	| N => l22:14}))
//│ def rev1^29 = (fun l11:30 -> (fun l22:31 -> l11:30))
//│ def rev1^29_rev1^14 = (fun l11:34 -> (fun l22:35 -> l11:34))
//│ def rev^28 = (fun l1:22 -> (fun l2:23 -> l1:22))
//│ def rev^28_rev^2 = (fun l1:26 -> (fun l2:27 -> l1:26))
//│ <<<<<<< after fusion <<<<<<<


// `id2` used twice
:ns
let p = C(C(C(id2(p))))
fun c(x) = if x is
    C(a) then if a is
        C(a) then c(a)
fun id2(yy) = yy
fun id(y) = id2(y)
c(id(p))
//│ |#let| |p| |#=| |C|(|C|(|C|(|id2|(|p|)|)|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|a|)| |#then| |c|(|a|)|←|←|↵|#fun| |id2|(|yy|)| |#=| |yy|↵|#fun| |id|(|y|)| |#=| |id2|(|y|)|↵|c|(|id|(|p|)|)|
//│ Parsed: {let p = C (C (C (id2 (p,),),),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (a,)) then c (a,)››; fun id2 = yy, => yy; fun id = y, => id2 (y,); c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^21 (id^22 p^23))
//│ def c = (fun x:10 -> case x:10 of {
//│ 	C a:11 => case a:11 of {
//│ 		C a:12 => (c^9 a:12)}})
//│ def id = (fun y:14 -> (id2^17 y:14))
//│ def id2 = (fun yy:13 -> yy:13)
//│ def p = [C [C [C (id2^1 p^2)]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(C(C('3_callres))) <: 'a:11
//│ 	[-p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9]
//│ 	[-p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9]
//│ 	[-p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]
//│ 	[-p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]
//│ 	[-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9]
//│ 	[-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9]
//│ 	[-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]
//│ 	[-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]
//│ 	[-p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9]
//│ 	[-p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9]
//│ 	[-p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]
//│ 	[-p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]
//│ 	[-p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9]
//│ 	[-p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9]
//│ 	[-p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]
//│ 	[-p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]
//│ 	[-p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9]
//│ 	[-p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9]
//│ C(C(C('3_callres))) <: 'a:12
//│ 	[-p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9]
//│ 	[-p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9]
//│ 	[-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9]
//│ 	[-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9]
//│ 	[-p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9]
//│ 	[-p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9]
//│ 	[-p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9]
//│ 	[-p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^23 · +id^22 · +id2^17 · -id2^1 · -p^2 · +id2^1 · -id2^1 · -p^2 · +id2^1 · -id2^17 · -id^22 · +c^21 · +c^9 · +c^9]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c^21 · c^9 · c^9 · c^9 · c^9] --> [c^21 · c^9]
//│ [p^23 · p^2 · p^2 · p^2] --> [p^23 · p^2]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^21]
//│ 	[c^21 · c^9]
//│ 		[c^21 · c^9 · c^9]
//│ 			[c^21 · c^9 · c^9 · c^9]
//│ 				[c^21 · c^9 · c^9 · c^9 · c^9] ---> [c^21 · c^9] (only one)
//│ [id^22] ---> [id^22] (hopeless to continue)
//│ [p^23]
//│ 	[p^23 · p^2]
//│ 		[p^23 · p^2 · p^2]
//│ 			[p^23 · p^2 · p^2 · p^2] ---> [p^23 · p^2] (only one)
//│ 			[p^23 · p^2 · p^2 · id2^1] ---> [id2^1] (hopeless to continue)
//│ 		[p^23 · p^2 · id2^1] ---> [id2^1] (hopeless to continue)
//│ 	[p^23 · id2^1] ---> [id2^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c^21 (id p^23))
//│ def c = (fun x:10 -> case x:10 of {
//│ 	C a:11 => case a:11 of {
//│ 		C a:12 => (c a:12)}})
//│ def c^21 = (fun x:22 -> case x:22 of {
//│ 	C a:23 => case a:23 of {
//│ 		C a:24 => (c^21_c^9 a:24)}})
//│ def c^21_c^9 = (fun x:28 -> case x:28 of {
//│ 	C a:29 => case a:29 of {
//│ 		C a:30 => (c^21_c^9_c^9 a:30)}})
//│ def c^21_c^9_c^9 = (fun x:31 -> case x:31 of {
//│ 	C a:32 => case a:32 of {
//│ 		C a:33 => (c^21_c^9_c^9_c^9 a:33)}})
//│ def c^21_c^9_c^9_c^9 = (fun x:25 -> case x:25 of {
//│ 	C a:26 => case a:26 of {
//│ 		C a:27 => (c^21_c^9 a:27)}})
//│ def id = (fun y:14 -> (id2 y:14))
//│ def id2 = (fun yy:13 -> yy:13)
//│ def p = [C [C [C (id2 p)]]]
//│ def p^23 = [C [C [C (id2 p^23_p^2)]]]
//│ def p^23_p^2 = [C [C [C (id2 p^23_p^2_p^2)]]]
//│ def p^23_p^2_p^2 = [C [C [C (id2 p^23_p^2)]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 10: [C 9: [C 8: (6: id2 7: p)]]
//│ [C [C (id2 p)]] --->
//│ 	case a:23 of {C a:24 => (c^21_c^9 a:24)}
//│ 	case a:26 of {C a:27 => (c^21_c^9 a:27)}
//│ 	case x:31 of {C a:32 => case a:32 of {C a:33 => (c^21_c^9_c^9_c^9 a:33)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 11: [C 10: [C 9: [C 8: (6: id2 7: p)]]]
//│ [C [C [C (id2 p)]]] --->
//│ 	case a:29 of {C a:30 => (c^21_c^9_c^9 a:30)}
//│ 	case x:22 of {C a:23 => case a:23 of {C a:24 => (c^21_c^9 a:24)}}
//│ 	case x:25 of {C a:26 => case a:26 of {C a:27 => (c^21_c^9 a:27)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 29: [C 28: (26: id2 27: p^23_p^2_p^2)]
//│ [C (id2 p^23_p^2_p^2)] --->
//│ 	case a:32 of {C a:33 => (c^21_c^9_c^9_c^9 a:33)}
//│ 	case x:28 of {C a:29 => case a:29 of {C a:30 => (c^21_c^9_c^9 a:30)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 30: [C 29: [C 28: (26: id2 27: p^23_p^2_p^2)]]
//│ [C [C (id2 p^23_p^2_p^2)]] --->
//│ 	case a:23 of {C a:24 => (c^21_c^9 a:24)}
//│ 	case a:26 of {C a:27 => (c^21_c^9 a:27)}
//│ 	case x:31 of {C a:32 => case a:32 of {C a:33 => (c^21_c^9_c^9_c^9 a:33)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 31: [C 30: [C 29: [C 28: (26: id2 27: p^23_p^2_p^2)]]]
//│ [C [C [C (id2 p^23_p^2_p^2)]]] --->
//│ 	case a:29 of {C a:30 => (c^21_c^9_c^9 a:30)}
//│ 	case x:22 of {C a:23 => case a:23 of {C a:24 => (c^21_c^9 a:24)}}
//│ 	case x:25 of {C a:26 => case a:26 of {C a:27 => (c^21_c^9 a:27)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 43: [C 42: (40: id2 41: p^23_p^2)]
//│ [C (id2 p^23_p^2)] --->
//│ 	case a:32 of {C a:33 => (c^21_c^9_c^9_c^9 a:33)}
//│ 	case x:28 of {C a:29 => case a:29 of {C a:30 => (c^21_c^9_c^9 a:30)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 44: [C 43: [C 42: (40: id2 41: p^23_p^2)]]
//│ [C [C (id2 p^23_p^2)]] --->
//│ 	case a:23 of {C a:24 => (c^21_c^9 a:24)}
//│ 	case a:26 of {C a:27 => (c^21_c^9 a:27)}
//│ 	case x:31 of {C a:32 => case a:32 of {C a:33 => (c^21_c^9_c^9_c^9 a:33)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 45: [C 44: [C 43: [C 42: (40: id2 41: p^23_p^2)]]]
//│ [C [C [C (id2 p^23_p^2)]]] --->
//│ 	case a:29 of {C a:30 => (c^21_c^9_c^9 a:30)}
//│ 	case x:22 of {C a:23 => case a:23 of {C a:24 => (c^21_c^9 a:24)}}
//│ 	case x:25 of {C a:26 => case a:26 of {C a:27 => (c^21_c^9 a:27)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 57: [C 56: (54: id2 55: p^23_p^2)]
//│ [C (id2 p^23_p^2)] --->
//│ 	case a:32 of {C a:33 => (c^21_c^9_c^9_c^9 a:33)}
//│ 	case x:28 of {C a:29 => case a:29 of {C a:30 => (c^21_c^9_c^9 a:30)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 58: [C 57: [C 56: (54: id2 55: p^23_p^2)]]
//│ [C [C (id2 p^23_p^2)]] --->
//│ 	case a:23 of {C a:24 => (c^21_c^9 a:24)}
//│ 	case a:26 of {C a:27 => (c^21_c^9 a:27)}
//│ 	case x:31 of {C a:32 => case a:32 of {C a:33 => (c^21_c^9_c^9_c^9 a:33)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 59: [C 58: [C 57: [C 56: (54: id2 55: p^23_p^2)]]]
//│ [C [C [C (id2 p^23_p^2)]]] --->
//│ 	case a:29 of {C a:30 => (c^21_c^9_c^9 a:30)}
//│ 	case x:22 of {C a:23 => case a:23 of {C a:24 => (c^21_c^9 a:24)}}
//│ 	case x:25 of {C a:26 => case a:26 of {C a:27 => (c^21_c^9 a:27)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 9: [C 8: (6: id2 7: p)]
//│ [C (id2 p)] --->
//│ 	case a:32 of {C a:33 => (c^21_c^9_c^9_c^9 a:33)}
//│ 	case x:28 of {C a:29 => case a:29 of {C a:30 => (c^21_c^9_c^9 a:30)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c^21 (id p^23))
//│ def c = (fun x:10 -> case x:10 of {
//│ 	C a:11 => case a:11 of {
//│ 		C a:12 => (c a:12)}})
//│ def c^21 = (fun x:22 -> x:22)
//│ def c^21_c^9 = (fun x:28 -> x:28)
//│ def c^21_c^9_c^9 = (fun x:31 -> x:31)
//│ def c^21_c^9_c^9_c^9 = (fun x:25 -> x:25)
//│ def id = (fun y:14 -> (id2 y:14))
//│ def id2 = (fun yy:13 -> yy:13)
//│ def p = let a:26 = 
//│ 	let a:27 = 
//│ 		let a:29 = (id2 p)
//│ 		in a:29
//│ 	in (c^21_c^9 a:27)
//│ in a:26
//│ def p^23 = let a:23 = 
//│ 	let a:24 = 
//│ 		let a:29 = (id2 p^23_p^2)
//│ 		in a:29
//│ 	in (c^21_c^9 a:24)
//│ in a:23
//│ def p^23_p^2 = let a:26 = 
//│ 	let a:27 = 
//│ 		let a:29 = (id2 p^23_p^2_p^2)
//│ 		in a:29
//│ 	in (c^21_c^9 a:27)
//│ in a:26
//│ def p^23_p^2_p^2 = let a:30 = 
//│ 	let a:32 = 
//│ 		let a:33 = (id2 p^23_p^2)
//│ 		in (c^21_c^9_c^9_c^9 a:33)
//│ 	in a:32
//│ in (c^21_c^9_c^9 a:30)
//│ <<<<<<< after fusion <<<<<<<


// no polymorphism
:ns
_LUMBERHACK_ERROR
fun id(x) = x
let rec p1 = C(p1)
fun c1(a) = if a is
    C(i) then c1(i)
id(c1)(id(p1))
//│ |_LUMBERHACK_ERROR|↵|#fun| |id|(|x|)| |#=| |x|↵|#let| |#rec| |p1| |#=| |C|(|p1|)|↵|#fun| |c1|(|a|)| |#=| |#if| |a| |is|→|C|(|i|)| |#then| |c1|(|i|)|←|↵|id|(|c1|)|(|id|(|p1|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun id = x, => x; let rec p1 = C (p1,); fun c1 = a, => if a is ‹(C (i,)) then c1 (i,)›; id (c1,) (id (p1,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((id^11 c1^12) (id^14 p1^15))
//│ def c1 = (fun a:10 -> case a:10 of {
//│ 	C i:11 => (c1^6 i:11)})
//│ def id = (fun x:9 -> x:9)
//│ def p1 = [C p1^3]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: type error C('p1:7) <: '16_callres => '17_callres
//│ !!!!!!ERROR!!!!!!

:ns
_LUMBERHACK_ERROR
fun map(ls) = if ls is
    C(hh, tt) then C(
        (if hh is
            A then B
            AA then BB
        ),
        map(tt)
    )
    N then N
fun rev(a, lss) = if lss is
    C(h, t) then rev(C(h, a), t)
    N then a
// map(rev(N, C(A, C(AA, N))))
map(rev(N, primitive))
//│ |_LUMBERHACK_ERROR|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|hh|,| |tt|)| |#then| |C|(|→|(|#if| |hh| |is|→|A| |#then| |B|↵|AA| |#then| |BB|←|↵|)|,|↵|map|(|tt|)|←|↵|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|a|,| |lss|)| |#=| |#if| |lss| |is|→|C|(|h|,| |t|)| |#then| |rev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|/* map(rev(N, C(A, C(AA, N))))*/|↵|map|(|rev|(|N|,| |primitive|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun map = ls, => if ls is ‹(C (hh, tt,)) then C ('(' if hh is ‹(A) then B; (AA) then BB›, ')', map (tt,),); (N) then N›; fun rev = a, lss, => if lss is ‹(C (h, t,)) then rev (C (h, a,), t,); (N) then a›; map (rev (N, primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^25 ((rev^26 [N]) primitive:3))
//│ def map = (fun ls:8 -> case ls:8 of {
//│ 	C hh:9 tt:10 => [C case hh:9 of {
//│ 		A => [B]
//│ 		| AA => [BB]} (map^6 tt:10)]
//│ 	| N => [N]})
//│ def rev = (fun a:11 -> (fun lss:12 -> case lss:12 of {
//│ 	C h:13 t:14 => ((rev^14 [C h:13 a:11]) t:14)
//│ 	| N => a:11}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('h:13, 'a:11) <: 'ls:8
//│ 	[+rev^14 · +rev^14 · +rev^14 · -rev^26 · +map^25 · +map^6 · +map^6]  --->  [+rev^14 · +rev^14 · -rev^26 · +map^25 · +map^6]
//│ 	[+rev^14 · +rev^14 · +rev^14 · -rev^14 · -rev^26 · +map^25 · +map^6 · +map^6]  --->  [+rev^14 · +rev^14 · -rev^14 · -rev^26 · +map^25 · +map^6]
//│ NoProd <: 'lss:12
//│ 	[+rev^26 · +rev^14 · +rev^14]  --->  [+rev^26 · +rev^14]
//│ NoProd <: 'ls:8
//│ 	[+rev^26 · -rev^26 · +map^25 · +map^6 · +map^6]  --->  [+rev^26 · -rev^26 · +map^25 · +map^6]
//│ 	[+rev^26 · -rev^14 · -rev^26 · +map^25 · +map^6 · +map^6]  --->  [+rev^26 · -rev^14 · -rev^26 · +map^25 · +map^6]
//│ NoProd <: 'tt:10
//│ 	[+rev^26 · +rev^14 · -rev^26 · +map^25 · +map^6 · +map^6]  --->  [+rev^26 · +rev^14 · -rev^26 · +map^25 · +map^6]
//│ 	[+rev^26 · +rev^14 · +rev^14 · -rev^26 · +map^25 · +map^6 · +map^6 · +map^6]  --->  [+rev^26 · +rev^14 · +rev^14 · -rev^26 · +map^25 · +map^6 · +map^6]
//│ 	[+rev^26 · +rev^14 · -rev^14 · -rev^26 · +map^25 · +map^6 · +map^6]  --->  [+rev^26 · +rev^14 · -rev^14 · -rev^26 · +map^25 · +map^6]
//│ 	[+rev^26 · +rev^14 · +rev^14 · -rev^14 · -rev^26 · +map^25 · +map^6 · +map^6 · +map^6]  --->  [+rev^26 · +rev^14 · +rev^14 · -rev^14 · -rev^26 · +map^25 · +map^6 · +map^6]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [map^25 · map^6 · map^6] --> [map^25 · map^6]
//│ [rev^26 · rev^14 · rev^14] --> [rev^26 · rev^14]
//│ [rev^26 · rev^14] --> [rev^26 · rev^14]
//│ [rev^26] --> [rev^26]
//│ [] --> []
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [map^25]
//│ 	[map^25 · map^6]
//│ 		[map^25 · map^6 · map^6] ---> [map^25 · map^6] (only one)
//│ [rev^26]
//│ 	[rev^26 · rev^14]
//│ 		[rev^26 · rev^14 · rev^14] ---> [rev^26 · rev^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map^25 ((rev^26 [N]) primitive:3))
//│ def map = (fun ls:8 -> case ls:8 of {
//│ 	C hh:9 tt:10 => [C case hh:9 of {
//│ 		A => [B]
//│ 		| AA => [BB]} (map tt:10)]
//│ 	| N => [N]})
//│ def map^25 = (fun ls:19 -> case ls:19 of {
//│ 	C hh:20 tt:21 => [C case hh:20 of {
//│ 		A => [B]
//│ 		| AA => [BB]} (map^25_map^6 tt:21)]
//│ 	| N => [N]})
//│ def map^25_map^6 = (fun ls:22 -> case ls:22 of {
//│ 	C hh:23 tt:24 => [C case hh:23 of {
//│ 		A => [B]
//│ 		| AA => [BB]} (map^25_map^6 tt:24)]
//│ 	| N => [N]})
//│ def rev = (fun a:11 -> (fun lss:12 -> case lss:12 of {
//│ 	C h:13 t:14 => ((rev [C h:13 a:11]) t:14)
//│ 	| N => a:11}))
//│ def rev^26 = (fun a:29 -> (fun lss:30 -> case lss:30 of {
//│ 	C h:31 t:32 => ((rev^26_rev^14 [C h:31 a:29]) t:32)
//│ 	| N => a:29}))
//│ def rev^26_rev^14 = (fun a:25 -> (fun lss:26 -> case lss:26 of {
//│ 	C h:27 t:28 => ((rev^26_rev^14 [C h:27 a:25]) t:28)
//│ 	| N => a:25}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 60: [C 58: h 59: a]
//│ [C h:27 a:25] --->
//│ 	case ls:19 of {C hh:20 tt:21 => [C case hh:20 of {A => [B] | AA => [BB]} (map^25_map^6 tt:21)] | N => [N]}
//│ 	case ls:22 of {C hh:23 tt:24 => [C case hh:23 of {A => [B] | AA => [BB]} (map^25_map^6 tt:24)] | N => [N]}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 72: [C 70: h 71: a]
//│ [C h:31 a:29] --->
//│ 	case ls:19 of {C hh:20 tt:21 => [C case hh:20 of {A => [B] | AA => [BB]} (map^25_map^6 tt:21)] | N => [N]}
//│ 	case ls:22 of {C hh:23 tt:24 => [C case hh:23 of {A => [B] | AA => [BB]} (map^25_map^6 tt:24)] | N => [N]}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 82: [N]
//│ [N] --->
//│ 	case ls:19 of {C hh:20 tt:21 => [C case hh:20 of {A => [B] | AA => [BB]} (map^25_map^6 tt:21)] | N => [N]}
//│ 	case ls:22 of {C hh:23 tt:24 => [C case hh:23 of {A => [B] | AA => [BB]} (map^25_map^6 tt:24)] | N => [N]}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map^25 ((rev^26 [N]) primitive:3))
//│ def map = (fun ls:8 -> case ls:8 of {
//│ 	C hh:9 tt:10 => [C case hh:9 of {
//│ 		A => [B]
//│ 		| AA => [BB]} (map tt:10)]
//│ 	| N => [N]})
//│ def map^25 = (fun ls:19 -> ls:19)
//│ def map^25_map^6 = (fun ls:22 -> case ls:22 of {
//│ 	C hh:23 tt:24 => [C case hh:23 of {
//│ 		A => [B]
//│ 		| AA => [BB]} (map^25_map^6 tt:24)]
//│ 	| N => [N]})
//│ def rev = (fun a:11 -> (fun lss:12 -> case lss:12 of {
//│ 	C h:13 t:14 => ((rev [C h:13 a:11]) t:14)
//│ 	| N => a:11}))
//│ def rev^26 = (fun a:29 -> (fun lss:30 -> case lss:30 of {
//│ 	C h:31 t:32 => ((rev^26_rev^14 let hh:20 = h:31
//│ 	in let tt:21 = a:29
//│ 	in [C case hh:20 of {
//│ 		A => [B]
//│ 		| AA => [BB]} (map^25_map^6 tt:21)]) t:32)
//│ 	| N => a:29}))
//│ def rev^26_rev^14 = (fun a:25 -> (fun lss:26 -> case lss:26 of {
//│ 	C h:27 t:28 => ((rev^26_rev^14 let hh:20 = h:27
//│ 	in let tt:21 = a:25
//│ 	in [C case hh:20 of {
//│ 		A => [B]
//│ 		| AA => [BB]} (map^25_map^6 tt:21)]) t:28)
//│ 	| N => a:25}))
//│ <<<<<<< after fusion <<<<<<<

:ns
_LUMBERHACK_ERROR
let p = Pair(A, B)
fun c(x) = if x is
    Pair(a, b) then c(Pair(b, a))
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^12 p^13)
//│ def c = (fun x:8 -> case x:8 of {
//│ 	Pair a:9 b:10 => (c^5 [Pair b:10 a:9])})
//│ def p = [Pair [A] [B]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^12] ---> [c^12] (hopeless to continue)
//│ [p^13] ---> [p^13] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c p)
//│ def c = (fun x:8 -> case x:8 of {
//│ 	Pair a:9 b:10 => (c [Pair b:10 a:9])})
//│ def p = [Pair [A] [B]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 11: [Pair 9: b 10: a]
//│ [Pair b:10 a:9] --->
//│ 	case x:8 of {Pair a:9 b:10 => (c [Pair b:10 a:9])}
//│ 6: [Pair 4: [A] 5: [B]]
//│ [Pair [A] [B]] --->
//│ 	case x:8 of {Pair a:9 b:10 => (c [Pair b:10 a:9])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!


// pushing in of auxiliary parameters
// FIXME: weird recursive
:ns
fun last(x, ys) = if ys is
    N then x
    C(h, t) then last(h, t)
fun lastDrive(xs) = if xs is
    N then None
    C(hh, tt) then Some(last(hh, tt))
lastDrive(C(1, C(2, N)))
//│ |#fun| |last|(|x|,| |ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x|↵|C|(|h|,| |t|)| |#then| |last|(|h|,| |t|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|hh|,| |tt|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun last = x, ys, => if ys is ‹(N) then x; (C (h, t,)) then last (h, t,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (hh, tt,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (lastDrive^21 [C 1 [C 2 [N]]])
//│ def last = (fun x:8 -> (fun ys:9 -> case ys:9 of {
//│ 	N => x:8
//│ 	| C h:10 t:11 => ((last^3 h:10) t:11)}))
//│ def lastDrive = (fun xs:12 -> case xs:12 of {
//│ 	N => [None]
//│ 	| C hh:13 tt:14 => [Some ((last^13 hh:13) tt:14)]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 't:11
//│ 	[+lastDrive^21 · +last^13 · +last^3 · +last^3]  --->  [+lastDrive^21 · +last^13 · +last^3]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [lastDrive^21 · last^13 · last^3 · last^3] --> [lastDrive^21 · last^13 · last^3]
//│ [] --> []
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive^21]
//│ 	[lastDrive^21 · last^13]
//│ 		[lastDrive^21 · last^13 · last^3]
//│ 			[lastDrive^21 · last^13 · last^3 · last^3] ---> [lastDrive^21 · last^13 · last^3] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (lastDrive^21 [C 1 [C 2 [N]]])
//│ def last = (fun x:8 -> (fun ys:9 -> case ys:9 of {
//│ 	N => x:8
//│ 	| C h:10 t:11 => ((last h:10) t:11)}))
//│ def lastDrive = (fun xs:12 -> case xs:12 of {
//│ 	N => [None]
//│ 	| C hh:13 tt:14 => [Some ((last hh:13) tt:14)]})
//│ def lastDrive^21 = (fun xs:22 -> case xs:22 of {
//│ 	N => [None]
//│ 	| C hh:23 tt:24 => [Some ((lastDrive^21_last^13 hh:23) tt:24)]})
//│ def lastDrive^21_last^13 = (fun x:25 -> (fun ys:26 -> case ys:26 of {
//│ 	N => x:25
//│ 	| C h:27 t:28 => ((lastDrive^21_last^13_last^3 h:27) t:28)}))
//│ def lastDrive^21_last^13_last^3 = (fun x:18 -> (fun ys:19 -> case ys:19 of {
//│ 	N => x:18
//│ 	| C h:20 t:21 => ((lastDrive^21_last^13_last^3 h:20) t:21)}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 61: [N]
//│ [N] --->
//│ 	case ys:19 of {N => x:18 | C h:20 t:21 => ((lastDrive^21_last^13_last^3 h:20) t:21)}
//│ 62: [C 60: 2 61: [N]]
//│ [C 2 [N]] --->
//│ 	case ys:26 of {N => x:25 | C h:27 t:28 => ((lastDrive^21_last^13_last^3 h:27) t:28)}
//│ 63: [C 59: 1 62: [C 60: 2 61: [N]]]
//│ [C 1 [C 2 [N]]] --->
//│ 	case xs:22 of {N => [None] | C hh:23 tt:24 => [Some ((lastDrive^21_last^13 hh:23) tt:24)]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (lastDrive^21 let hh:23 = 1
//│ in let tt:24 = 
//│ 	let h:27 = 2
//│ 	in let t:28 = x:18
//│ 	in ((lastDrive^21_last^13_last^3 h:27) t:28)
//│ in [Some ((lastDrive^21_last^13 hh:23) tt:24)])
//│ def last = (fun x:8 -> (fun ys:9 -> case ys:9 of {
//│ 	N => x:8
//│ 	| C h:10 t:11 => ((last h:10) t:11)}))
//│ def lastDrive = (fun xs:12 -> case xs:12 of {
//│ 	N => [None]
//│ 	| C hh:13 tt:14 => [Some ((last hh:13) tt:14)]})
//│ def lastDrive^21 = (fun xs:22 -> xs:22)
//│ def lastDrive^21_last^13 = (fun x:25 -> (fun ys:26 -> ys:26))
//│ def lastDrive^21_last^13_last^3 = (fun x:18 -> (fun ys:19 -> ys:19))
//│ <<<<<<< after fusion <<<<<<<

:ns
fun inter(xs, ys) = if xs is
    N then ys
    C(h, t) then C(h, inter(ys, t))
inter(C(1, C(2, C(3, N))), C(9, C(8, C(7, N))))
//│ |#fun| |inter|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |inter|(|ys|,| |t|)|)|←|↵|inter|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|,| |C|(|9|,| |C|(|8|,| |C|(|7|,| |N|)|)|)|)|
//│ Parsed: {fun inter = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, inter (ys, t,),)›; inter (C (1, C (2, C (3, N,),),), C (9, C (8, C (7, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter^13 [C 1 [C 2 [C 3 [N]]]]) [C 9 [C 8 [C 7 [N]]]])
//│ def inter = (fun xs:7 -> (fun ys:8 -> case xs:7 of {
//│ 	N => ys:8
//│ 	| C h:9 t:10 => [C h:9 ((inter^4 ys:8) t:10)]}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 't:10
//│ 	[+inter^13 · +inter^4 · +inter^4 · +inter^4 · +inter^4 · +inter^4 · +inter^4 · +inter^4 · +inter^4 · +inter^4]  --->  [+inter^13 · +inter^4 · +inter^4 · +inter^4 · +inter^4 · +inter^4 · +inter^4 · +inter^4]
//│ 	[+inter^13 · +inter^4 · +inter^4 · +inter^4 · +inter^4 · +inter^4 · +inter^4 · +inter^4 · +inter^4]  --->  [+inter^13 · +inter^4 · +inter^4 · +inter^4 · +inter^4 · +inter^4 · +inter^4]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [inter^13 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4] --> [inter^13 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4]
//│ [inter^13 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4] --> [inter^13 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4]
//│ [] --> []
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^13]
//│ 	[inter^13 · inter^4]
//│ 		[inter^13 · inter^4 · inter^4]
//│ 			[inter^13 · inter^4 · inter^4 · inter^4]
//│ 				[inter^13 · inter^4 · inter^4 · inter^4 · inter^4]
//│ 					[inter^13 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4]
//│ 						[inter^13 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4]
//│ 							[inter^13 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4]
//│ 								[inter^13 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4] ---> [inter^13 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4 · inter^4] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((inter^13 [C 1 [C 2 [C 3 [N]]]]) [C 9 [C 8 [C 7 [N]]]])
//│ def inter = (fun xs:7 -> (fun ys:8 -> case xs:7 of {
//│ 	N => ys:8
//│ 	| C h:9 t:10 => [C h:9 ((inter ys:8) t:10)]}))
//│ def inter^13 = (fun xs:19 -> (fun ys:20 -> case xs:19 of {
//│ 	N => ys:20
//│ 	| C h:21 t:22 => [C h:21 ((inter^13_inter^4 ys:20) t:22)]}))
//│ def inter^13_inter^4 = (fun xs:27 -> (fun ys:28 -> case xs:27 of {
//│ 	N => ys:28
//│ 	| C h:29 t:30 => [C h:29 ((inter^13_inter^4_inter^4 ys:28) t:30)]}))
//│ def inter^13_inter^4_inter^4 = (fun xs:35 -> (fun ys:36 -> case xs:35 of {
//│ 	N => ys:36
//│ 	| C h:37 t:38 => [C h:37 ((inter^13_inter^4_inter^4_inter^4 ys:36) t:38)]}))
//│ def inter^13_inter^4_inter^4_inter^4 = (fun xs:39 -> (fun ys:40 -> case xs:39 of {
//│ 	N => ys:40
//│ 	| C h:41 t:42 => [C h:41 ((inter^13_inter^4_inter^4_inter^4_inter^4 ys:40) t:42)]}))
//│ def inter^13_inter^4_inter^4_inter^4_inter^4 = (fun xs:43 -> (fun ys:44 -> case xs:43 of {
//│ 	N => ys:44
//│ 	| C h:45 t:46 => [C h:45 ((inter^13_inter^4_inter^4_inter^4_inter^4_inter^4 ys:44) t:46)]}))
//│ def inter^13_inter^4_inter^4_inter^4_inter^4_inter^4 = (fun xs:23 -> (fun ys:24 -> case xs:23 of {
//│ 	N => ys:24
//│ 	| C h:25 t:26 => [C h:25 ((inter^13_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4 ys:24) t:26)]}))
//│ def inter^13_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4 = (fun xs:47 -> (fun ys:48 -> case xs:47 of {
//│ 	N => ys:48
//│ 	| C h:49 t:50 => [C h:49 ((inter^13_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4 ys:48) t:50)]}))
//│ def inter^13_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4 = (fun xs:31 -> (fun ys:32 -> case xs:31 of {
//│ 	N => ys:32
//│ 	| C h:33 t:34 => [C h:33 ((inter^13_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4 ys:32) t:34)]}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 130: [N]
//│ [N] --->
//│ 	case xs:47 of {N => ys:48 | C h:49 t:50 => [C h:49 ((inter^13_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4 ys:48) t:50)]}
//│ 131: [C 129: 3 130: [N]]
//│ [C 3 [N]] --->
//│ 	case xs:43 of {N => ys:44 | C h:45 t:46 => [C h:45 ((inter^13_inter^4_inter^4_inter^4_inter^4_inter^4 ys:44) t:46)]}
//│ 132: [C 128: 2 131: [C 129: 3 130: [N]]]
//│ [C 2 [C 3 [N]]] --->
//│ 	case xs:35 of {N => ys:36 | C h:37 t:38 => [C h:37 ((inter^13_inter^4_inter^4_inter^4 ys:36) t:38)]}
//│ 133: [C 127: 1 132: [C 128: 2 131: [C 129: 3 130: [N]]]]
//│ [C 1 [C 2 [C 3 [N]]]] --->
//│ 	case xs:19 of {N => ys:20 | C h:21 t:22 => [C h:21 ((inter^13_inter^4 ys:20) t:22)]}
//│ 138: [N]
//│ [N] --->
//│ 	case xs:31 of {N => ys:32 | C h:33 t:34 => [C h:33 ((inter^13_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4 ys:32) t:34)]}
//│ 139: [C 137: 7 138: [N]]
//│ [C 7 [N]] --->
//│ 	case xs:23 of {N => ys:24 | C h:25 t:26 => [C h:25 ((inter^13_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4 ys:24) t:26)]}
//│ 140: [C 136: 8 139: [C 137: 7 138: [N]]]
//│ [C 8 [C 7 [N]]] --->
//│ 	case xs:39 of {N => ys:40 | C h:41 t:42 => [C h:41 ((inter^13_inter^4_inter^4_inter^4_inter^4 ys:40) t:42)]}
//│ 141: [C 135: 9 140: [C 136: 8 139: [C 137: 7 138: [N]]]]
//│ [C 9 [C 8 [C 7 [N]]]] --->
//│ 	case xs:27 of {N => ys:28 | C h:29 t:30 => [C h:29 ((inter^13_inter^4_inter^4 ys:28) t:30)]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((inter^13 let h:21 = 1
//│ in let t:22 = 
//│ 	let h:37 = 2
//│ 	in let t:38 = 
//│ 		let h:45 = 3
//│ 		in let t:46 = ys:48
//│ 		in [C h:45 ((inter^13_inter^4_inter^4_inter^4_inter^4_inter^4 ys:44) t:46)]
//│ 	in [C h:37 ((inter^13_inter^4_inter^4_inter^4 ys:36) t:38)]
//│ in [C h:21 ((inter^13_inter^4 ys:20) t:22)]) let h:29 = 9
//│ in let t:30 = 
//│ 	let h:41 = 8
//│ 	in let t:42 = 
//│ 		let h:25 = 7
//│ 		in let t:26 = ys:32
//│ 		in [C h:25 ((inter^13_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4 ys:24) t:26)]
//│ 	in [C h:41 ((inter^13_inter^4_inter^4_inter^4_inter^4 ys:40) t:42)]
//│ in [C h:29 ((inter^13_inter^4_inter^4 ys:28) t:30)])
//│ def inter = (fun xs:7 -> (fun ys:8 -> case xs:7 of {
//│ 	N => ys:8
//│ 	| C h:9 t:10 => [C h:9 ((inter ys:8) t:10)]}))
//│ def inter^13 = (fun xs:19 -> (fun ys:20 -> xs:19))
//│ def inter^13_inter^4 = (fun xs:27 -> (fun ys:28 -> xs:27))
//│ def inter^13_inter^4_inter^4 = (fun xs:35 -> (fun ys:36 -> xs:35))
//│ def inter^13_inter^4_inter^4_inter^4 = (fun xs:39 -> (fun ys:40 -> xs:39))
//│ def inter^13_inter^4_inter^4_inter^4_inter^4 = (fun xs:43 -> (fun ys:44 -> xs:43))
//│ def inter^13_inter^4_inter^4_inter^4_inter^4_inter^4 = (fun xs:23 -> (fun ys:24 -> xs:23))
//│ def inter^13_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4 = (fun xs:47 -> (fun ys:48 -> xs:47))
//│ def inter^13_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4_inter^4 = (fun xs:31 -> (fun ys:32 -> xs:31))
//│ <<<<<<< after fusion <<<<<<<

:ns
_LUMBERHACK_ERROR
let add = primitive
fun idxSum(ls) = if ls is
    N then acc => 0
    C(h, t) then acc => add(acc, idxSum(t)(add(acc, 1)))
fun rev(lss, a) = if lss is
    N then a
    C(hh, tt) then rev(tt, C(hh, a))
idxSum(rev(primitive, N))(0)
//│ |_LUMBERHACK_ERROR|↵|#let| |add| |#=| |primitive|↵|#fun| |idxSum|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc| |=>| |0|↵|C|(|h|,| |t|)| |#then| |acc| |=>| |add|(|acc|,| |idxSum|(|t|)|(|add|(|acc|,| |1|)|)|)|←|↵|#fun| |rev|(|lss|,| |a|)| |#=| |#if| |lss| |is|→|N| |#then| |a|↵|C|(|hh|,| |tt|)| |#then| |rev|(|tt|,| |C|(|hh|,| |a|)|)|←|↵|idxSum|(|rev|(|primitive|,| |N|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_ERROR; let add = primitive; fun idxSum = ls, => if ls is ‹(N) then acc, => 0; (C (h, t,)) then acc, => add (acc, idxSum (t,) (add (acc, 1,),),)›; fun rev = lss, a, => if lss is ‹(N) then a; (C (hh, tt,)) then rev (tt, C (hh, a,),)›; idxSum (rev (primitive, N,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((idxSum^33 ((rev^34 primitive:3) [N])) 0)
//│ def add = primitive:3
//│ def idxSum = (fun ls:9 -> case ls:9 of {
//│ 	N => (fun acc:10 -> 0)
//│ 	| C h:11 t:12 => (fun acc:13 -> ((add:4 acc:13) ((idxSum^8 t:12) ((add:4 acc:13) 1))))})
//│ def rev = (fun lss:14 -> (fun a:15 -> case lss:14 of {
//│ 	N => a:15
//│ 	| C hh:16 tt:17 => ((rev^23 tt:17) [C hh:16 a:15])}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('hh:16, 'a:15) <: 'ls:9
//│ 	[+rev^23 · +rev^23 · +rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]  --->  [+rev^23 · +rev^23 · -rev^34 · +idxSum^33 · +idxSum^8]
//│ 	[+rev^23 · +rev^23 · +rev^23 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]  --->  [+rev^23 · +rev^23 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8]
//│ NoProd <: 'lss:14
//│ 	[+rev^34 · +rev^23 · +rev^23]  --->  [+rev^34 · +rev^23]
//│ NoProd <: 'ls:9
//│ 	[+rev^34 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]  --->  [+rev^34 · -rev^34 · +idxSum^33 · +idxSum^8]
//│ 	[+rev^34 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]  --->  [+rev^34 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8]
//│ NoProd <: 't:12
//│ 	[+rev^34 · +rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]  --->  [+rev^34 · +rev^23 · -rev^34 · +idxSum^33 · +idxSum^8]
//│ 	[+rev^34 · +rev^23 · +rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8 · +idxSum^8]  --->  [+rev^34 · +rev^23 · +rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]
//│ 	[+rev^34 · +rev^23 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]  --->  [+rev^34 · +rev^23 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8]
//│ 	[+rev^34 · +rev^23 · +rev^23 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8 · +idxSum^8]  --->  [+rev^34 · +rev^23 · +rev^23 · -rev^23 · -rev^34 · +idxSum^33 · +idxSum^8 · +idxSum^8]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [idxSum^33 · idxSum^8 · idxSum^8] --> [idxSum^33 · idxSum^8]
//│ [rev^34 · rev^23 · rev^23] --> [rev^34 · rev^23]
//│ [rev^34 · rev^23] --> [rev^34 · rev^23]
//│ [rev^34] --> [rev^34]
//│ [] --> []
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [idxSum^33]
//│ 	[idxSum^33 · idxSum^8]
//│ 		[idxSum^33 · idxSum^8 · idxSum^8] ---> [idxSum^33 · idxSum^8] (only one)
//│ [rev^34]
//│ 	[rev^34 · rev^23]
//│ 		[rev^34 · rev^23 · rev^23] ---> [rev^34 · rev^23] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((idxSum^33 ((rev^34 primitive:3) [N])) 0)
//│ def add = primitive:3
//│ def idxSum = (fun ls:9 -> case ls:9 of {
//│ 	N => (fun acc:10 -> 0)
//│ 	| C h:11 t:12 => (fun acc:13 -> ((add:4 acc:13) ((idxSum t:12) ((add:4 acc:13) 1))))})
//│ def idxSum^33 = (fun ls:31 -> case ls:31 of {
//│ 	N => (fun acc:32 -> 0)
//│ 	| C h:33 t:34 => (fun acc:35 -> ((add:4 acc:35) ((idxSum^33_idxSum^8 t:34) ((add:4 acc:35) 1))))})
//│ def idxSum^33_idxSum^8 = (fun ls:26 -> case ls:26 of {
//│ 	N => (fun acc:27 -> 0)
//│ 	| C h:28 t:29 => (fun acc:30 -> ((add:4 acc:30) ((idxSum^33_idxSum^8 t:29) ((add:4 acc:30) 1))))})
//│ def rev = (fun lss:14 -> (fun a:15 -> case lss:14 of {
//│ 	N => a:15
//│ 	| C hh:16 tt:17 => ((rev tt:17) [C hh:16 a:15])}))
//│ def rev^34 = (fun lss:36 -> (fun a:37 -> case lss:36 of {
//│ 	N => a:37
//│ 	| C hh:38 tt:39 => ((rev^34_rev^23 tt:39) [C hh:38 a:37])}))
//│ def rev^34_rev^23 = (fun lss:22 -> (fun a:23 -> case lss:22 of {
//│ 	N => a:23
//│ 	| C hh:24 tt:25 => ((rev^34_rev^23 tt:25) [C hh:24 a:23])}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 108: [N]
//│ [N] --->
//│ 	case ls:26 of {N => (fun acc:27 -> 0) | C h:28 t:29 => (fun acc:30 -> ((add:4 acc:30) ((idxSum^33_idxSum^8 t:29) ((add:4 acc:30) 1))))}
//│ 	case ls:31 of {N => (fun acc:32 -> 0) | C h:33 t:34 => (fun acc:35 -> ((add:4 acc:35) ((idxSum^33_idxSum^8 t:34) ((add:4 acc:35) 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 49: [C 47: hh 48: a]
//│ [C hh:24 a:23] --->
//│ 	case ls:26 of {N => (fun acc:27 -> 0) | C h:28 t:29 => (fun acc:30 -> ((add:4 acc:30) ((idxSum^33_idxSum^8 t:29) ((add:4 acc:30) 1))))}
//│ 	case ls:31 of {N => (fun acc:32 -> 0) | C h:33 t:34 => (fun acc:35 -> ((add:4 acc:35) ((idxSum^33_idxSum^8 t:34) ((add:4 acc:35) 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 99: [C 97: hh 98: a]
//│ [C hh:38 a:37] --->
//│ 	case ls:26 of {N => (fun acc:27 -> 0) | C h:28 t:29 => (fun acc:30 -> ((add:4 acc:30) ((idxSum^33_idxSum^8 t:29) ((add:4 acc:30) 1))))}
//│ 	case ls:31 of {N => (fun acc:32 -> 0) | C h:33 t:34 => (fun acc:35 -> ((add:4 acc:35) ((idxSum^33_idxSum^8 t:34) ((add:4 acc:35) 1))))}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((idxSum^33 ((rev^34 primitive:3) (fun acc:32 -> 0))) 0)
//│ def add = primitive:3
//│ def idxSum = (fun ls:9 -> case ls:9 of {
//│ 	N => (fun acc:10 -> 0)
//│ 	| C h:11 t:12 => (fun acc:13 -> ((add:4 acc:13) ((idxSum t:12) ((add:4 acc:13) 1))))})
//│ def idxSum^33 = (fun ls:31 -> ls:31)
//│ def idxSum^33_idxSum^8 = (fun ls:26 -> case ls:26 of {
//│ 	N => (fun acc:27 -> 0)
//│ 	| C h:28 t:29 => (fun acc:30 -> ((add:4 acc:30) ((idxSum^33_idxSum^8 t:29) ((add:4 acc:30) 1))))})
//│ def rev = (fun lss:14 -> (fun a:15 -> case lss:14 of {
//│ 	N => a:15
//│ 	| C hh:16 tt:17 => ((rev tt:17) [C hh:16 a:15])}))
//│ def rev^34 = (fun lss:36 -> (fun a:37 -> case lss:36 of {
//│ 	N => a:37
//│ 	| C hh:38 tt:39 => ((rev^34_rev^23 tt:39) let h:33 = hh:38
//│ 	in let t:34 = a:37
//│ 	in (fun acc:35 -> ((add:4 acc:35) ((idxSum^33_idxSum^8 t:34) ((add:4 acc:35) 1)))))}))
//│ def rev^34_rev^23 = (fun lss:22 -> (fun a:23 -> case lss:22 of {
//│ 	N => a:23
//│ 	| C hh:24 tt:25 => ((rev^34_rev^23 tt:25) let h:33 = hh:24
//│ 	in let t:34 = a:23
//│ 	in (fun acc:35 -> ((add:4 acc:35) ((idxSum^33_idxSum^8 t:34) ((add:4 acc:35) 1)))))}))
//│ <<<<<<< after fusion <<<<<<<


// scope extrusion
:ns
fun inter(xs) = if xs is
    N then ys => ys
    C(h0, t0) then ys => if ys is
        N then N2
        C(h1, t1) then C2(add(h0,h1), inter(t0, t1))
let l1 = C(1, C(2, C(1, C(2, N))))
// let rec l2 = N
let rec l2 = C(11, N)
inter(l1, l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h0|,| |t0|)| |#then| |ys| |=>| |#if| |ys| |is|→|N| |#then| |N2|↵|C|(|h1|,| |t1|)| |#then| |C2|(|add|(|h0|,|h1|)|,| |inter|(|t0|,| |t1|)|)|←|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |C|(|1|,| |C|(|2|,| |N|)|)|)|)|↵|/* let rec l2 = N*/|↵|#let| |#rec| |l2| |#=| |C|(|11|,| |N|)|↵|inter|(|l1|,| |l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h0, t0,)) then ys, => if ys is ‹(N) then N2; (C (h1, t1,)) then C2 (add (h0, h1,), inter (t0, t1,),)››; let l1 = C (1, C (2, C (1, C (2, N,),),),); let rec l2 = C (11, N,); inter (l1, l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter^33 l1^34) l2^36)
//│ def inter = (fun xs:9 -> case xs:9 of {
//│ 	N => (fun ys:10 -> ys:10)
//│ 	| C h0:11 t0:12 => (fun ys:13 -> case ys:13 of {
//│ 		N => [N2]
//│ 		| C h1:14 t1:15 => [C2 ((add:4 h0:11) h1:14) ((inter^11 t0:12) t1:15)]})})
//│ def l1 = [C 1 [C 2 [C 1 [C 2 [N]]]]]
//│ def l2 = [C 11 [N]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 't0:12
//│ 	[-l1^34 · +inter^33 · +inter^11 · +inter^11 · +inter^11 · +inter^11 · +inter^11]  --->  [-l1^34 · +inter^33 · +inter^11 · +inter^11 · +inter^11 · +inter^11]
//│ NoProd <: 't1:15
//│ 	[-l2^36 · +inter^33 · +inter^11 · +inter^11]  --->  [-l2^36 · +inter^33 · +inter^11]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [inter^33 · inter^11 · inter^11 · inter^11 · inter^11 · inter^11] --> [inter^33 · inter^11 · inter^11 · inter^11 · inter^11]
//│ [inter^33 · inter^11 · inter^11] --> [inter^33 · inter^11]
//│ [l1^34] --> [l1^34]
//│ [l2^36] --> [l2^36]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^33]
//│ 	[inter^33 · inter^11]
//│ 		[inter^33 · inter^11 · inter^11] ---> [inter^33 · inter^11] (only one)
//│ [l1^34]
//│ [l2^36]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((inter^33 l1^34) l2^36)
//│ def inter = (fun xs:9 -> case xs:9 of {
//│ 	N => (fun ys:10 -> ys:10)
//│ 	| C h0:11 t0:12 => (fun ys:13 -> case ys:13 of {
//│ 		N => [N2]
//│ 		| C h1:14 t1:15 => [C2 ((add:4 h0:11) h1:14) ((inter t0:12) t1:15)]})})
//│ def inter^33 = (fun xs:20 -> case xs:20 of {
//│ 	N => (fun ys:21 -> ys:21)
//│ 	| C h0:22 t0:23 => (fun ys:24 -> case ys:24 of {
//│ 		N => [N2]
//│ 		| C h1:25 t1:26 => [C2 ((add:4 h0:22) h1:25) ((inter^33_inter^11 t0:23) t1:26)]})})
//│ def inter^33_inter^11 = (fun xs:27 -> case xs:27 of {
//│ 	N => (fun ys:28 -> ys:28)
//│ 	| C h0:29 t0:30 => (fun ys:31 -> case ys:31 of {
//│ 		N => [N2]
//│ 		| C h1:32 t1:33 => [C2 ((add:4 h0:29) h1:32) ((inter^33_inter^11 t0:30) t1:33)]})})
//│ def l1 = [C 1 [C 2 [C 1 [C 2 [N]]]]]
//│ def l1^34 = [C 1 [C 2 [C 1 [C 2 [N]]]]]
//│ def l2 = [C 11 [N]]
//│ def l2^36 = [C 11 [N]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 82: [N]
//│ [N] --->
//│ 	case xs:27 of {N => (fun ys:28 -> ys:28) | C h0:29 t0:30 => (fun ys:31 -> case ys:31 of {N => [N2] | C h1:32 t1:33 => [C2 ((add:4 h0:29) h1:32) ((inter^33_inter^11 t0:30) t1:33)]})}
//│ 83: [C 81: 2 82: [N]]
//│ [C 2 [N]] --->
//│ 	case xs:27 of {N => (fun ys:28 -> ys:28) | C h0:29 t0:30 => (fun ys:31 -> case ys:31 of {N => [N2] | C h1:32 t1:33 => [C2 ((add:4 h0:29) h1:32) ((inter^33_inter^11 t0:30) t1:33)]})}
//│ 84: [C 80: 1 83: [C 81: 2 82: [N]]]
//│ [C 1 [C 2 [N]]] --->
//│ 	case xs:27 of {N => (fun ys:28 -> ys:28) | C h0:29 t0:30 => (fun ys:31 -> case ys:31 of {N => [N2] | C h1:32 t1:33 => [C2 ((add:4 h0:29) h1:32) ((inter^33_inter^11 t0:30) t1:33)]})}
//│ 85: [C 79: 2 84: [C 80: 1 83: [C 81: 2 82: [N]]]]
//│ [C 2 [C 1 [C 2 [N]]]] --->
//│ 	case xs:27 of {N => (fun ys:28 -> ys:28) | C h0:29 t0:30 => (fun ys:31 -> case ys:31 of {N => [N2] | C h1:32 t1:33 => [C2 ((add:4 h0:29) h1:32) ((inter^33_inter^11 t0:30) t1:33)]})}
//│ 86: [C 78: 1 85: [C 79: 2 84: [C 80: 1 83: [C 81: 2 82: [N]]]]]
//│ [C 1 [C 2 [C 1 [C 2 [N]]]]] --->
//│ 	case xs:20 of {N => (fun ys:21 -> ys:21) | C h0:22 t0:23 => (fun ys:24 -> case ys:24 of {N => [N2] | C h1:25 t1:26 => [C2 ((add:4 h0:22) h1:25) ((inter^33_inter^11 t0:23) t1:26)]})}
//│ 88: [N]
//│ [N] --->
//│ 	case ys:31 of {N => [N2] | C h1:32 t1:33 => [C2 ((add:4 h0:29) h1:32) ((inter^33_inter^11 t0:30) t1:33)]}
//│ 89: [C 87: 11 88: [N]]
//│ [C 11 [N]] --->
//│ 	case ys:24 of {N => [N2] | C h1:25 t1:26 => [C2 ((add:4 h0:22) h1:25) ((inter^33_inter^11 t0:23) t1:26)]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((inter^33 l1^34) l2^36)
//│ def inter = (fun xs:9 -> case xs:9 of {
//│ 	N => (fun ys:10 -> ys:10)
//│ 	| C h0:11 t0:12 => (fun ys:13 -> case ys:13 of {
//│ 		N => [N2]
//│ 		| C h1:14 t1:15 => [C2 ((add:4 h0:11) h1:14) ((inter t0:12) t1:15)]})})
//│ def inter^33 = (fun xs:20 -> xs:20)
//│ def inter^33_inter^11 = (fun xs:27 -> xs:27)
//│ def l1 = [C 1 [C 2 [C 1 [C 2 [N]]]]]
//│ def l1^34 = let h0:22 = 1
//│ in let t0:23 = 
//│ 	let h0:29 = 2
//│ 	in let t0:30 = 
//│ 		let h0:29 = 1
//│ 		in let t0:30 = 
//│ 			let h0:29 = 2
//│ 			in let t0:30 = (fun ys:28 -> ys:28)
//│ 			in (fun ys:31 -> ys:31)
//│ 		in (fun ys:31 -> ys:31)
//│ 	in (fun ys:31 -> ys:31)
//│ in (fun ys:24 -> ys:24)
//│ def l2 = [C 11 [N]]
//│ def l2^36 = let h1:25 = 11
//│ in let t1:26 = [N2]
//│ in [C2 ((add:4 h0:22) h1:25) ((inter^33_inter^11 t0:23) t1:26)]
//│ <<<<<<< after fusion <<<<<<<


:ns
let rec p = C(C(C(id(p))))
fun c(x) = if x is
    C(a) then if a is
        C(b) then c(b)
fun id2(z) = z
fun id(y) = id2(y)
fun id3(d) = d
c(id3(p))
//│ |#let| |#rec| |p| |#=| |C|(|C|(|C|(|id|(|p|)|)|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |c|(|b|)|←|←|↵|#fun| |id2|(|z|)| |#=| |z|↵|#fun| |id|(|y|)| |#=| |id2|(|y|)|↵|#fun| |id3|(|d|)| |#=| |d|↵|c|(|id3|(|p|)|)|
//│ Parsed: {let rec p = C (C (C (id (p,),),),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then c (b,)››; fun id2 = z, => z; fun id = y, => id2 (y,); fun id3 = d, => d; c (id3 (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^23 (id3^24 p^25))
//│ def c = (fun x:11 -> case x:11 of {
//│ 	C a:12 => case a:12 of {
//│ 		C b:13 => (c^9 b:13)}})
//│ def id = (fun y:15 -> (id2^17 y:15))
//│ def id2 = (fun z:14 -> z:14)
//│ def id3 = (fun d:16 -> d:16)
//│ def p = [C [C [C (id^1 p^2)]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(C(C('3_callres))) <: 'a:12
//│ 	[-p^2 · +id^1 · +id2^17 · -id2^17 · -id^1 · -p^2 · +id^1 · +id2^17 · -id2^17 · -id^1 · -p^2 · +id^1 · +id2^17 · -id2^17 · -id^1 · -p^25 · +id3^24 · -id3^24 · +c^23 · +c^9 · +c^9 · +c^9 · +c^9]  --->  [-p^2 · +id^1 · +id2^17 · -id2^17 · -id^1 · -p^25 · +id3^24 · -id3^24 · +c^23 · +c^9]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c^23 · c^9 · c^9 · c^9 · c^9] --> [c^23 · c^9]
//│ [p^25 · p^2 · p^2 · p^2] --> [p^25 · p^2]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^23]
//│ 	[c^23 · c^9]
//│ 		[c^23 · c^9 · c^9]
//│ 			[c^23 · c^9 · c^9 · c^9]
//│ 				[c^23 · c^9 · c^9 · c^9 · c^9] ---> [c^23 · c^9] (only one)
//│ [id3^24] ---> [id3^24] (hopeless to continue)
//│ [p^25]
//│ 	[p^25 · p^2]
//│ 		[p^25 · p^2 · p^2]
//│ 			[p^25 · p^2 · p^2 · p^2] ---> [p^25 · p^2] (only one)
//│ 			[p^25 · p^2 · p^2 · id^1] ---> [id^1] (hopeless to continue)
//│ 		[p^25 · p^2 · id^1] ---> [id^1] (hopeless to continue)
//│ 	[p^25 · id^1] ---> [id^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c^23 (id3 p^25))
//│ def c = (fun x:14 -> case x:14 of {
//│ 	C a:15 => case a:15 of {
//│ 		C b:16 => (c b:16)}})
//│ def c^23 = (fun x:30 -> case x:30 of {
//│ 	C a:31 => case a:31 of {
//│ 		C b:32 => (c^23_c^9 b:32)}})
//│ def c^23_c^9 = (fun x:24 -> case x:24 of {
//│ 	C a:25 => case a:25 of {
//│ 		C b:26 => (c^23_c^9_c^9 b:26)}})
//│ def c^23_c^9_c^9 = (fun x:33 -> case x:33 of {
//│ 	C a:34 => case a:34 of {
//│ 		C b:35 => (c^23_c^9_c^9_c^9 b:35)}})
//│ def c^23_c^9_c^9_c^9 = (fun x:27 -> case x:27 of {
//│ 	C a:28 => case a:28 of {
//│ 		C b:29 => (c^23_c^9 b:29)}})
//│ def id = (fun y:13 -> (id2 y:13))
//│ def id2 = (fun z:12 -> z:12)
//│ def id3 = (fun d:11 -> d:11)
//│ def p = [C [C [C (id p)]]]
//│ def p^25 = [C [C [C (id p^25_p^2)]]]
//│ def p^25_p^2 = [C [C [C (id p^25_p^2_p^2)]]]
//│ def p^25_p^2_p^2 = [C [C [C (id p^25_p^2)]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 17: [C 16: (14: id 15: p)]
//│ [C (id p)] --->
//│ 	case a:34 of {C b:35 => (c^23_c^9_c^9_c^9 b:35)}
//│ 	case x:24 of {C a:25 => case a:25 of {C b:26 => (c^23_c^9_c^9 b:26)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 18: [C 17: [C 16: (14: id 15: p)]]
//│ [C [C (id p)]] --->
//│ 	case a:28 of {C b:29 => (c^23_c^9 b:29)}
//│ 	case x:33 of {C a:34 => case a:34 of {C b:35 => (c^23_c^9_c^9_c^9 b:35)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 19: [C 18: [C 17: [C 16: (14: id 15: p)]]]
//│ [C [C [C (id p)]]] --->
//│ 	case a:25 of {C b:26 => (c^23_c^9_c^9 b:26)}
//│ 	case x:27 of {C a:28 => case a:28 of {C b:29 => (c^23_c^9 b:29)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 31: [C 30: (28: id 29: p^25_p^2)]
//│ [C (id p^25_p^2)] --->
//│ 	case a:34 of {C b:35 => (c^23_c^9_c^9_c^9 b:35)}
//│ 	case x:24 of {C a:25 => case a:25 of {C b:26 => (c^23_c^9_c^9 b:26)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 32: [C 31: [C 30: (28: id 29: p^25_p^2)]]
//│ [C [C (id p^25_p^2)]] --->
//│ 	case a:28 of {C b:29 => (c^23_c^9 b:29)}
//│ 	case x:33 of {C a:34 => case a:34 of {C b:35 => (c^23_c^9_c^9_c^9 b:35)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 33: [C 32: [C 31: [C 30: (28: id 29: p^25_p^2)]]]
//│ [C [C [C (id p^25_p^2)]]] --->
//│ 	case a:25 of {C b:26 => (c^23_c^9_c^9 b:26)}
//│ 	case x:27 of {C a:28 => case a:28 of {C b:29 => (c^23_c^9 b:29)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 53: [C 52: (50: id 51: p^25_p^2_p^2)]
//│ [C (id p^25_p^2_p^2)] --->
//│ 	case a:34 of {C b:35 => (c^23_c^9_c^9_c^9 b:35)}
//│ 	case x:24 of {C a:25 => case a:25 of {C b:26 => (c^23_c^9_c^9 b:26)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 54: [C 53: [C 52: (50: id 51: p^25_p^2_p^2)]]
//│ [C [C (id p^25_p^2_p^2)]] --->
//│ 	case a:28 of {C b:29 => (c^23_c^9 b:29)}
//│ 	case x:33 of {C a:34 => case a:34 of {C b:35 => (c^23_c^9_c^9_c^9 b:35)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 55: [C 54: [C 53: [C 52: (50: id 51: p^25_p^2_p^2)]]]
//│ [C [C [C (id p^25_p^2_p^2)]]] --->
//│ 	case a:25 of {C b:26 => (c^23_c^9_c^9 b:26)}
//│ 	case x:27 of {C a:28 => case a:28 of {C b:29 => (c^23_c^9 b:29)}}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 75: [C 74: (72: id 73: p^25_p^2)]
//│ [C (id p^25_p^2)] --->
//│ 	case x:24 of {C a:25 => case a:25 of {C b:26 => (c^23_c^9_c^9 b:26)}}
//│ 76: [C 75: [C 74: (72: id 73: p^25_p^2)]]
//│ [C [C (id p^25_p^2)]] --->
//│ 	case a:31 of {C b:32 => (c^23_c^9 b:32)}
//│ 77: [C 76: [C 75: [C 74: (72: id 73: p^25_p^2)]]]
//│ [C [C [C (id p^25_p^2)]]] --->
//│ 	case x:30 of {C a:31 => case a:31 of {C b:32 => (c^23_c^9 b:32)}}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c^23 (id3 p^25))
//│ def c = (fun x:14 -> case x:14 of {
//│ 	C a:15 => case a:15 of {
//│ 		C b:16 => (c b:16)}})
//│ def c^23 = (fun x:30 -> x:30)
//│ def c^23_c^9 = (fun x:24 -> x:24)
//│ def c^23_c^9_c^9 = (fun x:33 -> x:33)
//│ def c^23_c^9_c^9_c^9 = (fun x:27 -> x:27)
//│ def id = (fun y:13 -> (id2 y:13))
//│ def id2 = (fun z:12 -> z:12)
//│ def id3 = (fun d:11 -> d:11)
//│ def p = let b:26 = 
//│ 	let a:34 = 
//│ 		let b:35 = (id p)
//│ 		in (c^23_c^9_c^9_c^9 b:35)
//│ 	in a:34
//│ in (c^23_c^9_c^9 b:26)
//│ def p^25 = let a:31 = 
//│ 	let b:32 = 
//│ 		let a:25 = (id p^25_p^2)
//│ 		in a:25
//│ 	in (c^23_c^9 b:32)
//│ in a:31
//│ def p^25_p^2 = let a:28 = 
//│ 	let b:29 = 
//│ 		let a:25 = (id p^25_p^2_p^2)
//│ 		in a:25
//│ 	in (c^23_c^9 b:29)
//│ in a:28
//│ def p^25_p^2_p^2 = let b:26 = 
//│ 	let a:34 = 
//│ 		let b:35 = (id p^25_p^2)
//│ 		in (c^23_c^9_c^9_c^9 b:35)
//│ 	in a:34
//│ in (c^23_c^9_c^9 b:26)
//│ <<<<<<< after fusion <<<<<<<

:ns
fun id(k) = k
fun id1(x) = id(x)
fun id2(y) = y
fun id3(z) = z
let rec p = C(C(C(id7(C(C(id1(p)))))))
fun c(xx) = if xx is
    C(a) then c(a)
fun id4(k) = k
fun id5(j) = j
fun id6(l) = l
fun id7(i) = i
id6(id4)(c)(id5(id2)(id3(p)))
//│ |#fun| |id|(|k|)| |#=| |k|↵|#fun| |id1|(|x|)| |#=| |id|(|x|)|↵|#fun| |id2|(|y|)| |#=| |y|↵|#fun| |id3|(|z|)| |#=| |z|↵|#let| |#rec| |p| |#=| |C|(|C|(|C|(|id7|(|C|(|C|(|id1|(|p|)|)|)|)|)|)|)|↵|#fun| |c|(|xx|)| |#=| |#if| |xx| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|#fun| |id4|(|k|)| |#=| |k|↵|#fun| |id5|(|j|)| |#=| |j|↵|#fun| |id6|(|l|)| |#=| |l|↵|#fun| |id7|(|i|)| |#=| |i|↵|id6|(|id4|)|(|c|)|(|id5|(|id2|)|(|id3|(|p|)|)|)|
//│ Parsed: {fun id = k, => k; fun id1 = x, => id (x,); fun id2 = y, => y; fun id3 = z, => z; let rec p = C (C (C (id7 (C (C (id1 (p,),),),),),),); fun c = xx, => if xx is ‹(C (a,)) then c (a,)›; fun id4 = k, => k; fun id5 = j, => j; fun id6 = l, => l; fun id7 = i, => i; id6 (id4,) (c,) (id5 (id2,) (id3 (p,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (((id6^35 id4^36) c^38) ((id5^40 id2^41) (id3^43 p^44)))
//│ def c = (fun xx:20 -> case xx:20 of {
//│ 	C a:21 => (c^22 a:21)})
//│ def id = (fun k:16 -> k:16)
//│ def id1 = (fun x:17 -> (id^3 x:17))
//│ def id2 = (fun y:18 -> y:18)
//│ def id3 = (fun z:19 -> z:19)
//│ def id4 = (fun k:22 -> k:22)
//│ def id5 = (fun j:23 -> j:23)
//│ def id6 = (fun l:24 -> l:24)
//│ def id7 = (fun i:25 -> i:25)
//│ def p = [C [C [C (id7^11 [C [C (id1^12 p^13)]])]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(C(C('17_callres))) <: 'a:21
//│ 	[-p^13 · +id1^12 · +id^3 · -id^3 · -id1^12 · +id7^11 · -id7^11 · -p^13 · +id1^12 · +id^3 · -id^3 · -id1^12 · +id7^11 · -id7^11 · -p^44 · +id3^43 · -id3^43 · +id5^40 · -id5^40 · +id2^41 · -id2^41 · +id5^40 · -id5^40 · +id6^35 · -id6^35 · +id4^36 · -id4^36 · +id6^35 · -id6^35 · +c^38 · +c^22 · +c^22 · +c^22 · +c^22 · +c^22 · +c^22 · +c^22 · +c^22 · +c^22]  --->  [-p^13 · +id1^12 · +id^3 · -id^3 · -id1^12 · +id7^11 · -id7^11 · -p^44 · +id3^43 · -id3^43 · +id5^40 · -id5^40 · +id2^41 · -id2^41 · +id5^40 · -id5^40 · +id6^35 · -id6^35 · +id4^36 · -id4^36 · +id6^35 · -id6^35 · +c^38 · +c^22 · +c^22 · +c^22 · +c^22]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> splitted knots >>>>>>>
//│ [c^38 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22] --> [c^38 · c^22 · c^22 · c^22 · c^22]
//│ [p^44 · p^13 · p^13] --> [p^44 · p^13]
//│ <<<<<<< splitted knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^38]
//│ 	[c^38 · c^22]
//│ 		[c^38 · c^22 · c^22]
//│ 			[c^38 · c^22 · c^22 · c^22]
//│ 				[c^38 · c^22 · c^22 · c^22 · c^22]
//│ 					[c^38 · c^22 · c^22 · c^22 · c^22 · c^22]
//│ 						[c^38 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22]
//│ 							[c^38 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22]
//│ 								[c^38 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22]
//│ 									[c^38 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22 · c^22] ---> [c^38 · c^22 · c^22 · c^22 · c^22] (only one)
//│ [id2^41] ---> [id2^41] (hopeless to continue)
//│ [id3^43] ---> [id3^43] (hopeless to continue)
//│ [id4^36] ---> [id4^36] (hopeless to continue)
//│ [id5^40] ---> [id5^40] (hopeless to continue)
//│ [id6^35] ---> [id6^35] (hopeless to continue)
//│ [p^44]
//│ 	[p^44 · id1^12] ---> [id1^12] (hopeless to continue)
//│ 	[p^44 · id7^11] ---> [id7^11] (hopeless to continue)
//│ 	[p^44 · p^13]
//│ 		[p^44 · p^13 · id1^12] ---> [id1^12] (hopeless to continue)
//│ 		[p^44 · p^13 · id7^11] ---> [id7^11] (hopeless to continue)
//│ 		[p^44 · p^13 · p^13] ---> [p^44 · p^13] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (((id6 id4) c^38) ((id5 id2) (id3 p^44)))
//│ def c = (fun xx:20 -> case xx:20 of {
//│ 	C a:21 => (c a:21)})
//│ def c^38 = (fun xx:39 -> case xx:39 of {
//│ 	C a:40 => (c^38_c^22 a:40)})
//│ def c^38_c^22 = (fun xx:37 -> case xx:37 of {
//│ 	C a:38 => (c^38_c^22_c^22 a:38)})
//│ def c^38_c^22_c^22 = (fun xx:47 -> case xx:47 of {
//│ 	C a:48 => (c^38_c^22_c^22_c^22 a:48)})
//│ def c^38_c^22_c^22_c^22 = (fun xx:41 -> case xx:41 of {
//│ 	C a:42 => (c^38_c^22_c^22_c^22_c^22 a:42)})
//│ def c^38_c^22_c^22_c^22_c^22 = (fun xx:45 -> case xx:45 of {
//│ 	C a:46 => (c^38_c^22_c^22_c^22_c^22_c^22 a:46)})
//│ def c^38_c^22_c^22_c^22_c^22_c^22 = (fun xx:53 -> case xx:53 of {
//│ 	C a:54 => (c^38_c^22_c^22_c^22_c^22_c^22_c^22 a:54)})
//│ def c^38_c^22_c^22_c^22_c^22_c^22_c^22 = (fun xx:51 -> case xx:51 of {
//│ 	C a:52 => (c^38_c^22_c^22_c^22_c^22_c^22_c^22_c^22 a:52)})
//│ def c^38_c^22_c^22_c^22_c^22_c^22_c^22_c^22 = (fun xx:43 -> case xx:43 of {
//│ 	C a:44 => (c^38_c^22_c^22_c^22_c^22_c^22_c^22_c^22_c^22 a:44)})
//│ def c^38_c^22_c^22_c^22_c^22_c^22_c^22_c^22_c^22 = (fun xx:49 -> case xx:49 of {
//│ 	C a:50 => (c^38_c^22_c^22_c^22_c^22 a:50)})
//│ def id = (fun k:23 -> k:23)
//│ def id1 = (fun x:17 -> (id x:17))
//│ def id2 = (fun y:24 -> y:24)
//│ def id3 = (fun z:19 -> z:19)
//│ def id4 = (fun k:22 -> k:22)
//│ def id5 = (fun j:25 -> j:25)
//│ def id6 = (fun l:16 -> l:16)
//│ def id7 = (fun i:18 -> i:18)
//│ def p = [C [C [C (id7 [C [C (id1 p)]])]]]
//│ def p^44 = [C [C [C (id7 [C [C (id1 p^44_p^13)]])]]]
//│ def p^44_p^13 = [C [C [C (id7 [C [C (id1 p^44_p^13)]])]]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 101: [C 100: (94: id7 99: [C 98: [C 97: (95: id1 96: p^44_p^13)]])]
//│ [C (id7 [C [C (id1 p^44_p^13)]])] --->
//│ 	case xx:47 of {C a:48 => (c^38_c^22_c^22_c^22 a:48)}
//│ 102: [C 101: [C 100: (94: id7 99: [C 98: [C 97: (95: id1 96: p^44_p^13)]])]]
//│ [C [C (id7 [C [C (id1 p^44_p^13)]])]] --->
//│ 	case xx:37 of {C a:38 => (c^38_c^22_c^22 a:38)}
//│ 103: [C 102: [C 101: [C 100: (94: id7 99: [C 98: [C 97: (95: id1 96: p^44_p^13)]])]]]
//│ [C [C [C (id7 [C [C (id1 p^44_p^13)]])]]] --->
//│ 	case xx:39 of {C a:40 => (c^38_c^22 a:40)}
//│ 34: [C 33: (31: id1 32: p)]
//│ [C (id1 p)] --->
//│ 	case xx:45 of {C a:46 => (c^38_c^22_c^22_c^22_c^22_c^22 a:46)}
//│ 35: [C 34: [C 33: (31: id1 32: p)]]
//│ [C [C (id1 p)]] --->
//│ 	case xx:41 of {C a:42 => (c^38_c^22_c^22_c^22_c^22 a:42)}
//│ 	case xx:49 of {C a:50 => (c^38_c^22_c^22_c^22_c^22 a:50)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 37: [C 36: (30: id7 35: [C 34: [C 33: (31: id1 32: p)]])]
//│ [C (id7 [C [C (id1 p)]])] --->
//│ 	case xx:43 of {C a:44 => (c^38_c^22_c^22_c^22_c^22_c^22_c^22_c^22_c^22 a:44)}
//│ 38: [C 37: [C 36: (30: id7 35: [C 34: [C 33: (31: id1 32: p)]])]]
//│ [C [C (id7 [C [C (id1 p)]])]] --->
//│ 	case xx:51 of {C a:52 => (c^38_c^22_c^22_c^22_c^22_c^22_c^22_c^22 a:52)}
//│ 39: [C 38: [C 37: [C 36: (30: id7 35: [C 34: [C 33: (31: id1 32: p)]])]]]
//│ [C [C [C (id7 [C [C (id1 p)]])]]] --->
//│ 	case xx:53 of {C a:54 => (c^38_c^22_c^22_c^22_c^22_c^22_c^22 a:54)}
//│ 82: [C 81: (79: id1 80: p^44_p^13)]
//│ [C (id1 p^44_p^13)] --->
//│ 	case xx:45 of {C a:46 => (c^38_c^22_c^22_c^22_c^22_c^22 a:46)}
//│ 83: [C 82: [C 81: (79: id1 80: p^44_p^13)]]
//│ [C [C (id1 p^44_p^13)]] --->
//│ 	case xx:41 of {C a:42 => (c^38_c^22_c^22_c^22_c^22 a:42)}
//│ 	case xx:49 of {C a:50 => (c^38_c^22_c^22_c^22_c^22 a:50)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ 85: [C 84: (78: id7 83: [C 82: [C 81: (79: id1 80: p^44_p^13)]])]
//│ [C (id7 [C [C (id1 p^44_p^13)]])] --->
//│ 	case xx:43 of {C a:44 => (c^38_c^22_c^22_c^22_c^22_c^22_c^22_c^22_c^22 a:44)}
//│ 86: [C 85: [C 84: (78: id7 83: [C 82: [C 81: (79: id1 80: p^44_p^13)]])]]
//│ [C [C (id7 [C [C (id1 p^44_p^13)]])]] --->
//│ 	case xx:51 of {C a:52 => (c^38_c^22_c^22_c^22_c^22_c^22_c^22_c^22 a:52)}
//│ 87: [C 86: [C 85: [C 84: (78: id7 83: [C 82: [C 81: (79: id1 80: p^44_p^13)]])]]]
//│ [C [C [C (id7 [C [C (id1 p^44_p^13)]])]]] --->
//│ 	case xx:53 of {C a:54 => (c^38_c^22_c^22_c^22_c^22_c^22_c^22 a:54)}
//│ 98: [C 97: (95: id1 96: p^44_p^13)]
//│ [C (id1 p^44_p^13)] --->
//│ 	case xx:45 of {C a:46 => (c^38_c^22_c^22_c^22_c^22_c^22 a:46)}
//│ 99: [C 98: [C 97: (95: id1 96: p^44_p^13)]]
//│ [C [C (id1 p^44_p^13)]] --->
//│ 	case xx:41 of {C a:42 => (c^38_c^22_c^22_c^22_c^22 a:42)}
//│ 	case xx:49 of {C a:50 => (c^38_c^22_c^22_c^22_c^22 a:50)}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (((id6 id4) c^38) ((id5 id2) (id3 p^44)))
//│ def c = (fun xx:20 -> case xx:20 of {
//│ 	C a:21 => (c a:21)})
//│ def c^38 = (fun xx:39 -> xx:39)
//│ def c^38_c^22 = (fun xx:37 -> xx:37)
//│ def c^38_c^22_c^22 = (fun xx:47 -> xx:47)
//│ def c^38_c^22_c^22_c^22 = (fun xx:41 -> xx:41)
//│ def c^38_c^22_c^22_c^22_c^22 = (fun xx:45 -> xx:45)
//│ def c^38_c^22_c^22_c^22_c^22_c^22 = (fun xx:53 -> xx:53)
//│ def c^38_c^22_c^22_c^22_c^22_c^22_c^22 = (fun xx:51 -> xx:51)
//│ def c^38_c^22_c^22_c^22_c^22_c^22_c^22_c^22 = (fun xx:43 -> xx:43)
//│ def c^38_c^22_c^22_c^22_c^22_c^22_c^22_c^22_c^22 = (fun xx:49 -> xx:49)
//│ def id = (fun k:23 -> k:23)
//│ def id1 = (fun x:17 -> (id x:17))
//│ def id2 = (fun y:24 -> y:24)
//│ def id3 = (fun z:19 -> z:19)
//│ def id4 = (fun k:22 -> k:22)
//│ def id5 = (fun j:25 -> j:25)
//│ def id6 = (fun l:16 -> l:16)
//│ def id7 = (fun i:18 -> i:18)
//│ def p = let a:54 = 
//│ 	let a:52 = 
//│ 		let a:44 = (id7 let a:42 = 
//│ 			let a:46 = (id1 p)
//│ 			in (c^38_c^22_c^22_c^22_c^22_c^22 a:46)
//│ 		in (c^38_c^22_c^22_c^22_c^22 a:42))
//│ 		in (c^38_c^22_c^22_c^22_c^22_c^22_c^22_c^22_c^22 a:44)
//│ 	in (c^38_c^22_c^22_c^22_c^22_c^22_c^22_c^22 a:52)
//│ in (c^38_c^22_c^22_c^22_c^22_c^22_c^22 a:54)
//│ def p^44 = let a:40 = 
//│ 	let a:38 = 
//│ 		let a:48 = (id7 let a:50 = 
//│ 			let a:46 = (id1 p^44_p^13)
//│ 			in (c^38_c^22_c^22_c^22_c^22_c^22 a:46)
//│ 		in (c^38_c^22_c^22_c^22_c^22 a:50))
//│ 		in (c^38_c^22_c^22_c^22 a:48)
//│ 	in (c^38_c^22_c^22 a:38)
//│ in (c^38_c^22 a:40)
//│ def p^44_p^13 = let a:54 = 
//│ 	let a:52 = 
//│ 		let a:44 = (id7 let a:50 = 
//│ 			let a:46 = (id1 p^44_p^13)
//│ 			in (c^38_c^22_c^22_c^22_c^22_c^22 a:46)
//│ 		in (c^38_c^22_c^22_c^22_c^22 a:50))
//│ 		in (c^38_c^22_c^22_c^22_c^22_c^22_c^22_c^22_c^22 a:44)
//│ 	in (c^38_c^22_c^22_c^22_c^22_c^22_c^22_c^22 a:52)
//│ in (c^38_c^22_c^22_c^22_c^22_c^22_c^22 a:54)
//│ <<<<<<< after fusion <<<<<<<

_LUMBERHACK_ERROR
fun id(x) = if x is
    ID(b) then b
    C(a) then id(ID(x))
let p = C(p)
fun c(y) = if y is
    C(aa) then c(aa)
c(id(p))
//│ |_LUMBERHACK_ERROR|↵|#fun| |id|(|x|)| |#=| |#if| |x| |is|→|ID|(|b|)| |#then| |b|↵|C|(|a|)| |#then| |id|(|ID|(|x|)|)|←|↵|#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |c|(|aa|)|←|↵|c|(|id|(|p|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun id = x, => if x is ‹(ID (b,)) then b; (C (a,)) then id (ID (x,),)›; let p = C (p,); fun c = y, => if y is ‹(C (aa,)) then c (aa,)›; c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^17 (id^18 p^19))
//│ def c = (fun y:12 -> case y:12 of {
//│ 	C aa:13 => (c^12 aa:13)})
//│ def id = (fun x:9 -> case x:9 of {
//│ 	ID b:10 => b:10
//│ 	| C a:11 => (id^3 [ID x:9])})
//│ def p = [C p^9]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: type error ID('x:9) <: Destruct(C('aa:13))
//│ !!!!!!ERROR!!!!!!
