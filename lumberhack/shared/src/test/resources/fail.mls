:NewParser
:ParseOnly

// WRONG: no push in, but all the elements can be handled
// _LUMBERHACK_ERROR
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun ff(x) = if x is
  K then T
  KK then TT
  KKKK then TTTT
let l = C(K, C(KK, C(KKKK, N)))
map(ff, l)
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|ff|,| |l|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; let l = C (K, C (KK, C (KKKK, N,),),); map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^28(ff^29, l^31)
//│ def ff(x⁰) = case x⁰ of {
//│ 	K  => [T]
//│ 	| KK  => [TT]
//│ 	| KKKK  => [TTTT]}
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 21 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 19
//│ [KK]: 22 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 19
//│ [KKKK]: 23 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 19
//│ [N]: 24 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ [C [KKKK] [N]]: 25 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ [C [KK] [C [KKKK] [N]]]: 26 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 27 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 24
//│ 	[C [KKKK] [N]]: 25
//│ 	[C [KK] [C [KKKK] [N]]]: 26
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 27
//│ case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 19 --->
//│ 	[K]: 21
//│ 	[KK]: 22
//│ 	[KKKK]: 23
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 21 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 19
//│ [KK]: 22 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 19
//│ [KKKK]: 23 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 19
//│ [N]: 24 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ [C [KKKK] [N]]: 25 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ [C [KK] [C [KKKK] [N]]]: 26 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 27 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 24
//│ 	[C [KKKK] [N]]: 25
//│ 	[C [KK] [C [KKKK] [N]]]: 26
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 27
//│ case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 19 --->
//│ 	[K]: 21
//│ 	[KK]: 22
//│ 	[KKKK]: 23
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(ff, l)
//│ def ff(x¹) = x¹
//│ def l = 
//│ 	let t¹ = 	
//│ 		let t² = 	
//│ 			let t³ = (fun f⁵ -> [N])
//│ 			in let h³ = [TTTT]
//│ 			in (fun f⁴ -> [C f⁴(h³) map(f⁴, t³)])
//│ 		in let h² = [TT]
//│ 		in (fun f³ -> [C f³(h²) map(f³, t²)])
//│ 	in let h¹ = [T]
//│ 	in (fun f² -> [C f²(h¹) map(f², t¹)])
//│ def map(f¹, ls¹) = ls¹(f¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ ff, map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ l -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ l(ff)
//│ def ff(x⁰) = x⁰
//│ def l = 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun f¹ -> [N])
//│ 			in let h⁰ = [TTTT]
//│ 			in (fun f² -> [C f²(h⁰) t²(f²)])
//│ 		in let h¹ = [TT]
//│ 		in (fun f³ -> [C f³(h¹) t¹(f³)])
//│ 	in let h² = [T]
//│ 	in (fun f⁴ -> [C f⁴(h²) t⁰(f⁴)])
//│ def map(f⁰, ls⁰) = ls⁰(f⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ l(ff)
//│ def ff(x⁰) = x⁰
//│ def l(f¹) = 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun f² -> [N])
//│ 			in let h⁰ = [TTTT]
//│ 			in (fun f³ -> [C f³(h⁰) t²(f³)])
//│ 		in let h¹ = [TT]
//│ 		in (fun f⁴ -> [C f⁴(h¹) t¹(f⁴)])
//│ 	in let h² = [T]
//│ 	in [C f¹(h²) t⁰(f¹)]
//│ def map(f⁰, ls⁰) = ls⁰(f⁰)
//│ <<<<<<< after floating out <<<<<<<

// NOTE: this way of doing param pushing in is a local change
_LUMBERHACK_EVAL
fun map(f, ls) = (if ls is
  C(h, t) then f => C(f(h), map(f, t))
  N then f => N
)(f)
fun ff(x) = if x is
  K then T
  KK then TT
  KKKK then TTTT
let l = C(K, C(KK, C(KKKK, N)))
map(ff, l)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|f|,| |ls|)| |#=| |(|#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |f| |=>| |N|←|↵|)|(|f|)|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|ff|,| |l|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = f, ls, => '(' if ls is ‹(C (h, t,)) then f, => C (f (h,), map (f, t,),); (N) then f, => N›, ')' (f,); fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; let l = C (K, C (KK, C (KKKK, N,),),); map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^32(ff^33, l^35)
//│ def ff(x⁰) = case x⁰ of {
//│ 	K  => [T]
//│ 	| KK  => [TT]
//│ 	| KKKK  => [TTTT]}
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun f¹ -> [C f¹(h⁰) map^5(f¹, t⁰)])
//│ 	| N  => (fun f² -> [N])}(f⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [T] [C [TT] [C [TTTT] [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 25 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 23
//│ [KK]: 26 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 23
//│ [KKKK]: 27 --->
//│ 	case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 23
//│ [N]: 28 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f¹ -> [C f¹(h⁰) map(f¹, t⁰)]) | N  => (fun f² -> [N])}: 14
//│ [C [KKKK] [N]]: 29 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f¹ -> [C f¹(h⁰) map(f¹, t⁰)]) | N  => (fun f² -> [N])}: 14
//│ [C [KK] [C [KKKK] [N]]]: 30 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f¹ -> [C f¹(h⁰) map(f¹, t⁰)]) | N  => (fun f² -> [N])}: 14
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 31 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f¹ -> [C f¹(h⁰) map(f¹, t⁰)]) | N  => (fun f² -> [N])}: 14
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => (fun f¹ -> [C f¹(h⁰) map(f¹, t⁰)]) | N  => (fun f² -> [N])}: 14 --->
//│ 	[N]: 28
//│ 	[C [KKKK] [N]]: 29
//│ 	[C [KK] [C [KKKK] [N]]]: 30
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 31
//│ case x⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 23 --->
//│ 	DeadCodeProd
//│ 	[K]: 25
//│ 	[KK]: 26
//│ 	[KKKK]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 28 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f¹ -> [C f¹(h⁰) map(f¹, t⁰)]) | N  => (fun f² -> [N])}: 14
//│ [C [KKKK] [N]]: 29 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f¹ -> [C f¹(h⁰) map(f¹, t⁰)]) | N  => (fun f² -> [N])}: 14
//│ [C [KK] [C [KKKK] [N]]]: 30 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f¹ -> [C f¹(h⁰) map(f¹, t⁰)]) | N  => (fun f² -> [N])}: 14
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 31 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f¹ -> [C f¹(h⁰) map(f¹, t⁰)]) | N  => (fun f² -> [N])}: 14
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => (fun f¹ -> [C f¹(h⁰) map(f¹, t⁰)]) | N  => (fun f² -> [N])}: 14 --->
//│ 	[N]: 28
//│ 	[C [KKKK] [N]]: 29
//│ 	[C [KK] [C [KKKK] [N]]]: 30
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 31
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(ff, l)
//│ def ff(x¹) = case x¹ of {
//│ 	K  => [T]
//│ 	| KK  => [TT]
//│ 	| KKKK  => [TTTT]}
//│ def l = 
//│ 	let t¹ = 	
//│ 		let t² = 	
//│ 			let t³ = (fun f⁷ -> [N])
//│ 			in let h³ = [KKKK]
//│ 			in (fun f⁶ -> [C f⁶(h³) map(f⁶, t³)])
//│ 		in let h² = [KK]
//│ 		in (fun f⁵ -> [C f⁵(h²) map(f⁵, t²)])
//│ 	in let h¹ = [K]
//│ 	in (fun f⁴ -> [C f⁴(h¹) map(f⁴, t¹)])
//│ def map(f³, ls¹) = ls¹(f³)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [T] [C [TT] [C [TTTT] [N]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ l -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ l(ff)
//│ def ff(x⁰) = case x⁰ of {
//│ 	K  => [T]
//│ 	| KK  => [TT]
//│ 	| KKKK  => [TTTT]}
//│ def l = 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun f¹ -> [N])
//│ 			in let h⁰ = [KKKK]
//│ 			in (fun f² -> [C f²(h⁰) t²(f²)])
//│ 		in let h¹ = [KK]
//│ 		in (fun f³ -> [C f³(h¹) t¹(f³)])
//│ 	in let h² = [K]
//│ 	in (fun f⁴ -> [C f⁴(h²) t⁰(f⁴)])
//│ def map(f⁰, ls⁰) = ls⁰(f⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ l(ff)
//│ def ff(x⁰) = case x⁰ of {
//│ 	K  => [T]
//│ 	| KK  => [TT]
//│ 	| KKKK  => [TTTT]}
//│ def l(f¹) = 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun f² -> [N])
//│ 			in let h⁰ = [KKKK]
//│ 			in (fun f³ -> [C f³(h⁰) t²(f³)])
//│ 		in let h¹ = [KK]
//│ 		in (fun f⁴ -> [C f⁴(h¹) t¹(f⁴)])
//│ 	in let h² = [K]
//│ 	in [C f¹(h²) t⁰(f¹)]
//│ def map(f⁰, ls⁰) = ls⁰(f⁰)
//│ <<<<<<< after floating out <<<<<<<



// WRONG: recursive length wrong: p should unrolled once and c should be unrolled to length 6 (unrol for 2 more times)!
// `id2` used twice
let p = C(C(C(id2(p))))
fun c(x) = if x is
  C(a) then if a is
    C(b) then c(b)
fun id2(yy) = yy
fun id(y) = id2(y)
c(id(p))
//│ |#let| |p| |#=| |C|(|C|(|C|(|id2|(|p|)|)|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |c|(|b|)|←|←|↵|#fun| |id2|(|yy|)| |#=| |yy|↵|#fun| |id|(|y|)| |#=| |id2|(|y|)|↵|c|(|id|(|p|)|)|
//│ Parsed: {let p = C (C (C (id2 (p,),),),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then c (b,)››; fun id2 = yy, => yy; fun id = y, => id2 (y,); c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^21(id^22(p^23))
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => c^9(b⁰)}}
//│ def id(y⁰) = id2^17(y⁰)
//│ def id2(yy⁰) = yy⁰
//│ def p = [C [C [C id2^1(p^2)]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C id2(p)]: 4 --->
//│ 	case a⁰ of {C b⁰ => c(b⁰)}: 12
//│ 	case x⁰ of {C a⁰ => case a⁰ of {C b⁰ => c(b⁰)}}: 13
//│ [C [C id2(p)]]: 5 --->
//│ 	case a⁰ of {C b⁰ => c(b⁰)}: 12
//│ 	case x⁰ of {C a⁰ => case a⁰ of {C b⁰ => c(b⁰)}}: 13
//│ [C [C [C id2(p)]]]: 6 --->
//│ 	case a⁰ of {C b⁰ => c(b⁰)}: 12
//│ 	case x⁰ of {C a⁰ => case a⁰ of {C b⁰ => c(b⁰)}}: 13
//│ ------------------
//│ case a⁰ of {C b⁰ => c(b⁰)}: 12 --->
//│ 	[C id2(p)]: 4
//│ 	[C [C id2(p)]]: 5
//│ 	[C [C [C id2(p)]]]: 6
//│ case x⁰ of {C a⁰ => case a⁰ of {C b⁰ => c(b⁰)}}: 13 --->
//│ 	[C id2(p)]: 4
//│ 	[C [C id2(p)]]: 5
//│ 	[C [C [C id2(p)]]]: 6
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(id(p))
//│ def c(x¹) = case x¹ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => c(b⁰)}}
//│ def id(y¹) = id2(y¹)
//│ def id2(yy¹) = yy¹
//│ def p = [C [C [C id2(p)]]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ c(id(p))
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => c(b⁰)}}
//│ def id(y⁰) = id2(y⁰)
//│ def id2(yy⁰) = yy⁰
//│ def p = [C [C [C id2(p)]]]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ c(id(p))
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => c(b⁰)}}
//│ def id(y⁰) = id2(y⁰)
//│ def id2(yy⁰) = yy⁰
//│ def p = [C [C [C id2(p)]]]
//│ <<<<<<< after floating out <<<<<<<


// WRONG: no polymorphism
_LUMBERHACK_ERROR
fun id(x) = x
let p = C(p)
fun c(a) = if a is
  C(i) then c(i)
id(c)(id(p))
//│ |_LUMBERHACK_ERROR|↵|#fun| |id|(|x|)| |#=| |x|↵|#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|a|)| |#=| |#if| |a| |is|→|C|(|i|)| |#then| |c|(|i|)|←|↵|id|(|c|)|(|id|(|p|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun id = x, => x; let p = C (p,); fun c = a, => if a is ‹(C (i,)) then c (i,)›; id (c,) (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ id^11(c^12, id^14(p^15))
//│ def c(a⁰) = case a⁰ of {
//│ 	C i⁰ => c^6(i⁰)}
//│ def id(x⁰) = x⁰
//│ def p = [C p^3]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p]: 4 --->
//│ 	case a⁰ of {C i⁰ => c(i⁰)}: 9
//│ ------------------
//│ case a⁰ of {C i⁰ => c(i⁰)}: 9 --->
//│ 	[C p]: 4
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C p]: 4 --->
//│ 	case a⁰ of {C i⁰ => c(i⁰)}: 9
//│ ------------------
//│ case a⁰ of {C i⁰ => c(i⁰)}: 9 --->
//│ 	[C p]: 4
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ id(c, id(p))
//│ def c(a¹) = a¹(99)
//│ def id(x¹) = x¹
//│ def p = 
//│ 	let i¹ = p
//│ 	in (fun _lh_dummy⁰ -> c(i¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ c
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ p -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ id(c, id(p))
//│ def c(a⁰) = a⁰(99)
//│ def id(x⁰) = x⁰
//│ def p = 
//│ 	let i⁰ = p
//│ 	in (fun _lh_dummy⁰ -> i⁰(99))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ id(c, id(p))
//│ def c(a⁰) = a⁰(99)
//│ def id(x⁰) = x⁰
//│ def p = 
//│ 	let i⁰ = p
//│ 	in (fun _lh_dummy⁰ -> i⁰(99))
//│ <<<<<<< after floating out <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!



// WRONG: recursive fusion strategies
let p = Pair(A, B)
fun c(x) = if x is
  Pair(a, b) then c(Pair(b, a))
c(p)
//│ |#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^12(p^13)
//│ def c(x⁰) = case x⁰ of {
//│ 	Pair a⁰ b⁰ => c^5([Pair b⁰ a⁰])}
//│ def p = [Pair [A] [B]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Pair [A] [B]]: 3 --->
//│ 	case x⁰ of {Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}: 10
//│ [Pair b⁰ a⁰]: 8 --->
//│ 	case x⁰ of {Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}: 10
//│ ------------------
//│ case x⁰ of {Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}: 10 --->
//│ 	[Pair [A] [B]]: 3
//│ 	[Pair b⁰ a⁰]: 8
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(p)
//│ def c(x¹) = case x¹ of {
//│ 	Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}
//│ def p = [Pair [A] [B]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ c(p)
//│ def c(x⁰) = case x⁰ of {
//│ 	Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}
//│ def p = [Pair [A] [B]]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ c(p)
//│ def c(x⁰) = case x⁰ of {
//│ 	Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}
//│ def p = [Pair [A] [B]]
//│ <<<<<<< after floating out <<<<<<<

// WRONG: before the filter of strategies, 
// it returns something like: C(1, C(9, C(2, ys => ys)))
// NOTE: after filtering of strategies, maybe we could have still got more fusion done in this case
_LUMBERHACK_EVAL
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
inter(C(1, C(2, N)))(C(9, N))
//│ |_LUMBERHACK_EVAL|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|inter|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|C|(|9|,| |N|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; inter (C (1, C (2, N,),),) (C (9, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^14([C 1 [C 2 [N]]], [C 9 [N]])
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 9 [C 2 [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 17 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 2 [N]]: 18 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 1 [C 2 [N]]]: 19 --->
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [N]: 22 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 9 [N]]: 23 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12 --->
//│ 	[N]: 17
//│ 	[C 2 [N]]: 18
//│ 	[C 1 [C 2 [N]]]: 19
//│ 	[N]: 22
//│ 	[C 9 [N]]: 23
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter([C 1 [C 2 [N]]], [C 9 [N]])
//│ def inter(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ inter(ys³, t⁰)])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 9 [C 2 [N]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ inter([C 1 [C 2 [N]]], [C 9 [N]])
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ inter([C 1 [C 2 [N]]], [C 9 [N]])
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ <<<<<<< after floating out <<<<<<<


// WRONG:
_LUMBERHACK_EVAL
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
fun typeCheck(ls) = if ls is
  C(a, b) then typeCheck(b)
  N then OK
typeCheck(inter(C(1, C(2, N)))(C(9, N)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#fun| |typeCheck|(|ls|)| |#=| |#if| |ls| |is|→|C|(|a|,| |b|)| |#then| |typeCheck|(|b|)|↵|N| |#then| |OK|←|↵|typeCheck|(|inter|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|C|(|9|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; fun typeCheck = ls, => if ls is ‹(C (a, b,)) then typeCheck (b,); (N) then OK›; typeCheck (inter (C (1, C (2, N,),),) (C (9, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ typeCheck^21(inter^22([C 1 [C 2 [N]]], [C 9 [N]]))
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def typeCheck(ls⁰) = case ls⁰ of {
//│ 	C a⁰ b⁰ => typeCheck^15(b⁰)
//│ 	| N  => [OK]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [OK]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ inter(ys¹, t⁰)]: 10 --->
//│ 	case ls⁰ of {C a⁰ b⁰ => typeCheck(b⁰) | N  => [OK]}: 19
//│ [N]: 25 --->
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ 	case ls⁰ of {C a⁰ b⁰ => typeCheck(b⁰) | N  => [OK]}: 19
//│ [C 2 [N]]: 26 --->
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ 	case ls⁰ of {C a⁰ b⁰ => typeCheck(b⁰) | N  => [OK]}: 19
//│ [C 1 [C 2 [N]]]: 27 --->
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [N]: 30 --->
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ 	case ls⁰ of {C a⁰ b⁰ => typeCheck(b⁰) | N  => [OK]}: 19
//│ [C 9 [N]]: 31 --->
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ 	case ls⁰ of {C a⁰ b⁰ => typeCheck(b⁰) | N  => [OK]}: 19
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12 --->
//│ 	[N]: 25
//│ 	[C 2 [N]]: 26
//│ 	[C 1 [C 2 [N]]]: 27
//│ 	[N]: 30
//│ 	[C 9 [N]]: 31
//│ case ls⁰ of {C a⁰ b⁰ => typeCheck(b⁰) | N  => [OK]}: 19 --->
//│ 	[C h⁰ inter(ys¹, t⁰)]: 10
//│ 	[N]: 25
//│ 	[C 2 [N]]: 26
//│ 	[N]: 30
//│ 	[C 9 [N]]: 31
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ typeCheck(inter([C 1 [C 2 [N]]], [C 9 [N]]))
//│ def inter(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ inter(ys³, t⁰)])}
//│ def typeCheck(ls¹) = case ls¹ of {
//│ 	C a⁰ b⁰ => typeCheck(b⁰)
//│ 	| N  => [OK]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [OK]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ typeCheck(inter([C 1 [C 2 [N]]], [C 9 [N]]))
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ def typeCheck(ls⁰) = case ls⁰ of {
//│ 	C a⁰ b⁰ => typeCheck(b⁰)
//│ 	| N  => [OK]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ typeCheck(inter([C 1 [C 2 [N]]], [C 9 [N]]))
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ def typeCheck(ls⁰) = case ls⁰ of {
//│ 	C a⁰ b⁰ => typeCheck(b⁰)
//│ 	| N  => [OK]}
//│ <<<<<<< after floating out <<<<<<<

// TODO: seems to be correct
_LUMBERHACK_EVAL
fun idxSum(ls) = if ls is
  N then acc => 0
  C(h, t) then acc => acc + idxSum(t)(acc + 1)
fun rev(lss) = if lss is
  N then a => a
  C(hh, tt) then a => rev(tt)(C(hh, a))
idxSum(rev(C(A, C(B, C(C, N))), N))(0)
//│ |_LUMBERHACK_EVAL|↵|#fun| |idxSum|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc| |=>| |0|↵|C|(|h|,| |t|)| |#then| |acc| |=>| |acc| |+| |idxSum|(|t|)|(|acc| |+| |1|)|←|↵|#fun| |rev|(|lss|)| |#=| |#if| |lss| |is|→|N| |#then| |a| |=>| |a|↵|C|(|hh|,| |tt|)| |#then| |a| |=>| |rev|(|tt|)|(|C|(|hh|,| |a|)|)|←|↵|idxSum|(|rev|(|C|(|A|,| |C|(|B|,| |C|(|C|,| |N|)|)|)|,| |N|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun idxSum = ls, => if ls is ‹(N) then acc, => 0; (C (h, t,)) then acc, => + (acc,) (idxSum (t,) (+ (acc,) (1,),),)›; fun rev = lss, => if lss is ‹(N) then a, => a; (C (hh, tt,)) then a, => rev (tt,) (C (hh, a,),)›; idxSum (rev (C (A, C (B, C (C, N,),),), N,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ idxSum^33(rev^34([C [A] [C [B] [C [C] [N]]]], [N]), 0)
//│ def idxSum(ls⁰) = case ls⁰ of {
//│ 	N  => (fun acc⁰ -> 0)
//│ 	| C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum^7(t⁰, (acc¹ + 1))))}
//│ def rev(lss⁰) = case lss⁰ of {
//│ 	N  => (fun a⁰ -> a⁰)
//│ 	| C hh⁰ tt⁰ => (fun a¹ -> rev^23(tt⁰, [C hh⁰ a¹]))}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 3
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh⁰ a¹]: 28 --->
//│ 	case ls⁰ of {N  => (fun acc⁰ -> 0) | C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum(t⁰, (acc¹ + 1))))}: 18
//│ [N]: 38 --->
//│ 	case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31
//│ [C [C] [N]]: 39 --->
//│ 	case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31
//│ [C [B] [C [C] [N]]]: 40 --->
//│ 	case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31
//│ [C [A] [C [B] [C [C] [N]]]]: 41 --->
//│ 	case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31
//│ [N]: 43 --->
//│ 	case ls⁰ of {N  => (fun acc⁰ -> 0) | C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum(t⁰, (acc¹ + 1))))}: 18
//│ ------------------
//│ case ls⁰ of {N  => (fun acc⁰ -> 0) | C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum(t⁰, (acc¹ + 1))))}: 18 --->
//│ 	[C hh⁰ a¹]: 28
//│ 	[N]: 43
//│ case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31 --->
//│ 	[N]: 38
//│ 	[C [C] [N]]: 39
//│ 	[C [B] [C [C] [N]]]: 40
//│ 	[C [A] [C [B] [C [C] [N]]]]: 41
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C hh⁰ a¹]: 28 --->
//│ 	case ls⁰ of {N  => (fun acc⁰ -> 0) | C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum(t⁰, (acc¹ + 1))))}: 18
//│ [N]: 38 --->
//│ 	case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31
//│ [C [C] [N]]: 39 --->
//│ 	case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31
//│ [C [B] [C [C] [N]]]: 40 --->
//│ 	case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31
//│ [C [A] [C [B] [C [C] [N]]]]: 41 --->
//│ 	case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31
//│ [N]: 43 --->
//│ 	case ls⁰ of {N  => (fun acc⁰ -> 0) | C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum(t⁰, (acc¹ + 1))))}: 18
//│ ------------------
//│ case ls⁰ of {N  => (fun acc⁰ -> 0) | C h⁰ t⁰ => (fun acc¹ -> (acc¹ + idxSum(t⁰, (acc¹ + 1))))}: 18 --->
//│ 	[C hh⁰ a¹]: 28
//│ 	[N]: 43
//│ case lss⁰ of {N  => (fun a⁰ -> a⁰) | C hh⁰ tt⁰ => (fun a¹ -> rev(tt⁰, [C hh⁰ a¹]))}: 31 --->
//│ 	[N]: 38
//│ 	[C [C] [N]]: 39
//│ 	[C [B] [C [C] [N]]]: 40
//│ 	[C [A] [C [B] [C [C] [N]]]]: 41
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ idxSum(rev(
//│ 	let tt¹ = 	
//│ 		let tt² = 	
//│ 			let tt³ = (fun a⁵ -> a⁵)
//│ 			in let hh³ = [C]
//│ 			in (fun a⁴ -> rev(tt³, 
//│ 				let t³ = a⁴
//│ 				in let h³ = hh³
//│ 				in (fun acc⁴ -> (acc⁴ + idxSum(t³, (acc⁴ + 1))))))
//│ 		in let hh² = [B]
//│ 		in (fun a³ -> rev(tt², 
//│ 			let t² = a³
//│ 			in let h² = hh²
//│ 			in (fun acc³ -> (acc³ + idxSum(t², (acc³ + 1))))))
//│ 	in let hh¹ = [A]
//│ 	in (fun a² -> rev(tt¹, 
//│ 		let t¹ = a²
//│ 		in let h¹ = hh¹
//│ 		in (fun acc² -> (acc² + idxSum(t¹, (acc² + 1)))))), (fun acc⁵ -> 0)), 0)
//│ def idxSum(ls¹) = ls¹
//│ def rev(lss¹) = lss¹
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 3
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev, idxSum
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ let tt⁰ = 	
//│ 	let tt¹ = 	
//│ 		let tt² = (fun a⁰ -> a⁰)
//│ 		in let hh⁰ = [C]
//│ 		in (fun a¹ -> tt²(
//│ 			let t⁰ = a¹
//│ 			in let h⁰ = hh⁰
//│ 			in (fun acc⁰ -> (acc⁰ + t⁰((acc⁰ + 1))))))
//│ 	in let hh¹ = [B]
//│ 	in (fun a² -> tt¹(
//│ 		let t¹ = a²
//│ 		in let h¹ = hh¹
//│ 		in (fun acc¹ -> (acc¹ + t¹((acc¹ + 1))))))
//│ in let hh² = [A]
//│ in tt⁰(
//│ 	let t² = (fun acc² -> 0)
//│ 	in let h² = hh²
//│ 	in (fun acc³ -> (acc³ + t²((acc³ + 1)))), 0)
//│ def idxSum(ls⁰) = ls⁰
//│ def rev(lss⁰) = lss⁰
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ let tt⁰ = 	
//│ 	let tt¹ = 	
//│ 		let tt² = (fun a⁰ -> a⁰)
//│ 		in let hh⁰ = [C]
//│ 		in (fun a¹ -> tt²(
//│ 			let t⁰ = a¹
//│ 			in let h⁰ = hh⁰
//│ 			in (fun acc⁰ -> (acc⁰ + t⁰((acc⁰ + 1))))))
//│ 	in let hh¹ = [B]
//│ 	in (fun a² -> tt¹(
//│ 		let t¹ = a²
//│ 		in let h¹ = hh¹
//│ 		in (fun acc¹ -> (acc¹ + t¹((acc¹ + 1))))))
//│ in let hh² = [A]
//│ in tt⁰(
//│ 	let t² = (fun acc² -> 0)
//│ 	in let h² = hh²
//│ 	in (fun acc³ -> (acc³ + t²((acc³ + 1)))), 0)
//│ def idxSum(ls⁰) = ls⁰
//│ def rev(lss⁰) = lss⁰
//│ <<<<<<< after floating out <<<<<<<


// WRONG: type
_LUMBERHACK_ERROR
fun id(x) = if x is
  ID(b) then b
  _ then id(ID(x))
let p = C(p)
fun c(y) = if y is
  C(aa) then c(aa)
c(id(p))
//│ |_LUMBERHACK_ERROR|↵|#fun| |id|(|x|)| |#=| |#if| |x| |is|→|ID|(|b|)| |#then| |b|↵|_| |#then| |id|(|ID|(|x|)|)|←|↵|#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |c|(|aa|)|←|↵|c|(|id|(|p|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun id = x, => if x is ‹(ID (b,)) then b; (_) then id (ID (x,),)›; let p = C (p,); fun c = y, => if y is ‹(C (aa,)) then c (aa,)›; c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^17(id^18(p^19))
//│ def c(y⁰) = case y⁰ of {
//│ 	C aa⁰ => c^12(aa⁰)}
//│ def id(x⁰) = case x⁰ of {
//│ 	ID b⁰ => b⁰
//│ 	| _  => id^3([ID x⁰])}
//│ def p = [C p^9]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [ID x⁰]: 5 --->
//│ 	case x⁰ of {ID b⁰ => b⁰ | _  => id([ID x⁰])}: 7
//│ [C p]: 10 --->
//│ 	case x⁰ of {ID b⁰ => b⁰ | _  => id([ID x⁰])}: 7
//│ 	case y⁰ of {C aa⁰ => c(aa⁰)}: 15
//│ ------------------
//│ case x⁰ of {ID b⁰ => b⁰ | _  => id([ID x⁰])}: 7 --->
//│ 	[ID x⁰]: 5
//│ 	[C p]: 10
//│ case y⁰ of {C aa⁰ => c(aa⁰)}: 15 --->
//│ 	[C p]: 10
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(id(p))
//│ def c(y¹) = case y¹ of {
//│ 	C aa⁰ => c(aa⁰)}
//│ def id(x¹) = case x¹ of {
//│ 	ID b⁰ => b⁰
//│ 	| _  => id([ID x¹])}
//│ def p = [C p]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ c(id(p))
//│ def c(y⁰) = case y⁰ of {
//│ 	C aa⁰ => c(aa⁰)}
//│ def id(x⁰) = case x⁰ of {
//│ 	ID b⁰ => b⁰
//│ 	| _  => id([ID x⁰])}
//│ def p = [C p]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ c(id(p))
//│ def c(y⁰) = case y⁰ of {
//│ 	C aa⁰ => c(aa⁰)}
//│ def id(x⁰) = case x⁰ of {
//│ 	ID b⁰ => b⁰
//│ 	| _  => id([ID x⁰])}
//│ def p = [C p]
//│ <<<<<<< after floating out <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!



// WRONG:
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
fun l1(x) = C(1, C(2, l1(add(x, 1))))
let rec l2 = C(9, C(8, l2))
inter(l1(0))(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#fun| |l1|(|x|)| |#=| |C|(|1|,| |C|(|2|,| |l1|(|add|(|x|,| |1|)|)|)|)|↵|#let| |#rec| |l2| |#=| |C|(|9|,| |C|(|8|,| |l2|)|)|↵|inter|(|l1|(|0|)|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; fun l1 = x, => C (1, C (2, l1 (add (x, 1,),),),); let rec l2 = C (9, C (8, l2,),); inter (l1 (0,),) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^31(l1^32(0), l2^36)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def l1(x⁰) = [C 1 [C 2 l1^16(add⁰(x⁰, 1))]]
//│ def l2 = [C 9 [C 8 l2^28]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 2 l1(add⁰(x⁰, 1))]: 23 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 1 [C 2 l1(add⁰(x⁰, 1))]]: 24 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 8 l2]: 29 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 9 [C 8 l2]]: 30 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12 --->
//│ 	[C 2 l1(add⁰(x⁰, 1))]: 23
//│ 	[C 1 [C 2 l1(add⁰(x⁰, 1))]]: 24
//│ 	[C 8 l2]: 29
//│ 	[C 9 [C 8 l2]]: 30
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter(l1(0), l2)
//│ def inter(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ inter(ys³, t⁰)])}
//│ def l1(x¹) = [C 1 [C 2 l1(add⁰(x¹, 1))]]
//│ def l2 = [C 9 [C 8 l2]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ inter(l1(0), l2)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ def l1(x⁰) = [C 1 [C 2 l1(add⁰(x⁰, 1))]]
//│ def l2 = [C 9 [C 8 l2]]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ inter(l1(0), l2)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ def l1(x⁰) = [C 1 [C 2 l1(add⁰(x⁰, 1))]]
//│ def l2 = [C 9 [C 8 l2]]
//│ <<<<<<< after floating out <<<<<<<


// WRONG: explosion on branch and recursive strategies, and timeout
// NOTE: need return pattern specilization for recursive strategies
// _LUMBERHACK_ERROR
// fun filterMax(ls) = if ls is
//   C(h, t) then m => if h > 0 is
//     True then if h > m is
//       True then if filterMax(t)(h) is
//         Pair(ys, max) then Pair(C(h, ys), max)
//       False then if filterMax(t)(m) is
//         Pair(ys, max) then Pair(C(h, ys), max)
//     False then filterMax(t)(m)
//   N then m => Pair(N, m)
// filterMax(C(1, C(2, N)))(0)


 
// WRONG: explode on branch
fun max(ms) = if ms is
  C(h, t) then m => if h > m is
   True then max(t)(h)
   False then max(t)(m)
  N then m => m
max(C(1, C(3, C(2, N))))(0)
//│ | |↵|/* WRONG: explode on branch*/|↵|#fun| |max|(|ms|)| |#=| |#if| |ms| |is|→|C|(|h|,| |t|)| |#then| |m| |=>| |#if| |h| |>| |m| |is|→|True| |#then| |max|(|t|)|(|h|)|↵|False| |#then| |max|(|t|)|(|m|)|←|↵|N| |#then| |m| |=>| |m|←|↵|max|(|C|(|1|,| |C|(|3|,| |C|(|2|,| |N|)|)|)|)|(|0|)|
//│ Parsed: {fun max = ms, => if ms is ‹(C (h, t,)) then m, => if > (h,) (m,) is ‹(True) then max (t,) (h,); (False) then max (t,) (m,)›; (N) then m, => m›; max (C (1, C (3, C (2, N,),),),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ max^23([C 1 [C 3 [C 2 [N]]]], 0)
//│ def max(ms⁰) = case ms⁰ of {
//│ 	C h⁰ t⁰ => (fun m⁰ -> case (h⁰ > m⁰) of {
//│ 		True  => max^7(t⁰, h⁰)
//│ 		| False  => max^12(t⁰, m⁰)})
//│ 	| N  => (fun m¹ -> m¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 27 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> case (h⁰ > m⁰) of {True  => max(t⁰, h⁰) | False  => max(t⁰, m⁰)}) | N  => (fun m¹ -> m¹)}: 21
//│ [C 2 [N]]: 28 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> case (h⁰ > m⁰) of {True  => max(t⁰, h⁰) | False  => max(t⁰, m⁰)}) | N  => (fun m¹ -> m¹)}: 21
//│ [C 3 [C 2 [N]]]: 29 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> case (h⁰ > m⁰) of {True  => max(t⁰, h⁰) | False  => max(t⁰, m⁰)}) | N  => (fun m¹ -> m¹)}: 21
//│ [C 1 [C 3 [C 2 [N]]]]: 30 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> case (h⁰ > m⁰) of {True  => max(t⁰, h⁰) | False  => max(t⁰, m⁰)}) | N  => (fun m¹ -> m¹)}: 21
//│ ------------------
//│ case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> case (h⁰ > m⁰) of {True  => max(t⁰, h⁰) | False  => max(t⁰, m⁰)}) | N  => (fun m¹ -> m¹)}: 21 --->
//│ 	[N]: 27
//│ 	[C 2 [N]]: 28
//│ 	[C 3 [C 2 [N]]]: 29
//│ 	[C 1 [C 3 [C 2 [N]]]]: 30
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 27 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> case (h⁰ > m⁰) of {True  => max(t⁰, h⁰) | False  => max(t⁰, m⁰)}) | N  => (fun m¹ -> m¹)}: 21
//│ [C 2 [N]]: 28 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> case (h⁰ > m⁰) of {True  => max(t⁰, h⁰) | False  => max(t⁰, m⁰)}) | N  => (fun m¹ -> m¹)}: 21
//│ [C 3 [C 2 [N]]]: 29 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> case (h⁰ > m⁰) of {True  => max(t⁰, h⁰) | False  => max(t⁰, m⁰)}) | N  => (fun m¹ -> m¹)}: 21
//│ [C 1 [C 3 [C 2 [N]]]]: 30 --->
//│ 	case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> case (h⁰ > m⁰) of {True  => max(t⁰, h⁰) | False  => max(t⁰, m⁰)}) | N  => (fun m¹ -> m¹)}: 21
//│ ------------------
//│ case ms⁰ of {C h⁰ t⁰ => (fun m⁰ -> case (h⁰ > m⁰) of {True  => max(t⁰, h⁰) | False  => max(t⁰, m⁰)}) | N  => (fun m¹ -> m¹)}: 21 --->
//│ 	[N]: 27
//│ 	[C 2 [N]]: 28
//│ 	[C 3 [C 2 [N]]]: 29
//│ 	[C 1 [C 3 [C 2 [N]]]]: 30
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ max(
//│ 	let t¹ = 	
//│ 		let t² = 	
//│ 			let t³ = (fun m⁵ -> m⁵)
//│ 			in let h³ = 2
//│ 			in (fun m⁴ -> case (h³ > m⁴) of {
//│ 				True  => max(t³, h³)
//│ 				| False  => max(t³, m⁴)})
//│ 		in let h² = 3
//│ 		in (fun m³ -> case (h² > m³) of {
//│ 			True  => max(t², h²)
//│ 			| False  => max(t², m³)})
//│ 	in let h¹ = 1
//│ 	in (fun m² -> case (h¹ > m²) of {
//│ 		True  => max(t¹, h¹)
//│ 		| False  => max(t¹, m²)}), 0)
//│ def max(ms¹) = ms¹
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ max
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ let t⁰ = 	
//│ 	let t¹ = 	
//│ 		let t² = (fun m⁰ -> m⁰)
//│ 		in let h⁰ = 2
//│ 		in (fun m¹ -> case (h⁰ > m¹) of {
//│ 			True  => t²(h⁰)
//│ 			| False  => t²(m¹)})
//│ 	in let h¹ = 3
//│ 	in (fun m² -> case (h¹ > m²) of {
//│ 		True  => t¹(h¹)
//│ 		| False  => t¹(m²)})
//│ in let h² = 1
//│ in case (h² > 0) of {
//│ 	True  => t⁰(h²)
//│ 	| False  => t⁰(0)}
//│ def max(ms⁰) = ms⁰
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ let t⁰ = 	
//│ 	let t¹ = 	
//│ 		let t² = (fun m⁰ -> m⁰)
//│ 		in let h⁰ = 2
//│ 		in (fun m¹ -> case (h⁰ > m¹) of {
//│ 			True  => t²(h⁰)
//│ 			| False  => t²(m¹)})
//│ 	in let h¹ = 3
//│ 	in (fun m² -> case (h¹ > m²) of {
//│ 		True  => t¹(h¹)
//│ 		| False  => t¹(m²)})
//│ in let h² = 1
//│ in case (h² > 0) of {
//│ 	True  => t⁰(h²)
//│ 	| False  => t⁰(0)}
//│ def max(ms⁰) = ms⁰
//│ <<<<<<< after floating out <<<<<<<

// WRONG: multiple match
fun last(ls) = if ls is
  C(h, t) then if t is
    N then Some(h)
    C(hh, tt) then last(t)
  N then None
last(C(1, C(2, C(3, N))))
//│ |#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |last|(|t|)|←|↵|N| |#then| |None|←|↵|last|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {fun last = ls, => if ls is ‹(C (h, t,)) then if t is ‹(N) then Some (h,); (C (hh, tt,)) then last (t,)›; (N) then None›; last (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ last^12([C 1 [C 2 [C 3 [N]]]])
//│ def last(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N  => [Some h⁰]
//│ 		| C hh⁰ tt⁰ => last^5(t⁰)}
//│ 	| N  => [None]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 16 --->
//│ 	DeadCodeCons
//│ 	case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)}: 8
//│ 	case ls⁰ of {C h⁰ t⁰ => case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)} | N  => [None]}: 10
//│ [C 3 [N]]: 17 --->
//│ 	DeadCodeCons
//│ 	case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)}: 8
//│ 	case ls⁰ of {C h⁰ t⁰ => case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)} | N  => [None]}: 10
//│ [C 2 [C 3 [N]]]: 18 --->
//│ 	case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)}: 8
//│ 	case ls⁰ of {C h⁰ t⁰ => case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)} | N  => [None]}: 10
//│ [C 1 [C 2 [C 3 [N]]]]: 19 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)} | N  => [None]}: 10
//│ ------------------
//│ case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)}: 8 --->
//│ 	[N]: 16
//│ 	[C 3 [N]]: 17
//│ 	[C 2 [C 3 [N]]]: 18
//│ case ls⁰ of {C h⁰ t⁰ => case t⁰ of {N  => [Some h⁰] | C hh⁰ tt⁰ => last(t⁰)} | N  => [None]}: 10 --->
//│ 	[N]: 16
//│ 	[C 3 [N]]: 17
//│ 	[C 2 [C 3 [N]]]: 18
//│ 	[C 1 [C 2 [C 3 [N]]]]: 19
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ last([C 1 [C 2 [C 3 [N]]]])
//│ def last(ls¹) = case ls¹ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N  => [Some h⁰]
//│ 		| C hh⁰ tt⁰ => last(t⁰)}
//│ 	| N  => [None]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ last([C 1 [C 2 [C 3 [N]]]])
//│ def last(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N  => [Some h⁰]
//│ 		| C hh⁰ tt⁰ => last(t⁰)}
//│ 	| N  => [None]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ last([C 1 [C 2 [C 3 [N]]]])
//│ def last(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N  => [Some h⁰]
//│ 		| C hh⁰ tt⁰ => last(t⁰)}
//│ 	| N  => [None]}
//│ <<<<<<< after floating out <<<<<<<

// cannot have asymptotic complexity improvement, but which is a non-goal
_LUMBERHACK_EVAL
fun concat(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(C(1, C(2, C(3, N))))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^27([C 1 [C 2 [C 3 [N]]]])
//│ def concat(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat^5(t⁰, ys¹)])}
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^15(rev^16(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 3 [C 2 [C 1 [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ concat(t⁰, ys¹)]: 10 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [N]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [C h¹ [N]]: 22 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [N]: 24 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [N]: 31 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 3 [N]]: 32 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 2 [C 3 [N]]]: 33 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 1 [C 2 [C 3 [N]]]]: 34 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12 --->
//│ 	[C h⁰ concat(t⁰, ys¹)]: 10
//│ 	[N]: 21
//│ 	[C h¹ [N]]: 22
//│ 	[N]: 24
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25 --->
//│ 	[N]: 31
//│ 	[C 3 [N]]: 32
//│ 	[C 2 [C 3 [N]]]: 33
//│ 	[C 1 [C 2 [C 3 [N]]]]: 34
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 31 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 3 [N]]: 32 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 2 [C 3 [N]]]: 33 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ [C 1 [C 2 [C 3 [N]]]]: 34 --->
//│ 	case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25
//│ ------------------
//│ case ls⁰ of {C h¹ t¹ => concat(rev(t¹), [C h¹ [N]]) | N  => [N]}: 25 --->
//│ 	[N]: 31
//│ 	[C 3 [N]]: 32
//│ 	[C 2 [C 3 [N]]]: 33
//│ 	[C 1 [C 2 [C 3 [N]]]]: 34
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(
//│ 	let t² = 	
//│ 		let t³ = 	
//│ 			let t⁴ = (fun _lh_dummy³ -> [N])
//│ 			in let h⁴ = 3
//│ 			in (fun _lh_dummy² -> concat(rev(t⁴), [C h⁴ [N]]))
//│ 		in let h³ = 2
//│ 		in (fun _lh_dummy¹ -> concat(rev(t³), [C h³ [N]]))
//│ 	in let h² = 1
//│ 	in (fun _lh_dummy⁰ -> concat(rev(t²), [C h² [N]])))
//│ def concat(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ concat(t⁰, ys³)])}
//│ def rev(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 3 [C 2 [C 1 [N]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ rev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun _lh_dummy⁰ -> [N])
//│ 			in let h⁰ = 3
//│ 			in (fun _lh_dummy¹ -> concat(t²(99), [C h⁰ [N]]))
//│ 		in let h¹ = 2
//│ 		in (fun _lh_dummy² -> concat(t¹(99), [C h¹ [N]]))
//│ 	in let h² = 1
//│ 	in (fun _lh_dummy³ -> concat(t⁰(99), [C h² [N]]))(99)
//│ def concat(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h³ t³ => (fun ys¹ -> [C h³ concat(t³, ys¹)])}
//│ def rev(ls⁰) = ls⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun _lh_dummy⁰ -> [N])
//│ 			in let h⁰ = 3
//│ 			in (fun _lh_dummy¹ -> concat(t²(99), [C h⁰ [N]]))
//│ 		in let h¹ = 2
//│ 		in (fun _lh_dummy² -> concat(t¹(99), [C h¹ [N]]))
//│ 	in let h² = 1
//│ 	in (fun _lh_dummy³ -> concat(t⁰(99), [C h² [N]]))(99)
//│ def concat(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h³ t³ => (fun ys¹ -> [C h³ concat(t³, ys¹)])}
//│ def rev(ls⁰) = ls⁰(99)
//│ <<<<<<< after floating out <<<<<<<



fun concat(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(primitive)
//│ |#fun| |concat|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|primitive|)|
//│ Parsed: {fun concat = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (primitive,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ rev^27(primitive⁰)
//│ def concat(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat^5(t⁰, ys¹)])}
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat^15(rev^16(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ concat(t⁰, ys¹)]: 10 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [N]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [C h¹ [N]]: 22 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ [N]: 24 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}: 12 --->
//│ 	[C h⁰ concat(t⁰, ys¹)]: 10
//│ 	[N]: 21
//│ 	[C h¹ [N]]: 22
//│ 	[N]: 24
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ rev(primitive⁰)
//│ def concat(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ concat(t⁰, ys³)])}
//│ def rev(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => concat(rev(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ rev(primitive⁰)
//│ def concat(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat(rev(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ rev(primitive⁰)
//│ def concat(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ concat(t⁰, ys¹)])}
//│ def rev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => concat(rev(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<< after floating out <<<<<<<


// WRONG: we can do the fusion, despite that `p` here will be consumed by toplevelResult
let rec p = C(p)
fun c(x) = if x is
  C(a) then a
fun main(y) = c(p)
main(0)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |a|←|↵|#fun| |main|(|y|)| |#=| |c|(|p|)|↵|main|(|0|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then a›; fun main = y, => c (p,); main (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^11(0)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => a⁰}
//│ def main(y⁰) = c^7(p^8)
//│ def p = [C p^1]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C p]: 2 --->
//│ 	NoCons
//│ 	case x⁰ of {C a⁰ => a⁰}: 5
//│ ------------------
//│ case x⁰ of {C a⁰ => a⁰}: 5 --->
//│ 	[C p]: 2
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main(0)
//│ def c(x¹) = case x¹ of {
//│ 	C a⁰ => a⁰}
//│ def main(y¹) = c(p)
//│ def p = [C p]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ main(0)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => a⁰}
//│ def main(y⁰) = c(p)
//│ def p = [C p]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ main(0)
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => a⁰}
//│ def main(y⁰) = c(p)
//│ def p = [C p]
//│ <<<<<<< after floating out <<<<<<<

// CORRECT: as long as the top level result is consumed
fun f(a) = if primitive then B else a
fun g(x) = if x is
  B then C
  D then E
fun k(a) = g(f(a))
k
//│ |#fun| |f|(|a|)| |#=| |#if| |primitive| |#then| |B| |#else| |a|↵|#fun| |g|(|x|)| |#=| |#if| |x| |is|→|B| |#then| |C|↵|D| |#then| |E|←|↵|#fun| |k|(|a|)| |#=| |g|(|f|(|a|)|)|↵|k|
//│ Parsed: {fun f = a, => if (primitive) then B else a; fun g = x, => if x is ‹(B) then C; (D) then E›; fun k = a, => g (f (a,),); k}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ k^17
//│ def f(a⁰) = if primitive⁰ then [B] else a⁰
//│ def g(x⁰) = case x⁰ of {
//│ 	B  => [C]
//│ 	| D  => [E]}
//│ def k(a¹) = g^11(f^12(a¹))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [B]: 2 --->
//│ 	case x⁰ of {B  => [C] | D  => [E]}: 9
//│ ------------------
//│ case x⁰ of {B  => [C] | D  => [E]}: 9 --->
//│ 	NoProd
//│ 	[B]: 2
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ k
//│ def f(a²) = if primitive⁰ then [B] else a²
//│ def g(x¹) = case x¹ of {
//│ 	B  => [C]
//│ 	| D  => [E]}
//│ def k(a³) = g(f(a³))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ k
//│ def f(a⁰) = if primitive⁰ then [B] else a⁰
//│ def g(x⁰) = case x⁰ of {
//│ 	B  => [C]
//│ 	| D  => [E]}
//│ def k(a¹) = g(f(a¹))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ k
//│ def f(a⁰) = if primitive⁰ then [B] else a⁰
//│ def g(x⁰) = case x⁰ of {
//│ 	B  => [C]
//│ 	| D  => [E]}
//│ def k(a¹) = g(f(a¹))
//│ <<<<<<< after floating out <<<<<<<
