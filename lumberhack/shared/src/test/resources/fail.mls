:NewParser
:ParseOnly

// WRONG: no push in, but all the elements can be handled
_LUMBERHACK_ERROR
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun ff(x) = if x is
  K then T
  KK then TT
  KKKK then TTTT
let l = C(K, C(KK, C(KKKK, N)))
map(ff, l)
//│ |_LUMBERHACK_ERROR|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|ff|,| |l|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; let l = C (K, C (KK, C (KKKK, N,),),); map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((map^28 ff^29) l^31)
//│ def ff = (fun x⁰ -> case x⁰ of {
//│ 	K => [T]
//│ 	| KK => [TT]
//│ 	| KKKK => [TTTT]})
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun f⁰ -> (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C (f⁰ h⁰) ((map^5 f⁰) t⁰)]
//│ 	| N => [N]}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^29] (hopeless to continue)
//│ [l^31] (hopeless to continue)
//│ [map^28] (hopeless to continue)
//│ 	[map^28 · map^5] ---> [map^28] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((map₀ ff₀) l₀)
//│ def ff₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]})
//│ def l₀ = 
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map₀ = 
//│ 	(fun f¹ -> (fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => [C (f¹ h¹) ((map₀ f¹) t¹)]
//│ 		| N => [N]}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [KKKK] [N]]: 57 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (f¹ h¹) ((map₀ f¹) t¹)] | N => [N]}: 50
//│ [C [KK] [C [KKKK] [N]]]: 58 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (f¹ h¹) ((map₀ f¹) t¹)] | N => [N]}: 50
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 59 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (f¹ h¹) ((map₀ f¹) t¹)] | N => [N]}: 50
//│ [KKKK]: 55 --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 37
//│ [KK]: 54 --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 37
//│ [K]: 53 --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 37
//│ [N]: 56 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (f¹ h¹) ((map₀ f¹) t¹)] | N => [N]}: 50
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 53 --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 37
//│ [KK]: 54 --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 37
//│ [KKKK]: 55 --->
//│ 	case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 37
//│ [N]: 56 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (f¹ h¹) ((map₀ f¹) t¹)] | N => [N]}: 50
//│ [C [KKKK] [N]]: 57 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (f¹ h¹) ((map₀ f¹) t¹)] | N => [N]}: 50
//│ [C [KK] [C [KKKK] [N]]]: 58 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (f¹ h¹) ((map₀ f¹) t¹)] | N => [N]}: 50
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 59 --->
//│ 	case ls¹ of {C h¹ t¹ => [C (f¹ h¹) ((map₀ f¹) t¹)] | N => [N]}: 50
//│ ------------------
//│ case x¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]}: 37 --->
//│ 	[K]: 53
//│ 	[KK]: 54
//│ 	[KKKK]: 55
//│ case ls¹ of {C h¹ t¹ => [C (f¹ h¹) ((map₀ f¹) t¹)] | N => [N]}: 50 --->
//│ 	[N]: 56
//│ 	[C [KKKK] [N]]: 57
//│ 	[C [KK] [C [KKKK] [N]]]: 58
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 59
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((map₀ ff₀) l₀)
//│ def ff₀ = 
//│ 	(fun x² -> x²)
//│ def l₀ = 
//│ 	let h² = [T]
//│ 	in let t² = 	
//│ 		let h³ = [TT]
//│ 		in let t³ = 	
//│ 			let h⁴ = [TTTT]
//│ 			in let t⁴ = [N]
//│ 			in [C (f¹ h⁴) ((map₀ f¹) t⁴)]
//│ 		in [C (f¹ h³) ((map₀ f¹) t³)]
//│ 	in [C (f¹ h²) ((map₀ f¹) t²)]
//│ def map₀ = 
//│ 	(fun f² -> (fun ls² -> ls²))
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: binding not found: Ident(false,f,1)
//│ !!!!!!ERROR!!!!!!

// WRONG: cannot handle the second rev call (but top level non-polymorphic multiple references can now be handled)
// _LUMBERHACK_ERROR
fun rev(ls) = if ls is
  N then a => a
  C(h, t) then a => rev(t)(C(h, a))
rev(C(AA, C(BB, C(CC, N))))(N)
//│ |#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a| |=>| |a|↵|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|←|↵|rev|(|C|(|AA|,| |C|(|BB|,| |C|(|CC|,| |N|)|)|)|)|(|N|)|
//│ Parsed: {fun rev = ls, => if ls is ‹(N) then a, => a; (C (h, t,)) then a, => rev (t,) (C (h, a,),)›; rev (C (AA, C (BB, C (CC, N,),),),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev^14 [C [AA] [C [BB] [C [CC] [N]]]]) [N])
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	N => (fun a⁰ -> a⁰)
//│ 	| C h⁰ t⁰ => (fun a¹ -> ((rev^4 t⁰) [C h⁰ a¹]))})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14] (hopeless to continue)
//│ 	[rev^14 · rev^4] ---> [rev^14] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev₀ [C [AA] [C [BB] [C [CC] [N]]]]) [N])
//│ def rev₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		N => (fun a² -> a²)
//│ 		| C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [AA] [C [BB] [C [CC] [N]]]]: 45 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ [C [BB] [C [CC] [N]]]: 44 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ [C [CC] [N]]: 43 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ [N]: 42 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 42 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ [C [CC] [N]]: 43 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ [C [BB] [C [CC] [N]]]: 44 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ [C [AA] [C [BB] [C [CC] [N]]]]: 45 --->
//│ 	case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ ------------------
//│ case ls¹ of {N => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36 --->
//│ 	[N]: 42
//│ 	[C [CC] [N]]: 43
//│ 	[C [BB] [C [CC] [N]]]: 44
//│ 	[C [AA] [C [BB] [C [CC] [N]]]]: 45
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev₀ 
//│ 	let h² = [AA]
//│ 	in let t² = 	
//│ 		let h³ = [BB]
//│ 		in let t³ = 	
//│ 			let h⁴ = [CC]
//│ 			in let t⁴ = (fun a⁷ -> a⁷)
//│ 			in (fun a⁶ -> ((rev₀ t⁴) [C h⁴ a⁶]))
//│ 		in (fun a⁵ -> ((rev₀ t³) [C h³ a⁵]))
//│ 	in (fun a⁴ -> ((rev₀ t²) [C h² a⁴]))) [N])
//│ def rev₀ = 
//│ 	(fun ls² -> ls²)
//│ <<<<<<< after fusion <<<<<<<


// `id2` used twice
// WRONG: recursive length wrong?
// NOTE: any more behavioural differences?
let p = C(C(C(id2(p))))
fun c(x) = if x is
  C(a) then if a is
    C(b) then c(b)
fun id2(yy) = yy
fun id(y) = id2(y)
c(id(p))
//│ |#let| |p| |#=| |C|(|C|(|C|(|id2|(|p|)|)|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|b|)| |#then| |c|(|b|)|←|←|↵|#fun| |id2|(|yy|)| |#=| |yy|↵|#fun| |id|(|y|)| |#=| |id2|(|y|)|↵|c|(|id|(|p|)|)|
//│ Parsed: {let p = C (C (C (id2 (p,),),),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (b,)) then c (b,)››; fun id2 = yy, => yy; fun id = y, => id2 (y,); c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^21 (id^22 p^23))
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		C b⁰ => (c^9 b⁰)}})
//│ def id = (fun y⁰ -> (id2^17 y⁰))
//│ def id2 = (fun yy⁰ -> yy⁰)
//│ def p = [C [C [C (id2^1 p^2)]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^21] (hopeless to continue)
//│ 	[c^21 · c^9] ---> [c^21] (using original def)
//│ [id^22] (hopeless to continue)
//│ 	[id^22 · id2^17] (using original def)
//│ [p^23] (hopeless to continue)
//│ 	[p^23 · id2^1] (using original def)
//│ 	[p^23 · p^2] ---> [p^23] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ (id₀ p₀))
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		C a¹ => case a¹ of {
//│ 			C b¹ => (c₀ b¹)}})
//│ def id₀ = 
//│ 	(fun y¹ -> (id2₀ y¹))
//│ 	where
//│ 	def id2₀ = 
//│ 		(fun yy¹ -> yy¹)
//│ def p₀ = 
//│ 	[C [C [C (id2₁ p₀)]]]
//│ 	where
//│ 	def id2₁ = 
//│ 		(fun yy² -> yy²)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C (id2₁ p₀)]: 45 --->
//│ 	case a¹ of {C b¹ => (c₀ b¹)}: 33
//│ 	case x¹ of {C a¹ => case a¹ of {C b¹ => (c₀ b¹)}}: 34
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C [C (id2₁ p₀)]]: 46 --->
//│ 	case a¹ of {C b¹ => (c₀ b¹)}: 33
//│ 	case x¹ of {C a¹ => case a¹ of {C b¹ => (c₀ b¹)}}: 34
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C [C [C (id2₁ p₀)]]]: 47 --->
//│ 	case a¹ of {C b¹ => (c₀ b¹)}: 33
//│ 	case x¹ of {C a¹ => case a¹ of {C b¹ => (c₀ b¹)}}: 34
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ (id₀ p₀))
//│ def c₀ = 
//│ 	(fun x² -> case x² of {
//│ 		C a¹ => case a¹ of {
//│ 			C b¹ => (c₀ b¹)}})
//│ def id₀ = 
//│ 	(fun y² -> (id2₀ y²))
//│ 	where
//│ 	def id2₀ = 
//│ 		(fun yy⁴ -> yy⁴)
//│ def p₀ = 
//│ 	[C [C [C (id2₁ p₀)]]]
//│ 	where
//│ 	def id2₁ = 
//│ 		(fun yy³ -> yy³)
//│ <<<<<<< after fusion <<<<<<<


// WRONG: no polymorphism
_LUMBERHACK_ERROR
fun id(x) = x
let p = C(p)
fun c(a) = if a is
  C(i) then c(i)
id(c)(id(p))
//│ |_LUMBERHACK_ERROR|↵|#fun| |id|(|x|)| |#=| |x|↵|#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|a|)| |#=| |#if| |a| |is|→|C|(|i|)| |#then| |c|(|i|)|←|↵|id|(|c|)|(|id|(|p|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun id = x, => x; let p = C (p,); fun c = a, => if a is ‹(C (i,)) then c (i,)›; id (c,) (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((id^11 c^12) (id^14 p^15))
//│ def c = (fun a⁰ -> case a⁰ of {
//│ 	C i⁰ => (c^6 i⁰)})
//│ def id = (fun x⁰ -> x⁰)
//│ def p = [C p^3]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: type error C('p) <: '16_callres => '17_callres
//│ !!!!!!ERROR!!!!!!

// WRONG:
// NOTE: but the result is correct
// but the multiple matches are concerning
fun map(ls) = if ls is
  C(hh, tt) then C(
    (if hh is
      A then B
      AA then BB
    ),
    map(tt)
  )
  N then N
fun rev(lss) = if lss is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
map(rev(C(A, C(AA, N)))(N))
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|hh|,| |tt|)| |#then| |C|(|→|(|#if| |hh| |is|→|A| |#then| |B|↵|AA| |#then| |BB|←|↵|)|,|↵|map|(|tt|)|←|↵|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|lss|)| |#=| |#if| |lss| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|map|(|rev|(|C|(|A|,| |C|(|AA|,| |N|)|)|)|(|N|)|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (hh, tt,)) then C ('(' if hh is ‹(A) then B; (AA) then BB›, ')', map (tt,),); (N) then N›; fun rev = lss, => if lss is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; map (rev (C (A, C (AA, N,),),) (N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^26 ((rev^27 [C [A] [C [AA] [N]]]) [N]))
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C hh⁰ tt⁰ => [C case hh⁰ of {
//│ 		A => [B]
//│ 		| AA => [BB]} (map^6 tt⁰)]
//│ 	| N => [N]})
//│ def rev = (fun lss⁰ -> case lss⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> ((rev^14 t⁰) [C h⁰ a⁰]))
//│ 	| N => (fun a¹ -> a¹)})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [map^26] (hopeless to continue)
//│ 	[map^26 · map^6] ---> [map^26] (using original def)
//│ [rev^27] (hopeless to continue)
//│ 	[rev^27 · rev^14] ---> [rev^27] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀ ((rev₀ [C [A] [C [AA] [N]]]) [N]))
//│ def map₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C hh¹ tt¹ => [C case hh¹ of {
//│ 			A => [B]
//│ 			| AA => [BB]} (map₀ tt¹)]
//│ 		| N => [N]})
//│ def rev₀ = 
//│ 	(fun lss¹ -> case lss¹ of {
//│ 		C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²]))
//│ 		| N => (fun a³ -> a³)})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [AA]: 65 --->
//│ 	case hh¹ of {A => [B] | AA => [BB]}: 41
//│ [A]: 64 --->
//│ 	case hh¹ of {A => [B] | AA => [BB]}: 41
//│ [C [AA] [N]]: 67 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 60
//│ [C [A] [C [AA] [N]]]: 68 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 60
//│ [C h¹ a²]: 55 --->
//│ 	case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A => [B] | AA => [BB]} (map₀ tt¹)] | N => [N]}: 47
//│ [N]: 66 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 60
//│ [N]: 70 --->
//│ 	case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A => [B] | AA => [BB]} (map₀ tt¹)] | N => [N]}: 47
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a²]: 55 --->
//│ 	case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A => [B] | AA => [BB]} (map₀ tt¹)] | N => [N]}: 47
//│ [A]: 64 --->
//│ 	case hh¹ of {A => [B] | AA => [BB]}: 41
//│ [AA]: 65 --->
//│ 	case hh¹ of {A => [B] | AA => [BB]}: 41
//│ [N]: 66 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 60
//│ [C [AA] [N]]: 67 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 60
//│ [C [A] [C [AA] [N]]]: 68 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 60
//│ [N]: 70 --->
//│ 	case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A => [B] | AA => [BB]} (map₀ tt¹)] | N => [N]}: 47
//│ ------------------
//│ case hh¹ of {A => [B] | AA => [BB]}: 41 --->
//│ 	[A]: 64
//│ 	[AA]: 65
//│ case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A => [B] | AA => [BB]} (map₀ tt¹)] | N => [N]}: 47 --->
//│ 	[C h¹ a²]: 55
//│ 	[N]: 70
//│ case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N => (fun a³ -> a³)}: 60 --->
//│ 	[N]: 66
//│ 	[C [AA] [N]]: 67
//│ 	[C [A] [C [AA] [N]]]: 68
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀ ((rev₀ 
//│ 	let h² = [B]
//│ 	in let t² = 	
//│ 		let h³ = [BB]
//│ 		in let t³ = (fun a⁶ -> a⁶)
//│ 		in (fun a⁵ -> ((rev₀ t³) 
//│ 			let hh³ = h³
//│ 			in let tt³ = a⁵
//│ 			in [C hh³ (map₀ tt³)]))
//│ 	in (fun a⁴ -> ((rev₀ t²) 
//│ 		let hh² = h²
//│ 		in let tt² = a⁴
//│ 		in [C hh² (map₀ tt²)]))) [N]))
//│ def map₀ = 
//│ 	(fun ls² -> ls²)
//│ def rev₀ = 
//│ 	(fun lss² -> lss²)
//│ <<<<<<< after fusion <<<<<<<

// WRONG: recursive fusion strategies
_LUMBERHACK_ERROR
let p = Pair(A, B)
fun c(x) = if x is
  Pair(a, b) then c(Pair(b, a))
c(p)
//│ |_LUMBERHACK_ERROR|↵|#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {_LUMBERHACK_ERROR; let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^12 p^13)
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	Pair a⁰ b⁰ => (c^5 [Pair b⁰ a⁰])})
//│ def p = [Pair [A] [B]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^12]
//│ 	[c^12 · c^5]
//│ 		[c^12 · c^5 · c^5] ---> [c^12] (only one)
//│ [p^13] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (c₀ p₀)
//│ def c₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		Pair a¹ b¹ => (c₁ [Pair b¹ a¹])})
//│ 	where
//│ 	def c₁ = 
//│ 		(fun x² -> case x² of {
//│ 			Pair a² b² => (c₀ [Pair b² a²])})
//│ def p₀ = 
//│ 	[Pair [A] [B]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Pair [A] [B]]: 33 --->
//│ 	case x¹ of {Pair a¹ b¹ => (c₁ [Pair b¹ a¹])}: 21
//│ [Pair b¹ a¹]: 19 --->
//│ 	case x² of {Pair a² b² => (c₀ [Pair b² a²])}: 29
//│ [Pair b² a²]: 27 --->
//│ 	case x¹ of {Pair a¹ b¹ => (c₁ [Pair b¹ a¹])}: 21
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Pair b¹ a¹]: 19 --->
//│ 	case x² of {Pair a² b² => (c₀ [Pair b² a²])}: 29
//│ [Pair b² a²]: 27 --->
//│ 	case x¹ of {Pair a¹ b¹ => (c₁ [Pair b¹ a¹])}: 21
//│ [Pair [A] [B]]: 33 --->
//│ 	case x¹ of {Pair a¹ b¹ => (c₁ [Pair b¹ a¹])}: 21
//│ ------------------
//│ case x¹ of {Pair a¹ b¹ => (c₁ [Pair b¹ a¹])}: 21 --->
//│ 	[Pair b² a²]: 27
//│ 	[Pair [A] [B]]: 33
//│ case x² of {Pair a² b² => (c₀ [Pair b² a²])}: 29 --->
//│ 	[Pair b¹ a¹]: 19
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ !!!!!!ERROR!!!!!!
//│ java.lang.StackOverflowError
//│ !!!!!!ERROR!!!!!!

// WRONG: it returns something like: C(1, C(9, C(2, ys => ys)))
// despite the fact that there is no clash at all
_LUMBERHACK_EVAL
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
inter(C(1, C(2, N)))(C(9, N))
//│ |_LUMBERHACK_EVAL|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|inter|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|C|(|9|,| |N|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; inter (C (1, C (2, N,),),) (C (9, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter^14 [C 1 [C 2 [N]]]) [C 9 [N]])
//│ def inter = (fun xs⁰ -> case xs⁰ of {
//│ 	N => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ ((inter^5 ys¹) t⁰)])})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^14]
//│ 	[inter^14 · inter^5] ---> [inter^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((inter₀ [C 1 [C 2 [N]]]) [C 9 [N]])
//│ def inter₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		N => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]]: 43 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 36
//│ [C 2 [N]]: 42 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 36
//│ [C 9 [N]]: 47 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 36
//│ [N]: 41 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 36
//│ [N]: 46 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((inter₀ [C 1 [C 2 [N]]]) [C 9 [N]])
//│ def inter₀ = 
//│ 	(fun xs² -> case xs² of {
//│ 		N => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ ((inter₀ ys⁵) t¹)])})
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 9 [C 2 [N]]]]
//│ <<<<<<< evaluate <<<<<<<


// WRONG:
_LUMBERHACK_ERROR
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
fun typeCheck(ls) = if ls is
  C(a, b) then typeCheck(b)
  N then OK
typeCheck(inter(C(1, C(2, N)))(C(9, N)))
//│ |_LUMBERHACK_ERROR|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#fun| |typeCheck|(|ls|)| |#=| |#if| |ls| |is|→|C|(|a|,| |b|)| |#then| |typeCheck|(|b|)|↵|N| |#then| |OK|←|↵|typeCheck|(|inter|(|C|(|1|,| |C|(|2|,| |N|)|)|)|(|C|(|9|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; fun typeCheck = ls, => if ls is ‹(C (a, b,)) then typeCheck (b,); (N) then OK›; typeCheck (inter (C (1, C (2, N,),),) (C (9, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (typeCheck^21 ((inter^22 [C 1 [C 2 [N]]]) [C 9 [N]]))
//│ def inter = (fun xs⁰ -> case xs⁰ of {
//│ 	N => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ ((inter^5 ys¹) t⁰)])})
//│ def typeCheck = (fun ls⁰ -> case ls⁰ of {
//│ 	C a⁰ b⁰ => (typeCheck^15 b⁰)
//│ 	| N => [OK]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^22]
//│ 	[inter^22 · inter^5]
//│ 		[inter^22 · inter^5 · inter^5] ---> [inter^22] (only one)
//│ [typeCheck^21] (hopeless to continue)
//│ 	[typeCheck^21 · typeCheck^15] ---> [typeCheck^21] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (typeCheck₀ ((inter₀ [C 1 [C 2 [N]]]) [C 9 [N]]))
//│ def inter₀ = 
//│ 	(fun xs² -> case xs² of {
//│ 		N => (fun ys⁴ -> ys⁴)
//│ 		| C h² t² => (fun ys⁵ -> [C h² ((inter₁ ys⁵) t²)])})
//│ 	where
//│ 	def inter₁ = 
//│ 		(fun xs¹ -> case xs¹ of {
//│ 			N => (fun ys² -> ys²)
//│ 			| C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])})
//│ def typeCheck₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C a¹ b¹ => (typeCheck₀ b¹)
//│ 		| N => [OK]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]]: 73 --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h² t² => (fun ys⁵ -> [C h² ((inter₁ ys⁵) t²)])}: 65
//│ [C 2 [N]]: 72 --->
//│ 	case ls¹ of {C a¹ b¹ => (typeCheck₀ b¹) | N => [OK]}: 39
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h² t² => (fun ys⁵ -> [C h² ((inter₁ ys⁵) t²)])}: 65
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C 9 [N]]: 77 --->
//│ 	case ls¹ of {C a¹ b¹ => (typeCheck₀ b¹) | N => [OK]}: 39
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 52
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C h¹ ((inter₀ ys³) t¹)]: 50 --->
//│ 	case ls¹ of {C a¹ b¹ => (typeCheck₀ b¹) | N => [OK]}: 39
//│ [C h² ((inter₁ ys⁵) t²)]: 63 --->
//│ 	case ls¹ of {C a¹ b¹ => (typeCheck₀ b¹) | N => [OK]}: 39
//│ [N]: 71 --->
//│ 	case ls¹ of {C a¹ b¹ => (typeCheck₀ b¹) | N => [OK]}: 39
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h² t² => (fun ys⁵ -> [C h² ((inter₁ ys⁵) t²)])}: 65
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N]: 76 --->
//│ 	case ls¹ of {C a¹ b¹ => (typeCheck₀ b¹) | N => [OK]}: 39
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 52
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (typeCheck₀ ((inter₀ [C 1 [C 2 [N]]]) [C 9 [N]]))
//│ def inter₀ = 
//│ 	(fun xs⁴ -> case xs⁴ of {
//│ 		N => (fun ys⁸ -> ys⁸)
//│ 		| C h² t² => (fun ys⁹ -> [C h² ((inter₁ ys⁹) t²)])})
//│ 	where
//│ 	def inter₁ = 
//│ 		(fun xs³ -> case xs³ of {
//│ 			N => (fun ys⁶ -> ys⁶)
//│ 			| C h¹ t¹ => (fun ys⁷ -> [C h¹ ((inter₀ ys⁷) t¹)])})
//│ def typeCheck₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C a¹ b¹ => (typeCheck₀ b¹)
//│ 		| N => [OK]})
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!

:ns
// TODO:
_LUMBERHACK_ERROR
fun idxSum(ls) = if ls is
  N then acc => 0
  C(h, t) then acc => acc + idxSum(t)(acc + 1)
fun rev(lss) = if lss is
  N then a => a
  C(hh, tt) then a => rev(tt)(C(hh, a))
idxSum(rev(primitive, N))(0)
//│ |_LUMBERHACK_ERROR|↵|#fun| |idxSum|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc| |=>| |0|↵|C|(|h|,| |t|)| |#then| |acc| |=>| |acc| |+| |idxSum|(|t|)|(|acc| |+| |1|)|←|↵|#fun| |rev|(|lss|)| |#=| |#if| |lss| |is|→|N| |#then| |a| |=>| |a|↵|C|(|hh|,| |tt|)| |#then| |a| |=>| |rev|(|tt|)|(|C|(|hh|,| |a|)|)|←|↵|idxSum|(|rev|(|primitive|,| |N|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun idxSum = ls, => if ls is ‹(N) then acc, => 0; (C (h, t,)) then acc, => + (acc,) (idxSum (t,) (+ (acc,) (1,),),)›; fun rev = lss, => if lss is ‹(N) then a, => a; (C (hh, tt,)) then a, => rev (tt,) (C (hh, a,),)›; idxSum (rev (primitive, N,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((idxSum^33 ((rev^34 primitive⁰) [N])) 0)
//│ def idxSum = (fun ls⁰ -> case ls⁰ of {
//│ 	N => (fun acc⁰ -> 0)
//│ 	| C h⁰ t⁰ => (fun acc¹ -> (acc¹ + ((idxSum^7 t⁰) (acc¹ + 1))))})
//│ def rev = (fun lss⁰ -> case lss⁰ of {
//│ 	N => (fun a⁰ -> a⁰)
//│ 	| C hh⁰ tt⁰ => (fun a¹ -> ((rev^23 tt⁰) [C hh⁰ a¹]))})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [idxSum^33] (hopeless to continue)
//│ 	[idxSum^33 · idxSum^7] ---> [idxSum^33] (using original def)
//│ [rev^34] (hopeless to continue)
//│ 	[rev^34 · rev^23] ---> [rev^34] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((idxSum₀ ((rev₀ primitive⁰) [N])) 0)
//│ def idxSum₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		N => (fun acc² -> 0)
//│ 		| C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₀ t¹) (acc³ + 1))))})
//│ def rev₀ = 
//│ 	(fun lss¹ -> case lss¹ of {
//│ 		N => (fun a² -> a²)
//│ 		| C hh¹ tt¹ => (fun a³ -> ((rev₀ tt¹) [C hh¹ a³]))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ a³]: 50 --->
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₀ t¹) (acc³ + 1))))}: 72
//│ [N]: 78 --->
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₀ t¹) (acc³ + 1))))}: 72
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C hh¹ a³]: 50 --->
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₀ t¹) (acc³ + 1))))}: 72
//│ [N]: 78 --->
//│ 	case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₀ t¹) (acc³ + 1))))}: 72
//│ ------------------
//│ case ls¹ of {N => (fun acc² -> 0) | C h¹ t¹ => (fun acc³ -> (acc³ + ((idxSum₀ t¹) (acc³ + 1))))}: 72 --->
//│ 	[C hh¹ a³]: 50
//│ 	[N]: 78
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((idxSum₀ ((rev₀ primitive⁰) (fun acc⁴ -> 0))) 0)
//│ def idxSum₀ = 
//│ 	(fun ls² -> ls²)
//│ def rev₀ = 
//│ 	(fun lss² -> case lss² of {
//│ 		N => (fun a⁴ -> a⁴)
//│ 		| C hh¹ tt¹ => (fun a⁵ -> ((rev₀ tt¹) 
//│ 			let h² = hh¹
//│ 			in let t² = a⁵
//│ 			in (fun acc⁵ -> (acc⁵ + ((idxSum₀ t²) (acc⁵ + 1))))))})
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!


// WRONG: type
_LUMBERHACK_ERROR
fun id(x) = if x is
  ID(b) then b
  _ then id(ID(x))
let p = C(p)
fun c(y) = if y is
  C(aa) then c(aa)
c(id(p))
//│ |_LUMBERHACK_ERROR|↵|#fun| |id|(|x|)| |#=| |#if| |x| |is|→|ID|(|b|)| |#then| |b|↵|_| |#then| |id|(|ID|(|x|)|)|←|↵|#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|y|)| |#=| |#if| |y| |is|→|C|(|aa|)| |#then| |c|(|aa|)|←|↵|c|(|id|(|p|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun id = x, => if x is ‹(ID (b,)) then b; (_) then id (ID (x,),)›; let p = C (p,); fun c = y, => if y is ‹(C (aa,)) then c (aa,)›; c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^17 (id^18 p^19))
//│ def c = (fun y⁰ -> case y⁰ of {
//│ 	C aa⁰ => (c^12 aa⁰)})
//│ def id = (fun x⁰ -> case x⁰ of {
//│ 	ID b⁰ => b⁰
//│ 	| _ => (id^3 [ID x⁰])})
//│ def p = [C p^9]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: Internal Error: type error ID('x⁰) <: Destruct(C('aa⁰))
//│ !!!!!!ERROR!!!!!!



// WRONG:
_LUMBERHACK_ERROR
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
fun l1(x) = C(1, C(2, l1(add(x, 1))))
let rec l2 = C(9, C(8, l2))
inter(l1(0))(l2)
//│ |_LUMBERHACK_ERROR|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#fun| |l1|(|x|)| |#=| |C|(|1|,| |C|(|2|,| |l1|(|add|(|x|,| |1|)|)|)|)|↵|#let| |#rec| |l2| |#=| |C|(|9|,| |C|(|8|,| |l2|)|)|↵|inter|(|l1|(|0|)|)|(|l2|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; fun l1 = x, => C (1, C (2, l1 (add (x, 1,),),),); let rec l2 = C (9, C (8, l2,),); inter (l1 (0,),) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter^31 (l1^32 0)) l2^36)
//│ def inter = (fun xs⁰ -> case xs⁰ of {
//│ 	N => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ ((inter^5 ys¹) t⁰)])})
//│ def l1 = (fun x⁰ -> [C 1 [C 2 (l1^16 ((add⁰ x⁰) 1))]])
//│ def l2 = [C 9 [C 8 l2^28]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^31]
//│ 	[inter^31 · inter^5] ---> [inter^31] (only one)
//│ [l1^32]
//│ 	[l1^32 · l1^16] ---> [l1^32] (only one)
//│ [l2^36]
//│ 	[l2^36 · l2^28] ---> [l2^36] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((inter₀ (l1₀ 0)) l2₀)
//│ def inter₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		N => (fun ys² -> ys²)
//│ 		| C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])})
//│ def l1₀ = 
//│ 	(fun x¹ -> [C 1 [C 2 (l1₀ ((add⁰ x¹) 1))]])
//│ def l2₀ = 
//│ 	[C 9 [C 8 l2₀]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 (l1₀ ((add⁰ x¹) 1))]]: 66 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 54
//│ [C 2 (l1₀ ((add⁰ x¹) 1))]: 65 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 54
//│ [C 8 l2₀]: 41 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 54
//│ [C 9 [C 8 l2₀]]: 42 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₀ ys³) t¹)])}: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((inter₀ (l1₀ 0)) l2₀)
//│ def inter₀ = 
//│ 	(fun xs² -> case xs² of {
//│ 		N => (fun ys⁴ -> ys⁴)
//│ 		| C h¹ t¹ => (fun ys⁵ -> [C h¹ ((inter₀ ys⁵) t¹)])})
//│ def l1₀ = 
//│ 	(fun x² -> [C 1 [C 2 (l1₀ ((add⁰ x²) 1))]])
//│ def l2₀ = 
//│ 	[C 9 [C 8 l2₀]]
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!


// WRONG: explosion on branch and recursive strategies, and timeout
// NOTE: need return pattern specilization for recursive strategies
// _LUMBERHACK_ERROR
// fun filterMax(ls) = if ls is
//   C(h, t) then m => if h > 0 is
//     True then if h > m is
//       True then if filterMax(t)(h) is
//         Pair(ys, max) then Pair(C(h, ys), max)
//       False then if filterMax(t)(m) is
//         Pair(ys, max) then Pair(C(h, ys), max)
//     False then filterMax(t)(m)
//   N then m => Pair(N, m)
// filterMax(C(1, C(2, N)))(0)


 
// WRONG: explode on branch
// _LUMBERHACK_ERROR
// fun max(ms) = if ms is
//   C(h, t) then m => if h > m is
//    True then max(t)(h)
//    False then max(t)(m)
//   N then m => m
// max(C(1, C(3, C(2, N))))(0)
//│ | |↵|/* WRONG: explode on branch*/|↵|/* _LUMBERHACK_ERROR*/|↵|/* fun max(ms) = if ms is*/|↵|/*   C(h, t) then m => if h > m is*/|↵|/*    True then max(t)(h)*/|↵|/*    False then max(t)(m)*/|↵|/*   N then m => m*/|↵|/* max(C(1, C(3, C(2, N))))(0)*/|
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ 
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ 
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ 
//│ 
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 
//│ <<<<<<< after fusion <<<<<<<

// WRONG: multiple match
_LUMBERHACK_ERROR
fun last(ls) = if ls is
  C(h, t) then if t is
    N then Some(h)
    C(hh, tt) then last(t)
  N then None
last(C(1, C(2, C(3, N))))
//│ |_LUMBERHACK_ERROR|↵|#fun| |last|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|N| |#then| |Some|(|h|)|↵|C|(|hh|,| |tt|)| |#then| |last|(|t|)|←|↵|N| |#then| |None|←|↵|last|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |N|)|)|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun last = ls, => if ls is ‹(C (h, t,)) then if t is ‹(N) then Some (h,); (C (hh, tt,)) then last (t,)›; (N) then None›; last (C (1, C (2, C (3, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (last^12 [C 1 [C 2 [C 3 [N]]]])
//│ def last = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => case t⁰ of {
//│ 		N => [Some h⁰]
//│ 		| C hh⁰ tt⁰ => (last^5 t⁰)}
//│ 	| N => [None]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^12]
//│ 	[last^12 · last^5] ---> [last^12] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (last₀ [C 1 [C 2 [C 3 [N]]]])
//│ def last₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => case t¹ of {
//│ 			N => [Some h¹]
//│ 			| C hh¹ tt¹ => (last₀ t¹)}
//│ 		| N => [None]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [C 3 [N]]]]: 39 --->
//│ 	case ls¹ of {C h¹ t¹ => case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₀ t¹)} | N => [None]}: 30
//│ [C 2 [C 3 [N]]]: 38 --->
//│ 	case ls¹ of {C h¹ t¹ => case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₀ t¹)} | N => [None]}: 30
//│ 	case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₀ t¹)}: 28
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C 3 [N]]: 37 --->
//│ 	case ls¹ of {C h¹ t¹ => case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₀ t¹)} | N => [None]}: 30
//│ 	case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₀ t¹)}: 28
//│ 	 MORE THAN ONE MATCH EXPR
//│ [N]: 36 --->
//│ 	case ls¹ of {C h¹ t¹ => case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₀ t¹)} | N => [None]}: 30
//│ 	case t¹ of {N => [Some h¹] | C hh¹ tt¹ => (last₀ t¹)}: 28
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (last₀ [C 1 [C 2 [C 3 [N]]]])
//│ def last₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h¹ t¹ => case t¹ of {
//│ 			N => [Some h¹]
//│ 			| C hh¹ tt¹ => (last₀ t¹)}
//│ 		| N => [None]})
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!


// WRONG: recursive strategy
_LUMBERHACK_ERROR
fun concat(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, concat(t, ys))
fun rev(ls) = if ls is
  C(h, t) then concat(rev(t), C(h, N))
  N then N
rev(primitive)
//│ |_LUMBERHACK_ERROR|↵|#fun| |concat|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |concat|(|t|,| |ys|)|)|←|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |concat|(|rev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|rev|(|primitive|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun concat = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, concat (t, ys,),)›; fun rev = ls, => if ls is ‹(C (h, t,)) then concat (rev (t,), C (h, N,),); (N) then N›; rev (primitive,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (rev^27 primitive⁰)
//│ def concat = (fun xs⁰ -> case xs⁰ of {
//│ 	N => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ ((concat^5 t⁰) ys¹)])})
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	C h¹ t¹ => ((concat^15 (rev^16 t¹)) [C h¹ [N]])
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^27] (hopeless to continue)
//│ 	[rev^27 · concat^15] (using original def)
//│ 		[rev^27 · concat^15 · concat^5] ---> [rev^27 · concat^15] (using original def)
//│ 	[rev^27 · rev^16] ---> [rev^27] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (rev₀ primitive⁰)
//│ def rev₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]])
//│ 		| N => [N]})
//│ 	where
//│ 	def concat₀ = 
//│ 		(fun xs¹ -> case xs¹ of {
//│ 			N => (fun ys² -> ys²)
//│ 			| C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h² ((concat₀ t²) ys³)]: 39 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])}: 41
//│ [C h³ [N]]: 51 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])}: 41
//│ [N]: 50 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])}: 41
//│ [N]: 53 --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h² t² => (fun ys³ -> [C h² ((concat₀ t²) ys³)])}: 41
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (rev₀ primitive⁰)
//│ def rev₀ = 
//│ 	(fun ls² -> case ls² of {
//│ 		C h³ t³ => ((concat₀ (rev₀ t³)) [C h³ [N]])
//│ 		| N => [N]})
//│ 	where
//│ 	def concat₀ = 
//│ 		(fun xs² -> case xs² of {
//│ 			N => (fun ys⁴ -> ys⁴)
//│ 			| C h² t² => (fun ys⁵ -> [C h² ((concat₀ t²) ys⁵)])})
//│ <<<<<<< after fusion <<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ java.lang.Exception: expect to fail but pass
//│ !!!!!!ERROR!!!!!!
