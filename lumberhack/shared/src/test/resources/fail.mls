:NewParser
:ParseOnly

// FIXME: wrong output: recursive calls should not only replace the identifier,
// but also the strategy (on more than one use scenarios)
// at this example the `recursive` map stores the actual type (which should have the concrete exprid), so
// to fix the rewrite for this example should be simple ------ but what about if the producer is not concrete,
// but another type variable?
let t = T(K, T(N, L, L), T(N, L, L))
fun c(x) = if x is
    T(n, l, r) then T(
        (if n is
            K then KK
            N then NN
        ),
        c(l),
        c(r)
    )
    L then LL
c(t)
//│ |#let| |t| |#=| |T|(|K|,| |T|(|N|,| |L|,| |L|)|,| |T|(|N|,| |L|,| |L|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let t = T (K, T (N, L, L,), T (N, L, L,),); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def t:1 = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ def c:2 = fun x:3 -> case x:3 of {T n:4 l:5 r:6 -> [T case n:4 of {K -> [KK] | N -> [NN]} (c:2 l:5) (c:2 r:6)] | L -> [LL]}
//│ (c:2 t:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((t:1^27 ⋅ ɛ, L()), (c:2^26 ⋅ c:2^16 ⋅ c:2^19 ⋅ ɛ, 2'x)) :::: ((t:1^27 ⋅ ɛ, L()), (c:2^26 ⋅ c:2^16 ⋅ c:2^16 ⋅ ɛ, 2'x))
//│ ((t:1^27 ⋅ ɛ, T((ɛ, N()), (ɛ, L()), (ɛ, L()))), (c:2^26 ⋅ c:2^19 ⋅ ɛ, 2'x)) :::: ((t:1^27 ⋅ ɛ, T((ɛ, N()), (ɛ, L()), (ɛ, L()))), (c:2^26 ⋅ c:2^16 ⋅ ɛ, 2'x))
//│ ------- defInstance -------
//│ t:1^27 ⋅ ɛ ==> c:2^26 ⋅ c:2^16 ⋅ c:2^16 ⋅ ɛ:
//│ 	3: [L]  <-->  24: case x:3 of {T n:4 l:5 r:6 -> [T case n:4 of {K -> [KK] | N -> [NN]} (c:2 l:5) (c:2 r:6)] | L -> [LL]}
//│ t:1^27 ⋅ ɛ ==> c:2^26 ⋅ c:2^16 ⋅ ɛ:
//│ 	2: [N]  <-->  15: case n:4 of {K -> [KK] | N -> [NN]}
//│ 	5: [T [N] [L] [L]]  <-->  24: case x:3 of {T n:4 l:5 r:6 -> [T case n:4 of {K -> [KK] | N -> [NN]} (c:2 l:5) (c:2 r:6)] | L -> [LL]}
//│ t:1^27 ⋅ ɛ ==> c:2^26 ⋅ ɛ:
//│ 	10: [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]  <-->  24: case x:3 of {T n:4 l:5 r:6 -> [T case n:4 of {K -> [KK] | N -> [NN]} (c:2 l:5) (c:2 r:6)] | L -> [LL]}
//│ 	1: [K]  <-->  15: case n:4 of {K -> [KK] | N -> [NN]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def t:1 = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ def c:2 = fun x:3 -> case x:3 of {T n:4 l:5 r:6 -> [T case n:4 of {K -> [KK] | N -> [NN]} (c:2 l:5) (c:2 r:6)] | L -> [LL]}
//│ def c'2'26:7 = fun x:3 -> x:3
//│ def c'2'26_c'2'16:9 = fun x:3 -> x:3
//│ def c'2'26_c'2'16_c'2'16:10 = fun x:3 -> x:3
//│ def t'1'27:8 = 
//│ 	let n:4 = [KK] in 
//│ 	let l:5 = 
//│ 		let n:4 = [NN] in 
//│ 		let l:5 = [LL] in 
//│ 		let r:6 = [L] in [T n:4 (c'2'26_c'2'16_c'2'16:10 l:5) (c'2'26_c'2'16_c'2'16:10 r:6)] 
//│ 	in 
//│ 	let r:6 = [T [N] [L] [L]] in [T n:4 (c'2'26_c'2'16:9 l:5) (c'2'26_c'2'16:9 r:6)]
//│ (c'2'26:7 t'1'27:8)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


// similar as above
let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
    T(n, l, r) then T(
        (if n is
            K then KK
            N then NN
        ),
        c(l),
        c(r)
    )
    L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def aa:1 = [T [N] [L] [L]]
//│ def bb:2 = [T [N] [L] [L]]
//│ def t:3 = [T [K] aa:1 bb:2]
//│ def c:4 = fun x:5 -> case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ (c:4 t:3)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((t:3^29 ⋅ aa:1^10 ⋅ ɛ, T((ɛ, N()), (ɛ, L()), (ɛ, L()))), (c:4^28 ⋅ c:4^18 ⋅ ɛ, 4'x)) :::: ((t:3^29 ⋅ bb:2^11 ⋅ ɛ, T((ɛ, N()), (ɛ, L()), (ɛ, L()))), (c:4^28 ⋅ c:4^21 ⋅ ɛ, 4'x))
//│ ((t:3^29 ⋅ bb:2^11 ⋅ ɛ, L()), (c:4^28 ⋅ c:4^21 ⋅ c:4^21 ⋅ ɛ, 4'x)) :::: ((t:3^29 ⋅ bb:2^11 ⋅ ɛ, L()), (c:4^28 ⋅ c:4^21 ⋅ c:4^18 ⋅ ɛ, 4'x))
//│ ------- defInstance -------
//│ t:3^29 ⋅ ɛ ==> c:4^28 ⋅ ɛ:
//│ 	12: [T [K] aa:1 bb:2]  <-->  26: case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ 	9: [K]  <-->  17: case n:6 of {K -> [KK] | N -> [NN]}
//│ t:3^29 ⋅ bb:2^11 ⋅ ɛ ==> c:4^28 ⋅ c:4^21 ⋅ c:4^18 ⋅ ɛ:
//│ 	6: [L]  <-->  26: case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ t:3^29 ⋅ bb:2^11 ⋅ ɛ ==> c:4^28 ⋅ c:4^21 ⋅ ɛ:
//│ 	5: [N]  <-->  17: case n:6 of {K -> [KK] | N -> [NN]}
//│ 	8: [T [N] [L] [L]]  <-->  26: case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def aa:1 = [T [N] [L] [L]]
//│ def bb:2 = [T [N] [L] [L]]
//│ def t:3 = [T [K] aa:1 bb:2]
//│ def c:4 = fun x:5 -> case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ def c'4'28_c'4'21_c'4'18:13 = fun x:5 -> x:5
//│ def c'4'28:9 = fun x:5 -> x:5
//│ def t'3'29:10 = 
//│ 	let n:6 = [KK] in 
//│ 	let l:7 = t'3'29_bb'2'11:12 in 
//│ 	let r:8 = t'3'29_bb'2'11:12 in [T n:6 (c'4'28_c'4'21:11 l:7) (c'4'28_c'4'21:11 r:8)]
//│ def c'4'28_c'4'21:11 = fun x:5 -> x:5
//│ def t'3'29_bb'2'11:12 = 
//│ 	let n:6 = [NN] in 
//│ 	let l:7 = [LL] in 
//│ 	let r:8 = [L] in [T n:6 (c'4'28_c'4'21_c'4'18:13 l:7) (c'4'28_c'4'21_c'4'18:13 r:8)]
//│ (c'4'28:9 t'3'29:10)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<





let p = C(p)
fun c(x) = if C(x) is
    C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = [C p:1]
//│ def c:2 = fun x:3 -> case [C x:3] of {C a:4 -> (c:2 a:4)}
//│ (c:2 p:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((p:1^11 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (c:2^10 ⋅ c:2^5 ⋅ ɛ, 2'x)) :::: ((p:1^11 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (c:2^10 ⋅ ɛ, 2'x))
//│ ------- defInstance -------
//│ ɛ ==> ɛ:
//│ 	4: [C x:3]  <-->  8: case [C x:3] of {C a:4 -> (c:2 a:4)}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C p:1]
//│ def c:2 = fun x:3 -> case [C x:3] of {C a:4 -> (c:2 a:4)}
//│ def p'1'11:6 = [C p'1'11_p'1'1:7]
//│ def p'1'11_p'1'1:7 = [C p'1'11_p'1'1_p'1'1:8]
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:14 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:15]
//│ def p'1'11_p'1'1_p'1'1_p'1'1:9 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1:10]
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:11 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:12]
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1:10 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:11]
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:13 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:14]
//│ def p'1'11_p'1'1_p'1'1:8 = [C p'1'11_p'1'1_p'1'1_p'1'1:9]
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:17 = "RECURSE_TOO_LONG"
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:12 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:13]
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:15 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:16]
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:16 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:17]
//│ def c'2'10:5 = fun x:3 -> case [C x:3] of {C a:4 -> (c'2'10:5 a:4)}
//│ (c'2'10:5 p'1'11:6)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


// NOTE: push in problem
fun map(f, ls) = if ls is
    C(h, t) then C(f(h), map(f, t))
    N then N
let l = C(K, l)
fun ff(x) = if x is
    K then T
map(ff, l)
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |l|)|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|←|↵|map|(|ff|,| |l|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; let l = C (K, l,); fun ff = x, => if x is ‹(K) then T›; map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def map:1 = fun f:4 -> fun ls:5 -> case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ def l:2 = [C [K] l:2]
//│ def ff:3 = fun x:8 -> case x:8 of {K -> [T]}
//│ ((map:1 ff:3) l:2)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((l:2^25 ⋅ l:2^16 ⋅ ɛ, C((ɛ, K()), (l:2^16 ⋅ ɛ, 1'l))), (map:1^22 ⋅ map:1^5 ⋅ ɛ, 4'ls)) :::: ((l:2^25 ⋅ ɛ, C((ɛ, K()), (l:2^16 ⋅ ɛ, 1'l))), (map:1^22 ⋅ ɛ, 4'ls))
//│ ((ff:3^23 ⋅ ɛ, (ɛ, 11'x) => ((ɛ, 12'20_matchres))), (map:1^22 ⋅ map:1^5 ⋅ ɛ, 3'f)) :::: ((ff:3^23 ⋅ ɛ, (ɛ, 11'x) => ((ɛ, 12'20_matchres))), (map:1^22 ⋅ ɛ, 3'f))
//│ ------- defInstance -------
//│ l:2^25 ⋅ ɛ ==> ff:3^23 ⋅ ɛ:
//│ 	15: [K]  <-->  20: case x:8 of {K -> [T]}
//│ l:2^25 ⋅ ɛ ==> map:1^22 ⋅ ɛ:
//│ 	17: [C [K] l:2]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def map:1 = fun f:4 -> fun ls:5 -> case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ def l:2 = [C [K] l:2]
//│ def ff:3 = fun x:8 -> case x:8 of {K -> [T]}
//│ def map'1'22:9 = fun f:4 -> fun ls:5 -> ls:5
//│ def l'2'25:11 = 
//│ 	let h:6 = [T] in 
//│ 	let t:7 = l'2'25:11 in [C (f:4 h:6) ((map'1'22:9 f:4) t:7)]
//│ def ff'3'23:10 = fun x:8 -> x:8
//│ ((map'1'22:9 ff'3'23:10) l'2'25:11)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<

// NOTE: only first head is handled
fun map(f, ls) = if ls is
    C(h, t) then C(f(h), map(f, t))
    N then N
fun ff(x) = if x is
    K then T
    KK then TT
    KKKK then TTTT
let l = C(K, C(KK, C(KKKK, N)))
map(ff, l)
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|ff|,| |l|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; let l = C (K, C (KK, C (KKKK, N,),),); map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def map:1 = fun f:4 -> fun ls:5 -> case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ def ff:2 = fun x:8 -> case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ def l:3 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ ((map:1 ff:2) l:3)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((ff:2^29 ⋅ ɛ, (ɛ, 11'x) => ((ɛ, 12'19_matchres))), (map:1^28 ⋅ map:1^5 ⋅ ɛ, 3'f)) :::: ((ff:2^29 ⋅ ɛ, (ɛ, 11'x) => ((ɛ, 12'19_matchres))), (map:1^28 ⋅ ɛ, 3'f))
//│ ------- defInstance -------
//│ l:3^31 ⋅ ɛ ==> ff:2^29 ⋅ ɛ:
//│ 	21: [K]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ map:1^28 ⋅ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ map:1^5 ⋅ ff:2^29 ⋅ ɛ:
//│ 	23: [KKKK]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ ɛ:
//│ 	27: [C [K] [C [KK] [C [KKKK] [N]]]]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ map:1^5 ⋅ ɛ:
//│ 	25: [C [KKKK] [N]]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ map:1^28 ⋅ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ ff:2^29 ⋅ ɛ:
//│ 	22: [KK]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ map:1^5 ⋅ map:1^5 ⋅ ɛ:
//│ 	24: [N]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ ɛ:
//│ 	26: [C [KK] [C [KKKK] [N]]]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def map:1 = fun f:4 -> fun ls:5 -> case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ def ff:2 = fun x:8 -> case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ def l:3 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def ff'2'29:10 = fun x:8 -> x:8
//│ def map'1'28_map'1'5_map'1'5:12 = fun f:4 -> fun ls:5 -> ls:5
//│ def map'1'28_map'1'5_map'1'5_map'1'5:13 = fun f:4 -> fun ls:5 -> ls:5
//│ def l'3'31:11 = 
//│ 	let h:6 = [T] in 
//│ 	let t:7 = 
//│ 		let h:6 = [KK] in 
//│ 		let t:7 = 
//│ 			let h:6 = [KKKK] in 
//│ 			let t:7 = [N] in [C (f:4 h:6) ((map'1'28_map'1'5_map'1'5_map'1'5:13 f:4) t:7)] 
//│ 		in [C (f:4 h:6) ((map'1'28_map'1'5_map'1'5:12 f:4) t:7)] 
//│ 	in [C (f:4 h:6) ((map'1'28:9 f:4) t:7)]
//│ def map'1'28:9 = fun f:4 -> fun ls:5 -> ls:5
//│ ((map'1'28:9 ff'2'29:10) l'3'31:11)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


fun rev(l1, l2) = if l1 is
    C(h, t) then rev(t, C(h, l2))
    N then l2
fun rev1(l11, l22) = if l11 is
    C(h1, t1) then rev1(t1, C(h1, l22))
    N then l22
let p = C(K, N)
rev(rev1(p, N), N)
//│ |#fun| |rev|(|l1|,| |l2|)| |#=| |#if| |l1| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |l2|)|)|↵|N| |#then| |l2|←|↵|#fun| |rev1|(|l11|,| |l22|)| |#=| |#if| |l11| |is|→|C|(|h1|,| |t1|)| |#then| |rev1|(|t1|,| |C|(|h1|,| |l22|)|)|↵|N| |#then| |l22|←|↵|#let| |p| |#=| |C|(|K|,| |N|)|↵|rev|(|rev1|(|p|,| |N|)|,| |N|)|
//│ Parsed: {fun rev = l1, l2, => if l1 is ‹(C (h, t,)) then rev (t, C (h, l2,),); (N) then l2›; fun rev1 = l11, l22, => if l11 is ‹(C (h1, t1,)) then rev1 (t1, C (h1, l22,),); (N) then l22›; let p = C (K, N,); rev (rev1 (p, N,), N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def rev:1 = fun l1:4 -> fun l2:5 -> case l1:4 of {C h:6 t:7 -> ((rev:1 t:7) [C h:6 l2:5]) | N -> l2:5}
//│ def rev1:2 = fun l11:8 -> fun l22:9 -> case l11:8 of {C h1:10 t1:11 -> ((rev1:2 t1:11) [C h1:10 l22:9]) | N -> l22:9}
//│ def p:3 = [C [K] [N]]
//│ ((rev:1 ((rev1:2 p:3) [N])) [N])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ (
//│   (rev1:2^29 ⋅ ɛ, C((ɛ, 12'h1), (ɛ, 11'l22))),
//│   (rev1:2^14 ⋅ rev1:2^14 ⋅ rev:1^28 ⋅ rev:1^2 ⋅ ɛ, 3'l1)
//│ ) :::: ((rev1:2^29 ⋅ ɛ, C((ɛ, 12'h1), (ɛ, 11'l22))), (rev1:2^14 ⋅ rev:1^28 ⋅ ɛ, 3'l1))
//│ ((ɛ, C((ɛ, 12'h1), (ɛ, 11'l22))), (ɛ, 16'22_matchres)) :::: ((ɛ, C((ɛ, 12'h1), (ɛ, 11'l22))), (rev1:2^14 ⋅ ɛ, 16'22_matchres))
//│ ((rev1:2^14 ⋅ ɛ, N()), (rev1:2^29 ⋅ ɛ, 16'22_matchres)) :::: ((ɛ, N()), (rev1:2^29 ⋅ ɛ, 16'22_matchres))
//│ ((ɛ, N()), (rev1:2^14 ⋅ rev:1^28 ⋅ rev:1^2 ⋅ ɛ, 3'l1)) :::: ((ɛ, N()), (rev:1^28 ⋅ ɛ, 3'l1))
//│ ((rev:1^2 ⋅ ɛ, N()), (rev:1^28 ⋅ ɛ, 9'10_matchres)) :::: ((ɛ, N()), (rev:1^28 ⋅ ɛ, 9'10_matchres))
//│ ((ɛ, C((ɛ, 5'h), (ɛ, 4'l2))), (ɛ, 9'10_matchres)) :::: ((ɛ, C((ɛ, 5'h), (ɛ, 4'l2))), (rev:1^2 ⋅ ɛ, 9'10_matchres))
//│ ------- defInstance -------
//│ ɛ ==> rev:1^28 ⋅ ɛ:
//│ 	32: [N]  <-->  10: case l1:4 of {C h:6 t:7 -> ((rev:1 t:7) [C h:6 l2:5]) | N -> l2:5}
//│ p:3^30 ⋅ ɛ ==> rev1:2^29 ⋅ ɛ:
//│ 	27: [C [K] [N]]  <-->  22: case l11:8 of {C h1:10 t1:11 -> ((rev1:2 t1:11) [C h1:10 l22:9]) | N -> l22:9}
//│ rev1:2^29 ⋅ ɛ ==> rev1:2^14 ⋅ rev:1^28 ⋅ ɛ:
//│ 	19: [C h1:10 l22:9]  <-->  10: case l1:4 of {C h:6 t:7 -> ((rev:1 t:7) [C h:6 l2:5]) | N -> l2:5}
//│ p:3^30 ⋅ ɛ ==> rev1:2^29 ⋅ rev1:2^14 ⋅ ɛ:
//│ 	26: [N]  <-->  22: case l11:8 of {C h1:10 t1:11 -> ((rev1:2 t1:11) [C h1:10 l22:9]) | N -> l22:9}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def rev:1 = fun l1:4 -> fun l2:5 -> case l1:4 of {C h:6 t:7 -> ((rev:1 t:7) [C h:6 l2:5]) | N -> l2:5}
//│ def rev1:2 = fun l11:8 -> fun l22:9 -> case l11:8 of {C h1:10 t1:11 -> ((rev1:2 t1:11) [C h1:10 l22:9]) | N -> l22:9}
//│ def p:3 = [C [K] [N]]
//│ def rev1'2'29:13 = fun l11:8 -> fun l22:9 -> l11:8
//│ def rev1'2'29_rev1'2'14:15 = fun l11:8 -> fun l22:9 -> l11:8
//│ def p'3'30:14 = 
//│ 	let h1:10 = [K] in 
//│ 	let t1:11 = l22:9 in ((rev1'2'29_rev1'2'14:15 t1:11) 
//│ 	let h:6 = h1:10 in 
//│ 	let t:7 = l22:9 in ((rev'1'28:12 t:7) [C h:6 l2:5]))
//│ def rev'1'28:12 = fun l1:4 -> fun l2:5 -> l1:4
//│ ((rev'1'28:12 ((rev1'2'29:13 p'3'30:14) l2:5)) [N])
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


let p = C(C(C(id2(p))))
fun c(x) = if x is
    C(a) then if a is
        C(a) then c(a)
fun id2(yy) = yy
fun id(y) = id2(y)
c(id(p))
//│ |#let| |p| |#=| |C|(|C|(|C|(|id2|(|p|)|)|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|a|)| |#then| |c|(|a|)|←|←|↵|#fun| |id2|(|yy|)| |#=| |yy|↵|#fun| |id|(|y|)| |#=| |id2|(|y|)|↵|c|(|id|(|p|)|)|
//│ Parsed: {let p = C (C (C (id2 (p,),),),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (a,)) then c (a,)››; fun id2 = yy, => yy; fun id = y, => id2 (y,); c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = [C [C [C (id2:3 p:1)]]]
//│ def c:2 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c:2 a:7)}}
//│ def id2:3 = fun yy:8 -> yy:8
//│ def id:4 = fun y:9 -> (id2:3 y:9)
//│ (c:2 (id:4 p:1))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ (
//│   (p:1^23 ⋅ id2:3^1 ⋅ p:1^23 ⋅ id2:3^1 ⋅ p:1^23 ⋅ ɛ, C((ɛ, C((ɛ, C((ɛ, 4'3_callres))))))),
//│   (id:4^22 ⋅ id2:3^17 ⋅ id:4^22 ⋅ id2:3^17 ⋅ c:2^21 ⋅ c:2^9 ⋅ c:2^9 ⋅ c:2^9 ⋅ ɛ, 5'x)
//│ ) :::: ((p:1^23 ⋅ ɛ, C((ɛ, C((ɛ, C((ɛ, 4'3_callres))))))), (c:2^21 ⋅ ɛ, 5'x))
//│ ((p:1^2 ⋅ ɛ, C((ɛ, C((ɛ, C((ɛ, 4'3_callres))))))), (id2:3^1 ⋅ ɛ, 11'yy)) :::: ((p:1^23 ⋅ ɛ, C((ɛ, C((ɛ, C((ɛ, 4'3_callres))))))), (id:4^22 ⋅ id2:3^17 ⋅ ɛ, 11'yy))
//│ ------- defInstance -------
//│ p:1^23 ⋅ ɛ ==> c:2^21 ⋅ ɛ:
//│ 	5: [C [C (id2:3 p:1)]]  <-->  12: case a:6 of {C a:7 -> (c:2 a:7)}
//│ 	6: [C [C [C (id2:3 p:1)]]]  <-->  13: case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c:2 a:7)}}
//│ p:1^23 ⋅ id2:3^1 ⋅ p:1^23 ⋅ ɛ ==> id:4^22 ⋅ id2:3^17 ⋅ c:2^21 ⋅ c:2^9 ⋅ c:2^9 ⋅ ɛ:
//│ 	4: [C (id2:3 p:1)]  <-->  12: case a:6 of {C a:7 -> (c:2 a:7)}
//│ 	5: [C [C (id2:3 p:1)]]  <-->  13: case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c:2 a:7)}}
//│ p:1^23 ⋅ id2:3^1 ⋅ p:1^23 ⋅ ɛ ==> id:4^22 ⋅ id2:3^17 ⋅ c:2^21 ⋅ c:2^9 ⋅ ɛ:
//│ 	6: [C [C [C (id2:3 p:1)]]]  <-->  12: case a:6 of {C a:7 -> (c:2 a:7)}
//│ p:1^23 ⋅ ɛ ==> c:2^21 ⋅ c:2^9 ⋅ ɛ:
//│ 	4: [C (id2:3 p:1)]  <-->  13: case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c:2 a:7)}}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C [C [C (id2:3 p:1)]]]
//│ def c:2 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c:2 a:7)}}
//│ def id2:3 = fun yy:8 -> yy:8
//│ def id:4 = fun y:9 -> (id2:3 y:9)
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:43 = fun yy:8 -> yy:8
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:35 = fun yy:8 -> yy:8
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9:17 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:18 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:46 = "RECURSE_TOO_LONG"
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:20 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:21 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:40 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:41 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:42)]]]
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:23 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:24 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:42 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:43 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:44)]]]
//│ def p'1'23_p'1'2_id2'3'1:27 = fun yy:8 -> yy:8
//│ def p'1'23_p'1'2_p'1'2_id2'3'1:29 = fun yy:8 -> yy:8
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:21 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:22 a:7)}}
//│ def c'2'21_c'2'9_c'2'9_c'2'9:16 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9:17 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:36 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:37 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:38)]]]
//│ def p'1'23_p'1'2_p'1'2_p'1'2_id2'3'1:31 = fun yy:8 -> yy:8
//│ def p'1'23_p'1'2_p'1'2:28 = [C [C [C (p'1'23_p'1'2_p'1'2_id2'3'1:29 p'1'23_p'1'2_p'1'2_p'1'2:30)]]]
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:44 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:45 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:46)]]]
//│ def c'2'21:10 = fun x:5 -> x:5
//│ def p'1'23_id2'3'1:25 = fun yy:8 -> yy:8
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:45 = fun yy:8 -> yy:8
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:34 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:35 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:36)]]]
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:22 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:23 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2:32 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:33 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:34)]]]
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:41 = fun yy:8 -> yy:8
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:38 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:39 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:40)]]]
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:19 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:20 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:33 = fun yy:8 -> yy:8
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:18 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:19 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:37 = fun yy:8 -> yy:8
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:39 = fun yy:8 -> yy:8
//│ def p'1'23:13 = 
//│ 	let a:6 = 
//│ 		let a:7 = 
//│ 			let a:6 = (p'1'23_id2'3'1:25 p'1'23_p'1'2:26) in case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9:15 a:7)} 
//│ 		in (c'2'21_c'2'9:14 a:7) 
//│ 	in a:6
//│ def p'1'23_p'1'2:26 = [C [C [C (p'1'23_p'1'2_id2'3'1:27 p'1'23_p'1'2_p'1'2:28)]]]
//│ def c'2'21_c'2'9_c'2'9:15 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9:16 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2:30 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_id2'3'1:31 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2:32)]]]
//│ def id'4'22:11 = fun y:9 -> (id'4'22_id2'3'17:12 y:9)
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:24 = "RECURSE_TOO_LONG"
//│ def id'4'22_id2'3'17:12 = fun yy:8 -> yy:8
//│ def c'2'21_c'2'9:14 = fun x:5 -> x:5
//│ (c'2'21:10 (id'4'22:11 p'1'23:13))
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


