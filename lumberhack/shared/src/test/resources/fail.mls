:NewParser
:ParseOnly

// FIXME: wrong output: recursive calls should not only replace the identifier,
// but also the strategy (on more than one use scenarios)
// at this example the `recursive` map stores the actual type (which should have the concrete exprid), so
// to fix the rewrite for this example should be simple ------ but what about if the producer is not concrete,
// but another type variable?
let t = T(K, T(N, L, L), T(N, L, L))
fun c(x) = if x is
    T(n, l, r) then T(
        (if n is
            K then KK
            N then NN
        ),
        c(l),
        c(r)
    )
    L then LL
c(t)
//│ |#let| |t| |#=| |T|(|K|,| |T|(|N|,| |L|,| |L|)|,| |T|(|N|,| |L|,| |L|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let t = T (K, T (N, L, L,), T (N, L, L,),); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def t:1 = 10: [T 1: [K] 5: [T 2: [N] 3: [L] 4: [L]] 9: [T 6: [N] 7: [L] 8: [L]]]
//│ def c:2 = 25: fun x:3 -> 24: case 11: x:3 of {T n:4 l:5 r:6 -> 22: [T 15: case 12: n:4 of {K -> 13: [KK] | N -> 14: [NN]} 18: (16: c:2 17: l:5) 21: (19: c:2 20: r:6)] | L -> 23: [LL]}
//│ 28: (26: c:2 27: t:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((t:1^27 ⋅ ɛ, L()), (c:2^26 ⋅ c:2^16 ⋅ c:2^19 ⋅ ɛ, 2'x)) :::: ((t:1^27 ⋅ ɛ, L()), (c:2^26 ⋅ c:2^16 ⋅ c:2^16 ⋅ ɛ, 2'x))
//│ ((t:1^27 ⋅ ɛ, T((ɛ, N()), (ɛ, L()), (ɛ, L()))), (c:2^26 ⋅ c:2^19 ⋅ ɛ, 2'x)) :::: ((t:1^27 ⋅ ɛ, T((ɛ, N()), (ɛ, L()), (ɛ, L()))), (c:2^26 ⋅ c:2^16 ⋅ ɛ, 2'x))
//│ ------- defInstance -------
//│ t:1^27 ⋅ ɛ ==> c:2^26 ⋅ c:2^16 ⋅ c:2^16 ⋅ ɛ:
//│ 	3: [L]  <-->  24: case x:3 of {T n:4 l:5 r:6 -> [T case n:4 of {K -> [KK] | N -> [NN]} (c:2 l:5) (c:2 r:6)] | L -> [LL]}
//│ t:1^27 ⋅ ɛ ==> c:2^26 ⋅ c:2^16 ⋅ ɛ:
//│ 	2: [N]  <-->  15: case n:4 of {K -> [KK] | N -> [NN]}
//│ 	5: [T [N] [L] [L]]  <-->  24: case x:3 of {T n:4 l:5 r:6 -> [T case n:4 of {K -> [KK] | N -> [NN]} (c:2 l:5) (c:2 r:6)] | L -> [LL]}
//│ t:1^27 ⋅ ɛ ==> c:2^26 ⋅ ɛ:
//│ 	10: [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]  <-->  24: case x:3 of {T n:4 l:5 r:6 -> [T case n:4 of {K -> [KK] | N -> [NN]} (c:2 l:5) (c:2 r:6)] | L -> [LL]}
//│ 	1: [K]  <-->  15: case n:4 of {K -> [KK] | N -> [NN]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def t:1 = [T [K] [T [N] [L] [L]] [T [N] [L] [L]]]
//│ def c:2 = fun x:3 -> case x:3 of {T n:4 l:5 r:6 -> [T case n:4 of {K -> [KK] | N -> [NN]} (c:2 l:5) (c:2 r:6)] | L -> [LL]}
//│ def c'2'26:7 = fun x:3 -> x:3
//│ def c'2'26_c'2'16:9 = fun x:3 -> x:3
//│ def c'2'26_c'2'16_c'2'16:10 = fun x:3 -> x:3
//│ def t'1'27:8 = 
//│ 	let n:4 = [KK] in 
//│ 	let l:5 = 
//│ 		let n:4 = [NN] in 
//│ 		let l:5 = [LL] in 
//│ 		let r:6 = [L] in [T n:4 (c'2'26_c'2'16_c'2'16:10 l:5) (c'2'26_c'2'16_c'2'16:10 r:6)] 
//│ 	in 
//│ 	let r:6 = [T [N] [L] [L]] in [T n:4 (c'2'26_c'2'16:9 l:5) (c'2'26_c'2'16:9 r:6)]
//│ (c'2'26:7 t'1'27:8)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


// similar as above
let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
    T(n, l, r) then T(
        (if n is
            K then KK
            N then NN
        ),
        c(l),
        c(r)
    )
    L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def aa:1 = 4: [T 1: [N] 2: [L] 3: [L]]
//│ def bb:2 = 8: [T 5: [N] 6: [L] 7: [L]]
//│ def t:3 = 12: [T 9: [K] 10: aa:1 11: bb:2]
//│ def c:4 = 27: fun x:5 -> 26: case 13: x:5 of {T n:6 l:7 r:8 -> 24: [T 17: case 14: n:6 of {K -> 15: [KK] | N -> 16: [NN]} 20: (18: c:4 19: l:7) 23: (21: c:4 22: r:8)] | L -> 25: [LL]}
//│ 30: (28: c:4 29: t:3)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((t:3^29 ⋅ aa:1^10 ⋅ ɛ, T((ɛ, N()), (ɛ, L()), (ɛ, L()))), (c:4^28 ⋅ c:4^18 ⋅ ɛ, 4'x)) :::: ((t:3^29 ⋅ bb:2^11 ⋅ ɛ, T((ɛ, N()), (ɛ, L()), (ɛ, L()))), (c:4^28 ⋅ c:4^21 ⋅ ɛ, 4'x))
//│ ((t:3^29 ⋅ bb:2^11 ⋅ ɛ, L()), (c:4^28 ⋅ c:4^21 ⋅ c:4^21 ⋅ ɛ, 4'x)) :::: ((t:3^29 ⋅ bb:2^11 ⋅ ɛ, L()), (c:4^28 ⋅ c:4^21 ⋅ c:4^18 ⋅ ɛ, 4'x))
//│ ------- defInstance -------
//│ t:3^29 ⋅ ɛ ==> c:4^28 ⋅ ɛ:
//│ 	12: [T [K] aa:1 bb:2]  <-->  26: case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ 	9: [K]  <-->  17: case n:6 of {K -> [KK] | N -> [NN]}
//│ t:3^29 ⋅ bb:2^11 ⋅ ɛ ==> c:4^28 ⋅ c:4^21 ⋅ c:4^18 ⋅ ɛ:
//│ 	6: [L]  <-->  26: case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ t:3^29 ⋅ bb:2^11 ⋅ ɛ ==> c:4^28 ⋅ c:4^21 ⋅ ɛ:
//│ 	5: [N]  <-->  17: case n:6 of {K -> [KK] | N -> [NN]}
//│ 	8: [T [N] [L] [L]]  <-->  26: case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def aa:1 = [T [N] [L] [L]]
//│ def bb:2 = [T [N] [L] [L]]
//│ def t:3 = [T [K] aa:1 bb:2]
//│ def c:4 = fun x:5 -> case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ def c'4'28_c'4'21_c'4'18:13 = fun x:5 -> x:5
//│ def c'4'28:9 = fun x:5 -> x:5
//│ def t'3'29:10 = 
//│ 	let n:6 = [KK] in 
//│ 	let l:7 = t'3'29_bb'2'11:12 in 
//│ 	let r:8 = t'3'29_bb'2'11:12 in [T n:6 (c'4'28_c'4'21:11 l:7) (c'4'28_c'4'21:11 r:8)]
//│ def c'4'28_c'4'21:11 = fun x:5 -> x:5
//│ def t'3'29_bb'2'11:12 = 
//│ 	let n:6 = [NN] in 
//│ 	let l:7 = [LL] in 
//│ 	let r:8 = [L] in [T n:6 (c'4'28_c'4'21_c'4'18:13 l:7) (c'4'28_c'4'21_c'4'18:13 r:8)]
//│ (c'4'28:9 t'3'29:10)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<



// the `p · p` is never touched (checked) by the typer, so no path leads to it, and no recusive map from it
let p = C(p)
fun c(x) = if C(x) is
    C(a) then c(a)
c(p)
//│ |#let| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |C|(|x|)| |is|→|C|(|a|)| |#then| |c|(|a|)|←|↵|c|(|p|)|
//│ Parsed: {let p = C (p,); fun c = x, => if C (x,) is ‹(C (a,)) then c (a,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 2: [C 1: p:1]
//│ def c:2 = 9: fun x:3 -> 8: case 4: [C 3: x:3] of {C a:4 -> 7: (5: c:2 6: a:4)}
//│ 12: (10: c:2 11: p:1)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((p:1^11 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (c:2^10 ⋅ c:2^5 ⋅ ɛ, 2'x)) :::: ((p:1^11 ⋅ ɛ, C((p:1^1 ⋅ ɛ, 0'p))), (c:2^10 ⋅ ɛ, 2'x))
//│ ------- defInstance -------
//│ ɛ ==> ɛ:
//│ 	4: [C x:3]  <-->  8: case [C x:3] of {C a:4 -> (c:2 a:4)}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C p:1]
//│ def c:2 = fun x:3 -> case [C x:3] of {C a:4 -> (c:2 a:4)}
//│ def p'1'11:7 = [C p'1'11_p'1'1:8]
//│ def p'1'11_p'1'1:8 = [C p'1'11_p'1'1_p'1'1:9]
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:15 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:16]
//│ def p'1'11_p'1'1_p'1'1_p'1'1:10 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1:11]
//│ def c'2'5:6 = fun x:3 -> 
//│ 	let a:4 = x:3 in (c'2'5:6 a:4)
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:12 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:13]
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1:11 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:12]
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:14 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:15]
//│ def p'1'11_p'1'1_p'1'1:9 = [C p'1'11_p'1'1_p'1'1_p'1'1:10]
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:18 = "RECURSE_TOO_LONG"
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:13 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:14]
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:16 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:17]
//│ def p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:17 = [C p'1'11_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:18]
//│ def c'2'10:5 = fun x:3 -> 
//│ 	let a:4 = x:3 in (c'2'5:6 a:4)
//│ (c'2'10:5 p'1'11:7)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<

// the `p · p` is never touched (checked) by the typer, so no path leads to it, and no recusive map from it
let rec p = C(p)
fun c(x) = if x is
    C(a) then a
fun main(y) = c(p)
main(0)
//│ |#let| |#rec| |p| |#=| |C|(|p|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |a|←|↵|#fun| |main|(|y|)| |#=| |c|(|p|)|↵|main|(|0|)|
//│ Parsed: {let rec p = C (p,); fun c = x, => if x is ‹(C (a,)) then a›; fun main = y, => c (p,); main (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 2: [C 1: p:1]
//│ def c:2 = 6: fun x:4 -> 5: case 3: x:4 of {C a:5 -> 4: a:5}
//│ def main:3 = 10: fun y:6 -> 9: (7: c:2 8: p:1)
//│ 13: (11: main:3 12: 0)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ------- defInstance -------
//│ p:1^8 ⋅ ɛ ==> c:2^7 ⋅ ɛ:
//│ 	2: [C p:1]  <-->  5: case x:4 of {C a:5 -> a:5}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C p:1]
//│ def c:2 = fun x:4 -> case x:4 of {C a:5 -> a:5}
//│ def main:3 = fun y:6 -> (c:2 p:1)
//│ def main'3'11_c'2'7:8 = fun x:4 -> x:4
//│ def main'3'11_p'1'8_p'1'1_p'1'1:11 = [C main'3'11_p'1'8_p'1'1_p'1'1_p'1'1:12]
//│ def main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:16 = [C main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:17]
//│ def main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1:13 = [C main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:14]
//│ def main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:20 = "RECURSE_TOO_LONG"
//│ def main'3'11_p'1'8_p'1'1:10 = [C main'3'11_p'1'8_p'1'1_p'1'1:11]
//│ def main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:18 = [C main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:19]
//│ def main'3'11_p'1'8:9 = 
//│ 	let a:5 = main'3'11_p'1'8_p'1'1:10 in a:5
//│ def main'3'11:7 = fun y:6 -> (main'3'11_c'2'7:8 main'3'11_p'1'8:9)
//│ def main'3'11_p'1'8_p'1'1_p'1'1_p'1'1:12 = [C main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1:13]
//│ def main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:15 = [C main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:16]
//│ def main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:17 = [C main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:18]
//│ def main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:19 = [C main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:20]
//│ def main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:14 = [C main'3'11_p'1'8_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1_p'1'1:15]
//│ (main'3'11:7 0)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<



// NOTE: push in problem
fun map(f, ls) = if ls is
    C(h, t) then C(f(h), map(f, t))
    N then N
let l = C(K, l)
fun ff(x) = if x is
    K then T
map(ff, l)
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |l|)|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|←|↵|map|(|ff|,| |l|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; let l = C (K, l,); fun ff = x, => if x is ‹(K) then T›; map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def map:1 = 14: fun f:4 -> 13: fun ls:5 -> 12: case 1: ls:5 of {C h:6 t:7 -> 10: [C 4: (2: f:4 3: h:6) 9: (7: (5: map:1 6: f:4) 8: t:7)] | N -> 11: [N]}
//│ def l:2 = 17: [C 15: [K] 16: l:2]
//│ def ff:3 = 21: fun x:8 -> 20: case 18: x:8 of {K -> 19: [T]}
//│ 26: (24: (22: map:1 23: ff:3) 25: l:2)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((l:2^25 ⋅ l:2^16 ⋅ ɛ, C((ɛ, K()), (l:2^16 ⋅ ɛ, 1'l))), (map:1^22 ⋅ map:1^5 ⋅ ɛ, 4'ls)) :::: ((l:2^25 ⋅ ɛ, C((ɛ, K()), (l:2^16 ⋅ ɛ, 1'l))), (map:1^22 ⋅ ɛ, 4'ls))
//│ ((ff:3^23 ⋅ ɛ, (ɛ, 11'x) => ((ɛ, 12'20_matchres))), (map:1^22 ⋅ map:1^5 ⋅ ɛ, 3'f)) :::: ((ff:3^23 ⋅ ɛ, (ɛ, 11'x) => ((ɛ, 12'20_matchres))), (map:1^22 ⋅ ɛ, 3'f))
//│ ------- defInstance -------
//│ l:2^25 ⋅ ɛ ==> ff:3^23 ⋅ ɛ:
//│ 	15: [K]  <-->  20: case x:8 of {K -> [T]}
//│ l:2^25 ⋅ ɛ ==> map:1^22 ⋅ ɛ:
//│ 	17: [C [K] l:2]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def map:1 = fun f:4 -> fun ls:5 -> case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ def l:2 = [C [K] l:2]
//│ def ff:3 = fun x:8 -> case x:8 of {K -> [T]}
//│ def map'1'22:9 = fun f:4 -> fun ls:5 -> ls:5
//│ def l'2'25:11 = 
//│ 	let h:6 = [T] in 
//│ 	let t:7 = l'2'25:11 in [C (f:4 h:6) ((map'1'22:9 f:4) t:7)]
//│ def ff'3'23:10 = fun x:8 -> x:8
//│ ((map'1'22:9 ff'3'23:10) l'2'25:11)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<

// NOTE: only first head is handled
fun map(f, ls) = if ls is
    C(h, t) then C(f(h), map(f, t))
    N then N
fun ff(x) = if x is
    K then T
    KK then TT
    KKKK then TTTT
let l = C(K, C(KK, C(KKKK, N)))
map(ff, l)
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|ff|,| |l|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun ff = x, => if x is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›; let l = C (K, C (KK, C (KKKK, N,),),); map (ff, l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def map:1 = 14: fun f:4 -> 13: fun ls:5 -> 12: case 1: ls:5 of {C h:6 t:7 -> 10: [C 4: (2: f:4 3: h:6) 9: (7: (5: map:1 6: f:4) 8: t:7)] | N -> 11: [N]}
//│ def ff:2 = 20: fun x:8 -> 19: case 15: x:8 of {K -> 16: [T] | KK -> 17: [TT] | KKKK -> 18: [TTTT]}
//│ def l:3 = 27: [C 21: [K] 26: [C 22: [KK] 25: [C 23: [KKKK] 24: [N]]]]
//│ 32: (30: (28: map:1 29: ff:2) 31: l:3)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((ff:2^29 ⋅ ɛ, (ɛ, 11'x) => ((ɛ, 12'19_matchres))), (map:1^28 ⋅ map:1^5 ⋅ ɛ, 3'f)) :::: ((ff:2^29 ⋅ ɛ, (ɛ, 11'x) => ((ɛ, 12'19_matchres))), (map:1^28 ⋅ ɛ, 3'f))
//│ ------- defInstance -------
//│ l:3^31 ⋅ ɛ ==> ff:2^29 ⋅ ɛ:
//│ 	21: [K]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ map:1^28 ⋅ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ map:1^5 ⋅ ff:2^29 ⋅ ɛ:
//│ 	23: [KKKK]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ ɛ:
//│ 	27: [C [K] [C [KK] [C [KKKK] [N]]]]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ map:1^5 ⋅ ɛ:
//│ 	25: [C [KKKK] [N]]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ map:1^28 ⋅ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ ff:2^29 ⋅ ɛ:
//│ 	22: [KK]  <-->  19: case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ map:1^5 ⋅ map:1^5 ⋅ ɛ:
//│ 	24: [N]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ l:3^31 ⋅ ɛ ==> map:1^28 ⋅ map:1^5 ⋅ ɛ:
//│ 	26: [C [KK] [C [KKKK] [N]]]  <-->  12: case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def map:1 = fun f:4 -> fun ls:5 -> case ls:5 of {C h:6 t:7 -> [C (f:4 h:6) ((map:1 f:4) t:7)] | N -> [N]}
//│ def ff:2 = fun x:8 -> case x:8 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ def l:3 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def ff'2'29:10 = fun x:8 -> x:8
//│ def map'1'28_map'1'5_map'1'5:12 = fun f:4 -> fun ls:5 -> ls:5
//│ def map'1'28_map'1'5_map'1'5_map'1'5:13 = fun f:4 -> fun ls:5 -> ls:5
//│ def l'3'31:11 = 
//│ 	let h:6 = [T] in 
//│ 	let t:7 = 
//│ 		let h:6 = [KK] in 
//│ 		let t:7 = 
//│ 			let h:6 = [KKKK] in 
//│ 			let t:7 = [N] in [C (f:4 h:6) ((map'1'28_map'1'5_map'1'5_map'1'5:13 f:4) t:7)] 
//│ 		in [C (f:4 h:6) ((map'1'28_map'1'5_map'1'5:12 f:4) t:7)] 
//│ 	in [C (f:4 h:6) ((map'1'28:9 f:4) t:7)]
//│ def map'1'28:9 = fun f:4 -> fun ls:5 -> ls:5
//│ ((map'1'28:9 ff'2'29:10) l'3'31:11)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


fun rev(l1, l2) = if l1 is
    C(h, t) then rev(t, C(h, l2))
    N then l2
fun rev1(l11, l22) = if l11 is
    C(h1, t1) then rev1(t1, C(h1, l22))
    N then l22
let p = C(K, N)
rev(rev1(p, N), N)
//│ |#fun| |rev|(|l1|,| |l2|)| |#=| |#if| |l1| |is|→|C|(|h|,| |t|)| |#then| |rev|(|t|,| |C|(|h|,| |l2|)|)|↵|N| |#then| |l2|←|↵|#fun| |rev1|(|l11|,| |l22|)| |#=| |#if| |l11| |is|→|C|(|h1|,| |t1|)| |#then| |rev1|(|t1|,| |C|(|h1|,| |l22|)|)|↵|N| |#then| |l22|←|↵|#let| |p| |#=| |C|(|K|,| |N|)|↵|rev|(|rev1|(|p|,| |N|)|,| |N|)|
//│ Parsed: {fun rev = l1, l2, => if l1 is ‹(C (h, t,)) then rev (t, C (h, l2,),); (N) then l2›; fun rev1 = l11, l22, => if l11 is ‹(C (h1, t1,)) then rev1 (t1, C (h1, l22,),); (N) then l22›; let p = C (K, N,); rev (rev1 (p, N,), N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def rev:1 = 12: fun l1:4 -> 11: fun l2:5 -> 10: case 1: l1:4 of {C h:6 t:7 -> 8: (4: (2: rev:1 3: t:7) 7: [C 5: h:6 6: l2:5]) | N -> 9: l2:5}
//│ def rev1:2 = 24: fun l11:8 -> 23: fun l22:9 -> 22: case 13: l11:8 of {C h1:10 t1:11 -> 20: (16: (14: rev1:2 15: t1:11) 19: [C 17: h1:10 18: l22:9]) | N -> 21: l22:9}
//│ def p:3 = 27: [C 25: [K] 26: [N]]
//│ 36: (34: (28: rev:1 33: (31: (29: rev1:2 30: p:3) 32: [N])) 35: [N])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ (
//│   (rev1:2^29 ⋅ ɛ, C((ɛ, 12'h1), (ɛ, 11'l22))),
//│   (rev1:2^14 ⋅ rev1:2^14 ⋅ rev:1^28 ⋅ rev:1^2 ⋅ ɛ, 3'l1)
//│ ) :::: ((rev1:2^29 ⋅ ɛ, C((ɛ, 12'h1), (ɛ, 11'l22))), (rev1:2^14 ⋅ rev:1^28 ⋅ ɛ, 3'l1))
//│ ((ɛ, C((ɛ, 12'h1), (ɛ, 11'l22))), (ɛ, 16'22_matchres)) :::: ((ɛ, C((ɛ, 12'h1), (ɛ, 11'l22))), (rev1:2^14 ⋅ ɛ, 16'22_matchres))
//│ ((rev1:2^14 ⋅ ɛ, N()), (rev1:2^29 ⋅ ɛ, 16'22_matchres)) :::: ((ɛ, N()), (rev1:2^29 ⋅ ɛ, 16'22_matchres))
//│ ((ɛ, N()), (rev1:2^14 ⋅ rev:1^28 ⋅ rev:1^2 ⋅ ɛ, 3'l1)) :::: ((ɛ, N()), (rev:1^28 ⋅ ɛ, 3'l1))
//│ ((rev:1^2 ⋅ ɛ, N()), (rev:1^28 ⋅ ɛ, 9'10_matchres)) :::: ((ɛ, N()), (rev:1^28 ⋅ ɛ, 9'10_matchres))
//│ ((ɛ, C((ɛ, 5'h), (ɛ, 4'l2))), (ɛ, 9'10_matchres)) :::: ((ɛ, C((ɛ, 5'h), (ɛ, 4'l2))), (rev:1^2 ⋅ ɛ, 9'10_matchres))
//│ ------- defInstance -------
//│ ɛ ==> rev:1^28 ⋅ ɛ:
//│ 	32: [N]  <-->  10: case l1:4 of {C h:6 t:7 -> ((rev:1 t:7) [C h:6 l2:5]) | N -> l2:5}
//│ p:3^30 ⋅ ɛ ==> rev1:2^29 ⋅ ɛ:
//│ 	27: [C [K] [N]]  <-->  22: case l11:8 of {C h1:10 t1:11 -> ((rev1:2 t1:11) [C h1:10 l22:9]) | N -> l22:9}
//│ rev1:2^29 ⋅ ɛ ==> rev1:2^14 ⋅ rev:1^28 ⋅ ɛ:
//│ 	19: [C h1:10 l22:9]  <-->  10: case l1:4 of {C h:6 t:7 -> ((rev:1 t:7) [C h:6 l2:5]) | N -> l2:5}
//│ p:3^30 ⋅ ɛ ==> rev1:2^29 ⋅ rev1:2^14 ⋅ ɛ:
//│ 	26: [N]  <-->  22: case l11:8 of {C h1:10 t1:11 -> ((rev1:2 t1:11) [C h1:10 l22:9]) | N -> l22:9}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def rev:1 = fun l1:4 -> fun l2:5 -> case l1:4 of {C h:6 t:7 -> ((rev:1 t:7) [C h:6 l2:5]) | N -> l2:5}
//│ def rev1:2 = fun l11:8 -> fun l22:9 -> case l11:8 of {C h1:10 t1:11 -> ((rev1:2 t1:11) [C h1:10 l22:9]) | N -> l22:9}
//│ def p:3 = [C [K] [N]]
//│ def rev1'2'29:13 = fun l11:8 -> fun l22:9 -> l11:8
//│ def rev1'2'29_rev1'2'14:15 = fun l11:8 -> fun l22:9 -> l11:8
//│ def p'3'30:14 = 
//│ 	let h1:10 = [K] in 
//│ 	let t1:11 = l22:9 in ((rev1'2'29_rev1'2'14:15 t1:11) 
//│ 	let h:6 = h1:10 in 
//│ 	let t:7 = l22:9 in ((rev'1'28:12 t:7) [C h:6 l2:5]))
//│ def rev'1'28:12 = fun l1:4 -> fun l2:5 -> l1:4
//│ ((rev'1'28:12 ((rev1'2'29:13 p'3'30:14) l2:5)) [N])
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


// `id2` used twice
let p = C(C(C(id2(p))))
fun c(x) = if x is
    C(a) then if a is
        C(a) then c(a)
fun id2(yy) = yy
fun id(y) = id2(y)
c(id(p))
//│ |#let| |p| |#=| |C|(|C|(|C|(|id2|(|p|)|)|)|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|C|(|a|)| |#then| |c|(|a|)|←|←|↵|#fun| |id2|(|yy|)| |#=| |yy|↵|#fun| |id|(|y|)| |#=| |id2|(|y|)|↵|c|(|id|(|p|)|)|
//│ Parsed: {let p = C (C (C (id2 (p,),),),); fun c = x, => if x is ‹(C (a,)) then if a is ‹(C (a,)) then c (a,)››; fun id2 = yy, => yy; fun id = y, => id2 (y,); c (id (p,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def p:1 = 6: [C 5: [C 4: [C 3: (1: id2:3 2: p:1)]]]
//│ def c:2 = 14: fun x:5 -> 13: case 7: x:5 of {C a:6 -> 12: case 8: a:6 of {C a:7 -> 11: (9: c:2 10: a:7)}}
//│ def id2:3 = 16: fun yy:8 -> 15: yy:8
//│ def id:4 = 20: fun y:9 -> 19: (17: id2:3 18: y:9)
//│ 25: (21: c:2 24: (22: id:4 23: p:1))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ (
//│   (p:1^23 ⋅ id2:3^1 ⋅ p:1^23 ⋅ id2:3^1 ⋅ p:1^23 ⋅ ɛ, C((ɛ, C((ɛ, C((ɛ, 4'3_callres))))))),
//│   (id:4^22 ⋅ id2:3^17 ⋅ id:4^22 ⋅ id2:3^17 ⋅ c:2^21 ⋅ c:2^9 ⋅ c:2^9 ⋅ c:2^9 ⋅ ɛ, 5'x)
//│ ) :::: ((p:1^23 ⋅ ɛ, C((ɛ, C((ɛ, C((ɛ, 4'3_callres))))))), (c:2^21 ⋅ ɛ, 5'x))
//│ ((p:1^2 ⋅ ɛ, C((ɛ, C((ɛ, C((ɛ, 4'3_callres))))))), (id2:3^1 ⋅ ɛ, 11'yy)) :::: ((p:1^23 ⋅ ɛ, C((ɛ, C((ɛ, C((ɛ, 4'3_callres))))))), (id:4^22 ⋅ id2:3^17 ⋅ ɛ, 11'yy))
//│ ------- defInstance -------
//│ p:1^23 ⋅ ɛ ==> c:2^21 ⋅ ɛ:
//│ 	5: [C [C (id2:3 p:1)]]  <-->  12: case a:6 of {C a:7 -> (c:2 a:7)}
//│ 	6: [C [C [C (id2:3 p:1)]]]  <-->  13: case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c:2 a:7)}}
//│ p:1^23 ⋅ id2:3^1 ⋅ p:1^23 ⋅ ɛ ==> id:4^22 ⋅ id2:3^17 ⋅ c:2^21 ⋅ c:2^9 ⋅ c:2^9 ⋅ ɛ:
//│ 	4: [C (id2:3 p:1)]  <-->  12: case a:6 of {C a:7 -> (c:2 a:7)}
//│ 	5: [C [C (id2:3 p:1)]]  <-->  13: case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c:2 a:7)}}
//│ p:1^23 ⋅ id2:3^1 ⋅ p:1^23 ⋅ ɛ ==> id:4^22 ⋅ id2:3^17 ⋅ c:2^21 ⋅ c:2^9 ⋅ ɛ:
//│ 	6: [C [C [C (id2:3 p:1)]]]  <-->  12: case a:6 of {C a:7 -> (c:2 a:7)}
//│ p:1^23 ⋅ ɛ ==> c:2^21 ⋅ c:2^9 ⋅ ɛ:
//│ 	4: [C (id2:3 p:1)]  <-->  13: case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c:2 a:7)}}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def p:1 = [C [C [C (id2:3 p:1)]]]
//│ def c:2 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c:2 a:7)}}
//│ def id2:3 = fun yy:8 -> yy:8
//│ def id:4 = fun y:9 -> (id2:3 y:9)
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:43 = fun yy:8 -> yy:8
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:35 = fun yy:8 -> yy:8
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9:17 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:18 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:46 = "RECURSE_TOO_LONG"
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:20 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:21 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:40 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:41 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:42)]]]
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:23 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:24 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:42 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:43 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:44)]]]
//│ def p'1'23_p'1'2_id2'3'1:27 = fun yy:8 -> yy:8
//│ def p'1'23_p'1'2_p'1'2_id2'3'1:29 = fun yy:8 -> yy:8
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:21 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:22 a:7)}}
//│ def c'2'21_c'2'9_c'2'9_c'2'9:16 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9:17 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:36 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:37 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:38)]]]
//│ def p'1'23_p'1'2_p'1'2_p'1'2_id2'3'1:31 = fun yy:8 -> yy:8
//│ def p'1'23_p'1'2_p'1'2:28 = [C [C [C (p'1'23_p'1'2_p'1'2_id2'3'1:29 p'1'23_p'1'2_p'1'2_p'1'2:30)]]]
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:44 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:45 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:46)]]]
//│ def c'2'21:10 = fun x:5 -> x:5
//│ def p'1'23_id2'3'1:25 = fun yy:8 -> yy:8
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:45 = fun yy:8 -> yy:8
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:34 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:35 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:36)]]]
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:22 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:23 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2:32 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:33 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:34)]]]
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:41 = fun yy:8 -> yy:8
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:38 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:39 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2:40)]]]
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:19 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:20 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:33 = fun yy:8 -> yy:8
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:18 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:19 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:37 = fun yy:8 -> yy:8
//│ def p'1'23_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_p'1'2_id2'3'1:39 = fun yy:8 -> yy:8
//│ def p'1'23:13 = 
//│ 	let a:6 = 
//│ 		let a:7 = 
//│ 			let a:6 = (p'1'23_id2'3'1:25 p'1'23_p'1'2:26) in case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9:15 a:7)} 
//│ 		in (c'2'21_c'2'9:14 a:7) 
//│ 	in a:6
//│ def p'1'23_p'1'2:26 = [C [C [C (p'1'23_p'1'2_id2'3'1:27 p'1'23_p'1'2_p'1'2:28)]]]
//│ def c'2'21_c'2'9_c'2'9:15 = fun x:5 -> case x:5 of {C a:6 -> case a:6 of {C a:7 -> (c'2'21_c'2'9_c'2'9_c'2'9:16 a:7)}}
//│ def p'1'23_p'1'2_p'1'2_p'1'2:30 = [C [C [C (p'1'23_p'1'2_p'1'2_p'1'2_id2'3'1:31 p'1'23_p'1'2_p'1'2_p'1'2_p'1'2:32)]]]
//│ def id'4'22:11 = fun y:9 -> (id'4'22_id2'3'17:12 y:9)
//│ def c'2'21_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9_c'2'9:24 = "RECURSE_TOO_LONG"
//│ def id'4'22_id2'3'17:12 = fun yy:8 -> yy:8
//│ def c'2'21_c'2'9:14 = fun x:5 -> x:5
//│ (c'2'21:10 (id'4'22:11 p'1'23:13))
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


// no polymorphism
_LUMBERHACK_ERROR
fun id(x) = x
let rec p1 = C(p1)
fun c1(a) = if a is
    C(i) then c1(i)
id(c1)(id(p1))
//│ |_LUMBERHACK_ERROR|↵|#fun| |id|(|x|)| |#=| |x|↵|#let| |#rec| |p1| |#=| |C|(|p1|)|↵|#fun| |c1|(|a|)| |#=| |#if| |a| |is|→|C|(|i|)| |#then| |c1|(|i|)|←|↵|id|(|c1|)|(|id|(|p1|)|)|
//│ Parsed: {_LUMBERHACK_ERROR; fun id = x, => x; let rec p1 = C (p1,); fun c1 = a, => if a is ‹(C (i,)) then c1 (i,)›; id (c1,) (id (p1,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def id:1 = 2: fun x:4 -> 1: x:4
//│ def p1:2 = 4: [C 3: p1:2]
//│ def c1:3 = 10: fun a:5 -> 9: case 5: a:5 of {C i:6 -> 8: (6: c1:3 7: i:6)}
//│ 17: (13: (11: id:1 12: c1:3) 16: (14: id:1 15: p1:2))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ !!!!!!ERROR!!!!!!
//│ type error
//│ !!!!!!ERROR!!!!!!


fun map(ls) = if ls is
    C(hh, tt) then C(
        (if hh is
            A then B
            AA then BB
        ),
        map(tt)
    )
    N then N
fun rev(a, lss) = if lss is
    C(h, t) then rev(C(h, a), t)
    N then a
// map(rev(N, C(A, C(AA, N))))
map(rev(N, primitive))
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|hh|,| |tt|)| |#then| |C|(|→|(|#if| |hh| |is|→|A| |#then| |B|↵|AA| |#then| |BB|←|↵|)|,|↵|map|(|tt|)|←|↵|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|a|,| |lss|)| |#=| |#if| |lss| |is|→|C|(|h|,| |t|)| |#then| |rev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|/* map(rev(N, C(A, C(AA, N))))*/|↵|map|(|rev|(|N|,| |primitive|)|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (hh, tt,)) then C ('(' if hh is ‹(A) then B; (AA) then BB›, ')', map (tt,),); (N) then N›; fun rev = a, lss, => if lss is ‹(C (h, t,)) then rev (C (h, a,), t,); (N) then a›; map (rev (N, primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def map:1 = 12: fun ls:3 -> 11: case 1: ls:3 of {C hh:4 tt:5 -> 9: [C 5: case 2: hh:4 of {A -> 3: [B] | AA -> 4: [BB]} 8: (6: map:1 7: tt:5)] | N -> 10: [N]}
//│ def rev:2 = 24: fun a:6 -> 23: fun lss:7 -> 22: case 13: lss:7 of {C h:8 t:9 -> 20: (18: (14: rev:2 17: [C 15: h:8 16: a:6]) 19: t:9) | N -> 21: a:6}
//│ 31: (25: map:1 30: (28: (26: rev:2 27: [N]) 29: primitive:0))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((rev:2^14 ⋅ ɛ, N()), (rev:2^26 ⋅ ɛ, 14'22_matchres)) :::: ((ɛ, N()), (rev:2^26 ⋅ ɛ, 14'22_matchres))
//│ ((ɛ, N()), (rev:2^14 ⋅ map:1^25 ⋅ map:1^6 ⋅ ɛ, 2'ls)) :::: ((ɛ, N()), (map:1^25 ⋅ ɛ, 2'ls))
//│ ((rev:2^26 ⋅ ɛ, C((ɛ, 10'h), (ɛ, 8'a))), (rev:2^14 ⋅ rev:2^14 ⋅ map:1^25 ⋅ map:1^6 ⋅ ɛ, 2'ls)) :::: ((rev:2^26 ⋅ ɛ, C((ɛ, 10'h), (ɛ, 8'a))), (rev:2^14 ⋅ map:1^25 ⋅ ɛ, 2'ls))
//│ ((ɛ, C((ɛ, 10'h), (ɛ, 8'a))), (ɛ, 14'22_matchres)) :::: ((ɛ, C((ɛ, 10'h), (ɛ, 8'a))), (rev:2^14 ⋅ ɛ, 14'22_matchres))
//│ ------- defInstance -------
//│ ɛ ==> map:1^25 ⋅ ɛ:
//│ 	27: [N]  <-->  11: case ls:3 of {C hh:4 tt:5 -> [C case hh:4 of {A -> [B] | AA -> [BB]} (map:1 tt:5)] | N -> [N]}
//│ rev:2^26 ⋅ ɛ ==> rev:2^14 ⋅ map:1^25 ⋅ ɛ:
//│ 	17: [C h:8 a:6]  <-->  11: case ls:3 of {C hh:4 tt:5 -> [C case hh:4 of {A -> [B] | AA -> [BB]} (map:1 tt:5)] | N -> [N]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def map:1 = fun ls:3 -> case ls:3 of {C hh:4 tt:5 -> [C case hh:4 of {A -> [B] | AA -> [BB]} (map:1 tt:5)] | N -> [N]}
//│ def rev:2 = fun a:6 -> fun lss:7 -> case lss:7 of {C h:8 t:9 -> ((rev:2 [C h:8 a:6]) t:9) | N -> a:6}
//│ def rev'2'26:11 = fun a:6 -> fun lss:7 -> case lss:7 of {C h:8 t:9 -> ((rev'2'26_rev'2'14:12 
//│ 	let hh:4 = h:8 in 
//│ 	let tt:5 = a:6 in [C case hh:4 of {A -> [B] | AA -> [BB]} (map'1'25:10 tt:5)]) t:9) | N -> a:6}
//│ def rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14:20 = fun a:6 -> fun lss:7 -> case lss:7 of {C h:8 t:9 -> ((rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14:21 [C h:8 a:6]) t:9) | N -> a:6}
//│ def rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14:21 = fun a:6 -> fun lss:7 -> case lss:7 of {C h:8 t:9 -> ((rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14:22 [C h:8 a:6]) t:9) | N -> a:6}
//│ def rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14:18 = fun a:6 -> fun lss:7 -> case lss:7 of {C h:8 t:9 -> ((rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14:19 [C h:8 a:6]) t:9) | N -> a:6}
//│ def rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14:15 = fun a:6 -> fun lss:7 -> case lss:7 of {C h:8 t:9 -> ((rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14:16 [C h:8 a:6]) t:9) | N -> a:6}
//│ def rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14:19 = fun a:6 -> fun lss:7 -> case lss:7 of {C h:8 t:9 -> ((rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14:20 [C h:8 a:6]) t:9) | N -> a:6}
//│ def map'1'25:10 = fun ls:3 -> ls:3
//│ def rev'2'26_rev'2'14_rev'2'14_rev'2'14:14 = fun a:6 -> fun lss:7 -> case lss:7 of {C h:8 t:9 -> ((rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14:15 [C h:8 a:6]) t:9) | N -> a:6}
//│ def rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14:16 = fun a:6 -> fun lss:7 -> case lss:7 of {C h:8 t:9 -> ((rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14:17 [C h:8 a:6]) t:9) | N -> a:6}
//│ def rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14:22 = "RECURSE_TOO_LONG"
//│ def rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14:17 = fun a:6 -> fun lss:7 -> case lss:7 of {C h:8 t:9 -> ((rev'2'26_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14_rev'2'14:18 [C h:8 a:6]) t:9) | N -> a:6}
//│ def rev'2'26_rev'2'14:12 = fun a:6 -> fun lss:7 -> case lss:7 of {C h:8 t:9 -> ((rev'2'26_rev'2'14_rev'2'14:13 [C h:8 a:6]) t:9) | N -> a:6}
//│ def rev'2'26_rev'2'14_rev'2'14:13 = fun a:6 -> fun lss:7 -> case lss:7 of {C h:8 t:9 -> ((rev'2'26_rev'2'14_rev'2'14_rev'2'14:14 [C h:8 a:6]) t:9) | N -> a:6}
//│ (map'1'25:10 ((rev'2'26:11 [N]) primitive:0))
//│ <<<<<<<<<< Rewritten <<<<<<<<<<
