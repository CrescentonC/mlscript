:NewParser
:ParseOnly

// NOTE: with concrete input as reference, will fuse completely after two iterations
_LUMBERHACK_EVAL
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
fun lastMap(ls, f) = last(map(ls, f))
fun ff(x) = if x is
  A then AA
  B then BB
lastMap(C(A, C(B, N)), ff)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|#fun| |lastMap|(|ls|,| |f|)| |#=| |last|(|map|(|ls|,| |f|)|)|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|lastMap|(|C|(|A|,| |C|(|B|,| |N|)|)|,| |ff|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; fun lastMap = ls, f, => last (map (ls, f,),); fun ff = x, => if x is ‹(A) then AA; (B) then BB›; lastMap (C (A, C (B, N,),), ff,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastMap^42([C [A] [C [B] [N]]], ff^49)
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last^28(map^29(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [Some [BB]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^49] (hopeless to continue)
//│ [lastMap^42] (hopeless to continue)
//│ 	[lastMap^42 · last^28] (using original def)
//│ 		[lastMap^42 · last^28 · last^17] ---> [lastMap^42 · last^28] (using original def)
//│ 	[lastMap^42 · map^29] (using original def)
//│ 		[lastMap^42 · map^29 · map^5] ---> [lastMap^42 · map^29] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastMap₀([C [A] [C [B] [N]]], ff₀)
//│ def ff₀(x¹) = 
//│ 	case x¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def lastMap₀(ls³, f³) = 
//│ 	last₀(map₀(ls³, f³))
//│ 	where
//│ 	def last₀(xs¹) = 
//│ 		case xs¹ of {
//│ 			C h³ t³ => case t³ of {
//│ 				C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 				| N  => [Some h³]}
//│ 			| N  => [None]}
//│ 	def map₀(ls², f²) = 
//│ 		case ls² of {
//│ 			C h² t² => [C f²(h²) map₀(t², f²)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f²(h²) map₀(t², f²)]: 60 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]}: 88
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 90
//│ [N]: 61 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]}: 88
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 90
//│ [C hh¹ tt¹]: 84 --->
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 90
//│ [A]: 93 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 68
//│ [B]: 94 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 68
//│ [N]: 95 --->
//│ 	case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62
//│ [C [B] [N]]: 96 --->
//│ 	case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62
//│ [C [A] [C [B] [N]]]: 97 --->
//│ 	case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62
//│ ------------------
//│ case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62 --->
//│ 	[N]: 95
//│ 	[C [B] [N]]: 96
//│ 	[C [A] [C [B] [N]]]: 97
//│ case x¹ of {A  => [AA] | B  => [BB]}: 68 --->
//│ 	[A]: 93
//│ 	[B]: 94
//│ case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]}: 88 --->
//│ 	[C f²(h²) map₀(t², f²)]: 60
//│ 	[N]: 61
//│ case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 90 --->
//│ 	[C f²(h²) map₀(t², f²)]: 60
//│ 	[N]: 61
//│ 	[C hh¹ tt¹]: 84
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 93 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 68
//│ [B]: 94 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 68
//│ [N]: 95 --->
//│ 	case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62
//│ [C [B] [N]]: 96 --->
//│ 	case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62
//│ [C [A] [C [B] [N]]]: 97 --->
//│ 	case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62
//│ ------------------
//│ case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62 --->
//│ 	[N]: 95
//│ 	[C [B] [N]]: 96
//│ 	[C [A] [C [B] [N]]]: 97
//│ case x¹ of {A  => [AA] | B  => [BB]}: 68 --->
//│ 	[A]: 93
//│ 	[B]: 94
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap₀(
//│ 	let h⁴ = (fun _lh_dummy¹ -> [AA])
//│ 	in let t⁴ = 	
//│ 		let h⁵ = (fun _lh_dummy⁰ -> [BB])
//│ 		in let t⁵ = (fun f⁶ -> [N])
//│ 		in (fun f⁵ -> [C f⁵(h⁵) map₀(t⁵, f⁵)])
//│ 	in (fun f⁴ -> [C f⁴(h⁴) map₀(t⁴, f⁴)]), ff₀)
//│ def ff₀(x²) = 
//│ 	x²(99)
//│ def lastMap₀(ls⁵, f⁸) = 
//│ 	last₀(map₀(ls⁵, f⁸))
//│ 	where
//│ 	def last₀(xs²) = 
//│ 		case xs² of {
//│ 			C h³ t³ => case t³ of {
//│ 				C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 				| N  => [Some h³]}
//│ 			| N  => [None]}
//│ 	def map₀(ls⁴, f⁷) = 
//│ 		ls⁴(f⁷)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some [BB]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff₀^33] (hopeless to continue)
//│ [lastMap₀^1] (hopeless to continue)
//│ 	[lastMap₀^1 · last₀^44] (using original def)
//│ 		[lastMap₀^1 · last₀^44 · last₀^55] ---> [lastMap₀^1 · last₀^44] (using original def)
//│ 	[lastMap₀^1 · map₀^45] (using original def)
//│ [map₀^11] (hopeless to continue)
//│ [map₀^23] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastMap₀₀(
//│ 	let h⁴ = (fun _lh_dummy² -> [AA])
//│ 	in let t⁴ = 	
//│ 		let h⁵ = (fun _lh_dummy³ -> [BB])
//│ 		in let t⁵ = (fun f⁹ -> [N])
//│ 		in (fun f¹⁰ -> [C f¹⁰(h⁵) map₀₁(t⁵, f¹⁰)])
//│ 	in (fun f¹¹ -> [C f¹¹(h⁴) map₀₂(t⁴, f¹¹)]), ff₀₀)
//│ def ff₀₀(x¹) = 
//│ 	x¹(99)
//│ def lastMap₀₀(ls², f⁵) = 
//│ 	last₀₀(map₀₀(ls², f⁵))
//│ 	where
//│ 	def last₀₀(xs¹) = 
//│ 		case xs¹ of {
//│ 			C h³ t³ => case t³ of {
//│ 				C hh¹ tt¹ => last₀₀([C hh¹ tt¹])
//│ 				| N  => [Some h³]}
//│ 			| N  => [None]}
//│ 	def map₀₀(ls³, f⁶) = 
//│ 		ls³(f⁶)
//│ def map₀₁(ls⁴, f⁷) = 
//│ 	ls⁴(f⁷)
//│ def map₀₂(ls⁵, f⁸) = 
//│ 	ls⁵(f⁸)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 95 --->
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 101
//│ [N]: 112 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]}: 99
//│ [C f¹⁰(h⁵) map₀₁(t⁵, f¹⁰)]: 122 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]}: 99
//│ [C f¹¹(h⁴) map₀₂(t⁴, f¹¹)]: 134 --->
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 101
//│ ------------------
//│ case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]}: 99 --->
//│ 	[N]: 112
//│ 	[C f¹⁰(h⁵) map₀₁(t⁵, f¹⁰)]: 122
//│ case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 101 --->
//│ 	[C hh¹ tt¹]: 95
//│ 	[C f¹¹(h⁴) map₀₂(t⁴, f¹¹)]: 134
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 112 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]}: 99
//│ [C f¹⁰(h⁵) map₀₁(t⁵, f¹⁰)]: 122 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]}: 99
//│ ------------------
//│ case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]}: 99 --->
//│ 	[N]: 112
//│ 	[C f¹⁰(h⁵) map₀₁(t⁵, f¹⁰)]: 122
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap₀₀(
//│ 	let h⁶ = (fun _lh_dummy⁴ -> [AA])
//│ 	in let t⁶ = 	
//│ 		let h⁷ = (fun _lh_dummy⁵ -> [BB])
//│ 		in let t⁷ = (fun f¹² -> (fun h⁸ -> [Some h⁸]))
//│ 		in (fun f¹³ -> 
//│ 			let hh² = f¹³(h⁷)
//│ 			in let tt² = map₀₁(t⁷, f¹³)
//│ 			in (fun h⁹ -> last₀₀([C hh² tt²])))
//│ 	in (fun f¹⁴ -> [C f¹⁴(h⁶) map₀₂(t⁶, f¹⁴)]), ff₀₀)
//│ def ff₀₀(x²) = 
//│ 	x²(99)
//│ def lastMap₀₀(ls⁶, f¹⁵) = 
//│ 	last₀₀(map₀₀(ls⁶, f¹⁵))
//│ 	where
//│ 	def last₀₀(xs²) = 
//│ 		case xs² of {
//│ 			C h³ t³ => t³(h³)
//│ 			| N  => [None]}
//│ 	def map₀₀(ls⁷, f¹⁶) = 
//│ 		ls⁷(f¹⁶)
//│ def map₀₁(ls⁹, f¹⁸) = 
//│ 	ls⁹(f¹⁸)
//│ def map₀₂(ls⁸, f¹⁷) = 
//│ 	ls⁸(f¹⁷)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some [BB]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff₀₀^42] (hopeless to continue)
//│ [lastMap₀₀^1] (hopeless to continue)
//│ 	[lastMap₀₀^1 · last₀₀^48] (using original def)
//│ 	[lastMap₀₀^1 · map₀₀^49] (using original def)
//│ [last₀₀^18] (hopeless to continue)
//│ [map₀₁^13] (hopeless to continue)
//│ [map₀₂^32] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastMap₀₀₀(
//│ 	let h⁷ = (fun _lh_dummy² -> [AA])
//│ 	in let t⁵ = 	
//│ 		let h⁸ = (fun _lh_dummy³ -> [BB])
//│ 		in let t⁶ = (fun f¹¹ -> (fun h⁹ -> [Some h⁹]))
//│ 		in (fun f¹² -> 
//│ 			let hh¹ = f¹²(h⁸)
//│ 			in let tt¹ = map₀₁₀(t⁶, f¹²)
//│ 			in (fun h¹⁰ -> last₀₀₁([C hh¹ tt¹])))
//│ 	in (fun f¹³ -> [C f¹³(h⁷) map₀₂₀(t⁵, f¹³)]), ff₀₀₀)
//│ def ff₀₀₀(x¹) = 
//│ 	x¹(99)
//│ def lastMap₀₀₀(ls⁴, f⁷) = 
//│ 	last₀₀₀(map₀₀₀(ls⁴, f⁷))
//│ 	where
//│ 	def last₀₀₀(xs²) = 
//│ 		case xs² of {
//│ 			C h⁶ t⁴ => t⁴(h⁶)
//│ 			| N  => [None]}
//│ 	def map₀₀₀(ls⁷, f¹⁰) = 
//│ 		ls⁷(f¹⁰)
//│ def last₀₀₁(xs¹) = 
//│ 	case xs¹ of {
//│ 		C h⁵ t³ => t³(h⁵)
//│ 		| N  => [None]}
//│ def map₀₁₀(ls⁵, f⁸) = 
//│ 	ls⁵(f⁸)
//│ def map₀₂₀(ls⁶, f⁹) = 
//│ 	ls⁶(f⁹)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 141 --->
//│ 	case xs¹ of {C h⁵ t³ => t³(h⁵) | N  => [None]}: 97
//│ [C f¹³(h⁷) map₀₂₀(t⁵, f¹³)]: 157 --->
//│ 	case xs² of {C h⁶ t⁴ => t⁴(h⁶) | N  => [None]}: 109
//│ ------------------
//│ case xs¹ of {C h⁵ t³ => t³(h⁵) | N  => [None]}: 97 --->
//│ 	[C hh¹ tt¹]: 141
//│ case xs² of {C h⁶ t⁴ => t⁴(h⁶) | N  => [None]}: 109 --->
//│ 	[C f¹³(h⁷) map₀₂₀(t⁵, f¹³)]: 157
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C hh¹ tt¹]: 141 --->
//│ 	case xs¹ of {C h⁵ t³ => t³(h⁵) | N  => [None]}: 97
//│ [C f¹³(h⁷) map₀₂₀(t⁵, f¹³)]: 157 --->
//│ 	case xs² of {C h⁶ t⁴ => t⁴(h⁶) | N  => [None]}: 109
//│ ------------------
//│ case xs¹ of {C h⁵ t³ => t³(h⁵) | N  => [None]}: 97 --->
//│ 	[C hh¹ tt¹]: 141
//│ case xs² of {C h⁶ t⁴ => t⁴(h⁶) | N  => [None]}: 109 --->
//│ 	[C f¹³(h⁷) map₀₂₀(t⁵, f¹³)]: 157
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap₀₀₀(
//│ 	let h¹¹ = (fun _lh_dummy⁴ -> [AA])
//│ 	in let t⁷ = 	
//│ 		let h¹² = (fun _lh_dummy⁵ -> [BB])
//│ 		in let t⁸ = (fun f¹⁴ -> (fun h¹³ -> [Some h¹³]))
//│ 		in (fun f¹⁵ -> 
//│ 			let hh² = f¹⁵(h¹²)
//│ 			in let tt² = map₀₁₀(t⁸, f¹⁵)
//│ 			in (fun h¹⁴ -> last₀₀₁(
//│ 				let h¹⁵ = hh²
//│ 				in let t⁹ = tt²
//│ 				in (fun _lh_dummy⁶ -> t⁹(h¹⁵)))))
//│ 	in (fun f¹⁶ -> 
//│ 		let h¹⁶ = f¹⁶(h¹¹)
//│ 		in let t¹⁰ = map₀₂₀(t⁷, f¹⁶)
//│ 		in (fun _lh_dummy⁷ -> t¹⁰(h¹⁶))), ff₀₀₀)
//│ def ff₀₀₀(x²) = 
//│ 	x²(99)
//│ def lastMap₀₀₀(ls⁸, f¹⁷) = 
//│ 	last₀₀₀(map₀₀₀(ls⁸, f¹⁷))
//│ 	where
//│ 	def last₀₀₀(xs⁴) = 
//│ 		xs⁴(99)
//│ 	def map₀₀₀(ls¹⁰, f¹⁹) = 
//│ 		ls¹⁰(f¹⁹)
//│ def last₀₀₁(xs³) = 
//│ 	xs³(99)
//│ def map₀₁₀(ls⁹, f¹⁸) = 
//│ 	ls⁹(f¹⁸)
//│ def map₀₂₀(ls¹¹, f²⁰) = 
//│ 	ls¹¹(f²⁰)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some [BB]]
//│ <<<<<<< evaluate <<<<<<<

// NOTE: no concrete input, will not fuse at all
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(t)
    N then Some(h)
  N then None
fun lastMap(ls, f) = last(map(ls, f))
lastMap
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|t|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|#fun| |lastMap|(|ls|,| |f|)| |#=| |last|(|map|(|ls|,| |f|)|)|↵|lastMap|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (t,); (N) then Some (h,)›; (N) then None›; fun lastMap = ls, f, => last (map (ls, f,),); lastMap}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastMap^35
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17(t¹)
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last^26(map^27(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastMap^35]
//│ 	[lastMap^35 · last^26] (hopeless to continue)
//│ 		[lastMap^35 · last^26 · last^17] ---> [lastMap^35 · last^26] (using original def)
//│ 	[lastMap^35 · map^27]
//│ 		[lastMap^35 · map^27 · map^5] ---> [lastMap^35 · map^27] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastMap₀
//│ def lastMap₀(ls², f²) = 
//│ 	last₀(map₀(ls², f²))
//│ 	where
//│ 	def last₀(xs¹) = 
//│ 		case xs¹ of {
//│ 			C h³ t³ => case t³ of {
//│ 				C hh¹ tt¹ => last₀(t³)
//│ 				| N  => [Some h³]}
//│ 			| N  => [None]}
//│ 	def map₀(ls³, f³) = 
//│ 		case ls³ of {
//│ 			C h² t² => [C f³(h²) map₀(t², f³)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f³(h²) map₀(t², f³)]: 54 --->
//│ 	DeadCodeCons
//│ 	case t³ of {C hh¹ tt¹ => last₀(t³) | N  => [Some h³]}: 66
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀(t³) | N  => [Some h³]} | N  => [None]}: 68
//│ [N]: 55 --->
//│ 	DeadCodeCons
//│ 	case t³ of {C hh¹ tt¹ => last₀(t³) | N  => [Some h³]}: 66
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀(t³) | N  => [Some h³]} | N  => [None]}: 68
//│ ------------------
//│ case t³ of {C hh¹ tt¹ => last₀(t³) | N  => [Some h³]}: 66 --->
//│ 	[C f³(h²) map₀(t², f³)]: 54
//│ 	[N]: 55
//│ case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀(t³) | N  => [Some h³]} | N  => [None]}: 68 --->
//│ 	[C f³(h²) map₀(t², f³)]: 54
//│ 	[N]: 55
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap₀
//│ def lastMap₀(ls⁴, f⁴) = 
//│ 	last₀(map₀(ls⁴, f⁴))
//│ 	where
//│ 	def last₀(xs²) = 
//│ 		case xs² of {
//│ 			C h³ t³ => case t³ of {
//│ 				C hh¹ tt¹ => last₀(t³)
//│ 				| N  => [Some h³]}
//│ 			| N  => [None]}
//│ 	def map₀(ls⁵, f⁵) = 
//│ 		case ls⁵ of {
//│ 			C h² t² => [C f⁵(h²) map₀(t², f⁵)]
//│ 			| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: replace the `t` in the previous `last(t)` into `C(h, t)`, still no fusion done
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
fun lastMap(ls, f) = last(map(ls, f))
lastMap
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|#fun| |lastMap|(|ls|,| |f|)| |#=| |last|(|map|(|ls|,| |f|)|)|↵|lastMap|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; fun lastMap = ls, f, => last (map (ls, f,),); lastMap}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastMap^37
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last^28(map^29(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastMap^37]
//│ 	[lastMap^37 · last^28] (hopeless to continue)
//│ 		[lastMap^37 · last^28 · last^17] ---> [lastMap^37 · last^28] (using original def)
//│ 	[lastMap^37 · map^29]
//│ 		[lastMap^37 · map^29 · map^5] ---> [lastMap^37 · map^29] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastMap₀
//│ def lastMap₀(ls², f²) = 
//│ 	last₀(map₀(ls², f²))
//│ 	where
//│ 	def last₀(xs¹) = 
//│ 		case xs¹ of {
//│ 			C h² t² => case t² of {
//│ 				C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 				| N  => [Some h²]}
//│ 			| N  => [None]}
//│ 	def map₀(ls³, f³) = 
//│ 		case ls³ of {
//│ 			C h³ t³ => [C f³(h³) map₀(t³, f³)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 52 --->
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 58
//│ [C f³(h³) map₀(t³, f³)]: 69 --->
//│ 	case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]}: 56
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 58
//│ [N]: 70 --->
//│ 	case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]}: 56
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 58
//│ ------------------
//│ case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]}: 56 --->
//│ 	[C f³(h³) map₀(t³, f³)]: 69
//│ 	[N]: 70
//│ case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 58 --->
//│ 	[C hh¹ tt¹]: 52
//│ 	[C f³(h³) map₀(t³, f³)]: 69
//│ 	[N]: 70
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap₀
//│ def lastMap₀(ls⁴, f⁴) = 
//│ 	last₀(map₀(ls⁴, f⁴))
//│ 	where
//│ 	def last₀(xs²) = 
//│ 		case xs² of {
//│ 			C h² t² => case t² of {
//│ 				C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 				| N  => [Some h²]}
//│ 			| N  => [None]}
//│ 	def map₀(ls⁵, f⁵) = 
//│ 		case ls⁵ of {
//│ 			C h³ t³ => [C f⁵(h³) map₀(t³, f⁵)]
//│ 			| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<


// NOTE: pass primitives as parameters, sitll no fusion done
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
fun lastMap(ls, f) = last(map(ls, f))
lastMap(primitive, primitive)
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|#fun| |lastMap|(|ls|,| |f|)| |#=| |last|(|map|(|ls|,| |f|)|)|↵|lastMap|(|primitive|,| |primitive|)|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; fun lastMap = ls, f, => last (map (ls, f,),); lastMap (primitive, primitive,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastMap^37(primitive⁰, primitive⁰)
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last^28(map^29(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastMap^37]
//│ 	[lastMap^37 · last^28] (hopeless to continue)
//│ 		[lastMap^37 · last^28 · last^17] ---> [lastMap^37 · last^28] (using original def)
//│ 	[lastMap^37 · map^29]
//│ 		[lastMap^37 · map^29 · map^5] ---> [lastMap^37 · map^29] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastMap₀(primitive⁰, primitive⁰)
//│ def lastMap₀(ls², f²) = 
//│ 	last₀(map₀(ls², f²))
//│ 	where
//│ 	def last₀(xs¹) = 
//│ 		case xs¹ of {
//│ 			C h² t² => case t² of {
//│ 				C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 				| N  => [Some h²]}
//│ 			| N  => [None]}
//│ 	def map₀(ls³, f³) = 
//│ 		case ls³ of {
//│ 			C h³ t³ => [C f³(h³) map₀(t³, f³)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 56 --->
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 62
//│ [C f³(h³) map₀(t³, f³)]: 73 --->
//│ 	case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]}: 60
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 62
//│ [N]: 74 --->
//│ 	case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]}: 60
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 62
//│ ------------------
//│ case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]}: 60 --->
//│ 	[C f³(h³) map₀(t³, f³)]: 73
//│ 	[N]: 74
//│ case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 62 --->
//│ 	[C hh¹ tt¹]: 56
//│ 	[C f³(h³) map₀(t³, f³)]: 73
//│ 	[N]: 74
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap₀(primitive⁰, primitive⁰)
//│ def lastMap₀(ls⁴, f⁴) = 
//│ 	last₀(map₀(ls⁴, f⁴))
//│ 	where
//│ 	def last₀(xs²) = 
//│ 		case xs² of {
//│ 			C h² t² => case t² of {
//│ 				C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 				| N  => [Some h²]}
//│ 			| N  => [None]}
//│ 	def map₀(ls⁵, f⁵) = 
//│ 		case ls⁵ of {
//│ 			C h³ t³ => [C f⁵(h³) map₀(t³, f⁵)]
//│ 			| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: this even does some function call pattern specialization for the last
// and the only difference is that map now is unrolled twice
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
last(map(primitive, primitive))
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|map|(|primitive|,| |primitive|)|)|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; last (map (primitive, primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ last^28(map^29(primitive⁰, primitive⁰))
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^28]
//│ 	[last^28 · last^17] ---> [last^28] (only one)
//│ [map^29]
//│ 	[map^29 · map^5] ---> [map^29] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ last₀(map₀(primitive⁰, primitive⁰))
//│ def last₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		C h³ t³ => case t³ of {
//│ 			C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 			| N  => [Some h³]}
//│ 		| N  => [None]}
//│ def map₀(ls¹, f¹) = 
//│ 	case ls¹ of {
//│ 		C h² t² => [C f¹(h²) map₀(t², f¹)]
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f¹(h²) map₀(t², f¹)]: 44 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]}: 58
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 60
//│ [N]: 45 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]}: 58
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 60
//│ [C hh¹ tt¹]: 54 --->
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 60
//│ ------------------
//│ case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]}: 58 --->
//│ 	[C f¹(h²) map₀(t², f¹)]: 44
//│ 	[N]: 45
//│ case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 60 --->
//│ 	[C f¹(h²) map₀(t², f¹)]: 44
//│ 	[N]: 45
//│ 	[C hh¹ tt¹]: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ last₀(map₀(primitive⁰, primitive⁰))
//│ def last₀(xs²) = 
//│ 	case xs² of {
//│ 		C h³ t³ => case t³ of {
//│ 			C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 			| N  => [Some h³]}
//│ 		| N  => [None]}
//│ def map₀(ls², f²) = 
//│ 	case ls² of {
//│ 		C h² t² => [C f²(h²) map₀(t², f²)]
//│ 		| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<


