:NewParser
:ParseOnly

// NOTE: with concrete input as reference, will fuse completely after two iterations
_LUMBERHACK_EVAL
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
fun lastMap(ls, f) = last(map(ls, f))
fun ff(x) = if x is
  A then AA
  B then BB
lastMap(C(A, C(B, N)), ff)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|#fun| |lastMap|(|ls|,| |f|)| |#=| |last|(|map|(|ls|,| |f|)|)|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|lastMap|(|C|(|A|,| |C|(|B|,| |N|)|)|,| |ff|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; fun lastMap = ls, f, => last (map (ls, f,),); fun ff = x, => if x is ‹(A) then AA; (B) then BB›; lastMap (C (A, C (B, N,),), ff,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastMap^42([C [A] [C [B] [N]]], ff^49)
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last^28(map^29(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [Some [BB]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]}: 24
//│ 	case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26
//│ [N]: 11 --->
//│ 	case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]}: 24
//│ 	case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26
//│ [C hh⁰ tt⁰]: 20 --->
//│ 	case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26
//│ [A]: 43 --->
//│ 	case x⁰ of {A  => [AA] | B  => [BB]}: 40
//│ [B]: 44 --->
//│ 	case x⁰ of {A  => [AA] | B  => [BB]}: 40
//│ [N]: 45 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [C [B] [N]]: 46 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [C [A] [C [B] [N]]]: 47 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 45
//│ 	[C [B] [N]]: 46
//│ 	[C [A] [C [B] [N]]]: 47
//│ case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]}: 24 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ 	[C hh⁰ tt⁰]: 20
//│ case x⁰ of {A  => [AA] | B  => [BB]}: 40 --->
//│ 	[A]: 43
//│ 	[B]: 44
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 43 --->
//│ 	case x⁰ of {A  => [AA] | B  => [BB]}: 40
//│ [B]: 44 --->
//│ 	case x⁰ of {A  => [AA] | B  => [BB]}: 40
//│ [N]: 45 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [C [B] [N]]: 46 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ [C [A] [C [B] [N]]]: 47 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 45
//│ 	[C [B] [N]]: 46
//│ 	[C [A] [C [B] [N]]]: 47
//│ case x⁰ of {A  => [AA] | B  => [BB]}: 40 --->
//│ 	[A]: 43
//│ 	[B]: 44
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap(
//│ 	let t² = 	
//│ 		let t³ = (fun f⁴ -> [N])
//│ 		in let h³ = [BB]
//│ 		in (fun f³ -> [C f³(h³) map(t³, f³)])
//│ 	in let h² = [AA]
//│ 	in (fun f² -> [C f²(h²) map(t², f²)]), ff)
//│ def ff(x¹) = x¹
//│ def last(xs¹) = case xs¹ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls³, f⁶) = last(map(ls³, f⁶))
//│ def map(ls², f⁵) = ls²(f⁵)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some [BB]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ ff, map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ lastMap(
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun f⁰ -> [N])
//│ 		in let h⁰ = [BB]
//│ 		in (fun f¹ -> [C f¹(h⁰) t¹(f¹)])
//│ 	in let h¹ = [AA]
//│ 	in (fun f² -> [C f²(h¹) t⁰(f²)]), ff)
//│ def ff(x⁰) = x⁰
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h² t² => case t² of {
//│ 		C hh⁰ tt⁰ => last([C hh⁰ tt⁰])
//│ 		| N  => [Some h²]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f⁴) = last(ls¹(f⁴))
//│ def map(ls⁰, f³) = ls⁰(f³)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ lastMap(
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun f⁰ -> [N])
//│ 		in let h⁰ = [BB]
//│ 		in (fun f¹ -> [C f¹(h⁰) t¹(f¹)])
//│ 	in let h¹ = [AA]
//│ 	in (fun f² -> [C f²(h¹) t⁰(f²)]), ff)
//│ def ff(x⁰) = x⁰
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h² t² => case t² of {
//│ 		C hh⁰ tt⁰ => last([C hh⁰ tt⁰])
//│ 		| N  => [Some h²]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f⁴) = last(ls¹(f⁴))
//│ def map(ls⁰, f³) = ls⁰(f³)
//│ <<<<<<< after floating out <<<<<<<

// NOTE: no concrete input, will not fuse at all
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(t)
    N then Some(h)
  N then None
fun lastMap(ls, f) = last(map(ls, f))
lastMap
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|t|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|#fun| |lastMap|(|ls|,| |f|)| |#=| |last|(|map|(|ls|,| |f|)|)|↵|lastMap|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (t,); (N) then Some (h,)›; (N) then None›; fun lastMap = ls, f, => last (map (ls, f,),); lastMap}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastMap^35
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17(t¹)
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last^26(map^27(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	DeadCodeCons
//│ 	case t¹ of {C hh⁰ tt⁰ => last(t¹) | N  => [Some h¹]}: 22
//│ 	case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last(t¹) | N  => [Some h¹]} | N  => [None]}: 24
//│ [N]: 11 --->
//│ 	DeadCodeCons
//│ 	case t¹ of {C hh⁰ tt⁰ => last(t¹) | N  => [Some h¹]}: 22
//│ 	case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last(t¹) | N  => [Some h¹]} | N  => [None]}: 24
//│ ------------------
//│ case t¹ of {C hh⁰ tt⁰ => last(t¹) | N  => [Some h¹]}: 22 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last(t¹) | N  => [Some h¹]} | N  => [None]}: 24 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap
//│ def last(xs¹) = case xs¹ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last(t¹)
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls³, f³) = last(map(ls³, f³))
//│ def map(ls², f²) = case ls² of {
//│ 	C h⁰ t⁰ => [C f²(h⁰) map(t⁰, f²)]
//│ 	| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ lastMap
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last(t¹)
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last(map(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ lastMap
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last(t¹)
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last(map(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<< after floating out <<<<<<<

// NOTE: replace the `t` in the previous `last(t)` into `C(h, t)`, still no fusion done
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
fun lastMap(ls, f) = last(map(ls, f))
lastMap
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|#fun| |lastMap|(|ls|,| |f|)| |#=| |last|(|map|(|ls|,| |f|)|)|↵|lastMap|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; fun lastMap = ls, f, => last (map (ls, f,),); lastMap}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastMap^37
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last^28(map^29(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]}: 24
//│ 	case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26
//│ [N]: 11 --->
//│ 	case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]}: 24
//│ 	case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26
//│ [C hh⁰ tt⁰]: 20 --->
//│ 	case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26
//│ ------------------
//│ case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]}: 24 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ 	[C hh⁰ tt⁰]: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap
//│ def last(xs¹) = case xs¹ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls³, f³) = last(map(ls³, f³))
//│ def map(ls², f²) = case ls² of {
//│ 	C h⁰ t⁰ => [C f²(h⁰) map(t⁰, f²)]
//│ 	| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ lastMap
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last(map(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ lastMap
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last(map(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<< after floating out <<<<<<<


// NOTE: pass primitives as parameters, sitll no fusion done
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
fun lastMap(ls, f) = last(map(ls, f))
lastMap(primitive, primitive)
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|#fun| |lastMap|(|ls|,| |f|)| |#=| |last|(|map|(|ls|,| |f|)|)|↵|lastMap|(|primitive|,| |primitive|)|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; fun lastMap = ls, f, => last (map (ls, f,),); lastMap (primitive, primitive,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastMap^37(primitive⁰, primitive⁰)
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last^28(map^29(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]}: 24
//│ 	case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26
//│ [N]: 11 --->
//│ 	case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]}: 24
//│ 	case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26
//│ [C hh⁰ tt⁰]: 20 --->
//│ 	case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26
//│ ------------------
//│ case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]}: 24 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ 	[C hh⁰ tt⁰]: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap(primitive⁰, primitive⁰)
//│ def last(xs¹) = case xs¹ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls³, f³) = last(map(ls³, f³))
//│ def map(ls², f²) = case ls² of {
//│ 	C h⁰ t⁰ => [C f²(h⁰) map(t⁰, f²)]
//│ 	| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ lastMap(primitive⁰, primitive⁰)
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last(map(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ lastMap(primitive⁰, primitive⁰)
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last(map(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<< after floating out <<<<<<<

// NOTE: this even does some function call pattern specialization for the last
// and the only difference is that map now is unrolled twice
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
last(map(primitive, primitive))
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|map|(|primitive|,| |primitive|)|)|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; last (map (primitive, primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ last^28(map^29(primitive⁰, primitive⁰))
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(t⁰, f⁰)]: 10 --->
//│ 	case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]}: 24
//│ 	case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26
//│ [N]: 11 --->
//│ 	case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]}: 24
//│ 	case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26
//│ [C hh⁰ tt⁰]: 20 --->
//│ 	case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26
//│ ------------------
//│ case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]}: 24 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ case xs⁰ of {C h¹ t¹ => case t¹ of {C hh⁰ tt⁰ => last([C hh⁰ tt⁰]) | N  => [Some h¹]} | N  => [None]}: 26 --->
//│ 	[C f⁰(h⁰) map(t⁰, f⁰)]: 10
//│ 	[N]: 11
//│ 	[C hh⁰ tt⁰]: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ last(map(primitive⁰, primitive⁰))
//│ def last(xs¹) = case xs¹ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def map(ls¹, f¹) = case ls¹ of {
//│ 	C h⁰ t⁰ => [C f¹(h⁰) map(t⁰, f¹)]
//│ 	| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ last(map(primitive⁰, primitive⁰))
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ last(map(primitive⁰, primitive⁰))
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<< after floating out <<<<<<<


