:NewParser
:ParseOnly

// NOTE: with concrete input as reference, will fuse completely after two iterations
_LUMBERHACK_EVAL
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
fun lastMap(ls, f) = last(map(ls, f))
fun ff(x) = if x is
  A then AA
  B then BB
lastMap(C(A, C(B, N)), ff)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|#fun| |lastMap|(|ls|,| |f|)| |#=| |last|(|map|(|ls|,| |f|)|)|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|lastMap|(|C|(|A|,| |C|(|B|,| |N|)|)|,| |ff|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; fun lastMap = ls, f, => last (map (ls, f,),); fun ff = x, => if x is ‹(A) then AA; (B) then BB›; lastMap (C (A, C (B, N,),), ff,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastMap^42([C [A] [C [B] [N]]], ff^49)
//│ def ff(x⁰) = case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]}
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last^28(map^29(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [Some [BB]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^49] (hopeless to continue)
//│ [lastMap^42] (hopeless to continue)
//│ 	[lastMap^42 · last^28] (using original def)
//│ 		[lastMap^42 · last^28 · last^17] ---> [lastMap^42 · last^28] (using original def)
//│ 	[lastMap^42 · map^29] (using original def)
//│ 		[lastMap^42 · map^29 · map^5] ---> [lastMap^42 · map^29] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastMap₀([C [A] [C [B] [N]]], ff₀)
//│ def ff₀(x¹) = 
//│ 	case x¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]}
//│ def lastMap₀(ls³, f³) = 
//│ 	last₀(map₀(ls³, f³))
//│ 	where
//│ 	def last₀(xs¹) = 
//│ 		case xs¹ of {
//│ 			C h³ t³ => case t³ of {
//│ 				C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 				| N  => [Some h³]}
//│ 			| N  => [None]}
//│ 	def map₀(ls², f²) = 
//│ 		case ls² of {
//│ 			C h² t² => [C f²(h²) map₀(t², f²)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f²(h²) map₀(t², f²)]: 60 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]}: 88
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 90
//│ [N]: 61 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]}: 88
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 90
//│ [C hh¹ tt¹]: 84 --->
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 90
//│ [A]: 93 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 68
//│ [B]: 94 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 68
//│ [N]: 95 --->
//│ 	case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62
//│ [C [B] [N]]: 96 --->
//│ 	case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62
//│ [C [A] [C [B] [N]]]: 97 --->
//│ 	case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62
//│ ------------------
//│ case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62 --->
//│ 	[N]: 95
//│ 	[C [B] [N]]: 96
//│ 	[C [A] [C [B] [N]]]: 97
//│ case x¹ of {A  => [AA] | B  => [BB]}: 68 --->
//│ 	[A]: 93
//│ 	[B]: 94
//│ case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]}: 88 --->
//│ 	[C f²(h²) map₀(t², f²)]: 60
//│ 	[N]: 61
//│ case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 90 --->
//│ 	[C f²(h²) map₀(t², f²)]: 60
//│ 	[N]: 61
//│ 	[C hh¹ tt¹]: 84
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 93 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 68
//│ [B]: 94 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 68
//│ [N]: 95 --->
//│ 	case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62
//│ [C [B] [N]]: 96 --->
//│ 	case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62
//│ [C [A] [C [B] [N]]]: 97 --->
//│ 	case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62
//│ ------------------
//│ case ls² of {C h² t² => [C f²(h²) map₀(t², f²)] | N  => [N]}: 62 --->
//│ 	[N]: 95
//│ 	[C [B] [N]]: 96
//│ 	[C [A] [C [B] [N]]]: 97
//│ case x¹ of {A  => [AA] | B  => [BB]}: 68 --->
//│ 	[A]: 93
//│ 	[B]: 94
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap₀(
//│ 	let h⁴ = lazy⁰([AA])
//│ 	in let t⁴ = lazy⁰(
//│ 		let h⁵ = lazy⁰([BB])
//│ 		in let t⁵ = lazy⁰((fun f⁶ -> [N]))
//│ 		in (fun f⁵ -> [C f⁵(force⁰(h⁵)) map₀(force⁰(t⁵), f⁵)]))
//│ 	in (fun f⁴ -> [C f⁴(force⁰(h⁴)) map₀(force⁰(t⁴), f⁴)]), ff₀)
//│ def ff₀(x²) = 
//│ 	x²
//│ def lastMap₀(ls⁵, f⁸) = 
//│ 	last₀(map₀(ls⁵, f⁸))
//│ 	where
//│ 	def last₀(xs²) = 
//│ 		case xs² of {
//│ 			C h³ t³ => case t³ of {
//│ 				C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 				| N  => [Some h³]}
//│ 			| N  => [None]}
//│ 	def map₀(ls⁴, f⁷) = 
//│ 		ls⁴(f⁷)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some [BB]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff₀^47] (hopeless to continue)
//│ [lastMap₀^1] (hopeless to continue)
//│ 	[lastMap₀^1 · last₀^56] (using original def)
//│ 		[lastMap₀^1 · last₀^56 · last₀^67] ---> [lastMap₀^1 · last₀^56] (using original def)
//│ 	[lastMap₀^1 · map₀^57] (using original def)
//│ [map₀^18] (hopeless to continue)
//│ [map₀^35] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastMap₀₀(
//│ 	let h⁴ = lazy⁰([AA])
//│ 	in let t⁴ = lazy⁰(
//│ 		let h⁵ = lazy⁰([BB])
//│ 		in let t⁵ = lazy⁰((fun f⁹ -> [N]))
//│ 		in (fun f¹⁰ -> [C f¹⁰(force⁰(h⁵)) map₀₁(force⁰(t⁵), f¹⁰)]))
//│ 	in (fun f¹¹ -> [C f¹¹(force⁰(h⁴)) map₀₂(force⁰(t⁴), f¹¹)]), ff₀₀)
//│ def ff₀₀(x¹) = 
//│ 	x¹
//│ def lastMap₀₀(ls², f⁵) = 
//│ 	last₀₀(map₀₀(ls², f⁵))
//│ 	where
//│ 	def last₀₀(xs¹) = 
//│ 		case xs¹ of {
//│ 			C h³ t³ => case t³ of {
//│ 				C hh¹ tt¹ => last₀₀([C hh¹ tt¹])
//│ 				| N  => [Some h³]}
//│ 			| N  => [None]}
//│ 	def map₀₀(ls³, f⁶) = 
//│ 		ls³(f⁶)
//│ def map₀₁(ls⁵, f⁸) = 
//│ 	ls⁵(f⁸)
//│ def map₀₂(ls⁴, f⁷) = 
//│ 	ls⁴(f⁷)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 83 --->
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 89
//│ [N]: 126 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]}: 87
//│ [C f¹⁰(force⁰(h⁵)) map₀₁(force⁰(t⁵), f¹⁰)]: 141 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]}: 87
//│ [C f¹¹(force⁰(h⁴)) map₀₂(force⁰(t⁴), f¹¹)]: 158 --->
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 89
//│ ------------------
//│ case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]}: 87 --->
//│ 	[N]: 126
//│ 	[C f¹⁰(force⁰(h⁵)) map₀₁(force⁰(t⁵), f¹⁰)]: 141
//│ case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 89 --->
//│ 	[C hh¹ tt¹]: 83
//│ 	[C f¹¹(force⁰(h⁴)) map₀₂(force⁰(t⁴), f¹¹)]: 158
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 126 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]}: 87
//│ [C f¹⁰(force⁰(h⁵)) map₀₁(force⁰(t⁵), f¹⁰)]: 141 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]}: 87
//│ ------------------
//│ case t³ of {C hh¹ tt¹ => last₀₀([C hh¹ tt¹]) | N  => [Some h³]}: 87 --->
//│ 	[N]: 126
//│ 	[C f¹⁰(force⁰(h⁵)) map₀₁(force⁰(t⁵), f¹⁰)]: 141
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap₀₀(
//│ 	let h⁶ = lazy⁰([AA])
//│ 	in let t⁶ = lazy⁰(
//│ 		let h⁷ = lazy⁰([BB])
//│ 		in let t⁷ = lazy⁰((fun f¹² -> (fun h⁸ -> [Some h⁸])))
//│ 		in (fun f¹³ -> 
//│ 			let hh² = lazy⁰(f¹³(force⁰(h⁷)))
//│ 			in let tt² = lazy⁰(map₀₁(force⁰(t⁷), f¹³))
//│ 			in (fun h⁹ -> last₀₀([C force⁰(hh²) force⁰(tt²)]))))
//│ 	in (fun f¹⁴ -> [C f¹⁴(force⁰(h⁶)) map₀₂(force⁰(t⁶), f¹⁴)]), ff₀₀)
//│ def ff₀₀(x²) = 
//│ 	x²
//│ def lastMap₀₀(ls⁶, f¹⁵) = 
//│ 	last₀₀(map₀₀(ls⁶, f¹⁵))
//│ 	where
//│ 	def last₀₀(xs²) = 
//│ 		case xs² of {
//│ 			C h³ t³ => t³(h³)
//│ 			| N  => [None]}
//│ 	def map₀₀(ls⁷, f¹⁶) = 
//│ 		ls⁷(f¹⁶)
//│ def map₀₁(ls⁹, f¹⁸) = 
//│ 	ls⁹(f¹⁸)
//│ def map₀₂(ls⁸, f¹⁷) = 
//│ 	ls⁸(f¹⁷)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some [BB]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff₀₀^64] (hopeless to continue)
//│ [lastMap₀₀^1] (hopeless to continue)
//│ 	[lastMap₀₀^1 · last₀₀^68] (using original def)
//│ 	[lastMap₀₀^1 · map₀₀^69] (using original def)
//│ [last₀₀^31] (hopeless to continue)
//│ [map₀₁^23] (hopeless to continue)
//│ [map₀₂^52] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastMap₀₀₀(
//│ 	let h⁷ = lazy⁰([AA])
//│ 	in let t⁵ = lazy⁰(
//│ 		let h⁸ = lazy⁰([BB])
//│ 		in let t⁶ = lazy⁰((fun f¹¹ -> (fun h⁹ -> [Some h⁹])))
//│ 		in (fun f¹² -> 
//│ 			let hh¹ = lazy⁰(f¹²(force⁰(h⁸)))
//│ 			in let tt¹ = lazy⁰(map₀₁₀(force⁰(t⁶), f¹²))
//│ 			in (fun h¹⁰ -> last₀₀₁([C force⁰(hh¹) force⁰(tt¹)]))))
//│ 	in (fun f¹³ -> [C f¹³(force⁰(h⁷)) map₀₂₀(force⁰(t⁵), f¹³)]), ff₀₀₀)
//│ def ff₀₀₀(x¹) = 
//│ 	x¹
//│ def lastMap₀₀₀(ls⁶, f⁹) = 
//│ 	last₀₀₀(map₀₀₀(ls⁶, f⁹))
//│ 	where
//│ 	def last₀₀₀(xs²) = 
//│ 		case xs² of {
//│ 			C h⁶ t⁴ => t⁴(h⁶)
//│ 			| N  => [None]}
//│ 	def map₀₀₀(ls⁴, f⁷) = 
//│ 		ls⁴(f⁷)
//│ def last₀₀₁(xs¹) = 
//│ 	case xs¹ of {
//│ 		C h⁵ t³ => t³(h⁵)
//│ 		| N  => [None]}
//│ def map₀₁₀(ls⁵, f⁸) = 
//│ 	ls⁵(f⁸)
//│ def map₀₂₀(ls⁷, f¹⁰) = 
//│ 	ls⁷(f¹⁰)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C force⁰(hh¹) force⁰(tt¹)]: 176 --->
//│ 	case xs¹ of {C h⁵ t³ => t³(h⁵) | N  => [None]}: 104
//│ [C f¹³(force⁰(h⁷)) map₀₂₀(force⁰(t⁵), f¹³)]: 197 --->
//│ 	case xs² of {C h⁶ t⁴ => t⁴(h⁶) | N  => [None]}: 132
//│ ------------------
//│ case xs¹ of {C h⁵ t³ => t³(h⁵) | N  => [None]}: 104 --->
//│ 	[C force⁰(hh¹) force⁰(tt¹)]: 176
//│ case xs² of {C h⁶ t⁴ => t⁴(h⁶) | N  => [None]}: 132 --->
//│ 	[C f¹³(force⁰(h⁷)) map₀₂₀(force⁰(t⁵), f¹³)]: 197
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C force⁰(hh¹) force⁰(tt¹)]: 176 --->
//│ 	case xs¹ of {C h⁵ t³ => t³(h⁵) | N  => [None]}: 104
//│ [C f¹³(force⁰(h⁷)) map₀₂₀(force⁰(t⁵), f¹³)]: 197 --->
//│ 	case xs² of {C h⁶ t⁴ => t⁴(h⁶) | N  => [None]}: 132
//│ ------------------
//│ case xs¹ of {C h⁵ t³ => t³(h⁵) | N  => [None]}: 104 --->
//│ 	[C force⁰(hh¹) force⁰(tt¹)]: 176
//│ case xs² of {C h⁶ t⁴ => t⁴(h⁶) | N  => [None]}: 132 --->
//│ 	[C f¹³(force⁰(h⁷)) map₀₂₀(force⁰(t⁵), f¹³)]: 197
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap₀₀₀(
//│ 	let h¹¹ = lazy⁰([AA])
//│ 	in let t⁷ = lazy⁰(
//│ 		let h¹² = lazy⁰([BB])
//│ 		in let t⁸ = lazy⁰((fun f¹⁴ -> (fun h¹³ -> [Some h¹³])))
//│ 		in (fun f¹⁵ -> 
//│ 			let hh² = lazy⁰(f¹⁵(force⁰(h¹²)))
//│ 			in let tt² = lazy⁰(map₀₁₀(force⁰(t⁸), f¹⁵))
//│ 			in (fun h¹⁴ -> last₀₀₁(
//│ 				let h¹⁵ = lazy⁰(force⁰(hh²))
//│ 				in let t⁹ = lazy⁰(force⁰(tt²))
//│ 				in force⁰(t⁹, force⁰(h¹⁵))))))
//│ 	in (fun f¹⁶ -> 
//│ 		let h¹⁶ = lazy⁰(f¹⁶(force⁰(h¹¹)))
//│ 		in let t¹⁰ = lazy⁰(map₀₂₀(force⁰(t⁷), f¹⁶))
//│ 		in force⁰(t¹⁰, force⁰(h¹⁶))), ff₀₀₀)
//│ def ff₀₀₀(x²) = 
//│ 	x²
//│ def lastMap₀₀₀(ls⁸, f¹⁷) = 
//│ 	last₀₀₀(map₀₀₀(ls⁸, f¹⁷))
//│ 	where
//│ 	def last₀₀₀(xs⁴) = 
//│ 		xs⁴
//│ 	def map₀₀₀(ls¹⁰, f¹⁹) = 
//│ 		ls¹⁰(f¹⁹)
//│ def last₀₀₁(xs³) = 
//│ 	xs³
//│ def map₀₁₀(ls⁹, f¹⁸) = 
//│ 	ls⁹(f¹⁸)
//│ def map₀₂₀(ls¹¹, f²⁰) = 
//│ 	ls¹¹(f²⁰)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Some [BB]]
//│ <<<<<<< evaluate <<<<<<<

// NOTE: no concrete input, will not fuse at all
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(t)
    N then Some(h)
  N then None
fun lastMap(ls, f) = last(map(ls, f))
lastMap
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|t|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|#fun| |lastMap|(|ls|,| |f|)| |#=| |last|(|map|(|ls|,| |f|)|)|↵|lastMap|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (t,); (N) then Some (h,)›; (N) then None›; fun lastMap = ls, f, => last (map (ls, f,),); lastMap}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastMap^35
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17(t¹)
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last^26(map^27(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastMap^35]
//│ 	[lastMap^35 · last^26] (hopeless to continue)
//│ 		[lastMap^35 · last^26 · last^17] ---> [lastMap^35 · last^26] (using original def)
//│ 	[lastMap^35 · map^27]
//│ 		[lastMap^35 · map^27 · map^5] ---> [lastMap^35 · map^27] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastMap₀
//│ def lastMap₀(ls², f²) = 
//│ 	last₀(map₀(ls², f²))
//│ 	where
//│ 	def last₀(xs¹) = 
//│ 		case xs¹ of {
//│ 			C h³ t³ => case t³ of {
//│ 				C hh¹ tt¹ => last₀(t³)
//│ 				| N  => [Some h³]}
//│ 			| N  => [None]}
//│ 	def map₀(ls³, f³) = 
//│ 		case ls³ of {
//│ 			C h² t² => [C f³(h²) map₀(t², f³)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f³(h²) map₀(t², f³)]: 54 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀(t³) | N  => [Some h³]}: 66
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀(t³) | N  => [Some h³]} | N  => [None]}: 68
//│ [N]: 55 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀(t³) | N  => [Some h³]}: 66
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀(t³) | N  => [Some h³]} | N  => [None]}: 68
//│ ------------------
//│ case t³ of {C hh¹ tt¹ => last₀(t³) | N  => [Some h³]}: 66 --->
//│ 	[C f³(h²) map₀(t², f³)]: 54
//│ 	[N]: 55
//│ case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀(t³) | N  => [Some h³]} | N  => [None]}: 68 --->
//│ 	[C f³(h²) map₀(t², f³)]: 54
//│ 	[N]: 55
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap₀
//│ def lastMap₀(ls⁴, f⁴) = 
//│ 	last₀(map₀(ls⁴, f⁴))
//│ 	where
//│ 	def last₀(xs²) = 
//│ 		case xs² of {
//│ 			C h³ t³ => case t³ of {
//│ 				C hh¹ tt¹ => last₀(t³)
//│ 				| N  => [Some h³]}
//│ 			| N  => [None]}
//│ 	def map₀(ls⁵, f⁵) = 
//│ 		case ls⁵ of {
//│ 			C h² t² => [C f⁵(h²) map₀(t², f⁵)]
//│ 			| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: replace the `t` in the previous `last(t)` into `C(h, t)`, still no fusion done
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
fun lastMap(ls, f) = last(map(ls, f))
lastMap
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|#fun| |lastMap|(|ls|,| |f|)| |#=| |last|(|map|(|ls|,| |f|)|)|↵|lastMap|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; fun lastMap = ls, f, => last (map (ls, f,),); lastMap}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastMap^37
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last^28(map^29(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastMap^37]
//│ 	[lastMap^37 · last^28] (hopeless to continue)
//│ 		[lastMap^37 · last^28 · last^17] ---> [lastMap^37 · last^28] (using original def)
//│ 	[lastMap^37 · map^29]
//│ 		[lastMap^37 · map^29 · map^5] ---> [lastMap^37 · map^29] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastMap₀
//│ def lastMap₀(ls², f²) = 
//│ 	last₀(map₀(ls², f²))
//│ 	where
//│ 	def last₀(xs¹) = 
//│ 		case xs¹ of {
//│ 			C h² t² => case t² of {
//│ 				C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 				| N  => [Some h²]}
//│ 			| N  => [None]}
//│ 	def map₀(ls³, f³) = 
//│ 		case ls³ of {
//│ 			C h³ t³ => [C f³(h³) map₀(t³, f³)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 52 --->
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 58
//│ [C f³(h³) map₀(t³, f³)]: 69 --->
//│ 	case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]}: 56
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 58
//│ [N]: 70 --->
//│ 	case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]}: 56
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 58
//│ ------------------
//│ case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]}: 56 --->
//│ 	[C f³(h³) map₀(t³, f³)]: 69
//│ 	[N]: 70
//│ case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 58 --->
//│ 	[C hh¹ tt¹]: 52
//│ 	[C f³(h³) map₀(t³, f³)]: 69
//│ 	[N]: 70
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap₀
//│ def lastMap₀(ls⁴, f⁴) = 
//│ 	last₀(map₀(ls⁴, f⁴))
//│ 	where
//│ 	def last₀(xs²) = 
//│ 		case xs² of {
//│ 			C h² t² => case t² of {
//│ 				C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 				| N  => [Some h²]}
//│ 			| N  => [None]}
//│ 	def map₀(ls⁵, f⁵) = 
//│ 		case ls⁵ of {
//│ 			C h³ t³ => [C f⁵(h³) map₀(t³, f⁵)]
//│ 			| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<


// NOTE: pass primitives as parameters, sitll no fusion done
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
fun lastMap(ls, f) = last(map(ls, f))
lastMap(primitive, primitive)
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|#fun| |lastMap|(|ls|,| |f|)| |#=| |last|(|map|(|ls|,| |f|)|)|↵|lastMap|(|primitive|,| |primitive|)|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; fun lastMap = ls, f, => last (map (ls, f,),); lastMap (primitive, primitive,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastMap^37(primitive⁰, primitive⁰)
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def lastMap(ls¹, f¹) = last^28(map^29(ls¹, f¹))
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastMap^37]
//│ 	[lastMap^37 · last^28] (hopeless to continue)
//│ 		[lastMap^37 · last^28 · last^17] ---> [lastMap^37 · last^28] (using original def)
//│ 	[lastMap^37 · map^29]
//│ 		[lastMap^37 · map^29 · map^5] ---> [lastMap^37 · map^29] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ lastMap₀(primitive⁰, primitive⁰)
//│ def lastMap₀(ls², f²) = 
//│ 	last₀(map₀(ls², f²))
//│ 	where
//│ 	def last₀(xs¹) = 
//│ 		case xs¹ of {
//│ 			C h² t² => case t² of {
//│ 				C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 				| N  => [Some h²]}
//│ 			| N  => [None]}
//│ 	def map₀(ls³, f³) = 
//│ 		case ls³ of {
//│ 			C h³ t³ => [C f³(h³) map₀(t³, f³)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C hh¹ tt¹]: 56 --->
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 62
//│ [C f³(h³) map₀(t³, f³)]: 73 --->
//│ 	case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]}: 60
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 62
//│ [N]: 74 --->
//│ 	case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]}: 60
//│ 	case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 62
//│ ------------------
//│ case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]}: 60 --->
//│ 	[C f³(h³) map₀(t³, f³)]: 73
//│ 	[N]: 74
//│ case xs¹ of {C h² t² => case t² of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h²]} | N  => [None]}: 62 --->
//│ 	[C hh¹ tt¹]: 56
//│ 	[C f³(h³) map₀(t³, f³)]: 73
//│ 	[N]: 74
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastMap₀(primitive⁰, primitive⁰)
//│ def lastMap₀(ls⁴, f⁴) = 
//│ 	last₀(map₀(ls⁴, f⁴))
//│ 	where
//│ 	def last₀(xs²) = 
//│ 		case xs² of {
//│ 			C h² t² => case t² of {
//│ 				C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 				| N  => [Some h²]}
//│ 			| N  => [None]}
//│ 	def map₀(ls⁵, f⁵) = 
//│ 		case ls⁵ of {
//│ 			C h³ t³ => [C f⁵(h³) map₀(t³, f⁵)]
//│ 			| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: this even does some function call pattern specialization for the last
// and the only difference is that map now is unrolled twice
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun last(xs) = if xs is
  C(h, t) then if t is
    C(hh, tt) then last(C(hh, tt))
    N then Some(h)
  N then None
last(map(primitive, primitive))
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |last|(|xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |last|(|C|(|hh|,| |tt|)|)|↵|N| |#then| |Some|(|h|)|←|↵|N| |#then| |None|←|↵|last|(|map|(|primitive|,| |primitive|)|)|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun last = xs, => if xs is ‹(C (h, t,)) then if t is ‹(C (hh, tt,)) then last (C (hh, tt,),); (N) then Some (h,)›; (N) then None›; last (map (primitive, primitive,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ last^28(map^29(primitive⁰, primitive⁰))
//│ def last(xs⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => case t¹ of {
//│ 		C hh⁰ tt⁰ => last^17([C hh⁰ tt⁰])
//│ 		| N  => [Some h¹]}
//│ 	| N  => [None]}
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(t⁰, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [last^28]
//│ 	[last^28 · last^17] ---> [last^28] (only one)
//│ [map^29]
//│ 	[map^29 · map^5] ---> [map^29] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ last₀(map₀(primitive⁰, primitive⁰))
//│ def last₀(xs¹) = 
//│ 	case xs¹ of {
//│ 		C h³ t³ => case t³ of {
//│ 			C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 			| N  => [Some h³]}
//│ 		| N  => [None]}
//│ def map₀(ls¹, f¹) = 
//│ 	case ls¹ of {
//│ 		C h² t² => [C f¹(h²) map₀(t², f¹)]
//│ 		| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f¹(h²) map₀(t², f¹)]: 44 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]}: 58
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 60
//│ [N]: 45 --->
//│ 	case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]}: 58
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 60
//│ [C hh¹ tt¹]: 54 --->
//│ 	case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 60
//│ ------------------
//│ case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]}: 58 --->
//│ 	[C f¹(h²) map₀(t², f¹)]: 44
//│ 	[N]: 45
//│ case xs¹ of {C h³ t³ => case t³ of {C hh¹ tt¹ => last₀([C hh¹ tt¹]) | N  => [Some h³]} | N  => [None]}: 60 --->
//│ 	[C f¹(h²) map₀(t², f¹)]: 44
//│ 	[N]: 45
//│ 	[C hh¹ tt¹]: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ last₀(map₀(primitive⁰, primitive⁰))
//│ def last₀(xs²) = 
//│ 	case xs² of {
//│ 		C h³ t³ => case t³ of {
//│ 			C hh¹ tt¹ => last₀([C hh¹ tt¹])
//│ 			| N  => [Some h³]}
//│ 		| N  => [None]}
//│ def map₀(ls², f²) = 
//│ 	case ls² of {
//│ 		C h² t² => [C f²(h²) map₀(t², f²)]
//│ 		| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<


