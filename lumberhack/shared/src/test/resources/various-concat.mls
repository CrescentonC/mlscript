:NewParser
:ParseOnly

// original append, nothing is fused
_LUMBERHACK_EVAL
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun appendThree(xs, ys, zs) =
  append(append(xs, ys), zs)
appendThree(
  primId(C(1, C(2, N))),
  primId(C(3, C(4, N))),
  primId(C(5, C(6, N)))
)
//│ |_LUMBERHACK_EVAL|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |appendThree|(|xs|,| |ys|,| |zs|)| |#=|→|append|(|append|(|xs|,| |ys|)|,| |zs|)|←|↵|appendThree|(|→|primId|(|C|(|1|,| |C|(|2|,| |N|)|)|)|,|↵|primId|(|C|(|3|,| |C|(|4|,| |N|)|)|)|,|↵|primId|(|C|(|5|,| |C|(|6|,| |N|)|)|)|←|↵|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun appendThree = xs, ys, zs, => {append (append (xs, ys,), zs,)}; appendThree (primId (C (1, C (2, N,),),), primId (C (3, C (4, N,),),), primId (C (5, C (6, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ appendThree^25(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def appendThree(xs¹, ys¹, zs⁰) = append^13(append^14(xs¹, ys¹), zs⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [appendThree^25]
//│ 	[appendThree^25 · append^13]
//│ 		[appendThree^25 · append^13 · append^3] ---> [appendThree^25 · append^13] (only one)
//│ 	[appendThree^25 · append^14]
//│ 		[appendThree^25 · append^14 · append^3] ---> [appendThree^25 · append^14] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ appendThree₀(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def appendThree₀(xs², ys², zs¹) = 
//│ 	append₀(append₁(xs², ys²), zs¹)
//│ 	where
//│ 	def append₀(xs⁴, ys⁴) = 
//│ 		case xs⁴ of {
//│ 			C h² t² => [C h² append₀(t², ys⁴)]
//│ 			| N  => ys⁴}
//│ 	def append₁(xs³, ys³) = 
//│ 		case xs³ of {
//│ 			C h¹ t¹ => [C h¹ append₁(t¹, ys³)]
//│ 			| N  => ys³}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ append₁(t¹, ys³)]: 69 --->
//│ 	case xs⁴ of {C h² t² => [C h² append₀(t², ys⁴)] | N  => ys⁴}: 83
//│ ------------------
//│ case xs⁴ of {C h² t² => [C h² append₀(t², ys⁴)] | N  => ys⁴}: 83 --->
//│ 	NoProd
//│ 	[C h¹ append₁(t¹, ys³)]: 69
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ appendThree₀(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def appendThree₀(xs⁵, ys⁵, zs²) = 
//│ 	append₀(append₁(xs⁵, ys⁵), zs²)
//│ 	where
//│ 	def append₀(xs⁷, ys⁷) = 
//│ 		case xs⁷ of {
//│ 			C h² t² => [C h² append₀(t², ys⁷)]
//│ 			| N  => ys⁷}
//│ 	def append₁(xs⁶, ys⁶) = 
//│ 		case xs⁶ of {
//│ 			C h¹ t¹ => [C h¹ append₁(t¹, ys⁶)]
//│ 			| N  => ys⁶}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<< evaluate <<<<<<<

// original append, duplicated append
_LUMBERHACK_EVAL
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun append'(xs, ys) = if xs is
  C(h, t) then C(h, append'(t, ys))
  N then ys
fun appendThree(xs, ys, zs) =
  append(append'(xs, ys), zs)
appendThree(
  primId(C(1, C(2, N))),
  primId(C(3, C(4, N))),
  primId(C(5, C(6, N)))
)
//│ |_LUMBERHACK_EVAL|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |append'|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append'|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |appendThree|(|xs|,| |ys|,| |zs|)| |#=|→|append|(|append'|(|xs|,| |ys|)|,| |zs|)|←|↵|appendThree|(|→|primId|(|C|(|1|,| |C|(|2|,| |N|)|)|)|,|↵|primId|(|C|(|3|,| |C|(|4|,| |N|)|)|)|,|↵|primId|(|C|(|5|,| |C|(|6|,| |N|)|)|)|←|↵|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun append' = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append' (t, ys,),); (N) then ys›; fun appendThree = xs, ys, zs, => {append (append' (xs, ys,), zs,)}; appendThree (primId (C (1, C (2, N,),),), primId (C (3, C (4, N,),),), primId (C (5, C (6, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ appendThree^37(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def append'(xs¹, ys¹) = case xs¹ of {
//│ 	C h¹ t¹ => [C h¹ append'^15(t¹, ys¹)]
//│ 	| N  => ys¹}
//│ def appendThree(xs², ys², zs⁰) = append^25(append'^26(xs², ys²), zs⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [appendThree^37]
//│ 	[appendThree^37 · append'^26]
//│ 		[appendThree^37 · append'^26 · append'^15] ---> [appendThree^37 · append'^26] (only one)
//│ 	[appendThree^37 · append^25]
//│ 		[appendThree^37 · append^25 · append^3] ---> [appendThree^37 · append^25] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ appendThree₀(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def appendThree₀(xs³, ys³, zs¹) = 
//│ 	append₀(append'₀(xs³, ys³), zs¹)
//│ 	where
//│ 	def append'₀(xs⁴, ys⁴) = 
//│ 		case xs⁴ of {
//│ 			C h² t² => [C h² append'₀(t², ys⁴)]
//│ 			| N  => ys⁴}
//│ 	def append₀(xs⁵, ys⁵) = 
//│ 		case xs⁵ of {
//│ 			C h³ t³ => [C h³ append₀(t³, ys⁵)]
//│ 			| N  => ys⁵}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h² append'₀(t², ys⁴)]: 81 --->
//│ 	case xs⁵ of {C h³ t³ => [C h³ append₀(t³, ys⁵)] | N  => ys⁵}: 95
//│ ------------------
//│ case xs⁵ of {C h³ t³ => [C h³ append₀(t³, ys⁵)] | N  => ys⁵}: 95 --->
//│ 	NoProd
//│ 	[C h² append'₀(t², ys⁴)]: 81
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ appendThree₀(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def appendThree₀(xs⁶, ys⁶, zs²) = 
//│ 	append₀(append'₀(xs⁶, ys⁶), zs²)
//│ 	where
//│ 	def append'₀(xs⁷, ys⁷) = 
//│ 		case xs⁷ of {
//│ 			C h² t² => [C h² append'₀(t², ys⁷)]
//│ 			| N  => ys⁷}
//│ 	def append₀(xs⁸, ys⁸) = 
//│ 		case xs⁸ of {
//│ 			C h³ t³ => [C h³ append₀(t³, ys⁸)]
//│ 			| N  => ys⁸}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<< evaluate <<<<<<<

// original append, duplicated append, but the input is `fromTo`
_LUMBERHACK_EVAL
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun append'(xs, ys) = if xs is
  C(h, t) then C(h, append'(t, ys))
  N then ys
fun appendThree(xs, ys, zs) =
  append(append'(xs, ys), zs)
fun fromTo(a, b) = if a < b then C(a, fromTo(a + 1, b)) else N
fun main(a, b) = appendThree(fromTo(a, b), fromTo(a, b), fromTo(a, b))
main(11, 22)
//│ |_LUMBERHACK_EVAL|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |append'|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append'|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |appendThree|(|xs|,| |ys|,| |zs|)| |#=|→|append|(|append'|(|xs|,| |ys|)|,| |zs|)|←|↵|#fun| |fromTo|(|a|,| |b|)| |#=| |#if| |a| |<| |b| |#then| |C|(|a|,| |fromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |main|(|a|,| |b|)| |#=| |appendThree|(|fromTo|(|a|,| |b|)|,| |fromTo|(|a|,| |b|)|,| |fromTo|(|a|,| |b|)|)|↵|main|(|11|,| |22|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun append' = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append' (t, ys,),); (N) then ys›; fun appendThree = xs, ys, zs, => {append (append' (xs, ys,), zs,)}; fun fromTo = a, b, => if (< (a,) (b,)) then C (a, fromTo (+ (a,) (1,), b,),) else N; fun main = a, b, => appendThree (fromTo (a, b,), fromTo (a, b,), fromTo (a, b,),); main (11, 22,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^78(11, 22)
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def append'(xs¹, ys¹) = case xs¹ of {
//│ 	C h¹ t¹ => [C h¹ append'^15(t¹, ys¹)]
//│ 	| N  => ys¹}
//│ def appendThree(xs², ys², zs⁰) = append^25(append'^26(xs², ys²), zs⁰)
//│ def fromTo(a⁰, b⁰) = if (a⁰ < b⁰) then [C a⁰ fromTo^43((a⁰ + 1), b⁰)] else [N]
//│ def main(a¹, b¹) = appendThree^57(fromTo^58(a¹, b¹), fromTo^64(a¹, b¹), fromTo^70(a¹, b¹))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 11 [C 12 [C 13 [C 14 [C 15 [C 16 [C 17 [C 18 [C 19 [C 20 [C 21 [C 11 [C 12 [C 13 [C 14 [C 15 [C 16 [C 17 [C 18 [C 19 [C 20 [C 21 [C 11 [C 12 [C 13 [C 14 [C 15 [C 16 [C 17 [C 18 [C 19 [C 20 [C 21 [N]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [main^78]
//│ 	[main^78 · appendThree^57]
//│ 		[main^78 · appendThree^57 · append'^26] (hopeless to continue)
//│ 			[main^78 · appendThree^57 · append'^26 · append'^15] ---> [main^78 · appendThree^57 · append'^26] (using original def)
//│ 		[main^78 · appendThree^57 · append^25]
//│ 			[main^78 · appendThree^57 · append^25 · append^3] ---> [main^78 · appendThree^57 · append^25] (only one)
//│ 	[main^78 · fromTo^58] (hopeless to continue)
//│ 		[main^78 · fromTo^58 · fromTo^43] ---> [main^78 · fromTo^58] (using original def)
//│ 	[main^78 · fromTo^64] (hopeless to continue)
//│ 		[main^78 · fromTo^64 · fromTo^43] ---> [main^78 · fromTo^64] (using original def)
//│ 	[main^78 · fromTo^70]
//│ 		[main^78 · fromTo^70 · fromTo^43] ---> [main^78 · fromTo^70] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ main₀(11, 22)
//│ def main₀(a⁵, b⁵) = 
//│ 	appendThree₀(fromTo₀(a⁵, b⁵), fromTo₁(a⁵, b⁵), fromTo₂(a⁵, b⁵))
//│ 	where
//│ 	def appendThree₀(xs⁵, ys⁵, zs¹) = 
//│ 		append₀(append'₀(xs⁵, ys⁵), zs¹)
//│ 		where
//│ 		def append'₀(xs⁴, ys⁴) = 
//│ 			case xs⁴ of {
//│ 				C h³ t³ => [C h³ append'₀(t³, ys⁴)]
//│ 				| N  => ys⁴}
//│ 		def append₀(xs³, ys³) = 
//│ 			case xs³ of {
//│ 				C h² t² => [C h² append₀(t², ys³)]
//│ 				| N  => ys³}
//│ 	def fromTo₀(a³, b³) = 
//│ 		if (a³ < b³) then [C a³ fromTo₀((a³ + 1), b³)] else [N]
//│ 	def fromTo₁(a⁴, b⁴) = 
//│ 		if (a⁴ < b⁴) then [C a⁴ fromTo₁((a⁴ + 1), b⁴)] else [N]
//│ 	def fromTo₂(a², b²) = 
//│ 		if (a² < b²) then [C a² fromTo₂((a² + 1), b²)] else [N]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a³ fromTo₀((a³ + 1), b³)]: 130 --->
//│ 	case xs⁴ of {C h³ t³ => [C h³ append'₀(t³, ys⁴)] | N  => ys⁴}: 144
//│ [N]: 131 --->
//│ 	case xs⁴ of {C h³ t³ => [C h³ append'₀(t³, ys⁴)] | N  => ys⁴}: 144
//│ [C h³ append'₀(t³, ys⁴)]: 142 --->
//│ 	case xs³ of {C h² t² => [C h² append₀(t², ys³)] | N  => ys³}: 112
//│ [C a⁴ fromTo₁((a⁴ + 1), b⁴)]: 162 --->
//│ 	case xs³ of {C h² t² => [C h² append₀(t², ys³)] | N  => ys³}: 112
//│ [N]: 163 --->
//│ 	case xs³ of {C h² t² => [C h² append₀(t², ys³)] | N  => ys³}: 112
//│ ------------------
//│ case xs³ of {C h² t² => [C h² append₀(t², ys³)] | N  => ys³}: 112 --->
//│ 	[C h³ append'₀(t³, ys⁴)]: 142
//│ 	[C a⁴ fromTo₁((a⁴ + 1), b⁴)]: 162
//│ 	[N]: 163
//│ case xs⁴ of {C h³ t³ => [C h³ append'₀(t³, ys⁴)] | N  => ys⁴}: 144 --->
//│ 	[C a³ fromTo₀((a³ + 1), b³)]: 130
//│ 	[N]: 131
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C a³ fromTo₀((a³ + 1), b³)]: 130 --->
//│ 	case xs⁴ of {C h³ t³ => [C h³ append'₀(t³, ys⁴)] | N  => ys⁴}: 144
//│ [N]: 131 --->
//│ 	case xs⁴ of {C h³ t³ => [C h³ append'₀(t³, ys⁴)] | N  => ys⁴}: 144
//│ [C h³ append'₀(t³, ys⁴)]: 142 --->
//│ 	case xs³ of {C h² t² => [C h² append₀(t², ys³)] | N  => ys³}: 112
//│ [C a⁴ fromTo₁((a⁴ + 1), b⁴)]: 162 --->
//│ 	case xs³ of {C h² t² => [C h² append₀(t², ys³)] | N  => ys³}: 112
//│ [N]: 163 --->
//│ 	case xs³ of {C h² t² => [C h² append₀(t², ys³)] | N  => ys³}: 112
//│ ------------------
//│ case xs³ of {C h² t² => [C h² append₀(t², ys³)] | N  => ys³}: 112 --->
//│ 	[C h³ append'₀(t³, ys⁴)]: 142
//│ 	[C a⁴ fromTo₁((a⁴ + 1), b⁴)]: 162
//│ 	[N]: 163
//│ case xs⁴ of {C h³ t³ => [C h³ append'₀(t³, ys⁴)] | N  => ys⁴}: 144 --->
//│ 	[C a³ fromTo₀((a³ + 1), b³)]: 130
//│ 	[N]: 131
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main₀(11, 22)
//│ def main₀(a⁶, b⁶) = 
//│ 	appendThree₀(fromTo₀(a⁶, b⁶), fromTo₁(a⁶, b⁶), fromTo₂(a⁶, b⁶))
//│ 	where
//│ 	def appendThree₀(xs⁷, ys⁷, zs²) = 
//│ 		append₀(append'₀(xs⁷, ys⁷), zs²)
//│ 		where
//│ 		def append'₀(xs⁶, ys⁶) = 
//│ 			xs⁶(ys⁶)
//│ 		def append₀(xs⁸, ys¹³) = 
//│ 			xs⁸(ys¹³)
//│ 	def fromTo₀(a⁹, b⁹) = 
//│ 		if (a⁹ < b⁹) then 
//│ 			let t⁵ = fromTo₀((a⁹ + 1), b⁹)
//│ 			in let h⁵ = a⁹
//│ 			in (fun ys¹⁰ -> 
//│ 				let t⁶ = append'₀(t⁵, ys¹⁰)
//│ 				in let h⁶ = h⁵
//│ 				in (fun ys¹¹ -> [C h⁶ append₀(t⁶, ys¹¹)])) else (fun ys¹² -> ys¹²)
//│ 	def fromTo₁(a⁸, b⁸) = 
//│ 		if (a⁸ < b⁸) then 
//│ 			let t⁴ = fromTo₁((a⁸ + 1), b⁸)
//│ 			in let h⁴ = a⁸
//│ 			in (fun ys⁸ -> [C h⁴ append₀(t⁴, ys⁸)]) else (fun ys⁹ -> ys⁹)
//│ 	def fromTo₂(a⁷, b⁷) = 
//│ 		if (a⁷ < b⁷) then [C a⁷ fromTo₂((a⁷ + 1), b⁷)] else [N]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 11 [C 12 [C 13 [C 14 [C 15 [C 16 [C 17 [C 18 [C 19 [C 20 [C 21 [C 11 [C 12 [C 13 [C 14 [C 15 [C 16 [C 17 [C 18 [C 19 [C 20 [C 21 [C 11 [C 12 [C 13 [C 14 [C 15 [C 16 [C 17 [C 18 [C 19 [C 20 [C 21 [N]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
//│ <<<<<<< evaluate <<<<<<<


// append where recursive `idList` is used
// now this `appendThree(xs, ys, zs)` is like `concat [xs, ys, zs]`, where if we do not optimize
// the last `idList` call on `zs`, the `zs` will also be traversed once, hence less efficient
// than the version in the deforestation by wadler
_LUMBERHACK_EVAL
fun idList(l) = if l is
  C(h, t) then C(h, idList(t))
  N then N
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then idList(ys)
fun appendThree(xs, ys, zs) =
  append(append(xs, ys), zs)
appendThree(
  primId(C(1, C(2, N))),
  primId(C(3, C(4, N))),
  primId(C(5, C(6, N)))
)
//│ |_LUMBERHACK_EVAL|↵|#fun| |idList|(|l|)| |#=| |#if| |l| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |idList|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |idList|(|ys|)|←|↵|#fun| |appendThree|(|xs|,| |ys|,| |zs|)| |#=|→|append|(|append|(|xs|,| |ys|)|,| |zs|)|←|↵|appendThree|(|→|primId|(|C|(|1|,| |C|(|2|,| |N|)|)|)|,|↵|primId|(|C|(|3|,| |C|(|4|,| |N|)|)|)|,|↵|primId|(|C|(|5|,| |C|(|6|,| |N|)|)|)|←|↵|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun idList = l, => if l is ‹(C (h, t,)) then C (h, idList (t,),); (N) then N›; fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then idList (ys,)›; fun appendThree = xs, ys, zs, => {append (append (xs, ys,), zs,)}; appendThree (primId (C (1, C (2, N,),),), primId (C (3, C (4, N,),),), primId (C (5, C (6, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ appendThree^36(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => [C h¹ append^12(t¹, ys⁰)]
//│ 	| N  => idList^18(ys⁰)}
//│ def appendThree(xs¹, ys¹, zs⁰) = append^24(append^25(xs¹, ys¹), zs⁰)
//│ def idList(l⁰) = case l⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ idList^3(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [appendThree^36]
//│ 	[appendThree^36 · append^24]
//│ 		[appendThree^36 · append^24 · append^12] ---> [appendThree^36 · append^24] (only one)
//│ 		[appendThree^36 · append^24 · idList^18] (hopeless to continue)
//│ 			[appendThree^36 · append^24 · idList^18 · idList^3] ---> [appendThree^36 · append^24 · idList^18] (using original def)
//│ 	[appendThree^36 · append^25]
//│ 		[appendThree^36 · append^25 · append^12] ---> [appendThree^36 · append^25] (only one)
//│ 		[appendThree^36 · append^25 · idList^18]
//│ 			[appendThree^36 · append^25 · idList^18 · idList^3] ---> [appendThree^36 · append^25 · idList^18] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ appendThree₀(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def appendThree₀(xs², ys², zs¹) = 
//│ 	append₀(append₁(xs², ys²), zs¹)
//│ 	where
//│ 	def append₀(xs⁴, ys⁴) = 
//│ 		case xs⁴ of {
//│ 			C h⁵ t⁵ => [C h⁵ append₀(t⁵, ys⁴)]
//│ 			| N  => idList₀(ys⁴)}
//│ 		where
//│ 		def idList₀(l¹) = 
//│ 			case l¹ of {
//│ 				C h² t² => [C h² idList₀(t²)]
//│ 				| N  => [N]}
//│ 	def append₁(xs³, ys³) = 
//│ 		case xs³ of {
//│ 			C h⁴ t⁴ => [C h⁴ append₁(t⁴, ys³)]
//│ 			| N  => idList₁(ys³)}
//│ 		where
//│ 		def idList₁(l²) = 
//│ 			case l² of {
//│ 				C h³ t³ => [C h³ idList₁(t³)]
//│ 				| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h³ idList₁(t³)]: 87 --->
//│ 	case xs⁴ of {C h⁵ t⁵ => [C h⁵ append₀(t⁵, ys⁴)] | N  => idList₀(ys⁴)}: 116
//│ [N]: 88 --->
//│ 	case xs⁴ of {C h⁵ t⁵ => [C h⁵ append₀(t⁵, ys⁴)] | N  => idList₀(ys⁴)}: 116
//│ [C h⁴ append₁(t⁴, ys³)]: 98 --->
//│ 	case xs⁴ of {C h⁵ t⁵ => [C h⁵ append₀(t⁵, ys⁴)] | N  => idList₀(ys⁴)}: 116
//│ ------------------
//│ case xs⁴ of {C h⁵ t⁵ => [C h⁵ append₀(t⁵, ys⁴)] | N  => idList₀(ys⁴)}: 116 --->
//│ 	[C h³ idList₁(t³)]: 87
//│ 	[N]: 88
//│ 	[C h⁴ append₁(t⁴, ys³)]: 98
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h³ idList₁(t³)]: 87 --->
//│ 	case xs⁴ of {C h⁵ t⁵ => [C h⁵ append₀(t⁵, ys⁴)] | N  => idList₀(ys⁴)}: 116
//│ [N]: 88 --->
//│ 	case xs⁴ of {C h⁵ t⁵ => [C h⁵ append₀(t⁵, ys⁴)] | N  => idList₀(ys⁴)}: 116
//│ [C h⁴ append₁(t⁴, ys³)]: 98 --->
//│ 	case xs⁴ of {C h⁵ t⁵ => [C h⁵ append₀(t⁵, ys⁴)] | N  => idList₀(ys⁴)}: 116
//│ ------------------
//│ case xs⁴ of {C h⁵ t⁵ => [C h⁵ append₀(t⁵, ys⁴)] | N  => idList₀(ys⁴)}: 116 --->
//│ 	[C h³ idList₁(t³)]: 87
//│ 	[N]: 88
//│ 	[C h⁴ append₁(t⁴, ys³)]: 98
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ appendThree₀(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def appendThree₀(xs⁶, ys⁹, zs²) = 
//│ 	append₀(append₁(xs⁶, ys⁹), zs²)
//│ 	where
//│ 	def append₀(xs⁷, ys¹⁰) = 
//│ 		xs⁷(ys¹⁰)
//│ 		where
//│ 		def idList₀(l⁴) = 
//│ 			case l⁴ of {
//│ 				C h² t² => [C h² idList₀(t²)]
//│ 				| N  => [N]}
//│ 	def append₁(xs⁵, ys⁵) = 
//│ 		case xs⁵ of {
//│ 			C h⁴ t⁴ => 
//│ 				let t⁶ = append₁(t⁴, ys⁵)
//│ 				in let h⁶ = h⁴
//│ 				in (fun ys⁶ -> [C h⁶ append₀(t⁶, ys⁶)])
//│ 			| N  => idList₁(ys⁵)}
//│ 		where
//│ 		def idList₁(l³) = 
//│ 			case l³ of {
//│ 				C h³ t³ => 
//│ 					let t⁷ = idList₁(t³)
//│ 					in let h⁷ = h³
//│ 					in (fun ys⁷ -> [C h⁷ append₀(t⁷, ys⁷)])
//│ 				| N  => (fun ys⁸ -> idList₀(ys⁸))}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<< evaluate <<<<<<<



// concat using append without idList
_LUMBERHACK_EVAL
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun concat(lss) = if lss is
  C(hh, tt) then append(hh, concat(tt))
  N then N
fun main(xss) =
  concat(xss)
main(primId(C(
  C(1, C(2, N)),
  C(
    C(3, C(4, N)),
    C(
      C(5, C(6, N)),
      N
    )
  )
)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |concat|(|lss|)| |#=| |#if| |lss| |is|→|C|(|hh|,| |tt|)| |#then| |append|(|hh|,| |concat|(|tt|)|)|↵|N| |#then| |N|←|↵|#fun| |main|(|xss|)| |#=|→|concat|(|xss|)|←|↵|main|(|primId|(|C|(|→|C|(|1|,| |C|(|2|,| |N|)|)|,|↵|C|(|→|C|(|3|,| |C|(|4|,| |N|)|)|,|↵|C|(|→|C|(|5|,| |C|(|6|,| |N|)|)|,|↵|N|←|↵|)|←|↵|)|←|↵|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun concat = lss, => if lss is ‹(C (hh, tt,)) then append (hh, concat (tt,),); (N) then N›; fun main = xss, => {concat (xss,)}; main (primId (C (C (1, C (2, N,),), C (C (3, C (4, N,),), C (C (5, C (6, N,),), N,),),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^28(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def concat(lss⁰) = case lss⁰ of {
//│ 	C hh⁰ tt⁰ => append^14(hh⁰, concat^17(tt⁰))
//│ 	| N  => [N]}
//│ def main(xss⁰) = concat^24(xss⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [main^28]
//│ 	[main^28 · concat^24]
//│ 		[main^28 · concat^24 · append^14]
//│ 			[main^28 · concat^24 · append^14 · append^3] ---> [main^28 · concat^24 · append^14] (only one)
//│ 		[main^28 · concat^24 · concat^17] ---> [main^28 · concat^24] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ main₀(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def main₀(xss¹) = 
//│ 	concat₀(xss¹)
//│ 	where
//│ 	def concat₀(lss¹) = 
//│ 		case lss¹ of {
//│ 			C hh¹ tt¹ => append₀(hh¹, concat₀(tt¹))
//│ 			| N  => [N]}
//│ 		where
//│ 		def append₀(xs¹, ys¹) = 
//│ 			case xs¹ of {
//│ 				C h¹ t¹ => [C h¹ append₀(t¹, ys¹)]
//│ 				| N  => ys¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main₀(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def main₀(xss²) = 
//│ 	concat₀(xss²)
//│ 	where
//│ 	def concat₀(lss²) = 
//│ 		case lss² of {
//│ 			C hh¹ tt¹ => append₀(hh¹, concat₀(tt¹))
//│ 			| N  => [N]}
//│ 		where
//│ 		def append₀(xs², ys²) = 
//│ 			case xs² of {
//│ 				C h¹ t¹ => [C h¹ append₀(t¹, ys²)]
//│ 				| N  => ys²}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<< evaluate <<<<<<<


// optimized concat function by list comprehension, no fusion done
// concat(lss) = [ x | xs <- lss, x <- xs ]
_LUMBERHACK_EVAL
let concat = lss => if lss is
  C(h, t) then if h is
    xs then
      let ok2 = args2 => if args2 is
        C(h, t) then if h is
          x then C(x, ok2(t))
          _ then ok2(t)
        _ then concat(t)
      ok2(xs)
    _ then concat(t)
  _ then N
fun main(xss) =
  concat(xss)
main(primId(C(
  C(1, C(2, N)),
  C(
    C(3, C(4, N)),
    C(
      C(5, C(6, N)),
      N
    )
  )
)))
//│ |_LUMBERHACK_EVAL|↵|#let| |concat| |#=| |lss| |=>| |#if| |lss| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |is|→|xs| |#then|→|#let| |ok2| |#=| |args2| |=>| |#if| |args2| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |is|→|x| |#then| |C|(|x|,| |ok2|(|t|)|)|↵|_| |#then| |ok2|(|t|)|←|↵|_| |#then| |concat|(|t|)|←|↵|ok2|(|xs|)|←|↵|_| |#then| |concat|(|t|)|←|↵|_| |#then| |N|←|↵|#fun| |main|(|xss|)| |#=|→|concat|(|xss|)|←|↵|main|(|primId|(|C|(|→|C|(|1|,| |C|(|2|,| |N|)|)|,|↵|C|(|→|C|(|3|,| |C|(|4|,| |N|)|)|,|↵|C|(|→|C|(|5|,| |C|(|6|,| |N|)|)|,|↵|N|←|↵|)|←|↵|)|←|↵|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; let concat = lss, => if lss is ‹(C (h, t,)) then if h is ‹(xs) then {let ok2 = args2, => if args2 is ‹(C (h, t,)) then if h is ‹(x) then C (x, ok2 (t,),); (_) then ok2 (t,)›; (_) then concat (t,)›; ok2 (xs,)}; (_) then concat (t,)›; (_) then N›; fun main = xss, => {concat (xss,)}; main (primId (C (C (1, C (2, N,),), C (C (3, C (4, N,),), C (C (5, C (6, N,),), N,),),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^34(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def concat(lss⁰) = case lss⁰ of {
//│ 	C h⁰ t⁰ => case h⁰ of {
//│ 		xs⁰ => 
//│ 			let ok2⁰ = (fun args2⁰ -> case args2⁰ of {
//│ 				C h¹ t¹ => case h¹ of {
//│ 					x⁰ => [C x⁰ ok2⁰(t¹)]
//│ 					| _  => ok2⁰(t¹)}
//│ 				| _  => concat^14(t⁰)})
//│ 			in ok2⁰(xs⁰)
//│ 		| _  => concat^23(t⁰)}
//│ 	| _  => [N]}
//│ def main(xss⁰) = concat^30(xss⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [main^34]
//│ 	[main^34 · concat^30]
//│ 		[main^34 · concat^30 · concat^14] (hopeless to continue)
//│ 			[main^34 · concat^30 · concat^14 · concat^14] ---> [main^34 · concat^30 · concat^14] (using original def)
//│ 			[main^34 · concat^30 · concat^14 · concat^23] ---> [main^34 · concat^30 · concat^14] (using original def)
//│ 		[main^34 · concat^30 · concat^23] ---> [main^34 · concat^30] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ main₀(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def main₀(xss¹) = 
//│ 	concat₀(xss¹)
//│ 	where
//│ 	def concat₀(lss¹) = 
//│ 		case lss¹ of {
//│ 			C h² t² => case h² of {
//│ 				xs¹ => 
//│ 					let ok2¹ = (fun args2¹ -> case args2¹ of {
//│ 						C h³ t³ => case h³ of {
//│ 							x¹ => [C x¹ ok2¹(t³)]
//│ 							| _  => ok2¹(t³)}
//│ 						| _  => concat₁(t²)})
//│ 					in ok2¹(xs¹)
//│ 				| _  => concat₀(t²)}
//│ 			| _  => [N]}
//│ 		where
//│ 		def concat₁(lss²) = 
//│ 			case lss² of {
//│ 				C h⁴ t⁴ => case h⁴ of {
//│ 					xs² => 
//│ 						let ok2² = (fun args2² -> case args2² of {
//│ 							C h⁵ t⁵ => case h⁵ of {
//│ 								x² => [C x² ok2²(t⁵)]
//│ 								| _  => ok2²(t⁵)}
//│ 							| _  => concat₁(t⁴)})
//│ 						in ok2²(xs²)
//│ 					| _  => concat₁(t⁴)}
//│ 				| _  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main₀(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def main₀(xss²) = 
//│ 	concat₀(xss²)
//│ 	where
//│ 	def concat₀(lss³) = 
//│ 		case lss³ of {
//│ 			C h² t² => case h² of {
//│ 				xs¹ => 
//│ 					let ok2³ = (fun args2³ -> case args2³ of {
//│ 						C h³ t³ => case h³ of {
//│ 							x¹ => [C x¹ ok2³(t³)]
//│ 							| _  => ok2³(t³)}
//│ 						| _  => concat₁(t²)})
//│ 					in ok2³(xs¹)
//│ 				| _  => concat₀(t²)}
//│ 			| _  => [N]}
//│ 		where
//│ 		def concat₁(lss⁴) = 
//│ 			case lss⁴ of {
//│ 				C h⁴ t⁴ => case h⁴ of {
//│ 					xs² => 
//│ 						let ok2⁴ = (fun args2⁴ -> case args2⁴ of {
//│ 							C h⁵ t⁵ => case h⁵ of {
//│ 								x² => [C x² ok2⁴(t⁵)]
//│ 								| _  => ok2⁴(t⁵)}
//│ 							| _  => concat₁(t⁴)})
//│ 						in ok2⁴(xs²)
//│ 					| _  => concat₁(t⁴)}
//│ 				| _  => [N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<< evaluate <<<<<<<

// optimized concat function by taking out the inner lambda, no fusion done
_LUMBERHACK_EVAL
fun concat(lss) = if lss is
  C(hh, tt) then concatInner(hh, tt)
  N then N
fun concatInner(xs, xss) = if xs is
  C(h, t) then C(h, concatInner(t, xss))
  N then concat(xss)
fun main(xss) =
  concat(xss)
main(primId(C(
  C(1, C(2, N)),
  C(
    C(3, C(4, N)),
    C(
      C(5, C(6, N)),
      N
    )
  )
)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|lss|)| |#=| |#if| |lss| |is|→|C|(|hh|,| |tt|)| |#then| |concatInner|(|hh|,| |tt|)|↵|N| |#then| |N|←|↵|#fun| |concatInner|(|xs|,| |xss|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |concatInner|(|t|,| |xss|)|)|↵|N| |#then| |concat|(|xss|)|←|↵|#fun| |main|(|xss|)| |#=|→|concat|(|xss|)|←|↵|main|(|primId|(|C|(|→|C|(|1|,| |C|(|2|,| |N|)|)|,|↵|C|(|→|C|(|3|,| |C|(|4|,| |N|)|)|,|↵|C|(|→|C|(|5|,| |C|(|6|,| |N|)|)|,|↵|N|←|↵|)|←|↵|)|←|↵|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = lss, => if lss is ‹(C (hh, tt,)) then concatInner (hh, tt,); (N) then N›; fun concatInner = xs, xss, => if xs is ‹(C (h, t,)) then C (h, concatInner (t, xss,),); (N) then concat (xss,)›; fun main = xss, => {concat (xss,)}; main (primId (C (C (1, C (2, N,),), C (C (3, C (4, N,),), C (C (5, C (6, N,),), N,),),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^28(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def concat(lss⁰) = case lss⁰ of {
//│ 	C hh⁰ tt⁰ => concatInner^2(hh⁰, tt⁰)
//│ 	| N  => [N]}
//│ def concatInner(xs⁰, xss⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ concatInner^12(t⁰, xss⁰)]
//│ 	| N  => concat^18(xss⁰)}
//│ def main(xss¹) = concat^24(xss¹)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [main^28]
//│ 	[main^28 · concat^24]
//│ 		[main^28 · concat^24 · concatInner^2]
//│ 			[main^28 · concat^24 · concatInner^2 · concatInner^12] ---> [main^28 · concat^24 · concatInner^2] (only one)
//│ 			[main^28 · concat^24 · concatInner^2 · concat^18] ---> [main^28 · concat^24] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ main₀(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def main₀(xss³) = 
//│ 	concat₀(xss³)
//│ 	where
//│ 	def concat₀(lss¹) = 
//│ 		case lss¹ of {
//│ 			C hh¹ tt¹ => concatInner₀(hh¹, tt¹)
//│ 			| N  => [N]}
//│ 		where
//│ 		def concatInner₀(xs¹, xss²) = 
//│ 			case xs¹ of {
//│ 				C h¹ t¹ => [C h¹ concatInner₀(t¹, xss²)]
//│ 				| N  => concat₀(xss²)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main₀(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def main₀(xss⁵) = 
//│ 	concat₀(xss⁵)
//│ 	where
//│ 	def concat₀(lss²) = 
//│ 		case lss² of {
//│ 			C hh¹ tt¹ => concatInner₀(hh¹, tt¹)
//│ 			| N  => [N]}
//│ 		where
//│ 		def concatInner₀(xs², xss⁴) = 
//│ 			case xs² of {
//│ 				C h¹ t¹ => [C h¹ concatInner₀(t¹, xss⁴)]
//│ 				| N  => concat₀(xss⁴)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
