:NewParser
:ParseOnly

// original append, nothing is fused
_LUMBERHACK_EVAL
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun appendThree(xs, ys, zs) =
  append(append(xs, ys), zs)
appendThree(
  primId(C(1, C(2, N))),
  primId(C(3, C(4, N))),
  primId(C(5, C(6, N)))
)
//│ |_LUMBERHACK_EVAL|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |appendThree|(|xs|,| |ys|,| |zs|)| |#=|→|append|(|append|(|xs|,| |ys|)|,| |zs|)|←|↵|appendThree|(|→|primId|(|C|(|1|,| |C|(|2|,| |N|)|)|)|,|↵|primId|(|C|(|3|,| |C|(|4|,| |N|)|)|)|,|↵|primId|(|C|(|5|,| |C|(|6|,| |N|)|)|)|←|↵|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun appendThree = xs, ys, zs, => {append (append (xs, ys,), zs,)}; appendThree (primId (C (1, C (2, N,),),), primId (C (3, C (4, N,),),), primId (C (5, C (6, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ appendThree^25(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def appendThree(xs¹, ys¹, zs⁰) = append^13(append^14(xs¹, ys¹), zs⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ append(t⁰, ys⁰)]: 8 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10 --->
//│ 	NoProd
//│ 	[C h⁰ append(t⁰, ys⁰)]: 8
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ appendThree(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs², ys²) = case xs² of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys²)]
//│ 	| N  => ys²}
//│ def appendThree(xs³, ys³, zs¹) = append(append(xs³, ys³), zs¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ appendThree(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def appendThree(xs¹, ys¹, zs⁰) = append(append(xs¹, ys¹), zs⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ appendThree(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def appendThree(xs¹, ys¹, zs⁰) = append(append(xs¹, ys¹), zs⁰)
//│ <<<<<<< after floating out <<<<<<<

// original append, duplicated append
_LUMBERHACK_EVAL
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun append'(xs, ys) = if xs is
  C(h, t) then C(h, append'(t, ys))
  N then ys
fun appendThree(xs, ys, zs) =
  append(append'(xs, ys), zs)
appendThree(
  primId(C(1, C(2, N))),
  primId(C(3, C(4, N))),
  primId(C(5, C(6, N)))
)
//│ |_LUMBERHACK_EVAL|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |append'|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append'|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |appendThree|(|xs|,| |ys|,| |zs|)| |#=|→|append|(|append'|(|xs|,| |ys|)|,| |zs|)|←|↵|appendThree|(|→|primId|(|C|(|1|,| |C|(|2|,| |N|)|)|)|,|↵|primId|(|C|(|3|,| |C|(|4|,| |N|)|)|)|,|↵|primId|(|C|(|5|,| |C|(|6|,| |N|)|)|)|←|↵|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun append' = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append' (t, ys,),); (N) then ys›; fun appendThree = xs, ys, zs, => {append (append' (xs, ys,), zs,)}; appendThree (primId (C (1, C (2, N,),),), primId (C (3, C (4, N,),),), primId (C (5, C (6, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ appendThree^37(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def append'(xs¹, ys¹) = case xs¹ of {
//│ 	C h¹ t¹ => [C h¹ append'^15(t¹, ys¹)]
//│ 	| N  => ys¹}
//│ def appendThree(xs², ys², zs⁰) = append^25(append'^26(xs², ys²), zs⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ append'(t¹, ys¹)]: 20 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10 --->
//│ 	NoProd
//│ 	[C h¹ append'(t¹, ys¹)]: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ appendThree(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs³, ys³) = case xs³ of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys³)]
//│ 	| N  => ys³}
//│ def append'(xs⁴, ys⁴) = case xs⁴ of {
//│ 	C h¹ t¹ => [C h¹ append'(t¹, ys⁴)]
//│ 	| N  => ys⁴}
//│ def appendThree(xs⁵, ys⁵, zs¹) = append(append'(xs⁵, ys⁵), zs¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ appendThree(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def append'(xs¹, ys¹) = case xs¹ of {
//│ 	C h¹ t¹ => [C h¹ append'(t¹, ys¹)]
//│ 	| N  => ys¹}
//│ def appendThree(xs², ys², zs⁰) = append(append'(xs², ys²), zs⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ appendThree(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def append'(xs¹, ys¹) = case xs¹ of {
//│ 	C h¹ t¹ => [C h¹ append'(t¹, ys¹)]
//│ 	| N  => ys¹}
//│ def appendThree(xs², ys², zs⁰) = append(append'(xs², ys²), zs⁰)
//│ <<<<<<< after floating out <<<<<<<

// original append, duplicated append, but the input is `fromTo`
_LUMBERHACK_EVAL
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun append'(xs, ys) = if xs is
  C(h, t) then C(h, append'(t, ys))
  N then ys
fun appendThree(xs, ys, zs) =
  append(append'(xs, ys), zs)
fun fromTo(a, b) = if a < b then C(a, fromTo(a + 1, b)) else N
fun main(a, b) = appendThree(fromTo(a, b), fromTo(a, b), fromTo(a, b))
main(11, 22)
//│ |_LUMBERHACK_EVAL|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |append'|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append'|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |appendThree|(|xs|,| |ys|,| |zs|)| |#=|→|append|(|append'|(|xs|,| |ys|)|,| |zs|)|←|↵|#fun| |fromTo|(|a|,| |b|)| |#=| |#if| |a| |<| |b| |#then| |C|(|a|,| |fromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |main|(|a|,| |b|)| |#=| |appendThree|(|fromTo|(|a|,| |b|)|,| |fromTo|(|a|,| |b|)|,| |fromTo|(|a|,| |b|)|)|↵|main|(|11|,| |22|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun append' = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append' (t, ys,),); (N) then ys›; fun appendThree = xs, ys, zs, => {append (append' (xs, ys,), zs,)}; fun fromTo = a, b, => if (< (a,) (b,)) then C (a, fromTo (+ (a,) (1,), b,),) else N; fun main = a, b, => appendThree (fromTo (a, b,), fromTo (a, b,), fromTo (a, b,),); main (11, 22,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^78(11, 22)
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def append'(xs¹, ys¹) = case xs¹ of {
//│ 	C h¹ t¹ => [C h¹ append'^15(t¹, ys¹)]
//│ 	| N  => ys¹}
//│ def appendThree(xs², ys², zs⁰) = append^25(append'^26(xs², ys²), zs⁰)
//│ def fromTo(a⁰, b⁰) = if (a⁰ < b⁰) then [C a⁰ fromTo^43((a⁰ + 1), b⁰)] else [N]
//│ def main(a¹, b¹) = appendThree^57(fromTo^58(a¹, b¹), fromTo^64(a¹, b¹), fromTo^70(a¹, b¹))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 11 [C 12 [C 13 [C 14 [C 15 [C 16 [C 17 [C 18 [C 19 [C 20 [C 21 [C 11 [C 12 [C 13 [C 14 [C 15 [C 16 [C 17 [C 18 [C 19 [C 20 [C 21 [C 11 [C 12 [C 13 [C 14 [C 15 [C 16 [C 17 [C 18 [C 19 [C 20 [C 21 [N]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ append'(t¹, ys¹)]: 20 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [C a⁰ fromTo((a⁰ + 1), b⁰)]: 52 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ 	case xs¹ of {C h¹ t¹ => [C h¹ append'(t¹, ys¹)] | N  => ys¹}: 22
//│ [N]: 53 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ 	case xs¹ of {C h¹ t¹ => [C h¹ append'(t¹, ys¹)] | N  => ys¹}: 22
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10 --->
//│ 	[C h¹ append'(t¹, ys¹)]: 20
//│ 	[C a⁰ fromTo((a⁰ + 1), b⁰)]: 52
//│ 	[N]: 53
//│ case xs¹ of {C h¹ t¹ => [C h¹ append'(t¹, ys¹)] | N  => ys¹}: 22 --->
//│ 	[C a⁰ fromTo((a⁰ + 1), b⁰)]: 52
//│ 	[N]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main(11, 22)
//│ def append(xs⁴, ys⁴) = case xs⁴ of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁴)]
//│ 	| N  => ys⁴}
//│ def append'(xs³, ys³) = case xs³ of {
//│ 	C h¹ t¹ => [C h¹ append'(t¹, ys³)]
//│ 	| N  => ys³}
//│ def appendThree(xs⁵, ys⁵, zs¹) = append(append'(xs⁵, ys⁵), zs¹)
//│ def fromTo(a³, b³) = if (a³ < b³) then [C a³ fromTo((a³ + 1), b³)] else [N]
//│ def main(a², b²) = appendThree(fromTo(a², b²), fromTo(a², b²), fromTo(a², b²))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 11 [C 12 [C 13 [C 14 [C 15 [C 16 [C 17 [C 18 [C 19 [C 20 [C 21 [C 11 [C 12 [C 13 [C 14 [C 15 [C 16 [C 17 [C 18 [C 19 [C 20 [C 21 [C 11 [C 12 [C 13 [C 14 [C 15 [C 16 [C 17 [C 18 [C 19 [C 20 [C 21 [N]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ main(11, 22)
//│ def append(xs¹, ys¹) = case xs¹ of {
//│ 	C h¹ t¹ => [C h¹ append(t¹, ys¹)]
//│ 	| N  => ys¹}
//│ def append'(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append'(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def appendThree(xs², ys², zs⁰) = append(append'(xs², ys²), zs⁰)
//│ def fromTo(a¹, b¹) = if (a¹ < b¹) then [C a¹ fromTo((a¹ + 1), b¹)] else [N]
//│ def main(a⁰, b⁰) = appendThree(fromTo(a⁰, b⁰), fromTo(a⁰, b⁰), fromTo(a⁰, b⁰))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ main(11, 22)
//│ def append(xs¹, ys¹) = case xs¹ of {
//│ 	C h¹ t¹ => [C h¹ append(t¹, ys¹)]
//│ 	| N  => ys¹}
//│ def append'(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append'(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def appendThree(xs², ys², zs⁰) = append(append'(xs², ys²), zs⁰)
//│ def fromTo(a¹, b¹) = if (a¹ < b¹) then [C a¹ fromTo((a¹ + 1), b¹)] else [N]
//│ def main(a⁰, b⁰) = appendThree(fromTo(a⁰, b⁰), fromTo(a⁰, b⁰), fromTo(a⁰, b⁰))
//│ <<<<<<< after floating out <<<<<<<


// append where recursive `idList` is used
// now this `appendThree(xs, ys, zs)` is like `concat [xs, ys, zs]`, where if we do not optimize
// the last `idList` call on `zs`, the `zs` will also be traversed once, hence less efficient
// than the version in the deforestation by wadler
_LUMBERHACK_EVAL
fun idList(l) = if l is
  C(h, t) then C(h, idList(t))
  N then N
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then idList(ys)
fun appendThree(xs, ys, zs) =
  append(append(xs, ys), zs)
appendThree(
  primId(C(1, C(2, N))),
  primId(C(3, C(4, N))),
  primId(C(5, C(6, N)))
)
//│ |_LUMBERHACK_EVAL|↵|#fun| |idList|(|l|)| |#=| |#if| |l| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |idList|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |idList|(|ys|)|←|↵|#fun| |appendThree|(|xs|,| |ys|,| |zs|)| |#=|→|append|(|append|(|xs|,| |ys|)|,| |zs|)|←|↵|appendThree|(|→|primId|(|C|(|1|,| |C|(|2|,| |N|)|)|)|,|↵|primId|(|C|(|3|,| |C|(|4|,| |N|)|)|)|,|↵|primId|(|C|(|5|,| |C|(|6|,| |N|)|)|)|←|↵|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun idList = l, => if l is ‹(C (h, t,)) then C (h, idList (t,),); (N) then N›; fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then idList (ys,)›; fun appendThree = xs, ys, zs, => {append (append (xs, ys,), zs,)}; appendThree (primId (C (1, C (2, N,),),), primId (C (3, C (4, N,),),), primId (C (5, C (6, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ appendThree^36(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => [C h¹ append^12(t¹, ys⁰)]
//│ 	| N  => idList^18(ys⁰)}
//│ def appendThree(xs¹, ys¹, zs⁰) = append^24(append^25(xs¹, ys¹), zs⁰)
//│ def idList(l⁰) = case l⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ idList^3(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ idList(t⁰)]: 6 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h¹ t¹ => [C h¹ append(t¹, ys⁰)] | N  => idList(ys⁰)}: 21
//│ [N]: 7 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h¹ t¹ => [C h¹ append(t¹, ys⁰)] | N  => idList(ys⁰)}: 21
//│ [C h¹ append(t¹, ys⁰)]: 17 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h¹ t¹ => [C h¹ append(t¹, ys⁰)] | N  => idList(ys⁰)}: 21
//│ ------------------
//│ case xs⁰ of {C h¹ t¹ => [C h¹ append(t¹, ys⁰)] | N  => idList(ys⁰)}: 21 --->
//│ 	NoProd
//│ 	[C h⁰ idList(t⁰)]: 6
//│ 	[N]: 7
//│ 	[C h¹ append(t¹, ys⁰)]: 17
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ appendThree(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs², ys²) = case xs² of {
//│ 	C h¹ t¹ => [C h¹ append(t¹, ys²)]
//│ 	| N  => idList(ys²)}
//│ def appendThree(xs³, ys³, zs¹) = append(append(xs³, ys³), zs¹)
//│ def idList(l¹) = case l¹ of {
//│ 	C h⁰ t⁰ => [C h⁰ idList(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ appendThree(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => [C h¹ append(t¹, ys⁰)]
//│ 	| N  => idList(ys⁰)}
//│ def appendThree(xs¹, ys¹, zs⁰) = append(append(xs¹, ys¹), zs⁰)
//│ def idList(l⁰) = case l⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ idList(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ appendThree(primId⁰([C 1 [C 2 [N]]]), primId⁰([C 3 [C 4 [N]]]), primId⁰([C 5 [C 6 [N]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => [C h¹ append(t¹, ys⁰)]
//│ 	| N  => idList(ys⁰)}
//│ def appendThree(xs¹, ys¹, zs⁰) = append(append(xs¹, ys¹), zs⁰)
//│ def idList(l⁰) = case l⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ idList(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<< after floating out <<<<<<<



// concat using append without idList
_LUMBERHACK_EVAL
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun concat(lss) = if lss is
  C(hh, tt) then append(hh, concat(tt))
  N then N
fun main(xss) =
  concat(xss)
main(primId(C(
  C(1, C(2, N)),
  C(
    C(3, C(4, N)),
    C(
      C(5, C(6, N)),
      N
    )
  )
)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |concat|(|lss|)| |#=| |#if| |lss| |is|→|C|(|hh|,| |tt|)| |#then| |append|(|hh|,| |concat|(|tt|)|)|↵|N| |#then| |N|←|↵|#fun| |main|(|xss|)| |#=|→|concat|(|xss|)|←|↵|main|(|primId|(|C|(|→|C|(|1|,| |C|(|2|,| |N|)|)|,|↵|C|(|→|C|(|3|,| |C|(|4|,| |N|)|)|,|↵|C|(|→|C|(|5|,| |C|(|6|,| |N|)|)|,|↵|N|←|↵|)|←|↵|)|←|↵|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun concat = lss, => if lss is ‹(C (hh, tt,)) then append (hh, concat (tt,),); (N) then N›; fun main = xss, => {concat (xss,)}; main (primId (C (C (1, C (2, N,),), C (C (3, C (4, N,),), C (C (5, C (6, N,),), N,),),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^28(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def concat(lss⁰) = case lss⁰ of {
//│ 	C hh⁰ tt⁰ => append^14(hh⁰, concat^17(tt⁰))
//│ 	| N  => [N]}
//│ def main(xss⁰) = concat^24(xss⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def append(xs¹, ys¹) = case xs¹ of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys¹)]
//│ 	| N  => ys¹}
//│ def concat(lss¹) = case lss¹ of {
//│ 	C hh⁰ tt⁰ => append(hh⁰, concat(tt⁰))
//│ 	| N  => [N]}
//│ def main(xss¹) = concat(xss¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ main(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def concat(lss⁰) = case lss⁰ of {
//│ 	C hh⁰ tt⁰ => append(hh⁰, concat(tt⁰))
//│ 	| N  => [N]}
//│ def main(xss⁰) = concat(xss⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ main(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def concat(lss⁰) = case lss⁰ of {
//│ 	C hh⁰ tt⁰ => append(hh⁰, concat(tt⁰))
//│ 	| N  => [N]}
//│ def main(xss⁰) = concat(xss⁰)
//│ <<<<<<< after floating out <<<<<<<


// optimized concat function by list comprehension, no fusion done
// concat(lss) = [ x | xs <- lss, x <- xs ]
_LUMBERHACK_EVAL
let concat = lss => if lss is
  C(h, t) then if h is
    xs then
      let ok2 = args2 => if args2 is
        C(h, t) then if h is
          x then C(x, ok2(t))
          _ then ok2(t)
        _ then concat(t)
      ok2(xs)
    _ then concat(t)
  _ then N
fun main(xss) =
  concat(xss)
main(primId(C(
  C(1, C(2, N)),
  C(
    C(3, C(4, N)),
    C(
      C(5, C(6, N)),
      N
    )
  )
)))
//│ |_LUMBERHACK_EVAL|↵|#let| |concat| |#=| |lss| |=>| |#if| |lss| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |is|→|xs| |#then|→|#let| |ok2| |#=| |args2| |=>| |#if| |args2| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |is|→|x| |#then| |C|(|x|,| |ok2|(|t|)|)|↵|_| |#then| |ok2|(|t|)|←|↵|_| |#then| |concat|(|t|)|←|↵|ok2|(|xs|)|←|↵|_| |#then| |concat|(|t|)|←|↵|_| |#then| |N|←|↵|#fun| |main|(|xss|)| |#=|→|concat|(|xss|)|←|↵|main|(|primId|(|C|(|→|C|(|1|,| |C|(|2|,| |N|)|)|,|↵|C|(|→|C|(|3|,| |C|(|4|,| |N|)|)|,|↵|C|(|→|C|(|5|,| |C|(|6|,| |N|)|)|,|↵|N|←|↵|)|←|↵|)|←|↵|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; let concat = lss, => if lss is ‹(C (h, t,)) then if h is ‹(xs) then {let ok2 = args2, => if args2 is ‹(C (h, t,)) then if h is ‹(x) then C (x, ok2 (t,),); (_) then ok2 (t,)›; (_) then concat (t,)›; ok2 (xs,)}; (_) then concat (t,)›; (_) then N›; fun main = xss, => {concat (xss,)}; main (primId (C (C (1, C (2, N,),), C (C (3, C (4, N,),), C (C (5, C (6, N,),), N,),),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^34(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def concat(lss⁰) = case lss⁰ of {
//│ 	C h⁰ t⁰ => case h⁰ of {
//│ 		xs⁰ => 
//│ 			let ok2⁰ = (fun args2⁰ -> case args2⁰ of {
//│ 				C h¹ t¹ => case h¹ of {
//│ 					x⁰ => [C x⁰ ok2⁰(t¹)]
//│ 					| _  => ok2⁰(t¹)}
//│ 				| _  => concat^14(t⁰)})
//│ 			in ok2⁰(xs⁰)
//│ 		| _  => concat^23(t⁰)}
//│ 	| _  => [N]}
//│ def main(xss⁰) = concat^30(xss⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def concat(lss¹) = case lss¹ of {
//│ 	C h⁰ t⁰ => case h⁰ of {
//│ 		xs⁰ => 
//│ 			let ok2¹ = (fun args2¹ -> case args2¹ of {
//│ 				C h¹ t¹ => case h¹ of {
//│ 					x⁰ => [C x⁰ ok2¹(t¹)]
//│ 					| _  => ok2¹(t¹)}
//│ 				| _  => concat(t⁰)})
//│ 			in ok2¹(xs⁰)
//│ 		| _  => concat(t⁰)}
//│ 	| _  => [N]}
//│ def main(xss¹) = concat(xss¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ main(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def concat(lss⁰) = case lss⁰ of {
//│ 	C h⁰ t⁰ => case h⁰ of {
//│ 		xs⁰ => 
//│ 			let ok2⁰ = (fun args2⁰ -> case args2⁰ of {
//│ 				C h¹ t¹ => case h¹ of {
//│ 					x⁰ => [C x⁰ ok2⁰(t¹)]
//│ 					| _  => ok2⁰(t¹)}
//│ 				| _  => concat(t⁰)})
//│ 			in ok2⁰(xs⁰)
//│ 		| _  => concat(t⁰)}
//│ 	| _  => [N]}
//│ def main(xss⁰) = concat(xss⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ main(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def concat(lss⁰) = case lss⁰ of {
//│ 	C h⁰ t⁰ => case h⁰ of {
//│ 		xs⁰ => 
//│ 			let ok2⁰ = (fun args2⁰ -> case args2⁰ of {
//│ 				C h¹ t¹ => case h¹ of {
//│ 					x⁰ => [C x⁰ ok2⁰(t¹)]
//│ 					| _  => ok2⁰(t¹)}
//│ 				| _  => concat(t⁰)})
//│ 			in ok2⁰(xs⁰)
//│ 		| _  => concat(t⁰)}
//│ 	| _  => [N]}
//│ def main(xss⁰) = concat(xss⁰)
//│ <<<<<<< after floating out <<<<<<<

// optimized concat function by taking out the inner lambda, no fusion done
_LUMBERHACK_EVAL
fun concat(lss) = if lss is
  C(hh, tt) then concatInner(hh, tt)
  N then N
fun concatInner(xs, xss) = if xs is
  C(h, t) then C(h, concatInner(t, xss))
  N then concat(xss)
fun main(xss) =
  concat(xss)
main(primId(C(
  C(1, C(2, N)),
  C(
    C(3, C(4, N)),
    C(
      C(5, C(6, N)),
      N
    )
  )
)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |concat|(|lss|)| |#=| |#if| |lss| |is|→|C|(|hh|,| |tt|)| |#then| |concatInner|(|hh|,| |tt|)|↵|N| |#then| |N|←|↵|#fun| |concatInner|(|xs|,| |xss|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |concatInner|(|t|,| |xss|)|)|↵|N| |#then| |concat|(|xss|)|←|↵|#fun| |main|(|xss|)| |#=|→|concat|(|xss|)|←|↵|main|(|primId|(|C|(|→|C|(|1|,| |C|(|2|,| |N|)|)|,|↵|C|(|→|C|(|3|,| |C|(|4|,| |N|)|)|,|↵|C|(|→|C|(|5|,| |C|(|6|,| |N|)|)|,|↵|N|←|↵|)|←|↵|)|←|↵|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun concat = lss, => if lss is ‹(C (hh, tt,)) then concatInner (hh, tt,); (N) then N›; fun concatInner = xs, xss, => if xs is ‹(C (h, t,)) then C (h, concatInner (t, xss,),); (N) then concat (xss,)›; fun main = xss, => {concat (xss,)}; main (primId (C (C (1, C (2, N,),), C (C (3, C (4, N,),), C (C (5, C (6, N,),), N,),),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^28(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def concat(lss⁰) = case lss⁰ of {
//│ 	C hh⁰ tt⁰ => concatInner^2(hh⁰, tt⁰)
//│ 	| N  => [N]}
//│ def concatInner(xs⁰, xss⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ concatInner^12(t⁰, xss⁰)]
//│ 	| N  => concat^18(xss⁰)}
//│ def main(xss¹) = concat^24(xss¹)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def concat(lss¹) = case lss¹ of {
//│ 	C hh⁰ tt⁰ => concatInner(hh⁰, tt⁰)
//│ 	| N  => [N]}
//│ def concatInner(xs¹, xss²) = case xs¹ of {
//│ 	C h⁰ t⁰ => [C h⁰ concatInner(t⁰, xss²)]
//│ 	| N  => concat(xss²)}
//│ def main(xss³) = concat(xss³)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 2 [C 3 [C 4 [C 5 [C 6 [N]]]]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ main(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def concat(lss⁰) = case lss⁰ of {
//│ 	C hh⁰ tt⁰ => concatInner(hh⁰, tt⁰)
//│ 	| N  => [N]}
//│ def concatInner(xs⁰, xss⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ concatInner(t⁰, xss⁰)]
//│ 	| N  => concat(xss⁰)}
//│ def main(xss¹) = concat(xss¹)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ main(primId⁰([C [C 1 [C 2 [N]]] [C [C 3 [C 4 [N]]] [C [C 5 [C 6 [N]]] [N]]]]))
//│ def concat(lss⁰) = case lss⁰ of {
//│ 	C hh⁰ tt⁰ => concatInner(hh⁰, tt⁰)
//│ 	| N  => [N]}
//│ def concatInner(xs⁰, xss⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ concatInner(t⁰, xss⁰)]
//│ 	| N  => concat(xss⁰)}
//│ def main(xss¹) = concat(xss¹)
//│ <<<<<<< after floating out <<<<<<<
