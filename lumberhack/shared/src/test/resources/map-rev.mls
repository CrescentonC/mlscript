:NewParser
:ParseOnly

// CORRECT: the single rev can work, multiple ctor to one dtor will be no problem
_LUMBERHACK_EVAL
fun rev(ls) = if ls is
  N then a => a
  C(h, t) then a => rev(t)(C(h, a))
rev(C(AA, C(BB, C(CC, N))))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a| |=>| |a|↵|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|←|↵|rev|(|C|(|AA|,| |C|(|BB|,| |C|(|CC|,| |N|)|)|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ls, => if ls is ‹(N) then a, => a; (C (h, t,)) then a, => rev (t,) (C (h, a,),)›; rev (C (AA, C (BB, C (CC, N,),),),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev^14 [C [AA] [C [BB] [C [CC] [N]]]]) [N])
//│ def rev = (fun ls⁰ -> case ls⁰ of {
//│ 	N  => (fun a⁰ -> a⁰)
//│ 	| C h⁰ t⁰ => (fun a¹ -> ((rev^4 t⁰) [C h⁰ a¹]))})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [CC] [C [BB] [C [AA] [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [rev^14] (hopeless to continue)
//│ 	[rev^14 · rev^4] ---> [rev^14] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev₀ [C [AA] [C [BB] [C [CC] [N]]]]) [N])
//│ def rev₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		N  => (fun a² -> a²)
//│ 		| C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 42 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ [C [CC] [N]]: 43 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ [C [BB] [C [CC] [N]]]: 44 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ [C [AA] [C [BB] [C [CC] [N]]]]: 45 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ ------------------
//│ case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36 --->
//│ 	[N]: 42
//│ 	[C [CC] [N]]: 43
//│ 	[C [BB] [C [CC] [N]]]: 44
//│ 	[C [AA] [C [BB] [C [CC] [N]]]]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 42 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ [C [CC] [N]]: 43 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ [C [BB] [C [CC] [N]]]: 44 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ [C [AA] [C [BB] [C [CC] [N]]]]: 45 --->
//│ 	case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36
//│ ------------------
//│ case ls¹ of {N  => (fun a² -> a²) | C h¹ t¹ => (fun a³ -> ((rev₀ t¹) [C h¹ a³]))}: 36 --->
//│ 	[N]: 42
//│ 	[C [CC] [N]]: 43
//│ 	[C [BB] [C [CC] [N]]]: 44
//│ 	[C [AA] [C [BB] [C [CC] [N]]]]: 45
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev₀ 
//│ 	let h² = [AA]
//│ 	in let t² = 	
//│ 		let h³ = [BB]
//│ 		in let t³ = 	
//│ 			let h⁴ = [CC]
//│ 			in let t⁴ = (fun a⁷ -> a⁷)
//│ 			in (fun a⁶ -> ((rev₀ t⁴) [C h⁴ a⁶]))
//│ 		in (fun a⁵ -> ((rev₀ t³) [C h³ a⁵]))
//│ 	in (fun a⁴ -> ((rev₀ t²) [C h² a⁴]))) [N])
//│ def rev₀ = 
//│ 	(fun ls² -> ls²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [CC] [C [BB] [C [AA] [N]]]]
//│ <<<<<<< evaluate <<<<<<<


_LUMBERHACK_EVAL
fun rev(ys) = if ys is
  N then a => a
  C(h, t) then a => rev(t)(C(h, a))
fun map(xs) = if xs is
  N then f => N
  C(h, t) then f => C(f(h), map(t)(f))
fun f(x) = if x is
  A then AA
  B then BB
rev(map(C(A, C(B, N)))(f))(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |rev|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |a| |=>| |a|↵|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|←|↵|#fun| |map|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |f| |=>| |N|↵|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|←|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|rev|(|map|(|C|(|A|,| |C|(|B|,| |N|)|)|)|(|f|)|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun rev = ys, => if ys is ‹(N) then a, => a; (C (h, t,)) then a, => rev (t,) (C (h, a,),)›; fun map = xs, => if xs is ‹(N) then f, => N; (C (h, t,)) then f, => C (f (h,), map (t,) (f,),)›; fun f = x, => if x is ‹(A) then AA; (B) then BB›; rev (map (C (A, C (B, N,),),) (f,),) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev^34 ((map^35 [C [A] [C [B] [N]]]) f^42)) [N])
//│ def f = (fun x⁰ -> case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]})
//│ def map = (fun xs⁰ -> case xs⁰ of {
//│ 	N  => (fun f¹ -> [N])
//│ 	| C h¹ t¹ => (fun f² -> [C (f² h¹) ((map^20 t¹) f²)])})
//│ def rev = (fun ys⁰ -> case ys⁰ of {
//│ 	N  => (fun a⁰ -> a⁰)
//│ 	| C h⁰ t⁰ => (fun a¹ -> ((rev^4 t⁰) [C h⁰ a¹]))})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^42] (hopeless to continue)
//│ [map^35]
//│ 	[map^35 · map^20] ---> [map^35] (only one)
//│ [rev^34]
//│ 	[rev^34 · rev^4] ---> [rev^34] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev₀ ((map₀ [C [A] [C [B] [N]]]) f₀)) [N])
//│ def f₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]})
//│ def map₀ = 
//│ 	(fun xs¹ -> case xs¹ of {
//│ 		N  => (fun f³ -> [N])
//│ 		| C h³ t³ => (fun f⁴ -> [C (f⁴ h³) ((map₀ t³) f⁴)])})
//│ def rev₀ = 
//│ 	(fun ys¹ -> case ys¹ of {
//│ 		N  => (fun a² -> a²)
//│ 		| C h² t² => (fun a³ -> ((rev₀ t²) [C h² a³]))})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 61 --->
//│ 	case ys¹ of {N  => (fun a² -> a²) | C h² t² => (fun a³ -> ((rev₀ t²) [C h² a³]))}: 58
//│ [C (f⁴ h³) ((map₀ t³) f⁴)]: 71 --->
//│ 	case ys¹ of {N  => (fun a² -> a²) | C h² t² => (fun a³ -> ((rev₀ t²) [C h² a³]))}: 58
//│ [A]: 82 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 78
//│ [B]: 83 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 78
//│ [N]: 84 --->
//│ 	case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C (f⁴ h³) ((map₀ t³) f⁴)])}: 73
//│ [C [B] [N]]: 85 --->
//│ 	case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C (f⁴ h³) ((map₀ t³) f⁴)])}: 73
//│ [C [A] [C [B] [N]]]: 86 --->
//│ 	case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C (f⁴ h³) ((map₀ t³) f⁴)])}: 73
//│ ------------------
//│ case ys¹ of {N  => (fun a² -> a²) | C h² t² => (fun a³ -> ((rev₀ t²) [C h² a³]))}: 58 --->
//│ 	[N]: 61
//│ 	[C (f⁴ h³) ((map₀ t³) f⁴)]: 71
//│ case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C (f⁴ h³) ((map₀ t³) f⁴)])}: 73 --->
//│ 	[N]: 84
//│ 	[C [B] [N]]: 85
//│ 	[C [A] [C [B] [N]]]: 86
//│ case x¹ of {A  => [AA] | B  => [BB]}: 78 --->
//│ 	[A]: 82
//│ 	[B]: 83
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 61 --->
//│ 	case ys¹ of {N  => (fun a² -> a²) | C h² t² => (fun a³ -> ((rev₀ t²) [C h² a³]))}: 58
//│ [C (f⁴ h³) ((map₀ t³) f⁴)]: 71 --->
//│ 	case ys¹ of {N  => (fun a² -> a²) | C h² t² => (fun a³ -> ((rev₀ t²) [C h² a³]))}: 58
//│ [A]: 82 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 78
//│ [B]: 83 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 78
//│ [N]: 84 --->
//│ 	case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C (f⁴ h³) ((map₀ t³) f⁴)])}: 73
//│ [C [B] [N]]: 85 --->
//│ 	case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C (f⁴ h³) ((map₀ t³) f⁴)])}: 73
//│ [C [A] [C [B] [N]]]: 86 --->
//│ 	case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C (f⁴ h³) ((map₀ t³) f⁴)])}: 73
//│ ------------------
//│ case ys¹ of {N  => (fun a² -> a²) | C h² t² => (fun a³ -> ((rev₀ t²) [C h² a³]))}: 58 --->
//│ 	[N]: 61
//│ 	[C (f⁴ h³) ((map₀ t³) f⁴)]: 71
//│ case xs¹ of {N  => (fun f³ -> [N]) | C h³ t³ => (fun f⁴ -> [C (f⁴ h³) ((map₀ t³) f⁴)])}: 73 --->
//│ 	[N]: 84
//│ 	[C [B] [N]]: 85
//│ 	[C [A] [C [B] [N]]]: 86
//│ case x¹ of {A  => [AA] | B  => [BB]}: 78 --->
//│ 	[A]: 82
//│ 	[B]: 83
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev₀ ((map₀ 
//│ 	let h⁴ = [AA]
//│ 	in let t⁴ = 	
//│ 		let h⁶ = [BB]
//│ 		in let t⁶ = (fun f⁷ -> (fun a⁶ -> a⁶))
//│ 		in (fun f⁶ -> 
//│ 			let h⁷ = (f⁶ h⁶)
//│ 			in let t⁷ = ((map₀ t⁶) f⁶)
//│ 			in (fun a⁵ -> ((rev₀ t⁷) [C h⁷ a⁵])))
//│ 	in (fun f⁵ -> 
//│ 		let h⁵ = (f⁵ h⁴)
//│ 		in let t⁵ = ((map₀ t⁴) f⁵)
//│ 		in (fun a⁴ -> ((rev₀ t⁵) [C h⁵ a⁴])))) f₀)) [N])
//│ def f₀ = 
//│ 	(fun x² -> x²)
//│ def map₀ = 
//│ 	(fun xs² -> xs²)
//│ def rev₀ = 
//│ 	(fun ys² -> ys²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<< evaluate <<<<<<<


// CORRECT:
_LUMBERHACK_EVAL
fun map(ls) = if ls is
  C(hh, tt) then C(
    (if hh is
      A then B
      AA then BB
    ),
    map(tt)
  )
  N then N
fun rev(lss) = if lss is
  C(h, t) then a => rev(t)(C(h, a))
  N then a => a
map(rev(C(A, C(AA, N)))(N))
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|hh|,| |tt|)| |#then| |C|(|→|(|#if| |hh| |is|→|A| |#then| |B|↵|AA| |#then| |BB|←|↵|)|,|↵|map|(|tt|)|←|↵|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|lss|)| |#=| |#if| |lss| |is|→|C|(|h|,| |t|)| |#then| |a| |=>| |rev|(|t|)|(|C|(|h|,| |a|)|)|↵|N| |#then| |a| |=>| |a|←|↵|map|(|rev|(|C|(|A|,| |C|(|AA|,| |N|)|)|)|(|N|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, => if ls is ‹(C (hh, tt,)) then C ('(' if hh is ‹(A) then B; (AA) then BB›, ')', map (tt,),); (N) then N›; fun rev = lss, => if lss is ‹(C (h, t,)) then a, => rev (t,) (C (h, a,),); (N) then a, => a›; map (rev (C (A, C (AA, N,),),) (N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^26 ((rev^27 [C [A] [C [AA] [N]]]) [N]))
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C hh⁰ tt⁰ => [C case hh⁰ of {
//│ 		A  => [B]
//│ 		| AA  => [BB]} (map^6 tt⁰)]
//│ 	| N  => [N]})
//│ def rev = (fun lss⁰ -> case lss⁰ of {
//│ 	C h⁰ t⁰ => (fun a⁰ -> ((rev^14 t⁰) [C h⁰ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [BB] [C [B] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [map^26]
//│ 	[map^26 · map^6] ---> [map^26] (only one)
//│ [rev^27] (hopeless to continue)
//│ 	[rev^27 · rev^14] ---> [rev^27] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (map₀ ((rev₀ [C [A] [C [AA] [N]]]) [N]))
//│ def map₀ = 
//│ 	(fun ls¹ -> case ls¹ of {
//│ 		C hh¹ tt¹ => [C case hh¹ of {
//│ 			A  => [B]
//│ 			| AA  => [BB]} (map₀ tt¹)]
//│ 		| N  => [N]})
//│ def rev₀ = 
//│ 	(fun lss¹ -> case lss¹ of {
//│ 		C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²]))
//│ 		| N  => (fun a³ -> a³)})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ a²]: 55 --->
//│ 	case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A  => [B] | AA  => [BB]} (map₀ tt¹)] | N  => [N]}: 47
//│ [A]: 64 --->
//│ 	case hh¹ of {A  => [B] | AA  => [BB]}: 41
//│ [AA]: 65 --->
//│ 	case hh¹ of {A  => [B] | AA  => [BB]}: 41
//│ [N]: 66 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N  => (fun a³ -> a³)}: 60
//│ [C [AA] [N]]: 67 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N  => (fun a³ -> a³)}: 60
//│ [C [A] [C [AA] [N]]]: 68 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N  => (fun a³ -> a³)}: 60
//│ [N]: 70 --->
//│ 	case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A  => [B] | AA  => [BB]} (map₀ tt¹)] | N  => [N]}: 47
//│ ------------------
//│ case hh¹ of {A  => [B] | AA  => [BB]}: 41 --->
//│ 	[A]: 64
//│ 	[AA]: 65
//│ case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A  => [B] | AA  => [BB]} (map₀ tt¹)] | N  => [N]}: 47 --->
//│ 	[C h¹ a²]: 55
//│ 	[N]: 70
//│ case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N  => (fun a³ -> a³)}: 60 --->
//│ 	[N]: 66
//│ 	[C [AA] [N]]: 67
//│ 	[C [A] [C [AA] [N]]]: 68
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a²]: 55 --->
//│ 	case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A  => [B] | AA  => [BB]} (map₀ tt¹)] | N  => [N]}: 47
//│ [A]: 64 --->
//│ 	case hh¹ of {A  => [B] | AA  => [BB]}: 41
//│ [AA]: 65 --->
//│ 	case hh¹ of {A  => [B] | AA  => [BB]}: 41
//│ [N]: 66 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N  => (fun a³ -> a³)}: 60
//│ [C [AA] [N]]: 67 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N  => (fun a³ -> a³)}: 60
//│ [C [A] [C [AA] [N]]]: 68 --->
//│ 	case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N  => (fun a³ -> a³)}: 60
//│ [N]: 70 --->
//│ 	case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A  => [B] | AA  => [BB]} (map₀ tt¹)] | N  => [N]}: 47
//│ ------------------
//│ case hh¹ of {A  => [B] | AA  => [BB]}: 41 --->
//│ 	[A]: 64
//│ 	[AA]: 65
//│ case ls¹ of {C hh¹ tt¹ => [C case hh¹ of {A  => [B] | AA  => [BB]} (map₀ tt¹)] | N  => [N]}: 47 --->
//│ 	[C h¹ a²]: 55
//│ 	[N]: 70
//│ case lss¹ of {C h¹ t¹ => (fun a² -> ((rev₀ t¹) [C h¹ a²])) | N  => (fun a³ -> a³)}: 60 --->
//│ 	[N]: 66
//│ 	[C [AA] [N]]: 67
//│ 	[C [A] [C [AA] [N]]]: 68
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀ ((rev₀ 
//│ 	let h² = [B]
//│ 	in let t² = 	
//│ 		let h³ = [BB]
//│ 		in let t³ = (fun a⁶ -> a⁶)
//│ 		in (fun a⁵ -> ((rev₀ t³) 
//│ 			let hh³ = h³
//│ 			in let tt³ = a⁵
//│ 			in [C hh³ (map₀ tt³)]))
//│ 	in (fun a⁴ -> ((rev₀ t²) 
//│ 		let hh² = h²
//│ 		in let tt² = a⁴
//│ 		in [C hh² (map₀ tt²)]))) [N]))
//│ def map₀ = 
//│ 	(fun ls² -> ls²)
//│ def rev₀ = 
//│ 	(fun lss² -> lss²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [BB] [C [B] [N]]]
//│ <<<<<<< evaluate <<<<<<<

_LUMBERHACK_EVAL
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun rev(a, ys) = if ys is
  C(h, t) then rev(C(h, a), t)
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
map(rev(N, C(A, C(B, N))), ff)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|map|(|rev|(|N|,| |C|(|A|,| |C|(|B|,| |N|)|)|)|,| |ff|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun rev = a, ys, => if ys is ‹(C (h, t,)) then rev (C (h, a,), t,); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; map (rev (N, C (A, C (B, N,),),), ff,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((map^32 ((rev^33 [N]) [C [A] [C [B] [N]]])) ff^43)
//│ def ff = (fun x⁰ -> case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]})
//│ def map = (fun xs⁰ -> (fun f⁰ -> case xs⁰ of {
//│ 	C h⁰ t⁰ => [C (f⁰ h⁰) ((map^5 t⁰) f⁰)]
//│ 	| N  => [N]}))
//│ def rev = (fun a⁰ -> (fun ys⁰ -> case ys⁰ of {
//│ 	C h¹ t¹ => ((rev^16 [C h¹ a⁰]) t¹)
//│ 	| N  => a⁰}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^43] (hopeless to continue)
//│ [map^32]
//│ 	[map^32 · map^5] ---> [map^32] (only one)
//│ [rev^33] (hopeless to continue)
//│ 	[rev^33 · rev^16] ---> [rev^33] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((map₀ ((rev₀ [N]) [C [A] [C [B] [N]]])) ff₀)
//│ def ff₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]})
//│ def map₀ = 
//│ 	(fun xs¹ -> (fun f¹ -> case xs¹ of {
//│ 		C h² t² => [C (f¹ h²) ((map₀ t²) f¹)]
//│ 		| N  => [N]}))
//│ def rev₀ = 
//│ 	(fun a¹ -> (fun ys¹ -> case ys¹ of {
//│ 		C h³ t³ => ((rev₀ [C h³ a¹]) t³)
//│ 		| N  => a¹}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h³ a¹]: 68 --->
//│ 	case xs¹ of {C h² t² => [C (f¹ h²) ((map₀ t²) f¹)] | N  => [N]}: 61
//│ [N]: 78 --->
//│ 	case xs¹ of {C h² t² => [C (f¹ h²) ((map₀ t²) f¹)] | N  => [N]}: 61
//│ [A]: 80 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 48
//│ [B]: 81 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 48
//│ [N]: 82 --->
//│ 	case ys¹ of {C h³ t³ => ((rev₀ [C h³ a¹]) t³) | N  => a¹}: 73
//│ [C [B] [N]]: 83 --->
//│ 	case ys¹ of {C h³ t³ => ((rev₀ [C h³ a¹]) t³) | N  => a¹}: 73
//│ [C [A] [C [B] [N]]]: 84 --->
//│ 	case ys¹ of {C h³ t³ => ((rev₀ [C h³ a¹]) t³) | N  => a¹}: 73
//│ ------------------
//│ case x¹ of {A  => [AA] | B  => [BB]}: 48 --->
//│ 	[A]: 80
//│ 	[B]: 81
//│ case xs¹ of {C h² t² => [C (f¹ h²) ((map₀ t²) f¹)] | N  => [N]}: 61 --->
//│ 	[C h³ a¹]: 68
//│ 	[N]: 78
//│ case ys¹ of {C h³ t³ => ((rev₀ [C h³ a¹]) t³) | N  => a¹}: 73 --->
//│ 	[N]: 82
//│ 	[C [B] [N]]: 83
//│ 	[C [A] [C [B] [N]]]: 84
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h³ a¹]: 68 --->
//│ 	case xs¹ of {C h² t² => [C (f¹ h²) ((map₀ t²) f¹)] | N  => [N]}: 61
//│ [N]: 78 --->
//│ 	case xs¹ of {C h² t² => [C (f¹ h²) ((map₀ t²) f¹)] | N  => [N]}: 61
//│ [A]: 80 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 48
//│ [B]: 81 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 48
//│ [N]: 82 --->
//│ 	case ys¹ of {C h³ t³ => ((rev₀ [C h³ a¹]) t³) | N  => a¹}: 73
//│ [C [B] [N]]: 83 --->
//│ 	case ys¹ of {C h³ t³ => ((rev₀ [C h³ a¹]) t³) | N  => a¹}: 73
//│ [C [A] [C [B] [N]]]: 84 --->
//│ 	case ys¹ of {C h³ t³ => ((rev₀ [C h³ a¹]) t³) | N  => a¹}: 73
//│ ------------------
//│ case x¹ of {A  => [AA] | B  => [BB]}: 48 --->
//│ 	[A]: 80
//│ 	[B]: 81
//│ case xs¹ of {C h² t² => [C (f¹ h²) ((map₀ t²) f¹)] | N  => [N]}: 61 --->
//│ 	[C h³ a¹]: 68
//│ 	[N]: 78
//│ case ys¹ of {C h³ t³ => ((rev₀ [C h³ a¹]) t³) | N  => a¹}: 73 --->
//│ 	[N]: 82
//│ 	[C [B] [N]]: 83
//│ 	[C [A] [C [B] [N]]]: 84
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((map₀ ((rev₀ (fun f² -> [N])) 
//│ 	let h⁴ = [AA]
//│ 	in let t⁴ = 	
//│ 		let h⁶ = [BB]
//│ 		in let t⁶ = (fun a⁴ -> a⁴)
//│ 		in (fun a³ -> ((rev₀ 
//│ 			let h⁷ = h⁶
//│ 			in let t⁷ = a³
//│ 			in (fun f⁴ -> [C (f⁴ h⁷) ((map₀ t⁷) f⁴)])) t⁶))
//│ 	in (fun a² -> ((rev₀ 
//│ 		let h⁵ = h⁴
//│ 		in let t⁵ = a²
//│ 		in (fun f³ -> [C (f³ h⁵) ((map₀ t⁵) f³)])) t⁴)))) ff₀)
//│ def ff₀ = 
//│ 	(fun x² -> x²)
//│ def map₀ = 
//│ 	(fun xs² -> (fun f⁵ -> (xs² f⁵)))
//│ def rev₀ = 
//│ 	(fun a⁵ -> (fun ys² -> (ys² a⁵)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<< evaluate <<<<<<<

_LUMBERHACK_EVAL
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun rev(a, ys) = if ys is
  C(h, t) then rev(C(h, a), t)
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
rev(N, map(C(A, C(B, N)), ff))
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|rev|(|N|,| |map|(|C|(|A|,| |C|(|B|,| |N|)|)|,| |ff|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun rev = a, ys, => if ys is ‹(C (h, t,)) then rev (C (h, a,), t,); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; rev (N, map (C (A, C (B, N,),), ff,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((rev^32 [N]) ((map^35 [C [A] [C [B] [N]]]) ff^42))
//│ def ff = (fun x⁰ -> case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]})
//│ def map = (fun xs⁰ -> (fun f⁰ -> case xs⁰ of {
//│ 	C h⁰ t⁰ => [C (f⁰ h⁰) ((map^5 t⁰) f⁰)]
//│ 	| N  => [N]}))
//│ def rev = (fun a⁰ -> (fun ys⁰ -> case ys⁰ of {
//│ 	C h¹ t¹ => ((rev^16 [C h¹ a⁰]) t¹)
//│ 	| N  => a⁰}))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [ff^42] (hopeless to continue)
//│ [map^35]
//│ 	[map^35 · map^5] ---> [map^35] (only one)
//│ [rev^32]
//│ 	[rev^32 · rev^16] ---> [rev^32] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((rev₀ [N]) ((map₀ [C [A] [C [B] [N]]]) ff₀))
//│ def ff₀ = 
//│ 	(fun x¹ -> case x¹ of {
//│ 		A  => [AA]
//│ 		| B  => [BB]})
//│ def map₀ = 
//│ 	(fun xs¹ -> (fun f¹ -> case xs¹ of {
//│ 		C h³ t³ => [C (f¹ h³) ((map₀ t³) f¹)]
//│ 		| N  => [N]}))
//│ def rev₀ = 
//│ 	(fun a¹ -> (fun ys¹ -> case ys¹ of {
//│ 		C h² t² => ((rev₀ [C h² a¹]) t²)
//│ 		| N  => a¹}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C (f¹ h³) ((map₀ t³) f¹)]: 66 --->
//│ 	case ys¹ of {C h² t² => ((rev₀ [C h² a¹]) t²) | N  => a¹}: 54
//│ [N]: 67 --->
//│ 	case ys¹ of {C h² t² => ((rev₀ [C h² a¹]) t²) | N  => a¹}: 54
//│ [A]: 80 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 74
//│ [B]: 81 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 74
//│ [N]: 82 --->
//│ 	case xs¹ of {C h³ t³ => [C (f¹ h³) ((map₀ t³) f¹)] | N  => [N]}: 68
//│ [C [B] [N]]: 83 --->
//│ 	case xs¹ of {C h³ t³ => [C (f¹ h³) ((map₀ t³) f¹)] | N  => [N]}: 68
//│ [C [A] [C [B] [N]]]: 84 --->
//│ 	case xs¹ of {C h³ t³ => [C (f¹ h³) ((map₀ t³) f¹)] | N  => [N]}: 68
//│ ------------------
//│ case ys¹ of {C h² t² => ((rev₀ [C h² a¹]) t²) | N  => a¹}: 54 --->
//│ 	[C (f¹ h³) ((map₀ t³) f¹)]: 66
//│ 	[N]: 67
//│ case xs¹ of {C h³ t³ => [C (f¹ h³) ((map₀ t³) f¹)] | N  => [N]}: 68 --->
//│ 	[N]: 82
//│ 	[C [B] [N]]: 83
//│ 	[C [A] [C [B] [N]]]: 84
//│ case x¹ of {A  => [AA] | B  => [BB]}: 74 --->
//│ 	[A]: 80
//│ 	[B]: 81
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C (f¹ h³) ((map₀ t³) f¹)]: 66 --->
//│ 	case ys¹ of {C h² t² => ((rev₀ [C h² a¹]) t²) | N  => a¹}: 54
//│ [N]: 67 --->
//│ 	case ys¹ of {C h² t² => ((rev₀ [C h² a¹]) t²) | N  => a¹}: 54
//│ [A]: 80 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 74
//│ [B]: 81 --->
//│ 	case x¹ of {A  => [AA] | B  => [BB]}: 74
//│ [N]: 82 --->
//│ 	case xs¹ of {C h³ t³ => [C (f¹ h³) ((map₀ t³) f¹)] | N  => [N]}: 68
//│ [C [B] [N]]: 83 --->
//│ 	case xs¹ of {C h³ t³ => [C (f¹ h³) ((map₀ t³) f¹)] | N  => [N]}: 68
//│ [C [A] [C [B] [N]]]: 84 --->
//│ 	case xs¹ of {C h³ t³ => [C (f¹ h³) ((map₀ t³) f¹)] | N  => [N]}: 68
//│ ------------------
//│ case ys¹ of {C h² t² => ((rev₀ [C h² a¹]) t²) | N  => a¹}: 54 --->
//│ 	[C (f¹ h³) ((map₀ t³) f¹)]: 66
//│ 	[N]: 67
//│ case xs¹ of {C h³ t³ => [C (f¹ h³) ((map₀ t³) f¹)] | N  => [N]}: 68 --->
//│ 	[N]: 82
//│ 	[C [B] [N]]: 83
//│ 	[C [A] [C [B] [N]]]: 84
//│ case x¹ of {A  => [AA] | B  => [BB]}: 74 --->
//│ 	[A]: 80
//│ 	[B]: 81
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((rev₀ [N]) ((map₀ 
//│ 	let h⁴ = [AA]
//│ 	in let t⁴ = 	
//│ 		let h⁶ = [BB]
//│ 		in let t⁶ = (fun f⁴ -> (fun a⁴ -> a⁴))
//│ 		in (fun f³ -> 
//│ 			let h⁷ = (f³ h⁶)
//│ 			in let t⁷ = ((map₀ t⁶) f³)
//│ 			in (fun a³ -> ((rev₀ [C h⁷ a³]) t⁷)))
//│ 	in (fun f² -> 
//│ 		let h⁵ = (f² h⁴)
//│ 		in let t⁵ = ((map₀ t⁴) f²)
//│ 		in (fun a² -> ((rev₀ [C h⁵ a²]) t⁵)))) ff₀))
//│ def ff₀ = 
//│ 	(fun x² -> x²)
//│ def map₀ = 
//│ 	(fun xs² -> (fun f⁵ -> (xs² f⁵)))
//│ def rev₀ = 
//│ 	(fun a⁵ -> (fun ys² -> (ys² a⁵)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [BB] [C [AA] [N]]]
//│ <<<<<<< evaluate <<<<<<<

// NOTE: this example works when no concrete input is provided
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun rev(a, ys) = if ys is
  C(h, t) then rev(C(h, a), t)
  N then a
fun ff(x) = if x is
  A then AA
  B then BB
fun revMap(ls, f) = rev(N, map(ls, f))
revMap
//│ |#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |rev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |rev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |ff|(|x|)| |#=| |#if| |x| |is|→|A| |#then| |AA|↵|B| |#then| |BB|←|↵|#fun| |revMap|(|ls|,| |f|)| |#=| |rev|(|N|,| |map|(|ls|,| |f|)|)|↵|revMap|
//│ Parsed: {fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun rev = a, ys, => if ys is ‹(C (h, t,)) then rev (C (h, a,), t,); (N) then a›; fun ff = x, => if x is ‹(A) then AA; (B) then BB›; fun revMap = ls, f, => rev (N, map (ls, f,),); revMap}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ revMap^43
//│ def ff = (fun x⁰ -> case x⁰ of {
//│ 	A  => [AA]
//│ 	| B  => [BB]})
//│ def map = (fun xs⁰ -> (fun f⁰ -> case xs⁰ of {
//│ 	C h⁰ t⁰ => [C (f⁰ h⁰) ((map^5 t⁰) f⁰)]
//│ 	| N  => [N]}))
//│ def rev = (fun a⁰ -> (fun ys⁰ -> case ys⁰ of {
//│ 	C h¹ t¹ => ((rev^16 [C h¹ a⁰]) t¹)
//│ 	| N  => a⁰}))
//│ def revMap = (fun ls⁰ -> (fun f¹ -> ((rev^32 [N]) ((map^35 ls⁰) f¹))))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [revMap^43]
//│ 	[revMap^43 · map^35]
//│ 		[revMap^43 · map^35 · map^5] ---> [revMap^43 · map^35] (only one)
//│ 	[revMap^43 · rev^32] (hopeless to continue)
//│ 		[revMap^43 · rev^32 · rev^16] ---> [revMap^43 · rev^32] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ revMap₀
//│ def revMap₀ = 
//│ 	(fun ls¹ -> (fun f³ -> ((rev₀ [N]) ((map₀ ls¹) f³))))
//│ 	where
//│ 	def map₀ = 
//│ 		(fun xs¹ -> (fun f² -> case xs¹ of {
//│ 			C h² t² => [C (f² h²) ((map₀ t²) f²)]
//│ 			| N  => [N]}))
//│ 	def rev₀ = 
//│ 		(fun a¹ -> (fun ys¹ -> case ys¹ of {
//│ 			C h³ t³ => ((rev₀ [C h³ a¹]) t³)
//│ 			| N  => a¹}))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C (f² h²) ((map₀ t²) f²)]: 53 --->
//│ 	case ys¹ of {C h³ t³ => ((rev₀ [C h³ a¹]) t³) | N  => a¹}: 67
//│ [N]: 54 --->
//│ 	case ys¹ of {C h³ t³ => ((rev₀ [C h³ a¹]) t³) | N  => a¹}: 67
//│ ------------------
//│ case ys¹ of {C h³ t³ => ((rev₀ [C h³ a¹]) t³) | N  => a¹}: 67 --->
//│ 	[C (f² h²) ((map₀ t²) f²)]: 53
//│ 	[N]: 54
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C (f² h²) ((map₀ t²) f²)]: 53 --->
//│ 	case ys¹ of {C h³ t³ => ((rev₀ [C h³ a¹]) t³) | N  => a¹}: 67
//│ [N]: 54 --->
//│ 	case ys¹ of {C h³ t³ => ((rev₀ [C h³ a¹]) t³) | N  => a¹}: 67
//│ ------------------
//│ case ys¹ of {C h³ t³ => ((rev₀ [C h³ a¹]) t³) | N  => a¹}: 67 --->
//│ 	[C (f² h²) ((map₀ t²) f²)]: 53
//│ 	[N]: 54
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ revMap₀
//│ def revMap₀ = 
//│ 	(fun ls² -> (fun f⁵ -> ((rev₀ [N]) ((map₀ ls²) f⁵))))
//│ 	where
//│ 	def map₀ = 
//│ 		(fun xs² -> (fun f⁴ -> case xs² of {
//│ 			C h² t² => 
//│ 				let h⁴ = (f⁴ h²)
//│ 				in let t⁴ = ((map₀ t²) f⁴)
//│ 				in (fun a² -> ((rev₀ [C h⁴ a²]) t⁴))
//│ 			| N  => (fun a³ -> a³)}))
//│ 	def rev₀ = 
//│ 		(fun a⁴ -> (fun ys² -> (ys² a⁴)))
//│ <<<<<<< after fusion <<<<<<<
