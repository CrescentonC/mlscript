:NewParser
:ParseOnly


// CORRECT: when the top level result is consumed by nocons
fun f(a) = if a is
  A(aa) then f(B)
  B then OK
fun g(b) =
  f(b)
g
//│ |#fun| |f|(|a|)| |#=| |#if| |a| |is|→|A|(|aa|)| |#then| |f|(|B|)|↵|B| |#then| |OK|←|↵|#fun| |g|(|b|)| |#=|→|f|(|b|)|←|↵|g|
//│ Parsed: {fun f = a, => if a is ‹(A (aa,)) then f (B,); (B) then OK›; fun g = b, => {f (b,)}; g}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ g^12
//│ def f(a⁰) = case a⁰ of {
//│ 	A aa⁰ => f^2([B])
//│ 	| B  => [OK]}
//│ def g(b⁰) = f^8(b⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [g^12] (hopeless to continue)
//│ 	[g^12 · f^8] (using original def)
//│ 		[g^12 · f^8 · f^2] ---> [g^12 · f^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ g_₀
//│ def g_₀(b¹) = 
//│ 	f_₀(b¹)
//│ 	where
//│ 	def f_₀(a¹) = 
//│ 		case a¹ of {
//│ 			A aa¹ => f_₀([B])
//│ 			| B  => [OK]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [B]: 19 --->
//│ 	case a¹ of {A aa¹ => f_₀([B]) | B  => [OK]}: 22
//│ ------------------
//│ case a¹ of {A aa¹ => f_₀([B]) | B  => [OK]}: 22 --->
//│ 	NoProd
//│ 	[B]: 19
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ g_₀
//│ def g_₀(b²) = 
//│ 	f_₀(b²)
//│ 	where
//│ 	def f_₀(a²) = 
//│ 		case a² of {
//│ 			A aa¹ => f_₀([B])
//│ 			| B  => [OK]}
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: when the top level result is consumed by nocons
fun f(a) = if a is
  A(aa) then f(B)
  B then OK
fun g(b) =
  f(b)
primitive(g)
//│ |#fun| |f|(|a|)| |#=| |#if| |a| |is|→|A|(|aa|)| |#then| |f|(|B|)|↵|B| |#then| |OK|←|↵|#fun| |g|(|b|)| |#=|→|f|(|b|)|←|↵|primitive|(|g|)|
//│ Parsed: {fun f = a, => if a is ‹(A (aa,)) then f (B,); (B) then OK›; fun g = b, => {f (b,)}; primitive (g,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ primitive⁰(g^13)
//│ def f(a⁰) = case a⁰ of {
//│ 	A aa⁰ => f^2([B])
//│ 	| B  => [OK]}
//│ def g(b⁰) = f^8(b⁰)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [g^13] (hopeless to continue)
//│ 	[g^13 · f^8] (using original def)
//│ 		[g^13 · f^8 · f^2] ---> [g^13 · f^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ primitive⁰(g_₀)
//│ def g_₀(b¹) = 
//│ 	f_₀(b¹)
//│ 	where
//│ 	def f_₀(a¹) = 
//│ 		case a¹ of {
//│ 			A aa¹ => f_₀([B])
//│ 			| B  => [OK]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [B]: 21 --->
//│ 	case a¹ of {A aa¹ => f_₀([B]) | B  => [OK]}: 24
//│ ------------------
//│ case a¹ of {A aa¹ => f_₀([B]) | B  => [OK]}: 24 --->
//│ 	NoProd
//│ 	[B]: 21
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ primitive⁰(g_₀)
//│ def g_₀(b²) = 
//│ 	f_₀(b²)
//│ 	where
//│ 	def f_₀(a²) = 
//│ 		case a² of {
//│ 			A aa¹ => f_₀([B])
//│ 			| B  => [OK]}
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: when the top level result is consumed by nocons
fun f(a) = if primitive then B else a
fun g(x) = if x is
  B then C
  D then E
fun k(a) = g(f(a))
k
//│ |#fun| |f|(|a|)| |#=| |#if| |primitive| |#then| |B| |#else| |a|↵|#fun| |g|(|x|)| |#=| |#if| |x| |is|→|B| |#then| |C|↵|D| |#then| |E|←|↵|#fun| |k|(|a|)| |#=| |g|(|f|(|a|)|)|↵|k|
//│ Parsed: {fun f = a, => if (primitive) then B else a; fun g = x, => if x is ‹(B) then C; (D) then E›; fun k = a, => g (f (a,),); k}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ k^17
//│ def f(a⁰) = if primitive⁰ then [B] else a⁰
//│ def g(x⁰) = case x⁰ of {
//│ 	B  => [C]
//│ 	| D  => [E]}
//│ def k(a¹) = g^11(f^12(a¹))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [k^17] (hopeless to continue)
//│ 	[k^17 · f^12] (using original def)
//│ 	[k^17 · g^11] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ k_₀
//│ def k_₀(a²) = 
//│ 	g_₀(f_₀(a²))
//│ 	where
//│ 	def f_₀(a³) = 
//│ 		if primitive⁰ then [B] else a³
//│ 	def g_₀(x¹) = 
//│ 		case x¹ of {
//│ 			B  => [C]
//│ 			| D  => [E]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [B]: 30 --->
//│ 	case x¹ of {B  => [C] | D  => [E]}: 27
//│ ------------------
//│ case x¹ of {B  => [C] | D  => [E]}: 27 --->
//│ 	NoProd
//│ 	[B]: 30
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ k_₀
//│ def k_₀(a⁴) = 
//│ 	g_₀(f_₀(a⁴))
//│ 	where
//│ 	def f_₀(a⁵) = 
//│ 		if primitive⁰ then [B] else a⁵
//│ 	def g_₀(x²) = 
//│ 		case x² of {
//│ 			B  => [C]
//│ 			| D  => [E]}
//│ <<<<<<< after fusion <<<<<<<
