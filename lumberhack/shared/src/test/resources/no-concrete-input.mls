:NewParser
:ParseOnly


// CORRECT: when the top level result is consumed by nocons
fun f(a) = if a is
  A(aa) then f(B)
  B then OK
fun g(b) =
  f(b)
g
//│ |#fun| |f|(|a|)| |#=| |#if| |a| |is|→|A|(|aa|)| |#then| |f|(|B|)|↵|B| |#then| |OK|←|↵|#fun| |g|(|b|)| |#=|→|f|(|b|)|←|↵|g|
//│ Parsed: {fun f = a, => if a is ‹(A (aa,)) then f (B,); (B) then OK›; fun g = b, => {f (b,)}; g}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ g^12
//│ def f = (fun a⁰ -> case a⁰ of {
//│ 	A aa⁰ => (f^2 [B])
//│ 	| B => [OK]})
//│ def g = (fun b⁰ -> (f^8 b⁰))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [g^12] (hopeless to continue)
//│ 	[g^12 · f^8] (using original def)
//│ 		[g^12 · f^8 · f^2] ---> [g^12 · f^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ g₀
//│ def g₀ = 
//│ 	(fun b¹ -> (f₀ b¹))
//│ 	where
//│ 	def f₀ = 
//│ 		(fun a¹ -> case a¹ of {
//│ 			A aa¹ => (f₀ [B])
//│ 			| B => [OK]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [B]: 19 --->
//│ 	case a¹ of {A aa¹ => (f₀ [B]) | B => [OK]}: 22
//│ ------------------
//│ case a¹ of {A aa¹ => (f₀ [B]) | B => [OK]}: 22 --->
//│ 	NoProd
//│ 	[B]: 19
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ g₀
//│ def g₀ = 
//│ 	(fun b² -> (f₀ b²))
//│ 	where
//│ 	def f₀ = 
//│ 		(fun a² -> case a² of {
//│ 			A aa¹ => (f₀ [B])
//│ 			| B => [OK]})
//│ <<<<<<< after fusion <<<<<<<

// CORRECT: when the top level result is consumed by nocons
fun f(a) = if a is
  A(aa) then f(B)
  B then OK
fun g(b) =
  f(b)
primitive(g)
//│ |#fun| |f|(|a|)| |#=| |#if| |a| |is|→|A|(|aa|)| |#then| |f|(|B|)|↵|B| |#then| |OK|←|↵|#fun| |g|(|b|)| |#=|→|f|(|b|)|←|↵|primitive|(|g|)|
//│ Parsed: {fun f = a, => if a is ‹(A (aa,)) then f (B,); (B) then OK›; fun g = b, => {f (b,)}; primitive (g,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (primitive⁰ g^13)
//│ def f = (fun a⁰ -> case a⁰ of {
//│ 	A aa⁰ => (f^2 [B])
//│ 	| B => [OK]})
//│ def g = (fun b⁰ -> (f^8 b⁰))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [g^13] (hopeless to continue)
//│ 	[g^13 · f^8] (using original def)
//│ 		[g^13 · f^8 · f^2] ---> [g^13 · f^8] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (primitive⁰ g₀)
//│ def g₀ = 
//│ 	(fun b¹ -> (f₀ b¹))
//│ 	where
//│ 	def f₀ = 
//│ 		(fun a¹ -> case a¹ of {
//│ 			A aa¹ => (f₀ [B])
//│ 			| B => [OK]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [B]: 21 --->
//│ 	case a¹ of {A aa¹ => (f₀ [B]) | B => [OK]}: 24
//│ ------------------
//│ case a¹ of {A aa¹ => (f₀ [B]) | B => [OK]}: 24 --->
//│ 	NoProd
//│ 	[B]: 21
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (primitive⁰ g₀)
//│ def g₀ = 
//│ 	(fun b² -> (f₀ b²))
//│ 	where
//│ 	def f₀ = 
//│ 		(fun a² -> case a² of {
//│ 			A aa¹ => (f₀ [B])
//│ 			| B => [OK]})
//│ <<<<<<< after fusion <<<<<<<


// CORRECT: when the top level result is consumed by nocons
fun f(a) = if primitive then B else a
fun g(x) = if x is
  B then C
  D then E
fun k(a) = g(f(a))
k
//│ |#fun| |f|(|a|)| |#=| |#if| |primitive| |#then| |B| |#else| |a|↵|#fun| |g|(|x|)| |#=| |#if| |x| |is|→|B| |#then| |C|↵|D| |#then| |E|←|↵|#fun| |k|(|a|)| |#=| |g|(|f|(|a|)|)|↵|k|
//│ Parsed: {fun f = a, => if (primitive) then B else a; fun g = x, => if x is ‹(B) then C; (D) then E›; fun k = a, => g (f (a,),); k}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ k^17
//│ def f = (fun a⁰ -> if primitive⁰ then [B] else a⁰)
//│ def g = (fun x⁰ -> case x⁰ of {
//│ 	B => [C]
//│ 	| D => [E]})
//│ def k = (fun a¹ -> (g^11 (f^12 a¹)))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [k^17] (hopeless to continue)
//│ 	[k^17 · f^12] (using original def)
//│ 	[k^17 · g^11] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ k₀
//│ def k₀ = 
//│ 	(fun a² -> (g₀ (f₀ a²)))
//│ 	where
//│ 	def f₀ = 
//│ 		(fun a³ -> if primitive⁰ then [B] else a³)
//│ 	def g₀ = 
//│ 		(fun x¹ -> case x¹ of {
//│ 			B => [C]
//│ 			| D => [E]})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [B]: 30 --->
//│ 	case x¹ of {B => [C] | D => [E]}: 27
//│ ------------------
//│ case x¹ of {B => [C] | D => [E]}: 27 --->
//│ 	NoProd
//│ 	[B]: 30
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ k₀
//│ def k₀ = 
//│ 	(fun a⁴ -> (g₀ (f₀ a⁴)))
//│ 	where
//│ 	def f₀ = 
//│ 		(fun a⁵ -> if primitive⁰ then [B] else a⁵)
//│ 	def g₀ = 
//│ 		(fun x² -> case x² of {
//│ 			B => [C]
//│ 			| D => [E]})
//│ <<<<<<< after fusion <<<<<<<
