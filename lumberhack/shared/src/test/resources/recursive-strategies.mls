:NewParser
:ParseOnly

// CORRECT:
let p = Pair(A, B)
fun c(x) = if x is
  Pair(a, b) then c(Pair(b, a))
c(p)
//│ |#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^12(p^13)
//│ def c(x⁰) = case x⁰ of {
//│ 	Pair a⁰ b⁰ => c^5([Pair b⁰ a⁰])}
//│ def p = [Pair [A] [B]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Pair [A] [B]]: 3 --->
//│ 	case x⁰ of {Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}: 10
//│ [Pair b⁰ a⁰]: 8 --->
//│ 	case x⁰ of {Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}: 10
//│ ------------------
//│ case x⁰ of {Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}: 10 --->
//│ 	[Pair [A] [B]]: 3
//│ 	[Pair b⁰ a⁰]: 8
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(p)
//│ def c(x¹) = case x¹ of {
//│ 	Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}
//│ def p = [Pair [A] [B]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ c(p)
//│ def c(x⁰) = case x⁰ of {
//│ 	Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}
//│ def p = [Pair [A] [B]]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ c(p)
//│ def c(x⁰) = case x⁰ of {
//│ 	Pair a⁰ b⁰ => c([Pair b⁰ a⁰])}
//│ def p = [Pair [A] [B]]
//│ <<<<<<< after floating out <<<<<<<

// CORRECT:
let p = Wrap(3)
fun c(x) = if x is
  Wrap(a) then if a > 0 then c(Wrap(a - 1)) else Wrap(0)
c(p)
//│ |#let| |p| |#=| |Wrap|(|3|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Wrap|(|a|)| |#then| |#if| |a| |>| |0| |#then| |c|(|Wrap|(|a| |-| |1|)|)| |#else| |Wrap|(|0|)|←|↵|c|(|p|)|
//│ Parsed: {let p = Wrap (3,); fun c = x, => if x is ‹(Wrap (a,)) then if (> (a,) (0,)) then c (Wrap (- (a,) (1,),),) else Wrap (0,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^22(p^23)
//│ def c(x⁰) = case x⁰ of {
//│ 	Wrap a⁰ => if (a⁰ > 0) then c^9([Wrap (a⁰ - 1)]) else [Wrap 0]}
//│ def p = [Wrap 3]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Wrap 3]: 2 --->
//│ 	case x⁰ of {Wrap a⁰ => if (a⁰ > 0) then c([Wrap (a⁰ - 1)]) else [Wrap 0]}: 20
//│ [Wrap (a⁰ - 1)]: 15 --->
//│ 	case x⁰ of {Wrap a⁰ => if (a⁰ > 0) then c([Wrap (a⁰ - 1)]) else [Wrap 0]}: 20
//│ ------------------
//│ case x⁰ of {Wrap a⁰ => if (a⁰ > 0) then c([Wrap (a⁰ - 1)]) else [Wrap 0]}: 20 --->
//│ 	[Wrap 3]: 2
//│ 	[Wrap (a⁰ - 1)]: 15
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(p)
//│ def c(x¹) = case x¹ of {
//│ 	Wrap a⁰ => if (a⁰ > 0) then c([Wrap (a⁰ - 1)]) else [Wrap 0]}
//│ def p = [Wrap 3]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ c(p)
//│ def c(x⁰) = case x⁰ of {
//│ 	Wrap a⁰ => if (a⁰ > 0) then c([Wrap (a⁰ - 1)]) else [Wrap 0]}
//│ def p = [Wrap 3]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ c(p)
//│ def c(x⁰) = case x⁰ of {
//│ 	Wrap a⁰ => if (a⁰ > 0) then c([Wrap (a⁰ - 1)]) else [Wrap 0]}
//│ def p = [Wrap 3]
//│ <<<<<<< after floating out <<<<<<<

// CORRECT:
fun f(x) = if x is
    C(a) then f(C(a))
fun g(y) = if y is
    D(b) then f(C(b))
f(C(A))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |f|(|C|(|a|)|)|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|D|(|b|)| |#then| |f|(|C|(|b|)|)|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then f (C (a,),)›; fun g = y, => if y is ‹(D (b,)) then f (C (b,),)›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^15([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => f^2([C a⁰])}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => f^9([C b⁰])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a⁰]: 4 --->
//│ 	case x⁰ of {C a⁰ => f([C a⁰])}: 6
//│ [C b⁰]: 11 --->
//│ 	case x⁰ of {C a⁰ => f([C a⁰])}: 6
//│ [C [A]]: 17 --->
//│ 	case x⁰ of {C a⁰ => f([C a⁰])}: 6
//│ ------------------
//│ case x⁰ of {C a⁰ => f([C a⁰])}: 6 --->
//│ 	[C a⁰]: 4
//│ 	[C b⁰]: 11
//│ 	[C [A]]: 17
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C [A]])
//│ def f(x¹) = case x¹ of {
//│ 	C a⁰ => f([C a⁰])}
//│ def g(y¹) = case y¹ of {
//│ 	D b⁰ => f([C b⁰])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => f([C a⁰])}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => f([C b⁰])}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => f([C a⁰])}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => f([C b⁰])}
//│ <<<<<<< after floating out <<<<<<<



// NOTE: there is recursive strategies, but it is not triggered at the call site
// but we still filter those strategies out
fun f(x) = if x is
  C(a) then if a is
    D(d) then d
    C(b) then f(C(C(b)))
f(C(D(A)))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|D|(|d|)| |#then| |d|↵|C|(|b|)| |#then| |f|(|C|(|C|(|b|)|)|)|←|←|↵|f|(|C|(|D|(|A|)|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then if a is ‹(D (d,)) then d; (C (b,)) then f (C (C (b,),),)››; f (C (D (A,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^12([C [D [A]]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		D d⁰ => d⁰
//│ 		| C b⁰ => f^4([C [C b⁰]])}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C b⁰]: 6 --->
//│ 	case a⁰ of {D d⁰ => d⁰ | C b⁰ => f([C [C b⁰]])}: 9
//│ [C [C b⁰]]: 7 --->
//│ 	case x⁰ of {C a⁰ => case a⁰ of {D d⁰ => d⁰ | C b⁰ => f([C [C b⁰]])}}: 10
//│ [D [A]]: 14 --->
//│ 	case a⁰ of {D d⁰ => d⁰ | C b⁰ => f([C [C b⁰]])}: 9
//│ [C [D [A]]]: 15 --->
//│ 	case x⁰ of {C a⁰ => case a⁰ of {D d⁰ => d⁰ | C b⁰ => f([C [C b⁰]])}}: 10
//│ ------------------
//│ case a⁰ of {D d⁰ => d⁰ | C b⁰ => f([C [C b⁰]])}: 9 --->
//│ 	[C b⁰]: 6
//│ 	[D [A]]: 14
//│ case x⁰ of {C a⁰ => case a⁰ of {D d⁰ => d⁰ | C b⁰ => f([C [C b⁰]])}}: 10 --->
//│ 	[C [C b⁰]]: 7
//│ 	[C [D [A]]]: 15
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C [D [A]]])
//│ def f(x¹) = case x¹ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		D d⁰ => d⁰
//│ 		| C b⁰ => f([C [C b⁰]])}}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f([C [D [A]]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		D d⁰ => d⁰
//│ 		| C b⁰ => f([C [C b⁰]])}}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f([C [D [A]]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		D d⁰ => d⁰
//│ 		| C b⁰ => f([C [C b⁰]])}}
//│ <<<<<<< after floating out <<<<<<<
