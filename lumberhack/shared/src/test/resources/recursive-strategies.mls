:NewParser
:ParseOnly

// CORRECT:
let p = Pair(A, B)
fun c(x) = if x is
  Pair(a, b) then c(Pair(b, a))
c(p)
//│ |#let| |p| |#=| |Pair|(|A|,| |B|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Pair|(|a|,| |b|)| |#then| |c|(|Pair|(|b|,| |a|)|)|←|↵|c|(|p|)|
//│ Parsed: {let p = Pair (A, B,); fun c = x, => if x is ‹(Pair (a, b,)) then c (Pair (b, a,),)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^12(p^13)
//│ def c(x⁰) = case x⁰ of {
//│ 	Pair a⁰ b⁰ => c^5([Pair b⁰ a⁰])}
//│ def p = [Pair [A] [B]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^12] (hopeless to continue)
//│ 	[c^12 · c^5] ---> [c^12] (using original def)
//│ [p^13] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		Pair a¹ b¹ => c_₀([Pair b¹ a¹])}
//│ def p_₀ = 
//│ 	[Pair [A] [B]]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Pair b¹ a¹]: 19 --->
//│ 	case x¹ of {Pair a¹ b¹ => c_₀([Pair b¹ a¹])}: 21
//│ [Pair [A] [B]]: 25 --->
//│ 	case x¹ of {Pair a¹ b¹ => c_₀([Pair b¹ a¹])}: 21
//│ ------------------
//│ case x¹ of {Pair a¹ b¹ => c_₀([Pair b¹ a¹])}: 21 --->
//│ 	[Pair b¹ a¹]: 19
//│ 	[Pair [A] [B]]: 25
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x²) = 
//│ 	case x² of {
//│ 		Pair a¹ b¹ => c_₀([Pair b¹ a¹])}
//│ def p_₀ = 
//│ 	[Pair [A] [B]]
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
let p = Wrap(3)
fun c(x) = if x is
  Wrap(a) then if a > 0 then c(Wrap(a - 1)) else Wrap(0)
c(p)
//│ |#let| |p| |#=| |Wrap|(|3|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|Wrap|(|a|)| |#then| |#if| |a| |>| |0| |#then| |c|(|Wrap|(|a| |-| |1|)|)| |#else| |Wrap|(|0|)|←|↵|c|(|p|)|
//│ Parsed: {let p = Wrap (3,); fun c = x, => if x is ‹(Wrap (a,)) then if (> (a,) (0,)) then c (Wrap (- (a,) (1,),),) else Wrap (0,)›; c (p,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^22(p^23)
//│ def c(x⁰) = case x⁰ of {
//│ 	Wrap a⁰ => if (a⁰ > 0) then c^9([Wrap (a⁰ - 1)]) else [Wrap 0]}
//│ def p = [Wrap 3]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^22] (hopeless to continue)
//│ 	[c^22 · c^9] ---> [c^22] (using original def)
//│ [p^23] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x¹) = 
//│ 	case x¹ of {
//│ 		Wrap a¹ => if (a¹ > 0) then c_₀([Wrap (a¹ - 1)]) else [Wrap 0]}
//│ def p_₀ = 
//│ 	[Wrap 3]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Wrap 3]: 26 --->
//│ 	case x¹ of {Wrap a¹ => if (a¹ > 0) then c_₀([Wrap (a¹ - 1)]) else [Wrap 0]}: 44
//│ [Wrap (a¹ - 1)]: 39 --->
//│ 	case x¹ of {Wrap a¹ => if (a¹ > 0) then c_₀([Wrap (a¹ - 1)]) else [Wrap 0]}: 44
//│ ------------------
//│ case x¹ of {Wrap a¹ => if (a¹ > 0) then c_₀([Wrap (a¹ - 1)]) else [Wrap 0]}: 44 --->
//│ 	[Wrap 3]: 26
//│ 	[Wrap (a¹ - 1)]: 39
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c_₀(p_₀)
//│ def c_₀(x²) = 
//│ 	case x² of {
//│ 		Wrap a¹ => if (a¹ > 0) then c_₀([Wrap (a¹ - 1)]) else [Wrap 0]}
//│ def p_₀ = 
//│ 	[Wrap 3]
//│ <<<<<<< after fusion <<<<<<<

// CORRECT:
fun f(x) = if x is
    C(a) then f(C(a))
fun g(y) = if y is
    D(b) then f(C(b))
f(C(A))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |f|(|C|(|a|)|)|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|D|(|b|)| |#then| |f|(|C|(|b|)|)|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then f (C (a,),)›; fun g = y, => if y is ‹(D (b,)) then f (C (b,),)›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^15([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => f^2([C a⁰])}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => f^9([C b⁰])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^15] (hopeless to continue)
//│ 	[f^15 · f^2] ---> [f^15] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([C [A]])
//│ def f_₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => f_₀([C a¹])}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a¹]: 22 --->
//│ 	case x¹ of {C a¹ => f_₀([C a¹])}: 24
//│ [C [A]]: 28 --->
//│ 	case x¹ of {C a¹ => f_₀([C a¹])}: 24
//│ ------------------
//│ case x¹ of {C a¹ => f_₀([C a¹])}: 24 --->
//│ 	[C a¹]: 22
//│ 	[C [A]]: 28
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀([C [A]])
//│ def f_₀(x²) = 
//│ 	case x² of {
//│ 		C a¹ => f_₀([C a¹])}
//│ <<<<<<< after fusion <<<<<<<



// NOTE: there is recursive strategies, but it is not triggered at the call site
// but we still filter those strategies out
fun f(x) = if x is
  C(a) then if a is
    D(d) then d
    C(b) then f(C(C(b)))
f(C(D(A)))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |#if| |a| |is|→|D|(|d|)| |#then| |d|↵|C|(|b|)| |#then| |f|(|C|(|C|(|b|)|)|)|←|←|↵|f|(|C|(|D|(|A|)|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then if a is ‹(D (d,)) then d; (C (b,)) then f (C (C (b,),),)››; f (C (D (A,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^12([C [D [A]]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		D d⁰ => d⁰
//│ 		| C b⁰ => f^4([C [C b⁰]])}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^12] (hopeless to continue)
//│ 	[f^12 · f^4] ---> [f^12] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([C [D [A]]])
//│ def f_₀(x¹) = 
//│ 	case x¹ of {
//│ 		C a¹ => case a¹ of {
//│ 			D d¹ => d¹
//│ 			| C b¹ => f_₀([C [C b¹]])}}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C b¹]: 22 --->
//│ 	case a¹ of {D d¹ => d¹ | C b¹ => f_₀([C [C b¹]])}: 25
//│ [C [C b¹]]: 23 --->
//│ 	case x¹ of {C a¹ => case a¹ of {D d¹ => d¹ | C b¹ => f_₀([C [C b¹]])}}: 26
//│ [D [A]]: 30 --->
//│ 	case a¹ of {D d¹ => d¹ | C b¹ => f_₀([C [C b¹]])}: 25
//│ [C [D [A]]]: 31 --->
//│ 	case x¹ of {C a¹ => case a¹ of {D d¹ => d¹ | C b¹ => f_₀([C [C b¹]])}}: 26
//│ ------------------
//│ case a¹ of {D d¹ => d¹ | C b¹ => f_₀([C [C b¹]])}: 25 --->
//│ 	[C b¹]: 22
//│ 	[D [A]]: 30
//│ case x¹ of {C a¹ => case a¹ of {D d¹ => d¹ | C b¹ => f_₀([C [C b¹]])}}: 26 --->
//│ 	[C [C b¹]]: 23
//│ 	[C [D [A]]]: 31
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀([C [D [A]]])
//│ def f_₀(x²) = 
//│ 	case x² of {
//│ 		C a¹ => case a¹ of {
//│ 			D d¹ => d¹
//│ 			| C b¹ => f_₀([C [C b¹]])}}
//│ <<<<<<< after fusion <<<<<<<
