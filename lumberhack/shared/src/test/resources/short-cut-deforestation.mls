:NewParser
:ParseOnly

fun andd(bs) = if bs is
  C(h, t) then if h then andd(t) else False
  N then True
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun all(xs, p) = andd(map(xs, p))
all
//│ |#fun| |andd|(|bs|)| |#=| |#if| |bs| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |#then| |andd|(|t|)| |#else| |False|↵|N| |#then| |True|←|↵|#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |all|(|xs|,| |p|)| |#=| |andd|(|map|(|xs|,| |p|)|)|↵|all|
//│ Parsed: {fun andd = bs, => if bs is ‹(C (h, t,)) then if (h) then andd (t,) else False; (N) then True›; fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun all = xs, p, => andd (map (xs, p,),); all}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ all^34
//│ def all(xs⁰, p⁰) = andd^25(map^26(xs⁰, p⁰))
//│ def andd(bs⁰) = case bs⁰ of {
//│ 	C h⁰ t⁰ => if h⁰ then andd^3(t⁰) else [False]
//│ 	| N  => [True]}
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => [C f⁰(h¹) map^15(t¹, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h¹) map(t¹, f⁰)]: 20 --->
//│ 	case bs⁰ of {C h⁰ t⁰ => if h⁰ then andd(t⁰) else [False] | N  => [True]}: 9
//│ [N]: 21 --->
//│ 	case bs⁰ of {C h⁰ t⁰ => if h⁰ then andd(t⁰) else [False] | N  => [True]}: 9
//│ ------------------
//│ case bs⁰ of {C h⁰ t⁰ => if h⁰ then andd(t⁰) else [False] | N  => [True]}: 9 --->
//│ 	[C f⁰(h¹) map(t¹, f⁰)]: 20
//│ 	[N]: 21
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h¹) map(t¹, f⁰)]: 20 --->
//│ 	case bs⁰ of {C h⁰ t⁰ => if h⁰ then andd(t⁰) else [False] | N  => [True]}: 9
//│ [N]: 21 --->
//│ 	case bs⁰ of {C h⁰ t⁰ => if h⁰ then andd(t⁰) else [False] | N  => [True]}: 9
//│ ------------------
//│ case bs⁰ of {C h⁰ t⁰ => if h⁰ then andd(t⁰) else [False] | N  => [True]}: 9 --->
//│ 	[C f⁰(h¹) map(t¹, f⁰)]: 20
//│ 	[N]: 21
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ all
//│ def all(xs¹, p¹) = andd(map(xs¹, p¹))
//│ def andd(bs¹) = bs¹(99)
//│ def map(ls¹, f¹) = case ls¹ of {
//│ 	C h¹ t¹ => 
//│ 		let t² = map(t¹, f¹)
//│ 		in let h² = f¹(h¹)
//│ 		in (fun _lh_dummy⁰ -> if h² then andd(t²) else [False])
//│ 	| N  => (fun _lh_dummy¹ -> [True])}
//│ <<<<<<< after fusion <<<<<<<

fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun odd(x) = if (x % 2) == 0 then True else False
fun f(xs, g, f) =
  let ok = ls => if ls is
    C(h, t) then if h is
      x then if odd(x) then C(f(x), ok(t)) else ok(t)
    N then N
  ok(map(xs, f))
f
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |odd|(|x|)| |#=| |#if| |(|x| |%| |2|)| |==| |0| |#then| |True| |#else| |False|↵|#fun| |f|(|xs|,| |g|,| |f|)| |#=|→|#let| |ok| |#=| |ls| |=>| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |is|→|x| |#then| |#if| |odd|(|x|)| |#then| |C|(|f|(|x|)|,| |ok|(|t|)|)| |#else| |ok|(|t|)|←|↵|N| |#then| |N|←|↵|ok|(|map|(|xs|,| |f|)|)|←|↵|f|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun odd = x, => if (== (% (x,) (2,),) (0,)) then True else False; fun f = xs, g, f, => {let ok = ls, => if ls is ‹(C (h, t,)) then if h is ‹(x) then if (odd (x,)) then C (f (x,), ok (t,),) else ok (t,)›; (N) then N›; ok (map (xs, f,),)}; f}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^59
//│ def f(xs⁰, g⁰, f²) = 
//│ 	let ok⁰ = (fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => case h¹ of {
//│ 			x¹ => if odd^30(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)}
//│ 		| N  => [N]})
//│ 	in ok⁰(map^49(xs⁰, f²))
//│ def map(ls⁰, f¹) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f¹(h⁰) map^5(t⁰, f¹)]
//│ 	| N  => [N]}
//│ def odd(x⁰) = if ((x⁰ % 2) == 0) then [True] else [False]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f¹(h⁰) map(t⁰, f¹)]: 10 --->
//│ 	case ls¹ of {C h¹ t¹ => case h¹ of {x¹ => if odd(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)} | N  => [N]}: 46
//│ [N]: 11 --->
//│ 	case ls¹ of {C h¹ t¹ => case h¹ of {x¹ => if odd(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)} | N  => [N]}: 46
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => case h¹ of {x¹ => if odd(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)} | N  => [N]}: 46 --->
//│ 	[C f¹(h⁰) map(t⁰, f¹)]: 10
//│ 	[N]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f¹(h⁰) map(t⁰, f¹)]: 10 --->
//│ 	case ls¹ of {C h¹ t¹ => case h¹ of {x¹ => if odd(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)} | N  => [N]}: 46
//│ [N]: 11 --->
//│ 	case ls¹ of {C h¹ t¹ => case h¹ of {x¹ => if odd(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)} | N  => [N]}: 46
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => case h¹ of {x¹ => if odd(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)} | N  => [N]}: 46 --->
//│ 	[C f¹(h⁰) map(t⁰, f¹)]: 10
//│ 	[N]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f
//│ def f(xs¹, g¹, f⁶) = 
//│ 	let ok³ = (fun ls³ -> ls³(f⁶, ok³))
//│ 	in ok³(map(xs¹, f⁶))
//│ def map(ls², f³) = case ls² of {
//│ 	C h⁰ t⁰ => 
//│ 		let t² = map(t⁰, f³)
//│ 		in let h² = f³(h⁰)
//│ 		in (fun f⁴ -> (fun ok¹ -> case h² of {
//│ 			x¹ => if odd(x¹) then [C f⁴(x¹) ok¹(t²)] else ok¹(t²)}))
//│ 	| N  => (fun f⁵ -> (fun ok² -> [N]))}
//│ def odd(x²) = if ((x² % 2) == 0) then [True] else [False]
//│ <<<<<<< after fusion <<<<<<<


// [ f x | x <- map g xs, odd x ]
// CORRECT:
_LUMBERHACK_EVAL
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun odd(x) = if (x % 2) == 0 then True else False
fun f(xs, g, f) =
  let ok = ls => if ls is
    C(h, t) then if h is
      x then if odd(x) then C(f(x), ok(t)) else ok(t)
    N then N
  ok(map(xs, g))
  xs
f(C(1, C(2, C(3, C(4, N)))), x => x + 1, x => x * 2)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |odd|(|x|)| |#=| |#if| |(|x| |%| |2|)| |==| |0| |#then| |True| |#else| |False|↵|#fun| |f|(|xs|,| |g|,| |f|)| |#=|→|#let| |ok| |#=| |ls| |=>| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |is|→|x| |#then| |#if| |odd|(|x|)| |#then| |C|(|f|(|x|)|,| |ok|(|t|)|)| |#else| |ok|(|t|)|←|↵|N| |#then| |N|←|↵|ok|(|map|(|xs|,| |g|)|)|↵|xs|←|↵|f|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |C|(|4|,| |N|)|)|)|)|,| |x| |=>| |x| |+| |1|,| |x| |=>| |x| |*| |2|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun odd = x, => if (== (% (x,) (2,),) (0,)) then True else False; fun f = xs, g, f, => {let ok = ls, => if ls is ‹(C (h, t,)) then if h is ‹(x) then if (odd (x,)) then C (f (x,), ok (t,),) else ok (t,)›; (N) then N›; ok (map (xs, g,),); xs}; f (C (1, C (2, C (3, C (4, N,),),),), x, => + (x,) (1,), x, => * (x,) (2,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^61([C 1 [C 2 [C 3 [C 4 [N]]]]], (fun x² -> (x² + 1)), (fun x³ -> (x³ * 2)))
//│ def f(xs⁰, g⁰, f²) = 
//│ 	let ok⁰ = (fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => case h¹ of {
//│ 			x¹ => if odd^30(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)}
//│ 		| N  => [N]})
//│ 	in ok⁰(map^49(xs⁰, g⁰))
//│ 	xs⁰
//│ def map(ls⁰, f¹) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f¹(h⁰) map^5(t⁰, f¹)]
//│ 	| N  => [N]}
//│ def odd(x⁰) = if ((x⁰ % 2) == 0) then [True] else [False]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 
//│ 	[C 4 [C 8 [N]]]
//│ 	[C 1 [C 2 [C 3 [C 4 [N]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f¹(h⁰) map(t⁰, f¹)]: 10 --->
//│ 	case ls¹ of {C h¹ t¹ => case h¹ of {x¹ => if odd(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)} | N  => [N]}: 46
//│ [N]: 11 --->
//│ 	case ls¹ of {C h¹ t¹ => case h¹ of {x¹ => if odd(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)} | N  => [N]}: 46
//│ [N]: 66 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f¹(h⁰) map(t⁰, f¹)] | N  => [N]}: 12
//│ [C 4 [N]]: 67 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f¹(h⁰) map(t⁰, f¹)] | N  => [N]}: 12
//│ [C 3 [C 4 [N]]]: 68 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f¹(h⁰) map(t⁰, f¹)] | N  => [N]}: 12
//│ [C 2 [C 3 [C 4 [N]]]]: 69 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f¹(h⁰) map(t⁰, f¹)] | N  => [N]}: 12
//│ [C 1 [C 2 [C 3 [C 4 [N]]]]]: 70 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f¹(h⁰) map(t⁰, f¹)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f¹(h⁰) map(t⁰, f¹)] | N  => [N]}: 12 --->
//│ 	[N]: 66
//│ 	[C 4 [N]]: 67
//│ 	[C 3 [C 4 [N]]]: 68
//│ 	[C 2 [C 3 [C 4 [N]]]]: 69
//│ 	[C 1 [C 2 [C 3 [C 4 [N]]]]]: 70
//│ case ls¹ of {C h¹ t¹ => case h¹ of {x¹ => if odd(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)} | N  => [N]}: 46 --->
//│ 	[C f¹(h⁰) map(t⁰, f¹)]: 10
//│ 	[N]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f¹(h⁰) map(t⁰, f¹)]: 10 --->
//│ 	case ls¹ of {C h¹ t¹ => case h¹ of {x¹ => if odd(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)} | N  => [N]}: 46
//│ [N]: 11 --->
//│ 	case ls¹ of {C h¹ t¹ => case h¹ of {x¹ => if odd(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)} | N  => [N]}: 46
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => case h¹ of {x¹ => if odd(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)} | N  => [N]}: 46 --->
//│ 	[C f¹(h⁰) map(t⁰, f¹)]: 10
//│ 	[N]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C 1 [C 2 [C 3 [C 4 [N]]]]], (fun x⁴ -> (x⁴ + 1)), (fun x⁵ -> (x⁵ * 2)))
//│ def f(xs¹, g¹, f⁶) = 
//│ 	let ok³ = (fun ls³ -> ls³(f⁶, ok³))
//│ 	in ok³(map(xs¹, g¹))
//│ 	xs¹
//│ def map(ls², f³) = case ls² of {
//│ 	C h⁰ t⁰ => 
//│ 		let t² = map(t⁰, f³)
//│ 		in let h² = f³(h⁰)
//│ 		in (fun f⁴ -> (fun ok¹ -> case h² of {
//│ 			x¹ => if odd(x¹) then [C f⁴(x¹) ok¹(t²)] else ok¹(t²)}))
//│ 	| N  => (fun f⁵ -> (fun ok² -> [N]))}
//│ def odd(x⁶) = if ((x⁶ % 2) == 0) then [True] else [False]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 
//│ 	[C 4 [C 8 [N]]]
//│ 	[C 1 [C 2 [C 3 [C 4 [N]]]]]
//│ <<<<<<< evaluate <<<<<<<



// unlines ls = concat (map (\l -> l ++ ['\n']) ls)
// concat(lss) = [ x | xs <- lss, x <- xs ]
_LUMBERHACK_EVAL
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun concat(lss) = if lss is
  C(hh, tt) then concatInner(hh, tt)
  N then N
fun concatInner(xs, xss) = if xs is
  C(h, t) then C(h, concatInner(t, xss))
  N then concat(xss)
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun unlines(lss) = concat(map(lss, xs => append(xs, C(NL, N))))
fun main(lss) =
  unlines(lss)
  lss
main(C(
  C(AA, C(BB, N)),
  C(
    C(CC, C(DD, N)),
    C(
      C(EE, C(FF, N)),
      N
    )
  )
))
//│ |_LUMBERHACK_EVAL|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |concat|(|lss|)| |#=| |#if| |lss| |is|→|C|(|hh|,| |tt|)| |#then| |concatInner|(|hh|,| |tt|)|↵|N| |#then| |N|←|↵|#fun| |concatInner|(|xs|,| |xss|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |concatInner|(|t|,| |xss|)|)|↵|N| |#then| |concat|(|xss|)|←|↵|#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |unlines|(|lss|)| |#=| |concat|(|map|(|lss|,| |xs| |=>| |append|(|xs|,| |C|(|NL|,| |N|)|)|)|)|↵|#fun| |main|(|lss|)| |#=|→|unlines|(|lss|)|↵|lss|←|↵|main|(|C|(|→|C|(|AA|,| |C|(|BB|,| |N|)|)|,|↵|C|(|→|C|(|CC|,| |C|(|DD|,| |N|)|)|,|↵|C|(|→|C|(|EE|,| |C|(|FF|,| |N|)|)|,|↵|N|←|↵|)|←|↵|)|←|↵|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun concat = lss, => if lss is ‹(C (hh, tt,)) then concatInner (hh, tt,); (N) then N›; fun concatInner = xs, xss, => if xs is ‹(C (h, t,)) then C (h, concatInner (t, xss,),); (N) then concat (xss,)›; fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun unlines = lss, => concat (map (lss, xs, => append (xs, C (NL, N,),),),); fun main = lss, => {unlines (lss,); lss}; main (C (C (AA, C (BB, N,),), C (C (CC, C (DD, N,),), C (C (EE, C (FF, N,),), N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^71([C [C [AA] [C [BB] [N]]] [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]])
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def concat(lss⁰) = case lss⁰ of {
//│ 	C hh⁰ tt⁰ => concatInner^14(hh⁰, tt⁰)
//│ 	| N  => [N]}
//│ def concatInner(xs¹, xss⁰) = case xs¹ of {
//│ 	C h¹ t¹ => [C h¹ concatInner^24(t¹, xss⁰)]
//│ 	| N  => concat^30(xss⁰)}
//│ def main(lss²) = 
//│ 	unlines^65(lss²)
//│ 	lss²
//│ def map(xs², f⁰) = case xs² of {
//│ 	C h² t² => [C f⁰(h²) map^40(t², f⁰)]
//│ 	| N  => [N]}
//│ def unlines(lss¹) = concat^50(map^51(lss¹, (fun xs³ -> append^54(xs³, [C [NL] [N]]))))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 
//│ 	[C [AA] [C [BB] [C [NL] [C [CC] [C [DD] [C [NL] [C [EE] [C [FF] [C [NL] [N]]]]]]]]]]
//│ 	[C [C [AA] [C [BB] [N]]] [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ append(t⁰, ys⁰)]: 8 --->
//│ 	case xs¹ of {C h¹ t¹ => [C h¹ concatInner(t¹, xss⁰)] | N  => concat(xss⁰)}: 33
//│ [C f⁰(h²) map(t², f⁰)]: 45 --->
//│ 	case lss⁰ of {C hh⁰ tt⁰ => concatInner(hh⁰, tt⁰) | N  => [N]}: 20
//│ [N]: 46 --->
//│ 	case lss⁰ of {C hh⁰ tt⁰ => concatInner(hh⁰, tt⁰) | N  => [N]}: 20
//│ [N]: 58 --->
//│ 	case xs¹ of {C h¹ t¹ => [C h¹ concatInner(t¹, xss⁰)] | N  => concat(xss⁰)}: 33
//│ [C [NL] [N]]: 59 --->
//│ 	case xs¹ of {C h¹ t¹ => [C h¹ concatInner(t¹, xss⁰)] | N  => concat(xss⁰)}: 33
//│ [N]: 74 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [C [BB] [N]]: 75 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [C [AA] [C [BB] [N]]]: 76 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [N]: 79 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [C [DD] [N]]: 80 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [C [CC] [C [DD] [N]]]: 81 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [N]: 84 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [C [FF] [N]]: 85 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [C [EE] [C [FF] [N]]]: 86 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [N]: 87 --->
//│ 	NoCons
//│ 	case xs² of {C h² t² => [C f⁰(h²) map(t², f⁰)] | N  => [N]}: 47
//│ [C [C [EE] [C [FF] [N]]] [N]]: 88 --->
//│ 	NoCons
//│ 	case xs² of {C h² t² => [C f⁰(h²) map(t², f⁰)] | N  => [N]}: 47
//│ [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]: 89 --->
//│ 	NoCons
//│ 	case xs² of {C h² t² => [C f⁰(h²) map(t², f⁰)] | N  => [N]}: 47
//│ [C [C [AA] [C [BB] [N]]] [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]]: 90 --->
//│ 	NoCons
//│ 	case xs² of {C h² t² => [C f⁰(h²) map(t², f⁰)] | N  => [N]}: 47
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10 --->
//│ 	[N]: 74
//│ 	[C [BB] [N]]: 75
//│ 	[C [AA] [C [BB] [N]]]: 76
//│ 	[N]: 79
//│ 	[C [DD] [N]]: 80
//│ 	[C [CC] [C [DD] [N]]]: 81
//│ 	[N]: 84
//│ 	[C [FF] [N]]: 85
//│ 	[C [EE] [C [FF] [N]]]: 86
//│ case lss⁰ of {C hh⁰ tt⁰ => concatInner(hh⁰, tt⁰) | N  => [N]}: 20 --->
//│ 	[C f⁰(h²) map(t², f⁰)]: 45
//│ 	[N]: 46
//│ case xs¹ of {C h¹ t¹ => [C h¹ concatInner(t¹, xss⁰)] | N  => concat(xss⁰)}: 33 --->
//│ 	[C h⁰ append(t⁰, ys⁰)]: 8
//│ 	[N]: 58
//│ 	[C [NL] [N]]: 59
//│ case xs² of {C h² t² => [C f⁰(h²) map(t², f⁰)] | N  => [N]}: 47 --->
//│ 	[N]: 87
//│ 	[C [C [EE] [C [FF] [N]]] [N]]: 88
//│ 	[C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]: 89
//│ 	[C [C [AA] [C [BB] [N]]] [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]]: 90
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h⁰ append(t⁰, ys⁰)]: 8 --->
//│ 	case xs¹ of {C h¹ t¹ => [C h¹ concatInner(t¹, xss⁰)] | N  => concat(xss⁰)}: 33
//│ [C f⁰(h²) map(t², f⁰)]: 45 --->
//│ 	case lss⁰ of {C hh⁰ tt⁰ => concatInner(hh⁰, tt⁰) | N  => [N]}: 20
//│ [N]: 46 --->
//│ 	case lss⁰ of {C hh⁰ tt⁰ => concatInner(hh⁰, tt⁰) | N  => [N]}: 20
//│ [N]: 58 --->
//│ 	case xs¹ of {C h¹ t¹ => [C h¹ concatInner(t¹, xss⁰)] | N  => concat(xss⁰)}: 33
//│ [C [NL] [N]]: 59 --->
//│ 	case xs¹ of {C h¹ t¹ => [C h¹ concatInner(t¹, xss⁰)] | N  => concat(xss⁰)}: 33
//│ ------------------
//│ case lss⁰ of {C hh⁰ tt⁰ => concatInner(hh⁰, tt⁰) | N  => [N]}: 20 --->
//│ 	[C f⁰(h²) map(t², f⁰)]: 45
//│ 	[N]: 46
//│ case xs¹ of {C h¹ t¹ => [C h¹ concatInner(t¹, xss⁰)] | N  => concat(xss⁰)}: 33 --->
//│ 	[C h⁰ append(t⁰, ys⁰)]: 8
//│ 	[N]: 58
//│ 	[C [NL] [N]]: 59
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main([C [C [AA] [C [BB] [N]]] [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]])
//│ def append(xs⁵, ys¹) = case xs⁵ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t⁴ = append(t⁰, ys¹)
//│ 		in let h⁴ = h⁰
//│ 		in (fun xss³ -> [C h⁴ concatInner(t⁴, xss³)])
//│ 	| N  => ys¹}
//│ def concat(lss⁵) = lss⁵(99)
//│ def concatInner(xs⁶, xss⁴) = xs⁶(xss⁴)
//│ def main(lss³) = 
//│ 	unlines(lss³)
//│ 	lss³
//│ def map(xs⁷, f¹) = case xs⁷ of {
//│ 	C h² t² => 
//│ 		let tt¹ = map(t², f¹)
//│ 		in let hh¹ = f¹(h²)
//│ 		in (fun _lh_dummy⁰ -> concatInner(hh¹, tt¹))
//│ 	| N  => (fun _lh_dummy¹ -> [N])}
//│ def unlines(lss⁴) = concat(map(lss⁴, (fun xs⁴ -> append(xs⁴, 
//│ 	let t³ = (fun xss² -> concat(xss²))
//│ 	in let h³ = [NL]
//│ 	in (fun xss¹ -> [C h³ concatInner(t³, xss¹)])))))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 
//│ 	[C [AA] [C [BB] [C [NL] [C [CC] [C [DD] [C [NL] [C [EE] [C [FF] [C [NL] [N]]]]]]]]]]
//│ 	[C [C [AA] [C [BB] [N]]] [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]]
//│ <<<<<<< evaluate <<<<<<<
