:NewParser
:ParseOnly

fun andd(bs) = if bs is
  C(h, t) then if h then andd(t) else False
  N then True
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun all(xs, p) = andd(map(xs, p))
all
//│ |#fun| |andd|(|bs|)| |#=| |#if| |bs| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |#then| |andd|(|t|)| |#else| |False|↵|N| |#then| |True|←|↵|#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |all|(|xs|,| |p|)| |#=| |andd|(|map|(|xs|,| |p|)|)|↵|all|
//│ Parsed: {fun andd = bs, => if bs is ‹(C (h, t,)) then if (h) then andd (t,) else False; (N) then True›; fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun all = xs, p, => andd (map (xs, p,),); all}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ all^34
//│ def all(xs⁰, p⁰) = andd^25(map^26(xs⁰, p⁰))
//│ def andd(bs⁰) = case bs⁰ of {
//│ 	C h⁰ t⁰ => if h⁰ then andd^3(t⁰) else [False]
//│ 	| N  => [True]}
//│ def map(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => [C f⁰(h¹) map^15(t¹, f⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [all^34]
//│ 	[all^34 · andd^25] (hopeless to continue)
//│ 		[all^34 · andd^25 · andd^3] ---> [all^34 · andd^25] (using original def)
//│ 	[all^34 · map^26]
//│ 		[all^34 · map^26 · map^15] ---> [all^34 · map^26] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ all_₀
//│ def all_₀(xs¹, p¹) = 
//│ 	andd_₀(map_₀(xs¹, p¹))
//│ 	where
//│ 	def andd_₀(bs¹) = 
//│ 		case bs¹ of {
//│ 			C h² t² => if h² then andd_₀(t²) else [False]
//│ 			| N  => [True]}
//│ 	def map_₀(ls¹, f¹) = 
//│ 		case ls¹ of {
//│ 			C h³ t³ => [C f¹(h³) map_₀(t³, f¹)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f¹(h³) map_₀(t³, f¹)]: 63 --->
//│ 	case bs¹ of {C h² t² => if h² then andd_₀(t²) else [False] | N  => [True]}: 43
//│ [N]: 64 --->
//│ 	case bs¹ of {C h² t² => if h² then andd_₀(t²) else [False] | N  => [True]}: 43
//│ ------------------
//│ case bs¹ of {C h² t² => if h² then andd_₀(t²) else [False] | N  => [True]}: 43 --->
//│ 	[C f¹(h³) map_₀(t³, f¹)]: 63
//│ 	[N]: 64
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f¹(h³) map_₀(t³, f¹)]: 63 --->
//│ 	case bs¹ of {C h² t² => if h² then andd_₀(t²) else [False] | N  => [True]}: 43
//│ [N]: 64 --->
//│ 	case bs¹ of {C h² t² => if h² then andd_₀(t²) else [False] | N  => [True]}: 43
//│ ------------------
//│ case bs¹ of {C h² t² => if h² then andd_₀(t²) else [False] | N  => [True]}: 43 --->
//│ 	[C f¹(h³) map_₀(t³, f¹)]: 63
//│ 	[N]: 64
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ all_₀
//│ def all_₀(xs², p²) = 
//│ 	andd_₀(map_₀(xs², p²))
//│ 	where
//│ 	def andd_₀(bs²) = 
//│ 		bs²(99)
//│ 	def map_₀(ls², f²) = 
//│ 		case ls² of {
//│ 			C h³ t³ => 
//│ 				let t⁴ = map_₀(t³, f²)
//│ 				in let h⁴ = f²(h³)
//│ 				in (fun _lh_dummy⁰ -> if h⁴ then andd_₀(t⁴) else [False])
//│ 			| N  => (fun _lh_dummy¹ -> [True])}
//│ <<<<<<< after fusion <<<<<<<

fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun odd(x) = if (x % 2) == 0 then True else False
fun f(xs, g, f) =
  let ok = ls => if ls is
    C(h, t) then if h is
      x then if odd(x) then C(f(x), ok(t)) else ok(t)
    N then N
  ok(map(xs, f))
f
//│ |#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |odd|(|x|)| |#=| |#if| |(|x| |%| |2|)| |==| |0| |#then| |True| |#else| |False|↵|#fun| |f|(|xs|,| |g|,| |f|)| |#=|→|#let| |ok| |#=| |ls| |=>| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |is|→|x| |#then| |#if| |odd|(|x|)| |#then| |C|(|f|(|x|)|,| |ok|(|t|)|)| |#else| |ok|(|t|)|←|↵|N| |#then| |N|←|↵|ok|(|map|(|xs|,| |f|)|)|←|↵|f|
//│ Parsed: {fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun odd = x, => if (== (% (x,) (2,),) (0,)) then True else False; fun f = xs, g, f, => {let ok = ls, => if ls is ‹(C (h, t,)) then if h is ‹(x) then if (odd (x,)) then C (f (x,), ok (t,),) else ok (t,)›; (N) then N›; ok (map (xs, f,),)}; f}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^59
//│ def f(xs⁰, g⁰, f²) = 
//│ 	let ok⁰ = (fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => case h¹ of {
//│ 			x¹ => if odd^30(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)}
//│ 		| N  => [N]})
//│ 	in ok⁰(map^49(xs⁰, f²))
//│ def map(ls⁰, f¹) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f¹(h⁰) map^5(t⁰, f¹)]
//│ 	| N  => [N]}
//│ def odd(x⁰) = if ((x⁰ % 2) == 0) then [True] else [False]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^59]
//│ 	[f^59 · map^49]
//│ 		[f^59 · map^49 · map^5] ---> [f^59 · map^49] (only one)
//│ 	[f^59 · odd^30] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀
//│ def f_₀(xs¹, g¹, f³) = 
//│ 	let ok¹ = (fun ls² -> case ls² of {
//│ 		C h² t² => case h² of {
//│ 			x² => if odd_₀(x²) then [C f³(x²) ok¹(t²)] else ok¹(t²)}
//│ 		| N  => [N]})
//│ 	in ok¹(map_₀(xs¹, f³))
//│ 	where
//│ 	def map_₀(ls³, f⁴) = 
//│ 		case ls³ of {
//│ 			C h³ t³ => [C f⁴(h³) map_₀(t³, f⁴)]
//│ 			| N  => [N]}
//│ 	def odd_₀(x³) = 
//│ 		if ((x³ % 2) == 0) then [True] else [False]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁴(h³) map_₀(t³, f⁴)]: 113 --->
//│ 	case ls² of {C h² t² => case h² of {x² => if odd_₀(x²) then [C f³(x²) ok¹(t²)] else ok¹(t²)} | N  => [N]}: 78
//│ [N]: 114 --->
//│ 	case ls² of {C h² t² => case h² of {x² => if odd_₀(x²) then [C f³(x²) ok¹(t²)] else ok¹(t²)} | N  => [N]}: 78
//│ ------------------
//│ case ls² of {C h² t² => case h² of {x² => if odd_₀(x²) then [C f³(x²) ok¹(t²)] else ok¹(t²)} | N  => [N]}: 78 --->
//│ 	[C f⁴(h³) map_₀(t³, f⁴)]: 113
//│ 	[N]: 114
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁴(h³) map_₀(t³, f⁴)]: 113 --->
//│ 	case ls² of {C h² t² => case h² of {x² => if odd_₀(x²) then [C f³(x²) ok¹(t²)] else ok¹(t²)} | N  => [N]}: 78
//│ [N]: 114 --->
//│ 	case ls² of {C h² t² => case h² of {x² => if odd_₀(x²) then [C f³(x²) ok¹(t²)] else ok¹(t²)} | N  => [N]}: 78
//│ ------------------
//│ case ls² of {C h² t² => case h² of {x² => if odd_₀(x²) then [C f³(x²) ok¹(t²)] else ok¹(t²)} | N  => [N]}: 78 --->
//│ 	[C f⁴(h³) map_₀(t³, f⁴)]: 113
//│ 	[N]: 114
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀
//│ def f_₀(xs², g², f⁵) = 
//│ 	let ok² = (fun ls⁴ -> ls⁴(f⁵, ok²))
//│ 	in ok²(map_₀(xs², f⁵))
//│ 	where
//│ 	def map_₀(ls⁵, f⁶) = 
//│ 		case ls⁵ of {
//│ 			C h³ t³ => 
//│ 				let t⁴ = map_₀(t³, f⁶)
//│ 				in let h⁴ = f⁶(h³)
//│ 				in (fun f⁷ -> (fun ok³ -> case h⁴ of {
//│ 					x² => if odd_₀(x²) then [C f⁷(x²) ok³(t⁴)] else ok³(t⁴)}))
//│ 			| N  => (fun f⁸ -> (fun ok⁴ -> [N]))}
//│ 	def odd_₀(x⁴) = 
//│ 		if ((x⁴ % 2) == 0) then [True] else [False]
//│ <<<<<<< after fusion <<<<<<<


// [ f x | x <- map g xs, odd x ]
// CORRECT:
_LUMBERHACK_EVAL
fun map(ls, f) = if ls is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun odd(x) = if (x % 2) == 0 then True else False
fun f(xs, g, f) =
  let ok = ls => if ls is
    C(h, t) then if h is
      x then if odd(x) then C(f(x), ok(t)) else ok(t)
    N then N
  ok(map(xs, g))
  xs
f(C(1, C(2, C(3, C(4, N)))), x => x + 1, x => x * 2)
//│ |_LUMBERHACK_EVAL|↵|#fun| |map|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |odd|(|x|)| |#=| |#if| |(|x| |%| |2|)| |==| |0| |#then| |True| |#else| |False|↵|#fun| |f|(|xs|,| |g|,| |f|)| |#=|→|#let| |ok| |#=| |ls| |=>| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |is|→|x| |#then| |#if| |odd|(|x|)| |#then| |C|(|f|(|x|)|,| |ok|(|t|)|)| |#else| |ok|(|t|)|←|↵|N| |#then| |N|←|↵|ok|(|map|(|xs|,| |g|)|)|↵|xs|←|↵|f|(|C|(|1|,| |C|(|2|,| |C|(|3|,| |C|(|4|,| |N|)|)|)|)|,| |x| |=>| |x| |+| |1|,| |x| |=>| |x| |*| |2|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun map = ls, f, => if ls is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun odd = x, => if (== (% (x,) (2,),) (0,)) then True else False; fun f = xs, g, f, => {let ok = ls, => if ls is ‹(C (h, t,)) then if h is ‹(x) then if (odd (x,)) then C (f (x,), ok (t,),) else ok (t,)›; (N) then N›; ok (map (xs, g,),); xs}; f (C (1, C (2, C (3, C (4, N,),),),), x, => + (x,) (1,), x, => * (x,) (2,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^61([C 1 [C 2 [C 3 [C 4 [N]]]]], (fun x² -> (x² + 1)), (fun x³ -> (x³ * 2)))
//│ def f(xs⁰, g⁰, f²) = 
//│ 	let ok⁰ = (fun ls¹ -> case ls¹ of {
//│ 		C h¹ t¹ => case h¹ of {
//│ 			x¹ => if odd^30(x¹) then [C f²(x¹) ok⁰(t¹)] else ok⁰(t¹)}
//│ 		| N  => [N]})
//│ 	in ok⁰(map^49(xs⁰, g⁰))
//│ 	xs⁰
//│ def map(ls⁰, f¹) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f¹(h⁰) map^5(t⁰, f¹)]
//│ 	| N  => [N]}
//│ def odd(x⁰) = if ((x⁰ % 2) == 0) then [True] else [False]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 
//│ 	[C 4 [C 8 [N]]]
//│ 	[C 1 [C 2 [C 3 [C 4 [N]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^61]
//│ 	[f^61 · map^49]
//│ 		[f^61 · map^49 · map^5] ---> [f^61 · map^49] (only one)
//│ 	[f^61 · odd^30] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([C 1 [C 2 [C 3 [C 4 [N]]]]], (fun x⁶ -> (x⁶ + 1)), (fun x⁷ -> (x⁷ * 2)))
//│ def f_₀(xs¹, g¹, f³) = 
//│ 	let ok¹ = (fun ls² -> case ls² of {
//│ 		C h² t² => case h² of {
//│ 			x⁵ => if odd_₀(x⁵) then [C f³(x⁵) ok¹(t²)] else ok¹(t²)}
//│ 		| N  => [N]})
//│ 	in ok¹(map_₀(xs¹, g¹))
//│ 	xs¹
//│ 	where
//│ 	def map_₀(ls³, f⁴) = 
//│ 		case ls³ of {
//│ 			C h³ t³ => [C f⁴(h³) map_₀(t³, f⁴)]
//│ 			| N  => [N]}
//│ 	def odd_₀(x⁴) = 
//│ 		if ((x⁴ % 2) == 0) then [True] else [False]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁴(h³) map_₀(t³, f⁴)]: 141 --->
//│ 	case ls² of {C h² t² => case h² of {x⁵ => if odd_₀(x⁵) then [C f³(x⁵) ok¹(t²)] else ok¹(t²)} | N  => [N]}: 117
//│ [N]: 142 --->
//│ 	case ls² of {C h² t² => case h² of {x⁵ => if odd_₀(x⁵) then [C f³(x⁵) ok¹(t²)] else ok¹(t²)} | N  => [N]}: 117
//│ [N]: 151 --->
//│ 	NoCons
//│ 	case ls³ of {C h³ t³ => [C f⁴(h³) map_₀(t³, f⁴)] | N  => [N]}: 143
//│ [C 4 [N]]: 152 --->
//│ 	NoCons
//│ 	case ls³ of {C h³ t³ => [C f⁴(h³) map_₀(t³, f⁴)] | N  => [N]}: 143
//│ [C 3 [C 4 [N]]]: 153 --->
//│ 	NoCons
//│ 	case ls³ of {C h³ t³ => [C f⁴(h³) map_₀(t³, f⁴)] | N  => [N]}: 143
//│ [C 2 [C 3 [C 4 [N]]]]: 154 --->
//│ 	NoCons
//│ 	case ls³ of {C h³ t³ => [C f⁴(h³) map_₀(t³, f⁴)] | N  => [N]}: 143
//│ [C 1 [C 2 [C 3 [C 4 [N]]]]]: 155 --->
//│ 	NoCons
//│ 	case ls³ of {C h³ t³ => [C f⁴(h³) map_₀(t³, f⁴)] | N  => [N]}: 143
//│ ------------------
//│ case ls² of {C h² t² => case h² of {x⁵ => if odd_₀(x⁵) then [C f³(x⁵) ok¹(t²)] else ok¹(t²)} | N  => [N]}: 117 --->
//│ 	[C f⁴(h³) map_₀(t³, f⁴)]: 141
//│ 	[N]: 142
//│ case ls³ of {C h³ t³ => [C f⁴(h³) map_₀(t³, f⁴)] | N  => [N]}: 143 --->
//│ 	[N]: 151
//│ 	[C 4 [N]]: 152
//│ 	[C 3 [C 4 [N]]]: 153
//│ 	[C 2 [C 3 [C 4 [N]]]]: 154
//│ 	[C 1 [C 2 [C 3 [C 4 [N]]]]]: 155
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁴(h³) map_₀(t³, f⁴)]: 141 --->
//│ 	case ls² of {C h² t² => case h² of {x⁵ => if odd_₀(x⁵) then [C f³(x⁵) ok¹(t²)] else ok¹(t²)} | N  => [N]}: 117
//│ [N]: 142 --->
//│ 	case ls² of {C h² t² => case h² of {x⁵ => if odd_₀(x⁵) then [C f³(x⁵) ok¹(t²)] else ok¹(t²)} | N  => [N]}: 117
//│ ------------------
//│ case ls² of {C h² t² => case h² of {x⁵ => if odd_₀(x⁵) then [C f³(x⁵) ok¹(t²)] else ok¹(t²)} | N  => [N]}: 117 --->
//│ 	[C f⁴(h³) map_₀(t³, f⁴)]: 141
//│ 	[N]: 142
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀([C 1 [C 2 [C 3 [C 4 [N]]]]], (fun x⁸ -> (x⁸ + 1)), (fun x⁹ -> (x⁹ * 2)))
//│ def f_₀(xs², g², f⁵) = 
//│ 	let ok² = (fun ls⁴ -> ls⁴(f⁵, ok²))
//│ 	in ok²(map_₀(xs², g²))
//│ 	xs²
//│ 	where
//│ 	def map_₀(ls⁵, f⁶) = 
//│ 		case ls⁵ of {
//│ 			C h³ t³ => 
//│ 				let t⁴ = map_₀(t³, f⁶)
//│ 				in let h⁴ = f⁶(h³)
//│ 				in (fun f⁷ -> (fun ok³ -> case h⁴ of {
//│ 					x⁵ => if odd_₀(x⁵) then [C f⁷(x⁵) ok³(t⁴)] else ok³(t⁴)}))
//│ 			| N  => (fun f⁸ -> (fun ok⁴ -> [N]))}
//│ 	def odd_₀(x¹⁰) = 
//│ 		if ((x¹⁰ % 2) == 0) then [True] else [False]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 
//│ 	[C 4 [C 8 [N]]]
//│ 	[C 1 [C 2 [C 3 [C 4 [N]]]]]
//│ <<<<<<< evaluate <<<<<<<



// unlines ls = concat (map (\l -> l ++ ['\n']) ls)
// concat(lss) = [ x | xs <- lss, x <- xs ]
_LUMBERHACK_EVAL
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun concat(lss) = if lss is
  C(hh, tt) then concatInner(hh, tt)
  N then N
fun concatInner(xs, xss) = if xs is
  C(h, t) then C(h, concatInner(t, xss))
  N then concat(xss)
fun map(xs, f) = if xs is
  C(h, t) then C(f(h), map(t, f))
  N then N
fun unlines(lss) = concat(map(lss, xs => append(xs, C(NL, N))))
fun main(lss) =
  unlines(lss)
  lss
main(C(
  C(AA, C(BB, N)),
  C(
    C(CC, C(DD, N)),
    C(
      C(EE, C(FF, N)),
      N
    )
  )
))
//│ |_LUMBERHACK_EVAL|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |concat|(|lss|)| |#=| |#if| |lss| |is|→|C|(|hh|,| |tt|)| |#then| |concatInner|(|hh|,| |tt|)|↵|N| |#then| |N|←|↵|#fun| |concatInner|(|xs|,| |xss|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |concatInner|(|t|,| |xss|)|)|↵|N| |#then| |concat|(|xss|)|←|↵|#fun| |map|(|xs|,| |f|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|t|,| |f|)|)|↵|N| |#then| |N|←|↵|#fun| |unlines|(|lss|)| |#=| |concat|(|map|(|lss|,| |xs| |=>| |append|(|xs|,| |C|(|NL|,| |N|)|)|)|)|↵|#fun| |main|(|lss|)| |#=|→|unlines|(|lss|)|↵|lss|←|↵|main|(|C|(|→|C|(|AA|,| |C|(|BB|,| |N|)|)|,|↵|C|(|→|C|(|CC|,| |C|(|DD|,| |N|)|)|,|↵|C|(|→|C|(|EE|,| |C|(|FF|,| |N|)|)|,|↵|N|←|↵|)|←|↵|)|←|↵|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun concat = lss, => if lss is ‹(C (hh, tt,)) then concatInner (hh, tt,); (N) then N›; fun concatInner = xs, xss, => if xs is ‹(C (h, t,)) then C (h, concatInner (t, xss,),); (N) then concat (xss,)›; fun map = xs, f, => if xs is ‹(C (h, t,)) then C (f (h,), map (t, f,),); (N) then N›; fun unlines = lss, => concat (map (lss, xs, => append (xs, C (NL, N,),),),); fun main = lss, => {unlines (lss,); lss}; main (C (C (AA, C (BB, N,),), C (C (CC, C (DD, N,),), C (C (EE, C (FF, N,),), N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^71([C [C [AA] [C [BB] [N]]] [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]])
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def concat(lss⁰) = case lss⁰ of {
//│ 	C hh⁰ tt⁰ => concatInner^14(hh⁰, tt⁰)
//│ 	| N  => [N]}
//│ def concatInner(xs¹, xss⁰) = case xs¹ of {
//│ 	C h¹ t¹ => [C h¹ concatInner^24(t¹, xss⁰)]
//│ 	| N  => concat^30(xss⁰)}
//│ def main(lss²) = 
//│ 	unlines^65(lss²)
//│ 	lss²
//│ def map(xs², f⁰) = case xs² of {
//│ 	C h² t² => [C f⁰(h²) map^40(t², f⁰)]
//│ 	| N  => [N]}
//│ def unlines(lss¹) = concat^50(map^51(lss¹, (fun xs³ -> append^54(xs³, [C [NL] [N]]))))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ 
//│ 	[C [AA] [C [BB] [C [NL] [C [CC] [C [DD] [C [NL] [C [EE] [C [FF] [C [NL] [N]]]]]]]]]]
//│ 	[C [C [AA] [C [BB] [N]]] [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [main^71] (hopeless to continue)
//│ 	[main^71 · unlines^65] (using original def)
//│ 		[main^71 · unlines^65 · append^54] (using original def)
//│ 			[main^71 · unlines^65 · append^54 · append^3] ---> [main^71 · unlines^65 · append^54] (using original def)
//│ 		[main^71 · unlines^65 · concat^50] (using original def)
//│ 			[main^71 · unlines^65 · concat^50 · concatInner^14] (using original def)
//│ 				[main^71 · unlines^65 · concat^50 · concatInner^14 · concatInner^24] ---> [main^71 · unlines^65 · concat^50 · concatInner^14] (using original def)
//│ 				[main^71 · unlines^65 · concat^50 · concatInner^14 · concat^30] ---> [main^71 · unlines^65 · concat^50] (using original def)
//│ 		[main^71 · unlines^65 · map^51] (using original def)
//│ 			[main^71 · unlines^65 · map^51 · map^40] ---> [main^71 · unlines^65 · map^51] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ main_₀([C [C [AA] [C [BB] [N]]] [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]])
//│ def main_₀(lss⁴) = 
//│ 	unlines_₀(lss⁴)
//│ 	lss⁴
//│ 	where
//│ 	def unlines_₀(lss⁵) = 
//│ 		concat_₀(map_₀(lss⁵, (fun xs⁴ -> append_₀(xs⁴, [C [NL] [N]]))))
//│ 		where
//│ 		def append_₀(xs⁶, ys¹) = 
//│ 			case xs⁶ of {
//│ 				C h⁴ t⁴ => [C h⁴ append_₀(t⁴, ys¹)]
//│ 				| N  => ys¹}
//│ 		def concat_₀(lss³) = 
//│ 			case lss³ of {
//│ 				C hh¹ tt¹ => concatInner_₀(hh¹, tt¹)
//│ 				| N  => [N]}
//│ 			where
//│ 			def concatInner_₀(xs⁷, xss¹) = 
//│ 				case xs⁷ of {
//│ 					C h⁵ t⁵ => [C h⁵ concatInner_₀(t⁵, xss¹)]
//│ 					| N  => concat_₀(xss¹)}
//│ 		def map_₀(xs⁵, f¹) = 
//│ 			case xs⁵ of {
//│ 				C h³ t³ => [C f¹(h³) map_₀(t³, f¹)]
//│ 				| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 115 --->
//│ 	case xs⁷ of {C h⁵ t⁵ => [C h⁵ concatInner_₀(t⁵, xss¹)] | N  => concat_₀(xss¹)}: 159
//│ [C [NL] [N]]: 116 --->
//│ 	case xs⁷ of {C h⁵ t⁵ => [C h⁵ concatInner_₀(t⁵, xss¹)] | N  => concat_₀(xss¹)}: 159
//│ [C f¹(h³) map_₀(t³, f¹)]: 131 --->
//│ 	case lss³ of {C hh¹ tt¹ => concatInner_₀(hh¹, tt¹) | N  => [N]}: 99
//│ [N]: 132 --->
//│ 	case lss³ of {C hh¹ tt¹ => concatInner_₀(hh¹, tt¹) | N  => [N]}: 99
//│ [C h⁴ append_₀(t⁴, ys¹)]: 143 --->
//│ 	case xs⁷ of {C h⁵ t⁵ => [C h⁵ concatInner_₀(t⁵, xss¹)] | N  => concat_₀(xss¹)}: 159
//│ [N]: 165 --->
//│ 	NoCons
//│ 	case xs⁶ of {C h⁴ t⁴ => [C h⁴ append_₀(t⁴, ys¹)] | N  => ys¹}: 145
//│ [C [BB] [N]]: 166 --->
//│ 	NoCons
//│ 	case xs⁶ of {C h⁴ t⁴ => [C h⁴ append_₀(t⁴, ys¹)] | N  => ys¹}: 145
//│ [C [AA] [C [BB] [N]]]: 167 --->
//│ 	NoCons
//│ 	case xs⁶ of {C h⁴ t⁴ => [C h⁴ append_₀(t⁴, ys¹)] | N  => ys¹}: 145
//│ [N]: 170 --->
//│ 	NoCons
//│ 	case xs⁶ of {C h⁴ t⁴ => [C h⁴ append_₀(t⁴, ys¹)] | N  => ys¹}: 145
//│ [C [DD] [N]]: 171 --->
//│ 	NoCons
//│ 	case xs⁶ of {C h⁴ t⁴ => [C h⁴ append_₀(t⁴, ys¹)] | N  => ys¹}: 145
//│ [C [CC] [C [DD] [N]]]: 172 --->
//│ 	NoCons
//│ 	case xs⁶ of {C h⁴ t⁴ => [C h⁴ append_₀(t⁴, ys¹)] | N  => ys¹}: 145
//│ [N]: 175 --->
//│ 	NoCons
//│ 	case xs⁶ of {C h⁴ t⁴ => [C h⁴ append_₀(t⁴, ys¹)] | N  => ys¹}: 145
//│ [C [FF] [N]]: 176 --->
//│ 	NoCons
//│ 	case xs⁶ of {C h⁴ t⁴ => [C h⁴ append_₀(t⁴, ys¹)] | N  => ys¹}: 145
//│ [C [EE] [C [FF] [N]]]: 177 --->
//│ 	NoCons
//│ 	case xs⁶ of {C h⁴ t⁴ => [C h⁴ append_₀(t⁴, ys¹)] | N  => ys¹}: 145
//│ [N]: 178 --->
//│ 	NoCons
//│ 	case xs⁵ of {C h³ t³ => [C f¹(h³) map_₀(t³, f¹)] | N  => [N]}: 133
//│ [C [C [EE] [C [FF] [N]]] [N]]: 179 --->
//│ 	NoCons
//│ 	case xs⁵ of {C h³ t³ => [C f¹(h³) map_₀(t³, f¹)] | N  => [N]}: 133
//│ [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]: 180 --->
//│ 	NoCons
//│ 	case xs⁵ of {C h³ t³ => [C f¹(h³) map_₀(t³, f¹)] | N  => [N]}: 133
//│ [C [C [AA] [C [BB] [N]]] [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]]: 181 --->
//│ 	NoCons
//│ 	case xs⁵ of {C h³ t³ => [C f¹(h³) map_₀(t³, f¹)] | N  => [N]}: 133
//│ ------------------
//│ case lss³ of {C hh¹ tt¹ => concatInner_₀(hh¹, tt¹) | N  => [N]}: 99 --->
//│ 	[C f¹(h³) map_₀(t³, f¹)]: 131
//│ 	[N]: 132
//│ case xs⁵ of {C h³ t³ => [C f¹(h³) map_₀(t³, f¹)] | N  => [N]}: 133 --->
//│ 	[N]: 178
//│ 	[C [C [EE] [C [FF] [N]]] [N]]: 179
//│ 	[C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]: 180
//│ 	[C [C [AA] [C [BB] [N]]] [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]]: 181
//│ case xs⁶ of {C h⁴ t⁴ => [C h⁴ append_₀(t⁴, ys¹)] | N  => ys¹}: 145 --->
//│ 	[N]: 165
//│ 	[C [BB] [N]]: 166
//│ 	[C [AA] [C [BB] [N]]]: 167
//│ 	[N]: 170
//│ 	[C [DD] [N]]: 171
//│ 	[C [CC] [C [DD] [N]]]: 172
//│ 	[N]: 175
//│ 	[C [FF] [N]]: 176
//│ 	[C [EE] [C [FF] [N]]]: 177
//│ case xs⁷ of {C h⁵ t⁵ => [C h⁵ concatInner_₀(t⁵, xss¹)] | N  => concat_₀(xss¹)}: 159 --->
//│ 	[N]: 115
//│ 	[C [NL] [N]]: 116
//│ 	[C h⁴ append_₀(t⁴, ys¹)]: 143
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 115 --->
//│ 	case xs⁷ of {C h⁵ t⁵ => [C h⁵ concatInner_₀(t⁵, xss¹)] | N  => concat_₀(xss¹)}: 159
//│ [C [NL] [N]]: 116 --->
//│ 	case xs⁷ of {C h⁵ t⁵ => [C h⁵ concatInner_₀(t⁵, xss¹)] | N  => concat_₀(xss¹)}: 159
//│ [C f¹(h³) map_₀(t³, f¹)]: 131 --->
//│ 	case lss³ of {C hh¹ tt¹ => concatInner_₀(hh¹, tt¹) | N  => [N]}: 99
//│ [N]: 132 --->
//│ 	case lss³ of {C hh¹ tt¹ => concatInner_₀(hh¹, tt¹) | N  => [N]}: 99
//│ [C h⁴ append_₀(t⁴, ys¹)]: 143 --->
//│ 	case xs⁷ of {C h⁵ t⁵ => [C h⁵ concatInner_₀(t⁵, xss¹)] | N  => concat_₀(xss¹)}: 159
//│ ------------------
//│ case lss³ of {C hh¹ tt¹ => concatInner_₀(hh¹, tt¹) | N  => [N]}: 99 --->
//│ 	[C f¹(h³) map_₀(t³, f¹)]: 131
//│ 	[N]: 132
//│ case xs⁷ of {C h⁵ t⁵ => [C h⁵ concatInner_₀(t⁵, xss¹)] | N  => concat_₀(xss¹)}: 159 --->
//│ 	[N]: 115
//│ 	[C [NL] [N]]: 116
//│ 	[C h⁴ append_₀(t⁴, ys¹)]: 143
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ main_₀([C [C [AA] [C [BB] [N]]] [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]])
//│ def main_₀(lss⁶) = 
//│ 	unlines_₀(lss⁶)
//│ 	lss⁶
//│ 	where
//│ 	def unlines_₀(lss⁸) = 
//│ 		concat_₀(map_₀(lss⁸, (fun xs¹⁰ -> append_₀(xs¹⁰, 
//│ 			let t⁷ = (fun xss⁴ -> concat_₀(xss⁴))
//│ 			in let h⁷ = [NL]
//│ 			in (fun xss³ -> [C h⁷ concatInner_₀(t⁷, xss³)])))))
//│ 		where
//│ 		def append_₀(xs⁹, ys²) = 
//│ 			case xs⁹ of {
//│ 				C h⁴ t⁴ => 
//│ 					let t⁶ = append_₀(t⁴, ys²)
//│ 					in let h⁶ = h⁴
//│ 					in (fun xss² -> [C h⁶ concatInner_₀(t⁶, xss²)])
//│ 				| N  => ys²}
//│ 		def concat_₀(lss⁷) = 
//│ 			lss⁷(99)
//│ 			where
//│ 			def concatInner_₀(xs¹¹, xss⁵) = 
//│ 				xs¹¹(xss⁵)
//│ 		def map_₀(xs⁸, f²) = 
//│ 			case xs⁸ of {
//│ 				C h³ t³ => 
//│ 					let tt² = map_₀(t³, f²)
//│ 					in let hh² = f²(h³)
//│ 					in (fun _lh_dummy⁰ -> concatInner_₀(hh², tt²))
//│ 				| N  => (fun _lh_dummy¹ -> [N])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ 
//│ 	[C [AA] [C [BB] [C [NL] [C [CC] [C [DD] [C [NL] [C [EE] [C [FF] [C [NL] [N]]]]]]]]]]
//│ 	[C [C [AA] [C [BB] [N]]] [C [C [CC] [C [DD] [N]]] [C [C [EE] [C [FF] [N]]] [N]]]]
//│ <<<<<<< evaluate <<<<<<<
