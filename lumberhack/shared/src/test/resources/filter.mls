:NewParser
:ParseOnly


fun filter(ls) = if ls is
  C(h, t) then f => if f(h) then C(h, filter(t)(f)) else filter(t)(f)
  N then f => N
fun predicate(x) = x > 3
filter(C(0, C(5, C(2, C(4, N)))))(predicate)
//│ |#fun| |filter|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |#if| |f|(|h|)| |#then| |C|(|h|,| |filter|(|t|)|(|f|)|)| |#else| |filter|(|t|)|(|f|)|↵|N| |#then| |f| |=>| |N|←|↵|#fun| |predicate|(|x|)| |#=| |x| |>| |3|↵|filter|(|C|(|0|,| |C|(|5|,| |C|(|2|,| |C|(|4|,| |N|)|)|)|)|)|(|predicate|)|
//│ Parsed: {fun filter = ls, => if ls is ‹(C (h, t,)) then f, => if (f (h,)) then C (h, filter (t,) (f,),) else filter (t,) (f,); (N) then f, => N›; fun predicate = x, => > (x,) (3,); filter (C (0, C (5, C (2, C (4, N,),),),),) (predicate,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ filter^29([C 0 [C 5 [C 2 [C 4 [N]]]]], predicate^40)
//│ def filter(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> if f⁰(h⁰) then [C h⁰ filter^6(t⁰, f⁰)] else filter^12(t⁰, f⁰))
//│ 	| N  => (fun f¹ -> [N])}
//│ def predicate(x⁰) = (x⁰ > 3)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [filter^29]
//│ 	[filter^29 · filter^12] ---> [filter^29] (only one)
//│ 	[filter^29 · filter^6] ---> [filter^29] (only one)
//│ [predicate^40] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ filter₀([C 0 [C 5 [C 2 [C 4 [N]]]]], predicate₀)
//│ def filter₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²))
//│ 		| N  => (fun f³ -> [N])}
//│ def predicate₀(x¹) = 
//│ 	(x¹ > 3)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 75 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 62
//│ [C 4 [N]]: 76 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 62
//│ [C 2 [C 4 [N]]]: 77 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 62
//│ [C 5 [C 2 [C 4 [N]]]]: 78 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 62
//│ [C 0 [C 5 [C 2 [C 4 [N]]]]]: 79 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 62
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 62 --->
//│ 	[N]: 75
//│ 	[C 4 [N]]: 76
//│ 	[C 2 [C 4 [N]]]: 77
//│ 	[C 5 [C 2 [C 4 [N]]]]: 78
//│ 	[C 0 [C 5 [C 2 [C 4 [N]]]]]: 79
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 75 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 62
//│ [C 4 [N]]: 76 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 62
//│ [C 2 [C 4 [N]]]: 77 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 62
//│ [C 5 [C 2 [C 4 [N]]]]: 78 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 62
//│ [C 0 [C 5 [C 2 [C 4 [N]]]]]: 79 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 62
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 62 --->
//│ 	[N]: 75
//│ 	[C 4 [N]]: 76
//│ 	[C 2 [C 4 [N]]]: 77
//│ 	[C 5 [C 2 [C 4 [N]]]]: 78
//│ 	[C 0 [C 5 [C 2 [C 4 [N]]]]]: 79
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ filter₀(
//│ 	let h² = 0
//│ 	in let t² = 	
//│ 		let h³ = 5
//│ 		in let t³ = 	
//│ 			let h⁴ = 2
//│ 			in let t⁴ = 	
//│ 				let h⁵ = 4
//│ 				in let t⁵ = (fun _lh_dummy⁴ -> (fun f⁸ -> [N]))
//│ 				in (fun _lh_dummy³ -> (fun f⁷ -> if f⁷(h⁵) then [C h⁵ filter₀(t⁵, f⁷)] else filter₀(t⁵, f⁷)))
//│ 			in (fun _lh_dummy² -> (fun f⁶ -> if f⁶(h⁴) then [C h⁴ filter₀(t⁴, f⁶)] else filter₀(t⁴, f⁶)))
//│ 		in (fun _lh_dummy¹ -> (fun f⁵ -> if f⁵(h³) then [C h³ filter₀(t³, f⁵)] else filter₀(t³, f⁵)))
//│ 	in (fun _lh_dummy⁰ -> (fun f⁴ -> if f⁴(h²) then [C h² filter₀(t², f⁴)] else filter₀(t², f⁴))), predicate₀)
//│ def filter₀(ls²) = 
//│ 	ls²(99)
//│ def predicate₀(x²) = 
//│ 	(x² > 3)
//│ <<<<<<< after fusion <<<<<<<



// NOTE: infinite list as producer
fun filter(ls) = if ls is
  C(h, t) then f => if f(h) then C(h, filter(t)(f)) else filter(t)(f)
  N then f => N
fun predicate(x) = x > 3
let l = C(0, C(5, C(2, C(4, C(1, l)))))
filter(l)(predicate)
//│ |#fun| |filter|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |#if| |f|(|h|)| |#then| |C|(|h|,| |filter|(|t|)|(|f|)|)| |#else| |filter|(|t|)|(|f|)|↵|N| |#then| |f| |=>| |N|←|↵|#fun| |predicate|(|x|)| |#=| |x| |>| |3|↵|#let| |l| |#=| |C|(|0|,| |C|(|5|,| |C|(|2|,| |C|(|4|,| |C|(|1|,| |l|)|)|)|)|)|↵|filter|(|l|)|(|predicate|)|
//│ Parsed: {fun filter = ls, => if ls is ‹(C (h, t,)) then f, => if (f (h,)) then C (h, filter (t,) (f,),) else filter (t,) (f,); (N) then f, => N›; fun predicate = x, => > (x,) (3,); let l = C (0, C (5, C (2, C (4, C (1, l,),),),),); filter (l,) (predicate,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ filter^40(l^41, predicate^43)
//│ def filter(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> if f⁰(h⁰) then [C h⁰ filter^6(t⁰, f⁰)] else filter^12(t⁰, f⁰))
//│ 	| N  => (fun f¹ -> [N])}
//│ def l = [C 0 [C 5 [C 2 [C 4 [C 1 l^34]]]]]
//│ def predicate(x⁰) = (x⁰ > 3)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [filter^40]
//│ 	[filter^40 · filter^12] ---> [filter^40] (only one)
//│ 	[filter^40 · filter^6] ---> [filter^40] (only one)
//│ [l^41]
//│ 	[l^41 · l^34] ---> [l^41] (only one)
//│ [predicate^43] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ filter₀(l₀, predicate₀)
//│ def filter₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²))
//│ 		| N  => (fun f³ -> [N])}
//│ def l₀ = 
//│ 	[C 0 [C 5 [C 2 [C 4 [C 1 l₀]]]]]
//│ def predicate₀(x¹) = 
//│ 	(x¹ > 3)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 l₀]: 79 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 65
//│ [C 4 [C 1 l₀]]: 80 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 65
//│ [C 2 [C 4 [C 1 l₀]]]: 81 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 65
//│ [C 5 [C 2 [C 4 [C 1 l₀]]]]: 82 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 65
//│ [C 0 [C 5 [C 2 [C 4 [C 1 l₀]]]]]: 83 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 65
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 65 --->
//│ 	[C 1 l₀]: 79
//│ 	[C 4 [C 1 l₀]]: 80
//│ 	[C 2 [C 4 [C 1 l₀]]]: 81
//│ 	[C 5 [C 2 [C 4 [C 1 l₀]]]]: 82
//│ 	[C 0 [C 5 [C 2 [C 4 [C 1 l₀]]]]]: 83
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 l₀]: 79 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 65
//│ [C 4 [C 1 l₀]]: 80 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 65
//│ [C 2 [C 4 [C 1 l₀]]]: 81 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 65
//│ [C 5 [C 2 [C 4 [C 1 l₀]]]]: 82 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 65
//│ [C 0 [C 5 [C 2 [C 4 [C 1 l₀]]]]]: 83 --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 65
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => (fun f² -> if f²(h¹) then [C h¹ filter₀(t¹, f²)] else filter₀(t¹, f²)) | N  => (fun f³ -> [N])}: 65 --->
//│ 	[C 1 l₀]: 79
//│ 	[C 4 [C 1 l₀]]: 80
//│ 	[C 2 [C 4 [C 1 l₀]]]: 81
//│ 	[C 5 [C 2 [C 4 [C 1 l₀]]]]: 82
//│ 	[C 0 [C 5 [C 2 [C 4 [C 1 l₀]]]]]: 83
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ filter₀(l₀, predicate₀)
//│ def filter₀(ls²) = 
//│ 	ls²(99)
//│ def l₀ = 
//│ 	let h² = 0
//│ 	in let t² = 	
//│ 		let h³ = 5
//│ 		in let t³ = 	
//│ 			let h⁴ = 2
//│ 			in let t⁴ = 	
//│ 				let h⁵ = 4
//│ 				in let t⁵ = 	
//│ 					let h⁶ = 1
//│ 					in let t⁶ = l₀
//│ 					in (fun _lh_dummy⁴ -> (fun f⁸ -> if f⁸(h⁶) then [C h⁶ filter₀(t⁶, f⁸)] else filter₀(t⁶, f⁸)))
//│ 				in (fun _lh_dummy³ -> (fun f⁷ -> if f⁷(h⁵) then [C h⁵ filter₀(t⁵, f⁷)] else filter₀(t⁵, f⁷)))
//│ 			in (fun _lh_dummy² -> (fun f⁶ -> if f⁶(h⁴) then [C h⁴ filter₀(t⁴, f⁶)] else filter₀(t⁴, f⁶)))
//│ 		in (fun _lh_dummy¹ -> (fun f⁵ -> if f⁵(h³) then [C h³ filter₀(t³, f⁵)] else filter₀(t³, f⁵)))
//│ 	in (fun _lh_dummy⁰ -> (fun f⁴ -> if f⁴(h²) then [C h² filter₀(t², f⁴)] else filter₀(t², f⁴)))
//│ def predicate₀(x²) = 
//│ 	(x² > 3)
//│ <<<<<<< after fusion <<<<<<<

// WRONG: infinite list and recusive length match
// :stdout
fun filter(ls) = if ls is
  C(h, t) then f =>
    let tail = if t is
      C(hh, tt) then if f(hh) then C(hh, filter(tt)(f)) else filter(tt)(f)
    if f(h) then C(h, tail) else tail
fun predicate(x) = x > 3
let l = C(0, C(5, C(2, C(4, C(1, l)))))
filter(l)(predicate)
//│ |#fun| |filter|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>|→|#let| |tail| |#=| |#if| |t| |is|→|C|(|hh|,| |tt|)| |#then| |#if| |f|(|hh|)| |#then| |C|(|hh|,| |filter|(|tt|)|(|f|)|)| |#else| |filter|(|tt|)|(|f|)|←|↵|#if| |f|(|h|)| |#then| |C|(|h|,| |tail|)| |#else| |tail|←|←|↵|#fun| |predicate|(|x|)| |#=| |x| |>| |3|↵|#let| |l| |#=| |C|(|0|,| |C|(|5|,| |C|(|2|,| |C|(|4|,| |C|(|1|,| |l|)|)|)|)|)|↵|filter|(|l|)|(|predicate|)|
//│ Parsed: {fun filter = ls, => if ls is ‹(C (h, t,)) then f, => {let tail = if t is ‹(C (hh, tt,)) then if (f (hh,)) then C (hh, filter (tt,) (f,),) else filter (tt,) (f,)›; if (f (h,)) then C (h, tail,) else tail}›; fun predicate = x, => > (x,) (3,); let l = C (0, C (5, C (2, C (4, C (1, l,),),),),); filter (l,) (predicate,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ filter^49(l^50, predicate^52)
//│ def filter(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> 
//│ 		let tail⁰ = case t⁰ of {
//│ 			C hh⁰ tt⁰ => if f⁰(hh⁰) then [C hh⁰ filter^7(tt⁰, f⁰)] else filter^13(tt⁰, f⁰)}
//│ 		in if f⁰(h⁰) then [C h⁰ tail⁰] else tail⁰)}
//│ def l = [C 0 [C 5 [C 2 [C 4 [C 1 l^43]]]]]
//│ def predicate(x⁰) = (x⁰ > 3)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [filter^49]
//│ 	[filter^49 · filter^13] ---> [filter^49] (only one)
//│ 	[filter^49 · filter^7] ---> [filter^49] (only one)
//│ [l^50]
//│ 	[l^50 · l^43] ---> [l^50] (only one)
//│ [predicate^52] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ filter₀(l₀, predicate₀)
//│ def filter₀(ls¹) = 
//│ 	case ls¹ of {
//│ 		C h¹ t¹ => (fun f¹ -> 
//│ 			let tail¹ = case t¹ of {
//│ 				C hh¹ tt¹ => if f¹(hh¹) then [C hh¹ filter₀(tt¹, f¹)] else filter₀(tt¹, f¹)}
//│ 			in if f¹(h¹) then [C h¹ tail¹] else tail¹)}
//│ def l₀ = 
//│ 	[C 0 [C 5 [C 2 [C 4 [C 1 l₀]]]]]
//│ def predicate₀(x¹) = 
//│ 	(x¹ > 3)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 l₀]: 97 --->
//│ 	case t¹ of {C hh¹ tt¹ => if f¹(hh¹) then [C hh¹ filter₀(tt¹, f¹)] else filter₀(tt¹, f¹)}: 72
//│ 	case ls¹ of {C h¹ t¹ => (fun f¹ -> let tail¹ = case t¹ of {C hh¹ tt¹ => if f¹(hh¹) then [C hh¹ filter₀(tt¹, f¹)] else filter₀(tt¹, f¹)}
//│ in if f¹(h¹) then [C h¹ tail¹] else tail¹)}: 83
//│ [C 4 [C 1 l₀]]: 98 --->
//│ 	case t¹ of {C hh¹ tt¹ => if f¹(hh¹) then [C hh¹ filter₀(tt¹, f¹)] else filter₀(tt¹, f¹)}: 72
//│ 	case ls¹ of {C h¹ t¹ => (fun f¹ -> let tail¹ = case t¹ of {C hh¹ tt¹ => if f¹(hh¹) then [C hh¹ filter₀(tt¹, f¹)] else filter₀(tt¹, f¹)}
//│ in if f¹(h¹) then [C h¹ tail¹] else tail¹)}: 83
//│ [C 2 [C 4 [C 1 l₀]]]: 99 --->
//│ 	case t¹ of {C hh¹ tt¹ => if f¹(hh¹) then [C hh¹ filter₀(tt¹, f¹)] else filter₀(tt¹, f¹)}: 72
//│ 	case ls¹ of {C h¹ t¹ => (fun f¹ -> let tail¹ = case t¹ of {C hh¹ tt¹ => if f¹(hh¹) then [C hh¹ filter₀(tt¹, f¹)] else filter₀(tt¹, f¹)}
//│ in if f¹(h¹) then [C h¹ tail¹] else tail¹)}: 83
//│ [C 5 [C 2 [C 4 [C 1 l₀]]]]: 100 --->
//│ 	case t¹ of {C hh¹ tt¹ => if f¹(hh¹) then [C hh¹ filter₀(tt¹, f¹)] else filter₀(tt¹, f¹)}: 72
//│ 	case ls¹ of {C h¹ t¹ => (fun f¹ -> let tail¹ = case t¹ of {C hh¹ tt¹ => if f¹(hh¹) then [C hh¹ filter₀(tt¹, f¹)] else filter₀(tt¹, f¹)}
//│ in if f¹(h¹) then [C h¹ tail¹] else tail¹)}: 83
//│ [C 0 [C 5 [C 2 [C 4 [C 1 l₀]]]]]: 101 --->
//│ 	case t¹ of {C hh¹ tt¹ => if f¹(hh¹) then [C hh¹ filter₀(tt¹, f¹)] else filter₀(tt¹, f¹)}: 72
//│ 	case ls¹ of {C h¹ t¹ => (fun f¹ -> let tail¹ = case t¹ of {C hh¹ tt¹ => if f¹(hh¹) then [C hh¹ filter₀(tt¹, f¹)] else filter₀(tt¹, f¹)}
//│ in if f¹(h¹) then [C h¹ tail¹] else tail¹)}: 83
//│ ------------------
//│ case t¹ of {C hh¹ tt¹ => if f¹(hh¹) then [C hh¹ filter₀(tt¹, f¹)] else filter₀(tt¹, f¹)}: 72 --->
//│ 	[C 1 l₀]: 97
//│ 	[C 4 [C 1 l₀]]: 98
//│ 	[C 2 [C 4 [C 1 l₀]]]: 99
//│ 	[C 5 [C 2 [C 4 [C 1 l₀]]]]: 100
//│ 	[C 0 [C 5 [C 2 [C 4 [C 1 l₀]]]]]: 101
//│ case ls¹ of {C h¹ t¹ => (fun f¹ -> let tail¹ = case t¹ of {C hh¹ tt¹ => if f¹(hh¹) then [C hh¹ filter₀(tt¹, f¹)] else filter₀(tt¹, f¹)}
//│ in if f¹(h¹) then [C h¹ tail¹] else tail¹)}: 83 --->
//│ 	[C 1 l₀]: 97
//│ 	[C 4 [C 1 l₀]]: 98
//│ 	[C 2 [C 4 [C 1 l₀]]]: 99
//│ 	[C 5 [C 2 [C 4 [C 1 l₀]]]]: 100
//│ 	[C 0 [C 5 [C 2 [C 4 [C 1 l₀]]]]]: 101
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ filter₀(l₀, predicate₀)
//│ def filter₀(ls²) = 
//│ 	case ls² of {
//│ 		C h¹ t¹ => (fun f² -> 
//│ 			let tail² = case t¹ of {
//│ 				C hh¹ tt¹ => if f²(hh¹) then [C hh¹ filter₀(tt¹, f²)] else filter₀(tt¹, f²)}
//│ 			in if f²(h¹) then [C h¹ tail²] else tail²)}
//│ def l₀ = 
//│ 	[C 0 [C 5 [C 2 [C 4 [C 1 l₀]]]]]
//│ def predicate₀(x²) = 
//│ 	(x² > 3)
//│ <<<<<<< after fusion <<<<<<<
