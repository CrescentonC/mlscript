:NewParser
:ParseOnly

// NOTE: naive implementation using list append
:lhInHaskell
flatten (Leaf x) = [x]
flatten (Node t1 t2) = (flatten t1) ++ (flatten t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_lh^29
//│ def flatten_lh(_lh_flatten_arg1⁰) = case _lh_flatten_arg1⁰ of {
//│ 	Leaf _lh_flatten_Leaf_0⁰ => [LH_C _lh_flatten_Leaf_0⁰ [LH_N]]
//│ 	| Node _lh_flatten_Node_0⁰ _lh_flatten_Node_1⁰ => mappend_lh^17(flatten_lh^18(_lh_flatten_Node_0⁰), flatten_lh^22(_lh_flatten_Node_1⁰))
//│ 	| _  => error⁰}
//│ def mappend_lh(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh^3(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten_lh^29] (hopeless to continue)
//│ 	[flatten_lh^29 · flatten_lh^18] ---> [flatten_lh^29] (using original def)
//│ 	[flatten_lh^29 · flatten_lh^22] ---> [flatten_lh^29] (using original def)
//│ 	[flatten_lh^29 · mappend_lh^17] (using original def)
//│ 		[flatten_lh^29 · mappend_lh^17 · mappend_lh^3] ---> [flatten_lh^29 · mappend_lh^17] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten_lh_₀
//│ def flatten_lh_₀(_lh_flatten_arg1¹) = 
//│ 	case _lh_flatten_arg1¹ of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ [LH_N]]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => mappend_lh_₀(flatten_lh_₀(_lh_flatten_Node_0¹), flatten_lh_₀(_lh_flatten_Node_1¹))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mappend_lh_₀(xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			LH_C h¹ t¹ => [LH_C h¹ mappend_lh_₀(t¹, ys¹)]
//│ 			| LH_N  => ys¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h¹ mappend_lh_₀(t¹, ys¹)]: 37 --->
//│ 	NoCons
//│ 	case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend_lh_₀(t¹, ys¹)] | LH_N  => ys¹}: 39
//│ [LH_N]: 44 --->
//│ 	NoCons
//│ 	case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend_lh_₀(t¹, ys¹)] | LH_N  => ys¹}: 39
//│ [LH_C _lh_flatten_Leaf_0¹ [LH_N]]: 45 --->
//│ 	NoCons
//│ 	case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend_lh_₀(t¹, ys¹)] | LH_N  => ys¹}: 39
//│ ------------------
//│ case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend_lh_₀(t¹, ys¹)] | LH_N  => ys¹}: 39 --->
//│ 	[LH_C h¹ mappend_lh_₀(t¹, ys¹)]: 37
//│ 	[LH_N]: 44
//│ 	[LH_C _lh_flatten_Leaf_0¹ [LH_N]]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_lh_₀
//│ def flatten_lh_₀(_lh_flatten_arg1²) = 
//│ 	case _lh_flatten_arg1² of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ [LH_N]]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => mappend_lh_₀(flatten_lh_₀(_lh_flatten_Node_0¹), flatten_lh_₀(_lh_flatten_Node_1¹))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mappend_lh_₀(xs², ys²) = 
//│ 		case xs² of {
//│ 			LH_C h¹ t¹ => [LH_C h¹ mappend_lh_₀(t¹, ys²)]
//│ 			| LH_N  => ys²}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: using accumulating parameter
:lhInHaskell
flatten (Leaf x) a = x:a
flatten (Node t1 t2) a = flatten t1 $ flatten t2 a
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_lh^18
//│ def flatten_lh(_lh_flatten_arg1⁰, _lh_flatten_arg2⁰) = case _lh_flatten_arg1⁰ of {
//│ 	Leaf _lh_flatten_Leaf_0⁰ => [LH_C _lh_flatten_Leaf_0⁰ _lh_flatten_arg2⁰]
//│ 	| Node _lh_flatten_Node_0⁰ _lh_flatten_Node_1⁰ => flatten_lh^5(_lh_flatten_Node_0⁰, flatten_lh^8(_lh_flatten_Node_1⁰, _lh_flatten_arg2⁰))
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten_lh^18] (hopeless to continue)
//│ 	[flatten_lh^18 · flatten_lh^5] ---> [flatten_lh^18] (using original def)
//│ 	[flatten_lh^18 · flatten_lh^8] ---> [flatten_lh^18] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten_lh_₀
//│ def flatten_lh_₀(_lh_flatten_arg1¹, _lh_flatten_arg2¹) = 
//│ 	case _lh_flatten_arg1¹ of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ _lh_flatten_arg2¹]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => flatten_lh_₀(_lh_flatten_Node_0¹, flatten_lh_₀(_lh_flatten_Node_1¹, _lh_flatten_arg2¹))
//│ 		| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_lh_₀
//│ def flatten_lh_₀(_lh_flatten_arg1², _lh_flatten_arg2²) = 
//│ 	case _lh_flatten_arg1² of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ _lh_flatten_arg2²]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => flatten_lh_₀(_lh_flatten_Node_0¹, flatten_lh_₀(_lh_flatten_Node_1¹, _lh_flatten_arg2²))
//│ 		| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: using higer order function (which is essentially the same as the above one?)
:lhInHaskell
flatten t = walk t []
walk (Leaf x) = \t -> (x:t)
walk (Node t1 t2) = (walk t1) . (walk t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_lh^25
//│ def flatten_lh(_lh_flatten_arg1⁰) = walk_lh^1(_lh_flatten_arg1⁰, [LH_N])
//│ def walk_lh(_lh_walk_arg1⁰) = case _lh_walk_arg1⁰ of {
//│ 	Leaf _lh_walk_Leaf_0⁰ => (fun t⁰ -> [LH_C _lh_walk_Leaf_0⁰ t⁰])
//│ 	| Node _lh_walk_Node_0⁰ _lh_walk_Node_1⁰ => (fun _lh_funcomp_x⁰ -> walk_lh^12(_lh_walk_Node_0⁰, walk_lh^15(_lh_walk_Node_1⁰, _lh_funcomp_x⁰)))
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten_lh^25] (hopeless to continue)
//│ 	[flatten_lh^25 · walk_lh^1] (using original def)
//│ 		[flatten_lh^25 · walk_lh^1 · walk_lh^12] ---> [flatten_lh^25 · walk_lh^1] (using original def)
//│ 		[flatten_lh^25 · walk_lh^1 · walk_lh^15] ---> [flatten_lh^25 · walk_lh^1] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten_lh_₀
//│ def flatten_lh_₀(_lh_flatten_arg1¹) = 
//│ 	walk_lh_₀(_lh_flatten_arg1¹, [LH_N])
//│ 	where
//│ 	def walk_lh_₀(_lh_walk_arg1¹) = 
//│ 		case _lh_walk_arg1¹ of {
//│ 			Leaf _lh_walk_Leaf_0¹ => (fun t¹ -> [LH_C _lh_walk_Leaf_0¹ t¹])
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => (fun _lh_funcomp_x¹ -> walk_lh_₀(_lh_walk_Node_0¹, walk_lh_₀(_lh_walk_Node_1¹, _lh_funcomp_x¹)))
//│ 			| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_lh_₀
//│ def flatten_lh_₀(_lh_flatten_arg1²) = 
//│ 	walk_lh_₀(_lh_flatten_arg1², [LH_N])
//│ 	where
//│ 	def walk_lh_₀(_lh_walk_arg1²) = 
//│ 		case _lh_walk_arg1² of {
//│ 			Leaf _lh_walk_Leaf_0¹ => (fun t² -> [LH_C _lh_walk_Leaf_0¹ t²])
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => (fun _lh_funcomp_x² -> walk_lh_₀(_lh_walk_Node_0¹, walk_lh_₀(_lh_walk_Node_1¹, _lh_funcomp_x²)))
//│ 			| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: defunctionalized,
// after fusion this will be the same as the above one using higher order function
:lhInHaskell
apply (LamCons x)  xs = x:xs
apply (LamO f1 f2) xs = apply f1 (apply f2 xs)
flatten t = apply (walk t) []
walk (Leaf x)     = LamCons x
walk (Node t1 t2) = LamO (walk t1) (walk t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_lh^39
//│ def apply_lh(_lh_apply_arg1⁰, _lh_apply_arg2⁰) = case _lh_apply_arg1⁰ of {
//│ 	LamCons _lh_apply_LamCons_0⁰ => [LH_C _lh_apply_LamCons_0⁰ _lh_apply_arg2⁰]
//│ 	| LamO _lh_apply_LamO_0⁰ _lh_apply_LamO_1⁰ => apply_lh^26(_lh_apply_LamO_0⁰, apply_lh^29(_lh_apply_LamO_1⁰, _lh_apply_arg2⁰))
//│ 	| _  => error⁰}
//│ def flatten_lh(_lh_flatten_arg1⁰) = apply_lh^1(walk_lh^2(_lh_flatten_arg1⁰), [LH_N])
//│ def walk_lh(_lh_walk_arg1⁰) = case _lh_walk_arg1⁰ of {
//│ 	Leaf _lh_walk_Leaf_0⁰ => [LamCons _lh_walk_Leaf_0⁰]
//│ 	| Node _lh_walk_Node_0⁰ _lh_walk_Node_1⁰ => [LamO walk_lh^12(_lh_walk_Node_0⁰) walk_lh^15(_lh_walk_Node_1⁰)]
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten_lh^39] (hopeless to continue)
//│ 	[flatten_lh^39 · apply_lh^1] (using original def)
//│ 		[flatten_lh^39 · apply_lh^1 · apply_lh^26] ---> [flatten_lh^39 · apply_lh^1] (using original def)
//│ 		[flatten_lh^39 · apply_lh^1 · apply_lh^29] ---> [flatten_lh^39 · apply_lh^1] (using original def)
//│ 	[flatten_lh^39 · walk_lh^2] (using original def)
//│ 		[flatten_lh^39 · walk_lh^2 · walk_lh^12] ---> [flatten_lh^39 · walk_lh^2] (using original def)
//│ 		[flatten_lh^39 · walk_lh^2 · walk_lh^15] ---> [flatten_lh^39 · walk_lh^2] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten_lh_₀
//│ def flatten_lh_₀(_lh_flatten_arg1¹) = 
//│ 	apply_lh_₀(walk_lh_₀(_lh_flatten_arg1¹), [LH_N])
//│ 	where
//│ 	def apply_lh_₀(_lh_apply_arg1¹, _lh_apply_arg2¹) = 
//│ 		case _lh_apply_arg1¹ of {
//│ 			LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹]
//│ 			| LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_lh_₀(_lh_apply_LamO_0¹, apply_lh_₀(_lh_apply_LamO_1¹, _lh_apply_arg2¹))
//│ 			| _  => error⁰}
//│ 	def walk_lh_₀(_lh_walk_arg1¹) = 
//│ 		case _lh_walk_arg1¹ of {
//│ 			Leaf _lh_walk_Leaf_0¹ => [LamCons _lh_walk_Leaf_0¹]
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => [LamO walk_lh_₀(_lh_walk_Node_0¹) walk_lh_₀(_lh_walk_Node_1¹)]
//│ 			| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LamCons _lh_walk_Leaf_0¹]: 42 --->
//│ 	case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_lh_₀(_lh_apply_LamO_0¹, apply_lh_₀(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 67
//│ [LamO walk_lh_₀(_lh_walk_Node_0¹) walk_lh_₀(_lh_walk_Node_1¹)]: 49 --->
//│ 	case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_lh_₀(_lh_apply_LamO_0¹, apply_lh_₀(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 67
//│ ------------------
//│ case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_lh_₀(_lh_apply_LamO_0¹, apply_lh_₀(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 67 --->
//│ 	[LamCons _lh_walk_Leaf_0¹]: 42
//│ 	[LamO walk_lh_₀(_lh_walk_Node_0¹) walk_lh_₀(_lh_walk_Node_1¹)]: 49
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LamCons _lh_walk_Leaf_0¹]: 42 --->
//│ 	case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_lh_₀(_lh_apply_LamO_0¹, apply_lh_₀(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 67
//│ [LamO walk_lh_₀(_lh_walk_Node_0¹) walk_lh_₀(_lh_walk_Node_1¹)]: 49 --->
//│ 	case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_lh_₀(_lh_apply_LamO_0¹, apply_lh_₀(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 67
//│ ------------------
//│ case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_lh_₀(_lh_apply_LamO_0¹, apply_lh_₀(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 67 --->
//│ 	[LamCons _lh_walk_Leaf_0¹]: 42
//│ 	[LamO walk_lh_₀(_lh_walk_Node_0¹) walk_lh_₀(_lh_walk_Node_1¹)]: 49
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_lh_₀
//│ def flatten_lh_₀(_lh_flatten_arg1²) = 
//│ 	apply_lh_₀(walk_lh_₀(_lh_flatten_arg1²), [LH_N])
//│ 	where
//│ 	def apply_lh_₀(_lh_apply_arg1², _lh_apply_arg2⁴) = 
//│ 		_lh_apply_arg1²(_lh_apply_arg2⁴)
//│ 	def walk_lh_₀(_lh_walk_arg1²) = 
//│ 		case _lh_walk_arg1² of {
//│ 			Leaf _lh_walk_Leaf_0¹ => 
//│ 				let _lh_apply_LamCons_0² = _lh_walk_Leaf_0¹
//│ 				in (fun _lh_apply_arg2² -> [LH_C _lh_apply_LamCons_0² _lh_apply_arg2²])
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => 
//│ 				let _lh_apply_LamO_1² = walk_lh_₀(_lh_walk_Node_1¹)
//│ 				in let _lh_apply_LamO_0² = walk_lh_₀(_lh_walk_Node_0¹)
//│ 				in (fun _lh_apply_arg2³ -> apply_lh_₀(_lh_apply_LamO_0², apply_lh_₀(_lh_apply_LamO_1², _lh_apply_arg2³)))
//│ 			| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
