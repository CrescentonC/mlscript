:NewParser
:ParseOnly

// NOTE: naive implementation using list append
:lhInHaskell
flatten (Leaf x) = [x]
flatten (Node t1 t2) = (flatten t1) ++ (flatten t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_₀^649
//│ def flatten_₀(_lh_flatten_arg1¹) = case _lh_flatten_arg1¹ of {
//│ 	Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ [LH_N]]
//│ 	| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => mappend_₀^637(flatten_₀^638(_lh_flatten_Node_0¹), flatten_₀^642(_lh_flatten_Node_1¹))
//│ 	| _  => error⁰}
//│ def mappend_₀(xs⁹, ys⁹) = case xs⁹ of {
//│ 	LH_C h²⁰ t²² => [LH_C h²⁰ mappend_₀^623(t²², ys⁹)]
//│ 	| LH_N  => ys⁹}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten_₀^649]
//│ 	[flatten_₀^649 · flatten_₀^638] ---> [flatten_₀^649] (only one)
//│ 	[flatten_₀^649 · flatten_₀^642] ---> [flatten_₀^649] (only one)
//│ 	[flatten_₀^649 · mappend_₀^637]
//│ 		[flatten_₀^649 · mappend_₀^637 · mappend_₀^623] ---> [flatten_₀^649 · mappend_₀^637] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1¹) = 
//│ 	case _lh_flatten_arg1¹ of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ [LH_N]]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => mappend_₀_₀(flatten_₀_₀(_lh_flatten_Node_0¹), flatten_₀_₀(_lh_flatten_Node_1¹))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mappend_₀_₀(xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			LH_C h¹ t¹ => [LH_C h¹ mappend_₀_₀(t¹, ys¹)]
//│ 			| LH_N  => ys¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 32 --->
//│ 	NoCons
//│ 	case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend_₀_₀(t¹, ys¹)] | LH_N  => ys¹}: 55
//│ [LH_C _lh_flatten_Leaf_0¹ [LH_N]]: 33 --->
//│ 	NoCons
//│ 	case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend_₀_₀(t¹, ys¹)] | LH_N  => ys¹}: 55
//│ [LH_C h¹ mappend_₀_₀(t¹, ys¹)]: 53 --->
//│ 	NoCons
//│ 	case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend_₀_₀(t¹, ys¹)] | LH_N  => ys¹}: 55
//│ ------------------
//│ case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend_₀_₀(t¹, ys¹)] | LH_N  => ys¹}: 55 --->
//│ 	[LH_N]: 32
//│ 	[LH_C _lh_flatten_Leaf_0¹ [LH_N]]: 33
//│ 	[LH_C h¹ mappend_₀_₀(t¹, ys¹)]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1²) = 
//│ 	case _lh_flatten_arg1² of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ [LH_N]]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => mappend_₀_₀(flatten_₀_₀(_lh_flatten_Node_0¹), flatten_₀_₀(_lh_flatten_Node_1¹))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mappend_₀_₀(xs², ys²) = 
//│ 		case xs² of {
//│ 			LH_C h¹ t¹ => [LH_C h¹ mappend_₀_₀(t¹, ys²)]
//│ 			| LH_N  => ys²}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: using accumulating parameter
:lhInHaskell
flatten (Leaf x) a = x:a
flatten (Node t1 t2) a = flatten t1 $ flatten t2 a
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_₀^639
//│ def flatten_₀(_lh_flatten_arg1¹, _lh_flatten_arg2¹) = case _lh_flatten_arg1¹ of {
//│ 	Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ _lh_flatten_arg2¹]
//│ 	| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => flatten_₀^626(_lh_flatten_Node_0¹, flatten_₀^629(_lh_flatten_Node_1¹, _lh_flatten_arg2¹))
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten_₀^639]
//│ 	[flatten_₀^639 · flatten_₀^626] ---> [flatten_₀^639] (only one)
//│ 	[flatten_₀^639 · flatten_₀^629] ---> [flatten_₀^639] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1¹, _lh_flatten_arg2¹) = 
//│ 	case _lh_flatten_arg1¹ of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ _lh_flatten_arg2¹]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => flatten_₀_₀(_lh_flatten_Node_0¹, flatten_₀_₀(_lh_flatten_Node_1¹, _lh_flatten_arg2¹))
//│ 		| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1², _lh_flatten_arg2²) = 
//│ 	case _lh_flatten_arg1² of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ _lh_flatten_arg2²]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => flatten_₀_₀(_lh_flatten_Node_0¹, flatten_₀_₀(_lh_flatten_Node_1¹, _lh_flatten_arg2²))
//│ 		| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: using higer order function (which is essentially the same as the above one?)
:lhInHaskell
flatten t = walk t []
walk (Leaf x) = \t -> (x:t)
walk (Node t1 t2) = (walk t1) . (walk t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_₀^653
//│ def flatten_₀(_lh_flatten_arg1¹) = walk_₀^629(_lh_flatten_arg1¹, [LH_N])
//│ def walk_₀(_lh_walk_arg1¹) = case _lh_walk_arg1¹ of {
//│ 	Leaf _lh_walk_Leaf_0¹ => (fun t²³ -> [LH_C _lh_walk_Leaf_0¹ t²³])
//│ 	| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => (fun _lh_funcomp_x¹ -> walk_₀^640(_lh_walk_Node_0¹, walk_₀^643(_lh_walk_Node_1¹, _lh_funcomp_x¹)))
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten_₀^653]
//│ 	[flatten_₀^653 · walk_₀^629]
//│ 		[flatten_₀^653 · walk_₀^629 · walk_₀^640] ---> [flatten_₀^653 · walk_₀^629] (only one)
//│ 		[flatten_₀^653 · walk_₀^629 · walk_₀^643] ---> [flatten_₀^653 · walk_₀^629] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1¹) = 
//│ 	walk_₀_₀(_lh_flatten_arg1¹, [LH_N])
//│ 	where
//│ 	def walk_₀_₀(_lh_walk_arg1¹) = 
//│ 		case _lh_walk_arg1¹ of {
//│ 			Leaf _lh_walk_Leaf_0¹ => (fun t¹ -> [LH_C _lh_walk_Leaf_0¹ t¹])
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => (fun _lh_funcomp_x¹ -> walk_₀_₀(_lh_walk_Node_0¹, walk_₀_₀(_lh_walk_Node_1¹, _lh_funcomp_x¹)))
//│ 			| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1²) = 
//│ 	walk_₀_₀(_lh_flatten_arg1², [LH_N])
//│ 	where
//│ 	def walk_₀_₀(_lh_walk_arg1²) = 
//│ 		case _lh_walk_arg1² of {
//│ 			Leaf _lh_walk_Leaf_0¹ => (fun t² -> [LH_C _lh_walk_Leaf_0¹ t²])
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => (fun _lh_funcomp_x² -> walk_₀_₀(_lh_walk_Node_0¹, walk_₀_₀(_lh_walk_Node_1¹, _lh_funcomp_x²)))
//│ 			| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: defunctionalized,
// after fusion this will be the same as the above one using higher order function
:lhInHaskell
apply (LamCons x)  xs = x:xs
apply (LamO f1 f2) xs = apply f1 (apply f2 xs)
flatten t = apply (walk t) []
walk (Leaf x)     = LamCons x
walk (Node t1 t2) = LamO (walk t1) (walk t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_₀^681
//│ def apply_₀(_lh_apply_arg1¹, _lh_apply_arg2¹) = case _lh_apply_arg1¹ of {
//│ 	LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹]
//│ 	| LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_₀^668(_lh_apply_LamO_0¹, apply_₀^671(_lh_apply_LamO_1¹, _lh_apply_arg2¹))
//│ 	| _  => error⁰}
//│ def flatten_₀(_lh_flatten_arg1¹) = apply_₀^643(walk_₀^644(_lh_flatten_arg1¹), [LH_N])
//│ def walk_₀(_lh_walk_arg1¹) = case _lh_walk_arg1¹ of {
//│ 	Leaf _lh_walk_Leaf_0¹ => [LamCons _lh_walk_Leaf_0¹]
//│ 	| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => [LamO walk_₀^654(_lh_walk_Node_0¹) walk_₀^657(_lh_walk_Node_1¹)]
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten_₀^681]
//│ 	[flatten_₀^681 · apply_₀^643]
//│ 		[flatten_₀^681 · apply_₀^643 · apply_₀^668] (hopeless to continue)
//│ 			[flatten_₀^681 · apply_₀^643 · apply_₀^668 · apply_₀^668] ---> [flatten_₀^681 · apply_₀^643 · apply_₀^668] (using original def)
//│ 			[flatten_₀^681 · apply_₀^643 · apply_₀^668 · apply_₀^671] ---> [flatten_₀^681 · apply_₀^643 · apply_₀^668] (using original def)
//│ 		[flatten_₀^681 · apply_₀^643 · apply_₀^671] ---> [flatten_₀^681 · apply_₀^643] (only one)
//│ 	[flatten_₀^681 · walk_₀^644]
//│ 		[flatten_₀^681 · walk_₀^644 · walk_₀^654] ---> [flatten_₀^681 · walk_₀^644] (only one)
//│ 		[flatten_₀^681 · walk_₀^644 · walk_₀^657] ---> [flatten_₀^681 · walk_₀^644] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1¹) = 
//│ 	apply_₀_₀(walk_₀_₀(_lh_flatten_arg1¹), [LH_N])
//│ 	where
//│ 	def apply_₀_₀(_lh_apply_arg1², _lh_apply_arg2²) = 
//│ 		case _lh_apply_arg1² of {
//│ 			LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2²]
//│ 			| LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply_₀_₁(_lh_apply_LamO_0², apply_₀_₀(_lh_apply_LamO_1², _lh_apply_arg2²))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def apply_₀_₁(_lh_apply_arg1¹, _lh_apply_arg2¹) = 
//│ 			case _lh_apply_arg1¹ of {
//│ 				LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹]
//│ 				| LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_₀_₁(_lh_apply_LamO_0¹, apply_₀_₁(_lh_apply_LamO_1¹, _lh_apply_arg2¹))
//│ 				| _  => error⁰}
//│ 	def walk_₀_₀(_lh_walk_arg1¹) = 
//│ 		case _lh_walk_arg1¹ of {
//│ 			Leaf _lh_walk_Leaf_0¹ => [LamCons _lh_walk_Leaf_0¹]
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => [LamO walk_₀_₀(_lh_walk_Node_0¹) walk_₀_₀(_lh_walk_Node_1¹)]
//│ 			| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LamCons _lh_walk_Leaf_0¹]: 76 --->
//│ 	case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_₀_₁(_lh_apply_LamO_0¹, apply_₀_₁(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 54
//│ 	case _lh_apply_arg1² of {LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2²] | LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply_₀_₁(_lh_apply_LamO_0², apply_₀_₀(_lh_apply_LamO_1², _lh_apply_arg2²)) | _  => error⁰}: 71
//│ [LamO walk_₀_₀(_lh_walk_Node_0¹) walk_₀_₀(_lh_walk_Node_1¹)]: 83 --->
//│ 	case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_₀_₁(_lh_apply_LamO_0¹, apply_₀_₁(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 54
//│ 	case _lh_apply_arg1² of {LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2²] | LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply_₀_₁(_lh_apply_LamO_0², apply_₀_₀(_lh_apply_LamO_1², _lh_apply_arg2²)) | _  => error⁰}: 71
//│ ------------------
//│ case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_₀_₁(_lh_apply_LamO_0¹, apply_₀_₁(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 54 --->
//│ 	[LamCons _lh_walk_Leaf_0¹]: 76
//│ 	[LamO walk_₀_₀(_lh_walk_Node_0¹) walk_₀_₀(_lh_walk_Node_1¹)]: 83
//│ case _lh_apply_arg1² of {LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2²] | LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply_₀_₁(_lh_apply_LamO_0², apply_₀_₀(_lh_apply_LamO_1², _lh_apply_arg2²)) | _  => error⁰}: 71 --->
//│ 	[LamCons _lh_walk_Leaf_0¹]: 76
//│ 	[LamO walk_₀_₀(_lh_walk_Node_0¹) walk_₀_₀(_lh_walk_Node_1¹)]: 83
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1²) = 
//│ 	apply_₀_₀(walk_₀_₀(_lh_flatten_arg1²), [LH_N])
//│ 	where
//│ 	def apply_₀_₀(_lh_apply_arg1⁴, _lh_apply_arg2⁴) = 
//│ 		case _lh_apply_arg1⁴ of {
//│ 			LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2⁴]
//│ 			| LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply_₀_₁(_lh_apply_LamO_0², apply_₀_₀(_lh_apply_LamO_1², _lh_apply_arg2⁴))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def apply_₀_₁(_lh_apply_arg1³, _lh_apply_arg2³) = 
//│ 			case _lh_apply_arg1³ of {
//│ 				LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2³]
//│ 				| LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_₀_₁(_lh_apply_LamO_0¹, apply_₀_₁(_lh_apply_LamO_1¹, _lh_apply_arg2³))
//│ 				| _  => error⁰}
//│ 	def walk_₀_₀(_lh_walk_arg1²) = 
//│ 		case _lh_walk_arg1² of {
//│ 			Leaf _lh_walk_Leaf_0¹ => [LamCons _lh_walk_Leaf_0¹]
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => [LamO walk_₀_₀(_lh_walk_Node_0¹) walk_₀_₀(_lh_walk_Node_1¹)]
//│ 			| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
