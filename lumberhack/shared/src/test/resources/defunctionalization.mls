:NewParser
:ParseOnly

// NOTE: naive implementation using list append
:lhInHaskell
flatten (Leaf x) = [x]
flatten (Node t1 t2) = (flatten t1) ++ (flatten t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_lh_₁^29
//│ def flatten_lh_₁(_lh_flatten_arg1⁰) = case _lh_flatten_arg1⁰ of {
//│ 	Leaf _lh_flatten_Leaf_0⁰ => [LH_C _lh_flatten_Leaf_0⁰ [LH_N]]
//│ 	| Node _lh_flatten_Node_0⁰ _lh_flatten_Node_1⁰ => mappend_lh_₁^17(flatten_lh_₁^18(_lh_flatten_Node_0⁰), flatten_lh_₁^22(_lh_flatten_Node_1⁰))
//│ 	| _  => error⁰}
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁^3(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_N]: 15 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C _lh_flatten_Leaf_0⁰ [LH_N]]: 16 --->
//│ 	NoCons
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10 --->
//│ 	[LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8
//│ 	[LH_N]: 15
//│ 	[LH_C _lh_flatten_Leaf_0⁰ [LH_N]]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_lh_₁
//│ def flatten_lh_₁(_lh_flatten_arg1¹) = case _lh_flatten_arg1¹ of {
//│ 	Leaf _lh_flatten_Leaf_0⁰ => [LH_C _lh_flatten_Leaf_0⁰ [LH_N]]
//│ 	| Node _lh_flatten_Node_0⁰ _lh_flatten_Node_1⁰ => mappend_lh_₁(flatten_lh_₁(_lh_flatten_Node_0⁰), flatten_lh_₁(_lh_flatten_Node_1⁰))
//│ 	| _  => error⁰}
//│ def mappend_lh_₁(xs¹, ys¹) = case xs¹ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys¹)]
//│ 	| LH_N  => ys¹}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ flatten_lh_₁
//│ def flatten_lh_₁(_lh_flatten_arg1⁰) = case _lh_flatten_arg1⁰ of {
//│ 	Leaf _lh_flatten_Leaf_0⁰ => [LH_C _lh_flatten_Leaf_0⁰ [LH_N]]
//│ 	| Node _lh_flatten_Node_0⁰ _lh_flatten_Node_1⁰ => mappend_lh_₁(flatten_lh_₁(_lh_flatten_Node_0⁰), flatten_lh_₁(_lh_flatten_Node_1⁰))
//│ 	| _  => error⁰}
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ flatten_lh_₁
//│ def flatten_lh_₁(_lh_flatten_arg1⁰) = case _lh_flatten_arg1⁰ of {
//│ 	Leaf _lh_flatten_Leaf_0⁰ => [LH_C _lh_flatten_Leaf_0⁰ [LH_N]]
//│ 	| Node _lh_flatten_Node_0⁰ _lh_flatten_Node_1⁰ => mappend_lh_₁(flatten_lh_₁(_lh_flatten_Node_0⁰), flatten_lh_₁(_lh_flatten_Node_1⁰))
//│ 	| _  => error⁰}
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ <<<<<<< after floating out <<<<<<<

// NOTE: using accumulating parameter
:lhInHaskell
flatten (Leaf x) a = x:a
flatten (Node t1 t2) a = flatten t1 $ flatten t2 a
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_lh_₁^18
//│ def flatten_lh_₁(_lh_flatten_arg1⁰, _lh_flatten_arg2⁰) = case _lh_flatten_arg1⁰ of {
//│ 	Leaf _lh_flatten_Leaf_0⁰ => [LH_C _lh_flatten_Leaf_0⁰ _lh_flatten_arg2⁰]
//│ 	| Node _lh_flatten_Node_0⁰ _lh_flatten_Node_1⁰ => flatten_lh_₁^5(_lh_flatten_Node_0⁰, flatten_lh_₁^8(_lh_flatten_Node_1⁰, _lh_flatten_arg2⁰))
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_lh_₁
//│ def flatten_lh_₁(_lh_flatten_arg1¹, _lh_flatten_arg2¹) = case _lh_flatten_arg1¹ of {
//│ 	Leaf _lh_flatten_Leaf_0⁰ => [LH_C _lh_flatten_Leaf_0⁰ _lh_flatten_arg2¹]
//│ 	| Node _lh_flatten_Node_0⁰ _lh_flatten_Node_1⁰ => flatten_lh_₁(_lh_flatten_Node_0⁰, flatten_lh_₁(_lh_flatten_Node_1⁰, _lh_flatten_arg2¹))
//│ 	| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ flatten_lh_₁
//│ def flatten_lh_₁(_lh_flatten_arg1⁰, _lh_flatten_arg2⁰) = case _lh_flatten_arg1⁰ of {
//│ 	Leaf _lh_flatten_Leaf_0⁰ => [LH_C _lh_flatten_Leaf_0⁰ _lh_flatten_arg2⁰]
//│ 	| Node _lh_flatten_Node_0⁰ _lh_flatten_Node_1⁰ => flatten_lh_₁(_lh_flatten_Node_0⁰, flatten_lh_₁(_lh_flatten_Node_1⁰, _lh_flatten_arg2⁰))
//│ 	| _  => error⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ flatten_lh_₁
//│ def flatten_lh_₁(_lh_flatten_arg1⁰, _lh_flatten_arg2⁰) = case _lh_flatten_arg1⁰ of {
//│ 	Leaf _lh_flatten_Leaf_0⁰ => [LH_C _lh_flatten_Leaf_0⁰ _lh_flatten_arg2⁰]
//│ 	| Node _lh_flatten_Node_0⁰ _lh_flatten_Node_1⁰ => flatten_lh_₁(_lh_flatten_Node_0⁰, flatten_lh_₁(_lh_flatten_Node_1⁰, _lh_flatten_arg2⁰))
//│ 	| _  => error⁰}
//│ <<<<<<< after floating out <<<<<<<

// NOTE: using higer order function (which is essentially the same as the above one?)
:lhInHaskell
flatten t = walk t []
walk (Leaf x) = \t -> (x:t)
walk (Node t1 t2) = (walk t1) . (walk t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_lh_₁^25
//│ def flatten_lh_₁(_lh_flatten_arg1⁰) = walk_lh_₁^19(_lh_flatten_arg1⁰, [LH_N])
//│ def walk_lh_₁(_lh_walk_arg1⁰) = case _lh_walk_arg1⁰ of {
//│ 	Leaf _lh_walk_Leaf_0⁰ => (fun t⁰ -> [LH_C _lh_walk_Leaf_0⁰ t⁰])
//│ 	| Node _lh_walk_Node_0⁰ _lh_walk_Node_1⁰ => (fun _lh_funcomp_x⁰ -> walk_lh_₁^6(_lh_walk_Node_0⁰, walk_lh_₁^9(_lh_walk_Node_1⁰, _lh_funcomp_x⁰)))
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_lh_₁
//│ def flatten_lh_₁(_lh_flatten_arg1¹) = walk_lh_₁(_lh_flatten_arg1¹, [LH_N])
//│ def walk_lh_₁(_lh_walk_arg1¹) = case _lh_walk_arg1¹ of {
//│ 	Leaf _lh_walk_Leaf_0⁰ => (fun t¹ -> [LH_C _lh_walk_Leaf_0⁰ t¹])
//│ 	| Node _lh_walk_Node_0⁰ _lh_walk_Node_1⁰ => (fun _lh_funcomp_x¹ -> walk_lh_₁(_lh_walk_Node_0⁰, walk_lh_₁(_lh_walk_Node_1⁰, _lh_funcomp_x¹)))
//│ 	| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ flatten_lh_₁
//│ def flatten_lh_₁(_lh_flatten_arg1⁰) = walk_lh_₁(_lh_flatten_arg1⁰, [LH_N])
//│ def walk_lh_₁(_lh_walk_arg1⁰) = case _lh_walk_arg1⁰ of {
//│ 	Leaf _lh_walk_Leaf_0⁰ => (fun t⁰ -> [LH_C _lh_walk_Leaf_0⁰ t⁰])
//│ 	| Node _lh_walk_Node_0⁰ _lh_walk_Node_1⁰ => (fun _lh_funcomp_x⁰ -> walk_lh_₁(_lh_walk_Node_0⁰, walk_lh_₁(_lh_walk_Node_1⁰, _lh_funcomp_x⁰)))
//│ 	| _  => error⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ flatten_lh_₁
//│ def flatten_lh_₁(_lh_flatten_arg1⁰) = walk_lh_₁(_lh_flatten_arg1⁰, [LH_N])
//│ def walk_lh_₁(_lh_walk_arg1⁰) = case _lh_walk_arg1⁰ of {
//│ 	Leaf _lh_walk_Leaf_0⁰ => (fun t⁰ -> [LH_C _lh_walk_Leaf_0⁰ t⁰])
//│ 	| Node _lh_walk_Node_0⁰ _lh_walk_Node_1⁰ => (fun _lh_funcomp_x⁰ -> walk_lh_₁(_lh_walk_Node_0⁰, walk_lh_₁(_lh_walk_Node_1⁰, _lh_funcomp_x⁰)))
//│ 	| _  => error⁰}
//│ <<<<<<< after floating out <<<<<<<

// NOTE: defunctionalized,
// after fusion this will be the same as the above one using higher order function
:lhInHaskell
apply (LamCons x)  xs = x:xs
apply (LamO f1 f2) xs = apply f1 (apply f2 xs)
flatten t = apply (walk t) []
walk (Leaf x)     = LamCons x
walk (Node t1 t2) = LamO (walk t1) (walk t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_lh_₁^39
//│ def apply_lh_₁(_lh_apply_arg1⁰, _lh_apply_arg2⁰) = case _lh_apply_arg1⁰ of {
//│ 	LamCons _lh_apply_LamCons_0⁰ => [LH_C _lh_apply_LamCons_0⁰ _lh_apply_arg2⁰]
//│ 	| LamO _lh_apply_LamO_0⁰ _lh_apply_LamO_1⁰ => apply_lh_₁^5(_lh_apply_LamO_0⁰, apply_lh_₁^8(_lh_apply_LamO_1⁰, _lh_apply_arg2⁰))
//│ 	| _  => error⁰}
//│ def flatten_lh_₁(_lh_flatten_arg1⁰) = apply_lh_₁^31(walk_lh_₁^32(_lh_flatten_arg1⁰), [LH_N])
//│ def walk_lh_₁(_lh_walk_arg1⁰) = case _lh_walk_arg1⁰ of {
//│ 	Leaf _lh_walk_Leaf_0⁰ => [LamCons _lh_walk_Leaf_0⁰]
//│ 	| Node _lh_walk_Node_0⁰ _lh_walk_Node_1⁰ => [LamO walk_lh_₁^21(_lh_walk_Node_0⁰) walk_lh_₁^24(_lh_walk_Node_1⁰)]
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LamCons _lh_walk_Leaf_0⁰]: 20 --->
//│ 	case _lh_apply_arg1⁰ of {LamCons _lh_apply_LamCons_0⁰ => [LH_C _lh_apply_LamCons_0⁰ _lh_apply_arg2⁰] | LamO _lh_apply_LamO_0⁰ _lh_apply_LamO_1⁰ => apply_lh_₁(_lh_apply_LamO_0⁰, apply_lh_₁(_lh_apply_LamO_1⁰, _lh_apply_arg2⁰)) | _  => error⁰}: 15
//│ [LamO walk_lh_₁(_lh_walk_Node_0⁰) walk_lh_₁(_lh_walk_Node_1⁰)]: 27 --->
//│ 	case _lh_apply_arg1⁰ of {LamCons _lh_apply_LamCons_0⁰ => [LH_C _lh_apply_LamCons_0⁰ _lh_apply_arg2⁰] | LamO _lh_apply_LamO_0⁰ _lh_apply_LamO_1⁰ => apply_lh_₁(_lh_apply_LamO_0⁰, apply_lh_₁(_lh_apply_LamO_1⁰, _lh_apply_arg2⁰)) | _  => error⁰}: 15
//│ ------------------
//│ case _lh_apply_arg1⁰ of {LamCons _lh_apply_LamCons_0⁰ => [LH_C _lh_apply_LamCons_0⁰ _lh_apply_arg2⁰] | LamO _lh_apply_LamO_0⁰ _lh_apply_LamO_1⁰ => apply_lh_₁(_lh_apply_LamO_0⁰, apply_lh_₁(_lh_apply_LamO_1⁰, _lh_apply_arg2⁰)) | _  => error⁰}: 15 --->
//│ 	[LamCons _lh_walk_Leaf_0⁰]: 20
//│ 	[LamO walk_lh_₁(_lh_walk_Node_0⁰) walk_lh_₁(_lh_walk_Node_1⁰)]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LamCons _lh_walk_Leaf_0⁰]: 20 --->
//│ 	case _lh_apply_arg1⁰ of {LamCons _lh_apply_LamCons_0⁰ => [LH_C _lh_apply_LamCons_0⁰ _lh_apply_arg2⁰] | LamO _lh_apply_LamO_0⁰ _lh_apply_LamO_1⁰ => apply_lh_₁(_lh_apply_LamO_0⁰, apply_lh_₁(_lh_apply_LamO_1⁰, _lh_apply_arg2⁰)) | _  => error⁰}: 15
//│ [LamO walk_lh_₁(_lh_walk_Node_0⁰) walk_lh_₁(_lh_walk_Node_1⁰)]: 27 --->
//│ 	case _lh_apply_arg1⁰ of {LamCons _lh_apply_LamCons_0⁰ => [LH_C _lh_apply_LamCons_0⁰ _lh_apply_arg2⁰] | LamO _lh_apply_LamO_0⁰ _lh_apply_LamO_1⁰ => apply_lh_₁(_lh_apply_LamO_0⁰, apply_lh_₁(_lh_apply_LamO_1⁰, _lh_apply_arg2⁰)) | _  => error⁰}: 15
//│ ------------------
//│ case _lh_apply_arg1⁰ of {LamCons _lh_apply_LamCons_0⁰ => [LH_C _lh_apply_LamCons_0⁰ _lh_apply_arg2⁰] | LamO _lh_apply_LamO_0⁰ _lh_apply_LamO_1⁰ => apply_lh_₁(_lh_apply_LamO_0⁰, apply_lh_₁(_lh_apply_LamO_1⁰, _lh_apply_arg2⁰)) | _  => error⁰}: 15 --->
//│ 	[LamCons _lh_walk_Leaf_0⁰]: 20
//│ 	[LamO walk_lh_₁(_lh_walk_Node_0⁰) walk_lh_₁(_lh_walk_Node_1⁰)]: 27
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_lh_₁
//│ def apply_lh_₁(_lh_apply_arg1¹, _lh_apply_arg2¹) = _lh_apply_arg1¹(_lh_apply_arg2¹)
//│ def flatten_lh_₁(_lh_flatten_arg1¹) = apply_lh_₁(walk_lh_₁(_lh_flatten_arg1¹), [LH_N])
//│ def walk_lh_₁(_lh_walk_arg1¹) = case _lh_walk_arg1¹ of {
//│ 	Leaf _lh_walk_Leaf_0⁰ => 
//│ 		let _lh_apply_LamCons_0¹ = _lh_walk_Leaf_0⁰
//│ 		in (fun _lh_apply_arg2² -> [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2²])
//│ 	| Node _lh_walk_Node_0⁰ _lh_walk_Node_1⁰ => 
//│ 		let _lh_apply_LamO_1¹ = walk_lh_₁(_lh_walk_Node_1⁰)
//│ 		in let _lh_apply_LamO_0¹ = walk_lh_₁(_lh_walk_Node_0⁰)
//│ 		in (fun _lh_apply_arg2³ -> apply_lh_₁(_lh_apply_LamO_0¹, apply_lh_₁(_lh_apply_LamO_1¹, _lh_apply_arg2³)))
//│ 	| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ apply_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ walk_lh_₁ -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ flatten_lh_₁
//│ def apply_lh_₁(_lh_apply_arg1⁰, _lh_apply_arg2⁰) = _lh_apply_arg1⁰(_lh_apply_arg2⁰)
//│ def flatten_lh_₁(_lh_flatten_arg1⁰) = walk_lh_₁(_lh_flatten_arg1⁰, [LH_N])
//│ def walk_lh_₁(_lh_walk_arg1⁰) = case _lh_walk_arg1⁰ of {
//│ 	Leaf _lh_walk_Leaf_0⁰ => 
//│ 		let _lh_apply_LamCons_0⁰ = _lh_walk_Leaf_0⁰
//│ 		in (fun _lh_apply_arg2¹ -> [LH_C _lh_apply_LamCons_0⁰ _lh_apply_arg2¹])
//│ 	| Node _lh_walk_Node_0⁰ _lh_walk_Node_1⁰ => 
//│ 		let _lh_apply_LamO_1⁰ = walk_lh_₁(_lh_walk_Node_1⁰)
//│ 		in let _lh_apply_LamO_0⁰ = walk_lh_₁(_lh_walk_Node_0⁰)
//│ 		in (fun _lh_apply_arg2² -> _lh_apply_LamO_0⁰(_lh_apply_LamO_1⁰(_lh_apply_arg2²)))
//│ 	| _  => error⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ flatten_lh_₁
//│ def apply_lh_₁(_lh_apply_arg1⁰, _lh_apply_arg2⁰) = _lh_apply_arg1⁰(_lh_apply_arg2⁰)
//│ def flatten_lh_₁(_lh_flatten_arg1⁰) = walk_lh_₁(_lh_flatten_arg1⁰, [LH_N])
//│ def walk_lh_₁(_lh_walk_arg1⁰) = case _lh_walk_arg1⁰ of {
//│ 	Leaf _lh_walk_Leaf_0⁰ => 
//│ 		let _lh_apply_LamCons_0⁰ = _lh_walk_Leaf_0⁰
//│ 		in (fun _lh_apply_arg2¹ -> [LH_C _lh_apply_LamCons_0⁰ _lh_apply_arg2¹])
//│ 	| Node _lh_walk_Node_0⁰ _lh_walk_Node_1⁰ => 
//│ 		let _lh_apply_LamO_1⁰ = walk_lh_₁(_lh_walk_Node_1⁰)
//│ 		in let _lh_apply_LamO_0⁰ = walk_lh_₁(_lh_walk_Node_0⁰)
//│ 		in (fun _lh_apply_arg2² -> _lh_apply_LamO_0⁰(_lh_apply_LamO_1⁰(_lh_apply_arg2²)))
//│ 	| _  => error⁰}
//│ <<<<<<< after floating out <<<<<<<
