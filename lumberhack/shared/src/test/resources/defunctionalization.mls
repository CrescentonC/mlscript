:NewParser
:ParseOnly

// NOTE: naive implementation using list append
:lhInHaskell
flatten (Leaf x) = [x]
flatten (Node t1 t2) = (flatten t1) ++ (flatten t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_₀^647
//│ def flatten_₀(_lh_flatten_arg1¹) = case _lh_flatten_arg1¹ of {
//│ 	Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ [LH_N]]
//│ 	| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => mappend_₀^623(flatten_₀^624(_lh_flatten_Node_0¹), flatten_₀^628(_lh_flatten_Node_1¹))
//│ 	| _  => error⁰}
//│ def mappend_₀(xs⁹, ys⁹) = case xs⁹ of {
//│ 	LH_C h²⁰ t²² => [LH_C h²⁰ mappend_₀^637(t²², ys⁹)]
//│ 	| LH_N  => ys⁹}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten_₀^647]
//│ 	[flatten_₀^647 · flatten_₀^624] ---> [flatten_₀^647] (only one)
//│ 	[flatten_₀^647 · flatten_₀^628] ---> [flatten_₀^647] (only one)
//│ 	[flatten_₀^647 · mappend_₀^623]
//│ 		[flatten_₀^647 · mappend_₀^623 · mappend_₀^637] ---> [flatten_₀^647 · mappend_₀^623] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1¹) = 
//│ 	case _lh_flatten_arg1¹ of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ [LH_N]]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => mappend_₀_₀(flatten_₀_₀(_lh_flatten_Node_0¹), flatten_₀_₀(_lh_flatten_Node_1¹))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mappend_₀_₀(xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			LH_C h¹ t¹ => [LH_C h¹ mappend_₀_₀(t¹, ys¹)]
//│ 			| LH_N  => ys¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 32 --->
//│ 	NoCons
//│ 	case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend_₀_₀(t¹, ys¹)] | LH_N  => ys¹}: 55
//│ [LH_C _lh_flatten_Leaf_0¹ [LH_N]]: 33 --->
//│ 	NoCons
//│ 	case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend_₀_₀(t¹, ys¹)] | LH_N  => ys¹}: 55
//│ [LH_C h¹ mappend_₀_₀(t¹, ys¹)]: 53 --->
//│ 	NoCons
//│ 	case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend_₀_₀(t¹, ys¹)] | LH_N  => ys¹}: 55
//│ ------------------
//│ case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend_₀_₀(t¹, ys¹)] | LH_N  => ys¹}: 55 --->
//│ 	[LH_N]: 32
//│ 	[LH_C _lh_flatten_Leaf_0¹ [LH_N]]: 33
//│ 	[LH_C h¹ mappend_₀_₀(t¹, ys¹)]: 53
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1²) = 
//│ 	case _lh_flatten_arg1² of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ [LH_N]]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => mappend_₀_₀(flatten_₀_₀(_lh_flatten_Node_0¹), flatten_₀_₀(_lh_flatten_Node_1¹))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mappend_₀_₀(xs², ys²) = 
//│ 		case xs² of {
//│ 			LH_C h¹ t¹ => [LH_C h¹ mappend_₀_₀(t¹, ys²)]
//│ 			| LH_N  => ys²}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: using accumulating parameter
:lhInHaskell
flatten (Leaf x) a = x:a
flatten (Node t1 t2) a = flatten t1 $ flatten t2 a
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_₀^637
//│ def flatten_₀(_lh_flatten_arg1¹, _lh_flatten_arg2¹) = case _lh_flatten_arg1¹ of {
//│ 	Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ _lh_flatten_arg2¹]
//│ 	| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => flatten_₀^624(_lh_flatten_Node_0¹, flatten_₀^627(_lh_flatten_Node_1¹, _lh_flatten_arg2¹))
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten_₀^637]
//│ 	[flatten_₀^637 · flatten_₀^624] ---> [flatten_₀^637] (only one)
//│ 	[flatten_₀^637 · flatten_₀^627] ---> [flatten_₀^637] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1¹, _lh_flatten_arg2¹) = 
//│ 	case _lh_flatten_arg1¹ of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ _lh_flatten_arg2¹]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => flatten_₀_₀(_lh_flatten_Node_0¹, flatten_₀_₀(_lh_flatten_Node_1¹, _lh_flatten_arg2¹))
//│ 		| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1², _lh_flatten_arg2²) = 
//│ 	case _lh_flatten_arg1² of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ _lh_flatten_arg2²]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => flatten_₀_₀(_lh_flatten_Node_0¹, flatten_₀_₀(_lh_flatten_Node_1¹, _lh_flatten_arg2²))
//│ 		| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: using higer order function (which is essentially the same as the above one?)
:lhInHaskell
flatten t = walk t []
walk (Leaf x) = \t -> (x:t)
walk (Node t1 t2) = (walk t1) . (walk t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_₀^651
//│ def flatten_₀(_lh_flatten_arg1¹) = walk_₀^627(_lh_flatten_arg1¹, [LH_N])
//│ def walk_₀(_lh_walk_arg1¹) = case _lh_walk_arg1¹ of {
//│ 	Leaf _lh_walk_Leaf_0¹ => (fun t²³ -> [LH_C _lh_walk_Leaf_0¹ t²³])
//│ 	| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => (fun _lh_funcomp_x¹ -> walk_₀^638(_lh_walk_Node_0¹, walk_₀^641(_lh_walk_Node_1¹, _lh_funcomp_x¹)))
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten_₀^651]
//│ 	[flatten_₀^651 · walk_₀^627]
//│ 		[flatten_₀^651 · walk_₀^627 · walk_₀^638] ---> [flatten_₀^651 · walk_₀^627] (only one)
//│ 		[flatten_₀^651 · walk_₀^627 · walk_₀^641] ---> [flatten_₀^651 · walk_₀^627] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1¹) = 
//│ 	walk_₀_₀(_lh_flatten_arg1¹, [LH_N])
//│ 	where
//│ 	def walk_₀_₀(_lh_walk_arg1¹) = 
//│ 		case _lh_walk_arg1¹ of {
//│ 			Leaf _lh_walk_Leaf_0¹ => (fun t¹ -> [LH_C _lh_walk_Leaf_0¹ t¹])
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => (fun _lh_funcomp_x¹ -> walk_₀_₀(_lh_walk_Node_0¹, walk_₀_₀(_lh_walk_Node_1¹, _lh_funcomp_x¹)))
//│ 			| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1²) = 
//│ 	walk_₀_₀(_lh_flatten_arg1², [LH_N])
//│ 	where
//│ 	def walk_₀_₀(_lh_walk_arg1²) = 
//│ 		case _lh_walk_arg1² of {
//│ 			Leaf _lh_walk_Leaf_0¹ => (fun t² -> [LH_C _lh_walk_Leaf_0¹ t²])
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => (fun _lh_funcomp_x² -> walk_₀_₀(_lh_walk_Node_0¹, walk_₀_₀(_lh_walk_Node_1¹, _lh_funcomp_x²)))
//│ 			| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: defunctionalized,
// after fusion this will be the same as the above one using higher order function
:lhInHaskell
apply (LamCons x)  xs = x:xs
apply (LamO f1 f2) xs = apply f1 (apply f2 xs)
flatten t = apply (walk t) []
walk (Leaf x)     = LamCons x
walk (Node t1 t2) = LamO (walk t1) (walk t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten_₀^679
//│ def apply_₀(_lh_apply_arg1¹, _lh_apply_arg2¹) = case _lh_apply_arg1¹ of {
//│ 	LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹]
//│ 	| LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_₀^645(_lh_apply_LamO_0¹, apply_₀^648(_lh_apply_LamO_1¹, _lh_apply_arg2¹))
//│ 	| _  => error⁰}
//│ def flatten_₀(_lh_flatten_arg1¹) = apply_₀^671(walk_₀^672(_lh_flatten_arg1¹), [LH_N])
//│ def walk_₀(_lh_walk_arg1¹) = case _lh_walk_arg1¹ of {
//│ 	Leaf _lh_walk_Leaf_0¹ => [LamCons _lh_walk_Leaf_0¹]
//│ 	| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => [LamO walk_₀^661(_lh_walk_Node_0¹) walk_₀^664(_lh_walk_Node_1¹)]
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten_₀^679]
//│ 	[flatten_₀^679 · apply_₀^671]
//│ 		[flatten_₀^679 · apply_₀^671 · apply_₀^645] (hopeless to continue)
//│ 			[flatten_₀^679 · apply_₀^671 · apply_₀^645 · apply_₀^645] ---> [flatten_₀^679 · apply_₀^671 · apply_₀^645] (using original def)
//│ 			[flatten_₀^679 · apply_₀^671 · apply_₀^645 · apply_₀^648] ---> [flatten_₀^679 · apply_₀^671 · apply_₀^645] (using original def)
//│ 		[flatten_₀^679 · apply_₀^671 · apply_₀^648] ---> [flatten_₀^679 · apply_₀^671] (only one)
//│ 	[flatten_₀^679 · walk_₀^672]
//│ 		[flatten_₀^679 · walk_₀^672 · walk_₀^661] ---> [flatten_₀^679 · walk_₀^672] (only one)
//│ 		[flatten_₀^679 · walk_₀^672 · walk_₀^664] ---> [flatten_₀^679 · walk_₀^672] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1¹) = 
//│ 	apply_₀_₀(walk_₀_₀(_lh_flatten_arg1¹), [LH_N])
//│ 	where
//│ 	def apply_₀_₀(_lh_apply_arg1², _lh_apply_arg2²) = 
//│ 		case _lh_apply_arg1² of {
//│ 			LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2²]
//│ 			| LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply_₀_₁(_lh_apply_LamO_0², apply_₀_₀(_lh_apply_LamO_1², _lh_apply_arg2²))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def apply_₀_₁(_lh_apply_arg1¹, _lh_apply_arg2¹) = 
//│ 			case _lh_apply_arg1¹ of {
//│ 				LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹]
//│ 				| LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_₀_₁(_lh_apply_LamO_0¹, apply_₀_₁(_lh_apply_LamO_1¹, _lh_apply_arg2¹))
//│ 				| _  => error⁰}
//│ 	def walk_₀_₀(_lh_walk_arg1¹) = 
//│ 		case _lh_walk_arg1¹ of {
//│ 			Leaf _lh_walk_Leaf_0¹ => [LamCons _lh_walk_Leaf_0¹]
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => [LamO walk_₀_₀(_lh_walk_Node_0¹) walk_₀_₀(_lh_walk_Node_1¹)]
//│ 			| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LamCons _lh_walk_Leaf_0¹]: 84 --->
//│ 	case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_₀_₁(_lh_apply_LamO_0¹, apply_₀_₁(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 54
//│ 	case _lh_apply_arg1² of {LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2²] | LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply_₀_₁(_lh_apply_LamO_0², apply_₀_₀(_lh_apply_LamO_1², _lh_apply_arg2²)) | _  => error⁰}: 71
//│ [LamO walk_₀_₀(_lh_walk_Node_0¹) walk_₀_₀(_lh_walk_Node_1¹)]: 91 --->
//│ 	case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_₀_₁(_lh_apply_LamO_0¹, apply_₀_₁(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 54
//│ 	case _lh_apply_arg1² of {LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2²] | LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply_₀_₁(_lh_apply_LamO_0², apply_₀_₀(_lh_apply_LamO_1², _lh_apply_arg2²)) | _  => error⁰}: 71
//│ ------------------
//│ case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_₀_₁(_lh_apply_LamO_0¹, apply_₀_₁(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 54 --->
//│ 	[LamCons _lh_walk_Leaf_0¹]: 84
//│ 	[LamO walk_₀_₀(_lh_walk_Node_0¹) walk_₀_₀(_lh_walk_Node_1¹)]: 91
//│ case _lh_apply_arg1² of {LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2²] | LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply_₀_₁(_lh_apply_LamO_0², apply_₀_₀(_lh_apply_LamO_1², _lh_apply_arg2²)) | _  => error⁰}: 71 --->
//│ 	[LamCons _lh_walk_Leaf_0¹]: 84
//│ 	[LamO walk_₀_₀(_lh_walk_Node_0¹) walk_₀_₀(_lh_walk_Node_1¹)]: 91
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten_₀_₀
//│ def flatten_₀_₀(_lh_flatten_arg1²) = 
//│ 	apply_₀_₀(walk_₀_₀(_lh_flatten_arg1²), [LH_N])
//│ 	where
//│ 	def apply_₀_₀(_lh_apply_arg1⁴, _lh_apply_arg2⁴) = 
//│ 		case _lh_apply_arg1⁴ of {
//│ 			LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2⁴]
//│ 			| LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply_₀_₁(_lh_apply_LamO_0², apply_₀_₀(_lh_apply_LamO_1², _lh_apply_arg2⁴))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def apply_₀_₁(_lh_apply_arg1³, _lh_apply_arg2³) = 
//│ 			case _lh_apply_arg1³ of {
//│ 				LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2³]
//│ 				| LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply_₀_₁(_lh_apply_LamO_0¹, apply_₀_₁(_lh_apply_LamO_1¹, _lh_apply_arg2³))
//│ 				| _  => error⁰}
//│ 	def walk_₀_₀(_lh_walk_arg1²) = 
//│ 		case _lh_walk_arg1² of {
//│ 			Leaf _lh_walk_Leaf_0¹ => [LamCons _lh_walk_Leaf_0¹]
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => [LamO walk_₀_₀(_lh_walk_Node_0¹) walk_₀_₀(_lh_walk_Node_1¹)]
//│ 			| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
