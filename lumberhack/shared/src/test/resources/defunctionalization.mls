:NewParser
:ParseOnly

// NOTE: naive implementation using list append
:lhInHaskell
flatten (Leaf x) = [x]
flatten (Node t1 t2) = (flatten t1) ++ (flatten t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten₀^647
//│ def flatten₀(_lh_flatten_arg1¹) = case _lh_flatten_arg1¹ of {
//│ 	Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ [LH_N]]
//│ 	| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => mappend₀^623(flatten₀^624(_lh_flatten_Node_0¹), flatten₀^628(_lh_flatten_Node_1¹))
//│ 	| _  => error⁰}
//│ def mappend₀(xs⁹, ys⁹) = case xs⁹ of {
//│ 	LH_C h²⁰ t²² => [LH_C h²⁰ mappend₀^637(t²², ys⁹)]
//│ 	| LH_N  => ys⁹}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten₀^647]
//│ 	[flatten₀^647 · flatten₀^624] ---> [flatten₀^647] (only one)
//│ 	[flatten₀^647 · flatten₀^628] ---> [flatten₀^647] (only one)
//│ 	[flatten₀^647 · mappend₀^623]
//│ 		[flatten₀^647 · mappend₀^623 · mappend₀^637] ---> [flatten₀^647 · mappend₀^623] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten₀₀
//│ def flatten₀₀(_lh_flatten_arg1¹) = 
//│ 	case _lh_flatten_arg1¹ of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ [LH_N]]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => mappend₀₀(flatten₀₀(_lh_flatten_Node_0¹), flatten₀₀(_lh_flatten_Node_1¹))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mappend₀₀(xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			LH_C h¹ t¹ => [LH_C h¹ mappend₀₀(t¹, ys¹)]
//│ 			| LH_N  => ys¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h¹ mappend₀₀(t¹, ys¹)]: 37 --->
//│ 	NoCons
//│ 	case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend₀₀(t¹, ys¹)] | LH_N  => ys¹}: 39
//│ [LH_N]: 44 --->
//│ 	NoCons
//│ 	case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend₀₀(t¹, ys¹)] | LH_N  => ys¹}: 39
//│ [LH_C _lh_flatten_Leaf_0¹ [LH_N]]: 45 --->
//│ 	NoCons
//│ 	case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend₀₀(t¹, ys¹)] | LH_N  => ys¹}: 39
//│ ------------------
//│ case xs¹ of {LH_C h¹ t¹ => [LH_C h¹ mappend₀₀(t¹, ys¹)] | LH_N  => ys¹}: 39 --->
//│ 	[LH_C h¹ mappend₀₀(t¹, ys¹)]: 37
//│ 	[LH_N]: 44
//│ 	[LH_C _lh_flatten_Leaf_0¹ [LH_N]]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten₀₀
//│ def flatten₀₀(_lh_flatten_arg1²) = 
//│ 	case _lh_flatten_arg1² of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ [LH_N]]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => mappend₀₀(flatten₀₀(_lh_flatten_Node_0¹), flatten₀₀(_lh_flatten_Node_1¹))
//│ 		| _  => error⁰}
//│ 	where
//│ 	def mappend₀₀(xs², ys²) = 
//│ 		case xs² of {
//│ 			LH_C h¹ t¹ => [LH_C h¹ mappend₀₀(t¹, ys²)]
//│ 			| LH_N  => ys²}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: using accumulating parameter
:lhInHaskell
flatten (Leaf x) a = x:a
flatten (Node t1 t2) a = flatten t1 $ flatten t2 a
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten₀^637
//│ def flatten₀(_lh_flatten_arg1¹, _lh_flatten_arg2¹) = case _lh_flatten_arg1¹ of {
//│ 	Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ _lh_flatten_arg2¹]
//│ 	| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => flatten₀^624(_lh_flatten_Node_0¹, flatten₀^627(_lh_flatten_Node_1¹, _lh_flatten_arg2¹))
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten₀^637]
//│ 	[flatten₀^637 · flatten₀^624] ---> [flatten₀^637] (only one)
//│ 	[flatten₀^637 · flatten₀^627] ---> [flatten₀^637] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten₀₀
//│ def flatten₀₀(_lh_flatten_arg1¹, _lh_flatten_arg2¹) = 
//│ 	case _lh_flatten_arg1¹ of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ _lh_flatten_arg2¹]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => flatten₀₀(_lh_flatten_Node_0¹, flatten₀₀(_lh_flatten_Node_1¹, _lh_flatten_arg2¹))
//│ 		| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten₀₀
//│ def flatten₀₀(_lh_flatten_arg1², _lh_flatten_arg2²) = 
//│ 	case _lh_flatten_arg1² of {
//│ 		Leaf _lh_flatten_Leaf_0¹ => [LH_C _lh_flatten_Leaf_0¹ _lh_flatten_arg2²]
//│ 		| Node _lh_flatten_Node_0¹ _lh_flatten_Node_1¹ => flatten₀₀(_lh_flatten_Node_0¹, flatten₀₀(_lh_flatten_Node_1¹, _lh_flatten_arg2²))
//│ 		| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: using higer order function (which is essentially the same as the above one?)
:lhInHaskell
flatten t = walk t []
walk (Leaf x) = \t -> (x:t)
walk (Node t1 t2) = (walk t1) . (walk t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten₀^651
//│ def flatten₀(_lh_flatten_arg1¹) = walk₀^627(_lh_flatten_arg1¹, [LH_N])
//│ def walk₀(_lh_walk_arg1¹) = case _lh_walk_arg1¹ of {
//│ 	Leaf _lh_walk_Leaf_0¹ => (fun t²³ -> [LH_C _lh_walk_Leaf_0¹ t²³])
//│ 	| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => (fun _lh_funcomp_x¹ -> walk₀^638(_lh_walk_Node_0¹, walk₀^641(_lh_walk_Node_1¹, _lh_funcomp_x¹)))
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten₀^651]
//│ 	[flatten₀^651 · walk₀^627]
//│ 		[flatten₀^651 · walk₀^627 · walk₀^638] ---> [flatten₀^651 · walk₀^627] (only one)
//│ 		[flatten₀^651 · walk₀^627 · walk₀^641] ---> [flatten₀^651 · walk₀^627] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten₀₀
//│ def flatten₀₀(_lh_flatten_arg1¹) = 
//│ 	walk₀₀(_lh_flatten_arg1¹, [LH_N])
//│ 	where
//│ 	def walk₀₀(_lh_walk_arg1¹) = 
//│ 		case _lh_walk_arg1¹ of {
//│ 			Leaf _lh_walk_Leaf_0¹ => (fun t¹ -> [LH_C _lh_walk_Leaf_0¹ t¹])
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => (fun _lh_funcomp_x¹ -> walk₀₀(_lh_walk_Node_0¹, walk₀₀(_lh_walk_Node_1¹, _lh_funcomp_x¹)))
//│ 			| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten₀₀
//│ def flatten₀₀(_lh_flatten_arg1²) = 
//│ 	walk₀₀(_lh_flatten_arg1², [LH_N])
//│ 	where
//│ 	def walk₀₀(_lh_walk_arg1²) = 
//│ 		case _lh_walk_arg1² of {
//│ 			Leaf _lh_walk_Leaf_0¹ => (fun t² -> [LH_C _lh_walk_Leaf_0¹ t²])
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => (fun _lh_funcomp_x² -> walk₀₀(_lh_walk_Node_0¹, walk₀₀(_lh_walk_Node_1¹, _lh_funcomp_x²)))
//│ 			| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<

// NOTE: defunctionalized,
// after fusion this will be the same as the above one using higher order function
:lhInHaskell
apply (LamCons x)  xs = x:xs
apply (LamO f1 f2) xs = apply f1 (apply f2 xs)
flatten t = apply (walk t) []
walk (Leaf x)     = LamCons x
walk (Node t1 t2) = LamO (walk t1) (walk t2)
flatten
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ flatten₀^679
//│ def apply₀(_lh_apply_arg1¹, _lh_apply_arg2¹) = case _lh_apply_arg1¹ of {
//│ 	LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹]
//│ 	| LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply₀^645(_lh_apply_LamO_0¹, apply₀^648(_lh_apply_LamO_1¹, _lh_apply_arg2¹))
//│ 	| _  => error⁰}
//│ def flatten₀(_lh_flatten_arg1¹) = apply₀^671(walk₀^672(_lh_flatten_arg1¹), [LH_N])
//│ def walk₀(_lh_walk_arg1¹) = case _lh_walk_arg1¹ of {
//│ 	Leaf _lh_walk_Leaf_0¹ => [LamCons _lh_walk_Leaf_0¹]
//│ 	| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => [LamO walk₀^661(_lh_walk_Node_0¹) walk₀^664(_lh_walk_Node_1¹)]
//│ 	| _  => error⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [flatten₀^679]
//│ 	[flatten₀^679 · apply₀^671]
//│ 		[flatten₀^679 · apply₀^671 · apply₀^645] (hopeless to continue)
//│ 			[flatten₀^679 · apply₀^671 · apply₀^645 · apply₀^645] ---> [flatten₀^679 · apply₀^671 · apply₀^645] (using original def)
//│ 			[flatten₀^679 · apply₀^671 · apply₀^645 · apply₀^648] ---> [flatten₀^679 · apply₀^671 · apply₀^645] (using original def)
//│ 		[flatten₀^679 · apply₀^671 · apply₀^648] ---> [flatten₀^679 · apply₀^671] (only one)
//│ 	[flatten₀^679 · walk₀^672]
//│ 		[flatten₀^679 · walk₀^672 · walk₀^661] ---> [flatten₀^679 · walk₀^672] (only one)
//│ 		[flatten₀^679 · walk₀^672 · walk₀^664] ---> [flatten₀^679 · walk₀^672] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ flatten₀₀
//│ def flatten₀₀(_lh_flatten_arg1¹) = 
//│ 	apply₀₀(walk₀₀(_lh_flatten_arg1¹), [LH_N])
//│ 	where
//│ 	def apply₀₀(_lh_apply_arg1¹, _lh_apply_arg2¹) = 
//│ 		case _lh_apply_arg1¹ of {
//│ 			LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹]
//│ 			| LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply₀₁(_lh_apply_LamO_0¹, apply₀₀(_lh_apply_LamO_1¹, _lh_apply_arg2¹))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def apply₀₁(_lh_apply_arg1², _lh_apply_arg2²) = 
//│ 			case _lh_apply_arg1² of {
//│ 				LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2²]
//│ 				| LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply₀₁(_lh_apply_LamO_0², apply₀₁(_lh_apply_LamO_1², _lh_apply_arg2²))
//│ 				| _  => error⁰}
//│ 	def walk₀₀(_lh_walk_arg1¹) = 
//│ 		case _lh_walk_arg1¹ of {
//│ 			Leaf _lh_walk_Leaf_0¹ => [LamCons _lh_walk_Leaf_0¹]
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => [LamO walk₀₀(_lh_walk_Node_0¹) walk₀₀(_lh_walk_Node_1¹)]
//│ 			| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LamCons _lh_walk_Leaf_0¹]: 42 --->
//│ 	case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply₀₁(_lh_apply_LamO_0¹, apply₀₀(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 67
//│ 	case _lh_apply_arg1² of {LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2²] | LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply₀₁(_lh_apply_LamO_0², apply₀₁(_lh_apply_LamO_1², _lh_apply_arg2²)) | _  => error⁰}: 84
//│ [LamO walk₀₀(_lh_walk_Node_0¹) walk₀₀(_lh_walk_Node_1¹)]: 49 --->
//│ 	case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply₀₁(_lh_apply_LamO_0¹, apply₀₀(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 67
//│ 	case _lh_apply_arg1² of {LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2²] | LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply₀₁(_lh_apply_LamO_0², apply₀₁(_lh_apply_LamO_1², _lh_apply_arg2²)) | _  => error⁰}: 84
//│ ------------------
//│ case _lh_apply_arg1¹ of {LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2¹] | LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply₀₁(_lh_apply_LamO_0¹, apply₀₀(_lh_apply_LamO_1¹, _lh_apply_arg2¹)) | _  => error⁰}: 67 --->
//│ 	[LamCons _lh_walk_Leaf_0¹]: 42
//│ 	[LamO walk₀₀(_lh_walk_Node_0¹) walk₀₀(_lh_walk_Node_1¹)]: 49
//│ case _lh_apply_arg1² of {LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2²] | LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply₀₁(_lh_apply_LamO_0², apply₀₁(_lh_apply_LamO_1², _lh_apply_arg2²)) | _  => error⁰}: 84 --->
//│ 	[LamCons _lh_walk_Leaf_0¹]: 42
//│ 	[LamO walk₀₀(_lh_walk_Node_0¹) walk₀₀(_lh_walk_Node_1¹)]: 49
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ flatten₀₀
//│ def flatten₀₀(_lh_flatten_arg1²) = 
//│ 	apply₀₀(walk₀₀(_lh_flatten_arg1²), [LH_N])
//│ 	where
//│ 	def apply₀₀(_lh_apply_arg1³, _lh_apply_arg2³) = 
//│ 		case _lh_apply_arg1³ of {
//│ 			LamCons _lh_apply_LamCons_0¹ => [LH_C _lh_apply_LamCons_0¹ _lh_apply_arg2³]
//│ 			| LamO _lh_apply_LamO_0¹ _lh_apply_LamO_1¹ => apply₀₁(_lh_apply_LamO_0¹, apply₀₀(_lh_apply_LamO_1¹, _lh_apply_arg2³))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def apply₀₁(_lh_apply_arg1⁴, _lh_apply_arg2⁴) = 
//│ 			case _lh_apply_arg1⁴ of {
//│ 				LamCons _lh_apply_LamCons_0² => [LH_C _lh_apply_LamCons_0² _lh_apply_arg2⁴]
//│ 				| LamO _lh_apply_LamO_0² _lh_apply_LamO_1² => apply₀₁(_lh_apply_LamO_0², apply₀₁(_lh_apply_LamO_1², _lh_apply_arg2⁴))
//│ 				| _  => error⁰}
//│ 	def walk₀₀(_lh_walk_arg1²) = 
//│ 		case _lh_walk_arg1² of {
//│ 			Leaf _lh_walk_Leaf_0¹ => [LamCons _lh_walk_Leaf_0¹]
//│ 			| Node _lh_walk_Node_0¹ _lh_walk_Node_1¹ => [LamO walk₀₀(_lh_walk_Node_0¹) walk₀₀(_lh_walk_Node_1¹)]
//│ 			| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
