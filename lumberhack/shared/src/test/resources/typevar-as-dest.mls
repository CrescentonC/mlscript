:NewParser
:ParseOnly


_LUMBERHACK_EVAL
fun f(a) = if a is
  C(d) then a
Ok(f(C(A)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |f|(|a|)| |#=| |#if| |a| |is|→|C|(|d|)| |#then| |a|←|↵|Ok|(|f|(|C|(|A|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun f = a, => if a is ‹(C (d,)) then a›; Ok (f (C (A,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ [Ok f^5([C [A]])]
//│ def f(a⁰) = case a⁰ of {
//│ 	C d⁰ => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [Ok [C [A]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 7 --->
//│ 	NoCons
//│ 	case a⁰ of {C d⁰ => a⁰}: 3
//│ ------------------
//│ case a⁰ of {C d⁰ => a⁰}: 3 --->
//│ 	[C [A]]: 7
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ [Ok f([C [A]])]
//│ def f(a¹) = case a¹ of {
//│ 	C d⁰ => a¹}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Ok [C [A]]]
//│ <<<<<<< evaluate <<<<<<<


fun f(x) =
  primitive(x)
  if x is
    C(a) then x
fun wrapInRes(y) =
  Res1(y)
  Res2(y)
wrapInRes(f(C(A)))
//│ |#fun| |f|(|x|)| |#=|→|primitive|(|x|)|↵|#if| |x| |is|→|C|(|a|)| |#then| |x|←|←|↵|#fun| |wrapInRes|(|y|)| |#=|→|Res1|(|y|)|↵|Res2|(|y|)|←|↵|wrapInRes|(|f|(|C|(|A|)|)|)|
//│ Parsed: {fun f = x, => {primitive (x,); if x is ‹(C (a,)) then x›}; fun wrapInRes = y, => {Res1 (y,); Res2 (y,)}; wrapInRes (f (C (A,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ wrapInRes^15(f^16([C [A]]))
//│ def f(x⁰) = 
//│ 	primitive⁰(x⁰)
//│ 	case x⁰ of {
//│ 		C a⁰ => x⁰}
//│ def wrapInRes(y⁰) = 
//│ 	[Res1 y⁰]
//│ 	[Res2 y⁰]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 18 --->
//│ 	NoCons
//│ 	case x⁰ of {C a⁰ => x⁰}: 6
//│ ------------------
//│ case x⁰ of {C a⁰ => x⁰}: 6 --->
//│ 	[C [A]]: 18
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ wrapInRes(f([C [A]]))
//│ def f(x¹) = 
//│ 	primitive⁰(x¹)
//│ 	case x¹ of {
//│ 		C a⁰ => x¹}
//│ def wrapInRes(y¹) = 
//│ 	[Res1 y¹]
//│ 	[Res2 y¹]
//│ <<<<<<< after fusion <<<<<<<
