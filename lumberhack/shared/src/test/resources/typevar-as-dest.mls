:NewParser
:ParseOnly


_LUMBERHACK_EVAL
fun f(a) = if a is
  C(d) then a
Ok(f(C(A)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |f|(|a|)| |#=| |#if| |a| |is|→|C|(|d|)| |#then| |a|←|↵|Ok|(|f|(|C|(|A|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun f = a, => if a is ‹(C (d,)) then a›; Ok (f (C (A,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ [Ok f^5([C [A]])]
//│ def f(a⁰) = case a⁰ of {
//│ 	C d⁰ => a⁰}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [Ok [C [A]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^5] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ [Ok f_₀([C [A]])]
//│ def f_₀(a¹) = 
//│ 	case a¹ of {
//│ 		C d¹ => a¹}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 16 --->
//│ 	NoCons
//│ 	case a¹ of {C d¹ => a¹}: 12
//│ ------------------
//│ case a¹ of {C d¹ => a¹}: 12 --->
//│ 	[C [A]]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ [Ok f_₀([C [A]])]
//│ def f_₀(a²) = 
//│ 	case a² of {
//│ 		C d¹ => a²}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [Ok [C [A]]]
//│ <<<<<<< evaluate <<<<<<<


fun f(x) =
  primitive(x)
  if x is
    C(a) then x
fun wrapInRes(y) =
  Res1(y)
  Res2(y)
wrapInRes(f(C(A)))
//│ |#fun| |f|(|x|)| |#=|→|primitive|(|x|)|↵|#if| |x| |is|→|C|(|a|)| |#then| |x|←|←|↵|#fun| |wrapInRes|(|y|)| |#=|→|Res1|(|y|)|↵|Res2|(|y|)|←|↵|wrapInRes|(|f|(|C|(|A|)|)|)|
//│ Parsed: {fun f = x, => {primitive (x,); if x is ‹(C (a,)) then x›}; fun wrapInRes = y, => {Res1 (y,); Res2 (y,)}; wrapInRes (f (C (A,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ wrapInRes^15(f^16([C [A]]))
//│ def f(x⁰) = 
//│ 	primitive⁰(x⁰)
//│ 	case x⁰ of {
//│ 		C a⁰ => x⁰}
//│ def wrapInRes(y⁰) = 
//│ 	[Res1 y⁰]
//│ 	[Res2 y⁰]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^16] (hopeless to continue)
//│ [wrapInRes^15] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ wrapInRes_₀(f_₀([C [A]]))
//│ def f_₀(x¹) = 
//│ 	primitive⁰(x¹)
//│ 	case x¹ of {
//│ 		C a¹ => x¹}
//│ def wrapInRes_₀(y¹) = 
//│ 	[Res1 y¹]
//│ 	[Res2 y¹]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 38 --->
//│ 	NoCons
//│ 	case x¹ of {C a¹ => x¹}: 26
//│ ------------------
//│ case x¹ of {C a¹ => x¹}: 26 --->
//│ 	[C [A]]: 38
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ wrapInRes_₀(f_₀([C [A]]))
//│ def f_₀(x²) = 
//│ 	primitive⁰(x²)
//│ 	case x² of {
//│ 		C a¹ => x²}
//│ def wrapInRes_₀(y²) = 
//│ 	[Res1 y²]
//│ 	[Res2 y²]
//│ <<<<<<< after fusion <<<<<<<
