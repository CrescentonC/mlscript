:ParseOnly
:NewParser


// [(a, c) | (a, b) <- [(5, 10)], (c, d) <- [(1, 3), (2, 3), (a, b)]]
// a less efficient desugaring of list comprehension
_LUMBERHACK_EVAL
fun append(xs, ys) = if xs is
  C(h, t) then C(h, append(t, ys))
  N then ys
fun concatMap(f, ls) = if ls is
  C(h, t) then append(f(h), concatMap(f, t))
  N then N
let ok1 = arg1 => if arg1 is
  P2(a, b) then
    let ok2 = arg2 => if arg2 is
      P2(c, b) then C(P2(a, c), N)
      _ then N
    concatMap(ok2, C(P2(1, 3), C(P2(2, 3), C(P2(a, b), N))))
  _ then N
concatMap(ok1, C(P2(5, 10), N))
//│ |_LUMBERHACK_EVAL|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|↵|N| |#then| |ys|←|↵|#fun| |concatMap|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |append|(|f|(|h|)|,| |concatMap|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#let| |ok1| |#=| |arg1| |=>| |#if| |arg1| |is|→|P2|(|a|,| |b|)| |#then|→|#let| |ok2| |#=| |arg2| |=>| |#if| |arg2| |is|→|P2|(|c|,| |b|)| |#then| |C|(|P2|(|a|,| |c|)|,| |N|)|↵|_| |#then| |N|←|↵|concatMap|(|ok2|,| |C|(|P2|(|1|,| |3|)|,| |C|(|P2|(|2|,| |3|)|,| |C|(|P2|(|a|,| |b|)|,| |N|)|)|)|)|←|↵|_| |#then| |N|←|↵|concatMap|(|ok1|,| |C|(|P2|(|5|,| |10|)|,| |N|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun append = xs, ys, => if xs is ‹(C (h, t,)) then C (h, append (t, ys,),); (N) then ys›; fun concatMap = f, ls, => if ls is ‹(C (h, t,)) then append (f (h,), concatMap (f, t,),); (N) then N›; let ok1 = arg1, => if arg1 is ‹(P2 (a, b,)) then {let ok2 = arg2, => if arg2 is ‹(P2 (c, b,)) then C (P2 (a, c,), N,); (_) then N›; concatMap (ok2, C (P2 (1, 3,), C (P2 (2, 3,), C (P2 (a, b,), N,),),),)}; (_) then N›; concatMap (ok1, C (P2 (5, 10,), N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ concatMap^60(ok1^61, [C [P2 5 10] [N]])
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C h⁰ append^3(t⁰, ys⁰)]
//│ 	| N  => ys⁰}
//│ def concatMap(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => append^14(f⁰(h¹), concatMap^19(f⁰, t¹))
//│ 	| N  => [N]}
//│ def ok1(arg1⁰) = case arg1⁰ of {
//│ 	P2 a⁰ b⁰ => 
//│ 		let ok2⁰ = (fun arg2⁰ -> case arg2⁰ of {
//│ 			P2 c⁰ b¹ => [C [P2 a⁰ c⁰] [N]]
//│ 			| _  => [N]})
//│ 		in concatMap^39(ok2⁰, [C [P2 1 3] [C [P2 2 3] [C [P2 a⁰ b⁰] [N]]]])
//│ 	| _  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [P2 5 1] [C [P2 5 2] [C [P2 5 5] [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ append(t⁰, ys⁰)]: 8 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [N]: 25 --->
//│ 	NoCons
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [N]: 34 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [C [P2 a⁰ c⁰] [N]]: 35 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [N]: 36 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [P2 1 3]: 44 --->
//│ 	case arg2⁰ of {P2 c⁰ b¹ => [C [P2 a⁰ c⁰] [N]] | _  => [N]}: 37
//│ 	case arg1⁰ of {P2 a⁰ b⁰ => let ok2⁰ = (fun arg2⁰ -> case arg2⁰ of {P2 c⁰ b¹ => [C [P2 a⁰ c⁰] [N]] | _  => [N]})
//│ in concatMap(ok2⁰, [C [P2 1 3] [C [P2 2 3] [C [P2 a⁰ b⁰] [N]]]]) | _  => [N]}: 58
//│ [P2 2 3]: 47 --->
//│ 	case arg2⁰ of {P2 c⁰ b¹ => [C [P2 a⁰ c⁰] [N]] | _  => [N]}: 37
//│ 	case arg1⁰ of {P2 a⁰ b⁰ => let ok2⁰ = (fun arg2⁰ -> case arg2⁰ of {P2 c⁰ b¹ => [C [P2 a⁰ c⁰] [N]] | _  => [N]})
//│ in concatMap(ok2⁰, [C [P2 1 3] [C [P2 2 3] [C [P2 a⁰ b⁰] [N]]]]) | _  => [N]}: 58
//│ [P2 a⁰ b⁰]: 50 --->
//│ 	case arg2⁰ of {P2 c⁰ b¹ => [C [P2 a⁰ c⁰] [N]] | _  => [N]}: 37
//│ 	case arg1⁰ of {P2 a⁰ b⁰ => let ok2⁰ = (fun arg2⁰ -> case arg2⁰ of {P2 c⁰ b¹ => [C [P2 a⁰ c⁰] [N]] | _  => [N]})
//│ in concatMap(ok2⁰, [C [P2 1 3] [C [P2 2 3] [C [P2 a⁰ b⁰] [N]]]]) | _  => [N]}: 58
//│ [N]: 51 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(f⁰(h¹), concatMap(f⁰, t¹)) | N  => [N]}: 26
//│ [C [P2 a⁰ b⁰] [N]]: 52 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(f⁰(h¹), concatMap(f⁰, t¹)) | N  => [N]}: 26
//│ [C [P2 2 3] [C [P2 a⁰ b⁰] [N]]]: 53 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(f⁰(h¹), concatMap(f⁰, t¹)) | N  => [N]}: 26
//│ [C [P2 1 3] [C [P2 2 3] [C [P2 a⁰ b⁰] [N]]]]: 54 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(f⁰(h¹), concatMap(f⁰, t¹)) | N  => [N]}: 26
//│ [N]: 57 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10
//│ [P2 5 10]: 65 --->
//│ 	case arg2⁰ of {P2 c⁰ b¹ => [C [P2 a⁰ c⁰] [N]] | _  => [N]}: 37
//│ 	case arg1⁰ of {P2 a⁰ b⁰ => let ok2⁰ = (fun arg2⁰ -> case arg2⁰ of {P2 c⁰ b¹ => [C [P2 a⁰ c⁰] [N]] | _  => [N]})
//│ in concatMap(ok2⁰, [C [P2 1 3] [C [P2 2 3] [C [P2 a⁰ b⁰] [N]]]]) | _  => [N]}: 58
//│ [N]: 66 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(f⁰(h¹), concatMap(f⁰, t¹)) | N  => [N]}: 26
//│ [C [P2 5 10] [N]]: 67 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(f⁰(h¹), concatMap(f⁰, t¹)) | N  => [N]}: 26
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)] | N  => ys⁰}: 10 --->
//│ 	[C h⁰ append(t⁰, ys⁰)]: 8
//│ 	[N]: 25
//│ 	[N]: 34
//│ 	[C [P2 a⁰ c⁰] [N]]: 35
//│ 	[N]: 36
//│ 	[N]: 57
//│ case ls⁰ of {C h¹ t¹ => append(f⁰(h¹), concatMap(f⁰, t¹)) | N  => [N]}: 26 --->
//│ 	[N]: 51
//│ 	[C [P2 a⁰ b⁰] [N]]: 52
//│ 	[C [P2 2 3] [C [P2 a⁰ b⁰] [N]]]: 53
//│ 	[C [P2 1 3] [C [P2 2 3] [C [P2 a⁰ b⁰] [N]]]]: 54
//│ 	[N]: 66
//│ 	[C [P2 5 10] [N]]: 67
//│ case arg2⁰ of {P2 c⁰ b¹ => [C [P2 a⁰ c⁰] [N]] | _  => [N]}: 37 --->
//│ 	[P2 1 3]: 44
//│ 	[P2 2 3]: 47
//│ 	[P2 a⁰ b⁰]: 50
//│ 	[P2 5 10]: 65
//│ case arg1⁰ of {P2 a⁰ b⁰ => let ok2⁰ = (fun arg2⁰ -> case arg2⁰ of {P2 c⁰ b¹ => [C [P2 a⁰ c⁰] [N]] | _  => [N]})
//│ in concatMap(ok2⁰, [C [P2 1 3] [C [P2 2 3] [C [P2 a⁰ b⁰] [N]]]]) | _  => [N]}: 58 --->
//│ 	[P2 1 3]: 44
//│ 	[P2 2 3]: 47
//│ 	[P2 a⁰ b⁰]: 50
//│ 	[P2 5 10]: 65
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 51 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(f⁰(h¹), concatMap(f⁰, t¹)) | N  => [N]}: 26
//│ [C [P2 a⁰ b⁰] [N]]: 52 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(f⁰(h¹), concatMap(f⁰, t¹)) | N  => [N]}: 26
//│ [C [P2 2 3] [C [P2 a⁰ b⁰] [N]]]: 53 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(f⁰(h¹), concatMap(f⁰, t¹)) | N  => [N]}: 26
//│ [C [P2 1 3] [C [P2 2 3] [C [P2 a⁰ b⁰] [N]]]]: 54 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(f⁰(h¹), concatMap(f⁰, t¹)) | N  => [N]}: 26
//│ [N]: 66 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(f⁰(h¹), concatMap(f⁰, t¹)) | N  => [N]}: 26
//│ [C [P2 5 10] [N]]: 67 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(f⁰(h¹), concatMap(f⁰, t¹)) | N  => [N]}: 26
//│ ------------------
//│ case ls⁰ of {C h¹ t¹ => append(f⁰(h¹), concatMap(f⁰, t¹)) | N  => [N]}: 26 --->
//│ 	[N]: 51
//│ 	[C [P2 a⁰ b⁰] [N]]: 52
//│ 	[C [P2 2 3] [C [P2 a⁰ b⁰] [N]]]: 53
//│ 	[C [P2 1 3] [C [P2 2 3] [C [P2 a⁰ b⁰] [N]]]]: 54
//│ 	[N]: 66
//│ 	[C [P2 5 10] [N]]: 67
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ concatMap(ok1, 
//│ 	let t² = (fun f² -> [N])
//│ 	in let h² = [P2 5 10]
//│ 	in (fun f¹ -> append(f¹(h²), concatMap(f¹, t²))))
//│ def append(xs¹, ys¹) = case xs¹ of {
//│ 	C h⁰ t⁰ => [C h⁰ append(t⁰, ys¹)]
//│ 	| N  => ys¹}
//│ def concatMap(f³, ls¹) = ls¹(f³)
//│ def ok1(arg1¹) = case arg1¹ of {
//│ 	P2 a⁰ b⁰ => 
//│ 		let ok2¹ = (fun arg2¹ -> case arg2¹ of {
//│ 			P2 c⁰ b¹ => [C [P2 a⁰ c⁰] [N]]
//│ 			| _  => [N]})
//│ 		in concatMap(ok2¹, 
//│ 			let t³ = 	
//│ 				let t⁴ = 	
//│ 					let t⁵ = (fun f⁷ -> [N])
//│ 					in let h⁵ = [P2 a⁰ b⁰]
//│ 					in (fun f⁶ -> append(f⁶(h⁵), concatMap(f⁶, t⁵)))
//│ 				in let h⁴ = [P2 2 3]
//│ 				in (fun f⁵ -> append(f⁵(h⁴), concatMap(f⁵, t⁴)))
//│ 			in let h³ = [P2 1 3]
//│ 			in (fun f⁴ -> append(f⁴(h³), concatMap(f⁴, t³))))
//│ 	| _  => [N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [P2 5 1] [C [P2 5 2] [C [P2 5 5] [N]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ concatMap
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ ok1 -> 0
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t⁰ = (fun f⁰ -> [N])
//│ 	in let h⁰ = [P2 5 10]
//│ 	in (fun f¹ -> append(f¹(h⁰), t⁰(f¹)))(ok1)
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => [C h¹ append(t¹, ys⁰)]
//│ 	| N  => ys⁰}
//│ def concatMap(f², ls⁰) = ls⁰(f²)
//│ def ok1(arg1⁰) = case arg1⁰ of {
//│ 	P2 a⁰ b⁰ => 
//│ 		let ok2⁰ = (fun arg2⁰ -> case arg2⁰ of {
//│ 			P2 c⁰ b¹ => [C [P2 a⁰ c⁰] [N]]
//│ 			| _  => [N]})
//│ 		in let t² = 	
//│ 				let t³ = 	
//│ 					let t⁴ = (fun f³ -> [N])
//│ 					in let h² = [P2 a⁰ b⁰]
//│ 					in (fun f⁴ -> append(f⁴(h²), t⁴(f⁴)))
//│ 				in let h³ = [P2 2 3]
//│ 				in (fun f⁵ -> append(f⁵(h³), t³(f⁵)))
//│ 			in let h⁴ = [P2 1 3]
//│ 			in (fun f⁶ -> append(f⁶(h⁴), t²(f⁶)))(ok2⁰)
//│ 	| _  => [N]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t⁰ = (fun f⁰ -> [N])
//│ 	in let h⁰ = [P2 5 10]
//│ 	in (fun f¹ -> append(f¹(h⁰), t⁰(f¹)))(ok1)
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h¹ t¹ => [C h¹ append(t¹, ys⁰)]
//│ 	| N  => ys⁰}
//│ def concatMap(f², ls⁰) = ls⁰(f²)
//│ def ok1(arg1⁰) = case arg1⁰ of {
//│ 	P2 a⁰ b⁰ => 
//│ 		let ok2⁰ = (fun arg2⁰ -> case arg2⁰ of {
//│ 			P2 c⁰ b¹ => [C [P2 a⁰ c⁰] [N]]
//│ 			| _  => [N]})
//│ 		in let t² = 	
//│ 				let t³ = 	
//│ 					let t⁴ = (fun f³ -> [N])
//│ 					in let h² = [P2 a⁰ b⁰]
//│ 					in (fun f⁴ -> append(f⁴(h²), t⁴(f⁴)))
//│ 				in let h³ = [P2 2 3]
//│ 				in (fun f⁵ -> append(f⁵(h³), t³(f⁵)))
//│ 			in let h⁴ = [P2 1 3]
//│ 			in (fun f⁶ -> append(f⁶(h⁴), t²(f⁶)))(ok2⁰)
//│ 	| _  => [N]}
//│ <<<<<<< after floating out <<<<<<<


// [(x, z) | (x, y1) <- zip [1 .. 3] [2 .. 4], (y2, z) <- zip [x .. x + 2] [y1 .. y1 + 1] , y1 == y2]
// more efficient desugaring, but requires recursive local let binding
_LUMBERHACK_EVAL
fun zip(xs, ys) = if xs is
  C(h, t) then if ys is
    C(h2, t2) then C(P2(h, h2), zip(t, t2))
    N then N
  N then N
fun fromTo(a, b) = if a < (b + 1) then C(a, fromTo(a + 1, b)) else N
let ok1 = ls1 => if ls1 is
  C(h, t) then if h is
    P2(x, y1) then
      let ok2 = ls2 => if ls2 is
        C(h2, t2) then if h2 is
          P2(y2, z) then if y1 == y2 then C(P2(x, z), ok2(t2)) else ok2(t2)
          _ then ok2(t2)
        N then ok1(t)
      ok2(zip(fromTo(x, x + 2), fromTo(y1, y1 + 1)))
    _ then ok1(t)
  N then N
ok1(zip(fromTo(1,3), fromTo(2,4)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |zip|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |ys| |is|→|C|(|h2|,| |t2|)| |#then| |C|(|P2|(|h|,| |h2|)|,| |zip|(|t|,| |t2|)|)|↵|N| |#then| |N|←|↵|N| |#then| |N|←|↵|#fun| |fromTo|(|a|,| |b|)| |#=| |#if| |a| |<| |(|b| |+| |1|)| |#then| |C|(|a|,| |fromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#let| |ok1| |#=| |ls1| |=>| |#if| |ls1| |is|→|C|(|h|,| |t|)| |#then| |#if| |h| |is|→|P2|(|x|,| |y1|)| |#then|→|#let| |ok2| |#=| |ls2| |=>| |#if| |ls2| |is|→|C|(|h2|,| |t2|)| |#then| |#if| |h2| |is|→|P2|(|y2|,| |z|)| |#then| |#if| |y1| |==| |y2| |#then| |C|(|P2|(|x|,| |z|)|,| |ok2|(|t2|)|)| |#else| |ok2|(|t2|)|↵|_| |#then| |ok2|(|t2|)|←|↵|N| |#then| |ok1|(|t|)|←|↵|ok2|(|zip|(|fromTo|(|x|,| |x| |+| |2|)|,| |fromTo|(|y1|,| |y1| |+| |1|)|)|)|←|↵|_| |#then| |ok1|(|t|)|←|↵|N| |#then| |N|←|↵|ok1|(|zip|(|fromTo|(|1|,|3|)|,| |fromTo|(|2|,|4|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun zip = xs, ys, => if xs is ‹(C (h, t,)) then if ys is ‹(C (h2, t2,)) then C (P2 (h, h2,), zip (t, t2,),); (N) then N›; (N) then N›; fun fromTo = a, b, => if (< (a,) (+ (b,) (1,),)) then C (a, fromTo (+ (a,) (1,), b,),) else N; let ok1 = ls1, => if ls1 is ‹(C (h, t,)) then if h is ‹(P2 (x, y1,)) then {let ok2 = ls2, => if ls2 is ‹(C (h2, t2,)) then if h2 is ‹(P2 (y2, z,)) then if (== (y1,) (y2,)) then C (P2 (x, z,), ok2 (t2,),) else ok2 (t2,); (_) then ok2 (t2,)›; (N) then ok1 (t,)›; ok2 (zip (fromTo (x, + (x,) (2,),), fromTo (y1, + (y1,) (1,),),),)}; (_) then ok1 (t,)›; (N) then N›; ok1 (zip (fromTo (1, 3,), fromTo (2, 4,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ok1^102(zip^103(fromTo^104(1, 3), fromTo^110(2, 4)))
//│ def fromTo(a⁰, b⁰) = if (a⁰ < (b⁰ + 1)) then [C a⁰ fromTo^28((a⁰ + 1), b⁰)] else [N]
//│ def ok1(ls1⁰) = case ls1⁰ of {
//│ 	C h¹ t¹ => case h¹ of {
//│ 		P2 x⁰ y1⁰ => 
//│ 			let ok2⁰ = (fun ls2⁰ -> case ls2⁰ of {
//│ 				C h2¹ t2¹ => case h2¹ of {
//│ 					P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹)
//│ 					| _  => ok2⁰(t2¹)}
//│ 				| N  => ok1^66(t¹)})
//│ 			in ok2⁰(zip^72(fromTo^73(x⁰, (x⁰ + 2)), fromTo^83(y1⁰, (y1⁰ + 1))))
//│ 		| _  => ok1^95(t¹)}
//│ 	| N  => [N]}
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => case ys⁰ of {
//│ 		C h2⁰ t2⁰ => [C [P2 h⁰ h2⁰] zip^6(t⁰, t2⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [P2 1 3] [C [P2 2 4] [C [P2 3 5] [N]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [P2 h⁰ h2⁰]: 5 --->
//│ 	case h2¹ of {P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹) | _  => ok2⁰(t2¹)}: 65
//│ 	case h¹ of {P2 x⁰ y1⁰ => let ok2⁰ = (fun ls2⁰ -> case ls2⁰ of {C h2¹ t2¹ => case h2¹ of {P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹) | _  => ok2⁰(t2¹)} | N  => ok1(t¹)})
//│ in ok2⁰(zip(fromTo(x⁰, (x⁰ + 2)), fromTo(y1⁰, (y1⁰ + 1)))) | _  => ok1(t¹)}: 98
//│ [C [P2 h⁰ h2⁰] zip(t⁰, t2⁰)]: 11 --->
//│ 	case ls2⁰ of {C h2¹ t2¹ => case h2¹ of {P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹) | _  => ok2⁰(t2¹)} | N  => ok1(t¹)}: 69
//│ 	case ls1⁰ of {C h¹ t¹ => case h¹ of {P2 x⁰ y1⁰ => let ok2⁰ = (fun ls2⁰ -> case ls2⁰ of {C h2¹ t2¹ => case h2¹ of {P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹) | _  => ok2⁰(t2¹)} | N  => ok1(t¹)})
//│ in ok2⁰(zip(fromTo(x⁰, (x⁰ + 2)), fromTo(y1⁰, (y1⁰ + 1)))) | _  => ok1(t¹)} | N  => [N]}: 100
//│ [N]: 12 --->
//│ 	case ls2⁰ of {C h2¹ t2¹ => case h2¹ of {P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹) | _  => ok2⁰(t2¹)} | N  => ok1(t¹)}: 69
//│ 	case ls1⁰ of {C h¹ t¹ => case h¹ of {P2 x⁰ y1⁰ => let ok2⁰ = (fun ls2⁰ -> case ls2⁰ of {C h2¹ t2¹ => case h2¹ of {P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹) | _  => ok2⁰(t2¹)} | N  => ok1(t¹)})
//│ in ok2⁰(zip(fromTo(x⁰, (x⁰ + 2)), fromTo(y1⁰, (y1⁰ + 1)))) | _  => ok1(t¹)} | N  => [N]}: 100
//│ [N]: 14 --->
//│ 	case ls2⁰ of {C h2¹ t2¹ => case h2¹ of {P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹) | _  => ok2⁰(t2¹)} | N  => ok1(t¹)}: 69
//│ 	case ls1⁰ of {C h¹ t¹ => case h¹ of {P2 x⁰ y1⁰ => let ok2⁰ = (fun ls2⁰ -> case ls2⁰ of {C h2¹ t2¹ => case h2¹ of {P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹) | _  => ok2⁰(t2¹)} | N  => ok1(t¹)})
//│ in ok2⁰(zip(fromTo(x⁰, (x⁰ + 2)), fromTo(y1⁰, (y1⁰ + 1)))) | _  => ok1(t¹)} | N  => [N]}: 100
//│ [C a⁰ fromTo((a⁰ + 1), b⁰)]: 37 --->
//│ 	case ys⁰ of {C h2⁰ t2⁰ => [C [P2 h⁰ h2⁰] zip(t⁰, t2⁰)] | N  => [N]}: 13
//│ 	case xs⁰ of {C h⁰ t⁰ => case ys⁰ of {C h2⁰ t2⁰ => [C [P2 h⁰ h2⁰] zip(t⁰, t2⁰)] | N  => [N]} | N  => [N]}: 15
//│ [N]: 38 --->
//│ 	case ys⁰ of {C h2⁰ t2⁰ => [C [P2 h⁰ h2⁰] zip(t⁰, t2⁰)] | N  => [N]}: 13
//│ 	case xs⁰ of {C h⁰ t⁰ => case ys⁰ of {C h2⁰ t2⁰ => [C [P2 h⁰ h2⁰] zip(t⁰, t2⁰)] | N  => [N]} | N  => [N]}: 15
//│ ------------------
//│ case ys⁰ of {C h2⁰ t2⁰ => [C [P2 h⁰ h2⁰] zip(t⁰, t2⁰)] | N  => [N]}: 13 --->
//│ 	[C a⁰ fromTo((a⁰ + 1), b⁰)]: 37
//│ 	[N]: 38
//│ case xs⁰ of {C h⁰ t⁰ => case ys⁰ of {C h2⁰ t2⁰ => [C [P2 h⁰ h2⁰] zip(t⁰, t2⁰)] | N  => [N]} | N  => [N]}: 15 --->
//│ 	[C a⁰ fromTo((a⁰ + 1), b⁰)]: 37
//│ 	[N]: 38
//│ case h2¹ of {P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹) | _  => ok2⁰(t2¹)}: 65 --->
//│ 	[P2 h⁰ h2⁰]: 5
//│ case ls2⁰ of {C h2¹ t2¹ => case h2¹ of {P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹) | _  => ok2⁰(t2¹)} | N  => ok1(t¹)}: 69 --->
//│ 	[C [P2 h⁰ h2⁰] zip(t⁰, t2⁰)]: 11
//│ 	[N]: 12
//│ 	[N]: 14
//│ case h¹ of {P2 x⁰ y1⁰ => let ok2⁰ = (fun ls2⁰ -> case ls2⁰ of {C h2¹ t2¹ => case h2¹ of {P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹) | _  => ok2⁰(t2¹)} | N  => ok1(t¹)})
//│ in ok2⁰(zip(fromTo(x⁰, (x⁰ + 2)), fromTo(y1⁰, (y1⁰ + 1)))) | _  => ok1(t¹)}: 98 --->
//│ 	[P2 h⁰ h2⁰]: 5
//│ case ls1⁰ of {C h¹ t¹ => case h¹ of {P2 x⁰ y1⁰ => let ok2⁰ = (fun ls2⁰ -> case ls2⁰ of {C h2¹ t2¹ => case h2¹ of {P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹) | _  => ok2⁰(t2¹)} | N  => ok1(t¹)})
//│ in ok2⁰(zip(fromTo(x⁰, (x⁰ + 2)), fromTo(y1⁰, (y1⁰ + 1)))) | _  => ok1(t¹)} | N  => [N]}: 100 --->
//│ 	[C [P2 h⁰ h2⁰] zip(t⁰, t2⁰)]: 11
//│ 	[N]: 12
//│ 	[N]: 14
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ok1(zip(fromTo(1, 3), fromTo(2, 4)))
//│ def fromTo(a¹, b¹) = if (a¹ < (b¹ + 1)) then [C a¹ fromTo((a¹ + 1), b¹)] else [N]
//│ def ok1(ls1¹) = case ls1¹ of {
//│ 	C h¹ t¹ => case h¹ of {
//│ 		P2 x⁰ y1⁰ => 
//│ 			let ok2¹ = (fun ls2¹ -> case ls2¹ of {
//│ 				C h2¹ t2¹ => case h2¹ of {
//│ 					P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2¹(t2¹)] else ok2¹(t2¹)
//│ 					| _  => ok2¹(t2¹)}
//│ 				| N  => ok1(t¹)})
//│ 			in ok2¹(zip(fromTo(x⁰, (x⁰ + 2)), fromTo(y1⁰, (y1⁰ + 1))))
//│ 		| _  => ok1(t¹)}
//│ 	| N  => [N]}
//│ def zip(xs¹, ys¹) = case xs¹ of {
//│ 	C h⁰ t⁰ => case ys¹ of {
//│ 		C h2⁰ t2⁰ => [C [P2 h⁰ h2⁰] zip(t⁰, t2⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [P2 1 3] [C [P2 2 4] [C [P2 3 5] [N]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ ok1(zip(fromTo(1, 3), fromTo(2, 4)))
//│ def fromTo(a⁰, b⁰) = if (a⁰ < (b⁰ + 1)) then [C a⁰ fromTo((a⁰ + 1), b⁰)] else [N]
//│ def ok1(ls1⁰) = case ls1⁰ of {
//│ 	C h¹ t¹ => case h¹ of {
//│ 		P2 x⁰ y1⁰ => 
//│ 			let ok2⁰ = (fun ls2⁰ -> case ls2⁰ of {
//│ 				C h2¹ t2¹ => case h2¹ of {
//│ 					P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹)
//│ 					| _  => ok2⁰(t2¹)}
//│ 				| N  => ok1(t¹)})
//│ 			in ok2⁰(zip(fromTo(x⁰, (x⁰ + 2)), fromTo(y1⁰, (y1⁰ + 1))))
//│ 		| _  => ok1(t¹)}
//│ 	| N  => [N]}
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => case ys⁰ of {
//│ 		C h2⁰ t2⁰ => [C [P2 h⁰ h2⁰] zip(t⁰, t2⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ ok1(zip(fromTo(1, 3), fromTo(2, 4)))
//│ def fromTo(a⁰, b⁰) = if (a⁰ < (b⁰ + 1)) then [C a⁰ fromTo((a⁰ + 1), b⁰)] else [N]
//│ def ok1(ls1⁰) = case ls1⁰ of {
//│ 	C h¹ t¹ => case h¹ of {
//│ 		P2 x⁰ y1⁰ => 
//│ 			let ok2⁰ = (fun ls2⁰ -> case ls2⁰ of {
//│ 				C h2¹ t2¹ => case h2¹ of {
//│ 					P2 y2⁰ z⁰ => if (y1⁰ == y2⁰) then [C [P2 x⁰ z⁰] ok2⁰(t2¹)] else ok2⁰(t2¹)
//│ 					| _  => ok2⁰(t2¹)}
//│ 				| N  => ok1(t¹)})
//│ 			in ok2⁰(zip(fromTo(x⁰, (x⁰ + 2)), fromTo(y1⁰, (y1⁰ + 1))))
//│ 		| _  => ok1(t¹)}
//│ 	| N  => [N]}
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => case ys⁰ of {
//│ 		C h2⁰ t2⁰ => [C [P2 h⁰ h2⁰] zip(t⁰, t2⁰)]
//│ 		| N  => [N]}
//│ 	| N  => [N]}
//│ <<<<<<< after floating out <<<<<<<


// NOTE: what if we lift the inner mutual recursive lambdas out?
// [(x, y) | x <- [1..2], y <- [3..4]]
_LUMBERHACK_EVAL
fun go1(ls1, ls2) = if ls1 is
  C(h1, t1) then go2(ls2, h1, t1)
  N then N
fun go2(ls2, h1, t1) = if ls2 is
  C(h2, t2) then C(P2(h1, h2), go2(t2, h1, t1))
  N then go1(t1, ls2)
go1(C(1, C(2, N)), C(3, C(4, N)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |go1|(|ls1|,| |ls2|)| |#=| |#if| |ls1| |is|→|C|(|h1|,| |t1|)| |#then| |go2|(|ls2|,| |h1|,| |t1|)|↵|N| |#then| |N|←|↵|#fun| |go2|(|ls2|,| |h1|,| |t1|)| |#=| |#if| |ls2| |is|→|C|(|h2|,| |t2|)| |#then| |C|(|P2|(|h1|,| |h2|)|,| |go2|(|t2|,| |h1|,| |t1|)|)|↵|N| |#then| |go1|(|t1|,| |ls2|)|←|↵|go1|(|C|(|1|,| |C|(|2|,| |N|)|)|,| |C|(|3|,| |C|(|4|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun go1 = ls1, ls2, => if ls1 is ‹(C (h1, t1,)) then go2 (ls2, h1, t1,); (N) then N›; fun go2 = ls2, h1, t1, => if ls2 is ‹(C (h2, t2,)) then C (P2 (h1, h2,), go2 (t2, h1, t1,),); (N) then go1 (t1, ls2,)›; go1 (C (1, C (2, N,),), C (3, C (4, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ go1^34([C 1 [C 2 [N]]], [C 3 [C 4 [N]]])
//│ def go1(ls1⁰, ls2⁰) = case ls1⁰ of {
//│ 	C h1⁰ t1⁰ => go2^2(ls2⁰, h1⁰, t1⁰)
//│ 	| N  => [N]}
//│ def go2(ls2¹, h1¹, t1¹) = case ls2¹ of {
//│ 	C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2^17(t2⁰, h1¹, t1¹)]
//│ 	| N  => go1^25(t1¹, ls2¹)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [P2 1 3] [C [P2 1 4] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 37 --->
//│ 	case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10
//│ [C 2 [N]]: 38 --->
//│ 	case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10
//│ [N]: 43 --->
//│ 	case ls2¹ of {C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2(t2⁰, h1¹, t1¹)] | N  => go1(t1¹, ls2¹)}: 30
//│ [C 4 [N]]: 44 --->
//│ 	case ls2¹ of {C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2(t2⁰, h1¹, t1¹)] | N  => go1(t1¹, ls2¹)}: 30
//│ [C 3 [C 4 [N]]]: 45 --->
//│ 	case ls2¹ of {C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2(t2⁰, h1¹, t1¹)] | N  => go1(t1¹, ls2¹)}: 30
//│ ------------------
//│ case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10 --->
//│ 	[N]: 37
//│ 	[C 2 [N]]: 38
//│ 	[C 1 [C 2 [N]]]: 39
//│ case ls2¹ of {C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2(t2⁰, h1¹, t1¹)] | N  => go1(t1¹, ls2¹)}: 30 --->
//│ 	[N]: 43
//│ 	[C 4 [N]]: 44
//│ 	[C 3 [C 4 [N]]]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 37 --->
//│ 	case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10
//│ [C 2 [N]]: 38 --->
//│ 	case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10
//│ [N]: 43 --->
//│ 	case ls2¹ of {C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2(t2⁰, h1¹, t1¹)] | N  => go1(t1¹, ls2¹)}: 30
//│ [C 4 [N]]: 44 --->
//│ 	case ls2¹ of {C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2(t2⁰, h1¹, t1¹)] | N  => go1(t1¹, ls2¹)}: 30
//│ [C 3 [C 4 [N]]]: 45 --->
//│ 	case ls2¹ of {C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2(t2⁰, h1¹, t1¹)] | N  => go1(t1¹, ls2¹)}: 30
//│ ------------------
//│ case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10 --->
//│ 	[N]: 37
//│ 	[C 2 [N]]: 38
//│ 	[C 1 [C 2 [N]]]: 39
//│ case ls2¹ of {C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2(t2⁰, h1¹, t1¹)] | N  => go1(t1¹, ls2¹)}: 30 --->
//│ 	[N]: 43
//│ 	[C 4 [N]]: 44
//│ 	[C 3 [C 4 [N]]]: 45
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ go1(
//│ 	let t1² = 	
//│ 		let t1³ = (fun ls2⁴ -> [N])
//│ 		in let h1³ = 2
//│ 		in (fun ls2³ -> go2(ls2³, h1³, t1³))
//│ 	in let h1² = 1
//│ 	in (fun ls2² -> go2(ls2², h1², t1²)), 
//│ 	let t2¹ = 	
//│ 		let t2² = (fun h1⁶ -> (fun t1⁶ -> (fun ls2⁷ -> go1(t1⁶, ls2⁷))))
//│ 		in let h2² = 4
//│ 		in (fun h1⁵ -> (fun t1⁵ -> (fun ls2⁶ -> [C [P2 h1⁵ h2²] go2(t2², h1⁵, t1⁵)])))
//│ 	in let h2¹ = 3
//│ 	in (fun h1⁴ -> (fun t1⁴ -> (fun ls2⁵ -> [C [P2 h1⁴ h2¹] go2(t2¹, h1⁴, t1⁴)]))))
//│ def go1(ls1¹, ls2⁸) = ls1¹(ls2⁸)
//│ def go2(ls2⁹, h1⁷, t1⁷) = ls2⁹(h1⁷, t1⁷, ls2⁹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [P2 1 3] [C [P2 1 4] [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ go1, go2
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t1⁰ = 	
//│ 		let t1¹ = (fun ls2⁰ -> [N])
//│ 		in let h1⁰ = 2
//│ 		in (fun ls2¹ -> ls2¹(h1⁰, t1¹, ls2¹))
//│ 	in let h1¹ = 1
//│ 	in (fun ls2² -> ls2²(h1¹, t1⁰, ls2²))(
//│ 	let t2⁰ = 	
//│ 		let t2¹ = (fun h1² -> (fun t1² -> (fun ls2³ -> t1²(ls2³))))
//│ 		in let h2⁰ = 4
//│ 		in (fun h1³ -> (fun t1³ -> (fun ls2⁴ -> [C [P2 h1³ h2⁰] t2¹(h1³, t1³, t2¹)])))
//│ 	in let h2¹ = 3
//│ 	in (fun h1⁴ -> (fun t1⁴ -> (fun ls2⁵ -> [C [P2 h1⁴ h2¹] t2⁰(h1⁴, t1⁴, t2⁰)]))))
//│ def go1(ls1⁰, ls2⁶) = ls1⁰(ls2⁶)
//│ def go2(ls2⁷, h1⁵, t1⁵) = ls2⁷(h1⁵, t1⁵, ls2⁷)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t1⁰ = 	
//│ 		let t1¹ = (fun ls2⁰ -> [N])
//│ 		in let h1⁰ = 2
//│ 		in (fun ls2¹ -> ls2¹(h1⁰, t1¹, ls2¹))
//│ 	in let h1¹ = 1
//│ 	in (fun ls2² -> ls2²(h1¹, t1⁰, ls2²))(
//│ 	let t2⁰ = 	
//│ 		let t2¹ = (fun h1² -> (fun t1² -> (fun ls2³ -> t1²(ls2³))))
//│ 		in let h2⁰ = 4
//│ 		in (fun h1³ -> (fun t1³ -> (fun ls2⁴ -> [C [P2 h1³ h2⁰] t2¹(h1³, t1³, t2¹)])))
//│ 	in let h2¹ = 3
//│ 	in (fun h1⁴ -> (fun t1⁴ -> (fun ls2⁵ -> [C [P2 h1⁴ h2¹] t2⁰(h1⁴, t1⁴, t2⁰)]))))
//│ def go1(ls1⁰, ls2⁶) = ls1⁰(ls2⁶)
//│ def go2(ls2⁷, h1⁵, t1⁵) = ls2⁷(h1⁵, t1⁵, ls2⁷)
//│ <<<<<<< after floating out <<<<<<<


// [(x, y) | x <- [1, 2], y <- [3, 4]]
// NOTE: change `ls2` to `N` and we need two iteration to fully fuse
_LUMBERHACK_EVAL
fun go1(ls1, ls2) = if ls1 is
  C(h1, t1) then go2(ls2, h1, t1)
  N then N
fun go2(ls2, h1, t1) = if ls2 is
  C(h2, t2) then C(P2(h1, h2), go2(t2, h1, t1))
  N then go1(t1, N)
go1(C(1, C(2, N)), C(3, C(4, N)))
//│ |_LUMBERHACK_EVAL|↵|#fun| |go1|(|ls1|,| |ls2|)| |#=| |#if| |ls1| |is|→|C|(|h1|,| |t1|)| |#then| |go2|(|ls2|,| |h1|,| |t1|)|↵|N| |#then| |N|←|↵|#fun| |go2|(|ls2|,| |h1|,| |t1|)| |#=| |#if| |ls2| |is|→|C|(|h2|,| |t2|)| |#then| |C|(|P2|(|h1|,| |h2|)|,| |go2|(|t2|,| |h1|,| |t1|)|)|↵|N| |#then| |go1|(|t1|,| |N|)|←|↵|go1|(|C|(|1|,| |C|(|2|,| |N|)|)|,| |C|(|3|,| |C|(|4|,| |N|)|)|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun go1 = ls1, ls2, => if ls1 is ‹(C (h1, t1,)) then go2 (ls2, h1, t1,); (N) then N›; fun go2 = ls2, h1, t1, => if ls2 is ‹(C (h2, t2,)) then C (P2 (h1, h2,), go2 (t2, h1, t1,),); (N) then go1 (t1, N,)›; go1 (C (1, C (2, N,),), C (3, C (4, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ go1^34([C 1 [C 2 [N]]], [C 3 [C 4 [N]]])
//│ def go1(ls1⁰, ls2⁰) = case ls1⁰ of {
//│ 	C h1⁰ t1⁰ => go2^2(ls2⁰, h1⁰, t1⁰)
//│ 	| N  => [N]}
//│ def go2(ls2¹, h1¹, t1¹) = case ls2¹ of {
//│ 	C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2^17(t2⁰, h1¹, t1¹)]
//│ 	| N  => go1^25(t1¹, [N])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C [P2 1 3] [C [P2 1 4] [N]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 28 --->
//│ 	case ls2¹ of {C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2(t2⁰, h1¹, t1¹)] | N  => go1(t1¹, [N])}: 30
//│ [N]: 37 --->
//│ 	case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10
//│ [C 2 [N]]: 38 --->
//│ 	case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10
//│ [N]: 43 --->
//│ 	case ls2¹ of {C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2(t2⁰, h1¹, t1¹)] | N  => go1(t1¹, [N])}: 30
//│ [C 4 [N]]: 44 --->
//│ 	case ls2¹ of {C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2(t2⁰, h1¹, t1¹)] | N  => go1(t1¹, [N])}: 30
//│ [C 3 [C 4 [N]]]: 45 --->
//│ 	case ls2¹ of {C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2(t2⁰, h1¹, t1¹)] | N  => go1(t1¹, [N])}: 30
//│ ------------------
//│ case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10 --->
//│ 	[N]: 37
//│ 	[C 2 [N]]: 38
//│ 	[C 1 [C 2 [N]]]: 39
//│ case ls2¹ of {C h2⁰ t2⁰ => [C [P2 h1¹ h2⁰] go2(t2⁰, h1¹, t1¹)] | N  => go1(t1¹, [N])}: 30 --->
//│ 	[N]: 28
//│ 	[N]: 43
//│ 	[C 4 [N]]: 44
//│ 	[C 3 [C 4 [N]]]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 37 --->
//│ 	case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10
//│ [C 2 [N]]: 38 --->
//│ 	case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10
//│ ------------------
//│ case ls1⁰ of {C h1⁰ t1⁰ => go2(ls2⁰, h1⁰, t1⁰) | N  => [N]}: 10 --->
//│ 	[N]: 37
//│ 	[C 2 [N]]: 38
//│ 	[C 1 [C 2 [N]]]: 39
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ go1(
//│ 	let t1² = 	
//│ 		let t1³ = (fun ls2⁴ -> [N])
//│ 		in let h1³ = 2
//│ 		in (fun ls2³ -> go2(ls2³, h1³, t1³))
//│ 	in let h1² = 1
//│ 	in (fun ls2² -> go2(ls2², h1², t1²)), [C 3 [C 4 [N]]])
//│ def go1(ls1¹, ls2⁵) = ls1¹(ls2⁵)
//│ def go2(ls2⁶, h1⁴, t1⁴) = case ls2⁶ of {
//│ 	C h2⁰ t2⁰ => [C [P2 h1⁴ h2⁰] go2(t2⁰, h1⁴, t1⁴)]
//│ 	| N  => go1(t1⁴, [N])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C [P2 1 3] [C [P2 1 4] [N]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ go1
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let t1⁰ = 	
//│ 		let t1¹ = (fun ls2⁰ -> [N])
//│ 		in let h1⁰ = 2
//│ 		in (fun ls2¹ -> go2(ls2¹, h1⁰, t1¹))
//│ 	in let h1¹ = 1
//│ 	in (fun ls2² -> go2(ls2², h1¹, t1⁰))([C 3 [C 4 [N]]])
//│ def go1(ls1⁰, ls2³) = ls1⁰(ls2³)
//│ def go2(ls2⁴, h1², t1²) = case ls2⁴ of {
//│ 	C h2⁰ t2⁰ => [C [P2 h1² h2⁰] go2(t2⁰, h1², t1²)]
//│ 	| N  => t1²([N])}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let t1⁰ = 	
//│ 		let t1¹ = (fun ls2⁰ -> [N])
//│ 		in let h1⁰ = 2
//│ 		in (fun ls2¹ -> go2(ls2¹, h1⁰, t1¹))
//│ 	in let h1¹ = 1
//│ 	in (fun ls2² -> go2(ls2², h1¹, t1⁰))([C 3 [C 4 [N]]])
//│ def go1(ls1⁰, ls2³) = ls1⁰(ls2³)
//│ def go2(ls2⁴, h1², t1²) = case ls2⁴ of {
//│ 	C h2⁰ t2⁰ => [C [P2 h1² h2⁰] go2(t2⁰, h1², t1²)]
//│ 	| N  => t1²([N])}
//│ <<<<<<< after floating out <<<<<<<
