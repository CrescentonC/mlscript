:NewParser
:ParseOnly


// WRONG: no fusion done, even after adding `idList`
:lhEval
fun fromEnumTo(a, b) = if a <= b then C(a, fromEnumTo(a + 1, b)) else N
fun append(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, append(t, ys))
fun nrev(ls) = if ls is
  C(h, t) then append(nrev(t), C(h, N))
  N then N
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
map(x => x + 1, nrev(primId(fromEnumTo(1, 4))))
//│ |#fun| |fromEnumTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |fromEnumTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|←|↵|#fun| |nrev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |append|(|nrev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|map|(|x| |=>| |x| |+| |1|,| |nrev|(|primId|(|fromEnumTo|(|1|,| |4|)|)|)|)|
//│ Parsed: {fun fromEnumTo = a, b, => if (<= (a,) (b,)) then C (a, fromEnumTo (+ (a,) (1,), b,),) else N; fun append = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, append (t, ys,),)›; fun nrev = ls, => if ls is ‹(C (h, t,)) then append (nrev (t,), C (h, N,),); (N) then N›; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; map (x, => + (x,) (1,), nrev (primId (fromEnumTo (1, 4,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^60((fun x⁰ -> (x⁰ + 1)), nrev^68(primId⁰(fromEnumTo^70(1, 4))))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ append^24(t⁰, ys⁰)]}
//│ def fromEnumTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ fromEnumTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls¹) = case ls¹ of {
//│ 	C h² t² => [C f⁰(h²) map^50(f⁰, t²)]
//│ 	| N  => [N]}
//│ def nrev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => append^34(nrev^35(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 5 [C 4 [C 3 [C 2 [N]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fromEnumTo^70] (hopeless to continue)
//│ 	[fromEnumTo^70 · fromEnumTo^7] ---> [fromEnumTo^70] (using original def)
//│ [map^60] (hopeless to continue)
//│ 	[map^60 · map^50] ---> [map^60] (using original def)
//│ [nrev^68] (hopeless to continue)
//│ 	[nrev^68 · append^34] (using original def)
//│ 		[nrev^68 · append^34 · append^24] ---> [nrev^68 · append^34] (using original def)
//│ 	[nrev^68 · nrev^35] ---> [nrev^68] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ map_₀((fun x¹ -> (x¹ + 1)), nrev_₀(primId⁰(fromEnumTo_₀(1, 4))))
//│ def fromEnumTo_₀(a¹, b¹) = 
//│ 	if (a¹ <= b¹) then [C a¹ fromEnumTo_₀((a¹ + 1), b¹)] else [N]
//│ def map_₀(f¹, ls³) = 
//│ 	case ls³ of {
//│ 		C h⁵ t⁵ => [C f¹(h⁵) map_₀(f¹, t⁵)]
//│ 		| N  => [N]}
//│ def nrev_₀(ls²) = 
//│ 	case ls² of {
//│ 		C h⁴ t⁴ => append_₀(nrev_₀(t⁴), [C h⁴ [N]])
//│ 		| N  => [N]}
//│ 	where
//│ 	def append_₀(xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			N  => ys¹
//│ 			| C h³ t³ => [C h³ append_₀(t³, ys¹)]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h³ append_₀(t³, ys¹)]: 86 --->
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ append_₀(t³, ys¹)]}: 87
//│ 	case ls³ of {C h⁵ t⁵ => [C f¹(h⁵) map_₀(f¹, t⁵)] | N  => [N]}: 114
//│ [N]: 97 --->
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ append_₀(t³, ys¹)]}: 87
//│ 	case ls³ of {C h⁵ t⁵ => [C f¹(h⁵) map_₀(f¹, t⁵)] | N  => [N]}: 114
//│ [C h⁴ [N]]: 98 --->
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ append_₀(t³, ys¹)]}: 87
//│ 	case ls³ of {C h⁵ t⁵ => [C f¹(h⁵) map_₀(f¹, t⁵)] | N  => [N]}: 114
//│ [N]: 100 --->
//│ 	case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ append_₀(t³, ys¹)]}: 87
//│ 	case ls³ of {C h⁵ t⁵ => [C f¹(h⁵) map_₀(f¹, t⁵)] | N  => [N]}: 114
//│ ------------------
//│ case xs¹ of {N  => ys¹ | C h³ t³ => [C h³ append_₀(t³, ys¹)]}: 87 --->
//│ 	[C h³ append_₀(t³, ys¹)]: 86
//│ 	[N]: 97
//│ 	[C h⁴ [N]]: 98
//│ 	[N]: 100
//│ case ls³ of {C h⁵ t⁵ => [C f¹(h⁵) map_₀(f¹, t⁵)] | N  => [N]}: 114 --->
//│ 	[C h³ append_₀(t³, ys¹)]: 86
//│ 	[N]: 97
//│ 	[C h⁴ [N]]: 98
//│ 	[N]: 100
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map_₀((fun x² -> (x² + 1)), nrev_₀(primId⁰(fromEnumTo_₀(1, 4))))
//│ def fromEnumTo_₀(a², b²) = 
//│ 	if (a² <= b²) then [C a² fromEnumTo_₀((a² + 1), b²)] else [N]
//│ def map_₀(f², ls⁵) = 
//│ 	case ls⁵ of {
//│ 		C h⁵ t⁵ => [C f²(h⁵) map_₀(f², t⁵)]
//│ 		| N  => [N]}
//│ def nrev_₀(ls⁴) = 
//│ 	case ls⁴ of {
//│ 		C h⁴ t⁴ => append_₀(nrev_₀(t⁴), [C h⁴ [N]])
//│ 		| N  => [N]}
//│ 	where
//│ 	def append_₀(xs², ys²) = 
//│ 		case xs² of {
//│ 			N  => ys²
//│ 			| C h³ t³ => [C h³ append_₀(t³, ys²)]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 5 [C 4 [C 3 [C 2 [N]]]]]
//│ <<<<<<< evaluate <<<<<<<


// CORRECT: can get some simple fusion done
fun fromEnumTo(a, b) = if a <= b then C(a, fromEnumTo(a + 1, b)) else N
fun append(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, append(t, ys))
fun nrev(ls) = if ls is
  C(h, t) then append(nrev(t), C(h, N))
  N then N
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
nrev(map(x => x + 1, primId(fromEnumTo(1, 6))))
//│ |#fun| |fromEnumTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |fromEnumTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|←|↵|#fun| |nrev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |append|(|nrev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|nrev|(|map|(|x| |=>| |x| |+| |1|,| |primId|(|fromEnumTo|(|1|,| |6|)|)|)|)|
//│ Parsed: {fun fromEnumTo = a, b, => if (<= (a,) (b,)) then C (a, fromEnumTo (+ (a,) (1,), b,),) else N; fun append = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, append (t, ys,),)›; fun nrev = ls, => if ls is ‹(C (h, t,)) then append (nrev (t,), C (h, N,),); (N) then N›; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; nrev (map (x, => + (x,) (1,), primId (fromEnumTo (1, 6,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ nrev^60(map^61((fun x⁰ -> (x⁰ + 1)), primId⁰(fromEnumTo^70(1, 6))))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ append^24(t⁰, ys⁰)]}
//│ def fromEnumTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ fromEnumTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls¹) = case ls¹ of {
//│ 	C h² t² => [C f⁰(h²) map^50(f⁰, t²)]
//│ 	| N  => [N]}
//│ def nrev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => append^34(nrev^35(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [fromEnumTo^70] (hopeless to continue)
//│ 	[fromEnumTo^70 · fromEnumTo^7] ---> [fromEnumTo^70] (using original def)
//│ [map^61] (hopeless to continue)
//│ 	[map^61 · map^50] ---> [map^61] (using original def)
//│ [nrev^60] (hopeless to continue)
//│ 	[nrev^60 · append^34] (using original def)
//│ 		[nrev^60 · append^34 · append^24] ---> [nrev^60 · append^34] (using original def)
//│ 	[nrev^60 · nrev^35] ---> [nrev^60] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ nrev_₀(map_₀((fun x¹ -> (x¹ + 1)), primId⁰(fromEnumTo_₀(1, 6))))
//│ def fromEnumTo_₀(a¹, b¹) = 
//│ 	if (a¹ <= b¹) then [C a¹ fromEnumTo_₀((a¹ + 1), b¹)] else [N]
//│ def map_₀(f¹, ls³) = 
//│ 	case ls³ of {
//│ 		C h⁴ t⁴ => [C f¹(h⁴) map_₀(f¹, t⁴)]
//│ 		| N  => [N]}
//│ def nrev_₀(ls²) = 
//│ 	case ls² of {
//│ 		C h³ t³ => append_₀(nrev_₀(t³), [C h³ [N]])
//│ 		| N  => [N]}
//│ 	where
//│ 	def append_₀(xs¹, ys¹) = 
//│ 		case xs¹ of {
//│ 			N  => ys¹
//│ 			| C h⁵ t⁵ => [C h⁵ append_₀(t⁵, ys¹)]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 85 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h⁵ t⁵ => [C h⁵ append_₀(t⁵, ys¹)]}: 134
//│ [C h³ [N]]: 86 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h⁵ t⁵ => [C h⁵ append_₀(t⁵, ys¹)]}: 134
//│ [N]: 88 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h⁵ t⁵ => [C h⁵ append_₀(t⁵, ys¹)]}: 134
//│ [C f¹(h⁴) map_₀(f¹, t⁴)]: 100 --->
//│ 	case ls² of {C h³ t³ => append_₀(nrev_₀(t³), [C h³ [N]]) | N  => [N]}: 89
//│ [N]: 101 --->
//│ 	case ls² of {C h³ t³ => append_₀(nrev_₀(t³), [C h³ [N]]) | N  => [N]}: 89
//│ [C h⁵ append_₀(t⁵, ys¹)]: 133 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h⁵ t⁵ => [C h⁵ append_₀(t⁵, ys¹)]}: 134
//│ ------------------
//│ case ls² of {C h³ t³ => append_₀(nrev_₀(t³), [C h³ [N]]) | N  => [N]}: 89 --->
//│ 	[C f¹(h⁴) map_₀(f¹, t⁴)]: 100
//│ 	[N]: 101
//│ case xs¹ of {N  => ys¹ | C h⁵ t⁵ => [C h⁵ append_₀(t⁵, ys¹)]}: 134 --->
//│ 	[N]: 85
//│ 	[C h³ [N]]: 86
//│ 	[N]: 88
//│ 	[C h⁵ append_₀(t⁵, ys¹)]: 133
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f¹(h⁴) map_₀(f¹, t⁴)]: 100 --->
//│ 	case ls² of {C h³ t³ => append_₀(nrev_₀(t³), [C h³ [N]]) | N  => [N]}: 89
//│ [N]: 101 --->
//│ 	case ls² of {C h³ t³ => append_₀(nrev_₀(t³), [C h³ [N]]) | N  => [N]}: 89
//│ ------------------
//│ case ls² of {C h³ t³ => append_₀(nrev_₀(t³), [C h³ [N]]) | N  => [N]}: 89 --->
//│ 	[C f¹(h⁴) map_₀(f¹, t⁴)]: 100
//│ 	[N]: 101
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ nrev_₀(map_₀((fun x² -> (x² + 1)), primId⁰(fromEnumTo_₀(1, 6))))
//│ def fromEnumTo_₀(a², b²) = 
//│ 	if (a² <= b²) then [C a² fromEnumTo_₀((a² + 1), b²)] else [N]
//│ def map_₀(f², ls⁵) = 
//│ 	case ls⁵ of {
//│ 		C h⁴ t⁴ => 
//│ 			let t⁶ = map_₀(f², t⁴)
//│ 			in let h⁶ = f²(h⁴)
//│ 			in (fun _lh_dummy⁰ -> append_₀(nrev_₀(t⁶), [C h⁶ [N]]))
//│ 		| N  => (fun _lh_dummy¹ -> [N])}
//│ def nrev_₀(ls⁴) = 
//│ 	ls⁴(99)
//│ 	where
//│ 	def append_₀(xs², ys²) = 
//│ 		case xs² of {
//│ 			N  => ys²
//│ 			| C h⁵ t⁵ => [C h⁵ append_₀(t⁵, ys²)]}
//│ <<<<<<< after fusion <<<<<<<


// WRONG: just adding another call the knot tier will not tie the ideal knots!
fun fromEnumTo(a, b) = if a <= b then C(a, fromEnumTo(a + 1, b)) else N
fun append(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, append(t, ys))
fun nrev(ls) = if ls is
  C(h, t) then append(nrev(t), C(h, N))
  N then N
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun t(n) = nrev(map(x => x + 1, primId(fromEnumTo(1, n))))
t(4)
//│ |#fun| |fromEnumTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |fromEnumTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|←|↵|#fun| |nrev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |append|(|nrev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |t|(|n|)| |#=| |nrev|(|map|(|x| |=>| |x| |+| |1|,| |primId|(|fromEnumTo|(|1|,| |n|)|)|)|)|↵|t|(|4|)|
//│ Parsed: {fun fromEnumTo = a, b, => if (<= (a,) (b,)) then C (a, fromEnumTo (+ (a,) (1,), b,),) else N; fun append = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, append (t, ys,),)›; fun nrev = ls, => if ls is ‹(C (h, t,)) then append (nrev (t,), C (h, N,),); (N) then N›; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun t = n, => nrev (map (x, => + (x,) (1,), primId (fromEnumTo (1, n,),),),); t (4,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ t^79(4)
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t¹ => [C h⁰ append^24(t¹, ys⁰)]}
//│ def fromEnumTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ fromEnumTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls¹) = case ls¹ of {
//│ 	C h² t³ => [C f⁰(h²) map^50(f⁰, t³)]
//│ 	| N  => [N]}
//│ def nrev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t² => append^34(nrev^35(t²), [C h¹ [N]])
//│ 	| N  => [N]}
//│ def t(n⁰) = nrev^60(map^61((fun x⁰ -> (x⁰ + 1)), primId⁰(fromEnumTo^70(1, n⁰))))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [t^79] (hopeless to continue)
//│ 	[t^79 · fromEnumTo^70] (using original def)
//│ 		[t^79 · fromEnumTo^70 · fromEnumTo^7] ---> [t^79 · fromEnumTo^70] (using original def)
//│ 	[t^79 · map^61] (using original def)
//│ 		[t^79 · map^61 · map^50] ---> [t^79 · map^61] (using original def)
//│ 	[t^79 · nrev^60] (using original def)
//│ 		[t^79 · nrev^60 · append^34] (using original def)
//│ 			[t^79 · nrev^60 · append^34 · append^24] ---> [t^79 · nrev^60 · append^34] (using original def)
//│ 		[t^79 · nrev^60 · nrev^35] ---> [t^79 · nrev^60] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ t_₀(4)
//│ def t_₀(n¹) = 
//│ 	nrev_₀(map_₀((fun x¹ -> (x¹ + 1)), primId⁰(fromEnumTo_₀(1, n¹))))
//│ 	where
//│ 	def fromEnumTo_₀(a¹, b¹) = 
//│ 		if (a¹ <= b¹) then [C a¹ fromEnumTo_₀((a¹ + 1), b¹)] else [N]
//│ 	def map_₀(f¹, ls³) = 
//│ 		case ls³ of {
//│ 			C h⁵ t⁶ => [C f¹(h⁵) map_₀(f¹, t⁶)]
//│ 			| N  => [N]}
//│ 	def nrev_₀(ls²) = 
//│ 		case ls² of {
//│ 			C h³ t⁴ => append_₀(nrev_₀(t⁴), [C h³ [N]])
//│ 			| N  => [N]}
//│ 		where
//│ 		def append_₀(xs¹, ys¹) = 
//│ 			case xs¹ of {
//│ 				N  => ys¹
//│ 				| C h⁴ t⁵ => [C h⁴ append_₀(t⁵, ys¹)]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 89 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h⁴ t⁵ => [C h⁴ append_₀(t⁵, ys¹)]}: 143
//│ [C h³ [N]]: 90 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h⁴ t⁵ => [C h⁴ append_₀(t⁵, ys¹)]}: 143
//│ [N]: 92 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h⁴ t⁵ => [C h⁴ append_₀(t⁵, ys¹)]}: 143
//│ [C h⁴ append_₀(t⁵, ys¹)]: 142 --->
//│ 	NoCons
//│ 	case xs¹ of {N  => ys¹ | C h⁴ t⁵ => [C h⁴ append_₀(t⁵, ys¹)]}: 143
//│ [C f¹(h⁵) map_₀(f¹, t⁶)]: 155 --->
//│ 	case ls² of {C h³ t⁴ => append_₀(nrev_₀(t⁴), [C h³ [N]]) | N  => [N]}: 93
//│ [N]: 156 --->
//│ 	case ls² of {C h³ t⁴ => append_₀(nrev_₀(t⁴), [C h³ [N]]) | N  => [N]}: 93
//│ ------------------
//│ case ls² of {C h³ t⁴ => append_₀(nrev_₀(t⁴), [C h³ [N]]) | N  => [N]}: 93 --->
//│ 	[C f¹(h⁵) map_₀(f¹, t⁶)]: 155
//│ 	[N]: 156
//│ case xs¹ of {N  => ys¹ | C h⁴ t⁵ => [C h⁴ append_₀(t⁵, ys¹)]}: 143 --->
//│ 	[N]: 89
//│ 	[C h³ [N]]: 90
//│ 	[N]: 92
//│ 	[C h⁴ append_₀(t⁵, ys¹)]: 142
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f¹(h⁵) map_₀(f¹, t⁶)]: 155 --->
//│ 	case ls² of {C h³ t⁴ => append_₀(nrev_₀(t⁴), [C h³ [N]]) | N  => [N]}: 93
//│ [N]: 156 --->
//│ 	case ls² of {C h³ t⁴ => append_₀(nrev_₀(t⁴), [C h³ [N]]) | N  => [N]}: 93
//│ ------------------
//│ case ls² of {C h³ t⁴ => append_₀(nrev_₀(t⁴), [C h³ [N]]) | N  => [N]}: 93 --->
//│ 	[C f¹(h⁵) map_₀(f¹, t⁶)]: 155
//│ 	[N]: 156
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ t_₀(4)
//│ def t_₀(n²) = 
//│ 	nrev_₀(map_₀((fun x² -> (x² + 1)), primId⁰(fromEnumTo_₀(1, n²))))
//│ 	where
//│ 	def fromEnumTo_₀(a², b²) = 
//│ 		if (a² <= b²) then [C a² fromEnumTo_₀((a² + 1), b²)] else [N]
//│ 	def map_₀(f², ls⁴) = 
//│ 		case ls⁴ of {
//│ 			C h⁵ t⁶ => 
//│ 				let t⁷ = map_₀(f², t⁶)
//│ 				in let h⁶ = f²(h⁵)
//│ 				in (fun _lh_dummy⁰ -> append_₀(nrev_₀(t⁷), [C h⁶ [N]]))
//│ 			| N  => (fun _lh_dummy¹ -> [N])}
//│ 	def nrev_₀(ls⁵) = 
//│ 		ls⁵(99)
//│ 		where
//│ 		def append_₀(xs², ys²) = 
//│ 			case xs² of {
//│ 				N  => ys²
//│ 				| C h⁴ t⁵ => [C h⁴ append_₀(t⁵, ys²)]}
//│ <<<<<<< after fusion <<<<<<<
