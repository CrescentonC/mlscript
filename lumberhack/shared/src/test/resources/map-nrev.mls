:NewParser
:ParseOnly


// WRONG: no fusion done, even after adding `idList`
:lhEval
fun fromEnumTo(a, b) = if a <= b then C(a, fromEnumTo(a + 1, b)) else N
fun append(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, append(t, ys))
fun nrev(ls) = if ls is
  C(h, t) then append(nrev(t), C(h, N))
  N then N
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
map(x => x + 1, nrev(primId(fromEnumTo(1, 4))))
//│ |#fun| |fromEnumTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |fromEnumTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|←|↵|#fun| |nrev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |append|(|nrev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|map|(|x| |=>| |x| |+| |1|,| |nrev|(|primId|(|fromEnumTo|(|1|,| |4|)|)|)|)|
//│ Parsed: {fun fromEnumTo = a, b, => if (<= (a,) (b,)) then C (a, fromEnumTo (+ (a,) (1,), b,),) else N; fun append = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, append (t, ys,),)›; fun nrev = ls, => if ls is ‹(C (h, t,)) then append (nrev (t,), C (h, N,),); (N) then N›; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; map (x, => + (x,) (1,), nrev (primId (fromEnumTo (1, 4,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^60((fun x⁰ -> (x⁰ + 1)), nrev^68(primId⁰(fromEnumTo^70(1, 4))))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ append^24(t⁰, ys⁰)]}
//│ def fromEnumTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ fromEnumTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls¹) = case ls¹ of {
//│ 	C h² t² => [C f⁰(h²) map^50(f⁰, t²)]
//│ 	| N  => [N]}
//│ def nrev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => append^34(nrev^35(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 5 [C 4 [C 3 [C 2 [N]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ append(t⁰, ys⁰)]: 29 --->
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]}: 30
//│ 	case ls¹ of {C h² t² => [C f⁰(h²) map(f⁰, t²)] | N  => [N]}: 57
//│ [N]: 40 --->
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]}: 30
//│ 	case ls¹ of {C h² t² => [C f⁰(h²) map(f⁰, t²)] | N  => [N]}: 57
//│ [C h¹ [N]]: 41 --->
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]}: 30
//│ 	case ls¹ of {C h² t² => [C f⁰(h²) map(f⁰, t²)] | N  => [N]}: 57
//│ [N]: 43 --->
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]}: 30
//│ 	case ls¹ of {C h² t² => [C f⁰(h²) map(f⁰, t²)] | N  => [N]}: 57
//│ ------------------
//│ case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]}: 30 --->
//│ 	[C h⁰ append(t⁰, ys⁰)]: 29
//│ 	[N]: 40
//│ 	[C h¹ [N]]: 41
//│ 	[N]: 43
//│ case ls¹ of {C h² t² => [C f⁰(h²) map(f⁰, t²)] | N  => [N]}: 57 --->
//│ 	[C h⁰ append(t⁰, ys⁰)]: 29
//│ 	[N]: 40
//│ 	[C h¹ [N]]: 41
//│ 	[N]: 43
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map((fun x¹ -> (x¹ + 1)), nrev(primId⁰(fromEnumTo(1, 4))))
//│ def append(xs¹, ys¹) = case xs¹ of {
//│ 	N  => ys¹
//│ 	| C h⁰ t⁰ => [C h⁰ append(t⁰, ys¹)]}
//│ def fromEnumTo(a¹, b¹) = if (a¹ <= b¹) then [C a¹ fromEnumTo((a¹ + 1), b¹)] else [N]
//│ def map(f¹, ls³) = case ls³ of {
//│ 	C h² t² => [C f¹(h²) map(f¹, t²)]
//│ 	| N  => [N]}
//│ def nrev(ls²) = case ls² of {
//│ 	C h¹ t¹ => append(nrev(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 5 [C 4 [C 3 [C 2 [N]]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ map((fun x⁰ -> (x⁰ + 1)), nrev(primId⁰(fromEnumTo(1, 4))))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]}
//│ def fromEnumTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ fromEnumTo((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls¹) = case ls¹ of {
//│ 	C h² t² => [C f⁰(h²) map(f⁰, t²)]
//│ 	| N  => [N]}
//│ def nrev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => append(nrev(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ map((fun x⁰ -> (x⁰ + 1)), nrev(primId⁰(fromEnumTo(1, 4))))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]}
//│ def fromEnumTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ fromEnumTo((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls¹) = case ls¹ of {
//│ 	C h² t² => [C f⁰(h²) map(f⁰, t²)]
//│ 	| N  => [N]}
//│ def nrev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => append(nrev(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<< after floating out <<<<<<<


// CORRECT: can get some simple fusion done
fun fromEnumTo(a, b) = if a <= b then C(a, fromEnumTo(a + 1, b)) else N
fun append(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, append(t, ys))
fun nrev(ls) = if ls is
  C(h, t) then append(nrev(t), C(h, N))
  N then N
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
nrev(map(x => x + 1, primId(fromEnumTo(1, 6))))
//│ |#fun| |fromEnumTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |fromEnumTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|←|↵|#fun| |nrev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |append|(|nrev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|nrev|(|map|(|x| |=>| |x| |+| |1|,| |primId|(|fromEnumTo|(|1|,| |6|)|)|)|)|
//│ Parsed: {fun fromEnumTo = a, b, => if (<= (a,) (b,)) then C (a, fromEnumTo (+ (a,) (1,), b,),) else N; fun append = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, append (t, ys,),)›; fun nrev = ls, => if ls is ‹(C (h, t,)) then append (nrev (t,), C (h, N,),); (N) then N›; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; nrev (map (x, => + (x,) (1,), primId (fromEnumTo (1, 6,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ nrev^60(map^61((fun x⁰ -> (x⁰ + 1)), primId⁰(fromEnumTo^70(1, 6))))
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ append^24(t⁰, ys⁰)]}
//│ def fromEnumTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ fromEnumTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls¹) = case ls¹ of {
//│ 	C h² t² => [C f⁰(h²) map^50(f⁰, t²)]
//│ 	| N  => [N]}
//│ def nrev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t¹ => append^34(nrev^35(t¹), [C h¹ [N]])
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ append(t⁰, ys⁰)]: 29 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]}: 30
//│ [N]: 40 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]}: 30
//│ [C h¹ [N]]: 41 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]}: 30
//│ [N]: 43 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]}: 30
//│ [C f⁰(h²) map(f⁰, t²)]: 55 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(nrev(t¹), [C h¹ [N]]) | N  => [N]}: 44
//│ [N]: 56 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(nrev(t¹), [C h¹ [N]]) | N  => [N]}: 44
//│ ------------------
//│ case xs⁰ of {N  => ys⁰ | C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]}: 30 --->
//│ 	[C h⁰ append(t⁰, ys⁰)]: 29
//│ 	[N]: 40
//│ 	[C h¹ [N]]: 41
//│ 	[N]: 43
//│ case ls⁰ of {C h¹ t¹ => append(nrev(t¹), [C h¹ [N]]) | N  => [N]}: 44 --->
//│ 	[C f⁰(h²) map(f⁰, t²)]: 55
//│ 	[N]: 56
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h²) map(f⁰, t²)]: 55 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(nrev(t¹), [C h¹ [N]]) | N  => [N]}: 44
//│ [N]: 56 --->
//│ 	case ls⁰ of {C h¹ t¹ => append(nrev(t¹), [C h¹ [N]]) | N  => [N]}: 44
//│ ------------------
//│ case ls⁰ of {C h¹ t¹ => append(nrev(t¹), [C h¹ [N]]) | N  => [N]}: 44 --->
//│ 	[C f⁰(h²) map(f⁰, t²)]: 55
//│ 	[N]: 56
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ nrev(map((fun x¹ -> (x¹ + 1)), primId⁰(fromEnumTo(1, 6))))
//│ def append(xs¹, ys¹) = case xs¹ of {
//│ 	N  => ys¹
//│ 	| C h⁰ t⁰ => [C h⁰ append(t⁰, ys¹)]}
//│ def fromEnumTo(a¹, b¹) = if (a¹ <= b¹) then [C a¹ fromEnumTo((a¹ + 1), b¹)] else [N]
//│ def map(f¹, ls³) = case ls³ of {
//│ 	C h² t² => 
//│ 		let t³ = map(f¹, t²)
//│ 		in let h³ = f¹(h²)
//│ 		in (fun _lh_dummy⁰ -> append(nrev(t³), [C h³ [N]]))
//│ 	| N  => (fun _lh_dummy¹ -> [N])}
//│ def nrev(ls²) = ls²(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ nrev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ map -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ map((fun x⁰ -> (x⁰ + 1)), primId⁰(fromEnumTo(1, 6)), 99)
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]}
//│ def fromEnumTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ fromEnumTo((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => 
//│ 		let t² = map(f⁰, t¹)
//│ 		in let h² = f⁰(h¹)
//│ 		in (fun _lh_dummy⁰ -> append(t²(99), [C h² [N]]))
//│ 	| N  => (fun _lh_dummy¹ -> [N])}
//│ def nrev(ls⁰) = ls⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ map((fun x⁰ -> (x⁰ + 1)), primId⁰(fromEnumTo(1, 6)), 99)
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t⁰ => [C h⁰ append(t⁰, ys⁰)]}
//│ def fromEnumTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ fromEnumTo((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls¹, _lh_popOutId_0⁰) = case ls¹ of {
//│ 	C h¹ t¹ => 
//│ 		let t² = map(f⁰, t¹)
//│ 		in let h² = f⁰(h¹)
//│ 		in append(t²(99), [C h² [N]])
//│ 	| N  => [N]}
//│ def nrev(ls⁰) = ls⁰(99)
//│ <<<<<<< after floating out <<<<<<<


// WRONG: just adding another call the knot tier will not tie the ideal knots!
fun fromEnumTo(a, b) = if a <= b then C(a, fromEnumTo(a + 1, b)) else N
fun append(xs, ys) = if xs is
  N then ys
  C(h, t) then C(h, append(t, ys))
fun nrev(ls) = if ls is
  C(h, t) then append(nrev(t), C(h, N))
  N then N
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun t(n) = nrev(map(x => x + 1, primId(fromEnumTo(1, n))))
t(4)
//│ |#fun| |fromEnumTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |fromEnumTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |append|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |ys|↵|C|(|h|,| |t|)| |#then| |C|(|h|,| |append|(|t|,| |ys|)|)|←|↵|#fun| |nrev|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |append|(|nrev|(|t|)|,| |C|(|h|,| |N|)|)|↵|N| |#then| |N|←|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |t|(|n|)| |#=| |nrev|(|map|(|x| |=>| |x| |+| |1|,| |primId|(|fromEnumTo|(|1|,| |n|)|)|)|)|↵|t|(|4|)|
//│ Parsed: {fun fromEnumTo = a, b, => if (<= (a,) (b,)) then C (a, fromEnumTo (+ (a,) (1,), b,),) else N; fun append = xs, ys, => if xs is ‹(N) then ys; (C (h, t,)) then C (h, append (t, ys,),)›; fun nrev = ls, => if ls is ‹(C (h, t,)) then append (nrev (t,), C (h, N,),); (N) then N›; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun t = n, => nrev (map (x, => + (x,) (1,), primId (fromEnumTo (1, n,),),),); t (4,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ t^79(4)
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h⁰ t¹ => [C h⁰ append^24(t¹, ys⁰)]}
//│ def fromEnumTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ fromEnumTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls¹) = case ls¹ of {
//│ 	C h² t³ => [C f⁰(h²) map^50(f⁰, t³)]
//│ 	| N  => [N]}
//│ def nrev(ls⁰) = case ls⁰ of {
//│ 	C h¹ t² => append^34(nrev^35(t²), [C h¹ [N]])
//│ 	| N  => [N]}
//│ def t(n⁰) = nrev^60(map^61((fun x⁰ -> (x⁰ + 1)), primId⁰(fromEnumTo^70(1, n⁰))))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ append(t¹, ys⁰)]: 29 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t¹ => [C h⁰ append(t¹, ys⁰)]}: 30
//│ [N]: 40 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t¹ => [C h⁰ append(t¹, ys⁰)]}: 30
//│ [C h¹ [N]]: 41 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t¹ => [C h⁰ append(t¹, ys⁰)]}: 30
//│ [N]: 43 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => ys⁰ | C h⁰ t¹ => [C h⁰ append(t¹, ys⁰)]}: 30
//│ [C f⁰(h²) map(f⁰, t³)]: 55 --->
//│ 	case ls⁰ of {C h¹ t² => append(nrev(t²), [C h¹ [N]]) | N  => [N]}: 44
//│ [N]: 56 --->
//│ 	case ls⁰ of {C h¹ t² => append(nrev(t²), [C h¹ [N]]) | N  => [N]}: 44
//│ ------------------
//│ case xs⁰ of {N  => ys⁰ | C h⁰ t¹ => [C h⁰ append(t¹, ys⁰)]}: 30 --->
//│ 	[C h⁰ append(t¹, ys⁰)]: 29
//│ 	[N]: 40
//│ 	[C h¹ [N]]: 41
//│ 	[N]: 43
//│ case ls⁰ of {C h¹ t² => append(nrev(t²), [C h¹ [N]]) | N  => [N]}: 44 --->
//│ 	[C f⁰(h²) map(f⁰, t³)]: 55
//│ 	[N]: 56
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h²) map(f⁰, t³)]: 55 --->
//│ 	case ls⁰ of {C h¹ t² => append(nrev(t²), [C h¹ [N]]) | N  => [N]}: 44
//│ [N]: 56 --->
//│ 	case ls⁰ of {C h¹ t² => append(nrev(t²), [C h¹ [N]]) | N  => [N]}: 44
//│ ------------------
//│ case ls⁰ of {C h¹ t² => append(nrev(t²), [C h¹ [N]]) | N  => [N]}: 44 --->
//│ 	[C f⁰(h²) map(f⁰, t³)]: 55
//│ 	[N]: 56
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ t(4)
//│ def append(xs¹, ys¹) = case xs¹ of {
//│ 	N  => ys¹
//│ 	| C h⁰ t¹ => [C h⁰ append(t¹, ys¹)]}
//│ def fromEnumTo(a¹, b¹) = if (a¹ <= b¹) then [C a¹ fromEnumTo((a¹ + 1), b¹)] else [N]
//│ def map(f¹, ls²) = case ls² of {
//│ 	C h² t³ => 
//│ 		let t⁴ = map(f¹, t³)
//│ 		in let h³ = f¹(h²)
//│ 		in (fun _lh_dummy⁰ -> append(nrev(t⁴), [C h³ [N]]))
//│ 	| N  => (fun _lh_dummy¹ -> [N])}
//│ def nrev(ls³) = ls³(99)
//│ def t(n¹) = nrev(map((fun x¹ -> (x¹ + 1)), primId⁰(fromEnumTo(1, n¹))))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ nrev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ map -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ t(4)
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h² t³ => [C h² append(t³, ys⁰)]}
//│ def fromEnumTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ fromEnumTo((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t¹ => 
//│ 		let t² = map(f⁰, t¹)
//│ 		in let h¹ = f⁰(h⁰)
//│ 		in (fun _lh_dummy⁰ -> append(t²(99), [C h¹ [N]]))
//│ 	| N  => (fun _lh_dummy¹ -> [N])}
//│ def nrev(ls¹) = ls¹(99)
//│ def t(n⁰) = map((fun x⁰ -> (x⁰ + 1)), primId⁰(fromEnumTo(1, n⁰)), 99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ t(4)
//│ def append(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => ys⁰
//│ 	| C h² t³ => [C h² append(t³, ys⁰)]}
//│ def fromEnumTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ fromEnumTo((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰, _lh_popOutId_0⁰) = case ls⁰ of {
//│ 	C h⁰ t¹ => 
//│ 		let t² = map(f⁰, t¹)
//│ 		in let h¹ = f⁰(h⁰)
//│ 		in append(t²(99), [C h¹ [N]])
//│ 	| N  => [N]}
//│ def nrev(ls¹) = ls¹(99)
//│ def t(n⁰) = map((fun x⁰ -> (x⁰ + 1)), primId⁰(fromEnumTo(1, n⁰)), 99)
//│ <<<<<<< after floating out <<<<<<<
