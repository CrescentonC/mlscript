:NewParser
:ParseOnly


fun inter(xs) = if xs is
    N then ys => ys
    C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, N))
let rec l2 = N
inter(l1, l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#let| |#rec| |l2| |#=| |N|↵|inter|(|l1|,| |l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, N,),); let rec l2 = N; inter (l1, l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter^20 l1^21) l2^23)
//│ def inter = (fun xs:9 -> case xs:9 of {
//│ 	N => (fun ys:10 -> ys:10)
//│ 	| C h:11 t:12 => (fun ys:13 -> [C h:11 ((inter^5 ys:13) t:12)])})
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [N]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 't:12
//│ 	[-l1^21 · +inter^20 · +inter^5 · +inter^5 · +inter^5 · +inter^5 · +inter^5 · +inter^5]  --->  [-l1^21 · +inter^20 · +inter^5 · +inter^5 · +inter^5 · +inter^5]
//│ NoProd <: 'ys:13
//│ 	[-l2^23 · +inter^20 · +inter^5 · +inter^5 · +inter^5 · +inter^5]  --->  [-l2^23 · +inter^20 · +inter^5 · +inter^5]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^20]
//│ 	[inter^20 · inter^5]
//│ 		[inter^20 · inter^5 · inter^5]
//│ 			[inter^20 · inter^5 · inter^5 · inter^5]
//│ 				[inter^20 · inter^5 · inter^5 · inter^5 · inter^5] ---> [inter^20 · inter^5 · inter^5] (only one)
//│ [l1^21]
//│ [l2^23]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N] --->
//│ 	case xs:20 of {N => (fun ys:21 -> ys:21) | C h:22 t:23 => (fun ys:24 -> [C h:22 ((inter₃ ys:24) t:23)])}
//│ [C 2 [N]] --->
//│ 	case xs:20 of {N => (fun ys:21 -> ys:21) | C h:22 t:23 => (fun ys:24 -> [C h:22 ((inter₃ ys:24) t:23)])}
//│ [C 1 [C 2 [N]]] --->
//│ 	case xs:30 of {N => (fun ys:31 -> ys:31) | C h:32 t:33 => (fun ys:34 -> [C h:32 ((inter₁ ys:34) t:33)])}
//│ [N] --->
//│ 	case xs:35 of {N => (fun ys:36 -> ys:36) | C h:37 t:38 => (fun ys:39 -> [C h:37 ((inter₂ ys:39) t:38)])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((inter₀ l1₀) l2₀)
//│ def inter₀ = {
//│ 	(fun xs:30 -> xs:30)
//│ 		where
//│ 	def inter₁ = {
//│ 		(fun xs:35 -> xs:35)
//│ 			where
//│ 		def inter₂ = {
//│ 			(fun xs:20 -> xs:20)
//│ 				where
//│ 			def inter₃ = {
//│ 				(fun xs:25 -> case xs:25 of {
//│ 					N => (fun ys:26 -> ys:26)
//│ 					| C h:27 t:28 => (fun ys:29 -> [C h:27 ((inter₂ ys:29) t:28)])})
//│ 			}
//│ 		}
//│ 	}
//│ }
//│ def l2₀ = {
//│ 	(fun ys:36 -> ys:36)
//│ }
//│ def l1₀ = {
//│ 	let h:32 = 1
//│ 	in let t:33 = 	
//│ 		let h:22 = 2
//│ 		in let t:23 = (fun ys:21 -> ys:21)
//│ 		in (fun ys:24 -> [C h:22 ((inter₃ ys:24) t:23)])
//│ 	in (fun ys:34 -> [C h:32 ((inter₁ ys:34) t:33)])
//│ }
//│ <<<<<<< after fusion <<<<<<<


fun inter(xs) = if xs is
    N then ys => ys
    C(h, t) then ys => C(h, inter(ys)(t))
fun l1(x) = C(1, C(2, l1(add(x, 1))))
let rec l2 = C(9, C(8, l2))
inter(l1(0))(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#fun| |l1|(|x|)| |#=| |C|(|1|,| |C|(|2|,| |l1|(|add|(|x|,| |1|)|)|)|)|↵|#let| |#rec| |l2| |#=| |C|(|9|,| |C|(|8|,| |l2|)|)|↵|inter|(|l1|(|0|)|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; fun l1 = x, => C (1, C (2, l1 (add (x, 1,),),),); let rec l2 = C (9, C (8, l2,),); inter (l1 (0,),) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter^31 (l1^32 0)) l2^36)
//│ def inter = (fun xs:9 -> case xs:9 of {
//│ 	N => (fun ys:10 -> ys:10)
//│ 	| C h:11 t:12 => (fun ys:13 -> [C h:11 ((inter^5 ys:13) t:12)])})
//│ def l1 = (fun x:14 -> [C 1 [C 2 (l1^16 ((add:4 x:14) 1))]])
//│ def l2 = [C 9 [C 8 l2^28]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C(Int, '22_callres) <: 'ys:13
//│ 	[-l1^16 · -l1^32 · +inter^31 · +inter^5 · +inter^5 · +inter^5 · +inter^5 · +inter^5]  --->  [-l1^32 · +inter^31 · +inter^5]
//│ C(Int, 'l2:8) <: 'ys:13
//│ 	[-l2^28 · -l2^36 · +inter^31 · +inter^5 · +inter^5 · +inter^5 · +inter^5 · +inter^5 · +inter^5]  --->  [-l2^36 · +inter^31 · +inter^5 · +inter^5]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^31]
//│ 	[inter^31 · inter^5]
//│ 		[inter^31 · inter^5 · inter^5]
//│ 			[inter^31 · inter^5 · inter^5 · inter^5]
//│ 				[inter^31 · inter^5 · inter^5 · inter^5 · inter^5]
//│ 					[inter^31 · inter^5 · inter^5 · inter^5 · inter^5 · inter^5] ---> [inter^31 · inter^5] (only one)
//│ [l1^32]
//│ 	[l1^32 · l1^16] ---> [l1^32] (only one)
//│ [l2^36]
//│ 	[l2^36 · l2^28] ---> [l2^36] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 8 l2₀] --->
//│ 	case xs:38 of {N => (fun ys:39 -> ys:39) | C h:40 t:41 => (fun ys:42 -> [C h:40 ((inter₄ ys:42) t:41)])}
//│ [C 9 [C 8 l2₀]] --->
//│ 	case xs:23 of {N => (fun ys:24 -> ys:24) | C h:25 t:26 => (fun ys:27 -> [C h:25 ((inter₂ ys:27) t:26)])}
//│ [C 2 (l1₀ ((add:4 x:22) 1))] --->
//│ 	case xs:28 of {N => (fun ys:29 -> ys:29) | C h:30 t:31 => (fun ys:32 -> [C h:30 ((inter₃ ys:32) t:31)])}
//│ [C 1 [C 2 (l1₀ ((add:4 x:22) 1))]] --->
//│ 	case xs:33 of {N => (fun ys:34 -> ys:34) | C h:35 t:36 => (fun ys:37 -> [C h:35 ((inter₁ ys:37) t:36)])}
//│ 	case xs:43 of {N => (fun ys:44 -> ys:44) | C h:45 t:46 => (fun ys:47 -> [C h:45 ((inter₁ ys:47) t:46)])}
//│ 	 MORE THAN ONE MATCH EXPR
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((inter₀ (l1₀ 0)) l2₀)
//│ def l2₀ = {
//│ 	let h:25 = 9
//│ 	in let t:26 = 	
//│ 		let h:40 = 8
//│ 		in let t:41 = l2₀
//│ 		in (fun ys:42 -> [C h:40 ((inter₄ ys:42) t:41)])
//│ 	in (fun ys:27 -> [C h:25 ((inter₂ ys:27) t:26)])
//│ }
//│ def l1₀ = {
//│ 	(fun x:22 -> 
//│ 		let h:45 = 1
//│ 		in let t:46 = 	
//│ 			let h:30 = 2
//│ 			in let t:31 = (l1₀ ((add:4 x:22) 1))
//│ 			in (fun ys:32 -> [C h:30 ((inter₃ ys:32) t:31)])
//│ 		in (fun ys:47 -> [C h:45 ((inter₁ ys:47) t:46)]))
//│ }
//│ def inter₀ = {
//│ 	(fun xs:43 -> xs:43)
//│ 		where
//│ 	def inter₁ = {
//│ 		(fun xs:23 -> xs:23)
//│ 			where
//│ 		def inter₂ = {
//│ 			(fun xs:28 -> xs:28)
//│ 				where
//│ 			def inter₃ = {
//│ 				(fun xs:38 -> xs:38)
//│ 					where
//│ 				def inter₄ = {
//│ 					(fun xs:33 -> case xs:33 of {
//│ 						N => (fun ys:34 -> ys:34)
//│ 						| C h:35 t:36 => (fun ys:37 -> [C h:35 ((inter₁ ys:37) t:36)])})
//│ 				}
//│ 			}
//│ 		}
//│ 	}
//│ }
//│ <<<<<<< after fusion <<<<<<<




// NOTE: only head is handled
fun map(ls) = if ls is
    C(h, t) then f => C(f(h), map(t)(f))
    N then f => N
let l = C(K, N)
map(l)(
    x => if x is
        K then T
)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#let| |l| |#=| |C|(|K|,| |N|)|↵|map|(|l|)|(|→|x| |=>| |#if| |x| |is|→|K| |#then| |T|←|←|↵|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then f, => C (f (h,), map (t,) (f,),); (N) then f, => N›; let l = C (K, N,); map (l,) (x, => if x is ‹(K) then T›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((map^19 l^20) (fun x:13 -> case x:13 of {
//│ 	K => [T]}))
//│ def l = [C [K] [N]]
//│ def map = (fun ls:8 -> case ls:8 of {
//│ 	C h:9 t:10 => (fun f:11 -> [C (f:11 h:9) ((map^5 t:10) f:11)])
//│ 	| N => (fun f:12 -> [N])})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 't:10
//│ 	[-l^20 · +map^19 · +map^5 · +map^5]  --->  [-l^20 · +map^19 · +map^5]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^20]
//│ [map^19]
//│ 	[map^19 · map^5]
//│ 		[map^19 · map^5 · map^5] ---> [map^19 · map^5] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K] --->
//│ 	case x:27 of {K => [T]}
//│ [N] --->
//│ 	case ls:22 of {C h:23 t:24 => (fun f:25 -> [C (f:25 h:23) ((map₁ t:24) f:25)]) | N => (fun f:26 -> [N])}
//│ [C [K] [N]] --->
//│ 	case ls:17 of {C h:18 t:19 => (fun f:20 -> [C (f:20 h:18) ((map₁ t:19) f:20)]) | N => (fun f:21 -> [N])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((map₀ l₀) (fun x:27 -> x:27))
//│ def l₀ = {
//│ 	let h:18 = [T]
//│ 	in let t:19 = (fun f:26 -> [N])
//│ 	in (fun f:20 -> [C (f:20 h:18) ((map₁ t:19) f:20)])
//│ }
//│ def map₀ = {
//│ 	(fun ls:17 -> ls:17)
//│ 		where
//│ 	def map₁ = {
//│ 		(fun ls:22 -> ls:22)
//│ 	}
//│ }
//│ <<<<<<< after fusion <<<<<<<



fun map(ls) = if ls is
    C(h, t) then C(
        (if h is
            K then T
            KK then TT
            KKKK then TTTT
        ),
        map(t)
    )
    N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›, ')', map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^21 l^22)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun ls:8 -> case ls:8 of {
//│ 	C h:9 t:10 => [C case h:9 of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} (map^7 t:10)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 't:10
//│ 	[-l^22 · +map^21 · +map^7 · +map^7 · +map^7 · +map^7]  --->  [-l^22 · +map^21 · +map^7 · +map^7 · +map^7]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^22]
//│ [map^21]
//│ 	[map^21 · map^7]
//│ 		[map^21 · map^7 · map^7]
//│ 			[map^21 · map^7 · map^7 · map^7]
//│ 				[map^21 · map^7 · map^7 · map^7 · map^7] ---> [map^21 · map^7 · map^7 · map^7] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K] --->
//│ 	case h:23 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ [KK] --->
//│ 	case h:20 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ [KKKK] --->
//│ 	case h:26 of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ [N] --->
//│ 	case ls:16 of {C h:17 t:18 => [C case h:17 of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₃ t:18)] | N => [N]}
//│ [C [KKKK] [N]] --->
//│ 	case ls:25 of {C h:26 t:27 => [C case h:26 of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₃ t:27)] | N => [N]}
//│ [C [KK] [C [KKKK] [N]]] --->
//│ 	case ls:19 of {C h:20 t:21 => [C case h:20 of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₂ t:21)] | N => [N]}
//│ [C [K] [C [KK] [C [KKKK] [N]]]] --->
//│ 	case ls:22 of {C h:23 t:24 => [C case h:23 of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₁ t:24)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = {
//│ 	let h:23 = [T]
//│ 	in let t:24 = 	
//│ 		let h:20 = [TT]
//│ 		in let t:21 = 	
//│ 			let h:26 = [TTTT]
//│ 			in let t:27 = [N]
//│ 			in [C h:26 (map₃ t:27)]
//│ 		in [C h:20 (map₂ t:21)]
//│ 	in [C h:23 (map₁ t:24)]
//│ }
//│ def map₀ = {
//│ 	(fun ls:22 -> ls:22)
//│ 		where
//│ 	def map₁ = {
//│ 		(fun ls:19 -> ls:19)
//│ 			where
//│ 		def map₂ = {
//│ 			(fun ls:25 -> ls:25)
//│ 				where
//│ 			def map₃ = {
//│ 				(fun ls:16 -> ls:16)
//│ 			}
//│ 		}
//│ 	}
//│ }
//│ <<<<<<< after fusion <<<<<<<



// NOTE: consumer `c` is used twice in its body, but it fine here
let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
    T(n, l, r) then T(
        (if n is
            K then KK
            N then NN
        ),
        c(l),
        c(r)
    )
    L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^28 t^29)
//│ def aa = [T [N] [L] [L]]
//│ def bb = [T [N] [L] [L]]
//│ def c = (fun x:10 -> case x:10 of {
//│ 	T n:11 l:12 r:13 => [T case n:11 of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^18 l:12) (c^21 r:13)]
//│ 	| L => [LL]})
//│ def t = [T [K] aa^10 bb^11]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ NoProd <: 'l:12
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^18 · +c^18]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^18]
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^21 · +c^18]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^21]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^21 · +c^18]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^21]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^18 · +c^18]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^18]
//│ NoProd <: 'r:13
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^21 · +c^21]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^21]
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^18 · +c^21]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^18]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^21 · +c^21]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^21]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^18 · +c^21]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^18]
//│ NoProd <: 'x:10
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^21 · +c^21 · +c^18]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^21 · +c^21]
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^18 · +c^18 · +c^21]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^18 · +c^18]
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^21 · +c^18 · +c^21]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^21 · +c^18]
//│ 	[-aa^10 · -t^29 · +c^28 · +c^18 · +c^18 · +c^21 · +c^18]  --->  [-aa^10 · -t^29 · +c^28 · +c^18 · +c^18 · +c^21]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^18 · +c^18 · +c^21]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^18 · +c^18]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^21 · +c^21 · +c^18]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^21 · +c^21]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^21 · +c^18 · +c^21]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^21 · +c^18]
//│ 	[-bb^11 · -t^29 · +c^28 · +c^21 · +c^18 · +c^21 · +c^18]  --->  [-bb^11 · -t^29 · +c^28 · +c^21 · +c^18 · +c^21]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^28]
//│ 	[c^28 · c^21]
//│ 		[c^28 · c^21 · c^21]
//│ 			[c^28 · c^21 · c^21 · c^21] ---> [c^28 · c^21 · c^21] (only one)
//│ 			[c^28 · c^21 · c^21 · c^18] ---> [c^28 · c^21 · c^21] (only one)
//│ 		[c^28 · c^21 · c^18]
//│ 			[c^28 · c^21 · c^18 · c^21] ---> [c^28 · c^21 · c^18] (only one)
//│ 			[c^28 · c^21 · c^18 · c^18] ---> [c^28 · c^21 · c^18] (only one)
//│ 	[c^28 · c^18]
//│ 		[c^28 · c^18 · c^21]
//│ 			[c^28 · c^18 · c^21 · c^21] ---> [c^28 · c^18 · c^21] (only one)
//│ 			[c^28 · c^18 · c^21 · c^18] ---> [c^28 · c^18 · c^21] (only one)
//│ 		[c^28 · c^18 · c^18]
//│ 			[c^28 · c^18 · c^18 · c^21] ---> [c^28 · c^18 · c^18] (only one)
//│ 			[c^28 · c^18 · c^18 · c^18] ---> [c^28 · c^18 · c^18] (only one)
//│ [t^29]
//│ 	[t^29 · bb^11]
//│ 	[t^29 · aa^10]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K] --->
//│ 	case n:41 of {K => [KK] | N => [NN]}
//│ [T [K] aa₀ bb₀] --->
//│ 	case x:40 of {T n:41 l:42 r:43 => [T case n:41 of {K => [KK] | N => [NN]} (c₄ l:42) (c₁ r:43)] | L => [LL]}
//│ [N] --->
//│ 	case n:37 of {K => [KK] | N => [NN]}
//│ [L] --->
//│ 	case x:28 of {T n:29 l:30 r:31 => [T case n:29 of {K => [KK] | N => [NN]} (c₃ l:30) (c₃ r:31)] | L => [LL]}
//│ [L] --->
//│ 	case x:32 of {T n:33 l:34 r:35 => [T case n:33 of {K => [KK] | N => [NN]} (c₂ l:34) (c₂ r:35)] | L => [LL]}
//│ [T [N] [L] [L]] --->
//│ 	case x:36 of {T n:37 l:38 r:39 => [T case n:37 of {K => [KK] | N => [NN]} (c₃ l:38) (c₂ r:39)] | L => [LL]}
//│ [N] --->
//│ 	case n:49 of {K => [KK] | N => [NN]}
//│ [L] --->
//│ 	case x:24 of {T n:25 l:26 r:27 => [T case n:25 of {K => [KK] | N => [NN]} (c₆ l:26) (c₆ r:27)] | L => [LL]}
//│ [L] --->
//│ 	case x:44 of {T n:45 l:46 r:47 => [T case n:45 of {K => [KK] | N => [NN]} (c₅ l:46) (c₅ r:47)] | L => [LL]}
//│ [T [N] [L] [L]] --->
//│ 	case x:48 of {T n:49 l:50 r:51 => [T case n:49 of {K => [KK] | N => [NN]} (c₆ l:50) (c₅ r:51)] | L => [LL]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ t₀)
//│ def t₀ = {
//│ 	let n:41 = [KK]
//│ 	in let l:42 = aa₀
//│ 	in let r:43 = bb₀
//│ 	in [T n:41 (c₄ l:42) (c₁ r:43)]
//│ 		where
//│ 	def bb₀ = {
//│ 		let n:37 = [NN]
//│ 		in let l:38 = [LL]
//│ 		in let r:39 = [LL]
//│ 		in [T n:37 (c₃ l:38) (c₂ r:39)]
//│ 	}
//│ 	def aa₀ = {
//│ 		let n:49 = [NN]
//│ 		in let l:50 = [LL]
//│ 		in let r:51 = [LL]
//│ 		in [T n:49 (c₆ l:50) (c₅ r:51)]
//│ 	}
//│ }
//│ def c₀ = {
//│ 	(fun x:40 -> x:40)
//│ 		where
//│ 	def c₁ = {
//│ 		(fun x:36 -> x:36)
//│ 			where
//│ 		def c₂ = {
//│ 			(fun x:32 -> x:32)
//│ 		}
//│ 		def c₃ = {
//│ 			(fun x:28 -> x:28)
//│ 		}
//│ 	}
//│ 	def c₄ = {
//│ 		(fun x:48 -> x:48)
//│ 			where
//│ 		def c₅ = {
//│ 			(fun x:44 -> x:44)
//│ 		}
//│ 		def c₆ = {
//│ 			(fun x:24 -> x:24)
//│ 		}
//│ 	}
//│ }
//│ <<<<<<< after fusion <<<<<<<




fun sum(ls) = if ls is
    C(h, t) then S(N, sum(t))
    N then N
fun mapa(lsa) = if lsa is
    C(ha, ta) then C(primitive(ha), mapa(ta))
    N then N
fun mapb(lsb) = if lsb is
    C(hb, tb) then C(primitive(hb), mapb(tb))
    N then N
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|↵|N| |#then| |N|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|↵|N| |#then| |N|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),); (N) then N›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),); (N) then N›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),); (N) then N›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (sum^32 (mapa^33 (mapb^34 primitive:3)))
//│ def mapa = (fun lsa:12 -> case lsa:12 of {
//│ 	C ha:13 ta:14 => [C (primitive:3 ha:13) (mapa^14 ta:14)]
//│ 	| N => [N]})
//│ def mapb = (fun lsb:15 -> case lsb:15 of {
//│ 	C hb:16 tb:17 => [C (primitive:3 hb:16) (mapb^25 tb:17)]
//│ 	| N => [N]})
//│ def sum = (fun ls:9 -> case ls:9 of {
//│ 	C h:10 t:11 => [S [N] (sum^3 t:11)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('13_callres, '16_callres) <: 'ls:9
//│ 	[-mapa^14 · -mapa^14 · -mapa^33 · +sum^32 · +sum^3 · +sum^3]  --->  [-mapa^14 · -mapa^33 · +sum^32 · +sum^3]
//│ C('24_callres, '27_callres) <: 'lsa:12
//│ 	[-mapb^25 · -mapb^25 · -mapb^34 · +mapa^33 · +mapa^14 · +mapa^14]  --->  [-mapb^25 · -mapb^34 · +mapa^33 · +mapa^14]
//│ NoProd <: 'ls:9
//│ 	[-mapa^33 · +sum^32 · +sum^3 · +sum^3]  --->  [-mapa^33 · +sum^32 · +sum^3]
//│ NoProd <: 't:11
//│ 	[-mapa^14 · -mapa^14 · -mapa^33 · +sum^32 · +sum^3 · +sum^3 · +sum^3]  --->  [-mapa^14 · -mapa^14 · -mapa^33 · +sum^32 · +sum^3 · +sum^3]
//│ 	[-mapa^14 · -mapa^33 · +sum^32 · +sum^3 · +sum^3]  --->  [-mapa^14 · -mapa^33 · +sum^32 · +sum^3]
//│ NoProd <: 'ta:14
//│ 	[-mapb^25 · -mapb^34 · +mapa^33 · +mapa^14 · +mapa^14]  --->  [-mapb^25 · -mapb^34 · +mapa^33 · +mapa^14]
//│ 	[-mapb^25 · -mapb^25 · -mapb^34 · +mapa^33 · +mapa^14 · +mapa^14 · +mapa^14]  --->  [-mapb^25 · -mapb^25 · -mapb^34 · +mapa^33 · +mapa^14 · +mapa^14]
//│ NoProd <: 'lsb:15
//│ 	[+mapb^34 · +mapb^25 · +mapb^25]  --->  [+mapb^34 · +mapb^25]
//│ NoProd <: 'lsa:12
//│ 	[-mapb^34 · +mapa^33 · +mapa^14 · +mapa^14]  --->  [-mapb^34 · +mapa^33 · +mapa^14]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa^33]
//│ 	[mapa^33 · mapa^14]
//│ 		[mapa^33 · mapa^14 · mapa^14] ---> [mapa^33 · mapa^14] (only one)
//│ [mapb^34]
//│ 	[mapb^34 · mapb^25]
//│ 		[mapb^34 · mapb^25 · mapb^25] ---> [mapb^34 · mapb^25] (only one)
//│ [sum^32]
//│ 	[sum^32 · sum^3]
//│ 		[sum^32 · sum^3 · sum^3] ---> [sum^32 · sum^3] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C (primitive:3 ha:25) (mapa₁ ta:26)] --->
//│ 	case ls:30 of {C h:31 t:32 => [S [N] (sum₁ t:32)] | N => [N]}
//│ [N] --->
//│ 	case ls:30 of {C h:31 t:32 => [S [N] (sum₁ t:32)] | N => [N]}
//│ [C (primitive:3 hb:28) (mapb₁ tb:29)] --->
//│ 	case lsa:36 of {C ha:37 ta:38 => [C (primitive:3 ha:37) (mapa₁ ta:38)] | N => [N]}
//│ [N] --->
//│ 	case lsa:36 of {C ha:37 ta:38 => [C (primitive:3 ha:37) (mapa₁ ta:38)] | N => [N]}
//│ [C (primitive:3 hb:34) (mapb₁ tb:35)] --->
//│ 	case lsa:24 of {C ha:25 ta:26 => [C (primitive:3 ha:25) (mapa₁ ta:26)] | N => [N]}
//│ [N] --->
//│ 	case lsa:24 of {C ha:25 ta:26 => [C (primitive:3 ha:25) (mapa₁ ta:26)] | N => [N]}
//│ [C (primitive:3 ha:37) (mapa₁ ta:38)] --->
//│ 	case ls:39 of {C h:40 t:41 => [S [N] (sum₁ t:41)] | N => [N]}
//│ [N] --->
//│ 	case ls:39 of {C h:40 t:41 => [S [N] (sum₁ t:41)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (sum₀ (mapa₀ (mapb₀ primitive:3)))
//│ def mapa₀ = {
//│ 	(fun lsa:36 -> lsa:36)
//│ 		where
//│ 	def mapa₁ = {
//│ 		(fun lsa:24 -> lsa:24)
//│ 	}
//│ }
//│ def sum₀ = {
//│ 	(fun ls:39 -> ls:39)
//│ 		where
//│ 	def sum₁ = {
//│ 		(fun ls:30 -> ls:30)
//│ 	}
//│ }
//│ def mapb₀ = {
//│ 	(fun lsb:27 -> case lsb:27 of {
//│ 		C hb:28 tb:29 => 
//│ 			let ha:37 = (primitive:3 hb:28)
//│ 			in let ta:38 = (mapb₁ tb:29)
//│ 			in let h:40 = (primitive:3 ha:37)
//│ 			in let t:41 = (mapa₁ ta:38)
//│ 			in [S [N] (sum₁ t:41)]
//│ 		| N => [N]})
//│ 		where
//│ 	def mapb₁ = {
//│ 		(fun lsb:33 -> case lsb:33 of {
//│ 			C hb:34 tb:35 => 
//│ 				let ha:25 = (primitive:3 hb:34)
//│ 				in let ta:26 = (mapb₁ tb:35)
//│ 				in let h:31 = (primitive:3 ha:25)
//│ 				in let t:32 = (mapa₁ ta:26)
//│ 				in [S [N] (sum₁ t:32)]
//│ 			| N => [N]})
//│ 	}
//│ }
//│ <<<<<<< after fusion <<<<<<<

fun map(ls) = if ls is
    N then N
    C(hhh, ttt) then C((
        head => if head is 
            T then K
            TT then KK
    )(hhh), map(ttt))
fun last(ys) = if ys is
    N then x => x
    C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
    N then None
    C(hh, tt) then Some(last(tt)(hh))
lastDrive(map(C(T, C(TT, N))))
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|hhh|,| |ttt|)| |#then| |C|(|(|→|head| |=>| |#if| |head| |is| |→|T| |#then| |K|↵|TT| |#then| |KK|←|←|↵|)|(|hhh|)|,| |map|(|ttt|)|)|←|↵|#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|map|(|C|(|T|,| |C|(|TT|,| |N|)|)|)|)|
//│ Parsed: {fun map = ls, => if ls is ‹(N) then N; (C (hhh, ttt,)) then C ('(' head, => if head is ‹(T) then K; (TT) then KK›, ')' (hhh,), map (ttt,),)›; fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (map (C (T, C (TT, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (lastDrive^37 (map^38 [C [T] [C [TT] [N]]]))
//│ def last = (fun ys:13 -> case ys:13 of {
//│ 	N => (fun x:14 -> x:14)
//│ 	| C h:15 t:16 => (fun x:17 -> ((last^19 t:16) h:15))})
//│ def lastDrive = (fun xs:18 -> case xs:18 of {
//│ 	N => [None]
//│ 	| C hh:19 tt:20 => [Some ((last^29 tt:20) hh:19)]})
//│ def map = (fun ls:9 -> case ls:9 of {
//│ 	N => [N]
//│ 	| C hhh:10 ttt:11 => [C ((fun head:12 -> case head:12 of {
//│ 		T => [K]
//│ 		| TT => [KK]}) hhh:10) (map^10 ttt:11)]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> knots >>>>>>>
//│ C('9_callres, '12_callres) <: 'ys:13
//│ 	[-map^10 · -map^10 · -map^38 · +lastDrive^37 · +last^29 · +last^19]  --->  [-map^10 · -map^38 · +lastDrive^37 · +last^29]
//│ NoProd <: 't:16
//│ 	[-map^10 · -map^38 · +lastDrive^37 · +last^29 · +last^19]  --->  [-map^10 · -map^38 · +lastDrive^37 · +last^29]
//│ 	[-map^10 · -map^10 · -map^38 · +lastDrive^37 · +last^29 · +last^19 · +last^19]  --->  [-map^10 · -map^10 · -map^38 · +lastDrive^37 · +last^29 · +last^19]
//│ NoProd <: 'ttt:11
//│ 	[+map^38 · +map^10 · +map^10 · +map^10]  --->  [+map^38 · +map^10 · +map^10]
//│ NoProd <: 'ys:13
//│ 	[-map^38 · +lastDrive^37 · +last^29 · +last^19]  --->  [-map^38 · +lastDrive^37 · +last^29]
//│ <<<<<<< knots <<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive^37]
//│ 	[lastDrive^37 · last^29]
//│ 		[lastDrive^37 · last^29 · last^19] ---> [lastDrive^37 · last^29] (only one)
//│ [map^38]
//│ 	[map^38 · map^10]
//│ 		[map^38 · map^10 · map^10] ---> [map^38 · map^10] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [TT] --->
//│ 	case head:32 of {T => [K] | TT => [KK]}
//│ [N] --->
//│ 	case ls:29 of {N => [N] | C hhh:30 ttt:31 => [C ((fun head:32 -> case head:32 of {T => [K] | TT => [KK]}) hhh:30) (map₁ ttt:31)]}
//│ [C [TT] [N]] --->
//│ 	case ls:29 of {N => [N] | C hhh:30 ttt:31 => [C ((fun head:32 -> case head:32 of {T => [K] | TT => [KK]}) hhh:30) (map₁ ttt:31)]}
//│ [C [T] [C [TT] [N]]] --->
//│ 	case ls:25 of {N => [N] | C hhh:26 ttt:27 => [C ((fun head:28 -> case head:28 of {T => [K] | TT => [KK]}) hhh:26) (map₁ ttt:27)]}
//│ [N] --->
//│ 	case xs:33 of {N => [None] | C hh:34 tt:35 => [Some ((last₀ tt:35) hh:34)]}
//│ [C ((fun head:28 -> case head:28 of {T => [K] | TT => [KK]}) hhh:26) (map₁ ttt:27)] --->
//│ 	case xs:33 of {N => [None] | C hh:34 tt:35 => [Some ((last₀ tt:35) hh:34)]}
//│ [N] --->
//│ 	case ys:36 of {N => (fun x:37 -> x:37) | C h:38 t:39 => (fun x:40 -> ((last₀ t:39) h:38))}
//│ [C ((fun head:32 -> case head:32 of {T => [K] | TT => [KK]}) hhh:30) (map₁ ttt:31)] --->
//│ 	case ys:36 of {N => (fun x:37 -> x:37) | C h:38 t:39 => (fun x:40 -> ((last₀ t:39) h:38))}
//│ [T] --->
//│ 	case head:28 of {T => [K] | TT => [KK]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (lastDrive₀ (map₀ 
//│ 	let hhh:26 = [K]
//│ 	in let ttt:27 = 	
//│ 		let hhh:30 = [KK]
//│ 		in let ttt:31 = (fun x:37 -> x:37)
//│ 		in let h:38 = ((fun head:32 -> head:32) hhh:30)
//│ 		in let t:39 = (map₁ ttt:31)
//│ 		in (fun x:40 -> ((last₀ t:39) h:38))
//│ 	in let hh:34 = ((fun head:28 -> head:28) hhh:26)
//│ 	in let tt:35 = (map₁ ttt:27)
//│ 	in [Some ((last₀ tt:35) hh:34)]))
//│ def map₀ = {
//│ 	(fun ls:25 -> ls:25)
//│ 		where
//│ 	def map₁ = {
//│ 		(fun ls:29 -> ls:29)
//│ 	}
//│ }
//│ def lastDrive₀ = {
//│ 	(fun xs:33 -> xs:33)
//│ 		where
//│ 	def last₀ = {
//│ 		(fun ys:36 -> ys:36)
//│ 	}
//│ }
//│ <<<<<<< after fusion <<<<<<<
