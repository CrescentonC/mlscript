:NewParser
:ParseOnly

fun inter(xs) = if xs is
    N then ys => ys
    C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, N))
let l2 = N
inter(l1)(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#let| |l2| |#=| |N|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, N,),); let l2 = N; inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^20(l1^21, l2^23)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [N]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 16 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 2 [N]]: 17 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 1 [C 2 [N]]]: 18 --->
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [N]: 19 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12 --->
//│ 	[N]: 16
//│ 	[C 2 [N]]: 17
//│ 	[C 1 [C 2 [N]]]: 18
//│ 	[N]: 19
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ inter(ys³, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [N]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [N]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [N]
//│ <<<<<<< after floating out <<<<<<<



// NOTE: only head is handled
fun map(ls) = if ls is
    C(h, t) then f => C(f(h), map(t)(f))
    N then f => N
let l = C(K, N)
map(l)(
    x => if x is
        K then T
)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#let| |l| |#=| |C|(|K|,| |N|)|↵|map|(|l|)|(|→|x| |=>| |#if| |x| |is|→|K| |#then| |T|←|←|↵|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then f, => C (f (h,), map (t,) (f,),); (N) then f, => N›; let l = C (K, N,); map (l,) (x, => if x is ‹(K) then T›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^19(l^20, (fun x⁰ -> case x⁰ of {
//│ 	K  => [T]}))
//│ def l = [C [K] [N]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map^5(t⁰, f⁰)])
//│ 	| N  => (fun f¹ -> [N])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 16 --->
//│ 	case x⁰ of {K  => [T]}: 24
//│ [N]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14
//│ [C [K] [N]]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14 --->
//│ 	[N]: 17
//│ 	[C [K] [N]]: 18
//│ case x⁰ of {K  => [T]}: 24 --->
//│ 	DeadCodeProd
//│ 	[K]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14
//│ [C [K] [N]]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => (fun f⁰ -> [C f⁰(h⁰) map(t⁰, f⁰)]) | N  => (fun f¹ -> [N])}: 14 --->
//│ 	[N]: 17
//│ 	[C [K] [N]]: 18
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(l, (fun x¹ -> case x¹ of {
//│ 	K  => [T]}))
//│ def l = 
//│ 	let t¹ = (fun f³ -> [N])
//│ 	in let h¹ = [K]
//│ 	in (fun f² -> [C f²(h¹) map(t¹, f²)])
//│ def map(ls¹) = ls¹
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ l -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ l((fun x⁰ -> case x⁰ of {
//│ 	K  => [T]}))
//│ def l = 
//│ 	let t⁰ = (fun f⁰ -> [N])
//│ 	in let h⁰ = [K]
//│ 	in (fun f¹ -> [C f¹(h⁰) t⁰(f¹)])
//│ def map(ls⁰) = ls⁰
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ l((fun x⁰ -> case x⁰ of {
//│ 	K  => [T]}))
//│ def l(f⁰) = 
//│ 	let t⁰ = (fun f¹ -> [N])
//│ 	in let h⁰ = [K]
//│ 	in [C f⁰(h⁰) t⁰(f⁰)]
//│ def map(ls⁰) = ls⁰
//│ <<<<<<< after floating out <<<<<<<



fun map(ls) = if ls is
    C(h, t) then C(
        (if h is
            K then T
            KK then TT
            KKKK then TTTT
        ),
        map(t)
    )
    N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›, ')', map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ map^21(l^22)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C case h⁰ of {
//│ 		K  => [T]
//│ 		| KK  => [TT]
//│ 		| KKKK  => [TTTT]} map^7(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K]: 14 --->
//│ 	case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6
//│ [KK]: 15 --->
//│ 	case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6
//│ [KKKK]: 16 --->
//│ 	case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6
//│ [N]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ [C [KKKK] [N]]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ [C [KK] [C [KKKK] [N]]]: 19 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 20 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ ------------------
//│ case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6 --->
//│ 	[K]: 14
//│ 	[KK]: 15
//│ 	[KKKK]: 16
//│ case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 17
//│ 	[C [KKKK] [N]]: 18
//│ 	[C [KK] [C [KKKK] [N]]]: 19
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [K]: 14 --->
//│ 	case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6
//│ [KK]: 15 --->
//│ 	case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6
//│ [KKKK]: 16 --->
//│ 	case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6
//│ [N]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ [C [KKKK] [N]]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ [C [KK] [C [KKKK] [N]]]: 19 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ [C [K] [C [KK] [C [KKKK] [N]]]]: 20 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12
//│ ------------------
//│ case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]}: 6 --->
//│ 	[K]: 14
//│ 	[KK]: 15
//│ 	[KKKK]: 16
//│ case ls⁰ of {C h⁰ t⁰ => [C case h⁰ of {K  => [T] | KK  => [TT] | KKKK  => [TTTT]} map(t⁰)] | N  => [N]}: 12 --->
//│ 	[N]: 17
//│ 	[C [KKKK] [N]]: 18
//│ 	[C [KK] [C [KKKK] [N]]]: 19
//│ 	[C [K] [C [KK] [C [KKKK] [N]]]]: 20
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ map(l)
//│ def l = 
//│ 	let t¹ = 	
//│ 		let t² = 	
//│ 			let t³ = (fun _lh_dummy³ -> [N])
//│ 			in let h³ = [TTTT]
//│ 			in (fun _lh_dummy² -> [C h³ map(t³)])
//│ 		in let h² = [TT]
//│ 		in (fun _lh_dummy¹ -> [C h² map(t²)])
//│ 	in let h¹ = [T]
//│ 	in (fun _lh_dummy⁰ -> [C h¹ map(t¹)])
//│ def map(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ l -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ l(99)
//│ def l = 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun _lh_dummy⁰ -> [N])
//│ 			in let h⁰ = [TTTT]
//│ 			in (fun _lh_dummy¹ -> [C h⁰ t²(99)])
//│ 		in let h¹ = [TT]
//│ 		in (fun _lh_dummy² -> [C h¹ t¹(99)])
//│ 	in let h² = [T]
//│ 	in (fun _lh_dummy³ -> [C h² t⁰(99)])
//│ def map(ls⁰) = ls⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ l(99)
//│ def l(_lh_dummy⁰) = 
//│ 	let t⁰ = 	
//│ 		let t¹ = 	
//│ 			let t² = (fun _lh_dummy¹ -> [N])
//│ 			in let h⁰ = [TTTT]
//│ 			in (fun _lh_dummy² -> [C h⁰ t²(99)])
//│ 		in let h¹ = [TT]
//│ 		in (fun _lh_dummy³ -> [C h¹ t¹(99)])
//│ 	in let h² = [T]
//│ 	in [C h² t⁰(99)]
//│ def map(ls⁰) = ls⁰(99)
//│ <<<<<<< after floating out <<<<<<<



// NOTE: consumer `c` is used twice in its body, but it fine here
let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
    T(n, l, r) then T(
        (if n is
            K then KK
            N then NN
        ),
        c(l),
        c(r)
    )
    L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ c^28(t^29)
//│ def aa = [T [N] [L] [L]]
//│ def bb = [T [N] [L] [L]]
//│ def c(x⁰) = case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K  => [KK]
//│ 		| N  => [NN]} c^18(l⁰) c^21(r⁰)]
//│ 	| L  => [LL]}
//│ def t = [T [K] aa^10 bb^11]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 1 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 17
//│ [L]: 2 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [L]: 3 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [T [N] [L] [L]]: 4 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [N]: 5 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 17
//│ [L]: 6 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [L]: 7 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [T [N] [L] [L]]: 8 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [K]: 9 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 17
//│ [T [K] aa bb]: 12 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ ------------------
//│ case n⁰ of {K  => [KK] | N  => [NN]}: 17 --->
//│ 	[N]: 1
//│ 	[N]: 5
//│ 	[K]: 9
//│ case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26 --->
//│ 	[L]: 2
//│ 	[L]: 3
//│ 	[T [N] [L] [L]]: 4
//│ 	[L]: 6
//│ 	[L]: 7
//│ 	[T [N] [L] [L]]: 8
//│ 	[T [K] aa bb]: 12
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 1 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 17
//│ [L]: 2 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [L]: 3 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [T [N] [L] [L]]: 4 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [N]: 5 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 17
//│ [L]: 6 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [L]: 7 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [T [N] [L] [L]]: 8 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ [K]: 9 --->
//│ 	case n⁰ of {K  => [KK] | N  => [NN]}: 17
//│ [T [K] aa bb]: 12 --->
//│ 	case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26
//│ ------------------
//│ case n⁰ of {K  => [KK] | N  => [NN]}: 17 --->
//│ 	[N]: 1
//│ 	[N]: 5
//│ 	[K]: 9
//│ case x⁰ of {T n⁰ l⁰ r⁰ => [T case n⁰ of {K  => [KK] | N  => [NN]} c(l⁰) c(r⁰)] | L  => [LL]}: 26 --->
//│ 	[L]: 2
//│ 	[L]: 3
//│ 	[T [N] [L] [L]]: 4
//│ 	[L]: 6
//│ 	[L]: 7
//│ 	[T [N] [L] [L]]: 8
//│ 	[T [K] aa bb]: 12
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ c(t)
//│ def aa = 
//│ 	let r¹ = (fun _lh_dummy² -> [LL])
//│ 	in let l¹ = (fun _lh_dummy¹ -> [LL])
//│ 	in let n¹ = [NN]
//│ 	in (fun _lh_dummy⁰ -> [T n¹ c(l¹) c(r¹)])
//│ def bb = 
//│ 	let r² = (fun _lh_dummy⁵ -> [LL])
//│ 	in let l² = (fun _lh_dummy⁴ -> [LL])
//│ 	in let n² = [NN]
//│ 	in (fun _lh_dummy³ -> [T n² c(l²) c(r²)])
//│ def c(x¹) = x¹(99)
//│ def t = 
//│ 	let r³ = bb
//│ 	in let l³ = aa
//│ 	in let n³ = [KK]
//│ 	in (fun _lh_dummy⁶ -> [T n³ c(l³) c(r³)])
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ c
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ aa -> 0
//│ bb -> 0
//│ t -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ t(99)
//│ def aa = 
//│ 	let r⁰ = (fun _lh_dummy⁰ -> [LL])
//│ 	in let l⁰ = (fun _lh_dummy¹ -> [LL])
//│ 	in let n⁰ = [NN]
//│ 	in (fun _lh_dummy² -> [T n⁰ l⁰(99) r⁰(99)])
//│ def bb = 
//│ 	let r¹ = (fun _lh_dummy³ -> [LL])
//│ 	in let l¹ = (fun _lh_dummy⁴ -> [LL])
//│ 	in let n¹ = [NN]
//│ 	in (fun _lh_dummy⁵ -> [T n¹ l¹(99) r¹(99)])
//│ def c(x⁰) = x⁰(99)
//│ def t = 
//│ 	let r² = bb
//│ 	in let l² = aa
//│ 	in let n² = [KK]
//│ 	in (fun _lh_dummy⁶ -> [T n² l²(99) r²(99)])
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ t(99)
//│ def aa = 
//│ 	let r⁰ = (fun _lh_dummy⁰ -> [LL])
//│ 	in let l⁰ = (fun _lh_dummy¹ -> [LL])
//│ 	in let n⁰ = [NN]
//│ 	in (fun _lh_dummy² -> [T n⁰ l⁰(99) r⁰(99)])
//│ def bb = 
//│ 	let r¹ = (fun _lh_dummy³ -> [LL])
//│ 	in let l¹ = (fun _lh_dummy⁴ -> [LL])
//│ 	in let n¹ = [NN]
//│ 	in (fun _lh_dummy⁵ -> [T n¹ l¹(99) r¹(99)])
//│ def c(x⁰) = x⁰(99)
//│ def t(_lh_dummy⁶) = 
//│ 	let r² = bb
//│ 	in let l² = aa
//│ 	in let n² = [KK]
//│ 	in [T n² l²(99) r²(99)]
//│ <<<<<<< after floating out <<<<<<<




fun sum(ls) = if ls is
    C(h, t) then S(N, sum(t))
    N then N
fun mapa(lsa) = if lsa is
    C(ha, ta) then C(primitive(ha), mapa(ta))
    N then N
fun mapb(lsb) = if lsb is
    C(hb, tb) then C(primitive(hb), mapb(tb))
    N then N
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|↵|N| |#then| |N|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|↵|N| |#then| |N|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),); (N) then N›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),); (N) then N›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),); (N) then N›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ sum^32(mapa^33(mapb^34(primitive⁰)))
//│ def mapa(lsa⁰) = case lsa⁰ of {
//│ 	C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa^14(ta⁰)]
//│ 	| N  => [N]}
//│ def mapb(lsb⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => [C primitive⁰(hb⁰) mapb^25(tb⁰)]
//│ 	| N  => [N]}
//│ def sum(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [S [N] sum^3(t⁰)]
//│ 	| N  => [N]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C primitive⁰(ha⁰) mapa(ta⁰)]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)] | N  => [N]}: 8
//│ [N]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)] | N  => [N]}: 8
//│ [C primitive⁰(hb⁰) mapb(tb⁰)]: 28 --->
//│ 	case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)] | N  => [N]}: 19
//│ [N]: 29 --->
//│ 	case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)] | N  => [N]}: 19
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)] | N  => [N]}: 8 --->
//│ 	[C primitive⁰(ha⁰) mapa(ta⁰)]: 17
//│ 	[N]: 18
//│ case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)] | N  => [N]}: 19 --->
//│ 	[C primitive⁰(hb⁰) mapb(tb⁰)]: 28
//│ 	[N]: 29
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C primitive⁰(ha⁰) mapa(ta⁰)]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)] | N  => [N]}: 8
//│ [N]: 18 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)] | N  => [N]}: 8
//│ [C primitive⁰(hb⁰) mapb(tb⁰)]: 28 --->
//│ 	case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)] | N  => [N]}: 19
//│ [N]: 29 --->
//│ 	case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)] | N  => [N]}: 19
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [S [N] sum(t⁰)] | N  => [N]}: 8 --->
//│ 	[C primitive⁰(ha⁰) mapa(ta⁰)]: 17
//│ 	[N]: 18
//│ case lsa⁰ of {C ha⁰ ta⁰ => [C primitive⁰(ha⁰) mapa(ta⁰)] | N  => [N]}: 19 --->
//│ 	[C primitive⁰(hb⁰) mapb(tb⁰)]: 28
//│ 	[N]: 29
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ sum(mapa(mapb(primitive⁰)))
//│ def mapa(lsa¹) = lsa¹(99)
//│ def mapb(lsb¹) = case lsb¹ of {
//│ 	C hb⁰ tb⁰ => 
//│ 		let ta¹ = mapb(tb⁰)
//│ 		in let ha¹ = primitive⁰(hb⁰)
//│ 		in (fun _lh_dummy¹ -> 
//│ 			let t¹ = mapa(ta¹)
//│ 			in let h¹ = primitive⁰(ha¹)
//│ 			in (fun _lh_dummy⁰ -> [S [N] sum(t¹)]))
//│ 	| N  => (fun _lh_dummy³ -> (fun _lh_dummy² -> [N]))}
//│ def sum(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ sum, mapa
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ mapb -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ mapb(primitive⁰, 99, 99)
//│ def mapa(lsa⁰) = lsa⁰(99)
//│ def mapb(lsb⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => 
//│ 		let ta⁰ = mapb(tb⁰)
//│ 		in let ha⁰ = primitive⁰(hb⁰)
//│ 		in (fun _lh_dummy⁰ -> 
//│ 			let t⁰ = ta⁰(99)
//│ 			in let h⁰ = primitive⁰(ha⁰)
//│ 			in (fun _lh_dummy¹ -> [S [N] t⁰(99)]))
//│ 	| N  => (fun _lh_dummy² -> (fun _lh_dummy³ -> [N]))}
//│ def sum(ls⁰) = ls⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ mapb(primitive⁰, 99, 99)
//│ def mapa(lsa⁰) = lsa⁰(99)
//│ def mapb(lsb⁰, _lh_popOutId_0⁰, _lh_popOutId_1⁰) = case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => 
//│ 		let ta⁰ = mapb(tb⁰)
//│ 		in let ha⁰ = primitive⁰(hb⁰)
//│ 		in let t⁰ = ta⁰(99)
//│ 		in let h⁰ = primitive⁰(ha⁰)
//│ 		in [S [N] t⁰(99)]
//│ 	| N  => [N]}
//│ def sum(ls⁰) = ls⁰(99)
//│ <<<<<<< after floating out <<<<<<<

fun map(ls) = if ls is
    N then N
    C(hhh, ttt) then C((
        head => if head is 
            T then K
            TT then KK
    )(hhh), map(ttt))
fun last(ys) = if ys is
    N then x => x
    C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
    N then None
    C(hh, tt) then Some(last(tt)(hh))
lastDrive(map(C(T, C(TT, N))))
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|hhh|,| |ttt|)| |#then| |C|(|(|→|head| |=>| |#if| |head| |is| |→|T| |#then| |K|↵|TT| |#then| |KK|←|←|↵|)|(|hhh|)|,| |map|(|ttt|)|)|←|↵|#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|map|(|C|(|T|,| |C|(|TT|,| |N|)|)|)|)|
//│ Parsed: {fun map = ls, => if ls is ‹(N) then N; (C (hhh, ttt,)) then C ('(' head, => if head is ‹(T) then K; (TT) then KK›, ')' (hhh,), map (ttt,),)›; fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (map (C (T, C (TT, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ lastDrive^37(map^38([C [T] [C [TT] [N]]]))
//│ def last(ys⁰) = case ys⁰ of {
//│ 	N  => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> last^19(t⁰, h⁰))}
//│ def lastDrive(xs⁰) = case xs⁰ of {
//│ 	N  => [None]
//│ 	| C hh⁰ tt⁰ => [Some last^29(tt⁰, hh⁰)]}
//│ def map(ls⁰) = case ls⁰ of {
//│ 	N  => [N]
//│ 	| C hhh⁰ ttt⁰ => [C (fun head⁰ -> case head⁰ of {
//│ 		T  => [K]
//│ 		| TT  => [KK]})(hhh⁰) map^10(ttt⁰)]}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 2 --->
//│ 	case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 25
//│ 	case xs⁰ of {N  => [None] | C hh⁰ tt⁰ => [Some last(tt⁰, hh⁰)]}: 35
//│ [C (fun head⁰ -> case head⁰ of {T  => [K] | TT  => [KK]})(hhh⁰) map(ttt⁰)]: 13 --->
//│ 	case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 25
//│ 	case xs⁰ of {N  => [None] | C hh⁰ tt⁰ => [Some last(tt⁰, hh⁰)]}: 35
//│ [T]: 39 --->
//│ 	case head⁰ of {T  => [K] | TT  => [KK]}: 6
//│ [TT]: 40 --->
//│ 	case head⁰ of {T  => [K] | TT  => [KK]}: 6
//│ [N]: 41 --->
//│ 	case ls⁰ of {N  => [N] | C hhh⁰ ttt⁰ => [C (fun head⁰ -> case head⁰ of {T  => [K] | TT  => [KK]})(hhh⁰) map(ttt⁰)]}: 14
//│ [C [TT] [N]]: 42 --->
//│ 	case ls⁰ of {N  => [N] | C hhh⁰ ttt⁰ => [C (fun head⁰ -> case head⁰ of {T  => [K] | TT  => [KK]})(hhh⁰) map(ttt⁰)]}: 14
//│ [C [T] [C [TT] [N]]]: 43 --->
//│ 	case ls⁰ of {N  => [N] | C hhh⁰ ttt⁰ => [C (fun head⁰ -> case head⁰ of {T  => [K] | TT  => [KK]})(hhh⁰) map(ttt⁰)]}: 14
//│ ------------------
//│ case head⁰ of {T  => [K] | TT  => [KK]}: 6 --->
//│ 	[T]: 39
//│ 	[TT]: 40
//│ case ls⁰ of {N  => [N] | C hhh⁰ ttt⁰ => [C (fun head⁰ -> case head⁰ of {T  => [K] | TT  => [KK]})(hhh⁰) map(ttt⁰)]}: 14 --->
//│ 	[N]: 41
//│ 	[C [TT] [N]]: 42
//│ 	[C [T] [C [TT] [N]]]: 43
//│ case ys⁰ of {N  => (fun x⁰ -> x⁰) | C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}: 25 --->
//│ 	[N]: 2
//│ 	[C (fun head⁰ -> case head⁰ of {T  => [K] | TT  => [KK]})(hhh⁰) map(ttt⁰)]: 13
//│ case xs⁰ of {N  => [None] | C hh⁰ tt⁰ => [Some last(tt⁰, hh⁰)]}: 35 --->
//│ 	[N]: 2
//│ 	[C (fun head⁰ -> case head⁰ of {T  => [K] | TT  => [KK]})(hhh⁰) map(ttt⁰)]: 13
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [T]: 39 --->
//│ 	case head⁰ of {T  => [K] | TT  => [KK]}: 6
//│ [TT]: 40 --->
//│ 	case head⁰ of {T  => [K] | TT  => [KK]}: 6
//│ [N]: 41 --->
//│ 	case ls⁰ of {N  => [N] | C hhh⁰ ttt⁰ => [C (fun head⁰ -> case head⁰ of {T  => [K] | TT  => [KK]})(hhh⁰) map(ttt⁰)]}: 14
//│ [C [TT] [N]]: 42 --->
//│ 	case ls⁰ of {N  => [N] | C hhh⁰ ttt⁰ => [C (fun head⁰ -> case head⁰ of {T  => [K] | TT  => [KK]})(hhh⁰) map(ttt⁰)]}: 14
//│ [C [T] [C [TT] [N]]]: 43 --->
//│ 	case ls⁰ of {N  => [N] | C hhh⁰ ttt⁰ => [C (fun head⁰ -> case head⁰ of {T  => [K] | TT  => [KK]})(hhh⁰) map(ttt⁰)]}: 14
//│ ------------------
//│ case head⁰ of {T  => [K] | TT  => [KK]}: 6 --->
//│ 	[T]: 39
//│ 	[TT]: 40
//│ case ls⁰ of {N  => [N] | C hhh⁰ ttt⁰ => [C (fun head⁰ -> case head⁰ of {T  => [K] | TT  => [KK]})(hhh⁰) map(ttt⁰)]}: 14 --->
//│ 	[N]: 41
//│ 	[C [TT] [N]]: 42
//│ 	[C [T] [C [TT] [N]]]: 43
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ lastDrive(map(
//│ 	let ttt¹ = 	
//│ 		let ttt² = (fun _lh_dummy² -> [N])
//│ 		in let hhh² = [KK]
//│ 		in (fun _lh_dummy¹ -> [C (fun head² -> head²)(hhh²) map(ttt²)])
//│ 	in let hhh¹ = [K]
//│ 	in (fun _lh_dummy⁰ -> [C (fun head¹ -> head¹)(hhh¹) map(ttt¹)])))
//│ def last(ys¹) = case ys¹ of {
//│ 	N  => (fun x² -> x²)
//│ 	| C h⁰ t⁰ => (fun x³ -> last(t⁰, h⁰))}
//│ def lastDrive(xs¹) = case xs¹ of {
//│ 	N  => [None]
//│ 	| C hh⁰ tt⁰ => [Some last(tt⁰, hh⁰)]}
//│ def map(ls¹) = ls¹(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ lastDrive(
//│ 	let ttt⁰ = 	
//│ 		let ttt¹ = (fun _lh_dummy⁰ -> [N])
//│ 		in let hhh⁰ = [KK]
//│ 		in (fun _lh_dummy¹ -> [C (fun head⁰ -> head⁰)(hhh⁰) ttt¹(99)])
//│ 	in let hhh¹ = [K]
//│ 	in (fun _lh_dummy² -> [C (fun head¹ -> head¹)(hhh¹) ttt⁰(99)])(99))
//│ def last(ys⁰) = case ys⁰ of {
//│ 	N  => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}
//│ def lastDrive(xs⁰) = case xs⁰ of {
//│ 	N  => [None]
//│ 	| C hh⁰ tt⁰ => [Some last(tt⁰, hh⁰)]}
//│ def map(ls⁰) = ls⁰(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ lastDrive(
//│ 	let ttt⁰ = 	
//│ 		let ttt¹ = (fun _lh_dummy⁰ -> [N])
//│ 		in let hhh⁰ = [KK]
//│ 		in (fun _lh_dummy¹ -> [C (fun head⁰ -> head⁰)(hhh⁰) ttt¹(99)])
//│ 	in let hhh¹ = [K]
//│ 	in (fun _lh_dummy² -> [C (fun head¹ -> head¹)(hhh¹) ttt⁰(99)])(99))
//│ def last(ys⁰) = case ys⁰ of {
//│ 	N  => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> last(t⁰, h⁰))}
//│ def lastDrive(xs⁰) = case xs⁰ of {
//│ 	N  => [None]
//│ 	| C hh⁰ tt⁰ => [Some last(tt⁰, hh⁰)]}
//│ def map(ls⁰) = ls⁰(99)
//│ <<<<<<< after floating out <<<<<<<
