:NewParser
:ParseOnly


fun inter(xs) = if xs is
    N then ys => ys
    C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, N))
let l2 = N
inter(l1)(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#let| |l2| |#=| |N|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, N,),); let l2 = N; inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter^20 l1^21) l2^23)
//│ def inter = (fun xs⁰ -> case xs⁰ of {
//│ 	N => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ ((inter^5 ys¹) t⁰)])})
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [N]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^20]
//│ 	[inter^20 · inter^5]
//│ 		[inter^20 · inter^5 · inter^5]
//│ 			[inter^20 · inter^5 · inter^5 · inter^5]
//│ 				[inter^20 · inter^5 · inter^5 · inter^5 · inter^5] ---> [inter^20 · inter^5 · inter^5] (only one)
//│ [l1^21]
//│ [l2^23]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]] --->
//│ 	case xs³ of {N => (fun ys⁶ -> ys⁶) | C h³ t³ => (fun ys⁷ -> [C h³ ((inter₁ ys⁷) t³)])}
//│ [C 2 [N]] --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h² t² => (fun ys⁵ -> [C h² ((inter₃ ys⁵) t²)])}
//│ [N] --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₂ ys³) t¹)])}
//│ [N] --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h² t² => (fun ys⁵ -> [C h² ((inter₃ ys⁵) t²)])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((inter₀ l1₀) l2₀)
//│ def inter₀ = 
//│ 	(fun xs³ -> xs³)
//│ 	where
//│ 	def inter₁ = 
//│ 		(fun xs¹ -> xs¹)
//│ 		where
//│ 		def inter₂ = 
//│ 			(fun xs² -> xs²)
//│ 			where
//│ 			def inter₃ = 
//│ 				(fun xs⁴ -> case xs⁴ of {
//│ 					N => (fun ys⁸ -> ys⁸)
//│ 					| C h⁴ t⁴ => (fun ys⁹ -> [C h⁴ ((inter₂ ys⁹) t⁴)])})
//│ def l1₀ = 
//│ 	let h³ = 1
//│ 	in let t³ = 	
//│ 		let h² = 2
//│ 		in let t² = (fun ys⁴ -> ys⁴)
//│ 		in (fun ys⁵ -> [C h² ((inter₃ ys⁵) t²)])
//│ 	in (fun ys⁷ -> [C h³ ((inter₁ ys⁷) t³)])
//│ def l2₀ = 
//│ 	(fun ys² -> ys²)
//│ <<<<<<< after fusion <<<<<<<


fun inter(xs) = if xs is
    N then ys => ys
    C(h, t) then ys => C(h, inter(ys)(t))
fun l1(x) = C(1, C(2, l1(add(x, 1))))
let rec l2 = C(9, C(8, l2))
inter(l1(0))(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#fun| |l1|(|x|)| |#=| |C|(|1|,| |C|(|2|,| |l1|(|add|(|x|,| |1|)|)|)|)|↵|#let| |#rec| |l2| |#=| |C|(|9|,| |C|(|8|,| |l2|)|)|↵|inter|(|l1|(|0|)|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; fun l1 = x, => C (1, C (2, l1 (add (x, 1,),),),); let rec l2 = C (9, C (8, l2,),); inter (l1 (0,),) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((inter^31 (l1^32 0)) l2^36)
//│ def inter = (fun xs⁰ -> case xs⁰ of {
//│ 	N => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ ((inter^5 ys¹) t⁰)])})
//│ def l1 = (fun x⁰ -> [C 1 [C 2 (l1^16 ((add⁰ x⁰) 1))]])
//│ def l2 = [C 9 [C 8 l2^28]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [inter^31]
//│ 	[inter^31 · inter^5]
//│ 		[inter^31 · inter^5 · inter^5]
//│ 			[inter^31 · inter^5 · inter^5 · inter^5]
//│ 				[inter^31 · inter^5 · inter^5 · inter^5 · inter^5]
//│ 					[inter^31 · inter^5 · inter^5 · inter^5 · inter^5 · inter^5] ---> [inter^31 · inter^5] (only one)
//│ [l1^32]
//│ 	[l1^32 · l1^16] ---> [l1^32] (only one)
//│ [l2^36]
//│ 	[l2^36 · l2^28] ---> [l2^36] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 (l1₀ ((add⁰ x¹) 1))]] --->
//│ 	case xs⁵ of {N => (fun ys¹⁰ -> ys¹⁰) | C h⁵ t⁵ => (fun ys¹¹ -> [C h⁵ ((inter₁ ys¹¹) t⁵)])}
//│ 	case xs⁴ of {N => (fun ys⁸ -> ys⁸) | C h⁴ t⁴ => (fun ys⁹ -> [C h⁴ ((inter₁ ys⁹) t⁴)])}
//│ 	 MORE THAN ONE MATCH EXPR
//│ [C 2 (l1₀ ((add⁰ x¹) 1))] --->
//│ 	case xs¹ of {N => (fun ys² -> ys²) | C h¹ t¹ => (fun ys³ -> [C h¹ ((inter₃ ys³) t¹)])}
//│ [C 8 l2₀] --->
//│ 	case xs³ of {N => (fun ys⁶ -> ys⁶) | C h³ t³ => (fun ys⁷ -> [C h³ ((inter₄ ys⁷) t³)])}
//│ [C 9 [C 8 l2₀]] --->
//│ 	case xs² of {N => (fun ys⁴ -> ys⁴) | C h² t² => (fun ys⁵ -> [C h² ((inter₂ ys⁵) t²)])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((inter₀ (l1₀ 0)) l2₀)
//│ def inter₀ = 
//│ 	(fun xs⁵ -> xs⁵)
//│ 	where
//│ 	def inter₁ = 
//│ 		(fun xs² -> xs²)
//│ 		where
//│ 		def inter₂ = 
//│ 			(fun xs¹ -> xs¹)
//│ 			where
//│ 			def inter₃ = 
//│ 				(fun xs³ -> xs³)
//│ 				where
//│ 				def inter₄ = 
//│ 					(fun xs⁴ -> case xs⁴ of {
//│ 						N => (fun ys⁸ -> ys⁸)
//│ 						| C h⁴ t⁴ => (fun ys⁹ -> [C h⁴ ((inter₁ ys⁹) t⁴)])})
//│ def l1₀ = 
//│ 	(fun x¹ -> 
//│ 		let h⁵ = 1
//│ 		in let t⁵ = 	
//│ 			let h¹ = 2
//│ 			in let t¹ = (l1₀ ((add⁰ x¹) 1))
//│ 			in (fun ys³ -> [C h¹ ((inter₃ ys³) t¹)])
//│ 		in (fun ys¹¹ -> [C h⁵ ((inter₁ ys¹¹) t⁵)]))
//│ def l2₀ = 
//│ 	let h² = 9
//│ 	in let t² = 	
//│ 		let h³ = 8
//│ 		in let t³ = l2₀
//│ 		in (fun ys⁷ -> [C h³ ((inter₄ ys⁷) t³)])
//│ 	in (fun ys⁵ -> [C h² ((inter₂ ys⁵) t²)])
//│ <<<<<<< after fusion <<<<<<<




// NOTE: only head is handled
fun map(ls) = if ls is
    C(h, t) then f => C(f(h), map(t)(f))
    N then f => N
let l = C(K, N)
map(l)(
    x => if x is
        K then T
)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#let| |l| |#=| |C|(|K|,| |N|)|↵|map|(|l|)|(|→|x| |=>| |#if| |x| |is|→|K| |#then| |T|←|←|↵|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then f, => C (f (h,), map (t,) (f,),); (N) then f, => N›; let l = C (K, N,); map (l,) (x, => if x is ‹(K) then T›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((map^19 l^20) (fun x⁰ -> case x⁰ of {
//│ 	K => [T]}))
//│ def l = [C [K] [N]]
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => (fun f⁰ -> [C (f⁰ h⁰) ((map^5 t⁰) f⁰)])
//│ 	| N => (fun f¹ -> [N])})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^20]
//│ [map^19]
//│ 	[map^19 · map^5]
//│ 		[map^19 · map^5 · map^5] ---> [map^19 · map^5] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [K] [N]] --->
//│ 	case ls² of {C h² t² => (fun f⁴ -> [C (f⁴ h²) ((map₁ t²) f⁴)]) | N => (fun f⁵ -> [N])}
//│ [K] --->
//│ 	case x¹ of {K => [T]}
//│ [N] --->
//│ 	case ls¹ of {C h¹ t¹ => (fun f² -> [C (f² h¹) ((map₁ t¹) f²)]) | N => (fun f³ -> [N])}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((map₀ l₀) (fun x¹ -> x¹))
//│ def l₀ = 
//│ 	let h² = [T]
//│ 	in let t² = (fun f³ -> [N])
//│ 	in (fun f⁴ -> [C (f⁴ h²) ((map₁ t²) f⁴)])
//│ def map₀ = 
//│ 	(fun ls² -> ls²)
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls¹ -> ls¹)
//│ <<<<<<< after fusion <<<<<<<



fun map(ls) = if ls is
    C(h, t) then C(
        (if h is
            K then T
            KK then TT
            KKKK then TTTT
        ),
        map(t)
    )
    N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›, ')', map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (map^21 l^22)
//│ def l = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [C case h⁰ of {
//│ 		K => [T]
//│ 		| KK => [TT]
//│ 		| KKKK => [TTTT]} (map^7 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [l^22]
//│ [map^21]
//│ 	[map^21 · map^7]
//│ 		[map^21 · map^7 · map^7]
//│ 			[map^21 · map^7 · map^7 · map^7]
//│ 				[map^21 · map^7 · map^7 · map^7 · map^7] ---> [map^21 · map^7 · map^7 · map^7] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [KKKK] [N]] --->
//│ 	case ls³ of {C h³ t³ => [C case h³ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₃ t³)] | N => [N]}
//│ [C [KK] [C [KKKK] [N]]] --->
//│ 	case ls² of {C h² t² => [C case h² of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₂ t²)] | N => [N]}
//│ [C [K] [C [KK] [C [KKKK] [N]]]] --->
//│ 	case ls⁴ of {C h⁴ t⁴ => [C case h⁴ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₁ t⁴)] | N => [N]}
//│ [KKKK] --->
//│ 	case h³ of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ [KK] --->
//│ 	case h² of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ [K] --->
//│ 	case h⁴ of {K => [T] | KK => [TT] | KKKK => [TTTT]}
//│ [N] --->
//│ 	case ls¹ of {C h¹ t¹ => [C case h¹ of {K => [T] | KK => [TT] | KKKK => [TTTT]} (map₃ t¹)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (map₀ l₀)
//│ def l₀ = 
//│ 	let h⁴ = [T]
//│ 	in let t⁴ = 	
//│ 		let h² = [TT]
//│ 		in let t² = 	
//│ 			let h³ = [TTTT]
//│ 			in let t³ = [N]
//│ 			in [C h³ (map₃ t³)]
//│ 		in [C h² (map₂ t²)]
//│ 	in [C h⁴ (map₁ t⁴)]
//│ def map₀ = 
//│ 	(fun ls⁴ -> ls⁴)
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls² -> ls²)
//│ 		where
//│ 		def map₂ = 
//│ 			(fun ls³ -> ls³)
//│ 			where
//│ 			def map₃ = 
//│ 				(fun ls¹ -> ls¹)
//│ <<<<<<< after fusion <<<<<<<



// NOTE: consumer `c` is used twice in its body, but it fine here
let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
    T(n, l, r) then T(
        (if n is
            K then KK
            N then NN
        ),
        c(l),
        c(r)
    )
    L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (c^28 t^29)
//│ def aa = [T [N] [L] [L]]
//│ def bb = [T [N] [L] [L]]
//│ def c = (fun x⁰ -> case x⁰ of {
//│ 	T n⁰ l⁰ r⁰ => [T case n⁰ of {
//│ 		K => [KK]
//│ 		| N => [NN]} (c^18 l⁰) (c^21 r⁰)]
//│ 	| L => [LL]})
//│ def t = [T [K] aa^10 bb^11]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [c^28]
//│ 	[c^28 · c^18]
//│ 		[c^28 · c^18 · c^18]
//│ 			[c^28 · c^18 · c^18 · c^18] ---> [c^28 · c^18 · c^18] (only one)
//│ 			[c^28 · c^18 · c^18 · c^21] ---> [c^28 · c^18 · c^18] (only one)
//│ 		[c^28 · c^18 · c^21]
//│ 			[c^28 · c^18 · c^21 · c^18] ---> [c^28 · c^18 · c^21] (only one)
//│ 			[c^28 · c^18 · c^21 · c^21] ---> [c^28 · c^18 · c^21] (only one)
//│ 	[c^28 · c^21]
//│ 		[c^28 · c^21 · c^18]
//│ 			[c^28 · c^21 · c^18 · c^18] ---> [c^28 · c^21 · c^18] (only one)
//│ 			[c^28 · c^21 · c^18 · c^21] ---> [c^28 · c^21 · c^18] (only one)
//│ 		[c^28 · c^21 · c^21]
//│ 			[c^28 · c^21 · c^21 · c^18] ---> [c^28 · c^21 · c^21] (only one)
//│ 			[c^28 · c^21 · c^21 · c^21] ---> [c^28 · c^21 · c^21] (only one)
//│ [t^29]
//│ 	[t^29 · aa^10]
//│ 	[t^29 · bb^11]
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [K] --->
//│ 	case n³ of {K => [KK] | N => [NN]}
//│ [L] --->
//│ 	case x² of {T n² l² r² => [T case n² of {K => [KK] | N => [NN]} (c₂ l²) (c₂ r²)] | L => [LL]}
//│ [L] --->
//│ 	case x⁶ of {T n⁶ l⁶ r⁶ => [T case n⁶ of {K => [KK] | N => [NN]} (c₃ l⁶) (c₃ r⁶)] | L => [LL]}
//│ [L] --->
//│ 	case x⁷ of {T n⁷ l⁷ r⁷ => [T case n⁷ of {K => [KK] | N => [NN]} (c₅ l⁷) (c₅ r⁷)] | L => [LL]}
//│ [L] --->
//│ 	case x⁵ of {T n⁵ l⁵ r⁵ => [T case n⁵ of {K => [KK] | N => [NN]} (c₆ l⁵) (c₆ r⁵)] | L => [LL]}
//│ [N] --->
//│ 	case n¹ of {K => [KK] | N => [NN]}
//│ [N] --->
//│ 	case n⁴ of {K => [KK] | N => [NN]}
//│ [T [K] aa₀ bb₀] --->
//│ 	case x³ of {T n³ l³ r³ => [T case n³ of {K => [KK] | N => [NN]} (c₁ l³) (c₄ r³)] | L => [LL]}
//│ [T [N] [L] [L]] --->
//│ 	case x⁴ of {T n⁴ l⁴ r⁴ => [T case n⁴ of {K => [KK] | N => [NN]} (c₅ l⁴) (c₆ r⁴)] | L => [LL]}
//│ [T [N] [L] [L]] --->
//│ 	case x¹ of {T n¹ l¹ r¹ => [T case n¹ of {K => [KK] | N => [NN]} (c₂ l¹) (c₃ r¹)] | L => [LL]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (c₀ t₀)
//│ def c₀ = 
//│ 	(fun x³ -> x³)
//│ 	where
//│ 	def c₁ = 
//│ 		(fun x¹ -> x¹)
//│ 		where
//│ 		def c₂ = 
//│ 			(fun x² -> x²)
//│ 		def c₃ = 
//│ 			(fun x⁶ -> x⁶)
//│ 	def c₄ = 
//│ 		(fun x⁴ -> x⁴)
//│ 		where
//│ 		def c₅ = 
//│ 			(fun x⁷ -> x⁷)
//│ 		def c₆ = 
//│ 			(fun x⁵ -> x⁵)
//│ def t₀ = 
//│ 	let n³ = [KK]
//│ 	in let l³ = aa₀
//│ 	in let r³ = bb₀
//│ 	in [T n³ (c₁ l³) (c₄ r³)]
//│ 	where
//│ 	def aa₀ = 
//│ 		let n¹ = [NN]
//│ 		in let l¹ = [LL]
//│ 		in let r¹ = [LL]
//│ 		in [T n¹ (c₂ l¹) (c₃ r¹)]
//│ 	def bb₀ = 
//│ 		let n⁴ = [NN]
//│ 		in let l⁴ = [LL]
//│ 		in let r⁴ = [LL]
//│ 		in [T n⁴ (c₅ l⁴) (c₆ r⁴)]
//│ <<<<<<< after fusion <<<<<<<




fun sum(ls) = if ls is
    C(h, t) then S(N, sum(t))
    N then N
fun mapa(lsa) = if lsa is
    C(ha, ta) then C(primitive(ha), mapa(ta))
    N then N
fun mapb(lsb) = if lsb is
    C(hb, tb) then C(primitive(hb), mapb(tb))
    N then N
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|↵|N| |#then| |N|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|↵|N| |#then| |N|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),); (N) then N›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),); (N) then N›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),); (N) then N›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (sum^32 (mapa^33 (mapb^34 primitive⁰)))
//│ def mapa = (fun lsa⁰ -> case lsa⁰ of {
//│ 	C ha⁰ ta⁰ => [C (primitive⁰ ha⁰) (mapa^14 ta⁰)]
//│ 	| N => [N]})
//│ def mapb = (fun lsb⁰ -> case lsb⁰ of {
//│ 	C hb⁰ tb⁰ => [C (primitive⁰ hb⁰) (mapb^25 tb⁰)]
//│ 	| N => [N]})
//│ def sum = (fun ls⁰ -> case ls⁰ of {
//│ 	C h⁰ t⁰ => [S [N] (sum^3 t⁰)]
//│ 	| N => [N]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [mapa^33]
//│ 	[mapa^33 · mapa^14]
//│ 		[mapa^33 · mapa^14 · mapa^14] ---> [mapa^33 · mapa^14] (only one)
//│ [mapb^34]
//│ 	[mapb^34 · mapb^25]
//│ 		[mapb^34 · mapb^25 · mapb^25] ---> [mapb^34 · mapb^25] (only one)
//│ [sum^32]
//│ 	[sum^32 · sum^3]
//│ 		[sum^32 · sum^3 · sum^3] ---> [sum^32 · sum^3] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C (primitive⁰ ha²) (mapa₁ ta²)] --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] (sum₁ t¹)] | N => [N]}
//│ [C (primitive⁰ ha¹) (mapa₁ ta¹)] --->
//│ 	case ls² of {C h² t² => [S [N] (sum₁ t²)] | N => [N]}
//│ [C (primitive⁰ hb²) (mapb₁ tb²)] --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₁ ta¹)] | N => [N]}
//│ [C (primitive⁰ hb¹) (mapb₁ tb¹)] --->
//│ 	case lsa² of {C ha² ta² => [C (primitive⁰ ha²) (mapa₁ ta²)] | N => [N]}
//│ [N] --->
//│ 	case lsa¹ of {C ha¹ ta¹ => [C (primitive⁰ ha¹) (mapa₁ ta¹)] | N => [N]}
//│ [N] --->
//│ 	case ls¹ of {C h¹ t¹ => [S [N] (sum₁ t¹)] | N => [N]}
//│ [N] --->
//│ 	case lsa² of {C ha² ta² => [C (primitive⁰ ha²) (mapa₁ ta²)] | N => [N]}
//│ [N] --->
//│ 	case ls² of {C h² t² => [S [N] (sum₁ t²)] | N => [N]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (sum₀ (mapa₀ (mapb₀ primitive⁰)))
//│ def mapa₀ = 
//│ 	(fun lsa¹ -> lsa¹)
//│ 	where
//│ 	def mapa₁ = 
//│ 		(fun lsa² -> lsa²)
//│ def mapb₀ = 
//│ 	(fun lsb² -> case lsb² of {
//│ 		C hb² tb² => 
//│ 			let ha¹ = (primitive⁰ hb²)
//│ 			in let ta¹ = (mapb₁ tb²)
//│ 			in let h² = (primitive⁰ ha¹)
//│ 			in let t² = (mapa₁ ta¹)
//│ 			in [S [N] (sum₁ t²)]
//│ 		| N => [N]})
//│ 	where
//│ 	def mapb₁ = 
//│ 		(fun lsb¹ -> case lsb¹ of {
//│ 			C hb¹ tb¹ => 
//│ 				let ha² = (primitive⁰ hb¹)
//│ 				in let ta² = (mapb₁ tb¹)
//│ 				in let h¹ = (primitive⁰ ha²)
//│ 				in let t¹ = (mapa₁ ta²)
//│ 				in [S [N] (sum₁ t¹)]
//│ 			| N => [N]})
//│ def sum₀ = 
//│ 	(fun ls² -> ls²)
//│ 	where
//│ 	def sum₁ = 
//│ 		(fun ls¹ -> ls¹)
//│ <<<<<<< after fusion <<<<<<<

fun map(ls) = if ls is
    N then N
    C(hhh, ttt) then C((
        head => if head is 
            T then K
            TT then KK
    )(hhh), map(ttt))
fun last(ys) = if ys is
    N then x => x
    C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
    N then None
    C(hh, tt) then Some(last(tt)(hh))
lastDrive(map(C(T, C(TT, N))))
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|hhh|,| |ttt|)| |#then| |C|(|(|→|head| |=>| |#if| |head| |is| |→|T| |#then| |K|↵|TT| |#then| |KK|←|←|↵|)|(|hhh|)|,| |map|(|ttt|)|)|←|↵|#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|map|(|C|(|T|,| |C|(|TT|,| |N|)|)|)|)|
//│ Parsed: {fun map = ls, => if ls is ‹(N) then N; (C (hhh, ttt,)) then C ('(' head, => if head is ‹(T) then K; (TT) then KK›, ')' (hhh,), map (ttt,),)›; fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (map (C (T, C (TT, N,),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (lastDrive^37 (map^38 [C [T] [C [TT] [N]]]))
//│ def last = (fun ys⁰ -> case ys⁰ of {
//│ 	N => (fun x⁰ -> x⁰)
//│ 	| C h⁰ t⁰ => (fun x¹ -> ((last^19 t⁰) h⁰))})
//│ def lastDrive = (fun xs⁰ -> case xs⁰ of {
//│ 	N => [None]
//│ 	| C hh⁰ tt⁰ => [Some ((last^29 tt⁰) hh⁰)]})
//│ def map = (fun ls⁰ -> case ls⁰ of {
//│ 	N => [N]
//│ 	| C hhh⁰ ttt⁰ => [C ((fun head⁰ -> case head⁰ of {
//│ 		T => [K]
//│ 		| TT => [KK]}) hhh⁰) (map^10 ttt⁰)]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [lastDrive^37]
//│ 	[lastDrive^37 · last^29]
//│ 		[lastDrive^37 · last^29 · last^19] ---> [lastDrive^37 · last^29] (only one)
//│ [map^38]
//│ 	[map^38 · map^10]
//│ 		[map^38 · map^10 · map^10] ---> [map^38 · map^10] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C ((fun head² -> case head² of {T => [K] | TT => [KK]}) hhh²) (map₁ ttt²)] --->
//│ 	case xs¹ of {N => [None] | C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]}
//│ [C ((fun head¹ -> case head¹ of {T => [K] | TT => [KK]}) hhh¹) (map₁ ttt¹)] --->
//│ 	case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))}
//│ [C [TT] [N]] --->
//│ 	case ls¹ of {N => [N] | C hhh¹ ttt¹ => [C ((fun head¹ -> case head¹ of {T => [K] | TT => [KK]}) hhh¹) (map₁ ttt¹)]}
//│ [C [T] [C [TT] [N]]] --->
//│ 	case ls² of {N => [N] | C hhh² ttt² => [C ((fun head² -> case head² of {T => [K] | TT => [KK]}) hhh²) (map₁ ttt²)]}
//│ [N] --->
//│ 	case ls¹ of {N => [N] | C hhh¹ ttt¹ => [C ((fun head¹ -> case head¹ of {T => [K] | TT => [KK]}) hhh¹) (map₁ ttt¹)]}
//│ [N] --->
//│ 	case xs¹ of {N => [None] | C hh¹ tt¹ => [Some ((last₀ tt¹) hh¹)]}
//│ [N] --->
//│ 	case ys¹ of {N => (fun x² -> x²) | C h¹ t¹ => (fun x³ -> ((last₀ t¹) h¹))}
//│ [TT] --->
//│ 	case head¹ of {T => [K] | TT => [KK]}
//│ [T] --->
//│ 	case head² of {T => [K] | TT => [KK]}
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (lastDrive₀ (map₀ 
//│ 	let hhh² = [K]
//│ 	in let ttt² = 	
//│ 		let hhh¹ = [KK]
//│ 		in let ttt¹ = (fun x² -> x²)
//│ 		in let h¹ = ((fun head¹ -> head¹) hhh¹)
//│ 		in let t¹ = (map₁ ttt¹)
//│ 		in (fun x³ -> ((last₀ t¹) h¹))
//│ 	in let hh¹ = ((fun head² -> head²) hhh²)
//│ 	in let tt¹ = (map₁ ttt²)
//│ 	in [Some ((last₀ tt¹) hh¹)]))
//│ def lastDrive₀ = 
//│ 	(fun xs¹ -> xs¹)
//│ 	where
//│ 	def last₀ = 
//│ 		(fun ys¹ -> ys¹)
//│ def map₀ = 
//│ 	(fun ls² -> ls²)
//│ 	where
//│ 	def map₁ = 
//│ 		(fun ls¹ -> ls¹)
//│ <<<<<<< after fusion <<<<<<<
