:NewParser
:ParseOnly


fun inter(xs) = if xs is
    N then ys => ys
    C(h, t) then ys => C(h, inter(ys)(t))
let rec l1 = C(1, C(2, l1))
let rec l2 = C(9, C(8, l2))
inter(l1)(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |#rec| |l1| |#=| |C|(|1|,| |C|(|2|,| |l1|)|)|↵|#let| |#rec| |l2| |#=| |C|(|9|,| |C|(|8|,| |l2|)|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let rec l1 = C (1, C (2, l1,),); let rec l2 = C (9, C (8, l2,),); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def inter:1 = 13: fun xs:4 -> 12: case 1: xs:4 of {N -> 3: fun ys:5 -> 2: ys:5 | C h:6 t:7 -> 11: fun ys:8 -> 10: [C 4: h:6 9: (7: (5: inter:1 6: ys:8) 8: t:7)]}
//│ def l1:2 = 18: [C 14: 1 17: [C 15: 2 16: l1:2]]
//│ def l2:3 = 23: [C 19: 9 22: [C 20: 8 21: l2:3]]
//│ 28: (26: (24: inter:1 25: l1:2) 27: l2:3)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ (
//│   (l2:3^27 ⋅ l2:3^21 ⋅ ɛ, C((ɛ, NoProd()), (l2:3^21 ⋅ ɛ, 2'l2))),
//│   (inter:1^24 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ ɛ, 7'ys)
//│ ) :::: (
//│   (l2:3^27 ⋅ ɛ, C((ɛ, NoProd()), (l2:3^21 ⋅ ɛ, 2'l2))),
//│   (inter:1^24 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ ɛ, 7'ys)
//│ )
//│ (
//│   (l1:2^25 ⋅ l1:2^16 ⋅ ɛ, C((ɛ, NoProd()), (l1:2^16 ⋅ ɛ, 1'l1))),
//│   (inter:1^24 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ ɛ, 7'ys)
//│ ) :::: ((l1:2^25 ⋅ ɛ, C((ɛ, NoProd()), (l1:2^16 ⋅ ɛ, 1'l1))), (inter:1^24 ⋅ inter:1^5 ⋅ ɛ, 7'ys))
//│ ------- defInstance -------
//│ l1:2^25 ⋅ ɛ ==> inter:1^24 ⋅ ɛ:
//│ 	18: [C 1 [C 2 l1:2]]  <-->  12: case xs:4 of {N -> fun ys:5 -> ys:5 | C h:6 t:7 -> fun ys:8 -> [C h:6 ((inter:1 ys:8) t:7)]}
//│ l1:2^25 ⋅ l1:2^16 ⋅ ɛ ==> inter:1^24 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ ɛ:
//│ 	18: [C 1 [C 2 l1:2]]  <-->  12: case xs:4 of {N -> fun ys:5 -> ys:5 | C h:6 t:7 -> fun ys:8 -> [C h:6 ((inter:1 ys:8) t:7)]}
//│ l2:3^27 ⋅ l2:3^21 ⋅ ɛ ==> inter:1^24 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ ɛ:
//│ 	23: [C 9 [C 8 l2:3]]  <-->  12: case xs:4 of {N -> fun ys:5 -> ys:5 | C h:6 t:7 -> fun ys:8 -> [C h:6 ((inter:1 ys:8) t:7)]}
//│ l1:2^25 ⋅ ɛ ==> inter:1^24 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ ɛ:
//│ 	17: [C 2 l1:2]  <-->  12: case xs:4 of {N -> fun ys:5 -> ys:5 | C h:6 t:7 -> fun ys:8 -> [C h:6 ((inter:1 ys:8) t:7)]}
//│ l2:3^27 ⋅ ɛ ==> inter:1^24 ⋅ inter:1^5 ⋅ ɛ:
//│ 	23: [C 9 [C 8 l2:3]]  <-->  12: case xs:4 of {N -> fun ys:5 -> ys:5 | C h:6 t:7 -> fun ys:8 -> [C h:6 ((inter:1 ys:8) t:7)]}
//│ l2:3^27 ⋅ ɛ ==> inter:1^24 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ inter:1^5 ⋅ ɛ:
//│ 	22: [C 8 l2:3]  <-->  12: case xs:4 of {N -> fun ys:5 -> ys:5 | C h:6 t:7 -> fun ys:8 -> [C h:6 ((inter:1 ys:8) t:7)]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def inter:1 = fun xs:4 -> case xs:4 of {N -> fun ys:5 -> ys:5 | C h:6 t:7 -> fun ys:8 -> [C h:6 ((inter:1 ys:8) t:7)]}
//│ def l1:2 = [C 1 [C 2 l1:2]]
//│ def l2:3 = [C 9 [C 8 l2:3]]
//│ def inter'1'24_inter'1'5:11 = fun xs:4 -> xs:4
//│ def l2'3'27:13 = 
//│ 	let h:6 = 9 in 
//│ 	let t:7 = 
//│ 		let h:6 = 8 in 
//│ 		let t:7 = l2'3'27:13 in fun ys:8 -> [C h:6 ((inter'1'24_inter'1'5_inter'1'5_inter'1'5_inter'1'5:15 ys:8) t:7)] 
//│ 	in fun ys:8 -> [C h:6 ((inter'1'24_inter'1'5_inter'1'5:14 ys:8) t:7)]
//│ def inter'1'24:9 = fun xs:4 -> xs:4
//│ def inter'1'24_inter'1'5_inter'1'5_inter'1'5:12 = fun xs:4 -> xs:4
//│ def inter'1'24_inter'1'5_inter'1'5:14 = fun xs:4 -> xs:4
//│ def l1'2'25:10 = 
//│ 	let h:6 = 1 in 
//│ 	let t:7 = 
//│ 		let h:6 = 2 in 
//│ 		let t:7 = l1'2'25:10 in fun ys:8 -> [C h:6 ((inter'1'24_inter'1'5_inter'1'5_inter'1'5:12 ys:8) t:7)] 
//│ 	in fun ys:8 -> [C h:6 ((inter'1'24_inter'1'5:11 ys:8) t:7)]
//│ def inter'1'24_inter'1'5_inter'1'5_inter'1'5_inter'1'5:15 = fun xs:4 -> xs:4
//│ ((inter'1'24:9 l1'2'25:10) l2'3'27:13)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<




// NOTE: only head is handled
fun map(ls) = if ls is
    C(h, t) then f => C(f(h), map(t)(f))
    N then f => N
let l = C(K, N)
map(l)(
    x => if x is
        K then T
)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |f| |=>| |C|(|f|(|h|)|,| |map|(|t|)|(|f|)|)|↵|N| |#then| |f| |=>| |N|←|↵|#let| |l| |#=| |C|(|K|,| |N|)|↵|map|(|l|)|(|→|x| |=>| |#if| |x| |is|→|K| |#then| |T|←|←|↵|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then f, => C (f (h,), map (t,) (f,),); (N) then f, => N›; let l = C (K, N,); map (l,) (x, => if x is ‹(K) then T›,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def map:1 = 15: fun ls:3 -> 14: case 1: ls:3 of {C h:4 t:5 -> 11: fun f:6 -> 10: [C 4: (2: f:6 3: h:4) 9: (7: (5: map:1 6: t:5) 8: f:6)] | N -> 13: fun f:7 -> 12: [N]}
//│ def l:2 = 18: [C 16: [K] 17: [N]]
//│ 26: (21: (19: map:1 20: l:2) 25: fun x:8 -> 24: case 22: x:8 of {K -> 23: [T]})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ((ɛ, (ɛ, 12'x) => ((ɛ, 13'24_matchres))), (map:1^19 ⋅ map:1^5 ⋅ map:1^5 ⋅ ɛ, 5'f)) :::: ((ɛ, (ɛ, 12'x) => ((ɛ, 13'24_matchres))), (map:1^19 ⋅ map:1^5 ⋅ ɛ, 5'f))
//│ ------- defInstance -------
//│ l:2^20 ⋅ ɛ ==> map:1^19 ⋅ map:1^5 ⋅ ɛ:
//│ 	17: [N]  <-->  14: case ls:3 of {C h:4 t:5 -> fun f:6 -> [C (f:6 h:4) ((map:1 t:5) f:6)] | N -> fun f:7 -> [N]}
//│ l:2^20 ⋅ ɛ ==> ɛ:
//│ 	16: [K]  <-->  24: case x:8 of {K -> [T]}
//│ map:1^19 ⋅ map:1^5 ⋅ l:2^20 ⋅ ɛ ==> map:1^19 ⋅ ɛ:
//│ 	16: [K]  <-->  24: case x:8 of {K -> [T]}
//│ l:2^20 ⋅ ɛ ==> map:1^19 ⋅ ɛ:
//│ 	18: [C [K] [N]]  <-->  14: case ls:3 of {C h:4 t:5 -> fun f:6 -> [C (f:6 h:4) ((map:1 t:5) f:6)] | N -> fun f:7 -> [N]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def map:1 = fun ls:3 -> case ls:3 of {C h:4 t:5 -> fun f:6 -> [C (f:6 h:4) ((map:1 t:5) f:6)] | N -> fun f:7 -> [N]}
//│ def l:2 = [C [K] [N]]
//│ def l'2'20:10 = 
//│ 	let h:4 = [T] in 
//│ 	let t:5 = fun f:7 -> [N] in fun f:6 -> [C (f:6 h:4) ((map'1'19_map'1'5:11 t:5) f:6)]
//│ def map'1'19_map'1'5:11 = fun ls:3 -> ls:3
//│ def map'1'19:9 = fun ls:3 -> ls:3
//│ ((map'1'19:9 l'2'20:10) fun x:8 -> x:8)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<



fun map(ls) = if ls is
    C(h, t) then C(
        (if h is
            K then T
            KK then TT
            KKKK then TTTT
        ),
        map(t)
    )
    N then N
let l = C(K, C(KK, C(KKKK, N)))
map(l)
//│ |#fun| |map|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|→|(|#if| |h| |is|→|K| |#then| |T|↵|KK| |#then| |TT|↵|KKKK| |#then| |TTTT|←|↵|)|,|↵|map|(|t|)|←|↵|)|↵|N| |#then| |N|←|↵|#let| |l| |#=| |C|(|K|,| |C|(|KK|,| |C|(|KKKK|,| |N|)|)|)|↵|map|(|l|)|
//│ Parsed: {fun map = ls, => if ls is ‹(C (h, t,)) then C ('(' if h is ‹(K) then T; (KK) then TT; (KKKK) then TTTT›, ')', map (t,),); (N) then N›; let l = C (K, C (KK, C (KKKK, N,),),); map (l,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def map:1 = 13: fun ls:3 -> 12: case 1: ls:3 of {C h:4 t:5 -> 10: [C 6: case 2: h:4 of {K -> 3: [T] | KK -> 4: [TT] | KKKK -> 5: [TTTT]} 9: (7: map:1 8: t:5)] | N -> 11: [N]}
//│ def l:2 = 20: [C 14: [K] 19: [C 15: [KK] 18: [C 16: [KKKK] 17: [N]]]]
//│ 23: (21: map:1 22: l:2)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ------- defInstance -------
//│ l:2^22 ⋅ ɛ ==> map:1^21 ⋅ ɛ:
//│ 	14: [K]  <-->  6: case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ 	20: [C [K] [C [KK] [C [KKKK] [N]]]]  <-->  12: case ls:3 of {C h:4 t:5 -> [C case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]} (map:1 t:5)] | N -> [N]}
//│ l:2^22 ⋅ ɛ ==> map:1^21 ⋅ map:1^7 ⋅ map:1^7 ⋅ map:1^7 ⋅ ɛ:
//│ 	17: [N]  <-->  12: case ls:3 of {C h:4 t:5 -> [C case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]} (map:1 t:5)] | N -> [N]}
//│ l:2^22 ⋅ ɛ ==> map:1^21 ⋅ map:1^7 ⋅ map:1^7 ⋅ ɛ:
//│ 	16: [KKKK]  <-->  6: case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ 	18: [C [KKKK] [N]]  <-->  12: case ls:3 of {C h:4 t:5 -> [C case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]} (map:1 t:5)] | N -> [N]}
//│ l:2^22 ⋅ ɛ ==> map:1^21 ⋅ map:1^7 ⋅ ɛ:
//│ 	15: [KK]  <-->  6: case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]}
//│ 	19: [C [KK] [C [KKKK] [N]]]  <-->  12: case ls:3 of {C h:4 t:5 -> [C case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]} (map:1 t:5)] | N -> [N]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def map:1 = fun ls:3 -> case ls:3 of {C h:4 t:5 -> [C case h:4 of {K -> [T] | KK -> [TT] | KKKK -> [TTTT]} (map:1 t:5)] | N -> [N]}
//│ def l:2 = [C [K] [C [KK] [C [KKKK] [N]]]]
//│ def map'1'21_map'1'7:8 = fun ls:3 -> ls:3
//│ def map'1'21:6 = fun ls:3 -> ls:3
//│ def map'1'21_map'1'7_map'1'7_map'1'7:10 = fun ls:3 -> ls:3
//│ def l'2'22:7 = 
//│ 	let h:4 = [T] in 
//│ 	let t:5 = 
//│ 		let h:4 = [TT] in 
//│ 		let t:5 = 
//│ 			let h:4 = [TTTT] in 
//│ 			let t:5 = [N] in [C h:4 (map'1'21_map'1'7_map'1'7_map'1'7:10 t:5)] 
//│ 		in [C h:4 (map'1'21_map'1'7_map'1'7:9 t:5)] 
//│ 	in [C h:4 (map'1'21_map'1'7:8 t:5)]
//│ def map'1'21_map'1'7_map'1'7:9 = fun ls:3 -> ls:3
//│ (map'1'21:6 l'2'22:7)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<



// NOTE: consumer `c` is used twice in its body, but it fine here
let aa = T(N, L, L)
let bb = T(N, L, L)
let t = T(K, aa, bb)
fun c(x) = if x is
    T(n, l, r) then T(
        (if n is
            K then KK
            N then NN
        ),
        c(l),
        c(r)
    )
    L then LL
c(t)
//│ |#let| |aa| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |bb| |#=| |T|(|N|,| |L|,| |L|)|↵|#let| |t| |#=| |T|(|K|,| |aa|,| |bb|)|↵|#fun| |c|(|x|)| |#=| |#if| |x| |is|→|T|(|n|,| |l|,| |r|)| |#then| |T|(|→|(|#if| |n| |is|→|K| |#then| |KK|↵|N| |#then| |NN|←|↵|)|,|↵|c|(|l|)|,|↵|c|(|r|)|←|↵|)|↵|L| |#then| |LL|←|↵|c|(|t|)|
//│ Parsed: {let aa = T (N, L, L,); let bb = T (N, L, L,); let t = T (K, aa, bb,); fun c = x, => if x is ‹(T (n, l, r,)) then T ('(' if n is ‹(K) then KK; (N) then NN›, ')', c (l,), c (r,),); (L) then LL›; c (t,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def aa:1 = 4: [T 1: [N] 2: [L] 3: [L]]
//│ def bb:2 = 8: [T 5: [N] 6: [L] 7: [L]]
//│ def t:3 = 12: [T 9: [K] 10: aa:1 11: bb:2]
//│ def c:4 = 27: fun x:5 -> 26: case 13: x:5 of {T n:6 l:7 r:8 -> 24: [T 17: case 14: n:6 of {K -> 15: [KK] | N -> 16: [NN]} 20: (18: c:4 19: l:7) 23: (21: c:4 22: r:8)] | L -> 25: [LL]}
//│ 30: (28: c:4 29: t:3)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ------- defInstance -------
//│ t:3^29 ⋅ ɛ ==> c:4^28 ⋅ ɛ:
//│ 	12: [T [K] aa:1 bb:2]  <-->  26: case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ 	9: [K]  <-->  17: case n:6 of {K -> [KK] | N -> [NN]}
//│ t:3^29 ⋅ aa:1^10 ⋅ ɛ ==> c:4^28 ⋅ c:4^18 ⋅ c:4^21 ⋅ ɛ:
//│ 	3: [L]  <-->  26: case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ t:3^29 ⋅ bb:2^11 ⋅ ɛ ==> c:4^28 ⋅ c:4^21 ⋅ c:4^18 ⋅ ɛ:
//│ 	6: [L]  <-->  26: case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ t:3^29 ⋅ bb:2^11 ⋅ ɛ ==> c:4^28 ⋅ c:4^21 ⋅ ɛ:
//│ 	5: [N]  <-->  17: case n:6 of {K -> [KK] | N -> [NN]}
//│ 	8: [T [N] [L] [L]]  <-->  26: case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ t:3^29 ⋅ aa:1^10 ⋅ ɛ ==> c:4^28 ⋅ c:4^18 ⋅ ɛ:
//│ 	1: [N]  <-->  17: case n:6 of {K -> [KK] | N -> [NN]}
//│ 	4: [T [N] [L] [L]]  <-->  26: case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ t:3^29 ⋅ aa:1^10 ⋅ ɛ ==> c:4^28 ⋅ c:4^18 ⋅ c:4^18 ⋅ ɛ:
//│ 	2: [L]  <-->  26: case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ t:3^29 ⋅ bb:2^11 ⋅ ɛ ==> c:4^28 ⋅ c:4^21 ⋅ c:4^21 ⋅ ɛ:
//│ 	7: [L]  <-->  26: case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def aa:1 = [T [N] [L] [L]]
//│ def bb:2 = [T [N] [L] [L]]
//│ def t:3 = [T [K] aa:1 bb:2]
//│ def c:4 = fun x:5 -> case x:5 of {T n:6 l:7 r:8 -> [T case n:6 of {K -> [KK] | N -> [NN]} (c:4 l:7) (c:4 r:8)] | L -> [LL]}
//│ def c'4'28_c'4'18:11 = fun x:5 -> x:5
//│ def c'4'28_c'4'21_c'4'18:14 = fun x:5 -> x:5
//│ def c'4'28_c'4'21_c'4'21:15 = fun x:5 -> x:5
//│ def c'4'28:9 = fun x:5 -> x:5
//│ def t'3'29_aa'1'10:16 = 
//│ 	let n:6 = [NN] in 
//│ 	let l:7 = [LL] in 
//│ 	let r:8 = [LL] in [T n:6 (c'4'28_c'4'18_c'4'18:17 l:7) (c'4'28_c'4'18_c'4'21:18 r:8)]
//│ def c'4'28_c'4'18_c'4'21:18 = fun x:5 -> x:5
//│ def c'4'28_c'4'18_c'4'18:17 = fun x:5 -> x:5
//│ def t'3'29:10 = 
//│ 	let n:6 = [KK] in 
//│ 	let l:7 = t'3'29_aa'1'10:16 in 
//│ 	let r:8 = t'3'29_bb'2'11:13 in [T n:6 (c'4'28_c'4'18:11 l:7) (c'4'28_c'4'21:12 r:8)]
//│ def c'4'28_c'4'21:12 = fun x:5 -> x:5
//│ def t'3'29_bb'2'11:13 = 
//│ 	let n:6 = [NN] in 
//│ 	let l:7 = [LL] in 
//│ 	let r:8 = [LL] in [T n:6 (c'4'28_c'4'21_c'4'18:14 l:7) (c'4'28_c'4'21_c'4'21:15 r:8)]
//│ (c'4'28:9 t'3'29:10)
//│ <<<<<<<<<< Rewritten <<<<<<<<<<




fun sum(ls) = if ls is
    C(h, t) then S(N, sum(t))
    N then N
fun mapa(lsa) = if lsa is
    C(ha, ta) then C(primitive(ha), mapa(ta))
    N then N
fun mapb(lsb) = if lsb is
    C(hb, tb) then C(primitive(hb), mapb(tb))
    N then N
sum(mapa(mapb(primitive)))
//│ |#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |S|(|N|,| |sum|(|t|)|)|↵|N| |#then| |N|←|↵|#fun| |mapa|(|lsa|)| |#=| |#if| |lsa| |is|→|C|(|ha|,| |ta|)| |#then| |C|(|primitive|(|ha|)|,| |mapa|(|ta|)|)|↵|N| |#then| |N|←|↵|#fun| |mapb|(|lsb|)| |#=| |#if| |lsb| |is|→|C|(|hb|,| |tb|)| |#then| |C|(|primitive|(|hb|)|,| |mapb|(|tb|)|)|↵|N| |#then| |N|←|↵|sum|(|mapa|(|mapb|(|primitive|)|)|)|
//│ Parsed: {fun sum = ls, => if ls is ‹(C (h, t,)) then S (N, sum (t,),); (N) then N›; fun mapa = lsa, => if lsa is ‹(C (ha, ta,)) then C (primitive (ha,), mapa (ta,),); (N) then N›; fun mapb = lsb, => if lsb is ‹(C (hb, tb,)) then C (primitive (hb,), mapb (tb,),); (N) then N›; sum (mapa (mapb (primitive,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def sum:1 = 9: fun ls:4 -> 8: case 1: ls:4 of {C h:5 t:6 -> 6: [S 2: [N] 5: (3: sum:1 4: t:6)] | N -> 7: [N]}
//│ def mapa:2 = 20: fun lsa:7 -> 19: case 10: lsa:7 of {C ha:8 ta:9 -> 17: [C 13: (11: primitive:0 12: ha:8) 16: (14: mapa:2 15: ta:9)] | N -> 18: [N]}
//│ def mapb:3 = 31: fun lsb:10 -> 30: case 21: lsb:10 of {C hb:11 tb:12 -> 28: [C 24: (22: primitive:0 23: hb:11) 27: (25: mapb:3 26: tb:12)] | N -> 29: [N]}
//│ 38: (32: sum:1 37: (33: mapa:2 36: (34: mapb:3 35: primitive:0)))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ (
//│   (mapa:2^33 ⋅ mapa:2^14 ⋅ mapa:2^14 ⋅ ɛ, C((ɛ, 11'13_callres), (ɛ, 12'16_callres))),
//│   (sum:1^32 ⋅ sum:1^3 ⋅ sum:1^3 ⋅ ɛ, 3'ls)
//│ ) :::: (
//│   (mapa:2^33 ⋅ mapa:2^14 ⋅ ɛ, C((ɛ, 11'13_callres), (ɛ, 12'16_callres))),
//│   (sum:1^32 ⋅ sum:1^3 ⋅ ɛ, 3'ls)
//│ )
//│ (
//│   (mapb:3^34 ⋅ mapb:3^25 ⋅ mapb:3^25 ⋅ ɛ, C((ɛ, 17'24_callres), (ɛ, 18'27_callres))),
//│   (mapa:2^33 ⋅ mapa:2^14 ⋅ mapa:2^14 ⋅ ɛ, 8'lsa)
//│ ) :::: (
//│   (mapb:3^34 ⋅ mapb:3^25 ⋅ ɛ, C((ɛ, 17'24_callres), (ɛ, 18'27_callres))),
//│   (mapa:2^33 ⋅ mapa:2^14 ⋅ ɛ, 8'lsa)
//│ )
//│ ------- defInstance -------
//│ mapa:2^33 ⋅ ɛ ==> sum:1^32 ⋅ ɛ:
//│ 	17: [C (primitive:0 ha:8) (mapa:2 ta:9)]  <-->  8: case ls:4 of {C h:5 t:6 -> [S [N] (sum:1 t:6)] | N -> [N]}
//│ 	18: [N]  <-->  8: case ls:4 of {C h:5 t:6 -> [S [N] (sum:1 t:6)] | N -> [N]}
//│ mapa:2^33 ⋅ mapa:2^14 ⋅ mapa:2^14 ⋅ ɛ ==> sum:1^32 ⋅ sum:1^3 ⋅ sum:1^3 ⋅ ɛ:
//│ 	18: [N]  <-->  8: case ls:4 of {C h:5 t:6 -> [S [N] (sum:1 t:6)] | N -> [N]}
//│ mapb:3^34 ⋅ ɛ ==> mapa:2^33 ⋅ ɛ:
//│ 	28: [C (primitive:0 hb:11) (mapb:3 tb:12)]  <-->  19: case lsa:7 of {C ha:8 ta:9 -> [C (primitive:0 ha:8) (mapa:2 ta:9)] | N -> [N]}
//│ 	29: [N]  <-->  19: case lsa:7 of {C ha:8 ta:9 -> [C (primitive:0 ha:8) (mapa:2 ta:9)] | N -> [N]}
//│ mapb:3^34 ⋅ mapb:3^25 ⋅ ɛ ==> mapa:2^33 ⋅ mapa:2^14 ⋅ ɛ:
//│ 	28: [C (primitive:0 hb:11) (mapb:3 tb:12)]  <-->  19: case lsa:7 of {C ha:8 ta:9 -> [C (primitive:0 ha:8) (mapa:2 ta:9)] | N -> [N]}
//│ 	29: [N]  <-->  19: case lsa:7 of {C ha:8 ta:9 -> [C (primitive:0 ha:8) (mapa:2 ta:9)] | N -> [N]}
//│ mapb:3^34 ⋅ mapb:3^25 ⋅ mapb:3^25 ⋅ ɛ ==> mapa:2^33 ⋅ mapa:2^14 ⋅ mapa:2^14 ⋅ ɛ:
//│ 	29: [N]  <-->  19: case lsa:7 of {C ha:8 ta:9 -> [C (primitive:0 ha:8) (mapa:2 ta:9)] | N -> [N]}
//│ mapa:2^33 ⋅ mapa:2^14 ⋅ ɛ ==> sum:1^32 ⋅ sum:1^3 ⋅ ɛ:
//│ 	17: [C (primitive:0 ha:8) (mapa:2 ta:9)]  <-->  8: case ls:4 of {C h:5 t:6 -> [S [N] (sum:1 t:6)] | N -> [N]}
//│ 	18: [N]  <-->  8: case ls:4 of {C h:5 t:6 -> [S [N] (sum:1 t:6)] | N -> [N]}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def sum:1 = fun ls:4 -> case ls:4 of {C h:5 t:6 -> [S [N] (sum:1 t:6)] | N -> [N]}
//│ def mapa:2 = fun lsa:7 -> case lsa:7 of {C ha:8 ta:9 -> [C (primitive:0 ha:8) (mapa:2 ta:9)] | N -> [N]}
//│ def mapb:3 = fun lsb:10 -> case lsb:10 of {C hb:11 tb:12 -> [C (primitive:0 hb:11) (mapb:3 tb:12)] | N -> [N]}
//│ def sum'1'32:13 = fun ls:4 -> ls:4
//│ def mapb'3'34_mapb'3'25:18 = fun lsb:10 -> case lsb:10 of {C hb:11 tb:12 -> 
//│ 	let ha:8 = (primitive:0 hb:11) in 
//│ 	let ta:9 = (mapb'3'34_mapb'3'25:18 tb:12) in 
//│ 	let h:5 = (primitive:0 ha:8) in 
//│ 	let t:6 = (mapa'2'33_mapa'2'14:17 ta:9) in [S [N] (sum'1'32_sum'1'3:16 t:6)] | N -> [N]}
//│ def mapa'2'33_mapa'2'14:17 = fun lsa:7 -> lsa:7
//│ def mapa'2'33:14 = fun lsa:7 -> lsa:7
//│ def sum'1'32_sum'1'3:16 = fun ls:4 -> ls:4
//│ def mapb'3'34:15 = fun lsb:10 -> case lsb:10 of {C hb:11 tb:12 -> 
//│ 	let ha:8 = (primitive:0 hb:11) in 
//│ 	let ta:9 = (mapb'3'34_mapb'3'25:18 tb:12) in 
//│ 	let h:5 = (primitive:0 ha:8) in 
//│ 	let t:6 = (mapa'2'33_mapa'2'14:17 ta:9) in [S [N] (sum'1'32_sum'1'3:16 t:6)] | N -> [N]}
//│ (sum'1'32:13 (mapa'2'33:14 (mapb'3'34:15 primitive:0)))
//│ <<<<<<<<<< Rewritten <<<<<<<<<<


fun last(ys) = if ys is
    N then x => x
    C(h, t) then x => last(t)(h)
fun lastDrive(xs) = if xs is
    N then None
    C(hh, tt) then Some(last(tt)(hh))
lastDrive(C(1, C(2, N)))
//│ |#fun| |last|(|ys|)| |#=| |#if| |ys| |is|→|N| |#then| |x| |=>| |x|↵|C|(|h|,| |t|)| |#then| |x| |=>| |last|(|t|)|(|h|)|←|↵|#fun| |lastDrive|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |None|↵|C|(|hh|,| |tt|)| |#then| |Some|(|last|(|tt|)|(|hh|)|)|←|↵|lastDrive|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun last = ys, => if ys is ‹(N) then x, => x; (C (h, t,)) then x, => last (t,) (h,)›; fun lastDrive = xs, => if xs is ‹(N) then None; (C (hh, tt,)) then Some (last (tt,) (hh,),)›; lastDrive (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ def last:1 = 11: fun ys:3 -> 10: case 1: ys:3 of {N -> 3: fun x:4 -> 2: x:4 | C h:5 t:6 -> 9: fun x:7 -> 8: (6: (4: last:1 5: t:6) 7: h:5)}
//│ def lastDrive:2 = 21: fun xs:8 -> 20: case 12: xs:8 of {N -> 13: [None] | C hh:9 tt:10 -> 19: [Some 18: (16: (14: last:1 15: tt:10) 17: hh:9)]}
//│ 28: (22: lastDrive:2 27: [C 23: 1 26: [C 24: 2 25: [N]]])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ ------- recursive -------
//│ ------- defInstance -------
//│ ɛ ==> lastDrive:2^22 ⋅ last:1^14 ⋅ last:1^4 ⋅ ɛ:
//│ 	25: [N]  <-->  10: case ys:3 of {N -> fun x:4 -> x:4 | C h:5 t:6 -> fun x:7 -> ((last:1 t:6) h:5)}
//│ ɛ ==> lastDrive:2^22 ⋅ ɛ:
//│ 	27: [C 1 [C 2 [N]]]  <-->  20: case xs:8 of {N -> [None] | C hh:9 tt:10 -> [Some ((last:1 tt:10) hh:9)]}
//│ ɛ ==> lastDrive:2^22 ⋅ last:1^14 ⋅ ɛ:
//│ 	26: [C 2 [N]]  <-->  10: case ys:3 of {N -> fun x:4 -> x:4 | C h:5 t:6 -> fun x:7 -> ((last:1 t:6) h:5)}
//│ 
//│ >>>>>>>>>> Rewritten >>>>>>>>>>
//│ def last:1 = fun ys:3 -> case ys:3 of {N -> fun x:4 -> x:4 | C h:5 t:6 -> fun x:7 -> ((last:1 t:6) h:5)}
//│ def lastDrive:2 = fun xs:8 -> case xs:8 of {N -> [None] | C hh:9 tt:10 -> [Some ((last:1 tt:10) hh:9)]}
//│ def lastDrive'2'22_last'1'14:12 = fun ys:3 -> ys:3
//│ def lastDrive'2'22_last'1'14_last'1'4:13 = fun ys:3 -> ys:3
//│ def lastDrive'2'22:11 = fun xs:8 -> xs:8
//│ (lastDrive'2'22:11 
//│ 	let hh:9 = 1 in 
//│ 	let tt:10 = 
//│ 		let h:5 = 2 in 
//│ 		let t:6 = fun x:4 -> x:4 in fun x:7 -> ((lastDrive'2'22_last'1'14_last'1'4:13 t:6) h:5) 
//│ 	in [Some ((lastDrive'2'22_last'1'14:12 tt:10) hh:9)])
//│ <<<<<<<<<< Rewritten <<<<<<<<<<
