:NewParser
:ParseOnly

:lhInHaskell
:lhGenOCaml
tak x y z = if not(y < x) then z
       else tak (tak (x-1) y z) (tak (y-1) z x) (tak (z-1) x y)
testTak_nofib n = tak 31 16 8
testTak_nofib $ primId 0
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testTak_nofib₀^721(primId⁰(0))
//│ def tak₀(_lh_tak_arg1¹, _lh_tak_arg2¹, _lh_tak_arg3¹) = if not⁰((_lh_tak_arg2¹ < _lh_tak_arg1¹)) then _lh_tak_arg3¹ else tak₀^680(tak₀^681((_lh_tak_arg1¹ - 1), _lh_tak_arg2¹, _lh_tak_arg3¹), tak₀^693((_lh_tak_arg2¹ - 1), _lh_tak_arg3¹, _lh_tak_arg1¹), tak₀^705((_lh_tak_arg3¹ - 1), _lh_tak_arg1¹, _lh_tak_arg2¹))
//│ def testTak_nofib₀(_lh_testTak_nofib_arg1¹) = tak₀^664(31, 16, 8)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec tak_d0 _lh_tak_arg1_1 _lh_tak_arg2_1 _lh_tak_arg3_1 =
//│ 		  (if (not (_lh_tak_arg2_1 < _lh_tak_arg1_1)) then
//│ 		    _lh_tak_arg3_1
//│ 		  else
//│ 		    (((tak_d0 (((tak_d0 (_lh_tak_arg1_1 - 1)) _lh_tak_arg2_1) _lh_tak_arg3_1)) (((tak_d0 (_lh_tak_arg2_1 - 1)) _lh_tak_arg3_1) _lh_tak_arg1_1)) (((tak_d0 (_lh_tak_arg3_1 - 1)) _lh_tak_arg1_1) _lh_tak_arg2_1)))
//│ 		and testTak_nofib_d0 _lh_testTak_nofib_arg1_1 =
//│ 		  (((tak_d0 31) 16) 8);;
//│ 		(testTak_nofib_d0 0)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testTak_nofib₀^721] (hopeless to continue)
//│ 	[testTak_nofib₀^721 · tak₀^664] (using original def)
//│ 		[testTak_nofib₀^721 · tak₀^664 · tak₀^680] ---> [testTak_nofib₀^721 · tak₀^664] (using original def)
//│ 		[testTak_nofib₀^721 · tak₀^664 · tak₀^681] ---> [testTak_nofib₀^721 · tak₀^664] (using original def)
//│ 		[testTak_nofib₀^721 · tak₀^664 · tak₀^693] ---> [testTak_nofib₀^721 · tak₀^664] (using original def)
//│ 		[testTak_nofib₀^721 · tak₀^664 · tak₀^705] ---> [testTak_nofib₀^721 · tak₀^664] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testTak_nofib₀₀(primId⁰(0))
//│ def testTak_nofib₀₀(_lh_testTak_nofib_arg1¹) = 
//│ 	tak₀₀(31, 16, 8)
//│ 	where
//│ 	def tak₀₀(_lh_tak_arg1¹, _lh_tak_arg2¹, _lh_tak_arg3¹) = 
//│ 		if not⁰((_lh_tak_arg2¹ < _lh_tak_arg1¹)) then _lh_tak_arg3¹ else tak₀₀(tak₀₀((_lh_tak_arg1¹ - 1), _lh_tak_arg2¹, _lh_tak_arg3¹), tak₀₀((_lh_tak_arg2¹ - 1), _lh_tak_arg3¹, _lh_tak_arg1¹), tak₀₀((_lh_tak_arg3¹ - 1), _lh_tak_arg1¹, _lh_tak_arg2¹))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testTak_nofib₀₀(primId⁰(0))
//│ def testTak_nofib₀₀(_lh_testTak_nofib_arg1²) = 
//│ 	tak₀₀(31, 16, 8)
//│ 	where
//│ 	def tak₀₀(_lh_tak_arg1², _lh_tak_arg2², _lh_tak_arg3²) = 
//│ 		if not⁰((_lh_tak_arg2² < _lh_tak_arg1²)) then _lh_tak_arg3² else tak₀₀(tak₀₀((_lh_tak_arg1² - 1), _lh_tak_arg2², _lh_tak_arg3²), tak₀₀((_lh_tak_arg2² - 1), _lh_tak_arg3², _lh_tak_arg1²), tak₀₀((_lh_tak_arg3² - 1), _lh_tak_arg1², _lh_tak_arg2²))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
