:NewParser
:ParseOnly

:lhInHaskell
:lhGenOCaml
tak x y z = if not(y < x) then z
       else tak (tak (x-1) y z) (tak (y-1) z x) (tak (z-1) x y)
testTak_nofib n = tak 31 16 8
testTak_nofib $ primId 0
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testTak_nofib_₀^721(primId⁰(0))
//│ def tak_₀(_lh_tak_arg1¹, _lh_tak_arg2¹, _lh_tak_arg3¹) = if not⁰((_lh_tak_arg2¹ < _lh_tak_arg1¹)) then _lh_tak_arg3¹ else tak_₀^680(tak_₀^681((_lh_tak_arg1¹ - 1), _lh_tak_arg2¹, _lh_tak_arg3¹), tak_₀^693((_lh_tak_arg2¹ - 1), _lh_tak_arg3¹, _lh_tak_arg1¹), tak_₀^705((_lh_tak_arg3¹ - 1), _lh_tak_arg1¹, _lh_tak_arg2¹))
//│ def testTak_nofib_₀(_lh_testTak_nofib_arg1¹) = tak_₀^664(31, 16, 8)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec tak__d0 _lh_tak_arg1_1 _lh_tak_arg2_1 _lh_tak_arg3_1 =
//│ 		  (if (not (_lh_tak_arg2_1 < _lh_tak_arg1_1)) then
//│ 		    _lh_tak_arg3_1
//│ 		  else
//│ 		    (((tak__d0 (((tak__d0 (_lh_tak_arg1_1 - 1)) _lh_tak_arg2_1) _lh_tak_arg3_1)) (((tak__d0 (_lh_tak_arg2_1 - 1)) _lh_tak_arg3_1) _lh_tak_arg1_1)) (((tak__d0 (_lh_tak_arg3_1 - 1)) _lh_tak_arg1_1) _lh_tak_arg2_1)))
//│ 		and testTak_nofib__d0 _lh_testTak_nofib_arg1_1 =
//│ 		  (((tak__d0 31) 16) 8);;
//│ 		(testTak_nofib__d0 0)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testTak_nofib_₀^721] (hopeless to continue)
//│ 	[testTak_nofib_₀^721 · tak_₀^664] (using original def)
//│ 		[testTak_nofib_₀^721 · tak_₀^664 · tak_₀^680] ---> [testTak_nofib_₀^721 · tak_₀^664] (using original def)
//│ 		[testTak_nofib_₀^721 · tak_₀^664 · tak_₀^681] ---> [testTak_nofib_₀^721 · tak_₀^664] (using original def)
//│ 		[testTak_nofib_₀^721 · tak_₀^664 · tak_₀^693] ---> [testTak_nofib_₀^721 · tak_₀^664] (using original def)
//│ 		[testTak_nofib_₀^721 · tak_₀^664 · tak_₀^705] ---> [testTak_nofib_₀^721 · tak_₀^664] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testTak_nofib_₀_₀(primId⁰(0))
//│ def testTak_nofib_₀_₀(_lh_testTak_nofib_arg1¹) = 
//│ 	tak_₀_₀(31, 16, 8)
//│ 	where
//│ 	def tak_₀_₀(_lh_tak_arg1¹, _lh_tak_arg2¹, _lh_tak_arg3¹) = 
//│ 		if not⁰((_lh_tak_arg2¹ < _lh_tak_arg1¹)) then _lh_tak_arg3¹ else tak_₀_₀(tak_₀_₀((_lh_tak_arg1¹ - 1), _lh_tak_arg2¹, _lh_tak_arg3¹), tak_₀_₀((_lh_tak_arg2¹ - 1), _lh_tak_arg3¹, _lh_tak_arg1¹), tak_₀_₀((_lh_tak_arg3¹ - 1), _lh_tak_arg1¹, _lh_tak_arg2¹))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testTak_nofib_₀_₀(primId⁰(0))
//│ def testTak_nofib_₀_₀(_lh_testTak_nofib_arg1²) = 
//│ 	tak_₀_₀(31, 16, 8)
//│ 	where
//│ 	def tak_₀_₀(_lh_tak_arg1², _lh_tak_arg2², _lh_tak_arg3²) = 
//│ 		if not⁰((_lh_tak_arg2² < _lh_tak_arg1²)) then _lh_tak_arg3² else tak_₀_₀(tak_₀_₀((_lh_tak_arg1² - 1), _lh_tak_arg2², _lh_tak_arg3²), tak_₀_₀((_lh_tak_arg2² - 1), _lh_tak_arg3², _lh_tak_arg1²), tak_₀_₀((_lh_tak_arg3² - 1), _lh_tak_arg1², _lh_tak_arg2²))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
