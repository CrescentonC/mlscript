:NewParser
:ParseOnly

// isdivs :: Int  -> Int -> Bool
// isdivs n x = mod x n /= 0

// the_filter :: [Int] -> [Int]
// the_filter (n:ns) = filter (isdivs n) ns

// prime :: Int -> Int
// prime n = map head (iterate the_filter [2..n*n]) !! n

// main = forM_ [1..100] $ const $ do
// 	[arg] <- getArgs
// 	print $ prime (read arg)


:lhInHaskell
:lhGenOCaml
isdivs n x = (x `mod` n) /= 0
the_filter (n:ns) = filter (isdivs n) ns
prime n = atIndex_lz n (map_lz head (iterate the_filter [2..(n*n)]))
testPrime_nofib n = prime n
testPrime_nofib $ primId 100
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testPrime_nofib_lh_₁^156(primId⁰(100))
//│ def atIndex_lz_lh_₁(n⁰, ls²) = if (n⁰ < 0) then error⁰ else case force⁰(ls²) of {
//│ 	LH_C h² t² => if (n⁰ == 0) then h² else atIndex_lz_lh_₁^84((n⁰ - 1), t²)
//│ 	| LH_N  => error⁰}
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^39((a⁰ + 1), b⁰)] else [LH_N]
//│ def filter_lh_₁(f⁰, ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => if f⁰(h⁰) then [LH_C h⁰ filter_lh_₁^17(f⁰, t⁰)] else filter_lh_₁^23(f⁰, t⁰)
//│ 	| LH_N  => [LH_N]}
//│ def head_lh_₁(ls¹) = case ls¹ of {
//│ 	LH_C h¹ t¹ => h¹
//│ 	| LH_N  => error⁰}
//│ def isdivs_lh_₁(_lh_isdivs_arg1⁰, _lh_isdivs_arg2⁰) = ((_lh_isdivs_arg2⁰ % _lh_isdivs_arg1⁰) /= 0)
//│ def iterate_lh_₁(f¹, x⁰) = lazy⁰([LH_C x⁰ iterate_lh_₁^101(f¹, f¹(x⁰))])
//│ def map_lz_lh_₁(f², ls³) = lazy⁰(case force⁰(ls³) of {
//│ 	LH_C h³ t³ => [LH_C f²(h³) map_lz_lh_₁^119(f², t³)]
//│ 	| LH_N  => [LH_N]})
//│ def prime_lh_₁(_lh_prime_arg1⁰) = atIndex_lz_lh_₁^130(_lh_prime_arg1⁰, map_lz_lh_₁^133(head_lh_₁^134, iterate_lh_₁^136(the_filter_lh_₁^137, enumFromTo_lh_₁^139(2, (_lh_prime_arg1⁰ * _lh_prime_arg1⁰)))))
//│ def testPrime_nofib_lh_₁(_lh_testPrime_nofib_arg1⁰) = prime_lh_₁^152(_lh_testPrime_nofib_arg1⁰)
//│ def the_filter_lh_₁(_lh_the_filter_arg1⁰) = case _lh_the_filter_arg1⁰ of {
//│ 	LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh_₁^54(isdivs_lh_₁^55(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰)
//│ 	| _  => error⁰}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec map_lz_lh__d1 f_2 ls_3 =
//│ 		  (lazy (match (Lazy.force ls_3) with
//│ 		    | `LH_C(h_3, t_3) -> 
//│ 		      (`LH_C((f_2 h_3), ((map_lz_lh__d1 f_2) t_3)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)));;
//│ 		let rec atIndex_lz_lh__d1 n_0 ls_2 =
//│ 		  (if (n_0 < 0) then
//│ 		    (failwith "error")
//│ 		  else
//│ 		    (match (Lazy.force ls_2) with
//│ 		      | `LH_C(h_2, t_2) -> 
//│ 		        (if (n_0 = 0) then
//│ 		          h_2
//│ 		        else
//│ 		          ((atIndex_lz_lh__d1 (n_0 - 1)) t_2))
//│ 		      | `LH_N -> 
//│ 		        (failwith "error")));;
//│ 		let rec enumFromTo_lh__d1 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d1 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec iterate_lh__d1 f_1 x_0 =
//│ 		  (lazy (`LH_C(x_0, ((iterate_lh__d1 f_1) (f_1 x_0)))));;
//│ 		let rec filter_lh__d1 f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (if (f_0 h_0) then
//│ 		        (`LH_C(h_0, ((filter_lh__d1 f_0) t_0)))
//│ 		      else
//│ 		        ((filter_lh__d1 f_0) t_0))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec isdivs_lh__d1 _lh_isdivs_arg1_0 _lh_isdivs_arg2_0 =
//│ 		  ((_lh_isdivs_arg2_0 mod _lh_isdivs_arg1_0) <> 0);;
//│ 		let rec the_filter_lh__d1 _lh_the_filter_arg1_0 =
//│ 		  (match _lh_the_filter_arg1_0 with
//│ 		    | `LH_C(_lh_the_filter_LH_C_0_0, _lh_the_filter_LH_C_1_0) -> 
//│ 		      ((filter_lh__d1 (isdivs_lh__d1 _lh_the_filter_LH_C_0_0)) _lh_the_filter_LH_C_1_0)
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec head_lh__d1 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      h_1
//│ 		    | `LH_N -> 
//│ 		      (failwith "error"));;
//│ 		let rec prime_lh__d1 _lh_prime_arg1_0 =
//│ 		  ((atIndex_lz_lh__d1 _lh_prime_arg1_0) ((map_lz_lh__d1 head_lh__d1) ((iterate_lh__d1 the_filter_lh__d1) ((enumFromTo_lh__d1 2) (_lh_prime_arg1_0 * _lh_prime_arg1_0)))));;
//│ 		let rec testPrime_nofib_lh__d1 _lh_testPrime_nofib_arg1_0 =
//│ 		  (prime_lh__d1 _lh_testPrime_nofib_arg1_0);;
//│ 		(testPrime_nofib_lh__d1 100)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h⁰ filter_lh_₁(f⁰, t⁰)]: 22 --->
//│ 	DeadCodeCons
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => if f⁰(h⁰) then [LH_C h⁰ filter_lh_₁(f⁰, t⁰)] else filter_lh_₁(f⁰, t⁰) | LH_N  => [LH_N]}: 30
//│ 	case _lh_the_filter_arg1⁰ of {LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh_₁(isdivs_lh_₁(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰) | _  => error⁰}: 62
//│ 	case ls¹ of {LH_C h¹ t¹ => h¹ | LH_N  => error⁰}: 67
//│ [LH_N]: 29 --->
//│ 	DeadCodeCons
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => if f⁰(h⁰) then [LH_C h⁰ filter_lh_₁(f⁰, t⁰)] else filter_lh_₁(f⁰, t⁰) | LH_N  => [LH_N]}: 30
//│ 	case _lh_the_filter_arg1⁰ of {LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh_₁(isdivs_lh_₁(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰) | _  => error⁰}: 62
//│ 	case ls¹ of {LH_C h¹ t¹ => h¹ | LH_N  => error⁰}: 67
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 48 --->
//│ 	DeadCodeCons
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => if f⁰(h⁰) then [LH_C h⁰ filter_lh_₁(f⁰, t⁰)] else filter_lh_₁(f⁰, t⁰) | LH_N  => [LH_N]}: 30
//│ 	case _lh_the_filter_arg1⁰ of {LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh_₁(isdivs_lh_₁(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰) | _  => error⁰}: 62
//│ 	case ls¹ of {LH_C h¹ t¹ => h¹ | LH_N  => error⁰}: 67
//│ [LH_N]: 49 --->
//│ 	DeadCodeCons
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => if f⁰(h⁰) then [LH_C h⁰ filter_lh_₁(f⁰, t⁰)] else filter_lh_₁(f⁰, t⁰) | LH_N  => [LH_N]}: 30
//│ 	case _lh_the_filter_arg1⁰ of {LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh_₁(isdivs_lh_₁(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰) | _  => error⁰}: 62
//│ 	case ls¹ of {LH_C h¹ t¹ => h¹ | LH_N  => error⁰}: 67
//│ [LH_C x⁰ iterate_lh_₁(f¹, f¹(x⁰))]: 108 --->
//│ 	case force⁰(ls³) of {LH_C h³ t³ => [LH_C f²(h³) map_lz_lh_₁(f², t³)] | LH_N  => [LH_N]}: 126
//│ [LH_C f²(h³) map_lz_lh_₁(f², t³)]: 124 --->
//│ 	case force⁰(ls²) of {LH_C h² t² => if (n⁰ == 0) then h² else atIndex_lz_lh_₁((n⁰ - 1), t²) | LH_N  => error⁰}: 95
//│ [LH_N]: 125 --->
//│ 	case force⁰(ls²) of {LH_C h² t² => if (n⁰ == 0) then h² else atIndex_lz_lh_₁((n⁰ - 1), t²) | LH_N  => error⁰}: 95
//│ ------------------
//│ case ls⁰ of {LH_C h⁰ t⁰ => if f⁰(h⁰) then [LH_C h⁰ filter_lh_₁(f⁰, t⁰)] else filter_lh_₁(f⁰, t⁰) | LH_N  => [LH_N]}: 30 --->
//│ 	[LH_C h⁰ filter_lh_₁(f⁰, t⁰)]: 22
//│ 	[LH_N]: 29
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 48
//│ 	[LH_N]: 49
//│ case _lh_the_filter_arg1⁰ of {LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh_₁(isdivs_lh_₁(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰) | _  => error⁰}: 62 --->
//│ 	[LH_C h⁰ filter_lh_₁(f⁰, t⁰)]: 22
//│ 	[LH_N]: 29
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 48
//│ 	[LH_N]: 49
//│ case ls¹ of {LH_C h¹ t¹ => h¹ | LH_N  => error⁰}: 67 --->
//│ 	[LH_C h⁰ filter_lh_₁(f⁰, t⁰)]: 22
//│ 	[LH_N]: 29
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 48
//│ 	[LH_N]: 49
//│ case force⁰(ls²) of {LH_C h² t² => if (n⁰ == 0) then h² else atIndex_lz_lh_₁((n⁰ - 1), t²) | LH_N  => error⁰}: 95 --->
//│ 	[LH_C f²(h³) map_lz_lh_₁(f², t³)]: 124
//│ 	[LH_N]: 125
//│ case force⁰(ls³) of {LH_C h³ t³ => [LH_C f²(h³) map_lz_lh_₁(f², t³)] | LH_N  => [LH_N]}: 126 --->
//│ 	[LH_C x⁰ iterate_lh_₁(f¹, f¹(x⁰))]: 108
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C x⁰ iterate_lh_₁(f¹, f¹(x⁰))]: 108 --->
//│ 	case force⁰(ls³) of {LH_C h³ t³ => [LH_C f²(h³) map_lz_lh_₁(f², t³)] | LH_N  => [LH_N]}: 126
//│ [LH_C f²(h³) map_lz_lh_₁(f², t³)]: 124 --->
//│ 	case force⁰(ls²) of {LH_C h² t² => if (n⁰ == 0) then h² else atIndex_lz_lh_₁((n⁰ - 1), t²) | LH_N  => error⁰}: 95
//│ [LH_N]: 125 --->
//│ 	case force⁰(ls²) of {LH_C h² t² => if (n⁰ == 0) then h² else atIndex_lz_lh_₁((n⁰ - 1), t²) | LH_N  => error⁰}: 95
//│ ------------------
//│ case force⁰(ls²) of {LH_C h² t² => if (n⁰ == 0) then h² else atIndex_lz_lh_₁((n⁰ - 1), t²) | LH_N  => error⁰}: 95 --->
//│ 	[LH_C f²(h³) map_lz_lh_₁(f², t³)]: 124
//│ 	[LH_N]: 125
//│ case force⁰(ls³) of {LH_C h³ t³ => [LH_C f²(h³) map_lz_lh_₁(f², t³)] | LH_N  => [LH_N]}: 126 --->
//│ 	[LH_C x⁰ iterate_lh_₁(f¹, f¹(x⁰))]: 108
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testPrime_nofib_lh_₁(primId⁰(100))
//│ def atIndex_lz_lh_₁(n¹, ls⁵) = if (n¹ < 0) then error⁰ else force⁰(ls⁵, n¹)
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then [LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b¹)] else [LH_N]
//│ def filter_lh_₁(f⁶, ls⁶) = case ls⁶ of {
//│ 	LH_C h⁰ t⁰ => if f⁶(h⁰) then [LH_C h⁰ filter_lh_₁(f⁶, t⁰)] else filter_lh_₁(f⁶, t⁰)
//│ 	| LH_N  => [LH_N]}
//│ def head_lh_₁(ls⁷) = case ls⁷ of {
//│ 	LH_C h¹ t¹ => h¹
//│ 	| LH_N  => error⁰}
//│ def isdivs_lh_₁(_lh_isdivs_arg1¹, _lh_isdivs_arg2¹) = ((_lh_isdivs_arg2¹ % _lh_isdivs_arg1¹) /= 0)
//│ def iterate_lh_₁(f⁴, x¹) = lazy⁰(
//│ 	let t⁴ = iterate_lh_₁(f⁴, f⁴(x¹))
//│ 	in let h⁴ = x¹
//│ 	in (fun f⁵ -> 
//│ 		let t⁵ = map_lz_lh_₁(f⁵, t⁴)
//│ 		in let h⁵ = f⁵(h⁴)
//│ 		in (fun n² -> if (n² == 0) then h⁵ else atIndex_lz_lh_₁((n² - 1), t⁵))))
//│ def map_lz_lh_₁(f³, ls⁴) = lazy⁰(force⁰(ls⁴, f³))
//│ def prime_lh_₁(_lh_prime_arg1¹) = atIndex_lz_lh_₁(_lh_prime_arg1¹, map_lz_lh_₁(head_lh_₁, iterate_lh_₁(the_filter_lh_₁, enumFromTo_lh_₁(2, (_lh_prime_arg1¹ * _lh_prime_arg1¹)))))
//│ def testPrime_nofib_lh_₁(_lh_testPrime_nofib_arg1¹) = prime_lh_₁(_lh_testPrime_nofib_arg1¹)
//│ def the_filter_lh_₁(_lh_the_filter_arg1¹) = case _lh_the_filter_arg1¹ of {
//│ 	LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh_₁(isdivs_lh_₁(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰)
//│ 	| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ atIndex_lz_lh_₁, map_lz_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ iterate_lh_₁ -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testPrime_nofib_lh_₁(primId⁰(100))
//│ def atIndex_lz_lh_₁(n⁰, ls¹) = if (n⁰ < 0) then error⁰ else force⁰(ls¹, n⁰)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)] else [LH_N]
//│ def filter_lh_₁(f³, ls²) = case ls² of {
//│ 	LH_C h² t² => if f³(h²) then [LH_C h² filter_lh_₁(f³, t²)] else filter_lh_₁(f³, t²)
//│ 	| LH_N  => [LH_N]}
//│ def head_lh_₁(ls³) = case ls³ of {
//│ 	LH_C h³ t³ => h³
//│ 	| LH_N  => error⁰}
//│ def isdivs_lh_₁(_lh_isdivs_arg1⁰, _lh_isdivs_arg2⁰) = ((_lh_isdivs_arg2⁰ % _lh_isdivs_arg1⁰) /= 0)
//│ def iterate_lh_₁(f¹, x⁰) = lazy⁰(
//│ 	let t⁰ = iterate_lh_₁(f¹, f¹(x⁰))
//│ 	in let h⁰ = x⁰
//│ 	in (fun f² -> 
//│ 		let t¹ = lazy⁰(force⁰(t⁰, f²))
//│ 		in let h¹ = f²(h⁰)
//│ 		in (fun n¹ -> if (n¹ == 0) then h¹ else if ((n¹ - 1) < 0) then error⁰ else force⁰(t¹, (n¹ - 1)))))
//│ def map_lz_lh_₁(f⁰, ls⁰) = lazy⁰(force⁰(ls⁰, f⁰))
//│ def prime_lh_₁(_lh_prime_arg1⁰) = if (_lh_prime_arg1⁰ < 0) then error⁰ else force⁰(lazy⁰(force⁰(iterate_lh_₁(the_filter_lh_₁, enumFromTo_lh_₁(2, (_lh_prime_arg1⁰ * _lh_prime_arg1⁰))), head_lh_₁)), _lh_prime_arg1⁰)
//│ def testPrime_nofib_lh_₁(_lh_testPrime_nofib_arg1⁰) = prime_lh_₁(_lh_testPrime_nofib_arg1⁰)
//│ def the_filter_lh_₁(_lh_the_filter_arg1⁰) = case _lh_the_filter_arg1⁰ of {
//│ 	LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh_₁(isdivs_lh_₁(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰)
//│ 	| _  => error⁰}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testPrime_nofib_lh_₁(primId⁰(100))
//│ def atIndex_lz_lh_₁(n⁰, ls¹) = if (n⁰ < 0) then error⁰ else force⁰(ls¹, n⁰)
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)] else [LH_N]
//│ def filter_lh_₁(f³, ls²) = case ls² of {
//│ 	LH_C h² t² => if f³(h²) then [LH_C h² filter_lh_₁(f³, t²)] else filter_lh_₁(f³, t²)
//│ 	| LH_N  => [LH_N]}
//│ def head_lh_₁(ls³) = case ls³ of {
//│ 	LH_C h³ t³ => h³
//│ 	| LH_N  => error⁰}
//│ def isdivs_lh_₁(_lh_isdivs_arg1⁰, _lh_isdivs_arg2⁰) = ((_lh_isdivs_arg2⁰ % _lh_isdivs_arg1⁰) /= 0)
//│ def iterate_lh_₁(f¹, x⁰) = lazy⁰(
//│ 	let t⁰ = iterate_lh_₁(f¹, f¹(x⁰))
//│ 	in let h⁰ = x⁰
//│ 	in (fun f² -> 
//│ 		let t¹ = lazy⁰(force⁰(t⁰, f²))
//│ 		in let h¹ = f²(h⁰)
//│ 		in (fun n¹ -> if (n¹ == 0) then h¹ else if ((n¹ - 1) < 0) then error⁰ else force⁰(t¹, (n¹ - 1)))))
//│ def map_lz_lh_₁(f⁰, ls⁰) = lazy⁰(force⁰(ls⁰, f⁰))
//│ def prime_lh_₁(_lh_prime_arg1⁰) = if (_lh_prime_arg1⁰ < 0) then error⁰ else force⁰(lazy⁰(force⁰(iterate_lh_₁(the_filter_lh_₁, enumFromTo_lh_₁(2, (_lh_prime_arg1⁰ * _lh_prime_arg1⁰))), head_lh_₁)), _lh_prime_arg1⁰)
//│ def testPrime_nofib_lh_₁(_lh_testPrime_nofib_arg1⁰) = prime_lh_₁(_lh_testPrime_nofib_arg1⁰)
//│ def the_filter_lh_₁(_lh_the_filter_arg1⁰) = case _lh_the_filter_arg1⁰ of {
//│ 	LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh_₁(isdivs_lh_₁(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰)
//│ 	| _  => error⁰}
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
