:NewParser
:ParseOnly

:lhInHaskell
:lhGenOCaml
and [] = True
and (h:t) = if h then (and t) else False
copy 0 a = []
copy n a = a:(copy (n - 1) a)
unlines ls = concat (map (\l -> l ++ ['n']) ls)
even a = (a `mod` 2) == 0
drop n [] = []
drop n (h:t) = if n > 0 then (drop (n - 1) t) else (h:t)
encrypt n e = unlines . map (string_of_int . power e n . code) . collect (size n)
code ls = foldl (\x y -> (128 * x) + (int_of_char y)) 0 ls
decode n = reverse (expand n)
expand 0 = []
expand x = (x `mod` 128) : (expand (x `div` 128))
collect 0 xs = []
collect n [] = []
collect n xs = (take n xs) : collect n (drop n xs)
size n = (length (string_of_int n) * 47) `div` 100
prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]
nextPrime a = let odd = (if (even a) then (a + 1) else a) in (head_lz (filter_lz prime [odd,odd+2..]))
iter g v 0  w = v
iter g v h w = let fact = (g `div` h) in (iter h w (g - (fact * h)) (v - (fact * w)))
invert n a = let e = (iter n 0 a 1) in (if e < 0 then e + n else e)
power 0 m x = 1
power n m x = if (even n) then ((sqr (power (n `div` 2) m x)) `mod` m) else ((x * (power (n-1) m x)) `mod` m)
sqr x = x * x
makeKeys p' q' = let p = (nextPrime p') in (let q = (nextPrime q') in (let d = (nextPrime (p+q+1)) in (p * q, invert ((p-1) * (q-1)) d, d)))
testRsa_nofib n = encrypt 6367 5189 (primId $ copy n 'l')
testRsa_nofib $ primId 50520
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testRsa_nofib_lh_₁^336(primId⁰(50520))
//│ def code_lh_₁(_lh_code_arg1⁰) = foldl_lh_₁^216((fun x⁰ -> (fun y⁰ -> ((128 * x⁰) + int_of_char⁰(y⁰)))), 0, _lh_code_arg1⁰)
//│ def collect_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰) = case _lh_collect_arg1⁰ of {
//│ 	0  => [LH_N]
//│ 	| _  => case _lh_collect_arg2⁰ of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => [LH_C take_lh_₁^240(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh_₁^245(_lh_collect_arg1⁰, drop_lh_₁^248(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]}}
//│ def concat_lh_₁(lss⁰) = case lss⁰ of {
//│ 	LH_C h² t² => mappend_lh_₂^26(h², concat_lh_₁^29(t²))
//│ 	| LH_N  => [LH_N]}
//│ def copy_lh_₁(_lh_copy_arg1⁰, _lh_copy_arg2⁰) = case _lh_copy_arg1⁰ of {
//│ 	0  => [LH_N]
//│ 	| _  => [LH_C _lh_copy_arg2⁰ copy_lh_₁^309((_lh_copy_arg1⁰ - 1), _lh_copy_arg2⁰)]}
//│ def drop_lh_₁(_lh_drop_arg1⁰, _lh_drop_arg2⁰) = case _lh_drop_arg2⁰ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰ => if (_lh_drop_arg1⁰ > 0) then drop_lh_₁^90((_lh_drop_arg1⁰ - 1), _lh_drop_LH_C_1⁰) else [LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰]
//│ 	| _  => error⁰}
//│ def encrypt_lh_₁(_lh_encrypt_arg1⁰, _lh_encrypt_arg2⁰, _lh_funcomp_x⁰) = (fun _lh_funcomp_x¹ -> unlines_lh_₁^273(map_lh_₁^274((fun _lh_funcomp_x² -> (fun _lh_funcomp_x³ -> string_of_int⁰(power_lh_₁^276(_lh_encrypt_arg2⁰, _lh_encrypt_arg1⁰, _lh_funcomp_x³)))(code_lh_₁^285(_lh_funcomp_x²))), _lh_funcomp_x¹)))(collect_lh_₁^295(size_lh_₁^296(_lh_encrypt_arg1⁰), _lh_funcomp_x⁰))
//│ def even_lh_₁(_lh_even_arg1⁰) = ((_lh_even_arg1⁰ % 2) == 0)
//│ def foldl_lh_₁(f¹, i⁰, ls¹) = case ls¹ of {
//│ 	LH_C h⁴ t⁴ => foldl_lh_₁^67(f¹, f¹(i⁰, h⁴), t⁴)
//│ 	| LH_N  => i⁰}
//│ def length_lh_₁(ls³) = case ls³ of {
//│ 	LH_C h⁶ t⁶ => (1 + length_lh_₁^134(t⁶))
//│ 	| LH_N  => 0}
//│ def map_lh_₁(f², ls⁴) = case ls⁴ of {
//│ 	LH_C h⁷ t⁷ => [LH_C f²(h⁷) map_lh_₁^160(f², t⁷)]
//│ 	| LH_N  => [LH_N]}
//│ def map_lh_₂(f⁰, ls⁰) = case ls⁰ of {
//│ 	LH_C h³ t³ => [LH_C f⁰(h³) map_lh_₂^40(f⁰, t³)]
//│ 	| LH_N  => [LH_N]}
//│ def mappend_lh_₁(xs¹, ys¹) = case xs¹ of {
//│ 	LH_C h¹ t¹ => [LH_C h¹ mappend_lh_₁^15(t¹, ys¹)]
//│ 	| LH_N  => ys¹}
//│ def mappend_lh_₂(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₂^3(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def power_lh_₁(_lh_power_arg1⁰, _lh_power_arg2⁰, _lh_power_arg3⁰) = case _lh_power_arg1⁰ of {
//│ 	0  => 1
//│ 	| _  => if even_lh_₁^172(_lh_power_arg1⁰) then (sqr_lh_₁^176(power_lh_₁^177(div⁰(_lh_power_arg1⁰, 2), _lh_power_arg2⁰, _lh_power_arg3⁰)) % _lh_power_arg2⁰) else ((_lh_power_arg3⁰ * power_lh_₁^196((_lh_power_arg1⁰ - 1), _lh_power_arg2⁰, _lh_power_arg3⁰)) % _lh_power_arg2⁰)}
//│ def size_lh_₁(_lh_size_arg1⁰) = div⁰((length_lh_₁^261(string_of_int⁰(_lh_size_arg1⁰)) * 47), 100)
//│ def sqr_lh_₁(_lh_sqr_arg1⁰) = (_lh_sqr_arg1⁰ * _lh_sqr_arg1⁰)
//│ def take_lh_₁(n⁰, ls²) = if (n⁰ > 0) then case ls² of {
//│ 	LH_C h⁵ t⁵ => [LH_C h⁵ take_lh_₁^114((n⁰ - 1), t⁵)]
//│ 	| LH_N  => [LH_N]} else [LH_N]
//│ def testRsa_nofib_lh_₁(_lh_testRsa_nofib_arg1⁰) = encrypt_lh_₁^322(6367, 5189, primId⁰(copy_lh_₁^328(_lh_testRsa_nofib_arg1⁰, 'l')))
//│ def unlines_lh_₁(_lh_unlines_arg1⁰) = concat_lh_₁^141(map_lh_₂^142((fun l⁰ -> mappend_lh_₁^143(l⁰, [LH_C 'n' [LH_N]])), _lh_unlines_arg1⁰))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec even_lh__d1 _lh_even_arg1_0 =
//│ 		  ((_lh_even_arg1_0 mod 2) = 0);;
//│ 		let rec sqr_lh__d1 _lh_sqr_arg1_0 =
//│ 		  (_lh_sqr_arg1_0 * _lh_sqr_arg1_0);;
//│ 		let rec power_lh__d1 _lh_power_arg1_0 _lh_power_arg2_0 _lh_power_arg3_0 =
//│ 		  (match _lh_power_arg1_0 with
//│ 		    | 0 -> 
//│ 		      1
//│ 		    | _ -> 
//│ 		      (if (even_lh__d1 _lh_power_arg1_0) then
//│ 		        ((sqr_lh__d1 (((power_lh__d1 (_lh_power_arg1_0 / 2)) _lh_power_arg2_0) _lh_power_arg3_0)) mod _lh_power_arg2_0)
//│ 		      else
//│ 		        ((_lh_power_arg3_0 * (((power_lh__d1 (_lh_power_arg1_0 - 1)) _lh_power_arg2_0) _lh_power_arg3_0)) mod _lh_power_arg2_0)));;
//│ 		let rec map_lh__d1 f_2 ls_4 =
//│ 		  (match ls_4 with
//│ 		    | `LH_C(h_7, t_7) -> 
//│ 		      (`LH_C((f_2 h_7), ((map_lh__d1 f_2) t_7)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec take_lh__d1 n_0 ls_2 =
//│ 		  (if (n_0 > 0) then
//│ 		    (match ls_2 with
//│ 		      | `LH_C(h_5, t_5) -> 
//│ 		        (`LH_C(h_5, ((take_lh__d1 (n_0 - 1)) t_5)))
//│ 		      | `LH_N -> 
//│ 		        (`LH_N))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec drop_lh__d1 _lh_drop_arg1_0 _lh_drop_arg2_0 =
//│ 		  (match _lh_drop_arg2_0 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_drop_LH_C_0_0, _lh_drop_LH_C_1_0) -> 
//│ 		      (if (_lh_drop_arg1_0 > 0) then
//│ 		        ((drop_lh__d1 (_lh_drop_arg1_0 - 1)) _lh_drop_LH_C_1_0)
//│ 		      else
//│ 		        (`LH_C(_lh_drop_LH_C_0_0, _lh_drop_LH_C_1_0)))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec collect_lh__d1 _lh_collect_arg1_0 _lh_collect_arg2_0 =
//│ 		  (match _lh_collect_arg1_0 with
//│ 		    | 0 -> 
//│ 		      (`LH_N)
//│ 		    | _ -> 
//│ 		      (match _lh_collect_arg2_0 with
//│ 		        | `LH_N -> 
//│ 		          (`LH_N)
//│ 		        | _ -> 
//│ 		          (`LH_C(((take_lh__d1 _lh_collect_arg1_0) _lh_collect_arg2_0), ((collect_lh__d1 _lh_collect_arg1_0) ((drop_lh__d1 _lh_collect_arg1_0) _lh_collect_arg2_0))))));;
//│ 		let rec foldl_lh__d1 f_1 i_0 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `LH_C(h_4, t_4) -> 
//│ 		      (((foldl_lh__d1 f_1) ((f_1 i_0) h_4)) t_4)
//│ 		    | `LH_N -> 
//│ 		      i_0);;
//│ 		let rec code_lh__d1 _lh_code_arg1_0 =
//│ 		  (((foldl_lh__d1 (fun x_0 y_0 -> 
//│ 		    ((128 * x_0) + (int_of_char y_0)))) 0) _lh_code_arg1_0);;
//│ 		let rec length_lh__d1 ls_3 =
//│ 		  (match ls_3 with
//│ 		    | `LH_C(h_6, t_6) -> 
//│ 		      (1 + (length_lh__d1 t_6))
//│ 		    | `LH_N -> 
//│ 		      0);;
//│ 		let rec size_lh__d1 _lh_size_arg1_0 =
//│ 		  (((length_lh__d1 (string_of_int _lh_size_arg1_0)) * 47) / 100);;
//│ 		let rec mappend_lh__d2 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (`LH_C(h_0, ((mappend_lh__d2 t_0) ys_0)))
//│ 		    | `LH_N -> 
//│ 		      ys_0);;
//│ 		let rec concat_lh__d1 lss_0 =
//│ 		  (match lss_0 with
//│ 		    | `LH_C(h_2, t_2) -> 
//│ 		      ((mappend_lh__d2 h_2) (concat_lh__d1 t_2))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec map_lh__d2 f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `LH_C(h_3, t_3) -> 
//│ 		      (`LH_C((f_0 h_3), ((map_lh__d2 f_0) t_3)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec mappend_lh__d1 xs_1 ys_1 =
//│ 		  (match xs_1 with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      (`LH_C(h_1, ((mappend_lh__d1 t_1) ys_1)))
//│ 		    | `LH_N -> 
//│ 		      ys_1);;
//│ 		let rec unlines_lh__d1 _lh_unlines_arg1_0 =
//│ 		  (concat_lh__d1 ((map_lh__d2 (fun l_0 -> 
//│ 		    ((mappend_lh__d1 l_0) (`LH_C('n', (`LH_N)))))) _lh_unlines_arg1_0));;
//│ 		let rec encrypt_lh__d1 _lh_encrypt_arg1_0 _lh_encrypt_arg2_0 _lh_funcomp_x_0 =
//│ 		  ((fun _lh_funcomp_x_1 -> 
//│ 		    (unlines_lh__d1 ((map_lh__d1 (fun _lh_funcomp_x_2 -> 
//│ 		      ((fun _lh_funcomp_x_3 -> 
//│ 		        (string_of_int (((power_lh__d1 _lh_encrypt_arg2_0) _lh_encrypt_arg1_0) _lh_funcomp_x_3))) (code_lh__d1 _lh_funcomp_x_2)))) _lh_funcomp_x_1))) ((collect_lh__d1 (size_lh__d1 _lh_encrypt_arg1_0)) _lh_funcomp_x_0));;
//│ 		let rec copy_lh__d1 _lh_copy_arg1_0 _lh_copy_arg2_0 =
//│ 		  (match _lh_copy_arg1_0 with
//│ 		    | 0 -> 
//│ 		      (`LH_N)
//│ 		    | _ -> 
//│ 		      (`LH_C(_lh_copy_arg2_0, ((copy_lh__d1 (_lh_copy_arg1_0 - 1)) _lh_copy_arg2_0))));;
//│ 		let rec testRsa_nofib_lh__d1 _lh_testRsa_nofib_arg1_0 =
//│ 		  (((encrypt_lh__d1 6367) 5189) ((copy_lh__d1 _lh_testRsa_nofib_arg1_0) 'l'));;
//│ 		(testRsa_nofib_lh__d1 50520)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h¹ mappend_lh_₁(t¹, ys¹)]: 20 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₂(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C f⁰(h³) map_lh_₂(f⁰, t³)]: 45 --->
//│ 	case lss⁰ of {LH_C h² t² => mappend_lh_₂(h², concat_lh_₁(t²)) | LH_N  => [LH_N]}: 34
//│ [LH_N]: 46 --->
//│ 	case lss⁰ of {LH_C h² t² => mappend_lh_₂(h², concat_lh_₁(t²)) | LH_N  => [LH_N]}: 34
//│ [LH_N]: 84 --->
//│ 	case _lh_drop_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰ => if (_lh_drop_arg1⁰ > 0) then drop_lh_₁((_lh_drop_arg1⁰ - 1), _lh_drop_LH_C_1⁰) else [LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰] | _  => error⁰}: 104
//│ 	case ls² of {LH_C h⁵ t⁵ => [LH_C h⁵ take_lh_₁((n⁰ - 1), t⁵)] | LH_N  => [LH_N]}: 125
//│ 	case _lh_collect_arg2⁰ of {LH_N  => [LH_N] | _  => [LH_C take_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh_₁(_lh_collect_arg1⁰, drop_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]}: 255
//│ [LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰]: 101 --->
//│ 	case _lh_drop_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰ => if (_lh_drop_arg1⁰ > 0) then drop_lh_₁((_lh_drop_arg1⁰ - 1), _lh_drop_LH_C_1⁰) else [LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰] | _  => error⁰}: 104
//│ 	case ls² of {LH_C h⁵ t⁵ => [LH_C h⁵ take_lh_₁((n⁰ - 1), t⁵)] | LH_N  => [LH_N]}: 125
//│ 	case _lh_collect_arg2⁰ of {LH_N  => [LH_N] | _  => [LH_C take_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh_₁(_lh_collect_arg1⁰, drop_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]}: 255
//│ [LH_C h⁵ take_lh_₁((n⁰ - 1), t⁵)]: 123 --->
//│ 	case ls¹ of {LH_C h⁴ t⁴ => foldl_lh_₁(f¹, f¹(i⁰, h⁴), t⁴) | LH_N  => i⁰}: 79
//│ [LH_N]: 124 --->
//│ 	case ls¹ of {LH_C h⁴ t⁴ => foldl_lh_₁(f¹, f¹(i⁰, h⁴), t⁴) | LH_N  => i⁰}: 79
//│ [LH_N]: 126 --->
//│ 	case ls¹ of {LH_C h⁴ t⁴ => foldl_lh_₁(f¹, f¹(i⁰, h⁴), t⁴) | LH_N  => i⁰}: 79
//│ [LH_N]: 147 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₂(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C 'n' [LH_N]]: 148 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₂(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C f²(h⁷) map_lh_₁(f², t⁷)]: 165 --->
//│ 	case ls⁰ of {LH_C h³ t³ => [LH_C f⁰(h³) map_lh_₂(f⁰, t³)] | LH_N  => [LH_N]}: 47
//│ [LH_N]: 166 --->
//│ 	case ls⁰ of {LH_C h³ t³ => [LH_C f⁰(h³) map_lh_₂(f⁰, t³)] | LH_N  => [LH_N]}: 47
//│ [LH_N]: 237 --->
//│ 	case ls⁴ of {LH_C h⁷ t⁷ => [LH_C f²(h⁷) map_lh_₁(f², t⁷)] | LH_N  => [LH_N]}: 167
//│ [LH_N]: 239 --->
//│ 	case ls⁴ of {LH_C h⁷ t⁷ => [LH_C f²(h⁷) map_lh_₁(f², t⁷)] | LH_N  => [LH_N]}: 167
//│ [LH_C take_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh_₁(_lh_collect_arg1⁰, drop_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]: 254 --->
//│ 	case ls⁴ of {LH_C h⁷ t⁷ => [LH_C f²(h⁷) map_lh_₁(f², t⁷)] | LH_N  => [LH_N]}: 167
//│ ------------------
//│ case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₂(t⁰, ys⁰)] | LH_N  => ys⁰}: 10 --->
//│ 	[LH_C h¹ mappend_lh_₁(t¹, ys¹)]: 20
//│ 	[LH_N]: 147
//│ 	[LH_C 'n' [LH_N]]: 148
//│ case lss⁰ of {LH_C h² t² => mappend_lh_₂(h², concat_lh_₁(t²)) | LH_N  => [LH_N]}: 34 --->
//│ 	[LH_C f⁰(h³) map_lh_₂(f⁰, t³)]: 45
//│ 	[LH_N]: 46
//│ case ls⁰ of {LH_C h³ t³ => [LH_C f⁰(h³) map_lh_₂(f⁰, t³)] | LH_N  => [LH_N]}: 47 --->
//│ 	[LH_C f²(h⁷) map_lh_₁(f², t⁷)]: 165
//│ 	[LH_N]: 166
//│ case ls¹ of {LH_C h⁴ t⁴ => foldl_lh_₁(f¹, f¹(i⁰, h⁴), t⁴) | LH_N  => i⁰}: 79 --->
//│ 	[LH_C h⁵ take_lh_₁((n⁰ - 1), t⁵)]: 123
//│ 	[LH_N]: 124
//│ 	[LH_N]: 126
//│ case _lh_drop_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰ => if (_lh_drop_arg1⁰ > 0) then drop_lh_₁((_lh_drop_arg1⁰ - 1), _lh_drop_LH_C_1⁰) else [LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰] | _  => error⁰}: 104 --->
//│ 	NoProd
//│ 	[LH_N]: 84
//│ 	[LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰]: 101
//│ case ls² of {LH_C h⁵ t⁵ => [LH_C h⁵ take_lh_₁((n⁰ - 1), t⁵)] | LH_N  => [LH_N]}: 125 --->
//│ 	NoProd
//│ 	[LH_N]: 84
//│ 	[LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰]: 101
//│ case ls⁴ of {LH_C h⁷ t⁷ => [LH_C f²(h⁷) map_lh_₁(f², t⁷)] | LH_N  => [LH_N]}: 167 --->
//│ 	[LH_N]: 237
//│ 	[LH_N]: 239
//│ 	[LH_C take_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh_₁(_lh_collect_arg1⁰, drop_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]: 254
//│ case _lh_collect_arg2⁰ of {LH_N  => [LH_N] | _  => [LH_C take_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh_₁(_lh_collect_arg1⁰, drop_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]}: 255 --->
//│ 	NoProd
//│ 	[LH_N]: 84
//│ 	[LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰]: 101
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C h¹ mappend_lh_₁(t¹, ys¹)]: 20 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₂(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C f⁰(h³) map_lh_₂(f⁰, t³)]: 45 --->
//│ 	case lss⁰ of {LH_C h² t² => mappend_lh_₂(h², concat_lh_₁(t²)) | LH_N  => [LH_N]}: 34
//│ [LH_N]: 46 --->
//│ 	case lss⁰ of {LH_C h² t² => mappend_lh_₂(h², concat_lh_₁(t²)) | LH_N  => [LH_N]}: 34
//│ [LH_C h⁵ take_lh_₁((n⁰ - 1), t⁵)]: 123 --->
//│ 	case ls¹ of {LH_C h⁴ t⁴ => foldl_lh_₁(f¹, f¹(i⁰, h⁴), t⁴) | LH_N  => i⁰}: 79
//│ [LH_N]: 124 --->
//│ 	case ls¹ of {LH_C h⁴ t⁴ => foldl_lh_₁(f¹, f¹(i⁰, h⁴), t⁴) | LH_N  => i⁰}: 79
//│ [LH_N]: 126 --->
//│ 	case ls¹ of {LH_C h⁴ t⁴ => foldl_lh_₁(f¹, f¹(i⁰, h⁴), t⁴) | LH_N  => i⁰}: 79
//│ [LH_N]: 147 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₂(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C 'n' [LH_N]]: 148 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₂(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C f²(h⁷) map_lh_₁(f², t⁷)]: 165 --->
//│ 	case ls⁰ of {LH_C h³ t³ => [LH_C f⁰(h³) map_lh_₂(f⁰, t³)] | LH_N  => [LH_N]}: 47
//│ [LH_N]: 166 --->
//│ 	case ls⁰ of {LH_C h³ t³ => [LH_C f⁰(h³) map_lh_₂(f⁰, t³)] | LH_N  => [LH_N]}: 47
//│ [LH_N]: 237 --->
//│ 	case ls⁴ of {LH_C h⁷ t⁷ => [LH_C f²(h⁷) map_lh_₁(f², t⁷)] | LH_N  => [LH_N]}: 167
//│ [LH_N]: 239 --->
//│ 	case ls⁴ of {LH_C h⁷ t⁷ => [LH_C f²(h⁷) map_lh_₁(f², t⁷)] | LH_N  => [LH_N]}: 167
//│ [LH_C take_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh_₁(_lh_collect_arg1⁰, drop_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]: 254 --->
//│ 	case ls⁴ of {LH_C h⁷ t⁷ => [LH_C f²(h⁷) map_lh_₁(f², t⁷)] | LH_N  => [LH_N]}: 167
//│ ------------------
//│ case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₂(t⁰, ys⁰)] | LH_N  => ys⁰}: 10 --->
//│ 	[LH_C h¹ mappend_lh_₁(t¹, ys¹)]: 20
//│ 	[LH_N]: 147
//│ 	[LH_C 'n' [LH_N]]: 148
//│ case lss⁰ of {LH_C h² t² => mappend_lh_₂(h², concat_lh_₁(t²)) | LH_N  => [LH_N]}: 34 --->
//│ 	[LH_C f⁰(h³) map_lh_₂(f⁰, t³)]: 45
//│ 	[LH_N]: 46
//│ case ls⁰ of {LH_C h³ t³ => [LH_C f⁰(h³) map_lh_₂(f⁰, t³)] | LH_N  => [LH_N]}: 47 --->
//│ 	[LH_C f²(h⁷) map_lh_₁(f², t⁷)]: 165
//│ 	[LH_N]: 166
//│ case ls¹ of {LH_C h⁴ t⁴ => foldl_lh_₁(f¹, f¹(i⁰, h⁴), t⁴) | LH_N  => i⁰}: 79 --->
//│ 	[LH_C h⁵ take_lh_₁((n⁰ - 1), t⁵)]: 123
//│ 	[LH_N]: 124
//│ 	[LH_N]: 126
//│ case ls⁴ of {LH_C h⁷ t⁷ => [LH_C f²(h⁷) map_lh_₁(f², t⁷)] | LH_N  => [LH_N]}: 167 --->
//│ 	[LH_N]: 237
//│ 	[LH_N]: 239
//│ 	[LH_C take_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh_₁(_lh_collect_arg1⁰, drop_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]: 254
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testRsa_nofib_lh_₁(primId⁰(50520))
//│ def code_lh_₁(_lh_code_arg1¹) = foldl_lh_₁((fun x¹ -> (fun y¹ -> ((128 * x¹) + int_of_char⁰(y¹)))), 0, _lh_code_arg1¹)
//│ def collect_lh_₁(_lh_collect_arg1¹, _lh_collect_arg2¹) = case _lh_collect_arg1¹ of {
//│ 	0  => (fun f⁵ -> (fun f⁶ -> (fun _lh_dummy⁰ -> [LH_N])))
//│ 	| _  => case _lh_collect_arg2¹ of {
//│ 		LH_N  => (fun f⁷ -> (fun f⁸ -> (fun _lh_dummy¹ -> [LH_N])))
//│ 		| _  => 
//│ 			let t⁸ = collect_lh_₁(_lh_collect_arg1¹, drop_lh_₁(_lh_collect_arg1¹, _lh_collect_arg2¹))
//│ 			in let h⁸ = take_lh_₁(_lh_collect_arg1¹, _lh_collect_arg2¹)
//│ 			in (fun f⁹ -> 
//│ 				let t⁹ = map_lh_₁(f⁹, t⁸)
//│ 				in let h⁹ = f⁹(h⁸)
//│ 				in (fun f¹⁰ -> 
//│ 					let t¹⁰ = map_lh_₂(f¹⁰, t⁹)
//│ 					in let h¹⁰ = f¹⁰(h⁹)
//│ 					in (fun _lh_dummy² -> mappend_lh_₂(h¹⁰, concat_lh_₁(t¹⁰)))))}}
//│ def concat_lh_₁(lss¹) = lss¹(99)
//│ def copy_lh_₁(_lh_copy_arg1¹, _lh_copy_arg2¹) = case _lh_copy_arg1¹ of {
//│ 	0  => [LH_N]
//│ 	| _  => [LH_C _lh_copy_arg2¹ copy_lh_₁((_lh_copy_arg1¹ - 1), _lh_copy_arg2¹)]}
//│ def drop_lh_₁(_lh_drop_arg1¹, _lh_drop_arg2¹) = case _lh_drop_arg2¹ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰ => if (_lh_drop_arg1¹ > 0) then drop_lh_₁((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1⁰) else [LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰]
//│ 	| _  => error⁰}
//│ def encrypt_lh_₁(_lh_encrypt_arg1¹, _lh_encrypt_arg2¹, _lh_funcomp_x⁴) = (fun _lh_funcomp_x⁵ -> unlines_lh_₁(map_lh_₁((fun _lh_funcomp_x⁶ -> (fun _lh_funcomp_x⁷ -> string_of_int⁰(power_lh_₁(_lh_encrypt_arg2¹, _lh_encrypt_arg1¹, _lh_funcomp_x⁷)))(code_lh_₁(_lh_funcomp_x⁶))), _lh_funcomp_x⁵)))(collect_lh_₁(size_lh_₁(_lh_encrypt_arg1¹), _lh_funcomp_x⁴))
//│ def even_lh_₁(_lh_even_arg1¹) = ((_lh_even_arg1¹ % 2) == 0)
//│ def foldl_lh_₁(f³, i¹, ls⁵) = ls⁵(f³, i¹)
//│ def length_lh_₁(ls⁷) = case ls⁷ of {
//│ 	LH_C h⁶ t⁶ => (1 + length_lh_₁(t⁶))
//│ 	| LH_N  => 0}
//│ def map_lh_₁(f⁴, ls⁶) = ls⁶(f⁴)
//│ def map_lh_₂(f¹⁴, ls⁹) = ls⁹(f¹⁴)
//│ def mappend_lh_₁(xs², ys²) = case xs² of {
//│ 	LH_C h¹ t¹ => 
//│ 		let t¹¹ = mappend_lh_₁(t¹, ys²)
//│ 		in let h¹¹ = h¹
//│ 		in (fun ys³ -> [LH_C h¹¹ mappend_lh_₂(t¹¹, ys³)])
//│ 	| LH_N  => ys²}
//│ def mappend_lh_₂(xs³, ys⁴) = xs³(ys⁴)
//│ def power_lh_₁(_lh_power_arg1¹, _lh_power_arg2¹, _lh_power_arg3¹) = case _lh_power_arg1¹ of {
//│ 	0  => 1
//│ 	| _  => if even_lh_₁(_lh_power_arg1¹) then (sqr_lh_₁(power_lh_₁(div⁰(_lh_power_arg1¹, 2), _lh_power_arg2¹, _lh_power_arg3¹)) % _lh_power_arg2¹) else ((_lh_power_arg3¹ * power_lh_₁((_lh_power_arg1¹ - 1), _lh_power_arg2¹, _lh_power_arg3¹)) % _lh_power_arg2¹)}
//│ def size_lh_₁(_lh_size_arg1¹) = div⁰((length_lh_₁(string_of_int⁰(_lh_size_arg1¹)) * 47), 100)
//│ def sqr_lh_₁(_lh_sqr_arg1¹) = (_lh_sqr_arg1¹ * _lh_sqr_arg1¹)
//│ def take_lh_₁(n¹, ls⁸) = if (n¹ > 0) then case ls⁸ of {
//│ 	LH_C h⁵ t⁵ => 
//│ 		let t¹² = take_lh_₁((n¹ - 1), t⁵)
//│ 		in let h¹² = h⁵
//│ 		in (fun f¹¹ -> (fun i² -> foldl_lh_₁(f¹¹, f¹¹(i², h¹²), t¹²)))
//│ 	| LH_N  => (fun f¹² -> (fun i³ -> i³))} else (fun f¹³ -> (fun i⁴ -> i⁴))
//│ def testRsa_nofib_lh_₁(_lh_testRsa_nofib_arg1¹) = encrypt_lh_₁(6367, 5189, primId⁰(copy_lh_₁(_lh_testRsa_nofib_arg1¹, 'l')))
//│ def unlines_lh_₁(_lh_unlines_arg1¹) = concat_lh_₁(map_lh_₂((fun l¹ -> mappend_lh_₁(l¹, 
//│ 	let t¹³ = (fun ys⁶ -> ys⁶)
//│ 	in let h¹³ = 'n'
//│ 	in (fun ys⁵ -> [LH_C h¹³ mappend_lh_₂(t¹³, ys⁵)]))), _lh_unlines_arg1¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<





