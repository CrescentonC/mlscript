:NewParser
:ParseOnly

:lhInHaskell
:lhGenOCaml
and [] = True
and (h:t) = if h then (and t) else False
copy 0 a = []
copy n a = a:(copy (n - 1) a)
unlines ls = concat (map (\l -> l ++ ['n']) ls)
even a = (a `mod` 2) == 0
drop n [] = []
drop n (h:t) = if n > 0 then (drop (n - 1) t) else (h:t)
encrypt n e = unlines . map (string_of_int . power e n . code) . collect (size n)
code ls = foldl (\x y -> (128 * x) + (int_of_char y)) 0 ls
decode n = reverse (expand n)
expand 0 = []
expand x = (x `mod` 128) : (expand (x `div` 128))
collect 0 xs = []
collect n [] = []
collect n xs = (take n xs) : collect n (drop n xs)
size n = (length (string_of_int n) * 47) `div` 100
prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]
nextPrime a = let odd = (if (even a) then (a + 1) else a) in (head_lz (filter_lz prime [odd,odd+2..]))
iter g v 0  w = v
iter g v h w = let fact = (g `div` h) in (iter h w (g - (fact * h)) (v - (fact * w)))
invert n a = let e = (iter n 0 a 1) in (if e < 0 then e + n else e)
power 0 m x = 1
power n m x = if (even n) then ((sqr (power (n `div` 2) m x)) `mod` m) else ((x * (power (n-1) m x)) `mod` m)
sqr x = x * x
makeKeys p' q' = let p = (nextPrime p') in (let q = (nextPrime q') in (let d = (nextPrime (p+q+1)) in (p * q, invert ((p-1) * (q-1)) d, d)))
testRsa_nofib n = encrypt 6367 5189 (primId $ copy n 'l')
testRsa_nofib $ primId 50520
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testRsa_nofib_lh^310(primId⁰(50520))
//│ def code_lh(_lh_code_arg1⁰) = foldl_lh^244((fun x⁰ -> (fun y⁰ -> ((128 * x⁰) + int_of_char⁰(y⁰)))), 0, _lh_code_arg1⁰)
//│ def collect_lh(_lh_collect_arg1⁰, _lh_collect_arg2⁰) = case _lh_collect_arg1⁰ of {
//│ 	0  => [LH_N]
//│ 	| _  => case _lh_collect_arg2⁰ of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => [LH_C take_lh^201(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh^206(_lh_collect_arg1⁰, drop_lh^209(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]}}
//│ def concat_lh(lss⁰) = case lss⁰ of {
//│ 	LH_C h⁵ t⁵ => mappend_lh^79(h⁵, concat_lh^82(t⁵))
//│ 	| LH_N  => [LH_N]}
//│ def copy_lh(_lh_copy_arg1⁰, _lh_copy_arg2⁰) = case _lh_copy_arg1⁰ of {
//│ 	0  => [LH_N]
//│ 	| _  => [LH_C _lh_copy_arg2⁰ copy_lh^184((_lh_copy_arg1⁰ - 1), _lh_copy_arg2⁰)]}
//│ def drop_lh(_lh_drop_arg1⁰, _lh_drop_arg2⁰) = case _lh_drop_arg2⁰ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰ => if (_lh_drop_arg1⁰ > 0) then drop_lh^227((_lh_drop_arg1⁰ - 1), _lh_drop_LH_C_1⁰) else [LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰]
//│ 	| _  => error⁰}
//│ def encrypt_lh(_lh_encrypt_arg1⁰, _lh_encrypt_arg2⁰, _lh_funcomp_x⁰) = (fun _lh_funcomp_x¹ -> unlines_lh^124(map_lh^125((fun _lh_funcomp_x² -> (fun _lh_funcomp_x³ -> string_of_int⁰(power_lh^127(_lh_encrypt_arg2⁰, _lh_encrypt_arg1⁰, _lh_funcomp_x³)))(code_lh^136(_lh_funcomp_x²))), _lh_funcomp_x¹)))(collect_lh^146(size_lh^147(_lh_encrypt_arg1⁰), _lh_funcomp_x⁰))
//│ def even_lh(_lh_even_arg1⁰) = ((_lh_even_arg1⁰ % 2) == 0)
//│ def foldl_lh(f¹, i⁰, ls¹) = case ls¹ of {
//│ 	LH_C h¹ t¹ => foldl_lh^16(f¹, f¹(i⁰, h¹), t¹)
//│ 	| LH_N  => i⁰}
//│ def length_lh(ls³) = case ls³ of {
//│ 	LH_C h³ t³ => (1 + length_lh^59(t³))
//│ 	| LH_N  => 0}
//│ def map_lh(f⁰, ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh^5(f⁰, t⁰)]
//│ 	| LH_N  => [LH_N]}
//│ def mappend_lh(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁴ t⁴ => [LH_C h⁴ mappend_lh^68(t⁴, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def power_lh(_lh_power_arg1⁰, _lh_power_arg2⁰, _lh_power_arg3⁰) = case _lh_power_arg1⁰ of {
//│ 	0  => 1
//│ 	| _  => if even_lh^266(_lh_power_arg1⁰) then (sqr_lh^270(power_lh^271(div⁰(_lh_power_arg1⁰, 2), _lh_power_arg2⁰, _lh_power_arg3⁰)) % _lh_power_arg2⁰) else ((_lh_power_arg3⁰ * power_lh^290((_lh_power_arg1⁰ - 1), _lh_power_arg2⁰, _lh_power_arg3⁰)) % _lh_power_arg2⁰)}
//│ def size_lh(_lh_size_arg1⁰) = div⁰((length_lh^97(string_of_int⁰(_lh_size_arg1⁰)) * 47), 100)
//│ def sqr_lh(_lh_sqr_arg1⁰) = (_lh_sqr_arg1⁰ * _lh_sqr_arg1⁰)
//│ def take_lh(n⁰, ls²) = if (n⁰ > 0) then case ls² of {
//│ 	LH_C h² t² => [LH_C h² take_lh^39((n⁰ - 1), t²)]
//│ 	| LH_N  => [LH_N]} else [LH_N]
//│ def testRsa_nofib_lh(_lh_testRsa_nofib_arg1⁰) = encrypt_lh^157(6367, 5189, primId⁰(copy_lh^163(_lh_testRsa_nofib_arg1⁰, 'l')))
//│ def unlines_lh(_lh_unlines_arg1⁰) = concat_lh^109(map_lh^110((fun l⁰ -> mappend_lh^111(l⁰, [LH_C 'n' [LH_N]])), _lh_unlines_arg1⁰))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec copy_lh _lh_copy_arg1_0 _lh_copy_arg2_0 =
//│ 		  (match _lh_copy_arg1_0 with
//│ 		    | 0 -> 
//│ 		      (`LH_N)
//│ 		    | _ -> 
//│ 		      (`LH_C(_lh_copy_arg2_0, ((copy_lh (_lh_copy_arg1_0 - 1)) _lh_copy_arg2_0))));;
//│ 		let rec even_lh _lh_even_arg1_0 =
//│ 		  ((_lh_even_arg1_0 mod 2) = 0);;
//│ 		let rec sqr_lh _lh_sqr_arg1_0 =
//│ 		  (_lh_sqr_arg1_0 * _lh_sqr_arg1_0);;
//│ 		let rec power_lh _lh_power_arg1_0 _lh_power_arg2_0 _lh_power_arg3_0 =
//│ 		  (match _lh_power_arg1_0 with
//│ 		    | 0 -> 
//│ 		      1
//│ 		    | _ -> 
//│ 		      (if (even_lh _lh_power_arg1_0) then
//│ 		        ((sqr_lh (((power_lh (_lh_power_arg1_0 / 2)) _lh_power_arg2_0) _lh_power_arg3_0)) mod _lh_power_arg2_0)
//│ 		      else
//│ 		        ((_lh_power_arg3_0 * (((power_lh (_lh_power_arg1_0 - 1)) _lh_power_arg2_0) _lh_power_arg3_0)) mod _lh_power_arg2_0)));;
//│ 		let rec length_lh ls_3 =
//│ 		  (match ls_3 with
//│ 		    | `LH_C(h_3, t_3) -> 
//│ 		      (1 + (length_lh t_3))
//│ 		    | `LH_N -> 
//│ 		      0);;
//│ 		let rec size_lh _lh_size_arg1_0 =
//│ 		  (((length_lh (string_of_int _lh_size_arg1_0)) * 47) / 100);;
//│ 		let rec map_lh f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (`LH_C((f_0 h_0), ((map_lh f_0) t_0)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec mappend_lh xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(h_4, t_4) -> 
//│ 		      (`LH_C(h_4, ((mappend_lh t_4) ys_0)))
//│ 		    | `LH_N -> 
//│ 		      ys_0);;
//│ 		let rec concat_lh lss_0 =
//│ 		  (match lss_0 with
//│ 		    | `LH_C(h_5, t_5) -> 
//│ 		      ((mappend_lh h_5) (concat_lh t_5))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec unlines_lh _lh_unlines_arg1_0 =
//│ 		  (concat_lh ((map_lh (fun l_0 -> 
//│ 		    ((mappend_lh l_0) (`LH_C('n', (`LH_N)))))) _lh_unlines_arg1_0));;
//│ 		let rec foldl_lh f_1 i_0 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      (((foldl_lh f_1) ((f_1 i_0) h_1)) t_1)
//│ 		    | `LH_N -> 
//│ 		      i_0);;
//│ 		let rec code_lh _lh_code_arg1_0 =
//│ 		  (((foldl_lh (fun x_0 y_0 -> 
//│ 		    ((128 * x_0) + (int_of_char y_0)))) 0) _lh_code_arg1_0);;
//│ 		let rec take_lh n_0 ls_2 =
//│ 		  (if (n_0 > 0) then
//│ 		    (match ls_2 with
//│ 		      | `LH_C(h_2, t_2) -> 
//│ 		        (`LH_C(h_2, ((take_lh (n_0 - 1)) t_2)))
//│ 		      | `LH_N -> 
//│ 		        (`LH_N))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec drop_lh _lh_drop_arg1_0 _lh_drop_arg2_0 =
//│ 		  (match _lh_drop_arg2_0 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_drop_LH_C_0_0, _lh_drop_LH_C_1_0) -> 
//│ 		      (if (_lh_drop_arg1_0 > 0) then
//│ 		        ((drop_lh (_lh_drop_arg1_0 - 1)) _lh_drop_LH_C_1_0)
//│ 		      else
//│ 		        (`LH_C(_lh_drop_LH_C_0_0, _lh_drop_LH_C_1_0)))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec collect_lh _lh_collect_arg1_0 _lh_collect_arg2_0 =
//│ 		  (match _lh_collect_arg1_0 with
//│ 		    | 0 -> 
//│ 		      (`LH_N)
//│ 		    | _ -> 
//│ 		      (match _lh_collect_arg2_0 with
//│ 		        | `LH_N -> 
//│ 		          (`LH_N)
//│ 		        | _ -> 
//│ 		          (`LH_C(((take_lh _lh_collect_arg1_0) _lh_collect_arg2_0), ((collect_lh _lh_collect_arg1_0) ((drop_lh _lh_collect_arg1_0) _lh_collect_arg2_0))))));;
//│ 		let rec encrypt_lh _lh_encrypt_arg1_0 _lh_encrypt_arg2_0 _lh_funcomp_x_0 =
//│ 		  ((fun _lh_funcomp_x_1 -> 
//│ 		    (unlines_lh ((map_lh (fun _lh_funcomp_x_2 -> 
//│ 		      ((fun _lh_funcomp_x_3 -> 
//│ 		        (string_of_int (((power_lh _lh_encrypt_arg2_0) _lh_encrypt_arg1_0) _lh_funcomp_x_3))) (code_lh _lh_funcomp_x_2)))) _lh_funcomp_x_1))) ((collect_lh (size_lh _lh_encrypt_arg1_0)) _lh_funcomp_x_0));;
//│ 		let rec testRsa_nofib_lh _lh_testRsa_nofib_arg1_0 =
//│ 		  (((encrypt_lh 6367) 5189) ((copy_lh _lh_testRsa_nofib_arg1_0) 'l'));;
//│ 		(testRsa_nofib_lh 50520)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f⁰(h⁰) map_lh(f⁰, t⁰)]: 10 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ 	case lss⁰ of {LH_C h⁵ t⁵ => mappend_lh(h⁵, concat_lh(t⁵)) | LH_N  => [LH_N]}: 87
//│ [LH_N]: 11 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ 	case lss⁰ of {LH_C h⁵ t⁵ => mappend_lh(h⁵, concat_lh(t⁵)) | LH_N  => [LH_N]}: 87
//│ [LH_C h² take_lh((n⁰ - 1), t²)]: 48 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_lh(f¹, f¹(i⁰, h¹), t¹) | LH_N  => i⁰}: 28
//│ 	case xs⁰ of {LH_C h⁴ t⁴ => [LH_C h⁴ mappend_lh(t⁴, ys⁰)] | LH_N  => ys⁰}: 75
//│ [LH_N]: 49 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_lh(f¹, f¹(i⁰, h¹), t¹) | LH_N  => i⁰}: 28
//│ 	case xs⁰ of {LH_C h⁴ t⁴ => [LH_C h⁴ mappend_lh(t⁴, ys⁰)] | LH_N  => ys⁰}: 75
//│ [LH_N]: 51 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_lh(f¹, f¹(i⁰, h¹), t¹) | LH_N  => i⁰}: 28
//│ 	case xs⁰ of {LH_C h⁴ t⁴ => [LH_C h⁴ mappend_lh(t⁴, ys⁰)] | LH_N  => ys⁰}: 75
//│ [LH_C h⁴ mappend_lh(t⁴, ys⁰)]: 73 --->
//│ 	NoCons
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_lh(f¹, f¹(i⁰, h¹), t¹) | LH_N  => i⁰}: 28
//│ 	case xs⁰ of {LH_C h⁴ t⁴ => [LH_C h⁴ mappend_lh(t⁴, ys⁰)] | LH_N  => ys⁰}: 75
//│ [LH_N]: 86 --->
//│ 	NoCons
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_lh(f¹, f¹(i⁰, h¹), t¹) | LH_N  => i⁰}: 28
//│ 	case xs⁰ of {LH_C h⁴ t⁴ => [LH_C h⁴ mappend_lh(t⁴, ys⁰)] | LH_N  => ys⁰}: 75
//│ [LH_N]: 115 --->
//│ 	NoCons
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_lh(f¹, f¹(i⁰, h¹), t¹) | LH_N  => i⁰}: 28
//│ 	case xs⁰ of {LH_C h⁴ t⁴ => [LH_C h⁴ mappend_lh(t⁴, ys⁰)] | LH_N  => ys⁰}: 75
//│ [LH_C 'n' [LH_N]]: 116 --->
//│ 	NoCons
//│ 	case ls¹ of {LH_C h¹ t¹ => foldl_lh(f¹, f¹(i⁰, h¹), t¹) | LH_N  => i⁰}: 28
//│ 	case xs⁰ of {LH_C h⁴ t⁴ => [LH_C h⁴ mappend_lh(t⁴, ys⁰)] | LH_N  => ys⁰}: 75
//│ [LH_N]: 198 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ [LH_N]: 200 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ [LH_C take_lh(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh(_lh_collect_arg1⁰, drop_lh(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]: 215 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ [LH_N]: 221 --->
//│ 	case ls² of {LH_C h² t² => [LH_C h² take_lh((n⁰ - 1), t²)] | LH_N  => [LH_N]}: 50
//│ 	case _lh_collect_arg2⁰ of {LH_N  => [LH_N] | _  => [LH_C take_lh(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh(_lh_collect_arg1⁰, drop_lh(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]}: 216
//│ 	case _lh_drop_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰ => if (_lh_drop_arg1⁰ > 0) then drop_lh((_lh_drop_arg1⁰ - 1), _lh_drop_LH_C_1⁰) else [LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰] | _  => error⁰}: 241
//│ [LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰]: 238 --->
//│ 	case ls² of {LH_C h² t² => [LH_C h² take_lh((n⁰ - 1), t²)] | LH_N  => [LH_N]}: 50
//│ 	case _lh_collect_arg2⁰ of {LH_N  => [LH_N] | _  => [LH_C take_lh(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh(_lh_collect_arg1⁰, drop_lh(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]}: 216
//│ 	case _lh_drop_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰ => if (_lh_drop_arg1⁰ > 0) then drop_lh((_lh_drop_arg1⁰ - 1), _lh_drop_LH_C_1⁰) else [LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰] | _  => error⁰}: 241
//│ ------------------
//│ case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh(f⁰, t⁰)] | LH_N  => [LH_N]}: 12 --->
//│ 	[LH_C f⁰(h⁰) map_lh(f⁰, t⁰)]: 10
//│ 	[LH_N]: 11
//│ 	[LH_N]: 198
//│ 	[LH_N]: 200
//│ 	[LH_C take_lh(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh(_lh_collect_arg1⁰, drop_lh(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]: 215
//│ case ls¹ of {LH_C h¹ t¹ => foldl_lh(f¹, f¹(i⁰, h¹), t¹) | LH_N  => i⁰}: 28 --->
//│ 	NoProd
//│ 	[LH_C h² take_lh((n⁰ - 1), t²)]: 48
//│ 	[LH_N]: 49
//│ 	[LH_N]: 51
//│ 	[LH_C h⁴ mappend_lh(t⁴, ys⁰)]: 73
//│ 	[LH_N]: 86
//│ 	[LH_N]: 115
//│ 	[LH_C 'n' [LH_N]]: 116
//│ case ls² of {LH_C h² t² => [LH_C h² take_lh((n⁰ - 1), t²)] | LH_N  => [LH_N]}: 50 --->
//│ 	NoProd
//│ 	[LH_N]: 221
//│ 	[LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰]: 238
//│ case xs⁰ of {LH_C h⁴ t⁴ => [LH_C h⁴ mappend_lh(t⁴, ys⁰)] | LH_N  => ys⁰}: 75 --->
//│ 	NoProd
//│ 	[LH_C h² take_lh((n⁰ - 1), t²)]: 48
//│ 	[LH_N]: 49
//│ 	[LH_N]: 51
//│ 	[LH_C h⁴ mappend_lh(t⁴, ys⁰)]: 73
//│ 	[LH_N]: 86
//│ 	[LH_N]: 115
//│ 	[LH_C 'n' [LH_N]]: 116
//│ case lss⁰ of {LH_C h⁵ t⁵ => mappend_lh(h⁵, concat_lh(t⁵)) | LH_N  => [LH_N]}: 87 --->
//│ 	[LH_C f⁰(h⁰) map_lh(f⁰, t⁰)]: 10
//│ 	[LH_N]: 11
//│ case _lh_collect_arg2⁰ of {LH_N  => [LH_N] | _  => [LH_C take_lh(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh(_lh_collect_arg1⁰, drop_lh(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]}: 216 --->
//│ 	NoProd
//│ 	[LH_N]: 221
//│ 	[LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰]: 238
//│ case _lh_drop_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰ => if (_lh_drop_arg1⁰ > 0) then drop_lh((_lh_drop_arg1⁰ - 1), _lh_drop_LH_C_1⁰) else [LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰] | _  => error⁰}: 241 --->
//│ 	NoProd
//│ 	[LH_N]: 221
//│ 	[LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰]: 238
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testRsa_nofib_lh(primId⁰(50520))
//│ def code_lh(_lh_code_arg1¹) = foldl_lh((fun x¹ -> (fun y¹ -> ((128 * x¹) + int_of_char⁰(y¹)))), 0, _lh_code_arg1¹)
//│ def collect_lh(_lh_collect_arg1¹, _lh_collect_arg2¹) = case _lh_collect_arg1¹ of {
//│ 	0  => [LH_N]
//│ 	| _  => case _lh_collect_arg2¹ of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => [LH_C take_lh(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_lh(_lh_collect_arg1¹, drop_lh(_lh_collect_arg1¹, _lh_collect_arg2¹))]}}
//│ def concat_lh(lss¹) = case lss¹ of {
//│ 	LH_C h⁵ t⁵ => mappend_lh(h⁵, concat_lh(t⁵))
//│ 	| LH_N  => [LH_N]}
//│ def copy_lh(_lh_copy_arg1¹, _lh_copy_arg2¹) = case _lh_copy_arg1¹ of {
//│ 	0  => [LH_N]
//│ 	| _  => [LH_C _lh_copy_arg2¹ copy_lh((_lh_copy_arg1¹ - 1), _lh_copy_arg2¹)]}
//│ def drop_lh(_lh_drop_arg1¹, _lh_drop_arg2¹) = case _lh_drop_arg2¹ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰ => if (_lh_drop_arg1¹ > 0) then drop_lh((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1⁰) else [LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰]
//│ 	| _  => error⁰}
//│ def encrypt_lh(_lh_encrypt_arg1¹, _lh_encrypt_arg2¹, _lh_funcomp_x⁴) = (fun _lh_funcomp_x⁵ -> unlines_lh(map_lh((fun _lh_funcomp_x⁶ -> (fun _lh_funcomp_x⁷ -> string_of_int⁰(power_lh(_lh_encrypt_arg2¹, _lh_encrypt_arg1¹, _lh_funcomp_x⁷)))(code_lh(_lh_funcomp_x⁶))), _lh_funcomp_x⁵)))(collect_lh(size_lh(_lh_encrypt_arg1¹), _lh_funcomp_x⁴))
//│ def even_lh(_lh_even_arg1¹) = ((_lh_even_arg1¹ % 2) == 0)
//│ def foldl_lh(f², i¹, ls⁶) = case ls⁶ of {
//│ 	LH_C h¹ t¹ => foldl_lh(f², f²(i¹, h¹), t¹)
//│ 	| LH_N  => i¹}
//│ def length_lh(ls⁴) = case ls⁴ of {
//│ 	LH_C h³ t³ => (1 + length_lh(t³))
//│ 	| LH_N  => 0}
//│ def map_lh(f³, ls⁷) = case ls⁷ of {
//│ 	LH_C h⁰ t⁰ => [LH_C f³(h⁰) map_lh(f³, t⁰)]
//│ 	| LH_N  => [LH_N]}
//│ def mappend_lh(xs¹, ys¹) = case xs¹ of {
//│ 	LH_C h⁴ t⁴ => [LH_C h⁴ mappend_lh(t⁴, ys¹)]
//│ 	| LH_N  => ys¹}
//│ def power_lh(_lh_power_arg1¹, _lh_power_arg2¹, _lh_power_arg3¹) = case _lh_power_arg1¹ of {
//│ 	0  => 1
//│ 	| _  => if even_lh(_lh_power_arg1¹) then (sqr_lh(power_lh(div⁰(_lh_power_arg1¹, 2), _lh_power_arg2¹, _lh_power_arg3¹)) % _lh_power_arg2¹) else ((_lh_power_arg3¹ * power_lh((_lh_power_arg1¹ - 1), _lh_power_arg2¹, _lh_power_arg3¹)) % _lh_power_arg2¹)}
//│ def size_lh(_lh_size_arg1¹) = div⁰((length_lh(string_of_int⁰(_lh_size_arg1¹)) * 47), 100)
//│ def sqr_lh(_lh_sqr_arg1¹) = (_lh_sqr_arg1¹ * _lh_sqr_arg1¹)
//│ def take_lh(n¹, ls⁵) = if (n¹ > 0) then case ls⁵ of {
//│ 	LH_C h² t² => [LH_C h² take_lh((n¹ - 1), t²)]
//│ 	| LH_N  => [LH_N]} else [LH_N]
//│ def testRsa_nofib_lh(_lh_testRsa_nofib_arg1¹) = encrypt_lh(6367, 5189, primId⁰(copy_lh(_lh_testRsa_nofib_arg1¹, 'l')))
//│ def unlines_lh(_lh_unlines_arg1¹) = concat_lh(map_lh((fun l¹ -> mappend_lh(l¹, [LH_C 'n' [LH_N]])), _lh_unlines_arg1¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<





