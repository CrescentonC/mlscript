


:lhInHaskell
:lhGenOCaml
:lhUseZarith
const0 = z_of_int 0
const31 = z_of_int 31
const1 = z_of_int 1
const2 = z_of_int 2
const128 = z_of_int 128
hash str = foldl (\acc -> \c -> z_add (z_of_int (int_of_char c)) (z_mul acc (const31))) (const0) str
and [] = True
and (h:t) = if h then (and t) else False
unlines ls = concat (map (\l -> l ++ ['n']) ls)
even a = z_equal (z_mod a (const2)) (const0)
drop n [] = []
drop n (h:t) = if n > 0 then (drop (n - 1) t) else (h:t)
encrypt n e = unlines . map (string_of_z . power e n . code) . collect (size n)
code ls = foldl (\x y -> z_add (z_mul (const128) x) (z_of_int (int_of_char y))) (const0) ls
collect 0 xs = []
collect n [] = []
collect n xs = (take n xs) : collect n (drop n xs)
size n = ((length (string_of_z n)) * 47) `div` 100
--- power 0 m x = 1
--- power n m x = if (even n) then ((sqr (power (n `div` 2) m x)) `mod` m) else ((x * (power (n-1) m x)) `mod` m)
power n m x = if (z_equal n (const0)) then
                (const1)
              else
                if (even n) then (z_mod (sqr (power (z_div n (const2)) m x)) m) else (z_mod (z_mul x (power (z_sub n (const1)) m x)) m)
sqr x = z_mul x x
input = from_large_str "module Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h------- Fast exponentiation, mod m -----------------power :: Integer -> Integer -> Integer -> Integerpower 0 m x          = 1power n m x | even n = sqr (power (n `div` 2) m x) `mod` m	    | True   = (x * power (n-1) m x) `mod` msqr :: Integer -> Integersqr x = x * x\\section{AbsDensematrix}This module imports the contents of Densematrix and exports some of thefunctions renaming many of them for use by Matrix. The original %includestatement(from Matrix) is left as a comment at the foot of this file.\\begin{code}module AbsDensematrix(Block,Vec,bmult,bvecmult,vecbmult,vecdot,vecnorm,                      vecouter,badd,bsub,vecadd,vecsub,bsize,vecsize,bneg,                      bxpose,bident,vecneg,svecmult,mkblock,bswaprow,bswapcol,                      bdroprow,bgetrow,bgetcol,bsubscript,vecsubscript,bupdate,                      vecupdate,vechd,vectl,mergevecs,binverse,showblock,                     showvec, mkvec,mkrvec,vecpart,update2,veclist,matlist)       whereimport Densematrixtype Block = Matrixtype Vec = Vectorbmult = mmultbvecmult = matvecmultvecbmult = vmmultvecdot   = vdotvecnorm = normvecouter = vouterbadd = maddbsub = msubvecadd = vaddvecsub = vsubbsize = msizevecsize = vsizebneg = mnegbxpose = mxposebident = midentvecneg = vnegsvecmult = svmultmkblock = mkmatbswaprow = swaprowbswapcol = swapcolbdroprow = droprowbgetrow = getrowbgetcol = getcolbsubscript = subscriptvecsubscript = vsubscriptbupdate = updatevecupdate = vupdatevechd = vhdvectl = vtlmergevecs = mergevectorsbinverse = minverseshowblock = showmatrixshowvec = displayvector\\end{code}The original include statement from Matrix :- %include \"densematrix\"                         block/matrix  vec/vector                         bmult/mmult   bvecmult/mvmult vecbmult/vmmult                         vecdot/vdot   vecnorm/norm    vecouter/vouterr                         badd/madd     bsub/msub  vecadd/vadd vecsub/vsub                         bsize/msize   vecsize/vsize                         bneg/mneg     bxpose/mxpose   bident/mident                         vecneg/vneg   svecmult/svmult                         mkblock/mkmat                         -mkrmat -mkcmat -mkcvec                         bswaprow/swaprow       bswapcol/swapcol                         bdroprow/droprow       bgetrow/getrow bgetcol/getcol                         bsubscript/subscript   vecsubscript/vsubscript                         bupdate/update         vecupdate/vupdate                         vechd/vhd              vectl/vtl                         mergevecs/mergevectors                         binverse/minverse                         showblock/showmatrix showvec/showvectormodule Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h------- Fast exponentiation, mod m -----------------power :: Integer -> Integer -> Integer -> Integerpower 0 m x          = 1power n m x | even n = sqr (power (n `div` 2) m x) `mod` m	    | True   = (x * power (n-1) m x) `mod` msqr :: Integer -> Integersqr x = x * x\\section{AbsDensematrix}This module imports the contents of Densematrix and exports some of thefunctions renaming many of them for use by Matrix. The original %includestatement(from Matrix) is left as a comment at the foot of this file.\\begin{code}module AbsDensematrix(Block,Vec,bmult,bvecmult,vecbmult,vecdot,vecnorm,                      vecouter,badd,bsub,vecadd,vecsub,bsize,vecsize,bneg,                      bxpose,bident,vecneg,svecmult,mkblock,bswaprow,bswapcol,                      bdroprow,bgetrow,bgetcol,bsubscript,vecsubscript,bupdate,                      vecupdate,vechd,vectl,mergevecs,binverse,showblock,                     showvec, mkvec,mkrvec,vecpart,update2,veclist,matlist)       whereimport Densematrixtype Block = Matrixtype Vec = Vectorbmult = mmultbvecmult = matvecmultvecbmult = vmmultvecdot   = vdotvecnorm = normvecouter = vouterbadd = maddbsub = msubvecadd = vaddvecsub = vsubbsize = msizevecsize = vsizebneg = mnegbxpose = mxposebident = midentvecneg = vnegsvecmult = svmultmkblock = mkmatbswaprow = swaprowbswapcol = swapcolbdroprow = droprowbgetrow = getrowbgetcol = getcolbsubscript = subscriptvecsubscript = vsubscriptbupdate = updatevecupdate = vupdatevechd = vhdvectl = vtlmergevecs = mergevectorsbinverse = minverseshowblock = showmatrixshowvec = displayvector\\end{code}The original include statement from Matrix :- %include \"densematrix\"                         block/matrix  vec/vector                         bmult/mmult   bvecmult/mvmult vecbmult/vmmult                         vecdot/vdot   vecnorm/norm    vecouter/vouterr                         badd/madd     bsub/msub  vecadd/vadd vecsub/vsub                         bsize/msize   vecsize/vsize                         bneg/mneg     bxpose/mxpose   bident/mident                         vecneg/vneg   svecmult/svmult                         mkblock/mkmat                         -mkrmat -mkcmat -mkcvec                         bswaprow/swaprow       bswapcol/swapcol                         bdroprow/droprow       bgetrow/getrow bgetcol/getcol                         bsubscript/subscript   vecsubscript/vsubscript                         bupdate/update         vecupdate/vupdate                         vechd/vhd              vectl/vtl                         mergevecs/mergevectors                         binverse/minverse                         showblock/showmatrix showvec/showvectormodule Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h"
testRsa_nofib _ = hash (encrypt
                          (z_of_string "2036450659413645137870851576872812267542175329986469156678671505255564383842535488743101632280716717779536712424613501441720195827856504007305662157107")
                          (z_of_string "387784473137902876992546516170169092918207676456888779623592396031349415024943784869634893342729620092877891356118467738167515879252473323905128540213")
                          input
                        )
testRsa_nofib $ primId 0
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> after expansion >>>>>>>>>>
//│ testRsa_nofib_lh_₁(primId⁰(0))
//│ def code_lh_₁(_lh_code_arg1⁰) = foldl_lh_₂((fun x⁰ -> (fun y⁰ -> z_add⁰(z_mul⁰(const128_lh_₁, x⁰), z_of_int⁰(int_of_char⁰(y⁰))))), const0_lh_₃, _lh_code_arg1⁰)
//│ def collect_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰) = case _lh_collect_arg1⁰ of {
//│ 	0  => [LH_N]
//│ 	| _  => case _lh_collect_arg2⁰ of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => [LH_C take_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰) collect_lh_₁(_lh_collect_arg1⁰, drop_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰))]}}
//│ def concat_lh_₁(lss⁰) = case lss⁰ of {
//│ 	LH_C h² t² => mappend_lh_₂(h², concat_lh_₁(t²))
//│ 	| LH_N  => [LH_N]}
//│ def const0_lh_₁ = z_of_int⁰(0)
//│ def const0_lh_₂ = z_of_int⁰(0)
//│ def const0_lh_₃ = z_of_int⁰(0)
//│ def const0_lh_₄ = z_of_int⁰(0)
//│ def const128_lh_₁ = z_of_int⁰(128)
//│ def const1_lh_₁ = z_of_int⁰(1)
//│ def const1_lh_₂ = z_of_int⁰(1)
//│ def const2_lh_₁ = z_of_int⁰(2)
//│ def const2_lh_₂ = z_of_int⁰(2)
//│ def const31_lh_₁ = z_of_int⁰(31)
//│ def drop_lh_₁(_lh_drop_arg1⁰, _lh_drop_arg2⁰) = case _lh_drop_arg2⁰ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰ => if (_lh_drop_arg1⁰ > 0) then drop_lh_₁((_lh_drop_arg1⁰ - 1), _lh_drop_LH_C_1⁰) else [LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰]}
//│ def encrypt_lh_₁(_lh_encrypt_arg1⁰, _lh_encrypt_arg2⁰, _lh_funcomp_x⁰) = (fun _lh_funcomp_x¹ -> unlines_lh_₁(map_lh_₁((fun _lh_funcomp_x² -> (fun _lh_funcomp_x³ -> string_of_z⁰(power_lh_₁(_lh_encrypt_arg2⁰, _lh_encrypt_arg1⁰, _lh_funcomp_x³)))(code_lh_₁(_lh_funcomp_x²))), _lh_funcomp_x¹)))(collect_lh_₁(size_lh_₁(_lh_encrypt_arg1⁰), _lh_funcomp_x⁰))
//│ def even_lh_₁(_lh_even_arg1⁰) = z_equal⁰(z_mod⁰(_lh_even_arg1⁰, const2_lh_₂), const0_lh_₄)
//│ def foldl_lh_₁(f², i¹, ls⁴) = case ls⁴ of {
//│ 	LH_C h⁷ t⁷ => foldl_lh_₁(f², f²(i¹, h⁷), t⁷)
//│ 	| LH_N  => i¹}
//│ def foldl_lh_₂(f¹, i⁰, ls³) = case ls³ of {
//│ 	LH_C h⁶ t⁶ => foldl_lh_₂(f¹, f¹(i⁰, h⁶), t⁶)
//│ 	| LH_N  => i⁰}
//│ def hash_lh_₁(_lh_hash_arg1⁰) = foldl_lh_₁((fun acc⁰ -> (fun c⁰ -> z_add⁰(z_of_int⁰(int_of_char⁰(c⁰)), z_mul⁰(acc⁰, const31_lh_₁)))), const0_lh_₁, _lh_hash_arg1⁰)
//│ def input_lh_₁ = from_large_str⁰("module Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h------- Fast exponentiation, mod m -----------------power :: Integer -> Integer -> Integer -> Integerpower 0 m x          = 1power n m x | even n = sqr (power (n `div` 2) m x) `mod` m	    | True   = (x * power (n-1) m x) `mod` msqr :: Integer -> Integersqr x = x * x\\section{AbsDensematrix}This module imports the contents of Densematrix and exports some of thefunctions renaming many of them for use by Matrix. The original %includestatement(from Matrix) is left as a comment at the foot of this file.\\begin{code}module AbsDensematrix(Block,Vec,bmult,bvecmult,vecbmult,vecdot,vecnorm,                      vecouter,badd,bsub,vecadd,vecsub,bsize,vecsize,bneg,                      bxpose,bident,vecneg,svecmult,mkblock,bswaprow,bswapcol,                      bdroprow,bgetrow,bgetcol,bsubscript,vecsubscript,bupdate,                      vecupdate,vechd,vectl,mergevecs,binverse,showblock,                     showvec, mkvec,mkrvec,vecpart,update2,veclist,matlist)       whereimport Densematrixtype Block = Matrixtype Vec = Vectorbmult = mmultbvecmult = matvecmultvecbmult = vmmultvecdot   = vdotvecnorm = normvecouter = vouterbadd = maddbsub = msubvecadd = vaddvecsub = vsubbsize = msizevecsize = vsizebneg = mnegbxpose = mxposebident = midentvecneg = vnegsvecmult = svmultmkblock = mkmatbswaprow = swaprowbswapcol = swapcolbdroprow = droprowbgetrow = getrowbgetcol = getcolbsubscript = subscriptvecsubscript = vsubscriptbupdate = updatevecupdate = vupdatevechd = vhdvectl = vtlmergevecs = mergevectorsbinverse = minverseshowblock = showmatrixshowvec = displayvector\\end{code}The original include statement from Matrix :- %include \"densematrix\"                         block/matrix  vec/vector                         bmult/mmult   bvecmult/mvmult vecbmult/vmmult                         vecdot/vdot   vecnorm/norm    vecouter/vouterr                         badd/madd     bsub/msub  vecadd/vadd vecsub/vsub                         bsize/msize   vecsize/vsize                         bneg/mneg     bxpose/mxpose   bident/mident                         vecneg/vneg   svecmult/svmult                         mkblock/mkmat                         -mkrmat -mkcmat -mkcvec                         bswaprow/swaprow       bswapcol/swapcol                         bdroprow/droprow       bgetrow/getrow bgetcol/getcol                         bsubscript/subscript   vecsubscript/vsubscript                         bupdate/update         vecupdate/vupdate                         vechd/vhd              vectl/vtl                         mergevecs/mergevectors                         binverse/minverse                         showblock/showmatrix showvec/showvectormodule Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h------- Fast exponentiation, mod m -----------------power :: Integer -> Integer -> Integer -> Integerpower 0 m x          = 1power n m x | even n = sqr (power (n `div` 2) m x) `mod` m	    | True   = (x * power (n-1) m x) `mod` msqr :: Integer -> Integersqr x = x * x\\section{AbsDensematrix}This module imports the contents of Densematrix and exports some of thefunctions renaming many of them for use by Matrix. The original %includestatement(from Matrix) is left as a comment at the foot of this file.\\begin{code}module AbsDensematrix(Block,Vec,bmult,bvecmult,vecbmult,vecdot,vecnorm,                      vecouter,badd,bsub,vecadd,vecsub,bsize,vecsize,bneg,                      bxpose,bident,vecneg,svecmult,mkblock,bswaprow,bswapcol,                      bdroprow,bgetrow,bgetcol,bsubscript,vecsubscript,bupdate,                      vecupdate,vechd,vectl,mergevecs,binverse,showblock,                     showvec, mkvec,mkrvec,vecpart,update2,veclist,matlist)       whereimport Densematrixtype Block = Matrixtype Vec = Vectorbmult = mmultbvecmult = matvecmultvecbmult = vmmultvecdot   = vdotvecnorm = normvecouter = vouterbadd = maddbsub = msubvecadd = vaddvecsub = vsubbsize = msizevecsize = vsizebneg = mnegbxpose = mxposebident = midentvecneg = vnegsvecmult = svmultmkblock = mkmatbswaprow = swaprowbswapcol = swapcolbdroprow = droprowbgetrow = getrowbgetcol = getcolbsubscript = subscriptvecsubscript = vsubscriptbupdate = updatevecupdate = vupdatevechd = vhdvectl = vtlmergevecs = mergevectorsbinverse = minverseshowblock = showmatrixshowvec = displayvector\\end{code}The original include statement from Matrix :- %include \"densematrix\"                         block/matrix  vec/vector                         bmult/mmult   bvecmult/mvmult vecbmult/vmmult                         vecdot/vdot   vecnorm/norm    vecouter/vouterr                         badd/madd     bsub/msub  vecadd/vadd vecsub/vsub                         bsize/msize   vecsize/vsize                         bneg/mneg     bxpose/mxpose   bident/mident                         vecneg/vneg   svecmult/svmult                         mkblock/mkmat                         -mkrmat -mkcmat -mkcvec                         bswaprow/swaprow       bswapcol/swapcol                         bdroprow/droprow       bgetrow/getrow bgetcol/getcol                         bsubscript/subscript   vecsubscript/vsubscript                         bupdate/update         vecupdate/vupdate                         vechd/vhd              vectl/vtl                         mergevecs/mergevectors                         binverse/minverse                         showblock/showmatrix showvec/showvectormodule Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h")
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h¹ t¹ => (1 + length_lh_₁(t¹))
//│ 	| LH_N  => 0}
//│ def map_lh_₁(f³, ls⁵) = case ls⁵ of {
//│ 	LH_C h⁸ t⁸ => [LH_C f³(h⁸) map_lh_₁(f³, t⁸)]
//│ 	| LH_N  => [LH_N]}
//│ def map_lh_₂(f⁰, ls¹) = case ls¹ of {
//│ 	LH_C h⁴ t⁴ => [LH_C f⁰(h⁴) map_lh_₂(f⁰, t⁴)]
//│ 	| LH_N  => [LH_N]}
//│ def mappend_lh_₁(xs¹, ys¹) = case xs¹ of {
//│ 	LH_C h³ t³ => [LH_C h³ mappend_lh_₁(t³, ys¹)]
//│ 	| LH_N  => ys¹}
//│ def mappend_lh_₂(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₂(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def power_lh_₁(_lh_power_arg1⁰, _lh_power_arg2⁰, _lh_power_arg3⁰) = if z_equal⁰(_lh_power_arg1⁰, const0_lh_₂) then const1_lh_₂ else if even_lh_₁(_lh_power_arg1⁰) then z_mod⁰(sqr_lh_₁(power_lh_₁(z_div⁰(_lh_power_arg1⁰, const2_lh_₁), _lh_power_arg2⁰, _lh_power_arg3⁰)), _lh_power_arg2⁰) else z_mod⁰(z_mul⁰(_lh_power_arg3⁰, power_lh_₁(z_sub⁰(_lh_power_arg1⁰, const1_lh_₁), _lh_power_arg2⁰, _lh_power_arg3⁰)), _lh_power_arg2⁰)
//│ def size_lh_₁(_lh_size_arg1⁰) = div⁰((length_lh_₁(string_of_z⁰(_lh_size_arg1⁰)) * 47), 100)
//│ def sqr_lh_₁(_lh_sqr_arg1⁰) = z_mul⁰(_lh_sqr_arg1⁰, _lh_sqr_arg1⁰)
//│ def take_lh_₁(n⁰, ls²) = if (n⁰ > 0) then case ls² of {
//│ 	LH_C h⁵ t⁵ => [LH_C h⁵ take_lh_₁((n⁰ - 1), t⁵)]
//│ 	| LH_N  => [LH_N]} else [LH_N]
//│ def testRsa_nofib_lh_₁(_lh_testRsa_nofib_arg1⁰) = hash_lh_₁(encrypt_lh_₁(z_of_string⁰("2036450659413645137870851576872812267542175329986469156678671505255564383842535488743101632280716717779536712424613501441720195827856504007305662157107"), z_of_string⁰("387784473137902876992546516170169092918207676456888779623592396031349415024943784869634893342729620092877891356118467738167515879252473323905128540213"), input_lh_₁))
//│ def unlines_lh_₁(_lh_unlines_arg1⁰) = concat_lh_₁(map_lh_₂((fun l⁰ -> mappend_lh_₁(l⁰, [LH_C 'n' [LH_N]])), _lh_unlines_arg1⁰))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec input_lh__d1 =
//│ 		  lh_large_str_0;;
//│ 		let rec const31_lh__d1 =
//│ 		  (Z.of_int 31);;
//│ 		let rec const0_lh__d1 =
//│ 		  (Z.of_int 0);;
//│ 		let rec foldl_lh__d1 f_2 i_1 ls_4 =
//│ 		  (match ls_4 with
//│ 		    | `LH_C(h_7, t_7) -> 
//│ 		      (((foldl_lh__d1 f_2) ((f_2 i_1) h_7)) t_7)
//│ 		    | `LH_N -> 
//│ 		      i_1);;
//│ 		let rec hash_lh__d1 _lh_hash_arg1_0 =
//│ 		  (((foldl_lh__d1 (fun acc_0 c_0 -> 
//│ 		    ((Z.add (Z.of_int (int_of_char c_0))) ((Z.mul acc_0) const31_lh__d1)))) const0_lh__d1) _lh_hash_arg1_0);;
//│ 		let rec const2_lh__d1 =
//│ 		  (Z.of_int 2);;
//│ 		let rec const0_lh__d2 =
//│ 		  (Z.of_int 0);;
//│ 		let rec const0_lh__d4 =
//│ 		  (Z.of_int 0);;
//│ 		let rec const2_lh__d2 =
//│ 		  (Z.of_int 2);;
//│ 		let rec even_lh__d1 _lh_even_arg1_0 =
//│ 		  ((Z.equal ((Z.rem _lh_even_arg1_0) const2_lh__d2)) const0_lh__d4);;
//│ 		let rec const1_lh__d2 =
//│ 		  (Z.of_int 1);;
//│ 		let rec sqr_lh__d1 _lh_sqr_arg1_0 =
//│ 		  ((Z.mul _lh_sqr_arg1_0) _lh_sqr_arg1_0);;
//│ 		let rec const1_lh__d1 =
//│ 		  (Z.of_int 1);;
//│ 		let rec power_lh__d1 _lh_power_arg1_0 _lh_power_arg2_0 _lh_power_arg3_0 =
//│ 		  (if ((Z.equal _lh_power_arg1_0) const0_lh__d2) then
//│ 		    const1_lh__d2
//│ 		  else
//│ 		    (if (even_lh__d1 _lh_power_arg1_0) then
//│ 		      ((Z.rem (sqr_lh__d1 (((power_lh__d1 ((Z.div _lh_power_arg1_0) const2_lh__d1)) _lh_power_arg2_0) _lh_power_arg3_0))) _lh_power_arg2_0)
//│ 		    else
//│ 		      ((Z.rem ((Z.mul _lh_power_arg3_0) (((power_lh__d1 ((Z.sub _lh_power_arg1_0) const1_lh__d1)) _lh_power_arg2_0) _lh_power_arg3_0))) _lh_power_arg2_0)));;
//│ 		let rec map_lh__d1 f_3 ls_5 =
//│ 		  (match ls_5 with
//│ 		    | `LH_C(h_8, t_8) -> 
//│ 		      (`LH_C((f_3 h_8), ((map_lh__d1 f_3) t_8)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec drop_lh__d1 _lh_drop_arg1_0 _lh_drop_arg2_0 =
//│ 		  (match _lh_drop_arg2_0 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_drop_LH_C_0_0, _lh_drop_LH_C_1_0) -> 
//│ 		      (if (_lh_drop_arg1_0 > 0) then
//│ 		        ((drop_lh__d1 (_lh_drop_arg1_0 - 1)) _lh_drop_LH_C_1_0)
//│ 		      else
//│ 		        (`LH_C(_lh_drop_LH_C_0_0, _lh_drop_LH_C_1_0))));;
//│ 		let rec take_lh__d1 n_0 ls_2 =
//│ 		  (if (n_0 > 0) then
//│ 		    (match ls_2 with
//│ 		      | `LH_C(h_5, t_5) -> 
//│ 		        (`LH_C(h_5, ((take_lh__d1 (n_0 - 1)) t_5)))
//│ 		      | `LH_N -> 
//│ 		        (`LH_N))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec collect_lh__d1 _lh_collect_arg1_0 _lh_collect_arg2_0 =
//│ 		  (match _lh_collect_arg1_0 with
//│ 		    | 0 -> 
//│ 		      (`LH_N)
//│ 		    | _ -> 
//│ 		      (match _lh_collect_arg2_0 with
//│ 		        | `LH_N -> 
//│ 		          (`LH_N)
//│ 		        | _ -> 
//│ 		          (`LH_C(((take_lh__d1 _lh_collect_arg1_0) _lh_collect_arg2_0), ((collect_lh__d1 _lh_collect_arg1_0) ((drop_lh__d1 _lh_collect_arg1_0) _lh_collect_arg2_0))))));;
//│ 		let rec foldl_lh__d2 f_1 i_0 ls_3 =
//│ 		  (match ls_3 with
//│ 		    | `LH_C(h_6, t_6) -> 
//│ 		      (((foldl_lh__d2 f_1) ((f_1 i_0) h_6)) t_6)
//│ 		    | `LH_N -> 
//│ 		      i_0);;
//│ 		let rec const0_lh__d3 =
//│ 		  (Z.of_int 0);;
//│ 		let rec const128_lh__d1 =
//│ 		  (Z.of_int 128);;
//│ 		let rec code_lh__d1 _lh_code_arg1_0 =
//│ 		  (((foldl_lh__d2 (fun x_0 y_0 -> 
//│ 		    ((Z.add ((Z.mul const128_lh__d1) x_0)) (Z.of_int (int_of_char y_0))))) const0_lh__d3) _lh_code_arg1_0);;
//│ 		let rec length_lh__d1 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      (1 + (length_lh__d1 t_1))
//│ 		    | `LH_N -> 
//│ 		      0);;
//│ 		let rec size_lh__d1 _lh_size_arg1_0 =
//│ 		  (((length_lh__d1 (string_of_z _lh_size_arg1_0)) * 47) / 100);;
//│ 		let rec mappend_lh__d1 xs_1 ys_1 =
//│ 		  (match xs_1 with
//│ 		    | `LH_C(h_3, t_3) -> 
//│ 		      (`LH_C(h_3, ((mappend_lh__d1 t_3) ys_1)))
//│ 		    | `LH_N -> 
//│ 		      ys_1);;
//│ 		let rec mappend_lh__d2 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (`LH_C(h_0, ((mappend_lh__d2 t_0) ys_0)))
//│ 		    | `LH_N -> 
//│ 		      ys_0);;
//│ 		let rec concat_lh__d1 lss_0 =
//│ 		  (match lss_0 with
//│ 		    | `LH_C(h_2, t_2) -> 
//│ 		      ((mappend_lh__d2 h_2) (concat_lh__d1 t_2))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec map_lh__d2 f_0 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `LH_C(h_4, t_4) -> 
//│ 		      (`LH_C((f_0 h_4), ((map_lh__d2 f_0) t_4)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec unlines_lh__d1 _lh_unlines_arg1_0 =
//│ 		  (concat_lh__d1 ((map_lh__d2 (fun l_0 -> 
//│ 		    ((mappend_lh__d1 l_0) (`LH_C('n', (`LH_N)))))) _lh_unlines_arg1_0));;
//│ 		let rec encrypt_lh__d1 _lh_encrypt_arg1_0 _lh_encrypt_arg2_0 _lh_funcomp_x_0 =
//│ 		  ((fun _lh_funcomp_x_1 -> 
//│ 		    (unlines_lh__d1 ((map_lh__d1 (fun _lh_funcomp_x_2 -> 
//│ 		      ((fun _lh_funcomp_x_3 -> 
//│ 		        (string_of_z (((power_lh__d1 _lh_encrypt_arg2_0) _lh_encrypt_arg1_0) _lh_funcomp_x_3))) (code_lh__d1 _lh_funcomp_x_2)))) _lh_funcomp_x_1))) ((collect_lh__d1 (size_lh__d1 _lh_encrypt_arg1_0)) _lh_funcomp_x_0));;
//│ 		let rec testRsa_nofib_lh__d1 _lh_testRsa_nofib_arg1_0 =
//│ 		  (hash_lh__d1 (((encrypt_lh__d1 lh_large_int_0) lh_large_int_1) input_lh__d1));;
//│ 		(testRsa_nofib_lh__d1 0)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< after expansion <<<<<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testRsa_nofib_lh_₁(primId⁰(0))
//│ def code_lh_₁(_lh_code_arg1⁰) = foldl_lh_₂((fun x⁰ -> (fun y⁰ -> z_add⁰(z_mul⁰(const128_lh_₁, x⁰), z_of_int⁰(int_of_char⁰(y⁰))))), const0_lh_₃, _lh_code_arg1⁰)
//│ def collect_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰, _lh_floatOutId_0¹, _lh_floatOutId_1¹, _lh_floatOutId_2¹) = case _lh_collect_arg1⁰ of {
//│ 	0  => (fun f⁵ -> (fun i² -> i²))
//│ 	| _  => case _lh_collect_arg2⁰ of {
//│ 		LH_N  => (fun f⁸ -> (fun i³ -> i³))
//│ 		| _  => 
//│ 			let t⁰ = collect_lh_₁(_lh_collect_arg1⁰, drop_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰))
//│ 			in let h⁰ = take_lh_₁(_lh_collect_arg1⁰, _lh_collect_arg2⁰)
//│ 			in let t¹ = map_lh_₁(_lh_floatOutId_0¹, t⁰)
//│ 			in let h¹ = _lh_floatOutId_0¹(h⁰)
//│ 			in let t² = map_lh_₂(_lh_floatOutId_1¹, t¹)
//│ 			in let h² = _lh_floatOutId_1¹(h¹)
//│ 			in mappend_lh_₂(h², concat_lh_₁(t²))}}
//│ def concat_lh_₁(lss⁰) = lss⁰([lh_Unit])
//│ def const0_lh_₁ = z_of_int⁰(0)
//│ def const0_lh_₂ = z_of_int⁰(0)
//│ def const0_lh_₃ = z_of_int⁰(0)
//│ def const0_lh_₄ = z_of_int⁰(0)
//│ def const128_lh_₁ = z_of_int⁰(128)
//│ def const1_lh_₁ = z_of_int⁰(1)
//│ def const1_lh_₂ = z_of_int⁰(1)
//│ def const2_lh_₁ = z_of_int⁰(2)
//│ def const2_lh_₂ = z_of_int⁰(2)
//│ def const31_lh_₁ = z_of_int⁰(31)
//│ def drop_lh_₁(_lh_drop_arg1⁰, _lh_drop_arg2⁰) = case _lh_drop_arg2⁰ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰ => if (_lh_drop_arg1⁰ > 0) then drop_lh_₁((_lh_drop_arg1⁰ - 1), _lh_drop_LH_C_1⁰) else [LH_C _lh_drop_LH_C_0⁰ _lh_drop_LH_C_1⁰]}
//│ def encrypt_lh_₁(_lh_encrypt_arg1⁰, _lh_encrypt_arg2⁰, _lh_funcomp_x⁰) = (fun _lh_funcomp_x¹ -> unlines_lh_₁(map_lh_₁((fun _lh_funcomp_x² -> (fun _lh_funcomp_x³ -> string_of_z⁰(power_lh_₁(_lh_encrypt_arg2⁰, _lh_encrypt_arg1⁰, _lh_funcomp_x³)))(code_lh_₁(_lh_funcomp_x²))), _lh_funcomp_x¹)))(collect_lh_₁(size_lh_₁(_lh_encrypt_arg1⁰), _lh_funcomp_x⁰))
//│ def even_lh_₁(_lh_even_arg1⁰) = z_equal⁰(z_mod⁰(_lh_even_arg1⁰, const2_lh_₂), const0_lh_₄)
//│ def foldl_lh_₁(f¹, i¹, ls¹) = ls¹(f¹, i¹)
//│ def foldl_lh_₂(f⁰, i⁰, ls⁰) = ls⁰(f⁰, i⁰)
//│ def hash_lh_₁(_lh_hash_arg1⁰) = foldl_lh_₁((fun acc⁰ -> (fun c⁰ -> z_add⁰(z_of_int⁰(int_of_char⁰(c⁰)), z_mul⁰(acc⁰, const31_lh_₁)))), const0_lh_₁, _lh_hash_arg1⁰)
//│ def input_lh_₁ = from_large_str⁰("module Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h------- Fast exponentiation, mod m -----------------power :: Integer -> Integer -> Integer -> Integerpower 0 m x          = 1power n m x | even n = sqr (power (n `div` 2) m x) `mod` m	    | True   = (x * power (n-1) m x) `mod` msqr :: Integer -> Integersqr x = x * x\\section{AbsDensematrix}This module imports the contents of Densematrix and exports some of thefunctions renaming many of them for use by Matrix. The original %includestatement(from Matrix) is left as a comment at the foot of this file.\\begin{code}module AbsDensematrix(Block,Vec,bmult,bvecmult,vecbmult,vecdot,vecnorm,                      vecouter,badd,bsub,vecadd,vecsub,bsize,vecsize,bneg,                      bxpose,bident,vecneg,svecmult,mkblock,bswaprow,bswapcol,                      bdroprow,bgetrow,bgetcol,bsubscript,vecsubscript,bupdate,                      vecupdate,vechd,vectl,mergevecs,binverse,showblock,                     showvec, mkvec,mkrvec,vecpart,update2,veclist,matlist)       whereimport Densematrixtype Block = Matrixtype Vec = Vectorbmult = mmultbvecmult = matvecmultvecbmult = vmmultvecdot   = vdotvecnorm = normvecouter = vouterbadd = maddbsub = msubvecadd = vaddvecsub = vsubbsize = msizevecsize = vsizebneg = mnegbxpose = mxposebident = midentvecneg = vnegsvecmult = svmultmkblock = mkmatbswaprow = swaprowbswapcol = swapcolbdroprow = droprowbgetrow = getrowbgetcol = getcolbsubscript = subscriptvecsubscript = vsubscriptbupdate = updatevecupdate = vupdatevechd = vhdvectl = vtlmergevecs = mergevectorsbinverse = minverseshowblock = showmatrixshowvec = displayvector\\end{code}The original include statement from Matrix :- %include \"densematrix\"                         block/matrix  vec/vector                         bmult/mmult   bvecmult/mvmult vecbmult/vmmult                         vecdot/vdot   vecnorm/norm    vecouter/vouterr                         badd/madd     bsub/msub  vecadd/vadd vecsub/vsub                         bsize/msize   vecsize/vsize                         bneg/mneg     bxpose/mxpose   bident/mident                         vecneg/vneg   svecmult/svmult                         mkblock/mkmat                         -mkrmat -mkcmat -mkcvec                         bswaprow/swaprow       bswapcol/swapcol                         bdroprow/droprow       bgetrow/getrow bgetcol/getcol                         bsubscript/subscript   vecsubscript/vsubscript                         bupdate/update         vecupdate/vupdate                         vechd/vhd              vectl/vtl                         mergevecs/mergevectors                         binverse/minverse                         showblock/showmatrix showvec/showvectormodule Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h------- Fast exponentiation, mod m -----------------power :: Integer -> Integer -> Integer -> Integerpower 0 m x          = 1power n m x | even n = sqr (power (n `div` 2) m x) `mod` m	    | True   = (x * power (n-1) m x) `mod` msqr :: Integer -> Integersqr x = x * x\\section{AbsDensematrix}This module imports the contents of Densematrix and exports some of thefunctions renaming many of them for use by Matrix. The original %includestatement(from Matrix) is left as a comment at the foot of this file.\\begin{code}module AbsDensematrix(Block,Vec,bmult,bvecmult,vecbmult,vecdot,vecnorm,                      vecouter,badd,bsub,vecadd,vecsub,bsize,vecsize,bneg,                      bxpose,bident,vecneg,svecmult,mkblock,bswaprow,bswapcol,                      bdroprow,bgetrow,bgetcol,bsubscript,vecsubscript,bupdate,                      vecupdate,vechd,vectl,mergevecs,binverse,showblock,                     showvec, mkvec,mkrvec,vecpart,update2,veclist,matlist)       whereimport Densematrixtype Block = Matrixtype Vec = Vectorbmult = mmultbvecmult = matvecmultvecbmult = vmmultvecdot   = vdotvecnorm = normvecouter = vouterbadd = maddbsub = msubvecadd = vaddvecsub = vsubbsize = msizevecsize = vsizebneg = mnegbxpose = mxposebident = midentvecneg = vnegsvecmult = svmultmkblock = mkmatbswaprow = swaprowbswapcol = swapcolbdroprow = droprowbgetrow = getrowbgetcol = getcolbsubscript = subscriptvecsubscript = vsubscriptbupdate = updatevecupdate = vupdatevechd = vhdvectl = vtlmergevecs = mergevectorsbinverse = minverseshowblock = showmatrixshowvec = displayvector\\end{code}The original include statement from Matrix :- %include \"densematrix\"                         block/matrix  vec/vector                         bmult/mmult   bvecmult/mvmult vecbmult/vmmult                         vecdot/vdot   vecnorm/norm    vecouter/vouterr                         badd/madd     bsub/msub  vecadd/vadd vecsub/vsub                         bsize/msize   vecsize/vsize                         bneg/mneg     bxpose/mxpose   bident/mident                         vecneg/vneg   svecmult/svmult                         mkblock/mkmat                         -mkrmat -mkcmat -mkcvec                         bswaprow/swaprow       bswapcol/swapcol                         bdroprow/droprow       bgetrow/getrow bgetcol/getcol                         bsubscript/subscript   vecsubscript/vsubscript                         bupdate/update         vecupdate/vupdate                         vechd/vhd              vectl/vtl                         mergevecs/mergevectors                         binverse/minverse                         showblock/showmatrix showvec/showvectormodule Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h")
//│ def length_lh_₁(ls⁵) = case ls⁵ of {
//│ 	LH_C h⁸ t⁸ => (1 + length_lh_₁(t⁸))
//│ 	| LH_N  => 0}
//│ def map_lh_₁(f², ls²) = ls²(f²)
//│ def map_lh_₂(f¹⁵, ls⁴) = ls⁴(f¹⁵)
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h³ t³ => 
//│ 		let t⁴ = mappend_lh_₁(t³, ys⁰)
//│ 		in let h⁴ = h³
//│ 		in (fun ys¹ -> 
//│ 			let t⁵ = mappend_lh_₂(t⁴, ys¹)
//│ 			in let h⁵ = h⁴
//│ 			in (fun f¹¹ -> (fun i⁴ -> foldl_lh_₁(f¹¹, f¹¹(i⁴, h⁵), t⁵))))
//│ 	| LH_N  => ys⁰}
//│ def mappend_lh_₂(xs¹, ys²) = xs¹(ys²)
//│ def power_lh_₁(_lh_power_arg1⁰, _lh_power_arg2⁰, _lh_power_arg3⁰) = if z_equal⁰(_lh_power_arg1⁰, const0_lh_₂) then const1_lh_₂ else if even_lh_₁(_lh_power_arg1⁰) then z_mod⁰(sqr_lh_₁(power_lh_₁(z_div⁰(_lh_power_arg1⁰, const2_lh_₁), _lh_power_arg2⁰, _lh_power_arg3⁰)), _lh_power_arg2⁰) else z_mod⁰(z_mul⁰(_lh_power_arg3⁰, power_lh_₁(z_sub⁰(_lh_power_arg1⁰, const1_lh_₁), _lh_power_arg2⁰, _lh_power_arg3⁰)), _lh_power_arg2⁰)
//│ def size_lh_₁(_lh_size_arg1⁰) = div⁰((length_lh_₁(string_of_z⁰(_lh_size_arg1⁰)) * 47), 100)
//│ def sqr_lh_₁(_lh_sqr_arg1⁰) = z_mul⁰(_lh_sqr_arg1⁰, _lh_sqr_arg1⁰)
//│ def take_lh_₁(n⁰, ls³, _lh_floatOutId_0³, _lh_floatOutId_1³) = if (n⁰ > 0) then case ls³ of {
//│ 	LH_C h⁶ t⁶ => 
//│ 		let t⁷ = take_lh_₁((n⁰ - 1), t⁶)
//│ 		in let h⁷ = h⁶
//│ 		in foldl_lh_₂(_lh_floatOutId_0³, _lh_floatOutId_0³(_lh_floatOutId_1³, h⁷), t⁷)
//│ 	| LH_N  => _lh_floatOutId_1³} else _lh_floatOutId_1³
//│ def testRsa_nofib_lh_₁(_lh_testRsa_nofib_arg1⁰) = hash_lh_₁(encrypt_lh_₁(z_of_string⁰("2036450659413645137870851576872812267542175329986469156678671505255564383842535488743101632280716717779536712424613501441720195827856504007305662157107"), z_of_string⁰("387784473137902876992546516170169092918207676456888779623592396031349415024943784869634893342729620092877891356118467738167515879252473323905128540213"), input_lh_₁))
//│ def unlines_lh_₁(_lh_unlines_arg1⁰) = concat_lh_₁(map_lh_₂((fun l⁰ -> mappend_lh_₁(l⁰, 
//│ 	let t⁹ = (fun ys³ -> ys³)
//│ 	in let h⁹ = 'n'
//│ 	in (fun ys⁴ -> 
//│ 		let t¹⁰ = mappend_lh_₂(t⁹, ys⁴)
//│ 		in let h¹⁰ = h⁹
//│ 		in (fun f¹⁶ -> (fun i⁸ -> foldl_lh_₁(f¹⁶, f¹⁶(i⁸, h¹⁰), t¹⁰)))))), _lh_unlines_arg1⁰))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<





