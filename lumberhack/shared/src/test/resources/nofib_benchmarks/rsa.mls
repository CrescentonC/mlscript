:NewParser
:ParseOnly

:lhInHaskell
:lhGenOCaml
and [] = True
and (h:t) = if h then (and t) else False
copy 0 a = []
copy n a = a:(copy (n - 1) a)
unlines ls = concat (map (\l -> l ++ ['n']) ls)
even a = (a `mod` 2) == 0
drop n [] = []
drop n (h:t) = if n > 0 then (drop (n - 1) t) else (h:t)
encrypt n e = unlines . map (string_of_int . power e n . code) . collect (size n)
code ls = foldl (\x y -> (128 * x) + (int_of_char y)) 0 ls
decode n = reverse (expand n)
expand 0 = []
expand x = (x `mod` 128) : (expand (x `div` 128))
collect 0 xs = []
collect n [] = []
collect n xs = (take n xs) : collect n (drop n xs)
size n = (length (string_of_int n) * 47) `div` 100
prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]
nextPrime a = let odd = (if (even a) then (a + 1) else a) in (head_lz (filter_lz prime [odd,odd+2..]))
iter g v 0  w = v
iter g v h w = let fact = (g `div` h) in (iter h w (g - (fact * h)) (v - (fact * w)))
invert n a = let e = (iter n 0 a 1) in (if e < 0 then e + n else e)
power 0 m x = 1
power n m x = if (even n) then ((sqr (power (n `div` 2) m x)) `mod` m) else ((x * (power (n-1) m x)) `mod` m)
sqr x = x * x
makeKeys p' q' = let p = (nextPrime p') in (let q = (nextPrime q') in (let d = (nextPrime (p+q+1)) in (p * q, invert ((p-1) * (q-1)) d, d)))
testRsa_nofib n = encrypt 6367 5189 (primId $ copy n 'l')
testRsa_nofib $ primId 50520
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testRsa_nofib_₀^1368(primId⁰(50520))
//│ def code_₀(_lh_code_arg1¹) = foldl_₀^1160((fun x³ -> (fun y¹ -> ((128 * x³) + int_of_char⁰(y¹)))), 0, _lh_code_arg1¹)
//│ def collect_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) = case _lh_collect_arg1¹ of {
//│ 	0  => [LH_N]
//│ 	| _  => case _lh_collect_arg2¹ of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => [LH_C take_₀^1184(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀^1189(_lh_collect_arg1¹, drop_₀^1192(_lh_collect_arg1¹, _lh_collect_arg2¹))]}}
//│ def concat_₀(lss¹) = case lss¹ of {
//│ 	LH_C h²⁴ t²⁶ => mappend_₀^1297(h²⁴, concat_₀^1300(t²⁶))
//│ 	| LH_N  => [LH_N]}
//│ def copy_₀(_lh_copy_arg1¹, _lh_copy_arg2¹) = case _lh_copy_arg1¹ of {
//│ 	0  => [LH_N]
//│ 	| _  => [LH_C _lh_copy_arg2¹ copy_₀^1059((_lh_copy_arg1¹ - 1), _lh_copy_arg2¹)]}
//│ def drop_₀(_lh_drop_arg1¹, _lh_drop_arg2¹) = case _lh_drop_arg2¹ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1¹ > 0) then drop_₀^1340((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]
//│ 	| _  => error⁰}
//│ def encrypt_₀(_lh_encrypt_arg1¹, _lh_encrypt_arg2¹, _lh_funcomp_x⁴) = (fun _lh_funcomp_x⁵ -> unlines_₀^1087(map_₀^1088((fun _lh_funcomp_x⁶ -> (fun _lh_funcomp_x⁷ -> string_of_int⁰(power_₀^1090(_lh_encrypt_arg2¹, _lh_encrypt_arg1¹, _lh_funcomp_x⁷)))(code_₀^1099(_lh_funcomp_x⁶))), _lh_funcomp_x⁵)))(collect_₀^1109(size_₀^1110(_lh_encrypt_arg1¹), _lh_funcomp_x⁴))
//│ def even_₀(_lh_even_arg1¹) = ((_lh_even_arg1¹ % 2) == 0)
//│ def foldl_₀(f¹³, i³, ls²¹) = case ls²¹ of {
//│ 	LH_C h²³ t²⁵ => foldl_₀^1280(f¹³, f¹³(i³, h²³), t²⁵)
//│ 	| LH_N  => i³}
//│ def length_₀(ls²³) = case ls²³ of {
//│ 	LH_C h²⁷ t²⁹ => (1 + length_₀^1361(t²⁹))
//│ 	| LH_N  => 0}
//│ def map_₀(f¹², ls²⁰) = case ls²⁰ of {
//│ 	LH_C h²² t²⁴ => [LH_C f¹²(h²²) map_₀^1269(f¹², t²⁴)]
//│ 	| LH_N  => [LH_N]}
//│ def map_₁(f¹⁴, ls²²) = case ls²² of {
//│ 	LH_C h²⁵ t²⁷ => [LH_C f¹⁴(h²⁵) map_₁^1311(f¹⁴, t²⁷)]
//│ 	| LH_N  => [LH_N]}
//│ def mappend_₀(xs⁹, ys⁹) = case xs⁹ of {
//│ 	LH_C h²¹ t²³ => [LH_C h²¹ mappend_₀^1122(t²³, ys⁹)]
//│ 	| LH_N  => ys⁹}
//│ def mappend_₁(xs¹⁰, ys¹⁰) = case xs¹⁰ of {
//│ 	LH_C h²⁶ t²⁸ => [LH_C h²⁶ mappend_₁^1323(t²⁸, ys¹⁰)]
//│ 	| LH_N  => ys¹⁰}
//│ def power_₀(_lh_power_arg1¹, _lh_power_arg2¹, _lh_power_arg3¹) = case _lh_power_arg1¹ of {
//│ 	0  => 1
//│ 	| _  => if even_₀^1205(_lh_power_arg1¹) then (sqr_₀^1209(power_₀^1210(div⁰(_lh_power_arg1¹, 2), _lh_power_arg2¹, _lh_power_arg3¹)) % _lh_power_arg2¹) else ((_lh_power_arg3¹ * power_₀^1229((_lh_power_arg1¹ - 1), _lh_power_arg2¹, _lh_power_arg3¹)) % _lh_power_arg2¹)}
//│ def size_₀(_lh_size_arg1¹) = div⁰((length_₀^1134(string_of_int⁰(_lh_size_arg1¹)) * 47), 100)
//│ def sqr_₀(_lh_sqr_arg1¹) = (_lh_sqr_arg1¹ * _lh_sqr_arg1¹)
//│ def take_₀(n⁴, ls¹⁹) = if (n⁴ > 0) then case ls¹⁹ of {
//│ 	LH_C h²⁰ t²² => [LH_C h²⁰ take_₀^1040((n⁴ - 1), t²²)]
//│ 	| LH_N  => [LH_N]} else [LH_N]
//│ def testRsa_nofib_₀(_lh_testRsa_nofib_arg1¹) = encrypt_₀^1146(6367, 5189, primId⁰(copy_₀^1152(_lh_testRsa_nofib_arg1¹, 'l')))
//│ def unlines_₀(_lh_unlines_arg1¹) = concat_₀^1072(map_₁^1073((fun l¹ -> mappend_₁^1074(l¹, [LH_C 'n' [LH_N]])), _lh_unlines_arg1¹))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec code__d0 _lh_code_arg1_1 =
//│ 		  (((foldl__d0 (fun x_3 y_1 -> 
//│ 		    ((128 * x_3) + (int_of_char y_1)))) 0) _lh_code_arg1_1)
//│ 		and collect__d0 _lh_collect_arg1_1 _lh_collect_arg2_1 =
//│ 		  (match _lh_collect_arg1_1 with
//│ 		    | 0 -> 
//│ 		      (`LH_N)
//│ 		    | _ -> 
//│ 		      (match _lh_collect_arg2_1 with
//│ 		        | `LH_N -> 
//│ 		          (`LH_N)
//│ 		        | _ -> 
//│ 		          (`LH_C(((take__d0 _lh_collect_arg1_1) _lh_collect_arg2_1), ((collect__d0 _lh_collect_arg1_1) ((drop__d0 _lh_collect_arg1_1) _lh_collect_arg2_1))))))
//│ 		and concat__d0 lss_1 =
//│ 		  (match lss_1 with
//│ 		    | `LH_C(h_2_4, t_2_6) -> 
//│ 		      ((mappend__d0 h_2_4) (concat__d0 t_2_6))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and copy__d0 _lh_copy_arg1_1 _lh_copy_arg2_1 =
//│ 		  (match _lh_copy_arg1_1 with
//│ 		    | 0 -> 
//│ 		      (`LH_N)
//│ 		    | _ -> 
//│ 		      (`LH_C(_lh_copy_arg2_1, ((copy__d0 (_lh_copy_arg1_1 - 1)) _lh_copy_arg2_1))))
//│ 		and drop__d0 _lh_drop_arg1_1 _lh_drop_arg2_1 =
//│ 		  (match _lh_drop_arg2_1 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_drop_LH_C_0_1, _lh_drop_LH_C_1_1) -> 
//│ 		      (if (_lh_drop_arg1_1 > 0) then
//│ 		        ((drop__d0 (_lh_drop_arg1_1 - 1)) _lh_drop_LH_C_1_1)
//│ 		      else
//│ 		        (`LH_C(_lh_drop_LH_C_0_1, _lh_drop_LH_C_1_1)))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and encrypt__d0 _lh_encrypt_arg1_1 _lh_encrypt_arg2_1 _lh_funcomp_x_4 =
//│ 		  ((fun _lh_funcomp_x_5 -> 
//│ 		    (unlines__d0 ((map__d0 (fun _lh_funcomp_x_6 -> 
//│ 		      ((fun _lh_funcomp_x_7 -> 
//│ 		        (string_of_int (((power__d0 _lh_encrypt_arg2_1) _lh_encrypt_arg1_1) _lh_funcomp_x_7))) (code__d0 _lh_funcomp_x_6)))) _lh_funcomp_x_5))) ((collect__d0 (size__d0 _lh_encrypt_arg1_1)) _lh_funcomp_x_4))
//│ 		and even__d0 _lh_even_arg1_1 =
//│ 		  ((_lh_even_arg1_1 mod 2) = 0)
//│ 		and foldl__d0 f_1_3 i_3 ls_2_1 =
//│ 		  (match ls_2_1 with
//│ 		    | `LH_C(h_2_3, t_2_5) -> 
//│ 		      (((foldl__d0 f_1_3) ((f_1_3 i_3) h_2_3)) t_2_5)
//│ 		    | `LH_N -> 
//│ 		      i_3)
//│ 		and length__d0 ls_2_3 =
//│ 		  (match ls_2_3 with
//│ 		    | `LH_C(h_2_7, t_2_9) -> 
//│ 		      (1 + (length__d0 t_2_9))
//│ 		    | `LH_N -> 
//│ 		      0)
//│ 		and map__d0 f_1_2 ls_2_0 =
//│ 		  (match ls_2_0 with
//│ 		    | `LH_C(h_2_2, t_2_4) -> 
//│ 		      (`LH_C((f_1_2 h_2_2), ((map__d0 f_1_2) t_2_4)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and map__d1 f_1_4 ls_2_2 =
//│ 		  (match ls_2_2 with
//│ 		    | `LH_C(h_2_5, t_2_7) -> 
//│ 		      (`LH_C((f_1_4 h_2_5), ((map__d1 f_1_4) t_2_7)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and mappend__d0 xs_9 ys_9 =
//│ 		  (match xs_9 with
//│ 		    | `LH_C(h_2_1, t_2_3) -> 
//│ 		      (`LH_C(h_2_1, ((mappend__d0 t_2_3) ys_9)))
//│ 		    | `LH_N -> 
//│ 		      ys_9)
//│ 		and mappend__d1 xs_1_0 ys_1_0 =
//│ 		  (match xs_1_0 with
//│ 		    | `LH_C(h_2_6, t_2_8) -> 
//│ 		      (`LH_C(h_2_6, ((mappend__d1 t_2_8) ys_1_0)))
//│ 		    | `LH_N -> 
//│ 		      ys_1_0)
//│ 		and power__d0 _lh_power_arg1_1 _lh_power_arg2_1 _lh_power_arg3_1 =
//│ 		  (match _lh_power_arg1_1 with
//│ 		    | 0 -> 
//│ 		      1
//│ 		    | _ -> 
//│ 		      (if (even__d0 _lh_power_arg1_1) then
//│ 		        ((sqr__d0 (((power__d0 (_lh_power_arg1_1 / 2)) _lh_power_arg2_1) _lh_power_arg3_1)) mod _lh_power_arg2_1)
//│ 		      else
//│ 		        ((_lh_power_arg3_1 * (((power__d0 (_lh_power_arg1_1 - 1)) _lh_power_arg2_1) _lh_power_arg3_1)) mod _lh_power_arg2_1)))
//│ 		and size__d0 _lh_size_arg1_1 =
//│ 		  (((length__d0 (string_of_int _lh_size_arg1_1)) * 47) / 100)
//│ 		and sqr__d0 _lh_sqr_arg1_1 =
//│ 		  (_lh_sqr_arg1_1 * _lh_sqr_arg1_1)
//│ 		and take__d0 n_4 ls_1_9 =
//│ 		  (if (n_4 > 0) then
//│ 		    (match ls_1_9 with
//│ 		      | `LH_C(h_2_0, t_2_2) -> 
//│ 		        (`LH_C(h_2_0, ((take__d0 (n_4 - 1)) t_2_2)))
//│ 		      | `LH_N -> 
//│ 		        (`LH_N))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and testRsa_nofib__d0 _lh_testRsa_nofib_arg1_1 =
//│ 		  (((encrypt__d0 6367) 5189) ((copy__d0 _lh_testRsa_nofib_arg1_1) 'l'))
//│ 		and unlines__d0 _lh_unlines_arg1_1 =
//│ 		  (concat__d0 ((map__d1 (fun l_1 -> 
//│ 		    ((mappend__d1 l_1) (`LH_C('n', (`LH_N)))))) _lh_unlines_arg1_1));;
//│ 		(testRsa_nofib__d0 50520)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testRsa_nofib_₀^1368]
//│ 	[testRsa_nofib_₀^1368 · copy_₀^1152] (hopeless to continue)
//│ 		[testRsa_nofib_₀^1368 · copy_₀^1152 · copy_₀^1059] ---> [testRsa_nofib_₀^1368 · copy_₀^1152] (using original def)
//│ 	[testRsa_nofib_₀^1368 · encrypt_₀^1146]
//│ 		[testRsa_nofib_₀^1368 · encrypt_₀^1146 · code_₀^1099] (hopeless to continue)
//│ 			[testRsa_nofib_₀^1368 · encrypt_₀^1146 · code_₀^1099 · foldl_₀^1160] (using original def)
//│ 				[testRsa_nofib_₀^1368 · encrypt_₀^1146 · code_₀^1099 · foldl_₀^1160 · foldl_₀^1280] ---> [testRsa_nofib_₀^1368 · encrypt_₀^1146 · code_₀^1099 · foldl_₀^1160] (using original def)
//│ 		[testRsa_nofib_₀^1368 · encrypt_₀^1146 · collect_₀^1109] (hopeless to continue)
//│ 			[testRsa_nofib_₀^1368 · encrypt_₀^1146 · collect_₀^1109 · collect_₀^1189] ---> [testRsa_nofib_₀^1368 · encrypt_₀^1146 · collect_₀^1109] (using original def)
//│ 			[testRsa_nofib_₀^1368 · encrypt_₀^1146 · collect_₀^1109 · drop_₀^1192] (using original def)
//│ 				[testRsa_nofib_₀^1368 · encrypt_₀^1146 · collect_₀^1109 · drop_₀^1192 · drop_₀^1340] ---> [testRsa_nofib_₀^1368 · encrypt_₀^1146 · collect_₀^1109 · drop_₀^1192] (using original def)
//│ 			[testRsa_nofib_₀^1368 · encrypt_₀^1146 · collect_₀^1109 · take_₀^1184] (using original def)
//│ 				[testRsa_nofib_₀^1368 · encrypt_₀^1146 · collect_₀^1109 · take_₀^1184 · take_₀^1040] ---> [testRsa_nofib_₀^1368 · encrypt_₀^1146 · collect_₀^1109 · take_₀^1184] (using original def)
//│ 		[testRsa_nofib_₀^1368 · encrypt_₀^1146 · map_₀^1088] (hopeless to continue)
//│ 			[testRsa_nofib_₀^1368 · encrypt_₀^1146 · map_₀^1088 · map_₀^1269] ---> [testRsa_nofib_₀^1368 · encrypt_₀^1146 · map_₀^1088] (using original def)
//│ 		[testRsa_nofib_₀^1368 · encrypt_₀^1146 · power_₀^1090] (hopeless to continue)
//│ 			[testRsa_nofib_₀^1368 · encrypt_₀^1146 · power_₀^1090 · even_₀^1205] (using original def)
//│ 			[testRsa_nofib_₀^1368 · encrypt_₀^1146 · power_₀^1090 · power_₀^1210] ---> [testRsa_nofib_₀^1368 · encrypt_₀^1146 · power_₀^1090] (using original def)
//│ 			[testRsa_nofib_₀^1368 · encrypt_₀^1146 · power_₀^1090 · power_₀^1229] ---> [testRsa_nofib_₀^1368 · encrypt_₀^1146 · power_₀^1090] (using original def)
//│ 			[testRsa_nofib_₀^1368 · encrypt_₀^1146 · power_₀^1090 · sqr_₀^1209] (using original def)
//│ 		[testRsa_nofib_₀^1368 · encrypt_₀^1146 · size_₀^1110] (hopeless to continue)
//│ 			[testRsa_nofib_₀^1368 · encrypt_₀^1146 · size_₀^1110 · length_₀^1134] (using original def)
//│ 				[testRsa_nofib_₀^1368 · encrypt_₀^1146 · size_₀^1110 · length_₀^1134 · length_₀^1361] ---> [testRsa_nofib_₀^1368 · encrypt_₀^1146 · size_₀^1110 · length_₀^1134] (using original def)
//│ 		[testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087]
//│ 			[testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · concat_₀^1072]
//│ 				[testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · concat_₀^1072 · concat_₀^1300] (hopeless to continue)
//│ 					[testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · concat_₀^1072 · concat_₀^1300 · concat_₀^1300] ---> [testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · concat_₀^1072 · concat_₀^1300] (using original def)
//│ 					[testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · concat_₀^1072 · concat_₀^1300 · mappend_₀^1297] (using original def)
//│ 						[testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · concat_₀^1072 · concat_₀^1300 · mappend_₀^1297 · mappend_₀^1122] ---> [testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · concat_₀^1072 · concat_₀^1300 · mappend_₀^1297] (using original def)
//│ 				[testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · concat_₀^1072 · mappend_₀^1297]
//│ 					[testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · concat_₀^1072 · mappend_₀^1297 · mappend_₀^1122] ---> [testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · concat_₀^1072 · mappend_₀^1297] (only one)
//│ 			[testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · map_₁^1073] (hopeless to continue)
//│ 				[testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · map_₁^1073 · map_₁^1311] ---> [testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · map_₁^1073] (using original def)
//│ 			[testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · mappend_₁^1074] (hopeless to continue)
//│ 				[testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · mappend_₁^1074 · mappend_₁^1323] ---> [testRsa_nofib_₀^1368 · encrypt_₀^1146 · unlines_₀^1087 · mappend_₁^1074] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testRsa_nofib_₀_₀(primId⁰(50520))
//│ def testRsa_nofib_₀_₀(_lh_testRsa_nofib_arg1¹) = 
//│ 	encrypt_₀_₀(6367, 5189, primId⁰(copy_₀_₀(_lh_testRsa_nofib_arg1¹, 'l')))
//│ 	where
//│ 	def copy_₀_₀(_lh_copy_arg1¹, _lh_copy_arg2¹) = 
//│ 		case _lh_copy_arg1¹ of {
//│ 			0  => [LH_N]
//│ 			| _  => [LH_C _lh_copy_arg2¹ copy_₀_₀((_lh_copy_arg1¹ - 1), _lh_copy_arg2¹)]}
//│ 	def encrypt_₀_₀(_lh_encrypt_arg1¹, _lh_encrypt_arg2¹, _lh_funcomp_x⁴) = 
//│ 		(fun _lh_funcomp_x⁵ -> unlines_₀_₀(map_₀_₀((fun _lh_funcomp_x⁶ -> (fun _lh_funcomp_x⁷ -> string_of_int⁰(power_₀_₀(_lh_encrypt_arg2¹, _lh_encrypt_arg1¹, _lh_funcomp_x⁷)))(code_₀_₀(_lh_funcomp_x⁶))), _lh_funcomp_x⁵)))(collect_₀_₀(size_₀_₀(_lh_encrypt_arg1¹), _lh_funcomp_x⁴))
//│ 		where
//│ 		def code_₀_₀(_lh_code_arg1¹) = 
//│ 			foldl_₀_₀((fun x¹ -> (fun y¹ -> ((128 * x¹) + int_of_char⁰(y¹)))), 0, _lh_code_arg1¹)
//│ 			where
//│ 			def foldl_₀_₀(f³, i¹, ls⁵) = 
//│ 				case ls⁵ of {
//│ 					LH_C h¹³ t¹³ => foldl_₀_₀(f³, f³(i¹, h¹³), t¹³)
//│ 					| LH_N  => i¹}
//│ 		def collect_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) = 
//│ 			case _lh_collect_arg1¹ of {
//│ 				0  => [LH_N]
//│ 				| _  => case _lh_collect_arg2¹ of {
//│ 					LH_N  => [LH_N]
//│ 					| _  => [LH_C take_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀_₀(_lh_collect_arg1¹, drop_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]}}
//│ 			where
//│ 			def drop_₀_₀(_lh_drop_arg1¹, _lh_drop_arg2¹) = 
//│ 				case _lh_drop_arg2¹ of {
//│ 					LH_N  => [LH_N]
//│ 					| LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1¹ > 0) then drop_₀_₀((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]
//│ 					| _  => error⁰}
//│ 			def take_₀_₀(n¹, ls⁶) = 
//│ 				if (n¹ > 0) then case ls⁶ of {
//│ 					LH_C h¹⁴ t¹⁴ => [LH_C h¹⁴ take_₀_₀((n¹ - 1), t¹⁴)]
//│ 					| LH_N  => [LH_N]} else [LH_N]
//│ 		def map_₀_₀(f⁵, ls⁹) = 
//│ 			case ls⁹ of {
//│ 				LH_C h¹⁷ t¹⁷ => [LH_C f⁵(h¹⁷) map_₀_₀(f⁵, t¹⁷)]
//│ 				| LH_N  => [LH_N]}
//│ 		def power_₀_₀(_lh_power_arg1¹, _lh_power_arg2¹, _lh_power_arg3¹) = 
//│ 			case _lh_power_arg1¹ of {
//│ 				0  => 1
//│ 				| _  => if even_₀_₀(_lh_power_arg1¹) then (sqr_₀_₀(power_₀_₀(div⁰(_lh_power_arg1¹, 2), _lh_power_arg2¹, _lh_power_arg3¹)) % _lh_power_arg2¹) else ((_lh_power_arg3¹ * power_₀_₀((_lh_power_arg1¹ - 1), _lh_power_arg2¹, _lh_power_arg3¹)) % _lh_power_arg2¹)}
//│ 			where
//│ 			def even_₀_₀(_lh_even_arg1¹) = 
//│ 				((_lh_even_arg1¹ % 2) == 0)
//│ 			def sqr_₀_₀(_lh_sqr_arg1¹) = 
//│ 				(_lh_sqr_arg1¹ * _lh_sqr_arg1¹)
//│ 		def size_₀_₀(_lh_size_arg1¹) = 
//│ 			div⁰((length_₀_₀(string_of_int⁰(_lh_size_arg1¹)) * 47), 100)
//│ 			where
//│ 			def length_₀_₀(ls⁸) = 
//│ 				case ls⁸ of {
//│ 					LH_C h¹⁶ t¹⁶ => (1 + length_₀_₀(t¹⁶))
//│ 					| LH_N  => 0}
//│ 		def unlines_₀_₀(_lh_unlines_arg1¹) = 
//│ 			concat_₀_₀(map_₁_₀((fun l¹ -> mappend_₁_₀(l¹, [LH_C 'n' [LH_N]])), _lh_unlines_arg1¹))
//│ 			where
//│ 			def concat_₀_₀(lss²) = 
//│ 				case lss² of {
//│ 					LH_C h¹¹ t¹¹ => mappend_₀_₁(h¹¹, concat_₀_₁(t¹¹))
//│ 					| LH_N  => [LH_N]}
//│ 				where
//│ 				def concat_₀_₁(lss¹) = 
//│ 					case lss¹ of {
//│ 						LH_C h⁸ t⁸ => mappend_₀_₀(h⁸, concat_₀_₁(t⁸))
//│ 						| LH_N  => [LH_N]}
//│ 					where
//│ 					def mappend_₀_₀(xs², ys²) = 
//│ 						case xs² of {
//│ 							LH_C h⁹ t⁹ => [LH_C h⁹ mappend_₀_₀(t⁹, ys²)]
//│ 							| LH_N  => ys²}
//│ 				def mappend_₀_₁(xs⁴, ys⁴) = 
//│ 					case xs⁴ of {
//│ 						LH_C h¹² t¹² => [LH_C h¹² mappend_₀_₁(t¹², ys⁴)]
//│ 						| LH_N  => ys⁴}
//│ 			def map_₁_₀(f⁴, ls⁷) = 
//│ 				case ls⁷ of {
//│ 					LH_C h¹⁵ t¹⁵ => [LH_C f⁴(h¹⁵) map_₁_₀(f⁴, t¹⁵)]
//│ 					| LH_N  => [LH_N]}
//│ 			def mappend_₁_₀(xs³, ys³) = 
//│ 				case xs³ of {
//│ 					LH_C h¹⁰ t¹⁰ => [LH_C h¹⁰ mappend_₁_₀(t¹⁰, ys³)]
//│ 					| LH_N  => ys³}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 358 --->
//│ 	case xs² of {LH_C h⁹ t⁹ => [LH_C h⁹ mappend_₀_₀(t⁹, ys²)] | LH_N  => ys²}: 376
//│ 	case xs⁴ of {LH_C h¹² t¹² => [LH_C h¹² mappend_₀_₁(t¹², ys⁴)] | LH_N  => ys⁴}: 451
//│ [LH_C 'n' [LH_N]]: 359 --->
//│ 	case xs² of {LH_C h⁹ t⁹ => [LH_C h⁹ mappend_₀_₀(t⁹, ys²)] | LH_N  => ys²}: 376
//│ 	case xs⁴ of {LH_C h¹² t¹² => [LH_C h¹² mappend_₀_₁(t¹², ys⁴)] | LH_N  => ys⁴}: 451
//│ [LH_C h¹⁰ mappend_₁_₀(t¹⁰, ys³)]: 386 --->
//│ 	case xs² of {LH_C h⁹ t⁹ => [LH_C h⁹ mappend_₀_₀(t⁹, ys²)] | LH_N  => ys²}: 376
//│ 	case xs⁴ of {LH_C h¹² t¹² => [LH_C h¹² mappend_₀_₁(t¹², ys⁴)] | LH_N  => ys⁴}: 451
//│ [LH_C h¹⁴ take_₀_₀((n¹ - 1), t¹⁴)]: 520 --->
//│ 	case ls⁵ of {LH_C h¹³ t¹³ => foldl_₀_₀(f³, f³(i¹, h¹³), t¹³) | LH_N  => i¹}: 467
//│ [LH_N]: 521 --->
//│ 	case ls⁵ of {LH_C h¹³ t¹³ => foldl_₀_₀(f³, f³(i¹, h¹³), t¹³) | LH_N  => i¹}: 467
//│ [LH_N]: 523 --->
//│ 	case ls⁵ of {LH_C h¹³ t¹³ => foldl_₀_₀(f³, f³(i¹, h¹³), t¹³) | LH_N  => i¹}: 467
//│ [LH_C f⁴(h¹⁵) map_₁_₀(f⁴, t¹⁵)]: 536 --->
//│ 	case lss¹ of {LH_C h⁸ t⁸ => mappend_₀_₀(h⁸, concat_₀_₁(t⁸)) | LH_N  => [LH_N]}: 350
//│ 	case lss² of {LH_C h¹¹ t¹¹ => mappend_₀_₁(h¹¹, concat_₀_₁(t¹¹)) | LH_N  => [LH_N]}: 434
//│ [LH_N]: 537 --->
//│ 	case lss¹ of {LH_C h⁸ t⁸ => mappend_₀_₀(h⁸, concat_₀_₁(t⁸)) | LH_N  => [LH_N]}: 350
//│ 	case lss² of {LH_C h¹¹ t¹¹ => mappend_₀_₁(h¹¹, concat_₀_₁(t¹¹)) | LH_N  => [LH_N]}: 434
//│ [LH_N]: 583 --->
//│ 	case ls⁹ of {LH_C h¹⁷ t¹⁷ => [LH_C f⁵(h¹⁷) map_₀_₀(f⁵, t¹⁷)] | LH_N  => [LH_N]}: 640
//│ [LH_N]: 585 --->
//│ 	case ls⁹ of {LH_C h¹⁷ t¹⁷ => [LH_C f⁵(h¹⁷) map_₀_₀(f⁵, t¹⁷)] | LH_N  => [LH_N]}: 640
//│ [LH_C take_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀_₀(_lh_collect_arg1¹, drop_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]: 600 --->
//│ 	case ls⁹ of {LH_C h¹⁷ t¹⁷ => [LH_C f⁵(h¹⁷) map_₀_₀(f⁵, t¹⁷)] | LH_N  => [LH_N]}: 640
//│ [LH_N]: 606 --->
//│ 	case ls⁶ of {LH_C h¹⁴ t¹⁴ => [LH_C h¹⁴ take_₀_₀((n¹ - 1), t¹⁴)] | LH_N  => [LH_N]}: 522
//│ 	case _lh_collect_arg2¹ of {LH_N  => [LH_N] | _  => [LH_C take_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀_₀(_lh_collect_arg1¹, drop_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]}: 601
//│ 	case _lh_drop_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1¹ > 0) then drop_₀_₀((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹] | _  => error⁰}: 626
//│ [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]: 623 --->
//│ 	case ls⁶ of {LH_C h¹⁴ t¹⁴ => [LH_C h¹⁴ take_₀_₀((n¹ - 1), t¹⁴)] | LH_N  => [LH_N]}: 522
//│ 	case _lh_collect_arg2¹ of {LH_N  => [LH_N] | _  => [LH_C take_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀_₀(_lh_collect_arg1¹, drop_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]}: 601
//│ 	case _lh_drop_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1¹ > 0) then drop_₀_₀((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹] | _  => error⁰}: 626
//│ [LH_C f⁵(h¹⁷) map_₀_₀(f⁵, t¹⁷)]: 638 --->
//│ 	case ls⁷ of {LH_C h¹⁵ t¹⁵ => [LH_C f⁴(h¹⁵) map_₁_₀(f⁴, t¹⁵)] | LH_N  => [LH_N]}: 538
//│ [LH_N]: 639 --->
//│ 	case ls⁷ of {LH_C h¹⁵ t¹⁵ => [LH_C f⁴(h¹⁵) map_₁_₀(f⁴, t¹⁵)] | LH_N  => [LH_N]}: 538
//│ ------------------
//│ case lss¹ of {LH_C h⁸ t⁸ => mappend_₀_₀(h⁸, concat_₀_₁(t⁸)) | LH_N  => [LH_N]}: 350 --->
//│ 	[LH_C f⁴(h¹⁵) map_₁_₀(f⁴, t¹⁵)]: 536
//│ 	[LH_N]: 537
//│ case xs² of {LH_C h⁹ t⁹ => [LH_C h⁹ mappend_₀_₀(t⁹, ys²)] | LH_N  => ys²}: 376 --->
//│ 	[LH_N]: 358
//│ 	[LH_C 'n' [LH_N]]: 359
//│ 	[LH_C h¹⁰ mappend_₁_₀(t¹⁰, ys³)]: 386
//│ case lss² of {LH_C h¹¹ t¹¹ => mappend_₀_₁(h¹¹, concat_₀_₁(t¹¹)) | LH_N  => [LH_N]}: 434 --->
//│ 	[LH_C f⁴(h¹⁵) map_₁_₀(f⁴, t¹⁵)]: 536
//│ 	[LH_N]: 537
//│ case xs⁴ of {LH_C h¹² t¹² => [LH_C h¹² mappend_₀_₁(t¹², ys⁴)] | LH_N  => ys⁴}: 451 --->
//│ 	[LH_N]: 358
//│ 	[LH_C 'n' [LH_N]]: 359
//│ 	[LH_C h¹⁰ mappend_₁_₀(t¹⁰, ys³)]: 386
//│ case ls⁵ of {LH_C h¹³ t¹³ => foldl_₀_₀(f³, f³(i¹, h¹³), t¹³) | LH_N  => i¹}: 467 --->
//│ 	[LH_C h¹⁴ take_₀_₀((n¹ - 1), t¹⁴)]: 520
//│ 	[LH_N]: 521
//│ 	[LH_N]: 523
//│ case ls⁶ of {LH_C h¹⁴ t¹⁴ => [LH_C h¹⁴ take_₀_₀((n¹ - 1), t¹⁴)] | LH_N  => [LH_N]}: 522 --->
//│ 	NoProd
//│ 	[LH_N]: 606
//│ 	[LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]: 623
//│ case ls⁷ of {LH_C h¹⁵ t¹⁵ => [LH_C f⁴(h¹⁵) map_₁_₀(f⁴, t¹⁵)] | LH_N  => [LH_N]}: 538 --->
//│ 	[LH_C f⁵(h¹⁷) map_₀_₀(f⁵, t¹⁷)]: 638
//│ 	[LH_N]: 639
//│ case _lh_collect_arg2¹ of {LH_N  => [LH_N] | _  => [LH_C take_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀_₀(_lh_collect_arg1¹, drop_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]}: 601 --->
//│ 	NoProd
//│ 	[LH_N]: 606
//│ 	[LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]: 623
//│ case _lh_drop_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1¹ > 0) then drop_₀_₀((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹] | _  => error⁰}: 626 --->
//│ 	NoProd
//│ 	[LH_N]: 606
//│ 	[LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]: 623
//│ case ls⁹ of {LH_C h¹⁷ t¹⁷ => [LH_C f⁵(h¹⁷) map_₀_₀(f⁵, t¹⁷)] | LH_N  => [LH_N]}: 640 --->
//│ 	[LH_N]: 583
//│ 	[LH_N]: 585
//│ 	[LH_C take_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀_₀(_lh_collect_arg1¹, drop_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]: 600
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C h¹⁴ take_₀_₀((n¹ - 1), t¹⁴)]: 520 --->
//│ 	case ls⁵ of {LH_C h¹³ t¹³ => foldl_₀_₀(f³, f³(i¹, h¹³), t¹³) | LH_N  => i¹}: 467
//│ [LH_N]: 521 --->
//│ 	case ls⁵ of {LH_C h¹³ t¹³ => foldl_₀_₀(f³, f³(i¹, h¹³), t¹³) | LH_N  => i¹}: 467
//│ [LH_N]: 523 --->
//│ 	case ls⁵ of {LH_C h¹³ t¹³ => foldl_₀_₀(f³, f³(i¹, h¹³), t¹³) | LH_N  => i¹}: 467
//│ [LH_N]: 583 --->
//│ 	case ls⁹ of {LH_C h¹⁷ t¹⁷ => [LH_C f⁵(h¹⁷) map_₀_₀(f⁵, t¹⁷)] | LH_N  => [LH_N]}: 640
//│ [LH_N]: 585 --->
//│ 	case ls⁹ of {LH_C h¹⁷ t¹⁷ => [LH_C f⁵(h¹⁷) map_₀_₀(f⁵, t¹⁷)] | LH_N  => [LH_N]}: 640
//│ [LH_C take_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀_₀(_lh_collect_arg1¹, drop_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]: 600 --->
//│ 	case ls⁹ of {LH_C h¹⁷ t¹⁷ => [LH_C f⁵(h¹⁷) map_₀_₀(f⁵, t¹⁷)] | LH_N  => [LH_N]}: 640
//│ [LH_C f⁵(h¹⁷) map_₀_₀(f⁵, t¹⁷)]: 638 --->
//│ 	case ls⁷ of {LH_C h¹⁵ t¹⁵ => [LH_C f⁴(h¹⁵) map_₁_₀(f⁴, t¹⁵)] | LH_N  => [LH_N]}: 538
//│ [LH_N]: 639 --->
//│ 	case ls⁷ of {LH_C h¹⁵ t¹⁵ => [LH_C f⁴(h¹⁵) map_₁_₀(f⁴, t¹⁵)] | LH_N  => [LH_N]}: 538
//│ ------------------
//│ case ls⁵ of {LH_C h¹³ t¹³ => foldl_₀_₀(f³, f³(i¹, h¹³), t¹³) | LH_N  => i¹}: 467 --->
//│ 	[LH_C h¹⁴ take_₀_₀((n¹ - 1), t¹⁴)]: 520
//│ 	[LH_N]: 521
//│ 	[LH_N]: 523
//│ case ls⁷ of {LH_C h¹⁵ t¹⁵ => [LH_C f⁴(h¹⁵) map_₁_₀(f⁴, t¹⁵)] | LH_N  => [LH_N]}: 538 --->
//│ 	[LH_C f⁵(h¹⁷) map_₀_₀(f⁵, t¹⁷)]: 638
//│ 	[LH_N]: 639
//│ case ls⁹ of {LH_C h¹⁷ t¹⁷ => [LH_C f⁵(h¹⁷) map_₀_₀(f⁵, t¹⁷)] | LH_N  => [LH_N]}: 640 --->
//│ 	[LH_N]: 583
//│ 	[LH_N]: 585
//│ 	[LH_C take_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀_₀(_lh_collect_arg1¹, drop_₀_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]: 600
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testRsa_nofib_₀_₀(primId⁰(50520))
//│ def testRsa_nofib_₀_₀(_lh_testRsa_nofib_arg1²) = 
//│ 	encrypt_₀_₀(6367, 5189, primId⁰(copy_₀_₀(_lh_testRsa_nofib_arg1², 'l')))
//│ 	where
//│ 	def copy_₀_₀(_lh_copy_arg1², _lh_copy_arg2²) = 
//│ 		case _lh_copy_arg1² of {
//│ 			0  => [LH_N]
//│ 			| _  => [LH_C _lh_copy_arg2² copy_₀_₀((_lh_copy_arg1² - 1), _lh_copy_arg2²)]}
//│ 	def encrypt_₀_₀(_lh_encrypt_arg1², _lh_encrypt_arg2², _lh_funcomp_x⁸) = 
//│ 		(fun _lh_funcomp_x⁹ -> unlines_₀_₀(map_₀_₀((fun _lh_funcomp_x¹⁰ -> (fun _lh_funcomp_x¹¹ -> string_of_int⁰(power_₀_₀(_lh_encrypt_arg2², _lh_encrypt_arg1², _lh_funcomp_x¹¹)))(code_₀_₀(_lh_funcomp_x¹⁰))), _lh_funcomp_x⁹)))(collect_₀_₀(size_₀_₀(_lh_encrypt_arg1²), _lh_funcomp_x⁸))
//│ 		where
//│ 		def code_₀_₀(_lh_code_arg1²) = 
//│ 			foldl_₀_₀((fun x² -> (fun y² -> ((128 * x²) + int_of_char⁰(y²)))), 0, _lh_code_arg1²)
//│ 			where
//│ 			def foldl_₀_₀(f⁷, i², ls¹¹) = 
//│ 				ls¹¹(f⁷, i²)
//│ 		def collect_₀_₀(_lh_collect_arg1², _lh_collect_arg2²) = 
//│ 			case _lh_collect_arg1² of {
//│ 				0  => (fun f¹² -> (fun f¹³ -> [LH_N]))
//│ 				| _  => case _lh_collect_arg2² of {
//│ 					LH_N  => (fun f¹⁴ -> (fun f¹⁵ -> [LH_N]))
//│ 					| _  => 
//│ 						let t¹⁹ = collect_₀_₀(_lh_collect_arg1², drop_₀_₀(_lh_collect_arg1², _lh_collect_arg2²))
//│ 						in let h¹⁹ = take_₀_₀(_lh_collect_arg1², _lh_collect_arg2²)
//│ 						in (fun f¹⁶ -> 
//│ 							let t²⁰ = map_₀_₀(f¹⁶, t¹⁹)
//│ 							in let h²⁰ = f¹⁶(h¹⁹)
//│ 							in (fun f¹⁷ -> [LH_C f¹⁷(h²⁰) map_₁_₀(f¹⁷, t²⁰)]))}}
//│ 			where
//│ 			def drop_₀_₀(_lh_drop_arg1², _lh_drop_arg2²) = 
//│ 				case _lh_drop_arg2² of {
//│ 					LH_N  => [LH_N]
//│ 					| LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1² > 0) then drop_₀_₀((_lh_drop_arg1² - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]
//│ 					| _  => error⁰}
//│ 			def take_₀_₀(n², ls¹²) = 
//│ 				if (n² > 0) then case ls¹² of {
//│ 					LH_C h¹⁴ t¹⁴ => 
//│ 						let t¹⁸ = take_₀_₀((n² - 1), t¹⁴)
//│ 						in let h¹⁸ = h¹⁴
//│ 						in (fun f⁸ -> (fun i³ -> foldl_₀_₀(f⁸, f⁸(i³, h¹⁸), t¹⁸)))
//│ 					| LH_N  => (fun f⁹ -> (fun i⁴ -> i⁴))} else (fun f¹⁰ -> (fun i⁵ -> i⁵))
//│ 		def map_₀_₀(f¹¹, ls¹³) = 
//│ 			ls¹³(f¹¹)
//│ 		def power_₀_₀(_lh_power_arg1², _lh_power_arg2², _lh_power_arg3²) = 
//│ 			case _lh_power_arg1² of {
//│ 				0  => 1
//│ 				| _  => if even_₀_₀(_lh_power_arg1²) then (sqr_₀_₀(power_₀_₀(div⁰(_lh_power_arg1², 2), _lh_power_arg2², _lh_power_arg3²)) % _lh_power_arg2²) else ((_lh_power_arg3² * power_₀_₀((_lh_power_arg1² - 1), _lh_power_arg2², _lh_power_arg3²)) % _lh_power_arg2²)}
//│ 			where
//│ 			def even_₀_₀(_lh_even_arg1²) = 
//│ 				((_lh_even_arg1² % 2) == 0)
//│ 			def sqr_₀_₀(_lh_sqr_arg1²) = 
//│ 				(_lh_sqr_arg1² * _lh_sqr_arg1²)
//│ 		def size_₀_₀(_lh_size_arg1²) = 
//│ 			div⁰((length_₀_₀(string_of_int⁰(_lh_size_arg1²)) * 47), 100)
//│ 			where
//│ 			def length_₀_₀(ls¹⁴) = 
//│ 				case ls¹⁴ of {
//│ 					LH_C h¹⁶ t¹⁶ => (1 + length_₀_₀(t¹⁶))
//│ 					| LH_N  => 0}
//│ 		def unlines_₀_₀(_lh_unlines_arg1²) = 
//│ 			concat_₀_₀(map_₁_₀((fun l² -> mappend_₁_₀(l², [LH_C 'n' [LH_N]])), _lh_unlines_arg1²))
//│ 			where
//│ 			def concat_₀_₀(lss⁴) = 
//│ 				case lss⁴ of {
//│ 					LH_C h¹¹ t¹¹ => mappend_₀_₁(h¹¹, concat_₀_₁(t¹¹))
//│ 					| LH_N  => [LH_N]}
//│ 				where
//│ 				def concat_₀_₁(lss³) = 
//│ 					case lss³ of {
//│ 						LH_C h⁸ t⁸ => mappend_₀_₀(h⁸, concat_₀_₁(t⁸))
//│ 						| LH_N  => [LH_N]}
//│ 					where
//│ 					def mappend_₀_₀(xs⁷, ys⁷) = 
//│ 						case xs⁷ of {
//│ 							LH_C h⁹ t⁹ => [LH_C h⁹ mappend_₀_₀(t⁹, ys⁷)]
//│ 							| LH_N  => ys⁷}
//│ 				def mappend_₀_₁(xs⁶, ys⁶) = 
//│ 					case xs⁶ of {
//│ 						LH_C h¹² t¹² => [LH_C h¹² mappend_₀_₁(t¹², ys⁶)]
//│ 						| LH_N  => ys⁶}
//│ 			def map_₁_₀(f⁶, ls¹⁰) = 
//│ 				ls¹⁰(f⁶)
//│ 			def mappend_₁_₀(xs⁵, ys⁵) = 
//│ 				case xs⁵ of {
//│ 					LH_C h¹⁰ t¹⁰ => [LH_C h¹⁰ mappend_₁_₀(t¹⁰, ys⁵)]
//│ 					| LH_N  => ys⁵}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<





