:NewParser
:ParseOnly

:lhInHaskell
:lhGenOCaml
and [] = True
and (h:t) = if h then (and t) else False
copy 0 a = []
copy n a = a:(copy (n - 1) a)
unlines ls = concat (map (\l -> l ++ ['n']) ls)
even a = (a `mod` 2) == 0
drop n [] = []
drop n (h:t) = if n > 0 then (drop (n - 1) t) else (h:t)
encrypt n e = unlines . map (string_of_int . power e n . code) . collect (size n)
code ls = foldl (\x y -> (128 * x) + (int_of_char y)) 0 ls
decode n = reverse (expand n)
expand 0 = []
expand x = (x `mod` 128) : (expand (x `div` 128))
collect 0 xs = []
collect n [] = []
collect n xs = (take n xs) : collect n (drop n xs)
size n = (length (string_of_int n) * 47) `div` 100
prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]
nextPrime a = let odd = (if (even a) then (a + 1) else a) in (head_lz (filter_lz prime [odd,odd+2..]))
iter g v 0  w = v
iter g v h w = let fact = (g `div` h) in (iter h w (g - (fact * h)) (v - (fact * w)))
invert n a = let e = (iter n 0 a 1) in (if e < 0 then e + n else e)
power 0 m x = 1
power n m x = if (even n) then ((sqr (power (n `div` 2) m x)) `mod` m) else ((x * (power (n-1) m x)) `mod` m)
sqr x = x * x
makeKeys p' q' = let p = (nextPrime p') in (let q = (nextPrime q') in (let d = (nextPrime (p+q+1)) in (p * q, invert ((p-1) * (q-1)) d, d)))
testRsa_nofib n = encrypt 6367 5189 (primId $ copy n 'l')
testRsa_nofib $ primId 50520
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testRsa_nofib_₀^1368(primId⁰(50520))
//│ def code_₀(_lh_code_arg1¹) = foldl_₀^1160((fun x³ -> (fun y¹ -> ((128 * x³) + int_of_char⁰(y¹)))), 0, _lh_code_arg1¹)
//│ def collect_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) = case _lh_collect_arg1¹ of {
//│ 	0  => [LH_N]
//│ 	| _  => case _lh_collect_arg2¹ of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => [LH_C take_₀^1184(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀^1189(_lh_collect_arg1¹, drop_₀^1192(_lh_collect_arg1¹, _lh_collect_arg2¹))]}}
//│ def concat_₀(lss¹) = case lss¹ of {
//│ 	LH_C h²⁴ t²⁶ => mappend_₀^1297(h²⁴, concat_₀^1300(t²⁶))
//│ 	| LH_N  => [LH_N]}
//│ def copy_₀(_lh_copy_arg1¹, _lh_copy_arg2¹) = case _lh_copy_arg1¹ of {
//│ 	0  => [LH_N]
//│ 	| _  => [LH_C _lh_copy_arg2¹ copy_₀^1059((_lh_copy_arg1¹ - 1), _lh_copy_arg2¹)]}
//│ def drop_₀(_lh_drop_arg1¹, _lh_drop_arg2¹) = case _lh_drop_arg2¹ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1¹ > 0) then drop_₀^1340((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]
//│ 	| _  => error⁰}
//│ def encrypt_₀(_lh_encrypt_arg1¹, _lh_encrypt_arg2¹, _lh_funcomp_x⁴) = (fun _lh_funcomp_x⁵ -> unlines_₀^1087(map_₀^1088((fun _lh_funcomp_x⁶ -> (fun _lh_funcomp_x⁷ -> string_of_int⁰(power_₀^1090(_lh_encrypt_arg2¹, _lh_encrypt_arg1¹, _lh_funcomp_x⁷)))(code_₀^1099(_lh_funcomp_x⁶))), _lh_funcomp_x⁵)))(collect_₀^1109(size_₀^1110(_lh_encrypt_arg1¹), _lh_funcomp_x⁴))
//│ def even_₀(_lh_even_arg1¹) = ((_lh_even_arg1¹ % 2) == 0)
//│ def foldl_₀(f¹³, i³, ls²¹) = case ls²¹ of {
//│ 	LH_C h²³ t²⁵ => foldl_₀^1280(f¹³, f¹³(i³, h²³), t²⁵)
//│ 	| LH_N  => i³}
//│ def length_₀(ls²³) = case ls²³ of {
//│ 	LH_C h²⁷ t²⁹ => (1 + length_₀^1361(t²⁹))
//│ 	| LH_N  => 0}
//│ def map_₀(f¹², ls²⁰) = case ls²⁰ of {
//│ 	LH_C h²² t²⁴ => [LH_C f¹²(h²²) map_₀^1269(f¹², t²⁴)]
//│ 	| LH_N  => [LH_N]}
//│ def map_₁(f¹⁴, ls²²) = case ls²² of {
//│ 	LH_C h²⁵ t²⁷ => [LH_C f¹⁴(h²⁵) map_₁^1311(f¹⁴, t²⁷)]
//│ 	| LH_N  => [LH_N]}
//│ def mappend_₀(xs⁹, ys⁹) = case xs⁹ of {
//│ 	LH_C h²¹ t²³ => [LH_C h²¹ mappend_₀^1122(t²³, ys⁹)]
//│ 	| LH_N  => ys⁹}
//│ def mappend_₁(xs¹⁰, ys¹⁰) = case xs¹⁰ of {
//│ 	LH_C h²⁶ t²⁸ => [LH_C h²⁶ mappend_₁^1323(t²⁸, ys¹⁰)]
//│ 	| LH_N  => ys¹⁰}
//│ def power_₀(_lh_power_arg1¹, _lh_power_arg2¹, _lh_power_arg3¹) = case _lh_power_arg1¹ of {
//│ 	0  => 1
//│ 	| _  => if even_₀^1205(_lh_power_arg1¹) then (sqr_₀^1209(power_₀^1210(div⁰(_lh_power_arg1¹, 2), _lh_power_arg2¹, _lh_power_arg3¹)) % _lh_power_arg2¹) else ((_lh_power_arg3¹ * power_₀^1229((_lh_power_arg1¹ - 1), _lh_power_arg2¹, _lh_power_arg3¹)) % _lh_power_arg2¹)}
//│ def size_₀(_lh_size_arg1¹) = div⁰((length_₀^1134(string_of_int⁰(_lh_size_arg1¹)) * 47), 100)
//│ def sqr_₀(_lh_sqr_arg1¹) = (_lh_sqr_arg1¹ * _lh_sqr_arg1¹)
//│ def take_₀(n⁴, ls¹⁹) = if (n⁴ > 0) then case ls¹⁹ of {
//│ 	LH_C h²⁰ t²² => [LH_C h²⁰ take_₀^1040((n⁴ - 1), t²²)]
//│ 	| LH_N  => [LH_N]} else [LH_N]
//│ def testRsa_nofib_₀(_lh_testRsa_nofib_arg1¹) = encrypt_₀^1146(6367, 5189, primId⁰(copy_₀^1152(_lh_testRsa_nofib_arg1¹, 'l')))
//│ def unlines_₀(_lh_unlines_arg1¹) = concat_₀^1072(map_₁^1073((fun l¹ -> mappend_₁^1074(l¹, [LH_C 'n' [LH_N]])), _lh_unlines_arg1¹))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec code__d0 _lh_code_arg1_1 =
//│ 		  (((foldl__d0 (fun x_3 y_1 -> 
//│ 		    ((128 * x_3) + (int_of_char y_1)))) 0) _lh_code_arg1_1)
//│ 		and collect__d0 _lh_collect_arg1_1 _lh_collect_arg2_1 =
//│ 		  (match _lh_collect_arg1_1 with
//│ 		    | 0 -> 
//│ 		      (`LH_N)
//│ 		    | _ -> 
//│ 		      (match _lh_collect_arg2_1 with
//│ 		        | `LH_N -> 
//│ 		          (`LH_N)
//│ 		        | _ -> 
//│ 		          (`LH_C(((take__d0 _lh_collect_arg1_1) _lh_collect_arg2_1), ((collect__d0 _lh_collect_arg1_1) ((drop__d0 _lh_collect_arg1_1) _lh_collect_arg2_1))))))
//│ 		and concat__d0 lss_1 =
//│ 		  (match lss_1 with
//│ 		    | `LH_C(h_2_4, t_2_6) -> 
//│ 		      ((mappend__d0 h_2_4) (concat__d0 t_2_6))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and copy__d0 _lh_copy_arg1_1 _lh_copy_arg2_1 =
//│ 		  (match _lh_copy_arg1_1 with
//│ 		    | 0 -> 
//│ 		      (`LH_N)
//│ 		    | _ -> 
//│ 		      (`LH_C(_lh_copy_arg2_1, ((copy__d0 (_lh_copy_arg1_1 - 1)) _lh_copy_arg2_1))))
//│ 		and drop__d0 _lh_drop_arg1_1 _lh_drop_arg2_1 =
//│ 		  (match _lh_drop_arg2_1 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_drop_LH_C_0_1, _lh_drop_LH_C_1_1) -> 
//│ 		      (if (_lh_drop_arg1_1 > 0) then
//│ 		        ((drop__d0 (_lh_drop_arg1_1 - 1)) _lh_drop_LH_C_1_1)
//│ 		      else
//│ 		        (`LH_C(_lh_drop_LH_C_0_1, _lh_drop_LH_C_1_1)))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and encrypt__d0 _lh_encrypt_arg1_1 _lh_encrypt_arg2_1 _lh_funcomp_x_4 =
//│ 		  ((fun _lh_funcomp_x_5 -> 
//│ 		    (unlines__d0 ((map__d0 (fun _lh_funcomp_x_6 -> 
//│ 		      ((fun _lh_funcomp_x_7 -> 
//│ 		        (string_of_int (((power__d0 _lh_encrypt_arg2_1) _lh_encrypt_arg1_1) _lh_funcomp_x_7))) (code__d0 _lh_funcomp_x_6)))) _lh_funcomp_x_5))) ((collect__d0 (size__d0 _lh_encrypt_arg1_1)) _lh_funcomp_x_4))
//│ 		and even__d0 _lh_even_arg1_1 =
//│ 		  ((_lh_even_arg1_1 mod 2) = 0)
//│ 		and foldl__d0 f_1_3 i_3 ls_2_1 =
//│ 		  (match ls_2_1 with
//│ 		    | `LH_C(h_2_3, t_2_5) -> 
//│ 		      (((foldl__d0 f_1_3) ((f_1_3 i_3) h_2_3)) t_2_5)
//│ 		    | `LH_N -> 
//│ 		      i_3)
//│ 		and length__d0 ls_2_3 =
//│ 		  (match ls_2_3 with
//│ 		    | `LH_C(h_2_7, t_2_9) -> 
//│ 		      (1 + (length__d0 t_2_9))
//│ 		    | `LH_N -> 
//│ 		      0)
//│ 		and map__d0 f_1_2 ls_2_0 =
//│ 		  (match ls_2_0 with
//│ 		    | `LH_C(h_2_2, t_2_4) -> 
//│ 		      (`LH_C((f_1_2 h_2_2), ((map__d0 f_1_2) t_2_4)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and map__d1 f_1_4 ls_2_2 =
//│ 		  (match ls_2_2 with
//│ 		    | `LH_C(h_2_5, t_2_7) -> 
//│ 		      (`LH_C((f_1_4 h_2_5), ((map__d1 f_1_4) t_2_7)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and mappend__d0 xs_9 ys_9 =
//│ 		  (match xs_9 with
//│ 		    | `LH_C(h_2_1, t_2_3) -> 
//│ 		      (`LH_C(h_2_1, ((mappend__d0 t_2_3) ys_9)))
//│ 		    | `LH_N -> 
//│ 		      ys_9)
//│ 		and mappend__d1 xs_1_0 ys_1_0 =
//│ 		  (match xs_1_0 with
//│ 		    | `LH_C(h_2_6, t_2_8) -> 
//│ 		      (`LH_C(h_2_6, ((mappend__d1 t_2_8) ys_1_0)))
//│ 		    | `LH_N -> 
//│ 		      ys_1_0)
//│ 		and power__d0 _lh_power_arg1_1 _lh_power_arg2_1 _lh_power_arg3_1 =
//│ 		  (match _lh_power_arg1_1 with
//│ 		    | 0 -> 
//│ 		      1
//│ 		    | _ -> 
//│ 		      (if (even__d0 _lh_power_arg1_1) then
//│ 		        ((sqr__d0 (((power__d0 (_lh_power_arg1_1 / 2)) _lh_power_arg2_1) _lh_power_arg3_1)) mod _lh_power_arg2_1)
//│ 		      else
//│ 		        ((_lh_power_arg3_1 * (((power__d0 (_lh_power_arg1_1 - 1)) _lh_power_arg2_1) _lh_power_arg3_1)) mod _lh_power_arg2_1)))
//│ 		and size__d0 _lh_size_arg1_1 =
//│ 		  (((length__d0 (string_of_int _lh_size_arg1_1)) * 47) / 100)
//│ 		and sqr__d0 _lh_sqr_arg1_1 =
//│ 		  (_lh_sqr_arg1_1 * _lh_sqr_arg1_1)
//│ 		and take__d0 n_4 ls_1_9 =
//│ 		  (if (n_4 > 0) then
//│ 		    (match ls_1_9 with
//│ 		      | `LH_C(h_2_0, t_2_2) -> 
//│ 		        (`LH_C(h_2_0, ((take__d0 (n_4 - 1)) t_2_2)))
//│ 		      | `LH_N -> 
//│ 		        (`LH_N))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and testRsa_nofib__d0 _lh_testRsa_nofib_arg1_1 =
//│ 		  (((encrypt__d0 6367) 5189) ((copy__d0 _lh_testRsa_nofib_arg1_1) 'l'))
//│ 		and unlines__d0 _lh_unlines_arg1_1 =
//│ 		  (concat__d0 ((map__d1 (fun l_1 -> 
//│ 		    ((mappend__d1 l_1) (`LH_C('n', (`LH_N)))))) _lh_unlines_arg1_1));;
//│ 		(testRsa_nofib__d0 50520)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h²⁰ take_₀((n⁴ - 1), t²²)]: 1049 --->
//│ 	case ls²¹ of {LH_C h²³ t²⁵ => foldl_₀(f¹³, f¹³(i³, h²³), t²⁵) | LH_N  => i³}: 1292
//│ [LH_N]: 1050 --->
//│ 	case ls²¹ of {LH_C h²³ t²⁵ => foldl_₀(f¹³, f¹³(i³, h²³), t²⁵) | LH_N  => i³}: 1292
//│ [LH_N]: 1052 --->
//│ 	case ls²¹ of {LH_C h²³ t²⁵ => foldl_₀(f¹³, f¹³(i³, h²³), t²⁵) | LH_N  => i³}: 1292
//│ [LH_N]: 1078 --->
//│ 	case xs⁹ of {LH_C h²¹ t²³ => [LH_C h²¹ mappend_₀(t²³, ys⁹)] | LH_N  => ys⁹}: 1129
//│ [LH_C 'n' [LH_N]]: 1079 --->
//│ 	case xs⁹ of {LH_C h²¹ t²³ => [LH_C h²¹ mappend_₀(t²³, ys⁹)] | LH_N  => ys⁹}: 1129
//│ [LH_N]: 1181 --->
//│ 	case ls²⁰ of {LH_C h²² t²⁴ => [LH_C f¹²(h²²) map_₀(f¹², t²⁴)] | LH_N  => [LH_N]}: 1276
//│ [LH_N]: 1183 --->
//│ 	case ls²⁰ of {LH_C h²² t²⁴ => [LH_C f¹²(h²²) map_₀(f¹², t²⁴)] | LH_N  => [LH_N]}: 1276
//│ [LH_C take_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀(_lh_collect_arg1¹, drop_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]: 1198 --->
//│ 	case ls²⁰ of {LH_C h²² t²⁴ => [LH_C f¹²(h²²) map_₀(f¹², t²⁴)] | LH_N  => [LH_N]}: 1276
//│ [LH_C f¹²(h²²) map_₀(f¹², t²⁴)]: 1274 --->
//│ 	case ls²² of {LH_C h²⁵ t²⁷ => [LH_C f¹⁴(h²⁵) map_₁(f¹⁴, t²⁷)] | LH_N  => [LH_N]}: 1318
//│ [LH_N]: 1275 --->
//│ 	case ls²² of {LH_C h²⁵ t²⁷ => [LH_C f¹⁴(h²⁵) map_₁(f¹⁴, t²⁷)] | LH_N  => [LH_N]}: 1318
//│ [LH_C f¹⁴(h²⁵) map_₁(f¹⁴, t²⁷)]: 1316 --->
//│ 	case lss¹ of {LH_C h²⁴ t²⁶ => mappend_₀(h²⁴, concat_₀(t²⁶)) | LH_N  => [LH_N]}: 1305
//│ [LH_N]: 1317 --->
//│ 	case lss¹ of {LH_C h²⁴ t²⁶ => mappend_₀(h²⁴, concat_₀(t²⁶)) | LH_N  => [LH_N]}: 1305
//│ [LH_C h²⁶ mappend_₁(t²⁸, ys¹⁰)]: 1328 --->
//│ 	case xs⁹ of {LH_C h²¹ t²³ => [LH_C h²¹ mappend_₀(t²³, ys⁹)] | LH_N  => ys⁹}: 1129
//│ [LH_N]: 1334 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => [LH_C h²⁰ take_₀((n⁴ - 1), t²²)] | LH_N  => [LH_N]}: 1051
//│ 	case _lh_collect_arg2¹ of {LH_N  => [LH_N] | _  => [LH_C take_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀(_lh_collect_arg1¹, drop_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]}: 1199
//│ 	case _lh_drop_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1¹ > 0) then drop_₀((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹] | _  => error⁰}: 1354
//│ [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]: 1351 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => [LH_C h²⁰ take_₀((n⁴ - 1), t²²)] | LH_N  => [LH_N]}: 1051
//│ 	case _lh_collect_arg2¹ of {LH_N  => [LH_N] | _  => [LH_C take_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀(_lh_collect_arg1¹, drop_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]}: 1199
//│ 	case _lh_drop_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1¹ > 0) then drop_₀((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹] | _  => error⁰}: 1354
//│ ------------------
//│ case ls¹⁹ of {LH_C h²⁰ t²² => [LH_C h²⁰ take_₀((n⁴ - 1), t²²)] | LH_N  => [LH_N]}: 1051 --->
//│ 	NoProd
//│ 	[LH_N]: 1334
//│ 	[LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]: 1351
//│ case xs⁹ of {LH_C h²¹ t²³ => [LH_C h²¹ mappend_₀(t²³, ys⁹)] | LH_N  => ys⁹}: 1129 --->
//│ 	[LH_N]: 1078
//│ 	[LH_C 'n' [LH_N]]: 1079
//│ 	[LH_C h²⁶ mappend_₁(t²⁸, ys¹⁰)]: 1328
//│ case _lh_collect_arg2¹ of {LH_N  => [LH_N] | _  => [LH_C take_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀(_lh_collect_arg1¹, drop_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]}: 1199 --->
//│ 	NoProd
//│ 	[LH_N]: 1334
//│ 	[LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]: 1351
//│ case ls²⁰ of {LH_C h²² t²⁴ => [LH_C f¹²(h²²) map_₀(f¹², t²⁴)] | LH_N  => [LH_N]}: 1276 --->
//│ 	[LH_N]: 1181
//│ 	[LH_N]: 1183
//│ 	[LH_C take_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀(_lh_collect_arg1¹, drop_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]: 1198
//│ case ls²¹ of {LH_C h²³ t²⁵ => foldl_₀(f¹³, f¹³(i³, h²³), t²⁵) | LH_N  => i³}: 1292 --->
//│ 	[LH_C h²⁰ take_₀((n⁴ - 1), t²²)]: 1049
//│ 	[LH_N]: 1050
//│ 	[LH_N]: 1052
//│ case lss¹ of {LH_C h²⁴ t²⁶ => mappend_₀(h²⁴, concat_₀(t²⁶)) | LH_N  => [LH_N]}: 1305 --->
//│ 	[LH_C f¹⁴(h²⁵) map_₁(f¹⁴, t²⁷)]: 1316
//│ 	[LH_N]: 1317
//│ case ls²² of {LH_C h²⁵ t²⁷ => [LH_C f¹⁴(h²⁵) map_₁(f¹⁴, t²⁷)] | LH_N  => [LH_N]}: 1318 --->
//│ 	[LH_C f¹²(h²²) map_₀(f¹², t²⁴)]: 1274
//│ 	[LH_N]: 1275
//│ case _lh_drop_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1¹ > 0) then drop_₀((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹] | _  => error⁰}: 1354 --->
//│ 	NoProd
//│ 	[LH_N]: 1334
//│ 	[LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]: 1351
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C h²⁰ take_₀((n⁴ - 1), t²²)]: 1049 --->
//│ 	case ls²¹ of {LH_C h²³ t²⁵ => foldl_₀(f¹³, f¹³(i³, h²³), t²⁵) | LH_N  => i³}: 1292
//│ [LH_N]: 1050 --->
//│ 	case ls²¹ of {LH_C h²³ t²⁵ => foldl_₀(f¹³, f¹³(i³, h²³), t²⁵) | LH_N  => i³}: 1292
//│ [LH_N]: 1052 --->
//│ 	case ls²¹ of {LH_C h²³ t²⁵ => foldl_₀(f¹³, f¹³(i³, h²³), t²⁵) | LH_N  => i³}: 1292
//│ [LH_N]: 1078 --->
//│ 	case xs⁹ of {LH_C h²¹ t²³ => [LH_C h²¹ mappend_₀(t²³, ys⁹)] | LH_N  => ys⁹}: 1129
//│ [LH_C 'n' [LH_N]]: 1079 --->
//│ 	case xs⁹ of {LH_C h²¹ t²³ => [LH_C h²¹ mappend_₀(t²³, ys⁹)] | LH_N  => ys⁹}: 1129
//│ [LH_N]: 1181 --->
//│ 	case ls²⁰ of {LH_C h²² t²⁴ => [LH_C f¹²(h²²) map_₀(f¹², t²⁴)] | LH_N  => [LH_N]}: 1276
//│ [LH_N]: 1183 --->
//│ 	case ls²⁰ of {LH_C h²² t²⁴ => [LH_C f¹²(h²²) map_₀(f¹², t²⁴)] | LH_N  => [LH_N]}: 1276
//│ [LH_C take_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀(_lh_collect_arg1¹, drop_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]: 1198 --->
//│ 	case ls²⁰ of {LH_C h²² t²⁴ => [LH_C f¹²(h²²) map_₀(f¹², t²⁴)] | LH_N  => [LH_N]}: 1276
//│ [LH_C f¹²(h²²) map_₀(f¹², t²⁴)]: 1274 --->
//│ 	case ls²² of {LH_C h²⁵ t²⁷ => [LH_C f¹⁴(h²⁵) map_₁(f¹⁴, t²⁷)] | LH_N  => [LH_N]}: 1318
//│ [LH_N]: 1275 --->
//│ 	case ls²² of {LH_C h²⁵ t²⁷ => [LH_C f¹⁴(h²⁵) map_₁(f¹⁴, t²⁷)] | LH_N  => [LH_N]}: 1318
//│ [LH_C f¹⁴(h²⁵) map_₁(f¹⁴, t²⁷)]: 1316 --->
//│ 	case lss¹ of {LH_C h²⁴ t²⁶ => mappend_₀(h²⁴, concat_₀(t²⁶)) | LH_N  => [LH_N]}: 1305
//│ [LH_N]: 1317 --->
//│ 	case lss¹ of {LH_C h²⁴ t²⁶ => mappend_₀(h²⁴, concat_₀(t²⁶)) | LH_N  => [LH_N]}: 1305
//│ [LH_C h²⁶ mappend_₁(t²⁸, ys¹⁰)]: 1328 --->
//│ 	case xs⁹ of {LH_C h²¹ t²³ => [LH_C h²¹ mappend_₀(t²³, ys⁹)] | LH_N  => ys⁹}: 1129
//│ ------------------
//│ case xs⁹ of {LH_C h²¹ t²³ => [LH_C h²¹ mappend_₀(t²³, ys⁹)] | LH_N  => ys⁹}: 1129 --->
//│ 	[LH_N]: 1078
//│ 	[LH_C 'n' [LH_N]]: 1079
//│ 	[LH_C h²⁶ mappend_₁(t²⁸, ys¹⁰)]: 1328
//│ case ls²⁰ of {LH_C h²² t²⁴ => [LH_C f¹²(h²²) map_₀(f¹², t²⁴)] | LH_N  => [LH_N]}: 1276 --->
//│ 	[LH_N]: 1181
//│ 	[LH_N]: 1183
//│ 	[LH_C take_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀(_lh_collect_arg1¹, drop_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]: 1198
//│ case ls²¹ of {LH_C h²³ t²⁵ => foldl_₀(f¹³, f¹³(i³, h²³), t²⁵) | LH_N  => i³}: 1292 --->
//│ 	[LH_C h²⁰ take_₀((n⁴ - 1), t²²)]: 1049
//│ 	[LH_N]: 1050
//│ 	[LH_N]: 1052
//│ case lss¹ of {LH_C h²⁴ t²⁶ => mappend_₀(h²⁴, concat_₀(t²⁶)) | LH_N  => [LH_N]}: 1305 --->
//│ 	[LH_C f¹⁴(h²⁵) map_₁(f¹⁴, t²⁷)]: 1316
//│ 	[LH_N]: 1317
//│ case ls²² of {LH_C h²⁵ t²⁷ => [LH_C f¹⁴(h²⁵) map_₁(f¹⁴, t²⁷)] | LH_N  => [LH_N]}: 1318 --->
//│ 	[LH_C f¹²(h²²) map_₀(f¹², t²⁴)]: 1274
//│ 	[LH_N]: 1275
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testRsa_nofib_₀(primId⁰(50520))
//│ def code_₀(_lh_code_arg1²) = foldl_₀((fun x⁴ -> (fun y² -> ((128 * x⁴) + int_of_char⁰(y²)))), 0, _lh_code_arg1²)
//│ def collect_₀(_lh_collect_arg1², _lh_collect_arg2²) = case _lh_collect_arg1² of {
//│ 	0  => (fun f²⁰ -> (fun f²¹ -> (fun _lh_dummy⁰ -> [LH_N])))
//│ 	| _  => case _lh_collect_arg2² of {
//│ 		LH_N  => (fun f²² -> (fun f²³ -> (fun _lh_dummy¹ -> [LH_N])))
//│ 		| _  => 
//│ 			let t³² = collect_₀(_lh_collect_arg1², drop_₀(_lh_collect_arg1², _lh_collect_arg2²))
//│ 			in let h³⁰ = take_₀(_lh_collect_arg1², _lh_collect_arg2²)
//│ 			in (fun f²⁴ -> 
//│ 				let t³³ = map_₀(f²⁴, t³²)
//│ 				in let h³¹ = f²⁴(h³⁰)
//│ 				in (fun f²⁵ -> 
//│ 					let t³⁴ = map_₁(f²⁵, t³³)
//│ 					in let h³² = f²⁵(h³¹)
//│ 					in (fun _lh_dummy² -> mappend_₀(h³², concat_₀(t³⁴)))))}}
//│ def concat_₀(lss²) = lss²(99)
//│ def copy_₀(_lh_copy_arg1², _lh_copy_arg2²) = case _lh_copy_arg1² of {
//│ 	0  => [LH_N]
//│ 	| _  => [LH_C _lh_copy_arg2² copy_₀((_lh_copy_arg1² - 1), _lh_copy_arg2²)]}
//│ def drop_₀(_lh_drop_arg1², _lh_drop_arg2²) = case _lh_drop_arg2² of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1² > 0) then drop_₀((_lh_drop_arg1² - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]
//│ 	| _  => error⁰}
//│ def encrypt_₀(_lh_encrypt_arg1², _lh_encrypt_arg2², _lh_funcomp_x⁸) = (fun _lh_funcomp_x⁹ -> unlines_₀(map_₀((fun _lh_funcomp_x¹⁰ -> (fun _lh_funcomp_x¹¹ -> string_of_int⁰(power_₀(_lh_encrypt_arg2², _lh_encrypt_arg1², _lh_funcomp_x¹¹)))(code_₀(_lh_funcomp_x¹⁰))), _lh_funcomp_x⁹)))(collect_₀(size_₀(_lh_encrypt_arg1²), _lh_funcomp_x⁸))
//│ def even_₀(_lh_even_arg1²) = ((_lh_even_arg1² % 2) == 0)
//│ def foldl_₀(f¹⁶, i⁴, ls²⁵) = ls²⁵(f¹⁶, i⁴)
//│ def length_₀(ls²⁷) = case ls²⁷ of {
//│ 	LH_C h²⁷ t²⁹ => (1 + length_₀(t²⁹))
//│ 	| LH_N  => 0}
//│ def map_₀(f¹⁵, ls²⁴) = ls²⁴(f¹⁵)
//│ def map_₁(f²⁶, ls²⁸) = ls²⁸(f²⁶)
//│ def mappend_₀(xs¹¹, ys¹¹) = xs¹¹(ys¹¹)
//│ def mappend_₁(xs¹², ys¹²) = case xs¹² of {
//│ 	LH_C h²⁶ t²⁸ => 
//│ 		let t³¹ = mappend_₁(t²⁸, ys¹²)
//│ 		in let h²⁹ = h²⁶
//│ 		in (fun ys¹³ -> [LH_C h²⁹ mappend_₀(t³¹, ys¹³)])
//│ 	| LH_N  => ys¹²}
//│ def power_₀(_lh_power_arg1², _lh_power_arg2², _lh_power_arg3²) = case _lh_power_arg1² of {
//│ 	0  => 1
//│ 	| _  => if even_₀(_lh_power_arg1²) then (sqr_₀(power_₀(div⁰(_lh_power_arg1², 2), _lh_power_arg2², _lh_power_arg3²)) % _lh_power_arg2²) else ((_lh_power_arg3² * power_₀((_lh_power_arg1² - 1), _lh_power_arg2², _lh_power_arg3²)) % _lh_power_arg2²)}
//│ def size_₀(_lh_size_arg1²) = div⁰((length_₀(string_of_int⁰(_lh_size_arg1²)) * 47), 100)
//│ def sqr_₀(_lh_sqr_arg1²) = (_lh_sqr_arg1² * _lh_sqr_arg1²)
//│ def take_₀(n⁵, ls²⁶) = if (n⁵ > 0) then case ls²⁶ of {
//│ 	LH_C h²⁰ t²² => 
//│ 		let t³⁰ = take_₀((n⁵ - 1), t²²)
//│ 		in let h²⁸ = h²⁰
//│ 		in (fun f¹⁷ -> (fun i⁵ -> foldl_₀(f¹⁷, f¹⁷(i⁵, h²⁸), t³⁰)))
//│ 	| LH_N  => (fun f¹⁸ -> (fun i⁶ -> i⁶))} else (fun f¹⁹ -> (fun i⁷ -> i⁷))
//│ def testRsa_nofib_₀(_lh_testRsa_nofib_arg1²) = encrypt_₀(6367, 5189, primId⁰(copy_₀(_lh_testRsa_nofib_arg1², 'l')))
//│ def unlines_₀(_lh_unlines_arg1²) = concat_₀(map_₁((fun l² -> mappend_₁(l², 
//│ 	let t³⁵ = (fun ys¹⁵ -> ys¹⁵)
//│ 	in let h³³ = 'n'
//│ 	in (fun ys¹⁴ -> [LH_C h³³ mappend_₀(t³⁵, ys¹⁴)]))), _lh_unlines_arg1²))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<





