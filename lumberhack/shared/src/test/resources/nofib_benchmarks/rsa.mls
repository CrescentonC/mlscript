:NewParser
:ParseOnly

:lhInHaskell
:lhGenOCaml
and [] = True
and (h:t) = if h then (and t) else False
copy 0 a = []
copy n a = a:(copy (n - 1) a)
unlines ls = concat (map (\l -> l ++ ['n']) ls)
even a = (a `mod` 2) == 0
drop n [] = []
drop n (h:t) = if n > 0 then (drop (n - 1) t) else (h:t)
encrypt n e = unlines . map (string_of_int . power e n . code) . collect (size n)
code ls = foldl (\x y -> (128 * x) + (int_of_char y)) 0 ls
decode n = reverse (expand n)
expand 0 = []
expand x = (x `mod` 128) : (expand (x `div` 128))
collect 0 xs = []
collect n [] = []
collect n xs = (take n xs) : collect n (drop n xs)
size n = (length (string_of_int n) * 47) `div` 100
prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]
nextPrime a = let odd = (if (even a) then (a + 1) else a) in (head_lz (filter_lz prime [odd,odd+2..]))
iter g v 0  w = v
iter g v h w = let fact = (g `div` h) in (iter h w (g - (fact * h)) (v - (fact * w)))
invert n a = let e = (iter n 0 a 1) in (if e < 0 then e + n else e)
power 0 m x = 1
power n m x = if (even n) then ((sqr (power (n `div` 2) m x)) `mod` m) else ((x * (power (n-1) m x)) `mod` m)
sqr x = x * x
makeKeys p' q' = let p = (nextPrime p') in (let q = (nextPrime q') in (let d = (nextPrime (p+q+1)) in (p * q, invert ((p-1) * (q-1)) d, d)))
testRsa_nofib n = encrypt 6367 5189 (primId $ copy n 'l')
testRsa_nofib $ primId 50520
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testRsa_nofib_₀^1370(primId⁰(50520))
//│ def code_₀(_lh_code_arg1¹) = foldl_₀^1118((fun x³ -> (fun y¹ -> ((128 * x³) + int_of_char⁰(y¹)))), 0, _lh_code_arg1¹)
//│ def collect_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) = case _lh_collect_arg1¹ of {
//│ 	0  => [LH_N]
//│ 	| _  => case _lh_collect_arg2¹ of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => [LH_C take_₀^1268(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀^1273(_lh_collect_arg1¹, drop_₀^1276(_lh_collect_arg1¹, _lh_collect_arg2¹))]}}
//│ def concat_₀(lss¹) = case lss¹ of {
//│ 	LH_C h²⁷ t²⁹ => mappend_₀^1344(h²⁷, concat_₀^1347(t²⁹))
//│ 	| LH_N  => [LH_N]}
//│ def copy_₀(_lh_copy_arg1¹, _lh_copy_arg2¹) = case _lh_copy_arg1¹ of {
//│ 	0  => [LH_N]
//│ 	| _  => [LH_C _lh_copy_arg2¹ copy_₀^1357((_lh_copy_arg1¹ - 1), _lh_copy_arg2¹)]}
//│ def drop_₀(_lh_drop_arg1¹, _lh_drop_arg2¹) = case _lh_drop_arg2¹ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1¹ > 0) then drop_₀^1218((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]
//│ 	| _  => error⁰}
//│ def encrypt_₀(_lh_encrypt_arg1¹, _lh_encrypt_arg2¹, _lh_funcomp_x⁴) = (fun _lh_funcomp_x⁵ -> unlines_₀^1166(map_₀^1167((fun _lh_funcomp_x⁶ -> (fun _lh_funcomp_x⁷ -> string_of_int⁰(power_₀^1169(_lh_encrypt_arg2¹, _lh_encrypt_arg1¹, _lh_funcomp_x⁷)))(code_₀^1178(_lh_funcomp_x⁶))), _lh_funcomp_x⁵)))(collect_₀^1188(size_₀^1189(_lh_encrypt_arg1¹), _lh_funcomp_x⁴))
//│ def even_₀(_lh_even_arg1¹) = ((_lh_even_arg1¹ % 2) == 0)
//│ def foldl_₀(f¹⁴, i³, ls²²) = case ls²² of {
//│ 	LH_C h²⁵ t²⁷ => foldl_₀^1300(f¹⁴, f¹⁴(i³, h²⁵), t²⁷)
//│ 	| LH_N  => i³}
//│ def length_₀(ls²³) = case ls²³ of {
//│ 	LH_C h²⁶ t²⁸ => (1 + length_₀^1330(t²⁸))
//│ 	| LH_N  => 0}
//│ def map_₀(f¹², ls²⁰) = case ls²⁰ of {
//│ 	LH_C h²¹ t²³ => [LH_C f¹²(h²¹) map_₀^1142(f¹², t²³)]
//│ 	| LH_N  => [LH_N]}
//│ def map_₁(f¹³, ls²¹) = case ls²¹ of {
//│ 	LH_C h²² t²⁴ => [LH_C f¹³(h²²) map_₁^1156(f¹³, t²⁴)]
//│ 	| LH_N  => [LH_N]}
//│ def mappend_₀(xs¹⁰, ys¹⁰) = case xs¹⁰ of {
//│ 	LH_C h²⁴ t²⁶ => [LH_C h²⁴ mappend_₀^1289(t²⁶, ys¹⁰)]
//│ 	| LH_N  => ys¹⁰}
//│ def mappend_₁(xs⁹, ys⁹) = case xs⁹ of {
//│ 	LH_C h²³ t²⁵ => [LH_C h²³ mappend_₁^1201(t²⁵, ys⁹)]
//│ 	| LH_N  => ys⁹}
//│ def power_₀(_lh_power_arg1¹, _lh_power_arg2¹, _lh_power_arg3¹) = case _lh_power_arg1¹ of {
//│ 	0  => 1
//│ 	| _  => if even_₀^1074(_lh_power_arg1¹) then (sqr_₀^1078(power_₀^1079(div⁰(_lh_power_arg1¹, 2), _lh_power_arg2¹, _lh_power_arg3¹)) % _lh_power_arg2¹) else ((_lh_power_arg3¹ * power_₀^1098((_lh_power_arg1¹ - 1), _lh_power_arg2¹, _lh_power_arg3¹)) % _lh_power_arg2¹)}
//│ def size_₀(_lh_size_arg1¹) = div⁰((length_₀^1060(string_of_int⁰(_lh_size_arg1¹)) * 47), 100)
//│ def sqr_₀(_lh_sqr_arg1¹) = (_lh_sqr_arg1¹ * _lh_sqr_arg1¹)
//│ def take_₀(n⁴, ls¹⁹) = if (n⁴ > 0) then case ls¹⁹ of {
//│ 	LH_C h²⁰ t²² => [LH_C h²⁰ take_₀^1042((n⁴ - 1), t²²)]
//│ 	| LH_N  => [LH_N]} else [LH_N]
//│ def testRsa_nofib_₀(_lh_testRsa_nofib_arg1¹) = encrypt_₀^1235(6367, 5189, primId⁰(copy_₀^1241(_lh_testRsa_nofib_arg1¹, 'l')))
//│ def unlines_₀(_lh_unlines_arg1¹) = concat_₀^1249(map_₁^1250((fun l¹ -> mappend_₁^1251(l¹, [LH_C 'n' [LH_N]])), _lh_unlines_arg1¹))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec code__d0 _lh_code_arg1_1 =
//│ 		  (((foldl__d0 (fun x_3 y_1 -> 
//│ 		    ((128 * x_3) + (int_of_char y_1)))) 0) _lh_code_arg1_1)
//│ 		and collect__d0 _lh_collect_arg1_1 _lh_collect_arg2_1 =
//│ 		  (match _lh_collect_arg1_1 with
//│ 		    | 0 -> 
//│ 		      (`LH_N)
//│ 		    | _ -> 
//│ 		      (match _lh_collect_arg2_1 with
//│ 		        | `LH_N -> 
//│ 		          (`LH_N)
//│ 		        | _ -> 
//│ 		          (`LH_C(((take__d0 _lh_collect_arg1_1) _lh_collect_arg2_1), ((collect__d0 _lh_collect_arg1_1) ((drop__d0 _lh_collect_arg1_1) _lh_collect_arg2_1))))))
//│ 		and concat__d0 lss_1 =
//│ 		  (match lss_1 with
//│ 		    | `LH_C(h_2_7, t_2_9) -> 
//│ 		      ((mappend__d0 h_2_7) (concat__d0 t_2_9))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and copy__d0 _lh_copy_arg1_1 _lh_copy_arg2_1 =
//│ 		  (match _lh_copy_arg1_1 with
//│ 		    | 0 -> 
//│ 		      (`LH_N)
//│ 		    | _ -> 
//│ 		      (`LH_C(_lh_copy_arg2_1, ((copy__d0 (_lh_copy_arg1_1 - 1)) _lh_copy_arg2_1))))
//│ 		and drop__d0 _lh_drop_arg1_1 _lh_drop_arg2_1 =
//│ 		  (match _lh_drop_arg2_1 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_drop_LH_C_0_1, _lh_drop_LH_C_1_1) -> 
//│ 		      (if (_lh_drop_arg1_1 > 0) then
//│ 		        ((drop__d0 (_lh_drop_arg1_1 - 1)) _lh_drop_LH_C_1_1)
//│ 		      else
//│ 		        (`LH_C(_lh_drop_LH_C_0_1, _lh_drop_LH_C_1_1)))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and encrypt__d0 _lh_encrypt_arg1_1 _lh_encrypt_arg2_1 _lh_funcomp_x_4 =
//│ 		  ((fun _lh_funcomp_x_5 -> 
//│ 		    (unlines__d0 ((map__d0 (fun _lh_funcomp_x_6 -> 
//│ 		      ((fun _lh_funcomp_x_7 -> 
//│ 		        (string_of_int (((power__d0 _lh_encrypt_arg2_1) _lh_encrypt_arg1_1) _lh_funcomp_x_7))) (code__d0 _lh_funcomp_x_6)))) _lh_funcomp_x_5))) ((collect__d0 (size__d0 _lh_encrypt_arg1_1)) _lh_funcomp_x_4))
//│ 		and even__d0 _lh_even_arg1_1 =
//│ 		  ((_lh_even_arg1_1 mod 2) = 0)
//│ 		and foldl__d0 f_1_4 i_3 ls_2_2 =
//│ 		  (match ls_2_2 with
//│ 		    | `LH_C(h_2_5, t_2_7) -> 
//│ 		      (((foldl__d0 f_1_4) ((f_1_4 i_3) h_2_5)) t_2_7)
//│ 		    | `LH_N -> 
//│ 		      i_3)
//│ 		and length__d0 ls_2_3 =
//│ 		  (match ls_2_3 with
//│ 		    | `LH_C(h_2_6, t_2_8) -> 
//│ 		      (1 + (length__d0 t_2_8))
//│ 		    | `LH_N -> 
//│ 		      0)
//│ 		and map__d0 f_1_2 ls_2_0 =
//│ 		  (match ls_2_0 with
//│ 		    | `LH_C(h_2_1, t_2_3) -> 
//│ 		      (`LH_C((f_1_2 h_2_1), ((map__d0 f_1_2) t_2_3)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and map__d1 f_1_3 ls_2_1 =
//│ 		  (match ls_2_1 with
//│ 		    | `LH_C(h_2_2, t_2_4) -> 
//│ 		      (`LH_C((f_1_3 h_2_2), ((map__d1 f_1_3) t_2_4)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and mappend__d0 xs_1_0 ys_1_0 =
//│ 		  (match xs_1_0 with
//│ 		    | `LH_C(h_2_4, t_2_6) -> 
//│ 		      (`LH_C(h_2_4, ((mappend__d0 t_2_6) ys_1_0)))
//│ 		    | `LH_N -> 
//│ 		      ys_1_0)
//│ 		and mappend__d1 xs_9 ys_9 =
//│ 		  (match xs_9 with
//│ 		    | `LH_C(h_2_3, t_2_5) -> 
//│ 		      (`LH_C(h_2_3, ((mappend__d1 t_2_5) ys_9)))
//│ 		    | `LH_N -> 
//│ 		      ys_9)
//│ 		and power__d0 _lh_power_arg1_1 _lh_power_arg2_1 _lh_power_arg3_1 =
//│ 		  (match _lh_power_arg1_1 with
//│ 		    | 0 -> 
//│ 		      1
//│ 		    | _ -> 
//│ 		      (if (even__d0 _lh_power_arg1_1) then
//│ 		        ((sqr__d0 (((power__d0 (_lh_power_arg1_1 / 2)) _lh_power_arg2_1) _lh_power_arg3_1)) mod _lh_power_arg2_1)
//│ 		      else
//│ 		        ((_lh_power_arg3_1 * (((power__d0 (_lh_power_arg1_1 - 1)) _lh_power_arg2_1) _lh_power_arg3_1)) mod _lh_power_arg2_1)))
//│ 		and size__d0 _lh_size_arg1_1 =
//│ 		  (((length__d0 (string_of_int _lh_size_arg1_1)) * 47) / 100)
//│ 		and sqr__d0 _lh_sqr_arg1_1 =
//│ 		  (_lh_sqr_arg1_1 * _lh_sqr_arg1_1)
//│ 		and take__d0 n_4 ls_1_9 =
//│ 		  (if (n_4 > 0) then
//│ 		    (match ls_1_9 with
//│ 		      | `LH_C(h_2_0, t_2_2) -> 
//│ 		        (`LH_C(h_2_0, ((take__d0 (n_4 - 1)) t_2_2)))
//│ 		      | `LH_N -> 
//│ 		        (`LH_N))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and testRsa_nofib__d0 _lh_testRsa_nofib_arg1_1 =
//│ 		  (((encrypt__d0 6367) 5189) ((copy__d0 _lh_testRsa_nofib_arg1_1) 'l'))
//│ 		and unlines__d0 _lh_unlines_arg1_1 =
//│ 		  (concat__d0 ((map__d1 (fun l_1 -> 
//│ 		    ((mappend__d1 l_1) (`LH_C('n', (`LH_N)))))) _lh_unlines_arg1_1));;
//│ 		(testRsa_nofib__d0 50520)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h²⁰ take_₀((n⁴ - 1), t²²)]: 1051 --->
//│ 	case ls²² of {LH_C h²⁵ t²⁷ => foldl_₀(f¹⁴, f¹⁴(i³, h²⁵), t²⁷) | LH_N  => i³}: 1312
//│ [LH_N]: 1052 --->
//│ 	case ls²² of {LH_C h²⁵ t²⁷ => foldl_₀(f¹⁴, f¹⁴(i³, h²⁵), t²⁷) | LH_N  => i³}: 1312
//│ [LH_N]: 1054 --->
//│ 	case ls²² of {LH_C h²⁵ t²⁷ => foldl_₀(f¹⁴, f¹⁴(i³, h²⁵), t²⁷) | LH_N  => i³}: 1312
//│ [LH_C f¹²(h²¹) map_₀(f¹², t²³)]: 1147 --->
//│ 	case ls²¹ of {LH_C h²² t²⁴ => [LH_C f¹³(h²²) map_₁(f¹³, t²⁴)] | LH_N  => [LH_N]}: 1163
//│ [LH_N]: 1148 --->
//│ 	case ls²¹ of {LH_C h²² t²⁴ => [LH_C f¹³(h²²) map_₁(f¹³, t²⁴)] | LH_N  => [LH_N]}: 1163
//│ [LH_C f¹³(h²²) map_₁(f¹³, t²⁴)]: 1161 --->
//│ 	case lss¹ of {LH_C h²⁷ t²⁹ => mappend_₀(h²⁷, concat_₀(t²⁹)) | LH_N  => [LH_N]}: 1352
//│ [LH_N]: 1162 --->
//│ 	case lss¹ of {LH_C h²⁷ t²⁹ => mappend_₀(h²⁷, concat_₀(t²⁹)) | LH_N  => [LH_N]}: 1352
//│ [LH_C h²³ mappend_₁(t²⁵, ys⁹)]: 1206 --->
//│ 	case xs¹⁰ of {LH_C h²⁴ t²⁶ => [LH_C h²⁴ mappend_₀(t²⁶, ys¹⁰)] | LH_N  => ys¹⁰}: 1296
//│ [LH_N]: 1212 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => [LH_C h²⁰ take_₀((n⁴ - 1), t²²)] | LH_N  => [LH_N]}: 1053
//│ 	case _lh_drop_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1¹ > 0) then drop_₀((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹] | _  => error⁰}: 1232
//│ 	case _lh_collect_arg2¹ of {LH_N  => [LH_N] | _  => [LH_C take_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀(_lh_collect_arg1¹, drop_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]}: 1283
//│ [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]: 1229 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => [LH_C h²⁰ take_₀((n⁴ - 1), t²²)] | LH_N  => [LH_N]}: 1053
//│ 	case _lh_drop_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1¹ > 0) then drop_₀((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹] | _  => error⁰}: 1232
//│ 	case _lh_collect_arg2¹ of {LH_N  => [LH_N] | _  => [LH_C take_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀(_lh_collect_arg1¹, drop_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]}: 1283
//│ [LH_N]: 1255 --->
//│ 	case xs¹⁰ of {LH_C h²⁴ t²⁶ => [LH_C h²⁴ mappend_₀(t²⁶, ys¹⁰)] | LH_N  => ys¹⁰}: 1296
//│ [LH_C 'n' [LH_N]]: 1256 --->
//│ 	case xs¹⁰ of {LH_C h²⁴ t²⁶ => [LH_C h²⁴ mappend_₀(t²⁶, ys¹⁰)] | LH_N  => ys¹⁰}: 1296
//│ [LH_N]: 1265 --->
//│ 	case ls²⁰ of {LH_C h²¹ t²³ => [LH_C f¹²(h²¹) map_₀(f¹², t²³)] | LH_N  => [LH_N]}: 1149
//│ [LH_N]: 1267 --->
//│ 	case ls²⁰ of {LH_C h²¹ t²³ => [LH_C f¹²(h²¹) map_₀(f¹², t²³)] | LH_N  => [LH_N]}: 1149
//│ [LH_C take_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀(_lh_collect_arg1¹, drop_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]: 1282 --->
//│ 	case ls²⁰ of {LH_C h²¹ t²³ => [LH_C f¹²(h²¹) map_₀(f¹², t²³)] | LH_N  => [LH_N]}: 1149
//│ ------------------
//│ case ls¹⁹ of {LH_C h²⁰ t²² => [LH_C h²⁰ take_₀((n⁴ - 1), t²²)] | LH_N  => [LH_N]}: 1053 --->
//│ 	NoProd
//│ 	[LH_N]: 1212
//│ 	[LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]: 1229
//│ case ls²⁰ of {LH_C h²¹ t²³ => [LH_C f¹²(h²¹) map_₀(f¹², t²³)] | LH_N  => [LH_N]}: 1149 --->
//│ 	[LH_N]: 1265
//│ 	[LH_N]: 1267
//│ 	[LH_C take_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀(_lh_collect_arg1¹, drop_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]: 1282
//│ case ls²¹ of {LH_C h²² t²⁴ => [LH_C f¹³(h²²) map_₁(f¹³, t²⁴)] | LH_N  => [LH_N]}: 1163 --->
//│ 	[LH_C f¹²(h²¹) map_₀(f¹², t²³)]: 1147
//│ 	[LH_N]: 1148
//│ case _lh_drop_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1¹ > 0) then drop_₀((_lh_drop_arg1¹ - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹] | _  => error⁰}: 1232 --->
//│ 	NoProd
//│ 	[LH_N]: 1212
//│ 	[LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]: 1229
//│ case _lh_collect_arg2¹ of {LH_N  => [LH_N] | _  => [LH_C take_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀(_lh_collect_arg1¹, drop_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]}: 1283 --->
//│ 	NoProd
//│ 	[LH_N]: 1212
//│ 	[LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]: 1229
//│ case xs¹⁰ of {LH_C h²⁴ t²⁶ => [LH_C h²⁴ mappend_₀(t²⁶, ys¹⁰)] | LH_N  => ys¹⁰}: 1296 --->
//│ 	[LH_C h²³ mappend_₁(t²⁵, ys⁹)]: 1206
//│ 	[LH_N]: 1255
//│ 	[LH_C 'n' [LH_N]]: 1256
//│ case ls²² of {LH_C h²⁵ t²⁷ => foldl_₀(f¹⁴, f¹⁴(i³, h²⁵), t²⁷) | LH_N  => i³}: 1312 --->
//│ 	[LH_C h²⁰ take_₀((n⁴ - 1), t²²)]: 1051
//│ 	[LH_N]: 1052
//│ 	[LH_N]: 1054
//│ case lss¹ of {LH_C h²⁷ t²⁹ => mappend_₀(h²⁷, concat_₀(t²⁹)) | LH_N  => [LH_N]}: 1352 --->
//│ 	[LH_C f¹³(h²²) map_₁(f¹³, t²⁴)]: 1161
//│ 	[LH_N]: 1162
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C h²⁰ take_₀((n⁴ - 1), t²²)]: 1051 --->
//│ 	case ls²² of {LH_C h²⁵ t²⁷ => foldl_₀(f¹⁴, f¹⁴(i³, h²⁵), t²⁷) | LH_N  => i³}: 1312
//│ [LH_N]: 1052 --->
//│ 	case ls²² of {LH_C h²⁵ t²⁷ => foldl_₀(f¹⁴, f¹⁴(i³, h²⁵), t²⁷) | LH_N  => i³}: 1312
//│ [LH_N]: 1054 --->
//│ 	case ls²² of {LH_C h²⁵ t²⁷ => foldl_₀(f¹⁴, f¹⁴(i³, h²⁵), t²⁷) | LH_N  => i³}: 1312
//│ [LH_C f¹²(h²¹) map_₀(f¹², t²³)]: 1147 --->
//│ 	case ls²¹ of {LH_C h²² t²⁴ => [LH_C f¹³(h²²) map_₁(f¹³, t²⁴)] | LH_N  => [LH_N]}: 1163
//│ [LH_N]: 1148 --->
//│ 	case ls²¹ of {LH_C h²² t²⁴ => [LH_C f¹³(h²²) map_₁(f¹³, t²⁴)] | LH_N  => [LH_N]}: 1163
//│ [LH_C f¹³(h²²) map_₁(f¹³, t²⁴)]: 1161 --->
//│ 	case lss¹ of {LH_C h²⁷ t²⁹ => mappend_₀(h²⁷, concat_₀(t²⁹)) | LH_N  => [LH_N]}: 1352
//│ [LH_N]: 1162 --->
//│ 	case lss¹ of {LH_C h²⁷ t²⁹ => mappend_₀(h²⁷, concat_₀(t²⁹)) | LH_N  => [LH_N]}: 1352
//│ [LH_C h²³ mappend_₁(t²⁵, ys⁹)]: 1206 --->
//│ 	case xs¹⁰ of {LH_C h²⁴ t²⁶ => [LH_C h²⁴ mappend_₀(t²⁶, ys¹⁰)] | LH_N  => ys¹⁰}: 1296
//│ [LH_N]: 1255 --->
//│ 	case xs¹⁰ of {LH_C h²⁴ t²⁶ => [LH_C h²⁴ mappend_₀(t²⁶, ys¹⁰)] | LH_N  => ys¹⁰}: 1296
//│ [LH_C 'n' [LH_N]]: 1256 --->
//│ 	case xs¹⁰ of {LH_C h²⁴ t²⁶ => [LH_C h²⁴ mappend_₀(t²⁶, ys¹⁰)] | LH_N  => ys¹⁰}: 1296
//│ [LH_N]: 1265 --->
//│ 	case ls²⁰ of {LH_C h²¹ t²³ => [LH_C f¹²(h²¹) map_₀(f¹², t²³)] | LH_N  => [LH_N]}: 1149
//│ [LH_N]: 1267 --->
//│ 	case ls²⁰ of {LH_C h²¹ t²³ => [LH_C f¹²(h²¹) map_₀(f¹², t²³)] | LH_N  => [LH_N]}: 1149
//│ [LH_C take_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀(_lh_collect_arg1¹, drop_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]: 1282 --->
//│ 	case ls²⁰ of {LH_C h²¹ t²³ => [LH_C f¹²(h²¹) map_₀(f¹², t²³)] | LH_N  => [LH_N]}: 1149
//│ ------------------
//│ case ls²⁰ of {LH_C h²¹ t²³ => [LH_C f¹²(h²¹) map_₀(f¹², t²³)] | LH_N  => [LH_N]}: 1149 --->
//│ 	[LH_N]: 1265
//│ 	[LH_N]: 1267
//│ 	[LH_C take_₀(_lh_collect_arg1¹, _lh_collect_arg2¹) collect_₀(_lh_collect_arg1¹, drop_₀(_lh_collect_arg1¹, _lh_collect_arg2¹))]: 1282
//│ case ls²¹ of {LH_C h²² t²⁴ => [LH_C f¹³(h²²) map_₁(f¹³, t²⁴)] | LH_N  => [LH_N]}: 1163 --->
//│ 	[LH_C f¹²(h²¹) map_₀(f¹², t²³)]: 1147
//│ 	[LH_N]: 1148
//│ case xs¹⁰ of {LH_C h²⁴ t²⁶ => [LH_C h²⁴ mappend_₀(t²⁶, ys¹⁰)] | LH_N  => ys¹⁰}: 1296 --->
//│ 	[LH_C h²³ mappend_₁(t²⁵, ys⁹)]: 1206
//│ 	[LH_N]: 1255
//│ 	[LH_C 'n' [LH_N]]: 1256
//│ case ls²² of {LH_C h²⁵ t²⁷ => foldl_₀(f¹⁴, f¹⁴(i³, h²⁵), t²⁷) | LH_N  => i³}: 1312 --->
//│ 	[LH_C h²⁰ take_₀((n⁴ - 1), t²²)]: 1051
//│ 	[LH_N]: 1052
//│ 	[LH_N]: 1054
//│ case lss¹ of {LH_C h²⁷ t²⁹ => mappend_₀(h²⁷, concat_₀(t²⁹)) | LH_N  => [LH_N]}: 1352 --->
//│ 	[LH_C f¹³(h²²) map_₁(f¹³, t²⁴)]: 1161
//│ 	[LH_N]: 1162
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testRsa_nofib_₀(primId⁰(50520))
//│ def code_₀(_lh_code_arg1²) = foldl_₀((fun x⁴ -> (fun y² -> ((128 * x⁴) + int_of_char⁰(y²)))), 0, _lh_code_arg1²)
//│ def collect_₀(_lh_collect_arg1², _lh_collect_arg2²) = case _lh_collect_arg1² of {
//│ 	0  => (fun f²⁰ -> (fun f²¹ -> (fun _lh_dummy⁰ -> [LH_N])))
//│ 	| _  => case _lh_collect_arg2² of {
//│ 		LH_N  => (fun f²² -> (fun f²³ -> (fun _lh_dummy¹ -> [LH_N])))
//│ 		| _  => 
//│ 			let t³² = collect_₀(_lh_collect_arg1², drop_₀(_lh_collect_arg1², _lh_collect_arg2²))
//│ 			in let h³⁰ = take_₀(_lh_collect_arg1², _lh_collect_arg2²)
//│ 			in (fun f²⁴ -> 
//│ 				let t³³ = map_₀(f²⁴, t³²)
//│ 				in let h³¹ = f²⁴(h³⁰)
//│ 				in (fun f²⁵ -> 
//│ 					let t³⁴ = map_₁(f²⁵, t³³)
//│ 					in let h³² = f²⁵(h³¹)
//│ 					in (fun _lh_dummy² -> mappend_₀(h³², concat_₀(t³⁴)))))}}
//│ def concat_₀(lss²) = lss²(99)
//│ def copy_₀(_lh_copy_arg1², _lh_copy_arg2²) = case _lh_copy_arg1² of {
//│ 	0  => [LH_N]
//│ 	| _  => [LH_C _lh_copy_arg2² copy_₀((_lh_copy_arg1² - 1), _lh_copy_arg2²)]}
//│ def drop_₀(_lh_drop_arg1², _lh_drop_arg2²) = case _lh_drop_arg2² of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹ => if (_lh_drop_arg1² > 0) then drop_₀((_lh_drop_arg1² - 1), _lh_drop_LH_C_1¹) else [LH_C _lh_drop_LH_C_0¹ _lh_drop_LH_C_1¹]
//│ 	| _  => error⁰}
//│ def encrypt_₀(_lh_encrypt_arg1², _lh_encrypt_arg2², _lh_funcomp_x⁸) = (fun _lh_funcomp_x⁹ -> unlines_₀(map_₀((fun _lh_funcomp_x¹⁰ -> (fun _lh_funcomp_x¹¹ -> string_of_int⁰(power_₀(_lh_encrypt_arg2², _lh_encrypt_arg1², _lh_funcomp_x¹¹)))(code_₀(_lh_funcomp_x¹⁰))), _lh_funcomp_x⁹)))(collect_₀(size_₀(_lh_encrypt_arg1²), _lh_funcomp_x⁸))
//│ def even_₀(_lh_even_arg1²) = ((_lh_even_arg1² % 2) == 0)
//│ def foldl_₀(f¹⁶, i⁴, ls²⁵) = ls²⁵(f¹⁶, i⁴)
//│ def length_₀(ls²⁷) = case ls²⁷ of {
//│ 	LH_C h²⁶ t²⁸ => (1 + length_₀(t²⁸))
//│ 	| LH_N  => 0}
//│ def map_₀(f¹⁵, ls²⁴) = ls²⁴(f¹⁵)
//│ def map_₁(f²⁶, ls²⁸) = ls²⁸(f²⁶)
//│ def mappend_₀(xs¹¹, ys¹¹) = xs¹¹(ys¹¹)
//│ def mappend_₁(xs¹², ys¹²) = case xs¹² of {
//│ 	LH_C h²³ t²⁵ => 
//│ 		let t³¹ = mappend_₁(t²⁵, ys¹²)
//│ 		in let h²⁹ = h²³
//│ 		in (fun ys¹³ -> [LH_C h²⁹ mappend_₀(t³¹, ys¹³)])
//│ 	| LH_N  => ys¹²}
//│ def power_₀(_lh_power_arg1², _lh_power_arg2², _lh_power_arg3²) = case _lh_power_arg1² of {
//│ 	0  => 1
//│ 	| _  => if even_₀(_lh_power_arg1²) then (sqr_₀(power_₀(div⁰(_lh_power_arg1², 2), _lh_power_arg2², _lh_power_arg3²)) % _lh_power_arg2²) else ((_lh_power_arg3² * power_₀((_lh_power_arg1² - 1), _lh_power_arg2², _lh_power_arg3²)) % _lh_power_arg2²)}
//│ def size_₀(_lh_size_arg1²) = div⁰((length_₀(string_of_int⁰(_lh_size_arg1²)) * 47), 100)
//│ def sqr_₀(_lh_sqr_arg1²) = (_lh_sqr_arg1² * _lh_sqr_arg1²)
//│ def take_₀(n⁵, ls²⁶) = if (n⁵ > 0) then case ls²⁶ of {
//│ 	LH_C h²⁰ t²² => 
//│ 		let t³⁰ = take_₀((n⁵ - 1), t²²)
//│ 		in let h²⁸ = h²⁰
//│ 		in (fun f¹⁷ -> (fun i⁵ -> foldl_₀(f¹⁷, f¹⁷(i⁵, h²⁸), t³⁰)))
//│ 	| LH_N  => (fun f¹⁸ -> (fun i⁶ -> i⁶))} else (fun f¹⁹ -> (fun i⁷ -> i⁷))
//│ def testRsa_nofib_₀(_lh_testRsa_nofib_arg1²) = encrypt_₀(6367, 5189, primId⁰(copy_₀(_lh_testRsa_nofib_arg1², 'l')))
//│ def unlines_₀(_lh_unlines_arg1²) = concat_₀(map_₁((fun l² -> mappend_₁(l², 
//│ 	let t³⁵ = (fun ys¹⁵ -> ys¹⁵)
//│ 	in let h³³ = 'n'
//│ 	in (fun ys¹⁴ -> [LH_C h³³ mappend_₀(t³⁵, ys¹⁴)]))), _lh_unlines_arg1²))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<





