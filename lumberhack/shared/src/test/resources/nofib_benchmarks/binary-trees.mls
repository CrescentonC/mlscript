:NewParser
:ParseOnly

// data Tree = Nil | Node !Int !Tree !Tree

// minN = 4

// io s n t = printf "%s of depth %d\t check: %d\n" s n t

// main = do
//     (i:_) <- getArgs
//     replicateM_ (read i) $ do
//         (_:n:_) <- map read <$> getArgs
//         let maxN     = max (minN + 2) n
//             stretchN = maxN + 1
//         -- stretch memory tree
//         let c = {-# SCC "stretch" #-} check (make 0 stretchN)
//         io "stretch tree" stretchN c

//         -- allocate a long lived tree
//         let !long    = make 0 maxN

//         -- allocate, walk, and deallocate many bottom-up binary trees
//         let vs = depth minN maxN
//         mapM_ (\((m,d,i)) -> io (show m ++ "\t trees") d i) vs

//         -- confirm the the long-lived binary tree still exists
//         io "long lived tree" maxN (check long)

// -- generate many trees
// depth :: Int -> Int -> [(Int,Int,Int)]
// depth d m
//     | d <= m    = let
//     	s = sumT d n 0
//     	rest = depth (d+2) m
//     	in s `par` ((2*n,d,s) : rest)
//     | otherwise = []
//   where n = bit (m - d + minN)

// -- allocate and check lots of trees
// sumT :: Int -> Int -> Int -> Int
// sumT d 0 t = t
// sumT  d i t = a `par` b `par` sumT d (i-1) ans
//   where a = check (make i    d)
//         b = check (make (-i) d)
//         ans = a + b + t

// check = check' True 0

// -- traverse the tree, counting up the nodes
// check' :: Bool -> Int -> Tree -> Int
// check' !b !z Nil          = z
// check' b z (Node i l r)	  = check' (not b) (check' b (if b then z+i else z-i) l) r

// -- build a tree
// make :: Int -> Int -> Tree
// make i 0 = Node i Nil Nil
// make i d = Node i (make (i2-1) d2) (make i2 d2)
//   where i2 = 2*i; d2 = d-1


:lhInHaskell
:lhGenOCaml
depth d m = let n = bit (m - d + minN) in
    if d <= m then
      let s = sumT d n 0 in (let rest = depth (d+2) m in ((2*n,d,s) : rest))
    else []
sumT d 0 t = t
sumT d i t = sumT d (i-1) ((check (make i d)) + (check (make (0-i) d)) + t)
bit n = if n > 0 then 2 * (bit (n - 1)) else 1
minN = 4
check t = check' True 0 t
check' b z Nil          = z
check' b z (Node i l r) = check' (not b) (check' b (if b then (z+i) else (z-i)) l) r
make i 0 = Node i Nil Nil
make i d = let i2 = 2*i in (let d2 = d-1 in (Node i (make (i2-1) d2) (make i2 d2)))
testBinaryTrees_nofib n = check (make 0 n)
testBinaryTrees_nofib $ primId 17
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testBinaryTrees_nofib_₀^887(primId⁰(17))
//│ def check'_₀(_lh_check'_arg1¹, _lh_check'_arg2¹, _lh_check'_arg3¹) = case _lh_check'_arg3¹ of {
//│ 	Nil  => _lh_check'_arg2¹
//│ 	| Node _lh_check'_Node_0¹ _lh_check'_Node_1¹ _lh_check'_Node_2¹ => check'_₀^820(not⁰(_lh_check'_arg1¹), check'_₀^825(_lh_check'_arg1¹, if _lh_check'_arg1¹ then (_lh_check'_arg2¹ + _lh_check'_Node_0¹) else (_lh_check'_arg2¹ - _lh_check'_Node_0¹), _lh_check'_Node_1¹), _lh_check'_Node_2¹)
//│ 	| _  => error⁰}
//│ def check_₀(_lh_check_arg1¹) = check'_₀^802([True], 0, _lh_check_arg1¹)
//│ def make_₀(_lh_make_arg1¹, _lh_make_arg2¹) = case _lh_make_arg2¹ of {
//│ 	0  => [Node _lh_make_arg1¹ [Nil] [Nil]]
//│ 	| _  => 
//│ 		let i2¹ = (2 * _lh_make_arg1¹)
//│ 		in let d2¹ = (_lh_make_arg2¹ - 1)
//│ 		in [Node _lh_make_arg1¹ make_₀^867((i2¹ - 1), d2¹) make_₀^876(i2¹, d2¹)]}
//│ def testBinaryTrees_nofib_₀(_lh_testBinaryTrees_nofib_arg1¹) = check_₀^810(make_₀^811(0, _lh_testBinaryTrees_nofib_arg1¹))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec check'__d0 _lh_check'_arg1_1 _lh_check'_arg2_1 _lh_check'_arg3_1 =
//│ 		  (match _lh_check'_arg3_1 with
//│ 		    | `Nil -> 
//│ 		      _lh_check'_arg2_1
//│ 		    | `Node(_lh_check'_Node_0_1, _lh_check'_Node_1_1, _lh_check'_Node_2_1) -> 
//│ 		      (((check'__d0 (not _lh_check'_arg1_1)) (((check'__d0 _lh_check'_arg1_1) (if _lh_check'_arg1_1 then
//│ 		        (_lh_check'_arg2_1 + _lh_check'_Node_0_1)
//│ 		      else
//│ 		        (_lh_check'_arg2_1 - _lh_check'_Node_0_1))) _lh_check'_Node_1_1)) _lh_check'_Node_2_1)
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and check__d0 _lh_check_arg1_1 =
//│ 		  (((check'__d0 true) 0) _lh_check_arg1_1)
//│ 		and make__d0 _lh_make_arg1_1 _lh_make_arg2_1 =
//│ 		  (match _lh_make_arg2_1 with
//│ 		    | 0 -> 
//│ 		      (`Node(_lh_make_arg1_1, (`Nil), (`Nil)))
//│ 		    | _ -> 
//│ 		      (let rec i2_1 = (2 * _lh_make_arg1_1) in
//│ 		        (let rec d2_1 = (_lh_make_arg2_1 - 1) in
//│ 		          (`Node(_lh_make_arg1_1, ((make__d0 (i2_1 - 1)) d2_1), ((make__d0 i2_1) d2_1))))))
//│ 		and testBinaryTrees_nofib__d0 _lh_testBinaryTrees_nofib_arg1_1 =
//│ 		  (check__d0 ((make__d0 0) _lh_testBinaryTrees_nofib_arg1_1));;
//│ 		(testBinaryTrees_nofib__d0 17)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testBinaryTrees_nofib_₀^887] (hopeless to continue)
//│ 	[testBinaryTrees_nofib_₀^887 · check_₀^810] (using original def)
//│ 		[testBinaryTrees_nofib_₀^887 · check_₀^810 · check'_₀^802] (using original def)
//│ 			[testBinaryTrees_nofib_₀^887 · check_₀^810 · check'_₀^802 · check'_₀^820] ---> [testBinaryTrees_nofib_₀^887 · check_₀^810 · check'_₀^802] (using original def)
//│ 			[testBinaryTrees_nofib_₀^887 · check_₀^810 · check'_₀^802 · check'_₀^825] ---> [testBinaryTrees_nofib_₀^887 · check_₀^810 · check'_₀^802] (using original def)
//│ 	[testBinaryTrees_nofib_₀^887 · make_₀^811] (using original def)
//│ 		[testBinaryTrees_nofib_₀^887 · make_₀^811 · make_₀^867] ---> [testBinaryTrees_nofib_₀^887 · make_₀^811] (using original def)
//│ 		[testBinaryTrees_nofib_₀^887 · make_₀^811 · make_₀^876] ---> [testBinaryTrees_nofib_₀^887 · make_₀^811] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testBinaryTrees_nofib_₀_₀(primId⁰(17))
//│ def testBinaryTrees_nofib_₀_₀(_lh_testBinaryTrees_nofib_arg1¹) = 
//│ 	check_₀_₀(make_₀_₀(0, _lh_testBinaryTrees_nofib_arg1¹))
//│ 	where
//│ 	def check_₀_₀(_lh_check_arg1¹) = 
//│ 		check'_₀_₀([True], 0, _lh_check_arg1¹)
//│ 		where
//│ 		def check'_₀_₀(_lh_check'_arg1¹, _lh_check'_arg2¹, _lh_check'_arg3¹) = 
//│ 			case _lh_check'_arg3¹ of {
//│ 				Nil  => _lh_check'_arg2¹
//│ 				| Node _lh_check'_Node_0¹ _lh_check'_Node_1¹ _lh_check'_Node_2¹ => check'_₀_₀(not⁰(_lh_check'_arg1¹), check'_₀_₀(_lh_check'_arg1¹, if _lh_check'_arg1¹ then (_lh_check'_arg2¹ + _lh_check'_Node_0¹) else (_lh_check'_arg2¹ - _lh_check'_Node_0¹), _lh_check'_Node_1¹), _lh_check'_Node_2¹)
//│ 				| _  => error⁰}
//│ 	def make_₀_₀(_lh_make_arg1¹, _lh_make_arg2¹) = 
//│ 		case _lh_make_arg2¹ of {
//│ 			0  => [Node _lh_make_arg1¹ [Nil] [Nil]]
//│ 			| _  => 
//│ 				let i2¹ = (2 * _lh_make_arg1¹)
//│ 				in let d2¹ = (_lh_make_arg2¹ - 1)
//│ 				in [Node _lh_make_arg1¹ make_₀_₀((i2¹ - 1), d2¹) make_₀_₀(i2¹, d2¹)]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Nil]: 93 --->
//│ 	case _lh_check'_arg3¹ of {Nil  => _lh_check'_arg2¹ | Node _lh_check'_Node_0¹ _lh_check'_Node_1¹ _lh_check'_Node_2¹ => check'_₀_₀(not⁰(_lh_check'_arg1¹), check'_₀_₀(_lh_check'_arg1¹, if _lh_check'_arg1¹ then (_lh_check'_arg2¹ + _lh_check'_Node_0¹) else (_lh_check'_arg2¹ - _lh_check'_Node_0¹), _lh_check'_Node_1¹), _lh_check'_Node_2¹) | _  => error⁰}: 156
//│ [Nil]: 94 --->
//│ 	case _lh_check'_arg3¹ of {Nil  => _lh_check'_arg2¹ | Node _lh_check'_Node_0¹ _lh_check'_Node_1¹ _lh_check'_Node_2¹ => check'_₀_₀(not⁰(_lh_check'_arg1¹), check'_₀_₀(_lh_check'_arg1¹, if _lh_check'_arg1¹ then (_lh_check'_arg2¹ + _lh_check'_Node_0¹) else (_lh_check'_arg2¹ - _lh_check'_Node_0¹), _lh_check'_Node_1¹), _lh_check'_Node_2¹) | _  => error⁰}: 156
//│ [Node _lh_make_arg1¹ [Nil] [Nil]]: 95 --->
//│ 	case _lh_check'_arg3¹ of {Nil  => _lh_check'_arg2¹ | Node _lh_check'_Node_0¹ _lh_check'_Node_1¹ _lh_check'_Node_2¹ => check'_₀_₀(not⁰(_lh_check'_arg1¹), check'_₀_₀(_lh_check'_arg1¹, if _lh_check'_arg1¹ then (_lh_check'_arg2¹ + _lh_check'_Node_0¹) else (_lh_check'_arg2¹ - _lh_check'_Node_0¹), _lh_check'_Node_1¹), _lh_check'_Node_2¹) | _  => error⁰}: 156
//│ [Node _lh_make_arg1¹ make_₀_₀((i2¹ - 1), d2¹) make_₀_₀(i2¹, d2¹)]: 121 --->
//│ 	case _lh_check'_arg3¹ of {Nil  => _lh_check'_arg2¹ | Node _lh_check'_Node_0¹ _lh_check'_Node_1¹ _lh_check'_Node_2¹ => check'_₀_₀(not⁰(_lh_check'_arg1¹), check'_₀_₀(_lh_check'_arg1¹, if _lh_check'_arg1¹ then (_lh_check'_arg2¹ + _lh_check'_Node_0¹) else (_lh_check'_arg2¹ - _lh_check'_Node_0¹), _lh_check'_Node_1¹), _lh_check'_Node_2¹) | _  => error⁰}: 156
//│ ------------------
//│ case _lh_check'_arg3¹ of {Nil  => _lh_check'_arg2¹ | Node _lh_check'_Node_0¹ _lh_check'_Node_1¹ _lh_check'_Node_2¹ => check'_₀_₀(not⁰(_lh_check'_arg1¹), check'_₀_₀(_lh_check'_arg1¹, if _lh_check'_arg1¹ then (_lh_check'_arg2¹ + _lh_check'_Node_0¹) else (_lh_check'_arg2¹ - _lh_check'_Node_0¹), _lh_check'_Node_1¹), _lh_check'_Node_2¹) | _  => error⁰}: 156 --->
//│ 	[Nil]: 93
//│ 	[Nil]: 94
//│ 	[Node _lh_make_arg1¹ [Nil] [Nil]]: 95
//│ 	[Node _lh_make_arg1¹ make_₀_₀((i2¹ - 1), d2¹) make_₀_₀(i2¹, d2¹)]: 121
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Nil]: 93 --->
//│ 	case _lh_check'_arg3¹ of {Nil  => _lh_check'_arg2¹ | Node _lh_check'_Node_0¹ _lh_check'_Node_1¹ _lh_check'_Node_2¹ => check'_₀_₀(not⁰(_lh_check'_arg1¹), check'_₀_₀(_lh_check'_arg1¹, if _lh_check'_arg1¹ then (_lh_check'_arg2¹ + _lh_check'_Node_0¹) else (_lh_check'_arg2¹ - _lh_check'_Node_0¹), _lh_check'_Node_1¹), _lh_check'_Node_2¹) | _  => error⁰}: 156
//│ [Nil]: 94 --->
//│ 	case _lh_check'_arg3¹ of {Nil  => _lh_check'_arg2¹ | Node _lh_check'_Node_0¹ _lh_check'_Node_1¹ _lh_check'_Node_2¹ => check'_₀_₀(not⁰(_lh_check'_arg1¹), check'_₀_₀(_lh_check'_arg1¹, if _lh_check'_arg1¹ then (_lh_check'_arg2¹ + _lh_check'_Node_0¹) else (_lh_check'_arg2¹ - _lh_check'_Node_0¹), _lh_check'_Node_1¹), _lh_check'_Node_2¹) | _  => error⁰}: 156
//│ [Node _lh_make_arg1¹ [Nil] [Nil]]: 95 --->
//│ 	case _lh_check'_arg3¹ of {Nil  => _lh_check'_arg2¹ | Node _lh_check'_Node_0¹ _lh_check'_Node_1¹ _lh_check'_Node_2¹ => check'_₀_₀(not⁰(_lh_check'_arg1¹), check'_₀_₀(_lh_check'_arg1¹, if _lh_check'_arg1¹ then (_lh_check'_arg2¹ + _lh_check'_Node_0¹) else (_lh_check'_arg2¹ - _lh_check'_Node_0¹), _lh_check'_Node_1¹), _lh_check'_Node_2¹) | _  => error⁰}: 156
//│ [Node _lh_make_arg1¹ make_₀_₀((i2¹ - 1), d2¹) make_₀_₀(i2¹, d2¹)]: 121 --->
//│ 	case _lh_check'_arg3¹ of {Nil  => _lh_check'_arg2¹ | Node _lh_check'_Node_0¹ _lh_check'_Node_1¹ _lh_check'_Node_2¹ => check'_₀_₀(not⁰(_lh_check'_arg1¹), check'_₀_₀(_lh_check'_arg1¹, if _lh_check'_arg1¹ then (_lh_check'_arg2¹ + _lh_check'_Node_0¹) else (_lh_check'_arg2¹ - _lh_check'_Node_0¹), _lh_check'_Node_1¹), _lh_check'_Node_2¹) | _  => error⁰}: 156
//│ ------------------
//│ case _lh_check'_arg3¹ of {Nil  => _lh_check'_arg2¹ | Node _lh_check'_Node_0¹ _lh_check'_Node_1¹ _lh_check'_Node_2¹ => check'_₀_₀(not⁰(_lh_check'_arg1¹), check'_₀_₀(_lh_check'_arg1¹, if _lh_check'_arg1¹ then (_lh_check'_arg2¹ + _lh_check'_Node_0¹) else (_lh_check'_arg2¹ - _lh_check'_Node_0¹), _lh_check'_Node_1¹), _lh_check'_Node_2¹) | _  => error⁰}: 156 --->
//│ 	[Nil]: 93
//│ 	[Nil]: 94
//│ 	[Node _lh_make_arg1¹ [Nil] [Nil]]: 95
//│ 	[Node _lh_make_arg1¹ make_₀_₀((i2¹ - 1), d2¹) make_₀_₀(i2¹, d2¹)]: 121
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testBinaryTrees_nofib_₀_₀(primId⁰(17))
//│ def testBinaryTrees_nofib_₀_₀(_lh_testBinaryTrees_nofib_arg1²) = 
//│ 	check_₀_₀(make_₀_₀(0, _lh_testBinaryTrees_nofib_arg1²))
//│ 	where
//│ 	def check_₀_₀(_lh_check_arg1²) = 
//│ 		check'_₀_₀([True], 0, _lh_check_arg1²)
//│ 		where
//│ 		def check'_₀_₀(_lh_check'_arg1⁶, _lh_check'_arg2⁶, _lh_check'_arg3²) = 
//│ 			_lh_check'_arg3²(_lh_check'_arg2⁶, _lh_check'_arg1⁶)
//│ 	def make_₀_₀(_lh_make_arg1², _lh_make_arg2²) = 
//│ 		case _lh_make_arg2² of {
//│ 			0  => 
//│ 				let _lh_check'_Node_2² = (fun _lh_check'_arg2⁴ -> (fun _lh_check'_arg1⁴ -> _lh_check'_arg2⁴))
//│ 				in let _lh_check'_Node_1² = (fun _lh_check'_arg2³ -> (fun _lh_check'_arg1³ -> _lh_check'_arg2³))
//│ 				in let _lh_check'_Node_0² = _lh_make_arg1²
//│ 				in (fun _lh_check'_arg2² -> (fun _lh_check'_arg1² -> check'_₀_₀(not⁰(_lh_check'_arg1²), check'_₀_₀(_lh_check'_arg1², if _lh_check'_arg1² then (_lh_check'_arg2² + _lh_check'_Node_0²) else (_lh_check'_arg2² - _lh_check'_Node_0²), _lh_check'_Node_1²), _lh_check'_Node_2²)))
//│ 			| _  => 
//│ 				let i2² = (2 * _lh_make_arg1²)
//│ 				in let d2² = (_lh_make_arg2² - 1)
//│ 				in let _lh_check'_Node_2³ = make_₀_₀(i2², d2²)
//│ 				in let _lh_check'_Node_1³ = make_₀_₀((i2² - 1), d2²)
//│ 				in let _lh_check'_Node_0³ = _lh_make_arg1²
//│ 				in (fun _lh_check'_arg2⁵ -> (fun _lh_check'_arg1⁵ -> check'_₀_₀(not⁰(_lh_check'_arg1⁵), check'_₀_₀(_lh_check'_arg1⁵, if _lh_check'_arg1⁵ then (_lh_check'_arg2⁵ + _lh_check'_Node_0³) else (_lh_check'_arg2⁵ - _lh_check'_Node_0³), _lh_check'_Node_1³), _lh_check'_Node_2³)))}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

