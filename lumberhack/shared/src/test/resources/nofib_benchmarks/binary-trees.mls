:NewParser
:ParseOnly

// data Tree = Nil | Node !Int !Tree !Tree

// minN = 4

// io s n t = printf "%s of depth %d\t check: %d\n" s n t

// main = do
//     (i:_) <- getArgs
//     replicateM_ (read i) $ do
//         (_:n:_) <- map read <$> getArgs
//         let maxN     = max (minN + 2) n
//             stretchN = maxN + 1
//         -- stretch memory tree
//         let c = {-# SCC "stretch" #-} check (make 0 stretchN)
//         io "stretch tree" stretchN c

//         -- allocate a long lived tree
//         let !long    = make 0 maxN

//         -- allocate, walk, and deallocate many bottom-up binary trees
//         let vs = depth minN maxN
//         mapM_ (\((m,d,i)) -> io (show m ++ "\t trees") d i) vs

//         -- confirm the the long-lived binary tree still exists
//         io "long lived tree" maxN (check long)

// -- generate many trees
// depth :: Int -> Int -> [(Int,Int,Int)]
// depth d m
//     | d <= m    = let
//     	s = sumT d n 0
//     	rest = depth (d+2) m
//     	in s `par` ((2*n,d,s) : rest)
//     | otherwise = []
//   where n = bit (m - d + minN)

// -- allocate and check lots of trees
// sumT :: Int -> Int -> Int -> Int
// sumT d 0 t = t
// sumT  d i t = a `par` b `par` sumT d (i-1) ans
//   where a = check (make i    d)
//         b = check (make (-i) d)
//         ans = a + b + t

// check = check' True 0

// -- traverse the tree, counting up the nodes
// check' :: Bool -> Int -> Tree -> Int
// check' !b !z Nil          = z
// check' b z (Node i l r)	  = check' (not b) (check' b (if b then z+i else z-i) l) r

// -- build a tree
// make :: Int -> Int -> Tree
// make i 0 = Node i Nil Nil
// make i d = Node i (make (i2-1) d2) (make i2 d2)
//   where i2 = 2*i; d2 = d-1


:lhInHaskell
:lhGenOCaml
depth d m = let n = bit (m - d + minN) in
    if d <= m then
      let s = sumT d n 0 in (let rest = depth (d+2) m in ((2*n,d,s) : rest))
    else []
sumT d 0 t = t
sumT d i t = sumT d (i-1) ((check (make i d)) + (check (make (0-i) d)) + t)
bit n = if n > 0 then 2 * (bit (n - 1)) else 1
minN = 4
check t = check' True 0 t
check' b z Nil          = z
check' b z (Node i l r) = check' (not b) (check' b (if b then (z+i) else (z-i)) l) r
make i 0 = Node i Nil Nil
make i d = let i2 = 2*i in (let d2 = d-1 in (Node i (make (i2-1) d2) (make i2 d2)))
testBinaryTrees_nofib n = check (make 0 n)
testBinaryTrees_nofib $ primId 17
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testBinaryTrees_nofib_lh_₁^86(primId⁰(17))
//│ def check'_lh_₁(_lh_check'_arg1⁰, _lh_check'_arg2⁰, _lh_check'_arg3⁰) = case _lh_check'_arg3⁰ of {
//│ 	Nil  => _lh_check'_arg2⁰
//│ 	| Node _lh_check'_Node_0⁰ _lh_check'_Node_1⁰ _lh_check'_Node_2⁰ => check'_lh_₁^3(not⁰(_lh_check'_arg1⁰), check'_lh_₁^8(_lh_check'_arg1⁰, if _lh_check'_arg1⁰ then (_lh_check'_arg2⁰ + _lh_check'_Node_0⁰) else (_lh_check'_arg2⁰ - _lh_check'_Node_0⁰), _lh_check'_Node_1⁰), _lh_check'_Node_2⁰)
//│ 	| _  => error⁰}
//│ def check_lh_₁(_lh_check_arg1⁰) = check'_lh_₁^70([True], 0, _lh_check_arg1⁰)
//│ def make_lh_₁(_lh_make_arg1⁰, _lh_make_arg2⁰) = case _lh_make_arg2⁰ of {
//│ 	0  => [Node _lh_make_arg1⁰ [Nil] [Nil]]
//│ 	| _  => 
//│ 		let i2⁰ = (2 * _lh_make_arg1⁰)
//│ 		in let d2⁰ = (_lh_make_arg2⁰ - 1)
//│ 		in [Node _lh_make_arg1⁰ make_lh_₁^50((i2⁰ - 1), d2⁰) make_lh_₁^59(i2⁰, d2⁰)]}
//│ def testBinaryTrees_nofib_lh_₁(_lh_testBinaryTrees_nofib_arg1⁰) = check_lh_₁^78(make_lh_₁^79(0, _lh_testBinaryTrees_nofib_arg1⁰))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec check'_lh__d1 _lh_check'_arg1_0 _lh_check'_arg2_0 _lh_check'_arg3_0 =
//│ 		  (match _lh_check'_arg3_0 with
//│ 		    | `Nil -> 
//│ 		      _lh_check'_arg2_0
//│ 		    | `Node(_lh_check'_Node_0_0, _lh_check'_Node_1_0, _lh_check'_Node_2_0) -> 
//│ 		      (((check'_lh__d1 (not _lh_check'_arg1_0)) (((check'_lh__d1 _lh_check'_arg1_0) (if _lh_check'_arg1_0 then
//│ 		        (_lh_check'_arg2_0 + _lh_check'_Node_0_0)
//│ 		      else
//│ 		        (_lh_check'_arg2_0 - _lh_check'_Node_0_0))) _lh_check'_Node_1_0)) _lh_check'_Node_2_0)
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec check_lh__d1 _lh_check_arg1_0 =
//│ 		  (((check'_lh__d1 true) 0) _lh_check_arg1_0);;
//│ 		let rec make_lh__d1 _lh_make_arg1_0 _lh_make_arg2_0 =
//│ 		  (match _lh_make_arg2_0 with
//│ 		    | 0 -> 
//│ 		      (`Node(_lh_make_arg1_0, (`Nil), (`Nil)))
//│ 		    | _ -> 
//│ 		      (let rec i2_0 = (2 * _lh_make_arg1_0) in
//│ 		        (let rec d2_0 = (_lh_make_arg2_0 - 1) in
//│ 		          (`Node(_lh_make_arg1_0, ((make_lh__d1 (i2_0 - 1)) d2_0), ((make_lh__d1 i2_0) d2_0))))));;
//│ 		let rec testBinaryTrees_nofib_lh__d1 _lh_testBinaryTrees_nofib_arg1_0 =
//│ 		  (check_lh__d1 ((make_lh__d1 0) _lh_testBinaryTrees_nofib_arg1_0));;
//│ 		(testBinaryTrees_nofib_lh__d1 17)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Nil]: 36 --->
//│ 	case _lh_check'_arg3⁰ of {Nil  => _lh_check'_arg2⁰ | Node _lh_check'_Node_0⁰ _lh_check'_Node_1⁰ _lh_check'_Node_2⁰ => check'_lh_₁(not⁰(_lh_check'_arg1⁰), check'_lh_₁(_lh_check'_arg1⁰, if _lh_check'_arg1⁰ then (_lh_check'_arg2⁰ + _lh_check'_Node_0⁰) else (_lh_check'_arg2⁰ - _lh_check'_Node_0⁰), _lh_check'_Node_1⁰), _lh_check'_Node_2⁰) | _  => error⁰}: 30
//│ [Nil]: 37 --->
//│ 	case _lh_check'_arg3⁰ of {Nil  => _lh_check'_arg2⁰ | Node _lh_check'_Node_0⁰ _lh_check'_Node_1⁰ _lh_check'_Node_2⁰ => check'_lh_₁(not⁰(_lh_check'_arg1⁰), check'_lh_₁(_lh_check'_arg1⁰, if _lh_check'_arg1⁰ then (_lh_check'_arg2⁰ + _lh_check'_Node_0⁰) else (_lh_check'_arg2⁰ - _lh_check'_Node_0⁰), _lh_check'_Node_1⁰), _lh_check'_Node_2⁰) | _  => error⁰}: 30
//│ [Node _lh_make_arg1⁰ [Nil] [Nil]]: 38 --->
//│ 	case _lh_check'_arg3⁰ of {Nil  => _lh_check'_arg2⁰ | Node _lh_check'_Node_0⁰ _lh_check'_Node_1⁰ _lh_check'_Node_2⁰ => check'_lh_₁(not⁰(_lh_check'_arg1⁰), check'_lh_₁(_lh_check'_arg1⁰, if _lh_check'_arg1⁰ then (_lh_check'_arg2⁰ + _lh_check'_Node_0⁰) else (_lh_check'_arg2⁰ - _lh_check'_Node_0⁰), _lh_check'_Node_1⁰), _lh_check'_Node_2⁰) | _  => error⁰}: 30
//│ [Node _lh_make_arg1⁰ make_lh_₁((i2⁰ - 1), d2⁰) make_lh_₁(i2⁰, d2⁰)]: 64 --->
//│ 	case _lh_check'_arg3⁰ of {Nil  => _lh_check'_arg2⁰ | Node _lh_check'_Node_0⁰ _lh_check'_Node_1⁰ _lh_check'_Node_2⁰ => check'_lh_₁(not⁰(_lh_check'_arg1⁰), check'_lh_₁(_lh_check'_arg1⁰, if _lh_check'_arg1⁰ then (_lh_check'_arg2⁰ + _lh_check'_Node_0⁰) else (_lh_check'_arg2⁰ - _lh_check'_Node_0⁰), _lh_check'_Node_1⁰), _lh_check'_Node_2⁰) | _  => error⁰}: 30
//│ ------------------
//│ case _lh_check'_arg3⁰ of {Nil  => _lh_check'_arg2⁰ | Node _lh_check'_Node_0⁰ _lh_check'_Node_1⁰ _lh_check'_Node_2⁰ => check'_lh_₁(not⁰(_lh_check'_arg1⁰), check'_lh_₁(_lh_check'_arg1⁰, if _lh_check'_arg1⁰ then (_lh_check'_arg2⁰ + _lh_check'_Node_0⁰) else (_lh_check'_arg2⁰ - _lh_check'_Node_0⁰), _lh_check'_Node_1⁰), _lh_check'_Node_2⁰) | _  => error⁰}: 30 --->
//│ 	[Nil]: 36
//│ 	[Nil]: 37
//│ 	[Node _lh_make_arg1⁰ [Nil] [Nil]]: 38
//│ 	[Node _lh_make_arg1⁰ make_lh_₁((i2⁰ - 1), d2⁰) make_lh_₁(i2⁰, d2⁰)]: 64
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Nil]: 36 --->
//│ 	case _lh_check'_arg3⁰ of {Nil  => _lh_check'_arg2⁰ | Node _lh_check'_Node_0⁰ _lh_check'_Node_1⁰ _lh_check'_Node_2⁰ => check'_lh_₁(not⁰(_lh_check'_arg1⁰), check'_lh_₁(_lh_check'_arg1⁰, if _lh_check'_arg1⁰ then (_lh_check'_arg2⁰ + _lh_check'_Node_0⁰) else (_lh_check'_arg2⁰ - _lh_check'_Node_0⁰), _lh_check'_Node_1⁰), _lh_check'_Node_2⁰) | _  => error⁰}: 30
//│ [Nil]: 37 --->
//│ 	case _lh_check'_arg3⁰ of {Nil  => _lh_check'_arg2⁰ | Node _lh_check'_Node_0⁰ _lh_check'_Node_1⁰ _lh_check'_Node_2⁰ => check'_lh_₁(not⁰(_lh_check'_arg1⁰), check'_lh_₁(_lh_check'_arg1⁰, if _lh_check'_arg1⁰ then (_lh_check'_arg2⁰ + _lh_check'_Node_0⁰) else (_lh_check'_arg2⁰ - _lh_check'_Node_0⁰), _lh_check'_Node_1⁰), _lh_check'_Node_2⁰) | _  => error⁰}: 30
//│ [Node _lh_make_arg1⁰ [Nil] [Nil]]: 38 --->
//│ 	case _lh_check'_arg3⁰ of {Nil  => _lh_check'_arg2⁰ | Node _lh_check'_Node_0⁰ _lh_check'_Node_1⁰ _lh_check'_Node_2⁰ => check'_lh_₁(not⁰(_lh_check'_arg1⁰), check'_lh_₁(_lh_check'_arg1⁰, if _lh_check'_arg1⁰ then (_lh_check'_arg2⁰ + _lh_check'_Node_0⁰) else (_lh_check'_arg2⁰ - _lh_check'_Node_0⁰), _lh_check'_Node_1⁰), _lh_check'_Node_2⁰) | _  => error⁰}: 30
//│ [Node _lh_make_arg1⁰ make_lh_₁((i2⁰ - 1), d2⁰) make_lh_₁(i2⁰, d2⁰)]: 64 --->
//│ 	case _lh_check'_arg3⁰ of {Nil  => _lh_check'_arg2⁰ | Node _lh_check'_Node_0⁰ _lh_check'_Node_1⁰ _lh_check'_Node_2⁰ => check'_lh_₁(not⁰(_lh_check'_arg1⁰), check'_lh_₁(_lh_check'_arg1⁰, if _lh_check'_arg1⁰ then (_lh_check'_arg2⁰ + _lh_check'_Node_0⁰) else (_lh_check'_arg2⁰ - _lh_check'_Node_0⁰), _lh_check'_Node_1⁰), _lh_check'_Node_2⁰) | _  => error⁰}: 30
//│ ------------------
//│ case _lh_check'_arg3⁰ of {Nil  => _lh_check'_arg2⁰ | Node _lh_check'_Node_0⁰ _lh_check'_Node_1⁰ _lh_check'_Node_2⁰ => check'_lh_₁(not⁰(_lh_check'_arg1⁰), check'_lh_₁(_lh_check'_arg1⁰, if _lh_check'_arg1⁰ then (_lh_check'_arg2⁰ + _lh_check'_Node_0⁰) else (_lh_check'_arg2⁰ - _lh_check'_Node_0⁰), _lh_check'_Node_1⁰), _lh_check'_Node_2⁰) | _  => error⁰}: 30 --->
//│ 	[Nil]: 36
//│ 	[Nil]: 37
//│ 	[Node _lh_make_arg1⁰ [Nil] [Nil]]: 38
//│ 	[Node _lh_make_arg1⁰ make_lh_₁((i2⁰ - 1), d2⁰) make_lh_₁(i2⁰, d2⁰)]: 64
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testBinaryTrees_nofib_lh_₁(primId⁰(17))
//│ def check'_lh_₁(_lh_check'_arg1¹, _lh_check'_arg2¹, _lh_check'_arg3¹) = _lh_check'_arg3¹(_lh_check'_arg2¹, _lh_check'_arg1¹)
//│ def check_lh_₁(_lh_check_arg1¹) = check'_lh_₁([True], 0, _lh_check_arg1¹)
//│ def make_lh_₁(_lh_make_arg1¹, _lh_make_arg2¹) = case _lh_make_arg2¹ of {
//│ 	0  => 
//│ 		let _lh_check'_Node_2¹ = (fun _lh_check'_arg2⁴ -> (fun _lh_check'_arg1⁴ -> _lh_check'_arg2⁴))
//│ 		in let _lh_check'_Node_1¹ = (fun _lh_check'_arg2³ -> (fun _lh_check'_arg1³ -> _lh_check'_arg2³))
//│ 		in let _lh_check'_Node_0¹ = _lh_make_arg1¹
//│ 		in (fun _lh_check'_arg2² -> (fun _lh_check'_arg1² -> check'_lh_₁(not⁰(_lh_check'_arg1²), check'_lh_₁(_lh_check'_arg1², if _lh_check'_arg1² then (_lh_check'_arg2² + _lh_check'_Node_0¹) else (_lh_check'_arg2² - _lh_check'_Node_0¹), _lh_check'_Node_1¹), _lh_check'_Node_2¹)))
//│ 	| _  => 
//│ 		let i2¹ = (2 * _lh_make_arg1¹)
//│ 		in let d2¹ = (_lh_make_arg2¹ - 1)
//│ 		in let _lh_check'_Node_2² = make_lh_₁(i2¹, d2¹)
//│ 		in let _lh_check'_Node_1² = make_lh_₁((i2¹ - 1), d2¹)
//│ 		in let _lh_check'_Node_0² = _lh_make_arg1¹
//│ 		in (fun _lh_check'_arg2⁵ -> (fun _lh_check'_arg1⁵ -> check'_lh_₁(not⁰(_lh_check'_arg1⁵), check'_lh_₁(_lh_check'_arg1⁵, if _lh_check'_arg1⁵ then (_lh_check'_arg2⁵ + _lh_check'_Node_0²) else (_lh_check'_arg2⁵ - _lh_check'_Node_0²), _lh_check'_Node_1²), _lh_check'_Node_2²)))}
//│ def testBinaryTrees_nofib_lh_₁(_lh_testBinaryTrees_nofib_arg1¹) = check_lh_₁(make_lh_₁(0, _lh_testBinaryTrees_nofib_arg1¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

