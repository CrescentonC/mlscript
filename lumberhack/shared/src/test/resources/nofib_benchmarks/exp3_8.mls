:NewParser
:ParseOnly

:lhInHaskell
:lhGenOCaml
natPlus  Z     y   = y
natPlus (S x)  y   = S (natPlus x y)
natMult x      Z   = Z
natMult x   (S y)  = natPlus (natMult x y) x
fromInteger x      = if x < 1 then Z else (S (fromInteger (x - 1)))
int Z     = 0
int (S x) = 1 + (int x)
p x Z     = S Z
p x (S y) = natMult x (p x y)
testExp38_nofib n = int (p (fromInteger 3) (fromInteger n))
testExp38_nofib $ primId 8
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testExp38_nofib_₀^791(primId⁰(8))
//│ def fromInteger_₀(_lh_fromInteger_arg1¹) = if (_lh_fromInteger_arg1¹ < 1) then [Z] else [S fromInteger_₀^741((_lh_fromInteger_arg1¹ - 1))]
//│ def fromInteger_₁(_lh_fromInteger_arg1²) = if (_lh_fromInteger_arg1² < 1) then [Z] else [S fromInteger_₁^781((_lh_fromInteger_arg1² - 1))]
//│ def int_₀(_lh_int_arg1¹) = case _lh_int_arg1¹ of {
//│ 	Z  => 0
//│ 	| S _lh_int_S_0¹ => (1 + int_₀^768(_lh_int_S_0¹))
//│ 	| _  => error⁰}
//│ def natMult_₀(_lh_natMult_arg1¹, _lh_natMult_arg2¹) = case _lh_natMult_arg2¹ of {
//│ 	Z  => [Z]
//│ 	| S _lh_natMult_S_0¹ => natPlus_₀^710(natMult_₀^711(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹)
//│ 	| _  => error⁰}
//│ def natPlus_₀(_lh_natPlus_arg1¹, _lh_natPlus_arg2¹) = case _lh_natPlus_arg1¹ of {
//│ 	Z  => _lh_natPlus_arg2¹
//│ 	| S _lh_natPlus_S_0¹ => [S natPlus_₀^725(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)]
//│ 	| _  => error⁰}
//│ def p_₀(_lh_p_arg1¹, _lh_p_arg2¹) = case _lh_p_arg2¹ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_p_S_0¹ => natMult_₀^695(_lh_p_arg1¹, p_₀^698(_lh_p_arg1¹, _lh_p_S_0¹))
//│ 	| _  => error⁰}
//│ def testExp38_nofib_₀(_lh_testExp38_nofib_arg1¹) = int_₀^751(p_₀^752(fromInteger_₀^753(3), fromInteger_₁^757(_lh_testExp38_nofib_arg1¹)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec fromInteger__d0 _lh_fromInteger_arg1_1 =
//│ 		  (if (_lh_fromInteger_arg1_1 < 1) then
//│ 		    (`Z)
//│ 		  else
//│ 		    (`S((fromInteger__d0 (_lh_fromInteger_arg1_1 - 1)))))
//│ 		and fromInteger__d1 _lh_fromInteger_arg1_2 =
//│ 		  (if (_lh_fromInteger_arg1_2 < 1) then
//│ 		    (`Z)
//│ 		  else
//│ 		    (`S((fromInteger__d1 (_lh_fromInteger_arg1_2 - 1)))))
//│ 		and int__d0 _lh_int_arg1_1 =
//│ 		  (match _lh_int_arg1_1 with
//│ 		    | `Z -> 
//│ 		      0
//│ 		    | `S(_lh_int_S_0_1) -> 
//│ 		      (1 + (int__d0 _lh_int_S_0_1))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and natMult__d0 _lh_natMult_arg1_1 _lh_natMult_arg2_1 =
//│ 		  (match _lh_natMult_arg2_1 with
//│ 		    | `Z -> 
//│ 		      (`Z)
//│ 		    | `S(_lh_natMult_S_0_1) -> 
//│ 		      ((natPlus__d0 ((natMult__d0 _lh_natMult_arg1_1) _lh_natMult_S_0_1)) _lh_natMult_arg1_1)
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and natPlus__d0 _lh_natPlus_arg1_1 _lh_natPlus_arg2_1 =
//│ 		  (match _lh_natPlus_arg1_1 with
//│ 		    | `Z -> 
//│ 		      _lh_natPlus_arg2_1
//│ 		    | `S(_lh_natPlus_S_0_1) -> 
//│ 		      (`S(((natPlus__d0 _lh_natPlus_S_0_1) _lh_natPlus_arg2_1)))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and p__d0 _lh_p_arg1_1 _lh_p_arg2_1 =
//│ 		  (match _lh_p_arg2_1 with
//│ 		    | `Z -> 
//│ 		      (`S((`Z)))
//│ 		    | `S(_lh_p_S_0_1) -> 
//│ 		      ((natMult__d0 _lh_p_arg1_1) ((p__d0 _lh_p_arg1_1) _lh_p_S_0_1))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and testExp38_nofib__d0 _lh_testExp38_nofib_arg1_1 =
//│ 		  (int__d0 ((p__d0 (fromInteger__d0 3)) (fromInteger__d1 _lh_testExp38_nofib_arg1_1)));;
//│ 		(testExp38_nofib__d0 8)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Z]: 693 --->
//│ 	case _lh_natMult_arg2¹ of {Z  => [Z] | S _lh_natMult_S_0¹ => natPlus_₀(natMult_₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹) | _  => error⁰}: 720
//│ 	case _lh_int_arg1¹ of {Z  => 0 | S _lh_int_S_0¹ => (1 + int_₀(_lh_int_S_0¹)) | _  => error⁰}: 773
//│ [S [Z]]: 694 --->
//│ 	case _lh_natMult_arg2¹ of {Z  => [Z] | S _lh_natMult_S_0¹ => natPlus_₀(natMult_₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹) | _  => error⁰}: 720
//│ 	case _lh_int_arg1¹ of {Z  => 0 | S _lh_int_S_0¹ => (1 + int_₀(_lh_int_S_0¹)) | _  => error⁰}: 773
//│ [Z]: 709 --->
//│ 	case _lh_natMult_arg2¹ of {Z  => [Z] | S _lh_natMult_S_0¹ => natPlus_₀(natMult_₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹) | _  => error⁰}: 720
//│ 	case _lh_natPlus_arg1¹ of {Z  => _lh_natPlus_arg2¹ | S _lh_natPlus_S_0¹ => [S natPlus_₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)] | _  => error⁰}: 732
//│ 	case _lh_int_arg1¹ of {Z  => 0 | S _lh_int_S_0¹ => (1 + int_₀(_lh_int_S_0¹)) | _  => error⁰}: 773
//│ [S natPlus_₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)]: 730 --->
//│ 	case _lh_natMult_arg2¹ of {Z  => [Z] | S _lh_natMult_S_0¹ => natPlus_₀(natMult_₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹) | _  => error⁰}: 720
//│ 	case _lh_natPlus_arg1¹ of {Z  => _lh_natPlus_arg2¹ | S _lh_natPlus_S_0¹ => [S natPlus_₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)] | _  => error⁰}: 732
//│ 	case _lh_int_arg1¹ of {Z  => 0 | S _lh_int_S_0¹ => (1 + int_₀(_lh_int_S_0¹)) | _  => error⁰}: 773
//│ [Z]: 740 --->
//│ 	case _lh_natMult_arg2¹ of {Z  => [Z] | S _lh_natMult_S_0¹ => natPlus_₀(natMult_₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹) | _  => error⁰}: 720
//│ 	case _lh_natPlus_arg1¹ of {Z  => _lh_natPlus_arg2¹ | S _lh_natPlus_S_0¹ => [S natPlus_₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)] | _  => error⁰}: 732
//│ 	case _lh_int_arg1¹ of {Z  => 0 | S _lh_int_S_0¹ => (1 + int_₀(_lh_int_S_0¹)) | _  => error⁰}: 773
//│ [S fromInteger_₀((_lh_fromInteger_arg1¹ - 1))]: 748 --->
//│ 	case _lh_natMult_arg2¹ of {Z  => [Z] | S _lh_natMult_S_0¹ => natPlus_₀(natMult_₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹) | _  => error⁰}: 720
//│ 	case _lh_natPlus_arg1¹ of {Z  => _lh_natPlus_arg2¹ | S _lh_natPlus_S_0¹ => [S natPlus_₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)] | _  => error⁰}: 732
//│ 	case _lh_int_arg1¹ of {Z  => 0 | S _lh_int_S_0¹ => (1 + int_₀(_lh_int_S_0¹)) | _  => error⁰}: 773
//│ [Z]: 780 --->
//│ 	case _lh_p_arg2¹ of {Z  => [S [Z]] | S _lh_p_S_0¹ => natMult_₀(_lh_p_arg1¹, p_₀(_lh_p_arg1¹, _lh_p_S_0¹)) | _  => error⁰}: 705
//│ [S fromInteger_₁((_lh_fromInteger_arg1² - 1))]: 788 --->
//│ 	case _lh_p_arg2¹ of {Z  => [S [Z]] | S _lh_p_S_0¹ => natMult_₀(_lh_p_arg1¹, p_₀(_lh_p_arg1¹, _lh_p_S_0¹)) | _  => error⁰}: 705
//│ ------------------
//│ case _lh_p_arg2¹ of {Z  => [S [Z]] | S _lh_p_S_0¹ => natMult_₀(_lh_p_arg1¹, p_₀(_lh_p_arg1¹, _lh_p_S_0¹)) | _  => error⁰}: 705 --->
//│ 	[Z]: 780
//│ 	[S fromInteger_₁((_lh_fromInteger_arg1² - 1))]: 788
//│ case _lh_natMult_arg2¹ of {Z  => [Z] | S _lh_natMult_S_0¹ => natPlus_₀(natMult_₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹) | _  => error⁰}: 720 --->
//│ 	[Z]: 693
//│ 	[S [Z]]: 694
//│ 	[Z]: 709
//│ 	[S natPlus_₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)]: 730
//│ 	[Z]: 740
//│ 	[S fromInteger_₀((_lh_fromInteger_arg1¹ - 1))]: 748
//│ case _lh_natPlus_arg1¹ of {Z  => _lh_natPlus_arg2¹ | S _lh_natPlus_S_0¹ => [S natPlus_₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)] | _  => error⁰}: 732 --->
//│ 	[Z]: 709
//│ 	[S natPlus_₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)]: 730
//│ 	[Z]: 740
//│ 	[S fromInteger_₀((_lh_fromInteger_arg1¹ - 1))]: 748
//│ case _lh_int_arg1¹ of {Z  => 0 | S _lh_int_S_0¹ => (1 + int_₀(_lh_int_S_0¹)) | _  => error⁰}: 773 --->
//│ 	[Z]: 693
//│ 	[S [Z]]: 694
//│ 	[Z]: 709
//│ 	[S natPlus_₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)]: 730
//│ 	[Z]: 740
//│ 	[S fromInteger_₀((_lh_fromInteger_arg1¹ - 1))]: 748
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Z]: 780 --->
//│ 	case _lh_p_arg2¹ of {Z  => [S [Z]] | S _lh_p_S_0¹ => natMult_₀(_lh_p_arg1¹, p_₀(_lh_p_arg1¹, _lh_p_S_0¹)) | _  => error⁰}: 705
//│ [S fromInteger_₁((_lh_fromInteger_arg1² - 1))]: 788 --->
//│ 	case _lh_p_arg2¹ of {Z  => [S [Z]] | S _lh_p_S_0¹ => natMult_₀(_lh_p_arg1¹, p_₀(_lh_p_arg1¹, _lh_p_S_0¹)) | _  => error⁰}: 705
//│ ------------------
//│ case _lh_p_arg2¹ of {Z  => [S [Z]] | S _lh_p_S_0¹ => natMult_₀(_lh_p_arg1¹, p_₀(_lh_p_arg1¹, _lh_p_S_0¹)) | _  => error⁰}: 705 --->
//│ 	[Z]: 780
//│ 	[S fromInteger_₁((_lh_fromInteger_arg1² - 1))]: 788
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testExp38_nofib_₀(primId⁰(8))
//│ def fromInteger_₀(_lh_fromInteger_arg1³) = if (_lh_fromInteger_arg1³ < 1) then [Z] else [S fromInteger_₀((_lh_fromInteger_arg1³ - 1))]
//│ def fromInteger_₁(_lh_fromInteger_arg1⁴) = if (_lh_fromInteger_arg1⁴ < 1) then (fun _lh_p_arg1² -> [S [Z]]) else 
//│ 	let _lh_p_S_0² = fromInteger_₁((_lh_fromInteger_arg1⁴ - 1))
//│ 	in (fun _lh_p_arg1³ -> natMult_₀(_lh_p_arg1³, p_₀(_lh_p_arg1³, _lh_p_S_0²)))
//│ def int_₀(_lh_int_arg1²) = case _lh_int_arg1² of {
//│ 	Z  => 0
//│ 	| S _lh_int_S_0¹ => (1 + int_₀(_lh_int_S_0¹))
//│ 	| _  => error⁰}
//│ def natMult_₀(_lh_natMult_arg1², _lh_natMult_arg2²) = case _lh_natMult_arg2² of {
//│ 	Z  => [Z]
//│ 	| S _lh_natMult_S_0¹ => natPlus_₀(natMult_₀(_lh_natMult_arg1², _lh_natMult_S_0¹), _lh_natMult_arg1²)
//│ 	| _  => error⁰}
//│ def natPlus_₀(_lh_natPlus_arg1², _lh_natPlus_arg2²) = case _lh_natPlus_arg1² of {
//│ 	Z  => _lh_natPlus_arg2²
//│ 	| S _lh_natPlus_S_0¹ => [S natPlus_₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2²)]
//│ 	| _  => error⁰}
//│ def p_₀(_lh_p_arg1⁴, _lh_p_arg2²) = _lh_p_arg2²(_lh_p_arg1⁴)
//│ def testExp38_nofib_₀(_lh_testExp38_nofib_arg1²) = int_₀(p_₀(fromInteger_₀(3), fromInteger_₁(_lh_testExp38_nofib_arg1²)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

