:NewParser
:ParseOnly

:lhInHaskell
:lhGenOCaml
natPlus  Z     y   = y
natPlus (S x)  y   = S (natPlus x y)
natMult x      Z   = Z
natMult x   (S y)  = natPlus (natMult x y) x
fromInteger x      = if x < 1 then Z else (S (fromInteger (x - 1)))
int Z     = 0
int (S x) = 1 + (int x)
p x Z     = S Z
p x (S y) = natMult x (p x y)
testExp38_nofib n = int (p (fromInteger 3) (fromInteger n))
testExp38_nofib $ primId 8
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testExp38_nofib₀^789(primId⁰(8))
//│ def fromInteger₀(_lh_fromInteger_arg1¹) = if (_lh_fromInteger_arg1¹ < 1) then [Z] else [S fromInteger₀^763((_lh_fromInteger_arg1¹ - 1))]
//│ def fromInteger₁(_lh_fromInteger_arg1²) = if (_lh_fromInteger_arg1² < 1) then [Z] else [S fromInteger₁^779((_lh_fromInteger_arg1² - 1))]
//│ def int₀(_lh_int_arg1¹) = case _lh_int_arg1¹ of {
//│ 	Z  => 0
//│ 	| S _lh_int_S_0¹ => (1 + int₀^695(_lh_int_S_0¹))
//│ 	| _  => error⁰}
//│ def natMult₀(_lh_natMult_arg1¹, _lh_natMult_arg2¹) = case _lh_natMult_arg2¹ of {
//│ 	Z  => [Z]
//│ 	| S _lh_natMult_S_0¹ => natPlus₀^744(natMult₀^745(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹)
//│ 	| _  => error⁰}
//│ def natPlus₀(_lh_natPlus_arg1¹, _lh_natPlus_arg2¹) = case _lh_natPlus_arg1¹ of {
//│ 	Z  => _lh_natPlus_arg2¹
//│ 	| S _lh_natPlus_S_0¹ => [S natPlus₀^732(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)]
//│ 	| _  => error⁰}
//│ def p₀(_lh_p_arg1¹, _lh_p_arg2¹) = case _lh_p_arg2¹ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_p_S_0¹ => natMult₀^705(_lh_p_arg1¹, p₀^708(_lh_p_arg1¹, _lh_p_S_0¹))
//│ 	| _  => error⁰}
//│ def testExp38_nofib₀(_lh_testExp38_nofib_arg1¹) = int₀^718(p₀^719(fromInteger₀^720(3), fromInteger₁^724(_lh_testExp38_nofib_arg1¹)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec fromInteger_d0 _lh_fromInteger_arg1_1 =
//│ 		  (if (_lh_fromInteger_arg1_1 < 1) then
//│ 		    (`Z)
//│ 		  else
//│ 		    (`S((fromInteger_d0 (_lh_fromInteger_arg1_1 - 1)))))
//│ 		and fromInteger_d1 _lh_fromInteger_arg1_2 =
//│ 		  (if (_lh_fromInteger_arg1_2 < 1) then
//│ 		    (`Z)
//│ 		  else
//│ 		    (`S((fromInteger_d1 (_lh_fromInteger_arg1_2 - 1)))))
//│ 		and int_d0 _lh_int_arg1_1 =
//│ 		  (match _lh_int_arg1_1 with
//│ 		    | `Z -> 
//│ 		      0
//│ 		    | `S(_lh_int_S_0_1) -> 
//│ 		      (1 + (int_d0 _lh_int_S_0_1))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and natMult_d0 _lh_natMult_arg1_1 _lh_natMult_arg2_1 =
//│ 		  (match _lh_natMult_arg2_1 with
//│ 		    | `Z -> 
//│ 		      (`Z)
//│ 		    | `S(_lh_natMult_S_0_1) -> 
//│ 		      ((natPlus_d0 ((natMult_d0 _lh_natMult_arg1_1) _lh_natMult_S_0_1)) _lh_natMult_arg1_1)
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and natPlus_d0 _lh_natPlus_arg1_1 _lh_natPlus_arg2_1 =
//│ 		  (match _lh_natPlus_arg1_1 with
//│ 		    | `Z -> 
//│ 		      _lh_natPlus_arg2_1
//│ 		    | `S(_lh_natPlus_S_0_1) -> 
//│ 		      (`S(((natPlus_d0 _lh_natPlus_S_0_1) _lh_natPlus_arg2_1)))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and p_d0 _lh_p_arg1_1 _lh_p_arg2_1 =
//│ 		  (match _lh_p_arg2_1 with
//│ 		    | `Z -> 
//│ 		      (`S((`Z)))
//│ 		    | `S(_lh_p_S_0_1) -> 
//│ 		      ((natMult_d0 _lh_p_arg1_1) ((p_d0 _lh_p_arg1_1) _lh_p_S_0_1))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and testExp38_nofib_d0 _lh_testExp38_nofib_arg1_1 =
//│ 		  (int_d0 ((p_d0 (fromInteger_d0 3)) (fromInteger_d1 _lh_testExp38_nofib_arg1_1)));;
//│ 		(testExp38_nofib_d0 8)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testExp38_nofib₀^789] (hopeless to continue)
//│ 	[testExp38_nofib₀^789 · fromInteger₀^720] (using original def)
//│ 		[testExp38_nofib₀^789 · fromInteger₀^720 · fromInteger₀^763] ---> [testExp38_nofib₀^789 · fromInteger₀^720] (using original def)
//│ 	[testExp38_nofib₀^789 · fromInteger₁^724] (using original def)
//│ 		[testExp38_nofib₀^789 · fromInteger₁^724 · fromInteger₁^779] ---> [testExp38_nofib₀^789 · fromInteger₁^724] (using original def)
//│ 	[testExp38_nofib₀^789 · int₀^718] (using original def)
//│ 		[testExp38_nofib₀^789 · int₀^718 · int₀^695] ---> [testExp38_nofib₀^789 · int₀^718] (using original def)
//│ 	[testExp38_nofib₀^789 · p₀^719] (using original def)
//│ 		[testExp38_nofib₀^789 · p₀^719 · natMult₀^705] (using original def)
//│ 			[testExp38_nofib₀^789 · p₀^719 · natMult₀^705 · natMult₀^745] ---> [testExp38_nofib₀^789 · p₀^719 · natMult₀^705] (using original def)
//│ 			[testExp38_nofib₀^789 · p₀^719 · natMult₀^705 · natPlus₀^744] (using original def)
//│ 				[testExp38_nofib₀^789 · p₀^719 · natMult₀^705 · natPlus₀^744 · natPlus₀^732] ---> [testExp38_nofib₀^789 · p₀^719 · natMult₀^705 · natPlus₀^744] (using original def)
//│ 		[testExp38_nofib₀^789 · p₀^719 · p₀^708] ---> [testExp38_nofib₀^789 · p₀^719] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testExp38_nofib₀₀(primId⁰(8))
//│ def testExp38_nofib₀₀(_lh_testExp38_nofib_arg1¹) = 
//│ 	int₀₀(p₀₀(fromInteger₀₀(3), fromInteger₁₀(_lh_testExp38_nofib_arg1¹)))
//│ 	where
//│ 	def fromInteger₀₀(_lh_fromInteger_arg1²) = 
//│ 		if (_lh_fromInteger_arg1² < 1) then [Z] else [S fromInteger₀₀((_lh_fromInteger_arg1² - 1))]
//│ 	def fromInteger₁₀(_lh_fromInteger_arg1³) = 
//│ 		if (_lh_fromInteger_arg1³ < 1) then [Z] else [S fromInteger₁₀((_lh_fromInteger_arg1³ - 1))]
//│ 	def int₀₀(_lh_int_arg1¹) = 
//│ 		case _lh_int_arg1¹ of {
//│ 			Z  => 0
//│ 			| S _lh_int_S_0¹ => (1 + int₀₀(_lh_int_S_0¹))
//│ 			| _  => error⁰}
//│ 	def p₀₀(_lh_p_arg1¹, _lh_p_arg2¹) = 
//│ 		case _lh_p_arg2¹ of {
//│ 			Z  => [S [Z]]
//│ 			| S _lh_p_S_0¹ => natMult₀₀(_lh_p_arg1¹, p₀₀(_lh_p_arg1¹, _lh_p_S_0¹))
//│ 			| _  => error⁰}
//│ 		where
//│ 		def natMult₀₀(_lh_natMult_arg1¹, _lh_natMult_arg2¹) = 
//│ 			case _lh_natMult_arg2¹ of {
//│ 				Z  => [Z]
//│ 				| S _lh_natMult_S_0¹ => natPlus₀₀(natMult₀₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹)
//│ 				| _  => error⁰}
//│ 			where
//│ 			def natPlus₀₀(_lh_natPlus_arg1¹, _lh_natPlus_arg2¹) = 
//│ 				case _lh_natPlus_arg1¹ of {
//│ 					Z  => _lh_natPlus_arg2¹
//│ 					| S _lh_natPlus_S_0¹ => [S natPlus₀₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)]
//│ 					| _  => error⁰}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S natPlus₀₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)]: 124 --->
//│ 	case _lh_natPlus_arg1¹ of {Z  => _lh_natPlus_arg2¹ | S _lh_natPlus_S_0¹ => [S natPlus₀₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)] | _  => error⁰}: 126
//│ 	case _lh_natMult_arg2¹ of {Z  => [Z] | S _lh_natMult_S_0¹ => natPlus₀₀(natMult₀₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹) | _  => error⁰}: 141
//│ 	case _lh_int_arg1¹ of {Z  => 0 | S _lh_int_S_0¹ => (1 + int₀₀(_lh_int_S_0¹)) | _  => error⁰}: 186
//│ [Z]: 130 --->
//│ 	case _lh_natPlus_arg1¹ of {Z  => _lh_natPlus_arg2¹ | S _lh_natPlus_S_0¹ => [S natPlus₀₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)] | _  => error⁰}: 126
//│ 	case _lh_natMult_arg2¹ of {Z  => [Z] | S _lh_natMult_S_0¹ => natPlus₀₀(natMult₀₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹) | _  => error⁰}: 141
//│ 	case _lh_int_arg1¹ of {Z  => 0 | S _lh_int_S_0¹ => (1 + int₀₀(_lh_int_S_0¹)) | _  => error⁰}: 186
//│ [Z]: 149 --->
//│ 	case _lh_natPlus_arg1¹ of {Z  => _lh_natPlus_arg2¹ | S _lh_natPlus_S_0¹ => [S natPlus₀₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)] | _  => error⁰}: 126
//│ 	case _lh_natMult_arg2¹ of {Z  => [Z] | S _lh_natMult_S_0¹ => natPlus₀₀(natMult₀₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹) | _  => error⁰}: 141
//│ 	case _lh_int_arg1¹ of {Z  => 0 | S _lh_int_S_0¹ => (1 + int₀₀(_lh_int_S_0¹)) | _  => error⁰}: 186
//│ [S fromInteger₀₀((_lh_fromInteger_arg1² - 1))]: 157 --->
//│ 	case _lh_natPlus_arg1¹ of {Z  => _lh_natPlus_arg2¹ | S _lh_natPlus_S_0¹ => [S natPlus₀₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)] | _  => error⁰}: 126
//│ 	case _lh_natMult_arg2¹ of {Z  => [Z] | S _lh_natMult_S_0¹ => natPlus₀₀(natMult₀₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹) | _  => error⁰}: 141
//│ 	case _lh_int_arg1¹ of {Z  => 0 | S _lh_int_S_0¹ => (1 + int₀₀(_lh_int_S_0¹)) | _  => error⁰}: 186
//│ [Z]: 165 --->
//│ 	case _lh_p_arg2¹ of {Z  => [S [Z]] | S _lh_p_S_0¹ => natMult₀₀(_lh_p_arg1¹, p₀₀(_lh_p_arg1¹, _lh_p_S_0¹)) | _  => error⁰}: 201
//│ [S fromInteger₁₀((_lh_fromInteger_arg1³ - 1))]: 173 --->
//│ 	case _lh_p_arg2¹ of {Z  => [S [Z]] | S _lh_p_S_0¹ => natMult₀₀(_lh_p_arg1¹, p₀₀(_lh_p_arg1¹, _lh_p_S_0¹)) | _  => error⁰}: 201
//│ [Z]: 189 --->
//│ 	case _lh_natMult_arg2¹ of {Z  => [Z] | S _lh_natMult_S_0¹ => natPlus₀₀(natMult₀₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹) | _  => error⁰}: 141
//│ 	case _lh_int_arg1¹ of {Z  => 0 | S _lh_int_S_0¹ => (1 + int₀₀(_lh_int_S_0¹)) | _  => error⁰}: 186
//│ [S [Z]]: 190 --->
//│ 	case _lh_natMult_arg2¹ of {Z  => [Z] | S _lh_natMult_S_0¹ => natPlus₀₀(natMult₀₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹) | _  => error⁰}: 141
//│ 	case _lh_int_arg1¹ of {Z  => 0 | S _lh_int_S_0¹ => (1 + int₀₀(_lh_int_S_0¹)) | _  => error⁰}: 186
//│ ------------------
//│ case _lh_natPlus_arg1¹ of {Z  => _lh_natPlus_arg2¹ | S _lh_natPlus_S_0¹ => [S natPlus₀₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)] | _  => error⁰}: 126 --->
//│ 	[S natPlus₀₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)]: 124
//│ 	[Z]: 130
//│ 	[Z]: 149
//│ 	[S fromInteger₀₀((_lh_fromInteger_arg1² - 1))]: 157
//│ case _lh_natMult_arg2¹ of {Z  => [Z] | S _lh_natMult_S_0¹ => natPlus₀₀(natMult₀₀(_lh_natMult_arg1¹, _lh_natMult_S_0¹), _lh_natMult_arg1¹) | _  => error⁰}: 141 --->
//│ 	[S natPlus₀₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)]: 124
//│ 	[Z]: 130
//│ 	[Z]: 149
//│ 	[S fromInteger₀₀((_lh_fromInteger_arg1² - 1))]: 157
//│ 	[Z]: 189
//│ 	[S [Z]]: 190
//│ case _lh_int_arg1¹ of {Z  => 0 | S _lh_int_S_0¹ => (1 + int₀₀(_lh_int_S_0¹)) | _  => error⁰}: 186 --->
//│ 	[S natPlus₀₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2¹)]: 124
//│ 	[Z]: 130
//│ 	[Z]: 149
//│ 	[S fromInteger₀₀((_lh_fromInteger_arg1² - 1))]: 157
//│ 	[Z]: 189
//│ 	[S [Z]]: 190
//│ case _lh_p_arg2¹ of {Z  => [S [Z]] | S _lh_p_S_0¹ => natMult₀₀(_lh_p_arg1¹, p₀₀(_lh_p_arg1¹, _lh_p_S_0¹)) | _  => error⁰}: 201 --->
//│ 	[Z]: 165
//│ 	[S fromInteger₁₀((_lh_fromInteger_arg1³ - 1))]: 173
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Z]: 165 --->
//│ 	case _lh_p_arg2¹ of {Z  => [S [Z]] | S _lh_p_S_0¹ => natMult₀₀(_lh_p_arg1¹, p₀₀(_lh_p_arg1¹, _lh_p_S_0¹)) | _  => error⁰}: 201
//│ [S fromInteger₁₀((_lh_fromInteger_arg1³ - 1))]: 173 --->
//│ 	case _lh_p_arg2¹ of {Z  => [S [Z]] | S _lh_p_S_0¹ => natMult₀₀(_lh_p_arg1¹, p₀₀(_lh_p_arg1¹, _lh_p_S_0¹)) | _  => error⁰}: 201
//│ ------------------
//│ case _lh_p_arg2¹ of {Z  => [S [Z]] | S _lh_p_S_0¹ => natMult₀₀(_lh_p_arg1¹, p₀₀(_lh_p_arg1¹, _lh_p_S_0¹)) | _  => error⁰}: 201 --->
//│ 	[Z]: 165
//│ 	[S fromInteger₁₀((_lh_fromInteger_arg1³ - 1))]: 173
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testExp38_nofib₀₀(primId⁰(8))
//│ def testExp38_nofib₀₀(_lh_testExp38_nofib_arg1²) = 
//│ 	int₀₀(p₀₀(fromInteger₀₀(3), fromInteger₁₀(_lh_testExp38_nofib_arg1²)))
//│ 	where
//│ 	def fromInteger₀₀(_lh_fromInteger_arg1⁵) = 
//│ 		if (_lh_fromInteger_arg1⁵ < 1) then [Z] else [S fromInteger₀₀((_lh_fromInteger_arg1⁵ - 1))]
//│ 	def fromInteger₁₀(_lh_fromInteger_arg1⁴) = 
//│ 		if (_lh_fromInteger_arg1⁴ < 1) then (fun _lh_p_arg1² -> [S [Z]]) else 
//│ 			let _lh_p_S_0² = lazy⁰(fromInteger₁₀((_lh_fromInteger_arg1⁴ - 1)))
//│ 			in (fun _lh_p_arg1³ -> natMult₀₀(_lh_p_arg1³, p₀₀(_lh_p_arg1³, force⁰(_lh_p_S_0²))))
//│ 	def int₀₀(_lh_int_arg1²) = 
//│ 		case _lh_int_arg1² of {
//│ 			Z  => 0
//│ 			| S _lh_int_S_0¹ => (1 + int₀₀(_lh_int_S_0¹))
//│ 			| _  => error⁰}
//│ 	def p₀₀(_lh_p_arg1⁴, _lh_p_arg2²) = 
//│ 		_lh_p_arg2²(_lh_p_arg1⁴)
//│ 		where
//│ 		def natMult₀₀(_lh_natMult_arg1², _lh_natMult_arg2²) = 
//│ 			case _lh_natMult_arg2² of {
//│ 				Z  => [Z]
//│ 				| S _lh_natMult_S_0¹ => natPlus₀₀(natMult₀₀(_lh_natMult_arg1², _lh_natMult_S_0¹), _lh_natMult_arg1²)
//│ 				| _  => error⁰}
//│ 			where
//│ 			def natPlus₀₀(_lh_natPlus_arg1², _lh_natPlus_arg2²) = 
//│ 				case _lh_natPlus_arg1² of {
//│ 					Z  => _lh_natPlus_arg2²
//│ 					| S _lh_natPlus_S_0¹ => [S natPlus₀₀(_lh_natPlus_S_0¹, _lh_natPlus_arg2²)]
//│ 					| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

