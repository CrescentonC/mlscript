:NewParser
:ParseOnly

:lhInHaskell
:lhGenOCaml
natPlus  Z     y   = y
natPlus (S x)  y   = S (natPlus x y)
natMult x      Z   = Z
natMult x   (S y)  = natPlus (natMult x y) x
fromInteger x      = if x < 1 then Z else (S (fromInteger (x - 1)))
int Z     = 0
int (S x) = 1 + (int x)
p x Z     = S Z
p x (S y) = natMult x (p x y)
testExp38_nofib n = int (p (fromInteger 3) (fromInteger n))
testExp38_nofib $ primId 8
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testExp38_nofib_lh^84(primId⁰(8))
//│ def fromInteger_lh(_lh_fromInteger_arg1⁰) = if (_lh_fromInteger_arg1⁰ < 1) then [Z] else [S fromInteger_lh^7((_lh_fromInteger_arg1⁰ - 1))]
//│ def int_lh(_lh_int_arg1⁰) = case _lh_int_arg1⁰ of {
//│ 	Z  => 0
//│ 	| S _lh_int_S_0⁰ => (1 + int_lh^61(_lh_int_S_0⁰))
//│ 	| _  => error⁰}
//│ def natMult_lh(_lh_natMult_arg1⁰, _lh_natMult_arg2⁰) = case _lh_natMult_arg2⁰ of {
//│ 	Z  => [Z]
//│ 	| S _lh_natMult_S_0⁰ => natPlus_lh^19(natMult_lh^20(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰)
//│ 	| _  => error⁰}
//│ def natPlus_lh(_lh_natPlus_arg1⁰, _lh_natPlus_arg2⁰) = case _lh_natPlus_arg1⁰ of {
//│ 	Z  => _lh_natPlus_arg2⁰
//│ 	| S _lh_natPlus_S_0⁰ => [S natPlus_lh^46(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)]
//│ 	| _  => error⁰}
//│ def p_lh(_lh_p_arg1⁰, _lh_p_arg2⁰) = case _lh_p_arg2⁰ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_p_S_0⁰ => natMult_lh^71(_lh_p_arg1⁰, p_lh^74(_lh_p_arg1⁰, _lh_p_S_0⁰))
//│ 	| _  => error⁰}
//│ def testExp38_nofib_lh(_lh_testExp38_nofib_arg1⁰) = int_lh^32(p_lh^33(fromInteger_lh^34(3), fromInteger_lh^38(_lh_testExp38_nofib_arg1⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec natPlus_lh _lh_natPlus_arg1_0 _lh_natPlus_arg2_0 =
//│ 		  (match _lh_natPlus_arg1_0 with
//│ 		    | `Z -> 
//│ 		      _lh_natPlus_arg2_0
//│ 		    | `S(_lh_natPlus_S_0_0) -> 
//│ 		      (`S(((natPlus_lh _lh_natPlus_S_0_0) _lh_natPlus_arg2_0)))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec natMult_lh _lh_natMult_arg1_0 _lh_natMult_arg2_0 =
//│ 		  (match _lh_natMult_arg2_0 with
//│ 		    | `Z -> 
//│ 		      (`Z)
//│ 		    | `S(_lh_natMult_S_0_0) -> 
//│ 		      ((natPlus_lh ((natMult_lh _lh_natMult_arg1_0) _lh_natMult_S_0_0)) _lh_natMult_arg1_0)
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec p_lh _lh_p_arg1_0 _lh_p_arg2_0 =
//│ 		  (match _lh_p_arg2_0 with
//│ 		    | `Z -> 
//│ 		      (`S((`Z)))
//│ 		    | `S(_lh_p_S_0_0) -> 
//│ 		      ((natMult_lh _lh_p_arg1_0) ((p_lh _lh_p_arg1_0) _lh_p_S_0_0))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec int_lh _lh_int_arg1_0 =
//│ 		  (match _lh_int_arg1_0 with
//│ 		    | `Z -> 
//│ 		      0
//│ 		    | `S(_lh_int_S_0_0) -> 
//│ 		      (1 + (int_lh _lh_int_S_0_0))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec fromInteger_lh _lh_fromInteger_arg1_0 =
//│ 		  (if (_lh_fromInteger_arg1_0 < 1) then
//│ 		    (`Z)
//│ 		  else
//│ 		    (`S((fromInteger_lh (_lh_fromInteger_arg1_0 - 1)))));;
//│ 		let rec testExp38_nofib_lh _lh_testExp38_nofib_arg1_0 =
//│ 		  (int_lh ((p_lh (fromInteger_lh 3)) (fromInteger_lh _lh_testExp38_nofib_arg1_0)));;
//│ 		(testExp38_nofib_lh 8)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [Z]: 6 --->
//│ 	case _lh_natMult_arg2⁰ of {Z  => [Z] | S _lh_natMult_S_0⁰ => natPlus_lh(natMult_lh(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰) | _  => error⁰}: 29
//│ 	case _lh_natPlus_arg1⁰ of {Z  => _lh_natPlus_arg2⁰ | S _lh_natPlus_S_0⁰ => [S natPlus_lh(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)] | _  => error⁰}: 53
//│ 	case _lh_int_arg1⁰ of {Z  => 0 | S _lh_int_S_0⁰ => (1 + int_lh(_lh_int_S_0⁰)) | _  => error⁰}: 66
//│ 	case _lh_p_arg2⁰ of {Z  => [S [Z]] | S _lh_p_S_0⁰ => natMult_lh(_lh_p_arg1⁰, p_lh(_lh_p_arg1⁰, _lh_p_S_0⁰)) | _  => error⁰}: 81
//│ [S fromInteger_lh((_lh_fromInteger_arg1⁰ - 1))]: 14 --->
//│ 	case _lh_natMult_arg2⁰ of {Z  => [Z] | S _lh_natMult_S_0⁰ => natPlus_lh(natMult_lh(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰) | _  => error⁰}: 29
//│ 	case _lh_natPlus_arg1⁰ of {Z  => _lh_natPlus_arg2⁰ | S _lh_natPlus_S_0⁰ => [S natPlus_lh(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)] | _  => error⁰}: 53
//│ 	case _lh_int_arg1⁰ of {Z  => 0 | S _lh_int_S_0⁰ => (1 + int_lh(_lh_int_S_0⁰)) | _  => error⁰}: 66
//│ 	case _lh_p_arg2⁰ of {Z  => [S [Z]] | S _lh_p_S_0⁰ => natMult_lh(_lh_p_arg1⁰, p_lh(_lh_p_arg1⁰, _lh_p_S_0⁰)) | _  => error⁰}: 81
//│ [Z]: 18 --->
//│ 	case _lh_natMult_arg2⁰ of {Z  => [Z] | S _lh_natMult_S_0⁰ => natPlus_lh(natMult_lh(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰) | _  => error⁰}: 29
//│ 	case _lh_natPlus_arg1⁰ of {Z  => _lh_natPlus_arg2⁰ | S _lh_natPlus_S_0⁰ => [S natPlus_lh(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)] | _  => error⁰}: 53
//│ 	case _lh_int_arg1⁰ of {Z  => 0 | S _lh_int_S_0⁰ => (1 + int_lh(_lh_int_S_0⁰)) | _  => error⁰}: 66
//│ [S natPlus_lh(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)]: 51 --->
//│ 	case _lh_natMult_arg2⁰ of {Z  => [Z] | S _lh_natMult_S_0⁰ => natPlus_lh(natMult_lh(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰) | _  => error⁰}: 29
//│ 	case _lh_natPlus_arg1⁰ of {Z  => _lh_natPlus_arg2⁰ | S _lh_natPlus_S_0⁰ => [S natPlus_lh(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)] | _  => error⁰}: 53
//│ 	case _lh_int_arg1⁰ of {Z  => 0 | S _lh_int_S_0⁰ => (1 + int_lh(_lh_int_S_0⁰)) | _  => error⁰}: 66
//│ [Z]: 69 --->
//│ 	case _lh_natMult_arg2⁰ of {Z  => [Z] | S _lh_natMult_S_0⁰ => natPlus_lh(natMult_lh(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰) | _  => error⁰}: 29
//│ 	case _lh_int_arg1⁰ of {Z  => 0 | S _lh_int_S_0⁰ => (1 + int_lh(_lh_int_S_0⁰)) | _  => error⁰}: 66
//│ [S [Z]]: 70 --->
//│ 	case _lh_natMult_arg2⁰ of {Z  => [Z] | S _lh_natMult_S_0⁰ => natPlus_lh(natMult_lh(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰) | _  => error⁰}: 29
//│ 	case _lh_int_arg1⁰ of {Z  => 0 | S _lh_int_S_0⁰ => (1 + int_lh(_lh_int_S_0⁰)) | _  => error⁰}: 66
//│ ------------------
//│ case _lh_natMult_arg2⁰ of {Z  => [Z] | S _lh_natMult_S_0⁰ => natPlus_lh(natMult_lh(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰) | _  => error⁰}: 29 --->
//│ 	[Z]: 6
//│ 	[S fromInteger_lh((_lh_fromInteger_arg1⁰ - 1))]: 14
//│ 	[Z]: 18
//│ 	[S natPlus_lh(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)]: 51
//│ 	[Z]: 69
//│ 	[S [Z]]: 70
//│ case _lh_natPlus_arg1⁰ of {Z  => _lh_natPlus_arg2⁰ | S _lh_natPlus_S_0⁰ => [S natPlus_lh(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)] | _  => error⁰}: 53 --->
//│ 	[Z]: 6
//│ 	[S fromInteger_lh((_lh_fromInteger_arg1⁰ - 1))]: 14
//│ 	[Z]: 18
//│ 	[S natPlus_lh(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)]: 51
//│ case _lh_int_arg1⁰ of {Z  => 0 | S _lh_int_S_0⁰ => (1 + int_lh(_lh_int_S_0⁰)) | _  => error⁰}: 66 --->
//│ 	[Z]: 6
//│ 	[S fromInteger_lh((_lh_fromInteger_arg1⁰ - 1))]: 14
//│ 	[Z]: 18
//│ 	[S natPlus_lh(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)]: 51
//│ 	[Z]: 69
//│ 	[S [Z]]: 70
//│ case _lh_p_arg2⁰ of {Z  => [S [Z]] | S _lh_p_S_0⁰ => natMult_lh(_lh_p_arg1⁰, p_lh(_lh_p_arg1⁰, _lh_p_S_0⁰)) | _  => error⁰}: 81 --->
//│ 	[Z]: 6
//│ 	[S fromInteger_lh((_lh_fromInteger_arg1⁰ - 1))]: 14
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testExp38_nofib_lh(primId⁰(8))
//│ def fromInteger_lh(_lh_fromInteger_arg1¹) = if (_lh_fromInteger_arg1¹ < 1) then [Z] else [S fromInteger_lh((_lh_fromInteger_arg1¹ - 1))]
//│ def int_lh(_lh_int_arg1¹) = case _lh_int_arg1¹ of {
//│ 	Z  => 0
//│ 	| S _lh_int_S_0⁰ => (1 + int_lh(_lh_int_S_0⁰))
//│ 	| _  => error⁰}
//│ def natMult_lh(_lh_natMult_arg1¹, _lh_natMult_arg2¹) = case _lh_natMult_arg2¹ of {
//│ 	Z  => [Z]
//│ 	| S _lh_natMult_S_0⁰ => natPlus_lh(natMult_lh(_lh_natMult_arg1¹, _lh_natMult_S_0⁰), _lh_natMult_arg1¹)
//│ 	| _  => error⁰}
//│ def natPlus_lh(_lh_natPlus_arg1¹, _lh_natPlus_arg2¹) = case _lh_natPlus_arg1¹ of {
//│ 	Z  => _lh_natPlus_arg2¹
//│ 	| S _lh_natPlus_S_0⁰ => [S natPlus_lh(_lh_natPlus_S_0⁰, _lh_natPlus_arg2¹)]
//│ 	| _  => error⁰}
//│ def p_lh(_lh_p_arg1¹, _lh_p_arg2¹) = case _lh_p_arg2¹ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_p_S_0⁰ => natMult_lh(_lh_p_arg1¹, p_lh(_lh_p_arg1¹, _lh_p_S_0⁰))
//│ 	| _  => error⁰}
//│ def testExp38_nofib_lh(_lh_testExp38_nofib_arg1¹) = int_lh(p_lh(fromInteger_lh(3), fromInteger_lh(_lh_testExp38_nofib_arg1¹)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

