:NewParser
:ParseOnly

:lhInHaskell
:lhGenOCaml
natPlus  Z     y   = y
natPlus (S x)  y   = S (natPlus x y)
natMult x      Z   = Z
natMult x   (S y)  = natPlus (natMult x y) x
fromInteger x      = if x < 1 then Z else (S (fromInteger (x - 1)))
int Z     = 0
int (S x) = 1 + (int x)
p x Z     = S Z
p x (S y) = natMult x (p x y)
testExp38_nofib n = int (p (fromInteger 3) (fromInteger n))
testExp38_nofib $ primId 8
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testExp38_nofib_lh_₁^100(primId⁰(8))
//│ def fromInteger_lh_₁(_lh_fromInteger_arg1¹) = if (_lh_fromInteger_arg1¹ < 1) then [Z] else [S fromInteger_lh_₁^50((_lh_fromInteger_arg1¹ - 1))]
//│ def fromInteger_lh_₂(_lh_fromInteger_arg1⁰) = if (_lh_fromInteger_arg1⁰ < 1) then [Z] else [S fromInteger_lh_₂^34((_lh_fromInteger_arg1⁰ - 1))]
//│ def int_lh_₁(_lh_int_arg1⁰) = case _lh_int_arg1⁰ of {
//│ 	Z  => 0
//│ 	| S _lh_int_S_0⁰ => (1 + int_lh_₁^65(_lh_int_S_0⁰))
//│ 	| _  => error⁰}
//│ def natMult_lh_₁(_lh_natMult_arg1⁰, _lh_natMult_arg2⁰) = case _lh_natMult_arg2⁰ of {
//│ 	Z  => [Z]
//│ 	| S _lh_natMult_S_0⁰ => natPlus_lh_₁^15(natMult_lh_₁^16(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰)
//│ 	| _  => error⁰}
//│ def natPlus_lh_₁(_lh_natPlus_arg1⁰, _lh_natPlus_arg2⁰) = case _lh_natPlus_arg1⁰ of {
//│ 	Z  => _lh_natPlus_arg2⁰
//│ 	| S _lh_natPlus_S_0⁰ => [S natPlus_lh_₁^3(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)]
//│ 	| _  => error⁰}
//│ def p_lh_₁(_lh_p_arg1⁰, _lh_p_arg2⁰) = case _lh_p_arg2⁰ of {
//│ 	Z  => [S [Z]]
//│ 	| S _lh_p_S_0⁰ => natMult_lh_₁^75(_lh_p_arg1⁰, p_lh_₁^78(_lh_p_arg1⁰, _lh_p_S_0⁰))
//│ 	| _  => error⁰}
//│ def testExp38_nofib_lh_₁(_lh_testExp38_nofib_arg1⁰) = int_lh_₁^88(p_lh_₁^89(fromInteger_lh_₂^90(3), fromInteger_lh_₁^94(_lh_testExp38_nofib_arg1⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec natPlus_lh__d1 _lh_natPlus_arg1_0 _lh_natPlus_arg2_0 =
//│ 		  (match _lh_natPlus_arg1_0 with
//│ 		    | `Z -> 
//│ 		      _lh_natPlus_arg2_0
//│ 		    | `S(_lh_natPlus_S_0_0) -> 
//│ 		      (`S(((natPlus_lh__d1 _lh_natPlus_S_0_0) _lh_natPlus_arg2_0)))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec natMult_lh__d1 _lh_natMult_arg1_0 _lh_natMult_arg2_0 =
//│ 		  (match _lh_natMult_arg2_0 with
//│ 		    | `Z -> 
//│ 		      (`Z)
//│ 		    | `S(_lh_natMult_S_0_0) -> 
//│ 		      ((natPlus_lh__d1 ((natMult_lh__d1 _lh_natMult_arg1_0) _lh_natMult_S_0_0)) _lh_natMult_arg1_0)
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec p_lh__d1 _lh_p_arg1_0 _lh_p_arg2_0 =
//│ 		  (match _lh_p_arg2_0 with
//│ 		    | `Z -> 
//│ 		      (`S((`Z)))
//│ 		    | `S(_lh_p_S_0_0) -> 
//│ 		      ((natMult_lh__d1 _lh_p_arg1_0) ((p_lh__d1 _lh_p_arg1_0) _lh_p_S_0_0))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec fromInteger_lh__d1 _lh_fromInteger_arg1_1 =
//│ 		  (if (_lh_fromInteger_arg1_1 < 1) then
//│ 		    (`Z)
//│ 		  else
//│ 		    (`S((fromInteger_lh__d1 (_lh_fromInteger_arg1_1 - 1)))));;
//│ 		let rec int_lh__d1 _lh_int_arg1_0 =
//│ 		  (match _lh_int_arg1_0 with
//│ 		    | `Z -> 
//│ 		      0
//│ 		    | `S(_lh_int_S_0_0) -> 
//│ 		      (1 + (int_lh__d1 _lh_int_S_0_0))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec fromInteger_lh__d2 _lh_fromInteger_arg1_0 =
//│ 		  (if (_lh_fromInteger_arg1_0 < 1) then
//│ 		    (`Z)
//│ 		  else
//│ 		    (`S((fromInteger_lh__d2 (_lh_fromInteger_arg1_0 - 1)))));;
//│ 		let rec testExp38_nofib_lh__d1 _lh_testExp38_nofib_arg1_0 =
//│ 		  (int_lh__d1 ((p_lh__d1 (fromInteger_lh__d2 3)) (fromInteger_lh__d1 _lh_testExp38_nofib_arg1_0)));;
//│ 		(testExp38_nofib_lh__d1 8)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [S natPlus_lh_₁(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)]: 8 --->
//│ 	case _lh_natPlus_arg1⁰ of {Z  => _lh_natPlus_arg2⁰ | S _lh_natPlus_S_0⁰ => [S natPlus_lh_₁(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)] | _  => error⁰}: 10
//│ 	case _lh_natMult_arg2⁰ of {Z  => [Z] | S _lh_natMult_S_0⁰ => natPlus_lh_₁(natMult_lh_₁(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰) | _  => error⁰}: 25
//│ 	case _lh_int_arg1⁰ of {Z  => 0 | S _lh_int_S_0⁰ => (1 + int_lh_₁(_lh_int_S_0⁰)) | _  => error⁰}: 70
//│ [Z]: 14 --->
//│ 	case _lh_natPlus_arg1⁰ of {Z  => _lh_natPlus_arg2⁰ | S _lh_natPlus_S_0⁰ => [S natPlus_lh_₁(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)] | _  => error⁰}: 10
//│ 	case _lh_natMult_arg2⁰ of {Z  => [Z] | S _lh_natMult_S_0⁰ => natPlus_lh_₁(natMult_lh_₁(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰) | _  => error⁰}: 25
//│ 	case _lh_int_arg1⁰ of {Z  => 0 | S _lh_int_S_0⁰ => (1 + int_lh_₁(_lh_int_S_0⁰)) | _  => error⁰}: 70
//│ [Z]: 33 --->
//│ 	case _lh_natPlus_arg1⁰ of {Z  => _lh_natPlus_arg2⁰ | S _lh_natPlus_S_0⁰ => [S natPlus_lh_₁(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)] | _  => error⁰}: 10
//│ 	case _lh_natMult_arg2⁰ of {Z  => [Z] | S _lh_natMult_S_0⁰ => natPlus_lh_₁(natMult_lh_₁(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰) | _  => error⁰}: 25
//│ 	case _lh_int_arg1⁰ of {Z  => 0 | S _lh_int_S_0⁰ => (1 + int_lh_₁(_lh_int_S_0⁰)) | _  => error⁰}: 70
//│ [S fromInteger_lh_₂((_lh_fromInteger_arg1⁰ - 1))]: 41 --->
//│ 	case _lh_natPlus_arg1⁰ of {Z  => _lh_natPlus_arg2⁰ | S _lh_natPlus_S_0⁰ => [S natPlus_lh_₁(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)] | _  => error⁰}: 10
//│ 	case _lh_natMult_arg2⁰ of {Z  => [Z] | S _lh_natMult_S_0⁰ => natPlus_lh_₁(natMult_lh_₁(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰) | _  => error⁰}: 25
//│ 	case _lh_int_arg1⁰ of {Z  => 0 | S _lh_int_S_0⁰ => (1 + int_lh_₁(_lh_int_S_0⁰)) | _  => error⁰}: 70
//│ [Z]: 49 --->
//│ 	case _lh_p_arg2⁰ of {Z  => [S [Z]] | S _lh_p_S_0⁰ => natMult_lh_₁(_lh_p_arg1⁰, p_lh_₁(_lh_p_arg1⁰, _lh_p_S_0⁰)) | _  => error⁰}: 85
//│ [S fromInteger_lh_₁((_lh_fromInteger_arg1¹ - 1))]: 57 --->
//│ 	case _lh_p_arg2⁰ of {Z  => [S [Z]] | S _lh_p_S_0⁰ => natMult_lh_₁(_lh_p_arg1⁰, p_lh_₁(_lh_p_arg1⁰, _lh_p_S_0⁰)) | _  => error⁰}: 85
//│ [Z]: 73 --->
//│ 	case _lh_natMult_arg2⁰ of {Z  => [Z] | S _lh_natMult_S_0⁰ => natPlus_lh_₁(natMult_lh_₁(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰) | _  => error⁰}: 25
//│ 	case _lh_int_arg1⁰ of {Z  => 0 | S _lh_int_S_0⁰ => (1 + int_lh_₁(_lh_int_S_0⁰)) | _  => error⁰}: 70
//│ [S [Z]]: 74 --->
//│ 	case _lh_natMult_arg2⁰ of {Z  => [Z] | S _lh_natMult_S_0⁰ => natPlus_lh_₁(natMult_lh_₁(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰) | _  => error⁰}: 25
//│ 	case _lh_int_arg1⁰ of {Z  => 0 | S _lh_int_S_0⁰ => (1 + int_lh_₁(_lh_int_S_0⁰)) | _  => error⁰}: 70
//│ ------------------
//│ case _lh_natPlus_arg1⁰ of {Z  => _lh_natPlus_arg2⁰ | S _lh_natPlus_S_0⁰ => [S natPlus_lh_₁(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)] | _  => error⁰}: 10 --->
//│ 	[S natPlus_lh_₁(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)]: 8
//│ 	[Z]: 14
//│ 	[Z]: 33
//│ 	[S fromInteger_lh_₂((_lh_fromInteger_arg1⁰ - 1))]: 41
//│ case _lh_natMult_arg2⁰ of {Z  => [Z] | S _lh_natMult_S_0⁰ => natPlus_lh_₁(natMult_lh_₁(_lh_natMult_arg1⁰, _lh_natMult_S_0⁰), _lh_natMult_arg1⁰) | _  => error⁰}: 25 --->
//│ 	[S natPlus_lh_₁(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)]: 8
//│ 	[Z]: 14
//│ 	[Z]: 33
//│ 	[S fromInteger_lh_₂((_lh_fromInteger_arg1⁰ - 1))]: 41
//│ 	[Z]: 73
//│ 	[S [Z]]: 74
//│ case _lh_int_arg1⁰ of {Z  => 0 | S _lh_int_S_0⁰ => (1 + int_lh_₁(_lh_int_S_0⁰)) | _  => error⁰}: 70 --->
//│ 	[S natPlus_lh_₁(_lh_natPlus_S_0⁰, _lh_natPlus_arg2⁰)]: 8
//│ 	[Z]: 14
//│ 	[Z]: 33
//│ 	[S fromInteger_lh_₂((_lh_fromInteger_arg1⁰ - 1))]: 41
//│ 	[Z]: 73
//│ 	[S [Z]]: 74
//│ case _lh_p_arg2⁰ of {Z  => [S [Z]] | S _lh_p_S_0⁰ => natMult_lh_₁(_lh_p_arg1⁰, p_lh_₁(_lh_p_arg1⁰, _lh_p_S_0⁰)) | _  => error⁰}: 85 --->
//│ 	[Z]: 49
//│ 	[S fromInteger_lh_₁((_lh_fromInteger_arg1¹ - 1))]: 57
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [Z]: 49 --->
//│ 	case _lh_p_arg2⁰ of {Z  => [S [Z]] | S _lh_p_S_0⁰ => natMult_lh_₁(_lh_p_arg1⁰, p_lh_₁(_lh_p_arg1⁰, _lh_p_S_0⁰)) | _  => error⁰}: 85
//│ [S fromInteger_lh_₁((_lh_fromInteger_arg1¹ - 1))]: 57 --->
//│ 	case _lh_p_arg2⁰ of {Z  => [S [Z]] | S _lh_p_S_0⁰ => natMult_lh_₁(_lh_p_arg1⁰, p_lh_₁(_lh_p_arg1⁰, _lh_p_S_0⁰)) | _  => error⁰}: 85
//│ ------------------
//│ case _lh_p_arg2⁰ of {Z  => [S [Z]] | S _lh_p_S_0⁰ => natMult_lh_₁(_lh_p_arg1⁰, p_lh_₁(_lh_p_arg1⁰, _lh_p_S_0⁰)) | _  => error⁰}: 85 --->
//│ 	[Z]: 49
//│ 	[S fromInteger_lh_₁((_lh_fromInteger_arg1¹ - 1))]: 57
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testExp38_nofib_lh_₁(primId⁰(8))
//│ def fromInteger_lh_₁(_lh_fromInteger_arg1²) = if (_lh_fromInteger_arg1² < 1) then (fun _lh_p_arg1¹ -> [S [Z]]) else 
//│ 	let _lh_p_S_0¹ = fromInteger_lh_₁((_lh_fromInteger_arg1² - 1))
//│ 	in (fun _lh_p_arg1² -> natMult_lh_₁(_lh_p_arg1², p_lh_₁(_lh_p_arg1², _lh_p_S_0¹)))
//│ def fromInteger_lh_₂(_lh_fromInteger_arg1³) = if (_lh_fromInteger_arg1³ < 1) then [Z] else [S fromInteger_lh_₂((_lh_fromInteger_arg1³ - 1))]
//│ def int_lh_₁(_lh_int_arg1¹) = case _lh_int_arg1¹ of {
//│ 	Z  => 0
//│ 	| S _lh_int_S_0⁰ => (1 + int_lh_₁(_lh_int_S_0⁰))
//│ 	| _  => error⁰}
//│ def natMult_lh_₁(_lh_natMult_arg1¹, _lh_natMult_arg2¹) = case _lh_natMult_arg2¹ of {
//│ 	Z  => [Z]
//│ 	| S _lh_natMult_S_0⁰ => natPlus_lh_₁(natMult_lh_₁(_lh_natMult_arg1¹, _lh_natMult_S_0⁰), _lh_natMult_arg1¹)
//│ 	| _  => error⁰}
//│ def natPlus_lh_₁(_lh_natPlus_arg1¹, _lh_natPlus_arg2¹) = case _lh_natPlus_arg1¹ of {
//│ 	Z  => _lh_natPlus_arg2¹
//│ 	| S _lh_natPlus_S_0⁰ => [S natPlus_lh_₁(_lh_natPlus_S_0⁰, _lh_natPlus_arg2¹)]
//│ 	| _  => error⁰}
//│ def p_lh_₁(_lh_p_arg1³, _lh_p_arg2¹) = _lh_p_arg2¹(_lh_p_arg1³)
//│ def testExp38_nofib_lh_₁(_lh_testExp38_nofib_arg1¹) = int_lh_₁(p_lh_₁(fromInteger_lh_₂(3), fromInteger_lh_₁(_lh_testExp38_nofib_arg1¹)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

