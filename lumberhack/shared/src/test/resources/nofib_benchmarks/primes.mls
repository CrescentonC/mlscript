:NewParser
:ParseOnly

// isdivs :: Int  -> Int -> Bool
// isdivs n x = mod x n /= 0

// the_filter :: [Int] -> [Int]
// the_filter (n:ns) = filter (isdivs n) ns

// prime :: Int -> Int
// prime n = map head (iterate the_filter [2..n*n]) !! n

// main = forM_ [1..100] $ const $ do
// 	[arg] <- getArgs
// 	print $ prime (read arg)


:lhInHaskell
:lhGenOCaml
isdivs n x = (x `mod` n) /= 0
the_filter (n:ns) = filter (isdivs n) ns
prime n = atIndex_lz n (map_lz head (iterate the_filter [2..(n*n)]))
testPrime_nofib n = prime n
testPrime_nofib $ primId 100
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testPrime_nofib_lh^156(primId⁰(100))
//│ def atIndex_lz_lh(n⁰, ls³) = if (n⁰ < 0) then error⁰ else case force⁰(ls³) of {
//│ 	LH_C h³ t³ => if (n⁰ == 0) then h³ else atIndex_lz_lh^93((n⁰ - 1), t³)
//│ 	| LH_N  => error⁰}
//│ def enumFromTo_lh(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh^51((a⁰ + 1), b⁰)] else [LH_N]
//│ def filter_lh(f¹, ls¹) = case ls¹ of {
//│ 	LH_C h¹ t¹ => if f¹(h¹) then [LH_C h¹ filter_lh^24(f¹, t¹)] else filter_lh^30(f¹, t¹)
//│ 	| LH_N  => [LH_N]}
//│ def head_lh(ls²) = case ls² of {
//│ 	LH_C h² t² => h²
//│ 	| LH_N  => error⁰}
//│ def isdivs_lh(_lh_isdivs_arg1⁰, _lh_isdivs_arg2⁰) = ((_lh_isdivs_arg2⁰ % _lh_isdivs_arg1⁰) /= 0)
//│ def iterate_lh(f², x⁰) = lazy⁰([LH_C x⁰ iterate_lh^67(f², f²(x⁰))])
//│ def map_lz_lh(f⁰, ls⁰) = lazy⁰(case force⁰(ls⁰) of {
//│ 	LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lz_lh^8(f⁰, t⁰)]
//│ 	| LH_N  => [LH_N]})
//│ def prime_lh(_lh_prime_arg1⁰) = atIndex_lz_lh^123(_lh_prime_arg1⁰, map_lz_lh^126(head_lh^127, iterate_lh^129(the_filter_lh^130, enumFromTo_lh^132(2, (_lh_prime_arg1⁰ * _lh_prime_arg1⁰)))))
//│ def testPrime_nofib_lh(_lh_testPrime_nofib_arg1⁰) = prime_lh^119(_lh_testPrime_nofib_arg1⁰)
//│ def the_filter_lh(_lh_the_filter_arg1⁰) = case _lh_the_filter_arg1⁰ of {
//│ 	LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh^109(isdivs_lh^110(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰)
//│ 	| _  => error⁰}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_lh a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec iterate_lh f_2 x_0 =
//│ 		  (lazy (`LH_C(x_0, ((iterate_lh f_2) (f_2 x_0)))));;
//│ 		let rec filter_lh f_1 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      (if (f_1 h_1) then
//│ 		        (`LH_C(h_1, ((filter_lh f_1) t_1)))
//│ 		      else
//│ 		        ((filter_lh f_1) t_1))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec isdivs_lh _lh_isdivs_arg1_0 _lh_isdivs_arg2_0 =
//│ 		  ((_lh_isdivs_arg2_0 mod _lh_isdivs_arg1_0) <> 0);;
//│ 		let rec the_filter_lh _lh_the_filter_arg1_0 =
//│ 		  (match _lh_the_filter_arg1_0 with
//│ 		    | `LH_C(_lh_the_filter_LH_C_0_0, _lh_the_filter_LH_C_1_0) -> 
//│ 		      ((filter_lh (isdivs_lh _lh_the_filter_LH_C_0_0)) _lh_the_filter_LH_C_1_0)
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec head_lh ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `LH_C(h_2, t_2) -> 
//│ 		      h_2
//│ 		    | `LH_N -> 
//│ 		      (failwith "error"));;
//│ 		let rec map_lz_lh f_0 ls_0 =
//│ 		  (lazy (match (Lazy.force ls_0) with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (`LH_C((f_0 h_0), ((map_lz_lh f_0) t_0)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)));;
//│ 		let rec atIndex_lz_lh n_0 ls_3 =
//│ 		  (if (n_0 < 0) then
//│ 		    (failwith "error")
//│ 		  else
//│ 		    (match (Lazy.force ls_3) with
//│ 		      | `LH_C(h_3, t_3) -> 
//│ 		        (if (n_0 = 0) then
//│ 		          h_3
//│ 		        else
//│ 		          ((atIndex_lz_lh (n_0 - 1)) t_3))
//│ 		      | `LH_N -> 
//│ 		        (failwith "error")));;
//│ 		let rec prime_lh _lh_prime_arg1_0 =
//│ 		  ((atIndex_lz_lh _lh_prime_arg1_0) ((map_lz_lh head_lh) ((iterate_lh the_filter_lh) ((enumFromTo_lh 2) (_lh_prime_arg1_0 * _lh_prime_arg1_0)))));;
//│ 		let rec testPrime_nofib_lh _lh_testPrime_nofib_arg1_0 =
//│ 		  (prime_lh _lh_testPrime_nofib_arg1_0);;
//│ 		(testPrime_nofib_lh 100)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f⁰(h⁰) map_lz_lh(f⁰, t⁰)]: 13 --->
//│ 	case force⁰(ls³) of {LH_C h³ t³ => if (n⁰ == 0) then h³ else atIndex_lz_lh((n⁰ - 1), t³) | LH_N  => error⁰}: 104
//│ [LH_N]: 14 --->
//│ 	case force⁰(ls³) of {LH_C h³ t³ => if (n⁰ == 0) then h³ else atIndex_lz_lh((n⁰ - 1), t³) | LH_N  => error⁰}: 104
//│ [LH_C h¹ filter_lh(f¹, t¹)]: 29 --->
//│ 	DeadCodeCons
//│ 	case ls¹ of {LH_C h¹ t¹ => if f¹(h¹) then [LH_C h¹ filter_lh(f¹, t¹)] else filter_lh(f¹, t¹) | LH_N  => [LH_N]}: 37
//│ 	case ls² of {LH_C h² t² => h² | LH_N  => error⁰}: 43
//│ 	case _lh_the_filter_arg1⁰ of {LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh(isdivs_lh(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰) | _  => error⁰}: 117
//│ [LH_N]: 36 --->
//│ 	DeadCodeCons
//│ 	case ls¹ of {LH_C h¹ t¹ => if f¹(h¹) then [LH_C h¹ filter_lh(f¹, t¹)] else filter_lh(f¹, t¹) | LH_N  => [LH_N]}: 37
//│ 	case ls² of {LH_C h² t² => h² | LH_N  => error⁰}: 43
//│ 	case _lh_the_filter_arg1⁰ of {LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh(isdivs_lh(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰) | _  => error⁰}: 117
//│ [LH_C a⁰ enumFromTo_lh((a⁰ + 1), b⁰)]: 60 --->
//│ 	DeadCodeCons
//│ 	case ls¹ of {LH_C h¹ t¹ => if f¹(h¹) then [LH_C h¹ filter_lh(f¹, t¹)] else filter_lh(f¹, t¹) | LH_N  => [LH_N]}: 37
//│ 	case ls² of {LH_C h² t² => h² | LH_N  => error⁰}: 43
//│ 	case _lh_the_filter_arg1⁰ of {LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh(isdivs_lh(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰) | _  => error⁰}: 117
//│ [LH_N]: 61 --->
//│ 	DeadCodeCons
//│ 	case ls¹ of {LH_C h¹ t¹ => if f¹(h¹) then [LH_C h¹ filter_lh(f¹, t¹)] else filter_lh(f¹, t¹) | LH_N  => [LH_N]}: 37
//│ 	case ls² of {LH_C h² t² => h² | LH_N  => error⁰}: 43
//│ 	case _lh_the_filter_arg1⁰ of {LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh(isdivs_lh(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰) | _  => error⁰}: 117
//│ [LH_C x⁰ iterate_lh(f², f²(x⁰))]: 74 --->
//│ 	case force⁰(ls⁰) of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lz_lh(f⁰, t⁰)] | LH_N  => [LH_N]}: 15
//│ ------------------
//│ case force⁰(ls⁰) of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lz_lh(f⁰, t⁰)] | LH_N  => [LH_N]}: 15 --->
//│ 	[LH_C x⁰ iterate_lh(f², f²(x⁰))]: 74
//│ case ls¹ of {LH_C h¹ t¹ => if f¹(h¹) then [LH_C h¹ filter_lh(f¹, t¹)] else filter_lh(f¹, t¹) | LH_N  => [LH_N]}: 37 --->
//│ 	[LH_C h¹ filter_lh(f¹, t¹)]: 29
//│ 	[LH_N]: 36
//│ 	[LH_C a⁰ enumFromTo_lh((a⁰ + 1), b⁰)]: 60
//│ 	[LH_N]: 61
//│ case ls² of {LH_C h² t² => h² | LH_N  => error⁰}: 43 --->
//│ 	[LH_C h¹ filter_lh(f¹, t¹)]: 29
//│ 	[LH_N]: 36
//│ 	[LH_C a⁰ enumFromTo_lh((a⁰ + 1), b⁰)]: 60
//│ 	[LH_N]: 61
//│ case force⁰(ls³) of {LH_C h³ t³ => if (n⁰ == 0) then h³ else atIndex_lz_lh((n⁰ - 1), t³) | LH_N  => error⁰}: 104 --->
//│ 	[LH_C f⁰(h⁰) map_lz_lh(f⁰, t⁰)]: 13
//│ 	[LH_N]: 14
//│ case _lh_the_filter_arg1⁰ of {LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh(isdivs_lh(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰) | _  => error⁰}: 117 --->
//│ 	[LH_C h¹ filter_lh(f¹, t¹)]: 29
//│ 	[LH_N]: 36
//│ 	[LH_C a⁰ enumFromTo_lh((a⁰ + 1), b⁰)]: 60
//│ 	[LH_N]: 61
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f⁰(h⁰) map_lz_lh(f⁰, t⁰)]: 13 --->
//│ 	case force⁰(ls³) of {LH_C h³ t³ => if (n⁰ == 0) then h³ else atIndex_lz_lh((n⁰ - 1), t³) | LH_N  => error⁰}: 104
//│ [LH_N]: 14 --->
//│ 	case force⁰(ls³) of {LH_C h³ t³ => if (n⁰ == 0) then h³ else atIndex_lz_lh((n⁰ - 1), t³) | LH_N  => error⁰}: 104
//│ [LH_C x⁰ iterate_lh(f², f²(x⁰))]: 74 --->
//│ 	case force⁰(ls⁰) of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lz_lh(f⁰, t⁰)] | LH_N  => [LH_N]}: 15
//│ ------------------
//│ case force⁰(ls⁰) of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lz_lh(f⁰, t⁰)] | LH_N  => [LH_N]}: 15 --->
//│ 	[LH_C x⁰ iterate_lh(f², f²(x⁰))]: 74
//│ case force⁰(ls³) of {LH_C h³ t³ => if (n⁰ == 0) then h³ else atIndex_lz_lh((n⁰ - 1), t³) | LH_N  => error⁰}: 104 --->
//│ 	[LH_C f⁰(h⁰) map_lz_lh(f⁰, t⁰)]: 13
//│ 	[LH_N]: 14
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testPrime_nofib_lh(primId⁰(100))
//│ def atIndex_lz_lh(n², ls⁶) = if (n² < 0) then error⁰ else force⁰(ls⁶, n²)
//│ def enumFromTo_lh(a¹, b¹) = if (a¹ <= b¹) then [LH_C a¹ enumFromTo_lh((a¹ + 1), b¹)] else [LH_N]
//│ def filter_lh(f⁶, ls⁷) = case ls⁷ of {
//│ 	LH_C h¹ t¹ => if f⁶(h¹) then [LH_C h¹ filter_lh(f⁶, t¹)] else filter_lh(f⁶, t¹)
//│ 	| LH_N  => [LH_N]}
//│ def head_lh(ls⁴) = case ls⁴ of {
//│ 	LH_C h² t² => h²
//│ 	| LH_N  => error⁰}
//│ def isdivs_lh(_lh_isdivs_arg1¹, _lh_isdivs_arg2¹) = ((_lh_isdivs_arg2¹ % _lh_isdivs_arg1¹) /= 0)
//│ def iterate_lh(f³, x¹) = lazy⁰(
//│ 	let t⁴ = iterate_lh(f³, f³(x¹))
//│ 	in let h⁴ = x¹
//│ 	in (fun f⁴ -> 
//│ 		let t⁵ = map_lz_lh(f⁴, t⁴)
//│ 		in let h⁵ = f⁴(h⁴)
//│ 		in (fun n¹ -> if (n¹ == 0) then h⁵ else atIndex_lz_lh((n¹ - 1), t⁵))))
//│ def map_lz_lh(f⁵, ls⁵) = lazy⁰(force⁰(ls⁵, f⁵))
//│ def prime_lh(_lh_prime_arg1¹) = atIndex_lz_lh(_lh_prime_arg1¹, map_lz_lh(head_lh, iterate_lh(the_filter_lh, enumFromTo_lh(2, (_lh_prime_arg1¹ * _lh_prime_arg1¹)))))
//│ def testPrime_nofib_lh(_lh_testPrime_nofib_arg1¹) = prime_lh(_lh_testPrime_nofib_arg1¹)
//│ def the_filter_lh(_lh_the_filter_arg1¹) = case _lh_the_filter_arg1¹ of {
//│ 	LH_C _lh_the_filter_LH_C_0⁰ _lh_the_filter_LH_C_1⁰ => filter_lh(isdivs_lh(_lh_the_filter_LH_C_0⁰), _lh_the_filter_LH_C_1⁰)
//│ 	| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
