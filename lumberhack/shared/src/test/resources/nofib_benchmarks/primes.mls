:NewParser
:ParseOnly

// isdivs :: Int  -> Int -> Bool
// isdivs n x = mod x n /= 0

// the_filter :: [Int] -> [Int]
// the_filter (n:ns) = filter (isdivs n) ns

// prime :: Int -> Int
// prime n = map head (iterate the_filter [2..n*n]) !! n

// main = forM_ [1..100] $ const $ do
// 	[arg] <- getArgs
// 	print $ prime (read arg)


:lhInHaskell
:lhGenOCaml
isdivs n x = (x `mod` n) /= 0
the_filter (n:ns) = filter (isdivs n) ns
prime n = atIndex_lz n (map_lz head (iterate the_filter [2..(n*n)]))
testPrime_nofib n = prime n
testPrime_nofib $ primId 100
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testPrime_nofib_₀^810(primId⁰(100))
//│ def atIndex_lz_₀(n⁴, ls²¹) = if (n⁴ < 0) then error⁰ else case force⁰(ls²¹) of {
//│ 	LH_C h²² t²⁴ => if (n⁴ == 0) then h²² else atIndex_lz_₀^743((n⁴ - 1), t²⁴)
//│ 	| LH_N  => error⁰}
//│ def enumFromTo_₀(a⁵, b²) = if (a⁵ <= b²) then [LH_C a⁵ enumFromTo_₀^764((a⁵ + 1), b²)] else [LH_N]
//│ def filter_₀(f¹⁴, ls²²) = case ls²² of {
//│ 	LH_C h²³ t²⁵ => if f¹⁴(h²³) then [LH_C h²³ filter_₀^783(f¹⁴, t²⁵)] else filter_₀^789(f¹⁴, t²⁵)
//│ 	| LH_N  => [LH_N]}
//│ def head_₀(ls²⁰) = case ls²⁰ of {
//│ 	LH_C h²¹ t²³ => h²¹
//│ 	| LH_N  => error⁰}
//│ def isdivs_₀(_lh_isdivs_arg1¹, _lh_isdivs_arg2¹) = ((_lh_isdivs_arg2¹ % _lh_isdivs_arg1¹) /= 0)
//│ def iterate_₀(f¹³, x²) = lazy⁰([LH_C x² iterate_₀^708(f¹³, f¹³(x²))])
//│ def map_lz_₀(f¹², ls¹⁹) = lazy⁰(case force⁰(ls¹⁹) of {
//│ 	LH_C h²⁰ t²² => [LH_C f¹²(h²⁰) map_lz_₀^684(f¹², t²²)]
//│ 	| LH_N  => [LH_N]})
//│ def prime_₀(_lh_prime_arg1¹) = atIndex_lz_₀^655(_lh_prime_arg1¹, map_lz_₀^658(head_₀^659, iterate_₀^661(the_filter_₀^662, enumFromTo_₀^664(2, (_lh_prime_arg1¹ * _lh_prime_arg1¹)))))
//│ def testPrime_nofib_₀(_lh_testPrime_nofib_arg1¹) = prime_₀^724(_lh_testPrime_nofib_arg1¹)
//│ def the_filter_₀(_lh_the_filter_arg1¹) = case _lh_the_filter_arg1¹ of {
//│ 	LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀^696(isdivs_₀^697(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹)
//│ 	| _  => error⁰}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec atIndex_lz__d0 n_4 ls_2_1 =
//│ 		  (if (n_4 < 0) then
//│ 		    (failwith "error")
//│ 		  else
//│ 		    (match (Lazy.force ls_2_1) with
//│ 		      | `LH_C(h_2_2, t_2_4) -> 
//│ 		        (if (n_4 = 0) then
//│ 		          h_2_2
//│ 		        else
//│ 		          ((atIndex_lz__d0 (n_4 - 1)) t_2_4))
//│ 		      | `LH_N -> 
//│ 		        (failwith "error")))
//│ 		and enumFromTo__d0 a_5 b_2 =
//│ 		  (if (a_5 <= b_2) then
//│ 		    (`LH_C(a_5, ((enumFromTo__d0 (a_5 + 1)) b_2)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and filter__d0 f_1_4 ls_2_2 =
//│ 		  (match ls_2_2 with
//│ 		    | `LH_C(h_2_3, t_2_5) -> 
//│ 		      (if (f_1_4 h_2_3) then
//│ 		        (`LH_C(h_2_3, ((filter__d0 f_1_4) t_2_5)))
//│ 		      else
//│ 		        ((filter__d0 f_1_4) t_2_5))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and head__d0 ls_2_0 =
//│ 		  (match ls_2_0 with
//│ 		    | `LH_C(h_2_1, t_2_3) -> 
//│ 		      h_2_1
//│ 		    | `LH_N -> 
//│ 		      (failwith "error"))
//│ 		and isdivs__d0 _lh_isdivs_arg1_1 _lh_isdivs_arg2_1 =
//│ 		  ((_lh_isdivs_arg2_1 mod _lh_isdivs_arg1_1) <> 0)
//│ 		and iterate__d0 f_1_3 x_2 =
//│ 		  (lazy (`LH_C(x_2, ((iterate__d0 f_1_3) (f_1_3 x_2)))))
//│ 		and map_lz__d0 f_1_2 ls_1_9 =
//│ 		  (lazy (match (Lazy.force ls_1_9) with
//│ 		    | `LH_C(h_2_0, t_2_2) -> 
//│ 		      (`LH_C((f_1_2 h_2_0), ((map_lz__d0 f_1_2) t_2_2)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)))
//│ 		and prime__d0 _lh_prime_arg1_1 =
//│ 		  ((atIndex_lz__d0 _lh_prime_arg1_1) ((map_lz__d0 head__d0) ((iterate__d0 the_filter__d0) ((enumFromTo__d0 2) (_lh_prime_arg1_1 * _lh_prime_arg1_1)))))
//│ 		and testPrime_nofib__d0 _lh_testPrime_nofib_arg1_1 =
//│ 		  (prime__d0 _lh_testPrime_nofib_arg1_1)
//│ 		and the_filter__d0 _lh_the_filter_arg1_1 =
//│ 		  (match _lh_the_filter_arg1_1 with
//│ 		    | `LH_C(_lh_the_filter_LH_C_0_1, _lh_the_filter_LH_C_1_1) -> 
//│ 		      ((filter__d0 (isdivs__d0 _lh_the_filter_LH_C_0_1)) _lh_the_filter_LH_C_1_1)
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		(testPrime_nofib__d0 100)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testPrime_nofib_₀^810] (hopeless to continue)
//│ 	[testPrime_nofib_₀^810 · prime_₀^724] (using original def)
//│ 		[testPrime_nofib_₀^810 · prime_₀^724 · atIndex_lz_₀^655] (using original def)
//│ 			[testPrime_nofib_₀^810 · prime_₀^724 · atIndex_lz_₀^655 · atIndex_lz_₀^743] ---> [testPrime_nofib_₀^810 · prime_₀^724 · atIndex_lz_₀^655] (using original def)
//│ 		[testPrime_nofib_₀^810 · prime_₀^724 · enumFromTo_₀^664] (using original def)
//│ 			[testPrime_nofib_₀^810 · prime_₀^724 · enumFromTo_₀^664 · enumFromTo_₀^764] ---> [testPrime_nofib_₀^810 · prime_₀^724 · enumFromTo_₀^664] (using original def)
//│ 		[testPrime_nofib_₀^810 · prime_₀^724 · head_₀^659] (using original def)
//│ 		[testPrime_nofib_₀^810 · prime_₀^724 · iterate_₀^661] (using original def)
//│ 			[testPrime_nofib_₀^810 · prime_₀^724 · iterate_₀^661 · iterate_₀^708] ---> [testPrime_nofib_₀^810 · prime_₀^724 · iterate_₀^661] (using original def)
//│ 		[testPrime_nofib_₀^810 · prime_₀^724 · map_lz_₀^658] (using original def)
//│ 			[testPrime_nofib_₀^810 · prime_₀^724 · map_lz_₀^658 · map_lz_₀^684] ---> [testPrime_nofib_₀^810 · prime_₀^724 · map_lz_₀^658] (using original def)
//│ 		[testPrime_nofib_₀^810 · prime_₀^724 · the_filter_₀^662] (using original def)
//│ 			[testPrime_nofib_₀^810 · prime_₀^724 · the_filter_₀^662 · filter_₀^696] (using original def)
//│ 				[testPrime_nofib_₀^810 · prime_₀^724 · the_filter_₀^662 · filter_₀^696 · filter_₀^783] ---> [testPrime_nofib_₀^810 · prime_₀^724 · the_filter_₀^662 · filter_₀^696] (using original def)
//│ 				[testPrime_nofib_₀^810 · prime_₀^724 · the_filter_₀^662 · filter_₀^696 · filter_₀^789] ---> [testPrime_nofib_₀^810 · prime_₀^724 · the_filter_₀^662 · filter_₀^696] (using original def)
//│ 			[testPrime_nofib_₀^810 · prime_₀^724 · the_filter_₀^662 · isdivs_₀^697] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testPrime_nofib_₀_₀(primId⁰(100))
//│ def testPrime_nofib_₀_₀(_lh_testPrime_nofib_arg1¹) = 
//│ 	prime_₀_₀(_lh_testPrime_nofib_arg1¹)
//│ 	where
//│ 	def prime_₀_₀(_lh_prime_arg1¹) = 
//│ 		atIndex_lz_₀_₀(_lh_prime_arg1¹, map_lz_₀_₀(head_₀_₀, iterate_₀_₀(the_filter_₀_₀, enumFromTo_₀_₀(2, (_lh_prime_arg1¹ * _lh_prime_arg1¹)))))
//│ 		where
//│ 		def atIndex_lz_₀_₀(n¹, ls⁶) = 
//│ 			if (n¹ < 0) then error⁰ else case force⁰(ls⁶) of {
//│ 				LH_C h⁶ t⁶ => if (n¹ == 0) then h⁶ else atIndex_lz_₀_₀((n¹ - 1), t⁶)
//│ 				| LH_N  => error⁰}
//│ 		def enumFromTo_₀_₀(a¹, b¹) = 
//│ 			if (a¹ <= b¹) then [LH_C a¹ enumFromTo_₀_₀((a¹ + 1), b¹)] else [LH_N]
//│ 		def head_₀_₀(ls⁵) = 
//│ 			case ls⁵ of {
//│ 				LH_C h⁵ t⁵ => h⁵
//│ 				| LH_N  => error⁰}
//│ 		def iterate_₀_₀(f⁴, x¹) = 
//│ 			lazy⁰([LH_C x¹ iterate_₀_₀(f⁴, f⁴(x¹))])
//│ 		def map_lz_₀_₀(f⁵, ls⁷) = 
//│ 			lazy⁰(case force⁰(ls⁷) of {
//│ 				LH_C h⁷ t⁷ => [LH_C f⁵(h⁷) map_lz_₀_₀(f⁵, t⁷)]
//│ 				| LH_N  => [LH_N]})
//│ 		def the_filter_₀_₀(_lh_the_filter_arg1¹) = 
//│ 			case _lh_the_filter_arg1¹ of {
//│ 				LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀_₀(isdivs_₀_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹)
//│ 				| _  => error⁰}
//│ 			where
//│ 			def filter_₀_₀(f³, ls⁴) = 
//│ 				case ls⁴ of {
//│ 					LH_C h⁴ t⁴ => if f³(h⁴) then [LH_C h⁴ filter_₀_₀(f³, t⁴)] else filter_₀_₀(f³, t⁴)
//│ 					| LH_N  => [LH_N]}
//│ 			def isdivs_₀_₀(_lh_isdivs_arg1¹, _lh_isdivs_arg2¹) = 
//│ 				((_lh_isdivs_arg2¹ % _lh_isdivs_arg1¹) /= 0)
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h⁴ filter_₀_₀(f³, t⁴)]: 171 --->
//│ 	DeadCodeCons
//│ 	case ls⁴ of {LH_C h⁴ t⁴ => if f³(h⁴) then [LH_C h⁴ filter_₀_₀(f³, t⁴)] else filter_₀_₀(f³, t⁴) | LH_N  => [LH_N]}: 179
//│ 	case ls⁵ of {LH_C h⁵ t⁵ => h⁵ | LH_N  => error⁰}: 198
//│ 	case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀_₀(isdivs_₀_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 213
//│ [LH_N]: 178 --->
//│ 	DeadCodeCons
//│ 	case ls⁴ of {LH_C h⁴ t⁴ => if f³(h⁴) then [LH_C h⁴ filter_₀_₀(f³, t⁴)] else filter_₀_₀(f³, t⁴) | LH_N  => [LH_N]}: 179
//│ 	case ls⁵ of {LH_C h⁵ t⁵ => h⁵ | LH_N  => error⁰}: 198
//│ 	case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀_₀(isdivs_₀_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 213
//│ [LH_C x¹ iterate_₀_₀(f⁴, f⁴(x¹))]: 191 --->
//│ 	case force⁰(ls⁷) of {LH_C h⁷ t⁷ => [LH_C f⁵(h⁷) map_lz_₀_₀(f⁵, t⁷)] | LH_N  => [LH_N]}: 312
//│ [LH_C a¹ enumFromTo_₀_₀((a¹ + 1), b¹)]: 293 --->
//│ 	DeadCodeCons
//│ 	case ls⁴ of {LH_C h⁴ t⁴ => if f³(h⁴) then [LH_C h⁴ filter_₀_₀(f³, t⁴)] else filter_₀_₀(f³, t⁴) | LH_N  => [LH_N]}: 179
//│ 	case ls⁵ of {LH_C h⁵ t⁵ => h⁵ | LH_N  => error⁰}: 198
//│ 	case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀_₀(isdivs_₀_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 213
//│ [LH_N]: 294 --->
//│ 	DeadCodeCons
//│ 	case ls⁴ of {LH_C h⁴ t⁴ => if f³(h⁴) then [LH_C h⁴ filter_₀_₀(f³, t⁴)] else filter_₀_₀(f³, t⁴) | LH_N  => [LH_N]}: 179
//│ 	case ls⁵ of {LH_C h⁵ t⁵ => h⁵ | LH_N  => error⁰}: 198
//│ 	case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀_₀(isdivs_₀_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 213
//│ [LH_C f⁵(h⁷) map_lz_₀_₀(f⁵, t⁷)]: 310 --->
//│ 	case force⁰(ls⁶) of {LH_C h⁶ t⁶ => if (n¹ == 0) then h⁶ else atIndex_lz_₀_₀((n¹ - 1), t⁶) | LH_N  => error⁰}: 252
//│ [LH_N]: 311 --->
//│ 	case force⁰(ls⁶) of {LH_C h⁶ t⁶ => if (n¹ == 0) then h⁶ else atIndex_lz_₀_₀((n¹ - 1), t⁶) | LH_N  => error⁰}: 252
//│ ------------------
//│ case ls⁴ of {LH_C h⁴ t⁴ => if f³(h⁴) then [LH_C h⁴ filter_₀_₀(f³, t⁴)] else filter_₀_₀(f³, t⁴) | LH_N  => [LH_N]}: 179 --->
//│ 	[LH_C h⁴ filter_₀_₀(f³, t⁴)]: 171
//│ 	[LH_N]: 178
//│ 	[LH_C a¹ enumFromTo_₀_₀((a¹ + 1), b¹)]: 293
//│ 	[LH_N]: 294
//│ case ls⁵ of {LH_C h⁵ t⁵ => h⁵ | LH_N  => error⁰}: 198 --->
//│ 	[LH_C h⁴ filter_₀_₀(f³, t⁴)]: 171
//│ 	[LH_N]: 178
//│ 	[LH_C a¹ enumFromTo_₀_₀((a¹ + 1), b¹)]: 293
//│ 	[LH_N]: 294
//│ case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀_₀(isdivs_₀_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 213 --->
//│ 	[LH_C h⁴ filter_₀_₀(f³, t⁴)]: 171
//│ 	[LH_N]: 178
//│ 	[LH_C a¹ enumFromTo_₀_₀((a¹ + 1), b¹)]: 293
//│ 	[LH_N]: 294
//│ case force⁰(ls⁶) of {LH_C h⁶ t⁶ => if (n¹ == 0) then h⁶ else atIndex_lz_₀_₀((n¹ - 1), t⁶) | LH_N  => error⁰}: 252 --->
//│ 	[LH_C f⁵(h⁷) map_lz_₀_₀(f⁵, t⁷)]: 310
//│ 	[LH_N]: 311
//│ case force⁰(ls⁷) of {LH_C h⁷ t⁷ => [LH_C f⁵(h⁷) map_lz_₀_₀(f⁵, t⁷)] | LH_N  => [LH_N]}: 312 --->
//│ 	[LH_C x¹ iterate_₀_₀(f⁴, f⁴(x¹))]: 191
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C x¹ iterate_₀_₀(f⁴, f⁴(x¹))]: 191 --->
//│ 	case force⁰(ls⁷) of {LH_C h⁷ t⁷ => [LH_C f⁵(h⁷) map_lz_₀_₀(f⁵, t⁷)] | LH_N  => [LH_N]}: 312
//│ [LH_C f⁵(h⁷) map_lz_₀_₀(f⁵, t⁷)]: 310 --->
//│ 	case force⁰(ls⁶) of {LH_C h⁶ t⁶ => if (n¹ == 0) then h⁶ else atIndex_lz_₀_₀((n¹ - 1), t⁶) | LH_N  => error⁰}: 252
//│ [LH_N]: 311 --->
//│ 	case force⁰(ls⁶) of {LH_C h⁶ t⁶ => if (n¹ == 0) then h⁶ else atIndex_lz_₀_₀((n¹ - 1), t⁶) | LH_N  => error⁰}: 252
//│ ------------------
//│ case force⁰(ls⁶) of {LH_C h⁶ t⁶ => if (n¹ == 0) then h⁶ else atIndex_lz_₀_₀((n¹ - 1), t⁶) | LH_N  => error⁰}: 252 --->
//│ 	[LH_C f⁵(h⁷) map_lz_₀_₀(f⁵, t⁷)]: 310
//│ 	[LH_N]: 311
//│ case force⁰(ls⁷) of {LH_C h⁷ t⁷ => [LH_C f⁵(h⁷) map_lz_₀_₀(f⁵, t⁷)] | LH_N  => [LH_N]}: 312 --->
//│ 	[LH_C x¹ iterate_₀_₀(f⁴, f⁴(x¹))]: 191
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testPrime_nofib_₀_₀(primId⁰(100))
//│ def testPrime_nofib_₀_₀(_lh_testPrime_nofib_arg1²) = 
//│ 	prime_₀_₀(_lh_testPrime_nofib_arg1²)
//│ 	where
//│ 	def prime_₀_₀(_lh_prime_arg1²) = 
//│ 		atIndex_lz_₀_₀(_lh_prime_arg1², map_lz_₀_₀(head_₀_₀, iterate_₀_₀(the_filter_₀_₀, enumFromTo_₀_₀(2, (_lh_prime_arg1² * _lh_prime_arg1²)))))
//│ 		where
//│ 		def atIndex_lz_₀_₀(n³, ls¹⁰) = 
//│ 			if (n³ < 0) then error⁰ else force⁰(ls¹⁰, n³)
//│ 		def enumFromTo_₀_₀(a², b²) = 
//│ 			if (a² <= b²) then [LH_C a² enumFromTo_₀_₀((a² + 1), b²)] else [LH_N]
//│ 		def head_₀_₀(ls⁹) = 
//│ 			case ls⁹ of {
//│ 				LH_C h⁵ t⁵ => h⁵
//│ 				| LH_N  => error⁰}
//│ 		def iterate_₀_₀(f⁷, x²) = 
//│ 			lazy⁰(
//│ 				let t⁸ = iterate_₀_₀(f⁷, f⁷(x²))
//│ 				in let h⁸ = x²
//│ 				in (fun f⁸ -> 
//│ 					let t⁹ = map_lz_₀_₀(f⁸, t⁸)
//│ 					in let h⁹ = f⁸(h⁸)
//│ 					in (fun n² -> if (n² == 0) then h⁹ else atIndex_lz_₀_₀((n² - 1), t⁹))))
//│ 		def map_lz_₀_₀(f⁹, ls¹¹) = 
//│ 			lazy⁰(force⁰(ls¹¹, f⁹))
//│ 		def the_filter_₀_₀(_lh_the_filter_arg1²) = 
//│ 			case _lh_the_filter_arg1² of {
//│ 				LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀_₀(isdivs_₀_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹)
//│ 				| _  => error⁰}
//│ 			where
//│ 			def filter_₀_₀(f⁶, ls⁸) = 
//│ 				case ls⁸ of {
//│ 					LH_C h⁴ t⁴ => if f⁶(h⁴) then [LH_C h⁴ filter_₀_₀(f⁶, t⁴)] else filter_₀_₀(f⁶, t⁴)
//│ 					| LH_N  => [LH_N]}
//│ 			def isdivs_₀_₀(_lh_isdivs_arg1², _lh_isdivs_arg2²) = 
//│ 				((_lh_isdivs_arg2² % _lh_isdivs_arg1²) /= 0)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
