:NewParser
:ParseOnly

// isdivs :: Int  -> Int -> Bool
// isdivs n x = mod x n /= 0

// the_filter :: [Int] -> [Int]
// the_filter (n:ns) = filter (isdivs n) ns

// prime :: Int -> Int
// prime n = map head (iterate the_filter [2..n*n]) !! n

// main = forM_ [1..100] $ const $ do
// 	[arg] <- getArgs
// 	print $ prime (read arg)


:lhInHaskell
:lhGenOCaml
isdivs n x = (x `mod` n) /= 0
the_filter (n:ns) = filter (isdivs n) ns
prime n = atIndex_lz n (map_lz head (iterate the_filter [2..(n*n)]))
testPrime_nofib n = prime n
testPrime_nofib $ primId 100
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testPrime_nofib_₀^810(primId⁰(100))
//│ def atIndex_lz_₀(n⁴, ls²¹) = if (n⁴ < 0) then error⁰ else case force⁰(ls²¹) of {
//│ 	LH_C h²² t²⁴ => if (n⁴ == 0) then h²² else atIndex_lz_₀^743((n⁴ - 1), t²⁴)
//│ 	| LH_N  => error⁰}
//│ def enumFromTo_₀(a⁵, b²) = if (a⁵ <= b²) then [LH_C a⁵ enumFromTo_₀^764((a⁵ + 1), b²)] else [LH_N]
//│ def filter_₀(f¹⁴, ls²²) = case ls²² of {
//│ 	LH_C h²³ t²⁵ => if f¹⁴(h²³) then [LH_C h²³ filter_₀^783(f¹⁴, t²⁵)] else filter_₀^789(f¹⁴, t²⁵)
//│ 	| LH_N  => [LH_N]}
//│ def head_₀(ls²⁰) = case ls²⁰ of {
//│ 	LH_C h²¹ t²³ => h²¹
//│ 	| LH_N  => error⁰}
//│ def isdivs_₀(_lh_isdivs_arg1¹, _lh_isdivs_arg2¹) = ((_lh_isdivs_arg2¹ % _lh_isdivs_arg1¹) /= 0)
//│ def iterate_₀(f¹³, x²) = lazy⁰([LH_C x² iterate_₀^708(f¹³, f¹³(x²))])
//│ def map_lz_₀(f¹², ls¹⁹) = lazy⁰(case force⁰(ls¹⁹) of {
//│ 	LH_C h²⁰ t²² => [LH_C f¹²(h²⁰) map_lz_₀^684(f¹², t²²)]
//│ 	| LH_N  => [LH_N]})
//│ def prime_₀(_lh_prime_arg1¹) = atIndex_lz_₀^655(_lh_prime_arg1¹, map_lz_₀^658(head_₀^659, iterate_₀^661(the_filter_₀^662, enumFromTo_₀^664(2, (_lh_prime_arg1¹ * _lh_prime_arg1¹)))))
//│ def testPrime_nofib_₀(_lh_testPrime_nofib_arg1¹) = prime_₀^724(_lh_testPrime_nofib_arg1¹)
//│ def the_filter_₀(_lh_the_filter_arg1¹) = case _lh_the_filter_arg1¹ of {
//│ 	LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀^696(isdivs_₀^697(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹)
//│ 	| _  => error⁰}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec atIndex_lz__d0 n_4 ls_2_1 =
//│ 		  (if (n_4 < 0) then
//│ 		    (failwith "error")
//│ 		  else
//│ 		    (match (Lazy.force ls_2_1) with
//│ 		      | `LH_C(h_2_2, t_2_4) -> 
//│ 		        (if (n_4 = 0) then
//│ 		          h_2_2
//│ 		        else
//│ 		          ((atIndex_lz__d0 (n_4 - 1)) t_2_4))
//│ 		      | `LH_N -> 
//│ 		        (failwith "error")))
//│ 		and enumFromTo__d0 a_5 b_2 =
//│ 		  (if (a_5 <= b_2) then
//│ 		    (`LH_C(a_5, ((enumFromTo__d0 (a_5 + 1)) b_2)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and filter__d0 f_1_4 ls_2_2 =
//│ 		  (match ls_2_2 with
//│ 		    | `LH_C(h_2_3, t_2_5) -> 
//│ 		      (if (f_1_4 h_2_3) then
//│ 		        (`LH_C(h_2_3, ((filter__d0 f_1_4) t_2_5)))
//│ 		      else
//│ 		        ((filter__d0 f_1_4) t_2_5))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and head__d0 ls_2_0 =
//│ 		  (match ls_2_0 with
//│ 		    | `LH_C(h_2_1, t_2_3) -> 
//│ 		      h_2_1
//│ 		    | `LH_N -> 
//│ 		      (failwith "error"))
//│ 		and isdivs__d0 _lh_isdivs_arg1_1 _lh_isdivs_arg2_1 =
//│ 		  ((_lh_isdivs_arg2_1 mod _lh_isdivs_arg1_1) <> 0)
//│ 		and iterate__d0 f_1_3 x_2 =
//│ 		  (lazy (`LH_C(x_2, ((iterate__d0 f_1_3) (f_1_3 x_2)))))
//│ 		and map_lz__d0 f_1_2 ls_1_9 =
//│ 		  (lazy (match (Lazy.force ls_1_9) with
//│ 		    | `LH_C(h_2_0, t_2_2) -> 
//│ 		      (`LH_C((f_1_2 h_2_0), ((map_lz__d0 f_1_2) t_2_2)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)))
//│ 		and prime__d0 _lh_prime_arg1_1 =
//│ 		  ((atIndex_lz__d0 _lh_prime_arg1_1) ((map_lz__d0 head__d0) ((iterate__d0 the_filter__d0) ((enumFromTo__d0 2) (_lh_prime_arg1_1 * _lh_prime_arg1_1)))))
//│ 		and testPrime_nofib__d0 _lh_testPrime_nofib_arg1_1 =
//│ 		  (prime__d0 _lh_testPrime_nofib_arg1_1)
//│ 		and the_filter__d0 _lh_the_filter_arg1_1 =
//│ 		  (match _lh_the_filter_arg1_1 with
//│ 		    | `LH_C(_lh_the_filter_LH_C_0_1, _lh_the_filter_LH_C_1_1) -> 
//│ 		      ((filter__d0 (isdivs__d0 _lh_the_filter_LH_C_0_1)) _lh_the_filter_LH_C_1_1)
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		(testPrime_nofib__d0 100)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f¹²(h²⁰) map_lz_₀(f¹², t²²)]: 689 --->
//│ 	case force⁰(ls²¹) of {LH_C h²² t²⁴ => if (n⁴ == 0) then h²² else atIndex_lz_₀((n⁴ - 1), t²⁴) | LH_N  => error⁰}: 754
//│ [LH_N]: 690 --->
//│ 	case force⁰(ls²¹) of {LH_C h²² t²⁴ => if (n⁴ == 0) then h²² else atIndex_lz_₀((n⁴ - 1), t²⁴) | LH_N  => error⁰}: 754
//│ [LH_C x² iterate_₀(f¹³, f¹³(x²))]: 715 --->
//│ 	case force⁰(ls¹⁹) of {LH_C h²⁰ t²² => [LH_C f¹²(h²⁰) map_lz_₀(f¹², t²²)] | LH_N  => [LH_N]}: 691
//│ [LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 773 --->
//│ 	DeadCodeCons
//│ 	case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀(isdivs_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 704
//│ 	case ls²⁰ of {LH_C h²¹ t²³ => h²¹ | LH_N  => error⁰}: 722
//│ 	case ls²² of {LH_C h²³ t²⁵ => if f¹⁴(h²³) then [LH_C h²³ filter_₀(f¹⁴, t²⁵)] else filter_₀(f¹⁴, t²⁵) | LH_N  => [LH_N]}: 796
//│ [LH_N]: 774 --->
//│ 	DeadCodeCons
//│ 	case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀(isdivs_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 704
//│ 	case ls²⁰ of {LH_C h²¹ t²³ => h²¹ | LH_N  => error⁰}: 722
//│ 	case ls²² of {LH_C h²³ t²⁵ => if f¹⁴(h²³) then [LH_C h²³ filter_₀(f¹⁴, t²⁵)] else filter_₀(f¹⁴, t²⁵) | LH_N  => [LH_N]}: 796
//│ [LH_C h²³ filter_₀(f¹⁴, t²⁵)]: 788 --->
//│ 	DeadCodeCons
//│ 	case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀(isdivs_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 704
//│ 	case ls²⁰ of {LH_C h²¹ t²³ => h²¹ | LH_N  => error⁰}: 722
//│ 	case ls²² of {LH_C h²³ t²⁵ => if f¹⁴(h²³) then [LH_C h²³ filter_₀(f¹⁴, t²⁵)] else filter_₀(f¹⁴, t²⁵) | LH_N  => [LH_N]}: 796
//│ [LH_N]: 795 --->
//│ 	DeadCodeCons
//│ 	case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀(isdivs_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 704
//│ 	case ls²⁰ of {LH_C h²¹ t²³ => h²¹ | LH_N  => error⁰}: 722
//│ 	case ls²² of {LH_C h²³ t²⁵ => if f¹⁴(h²³) then [LH_C h²³ filter_₀(f¹⁴, t²⁵)] else filter_₀(f¹⁴, t²⁵) | LH_N  => [LH_N]}: 796
//│ ------------------
//│ case force⁰(ls¹⁹) of {LH_C h²⁰ t²² => [LH_C f¹²(h²⁰) map_lz_₀(f¹², t²²)] | LH_N  => [LH_N]}: 691 --->
//│ 	[LH_C x² iterate_₀(f¹³, f¹³(x²))]: 715
//│ case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀(isdivs_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 704 --->
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 773
//│ 	[LH_N]: 774
//│ 	[LH_C h²³ filter_₀(f¹⁴, t²⁵)]: 788
//│ 	[LH_N]: 795
//│ case ls²⁰ of {LH_C h²¹ t²³ => h²¹ | LH_N  => error⁰}: 722 --->
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 773
//│ 	[LH_N]: 774
//│ 	[LH_C h²³ filter_₀(f¹⁴, t²⁵)]: 788
//│ 	[LH_N]: 795
//│ case force⁰(ls²¹) of {LH_C h²² t²⁴ => if (n⁴ == 0) then h²² else atIndex_lz_₀((n⁴ - 1), t²⁴) | LH_N  => error⁰}: 754 --->
//│ 	[LH_C f¹²(h²⁰) map_lz_₀(f¹², t²²)]: 689
//│ 	[LH_N]: 690
//│ case ls²² of {LH_C h²³ t²⁵ => if f¹⁴(h²³) then [LH_C h²³ filter_₀(f¹⁴, t²⁵)] else filter_₀(f¹⁴, t²⁵) | LH_N  => [LH_N]}: 796 --->
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 773
//│ 	[LH_N]: 774
//│ 	[LH_C h²³ filter_₀(f¹⁴, t²⁵)]: 788
//│ 	[LH_N]: 795
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f¹²(h²⁰) map_lz_₀(f¹², t²²)]: 689 --->
//│ 	case force⁰(ls²¹) of {LH_C h²² t²⁴ => if (n⁴ == 0) then h²² else atIndex_lz_₀((n⁴ - 1), t²⁴) | LH_N  => error⁰}: 754
//│ [LH_N]: 690 --->
//│ 	case force⁰(ls²¹) of {LH_C h²² t²⁴ => if (n⁴ == 0) then h²² else atIndex_lz_₀((n⁴ - 1), t²⁴) | LH_N  => error⁰}: 754
//│ [LH_C x² iterate_₀(f¹³, f¹³(x²))]: 715 --->
//│ 	case force⁰(ls¹⁹) of {LH_C h²⁰ t²² => [LH_C f¹²(h²⁰) map_lz_₀(f¹², t²²)] | LH_N  => [LH_N]}: 691
//│ ------------------
//│ case force⁰(ls¹⁹) of {LH_C h²⁰ t²² => [LH_C f¹²(h²⁰) map_lz_₀(f¹², t²²)] | LH_N  => [LH_N]}: 691 --->
//│ 	[LH_C x² iterate_₀(f¹³, f¹³(x²))]: 715
//│ case force⁰(ls²¹) of {LH_C h²² t²⁴ => if (n⁴ == 0) then h²² else atIndex_lz_₀((n⁴ - 1), t²⁴) | LH_N  => error⁰}: 754 --->
//│ 	[LH_C f¹²(h²⁰) map_lz_₀(f¹², t²²)]: 689
//│ 	[LH_N]: 690
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testPrime_nofib_₀(primId⁰(100))
//│ def atIndex_lz_₀(n⁶, ls²⁶) = if (n⁶ < 0) then error⁰ else force⁰(ls²⁶, n⁶)
//│ def enumFromTo_₀(a⁶, b³) = if (a⁶ <= b³) then [LH_C a⁶ enumFromTo_₀((a⁶ + 1), b³)] else [LH_N]
//│ def filter_₀(f¹⁵, ls²⁴) = case ls²⁴ of {
//│ 	LH_C h²³ t²⁵ => if f¹⁵(h²³) then [LH_C h²³ filter_₀(f¹⁵, t²⁵)] else filter_₀(f¹⁵, t²⁵)
//│ 	| LH_N  => [LH_N]}
//│ def head_₀(ls²³) = case ls²³ of {
//│ 	LH_C h²¹ t²³ => h²¹
//│ 	| LH_N  => error⁰}
//│ def isdivs_₀(_lh_isdivs_arg1², _lh_isdivs_arg2²) = ((_lh_isdivs_arg2² % _lh_isdivs_arg1²) /= 0)
//│ def iterate_₀(f¹⁶, x³) = lazy⁰(
//│ 	let t²⁶ = iterate_₀(f¹⁶, f¹⁶(x³))
//│ 	in let h²⁴ = x³
//│ 	in (fun f¹⁷ -> 
//│ 		let t²⁷ = map_lz_₀(f¹⁷, t²⁶)
//│ 		in let h²⁵ = f¹⁷(h²⁴)
//│ 		in (fun n⁵ -> if (n⁵ == 0) then h²⁵ else atIndex_lz_₀((n⁵ - 1), t²⁷))))
//│ def map_lz_₀(f¹⁸, ls²⁵) = lazy⁰(force⁰(ls²⁵, f¹⁸))
//│ def prime_₀(_lh_prime_arg1²) = atIndex_lz_₀(_lh_prime_arg1², map_lz_₀(head_₀, iterate_₀(the_filter_₀, enumFromTo_₀(2, (_lh_prime_arg1² * _lh_prime_arg1²)))))
//│ def testPrime_nofib_₀(_lh_testPrime_nofib_arg1²) = prime_₀(_lh_testPrime_nofib_arg1²)
//│ def the_filter_₀(_lh_the_filter_arg1²) = case _lh_the_filter_arg1² of {
//│ 	LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀(isdivs_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹)
//│ 	| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
