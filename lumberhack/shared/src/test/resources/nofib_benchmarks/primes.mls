:NewParser
:ParseOnly

// isdivs :: Int  -> Int -> Bool
// isdivs n x = mod x n /= 0

// the_filter :: [Int] -> [Int]
// the_filter (n:ns) = filter (isdivs n) ns

// prime :: Int -> Int
// prime n = map head (iterate the_filter [2..n*n]) !! n

// main = forM_ [1..100] $ const $ do
// 	[arg] <- getArgs
// 	print $ prime (read arg)


:lhInHaskell
:lhGenOCaml
isdivs n x = (x `mod` n) /= 0
the_filter (n:ns) = filter (isdivs n) ns
prime n = atIndex_lz n (map_lz head (iterate the_filter [2..(n*n)]))
testPrime_nofib n = prime n
testPrime_nofib $ primId 100
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testPrime_nofib_₀^812(primId⁰(100))
//│ def atIndex_lz_₀(n⁴, ls²²) = if (n⁴ < 0) then error⁰ else case force⁰(ls²²) of {
//│ 	LH_C h²³ t²⁵ => if (n⁴ == 0) then h²³ else atIndex_lz_₀^782((n⁴ - 1), t²⁵)
//│ 	| LH_N  => error⁰}
//│ def enumFromTo_₀(a⁵, b²) = if (a⁵ <= b²) then [LH_C a⁵ enumFromTo_₀^731((a⁵ + 1), b²)] else [LH_N]
//│ def filter_₀(f¹², ls¹⁹) = case ls¹⁹ of {
//│ 	LH_C h²⁰ t²² => if f¹²(h²⁰) then [LH_C h²⁰ filter_₀^662(f¹², t²²)] else filter_₀^668(f¹², t²²)
//│ 	| LH_N  => [LH_N]}
//│ def head_₀(ls²¹) = case ls²¹ of {
//│ 	LH_C h²² t²⁴ => h²²
//│ 	| LH_N  => error⁰}
//│ def isdivs_₀(_lh_isdivs_arg1¹, _lh_isdivs_arg2¹) = ((_lh_isdivs_arg2¹ % _lh_isdivs_arg1¹) /= 0)
//│ def iterate_₀(f¹³, x²) = lazy⁰([LH_C x² iterate_₀^680(f¹³, f¹³(x²))])
//│ def map_lz_₀(f¹⁴, ls²⁰) = lazy⁰(case force⁰(ls²⁰) of {
//│ 	LH_C h²¹ t²³ => [LH_C f¹⁴(h²¹) map_lz_₀^698(f¹⁴, t²³)]
//│ 	| LH_N  => [LH_N]})
//│ def prime_₀(_lh_prime_arg1¹) = atIndex_lz_₀^745(_lh_prime_arg1¹, map_lz_₀^748(head_₀^749, iterate_₀^751(the_filter_₀^752, enumFromTo_₀^754(2, (_lh_prime_arg1¹ * _lh_prime_arg1¹)))))
//│ def testPrime_nofib_₀(_lh_testPrime_nofib_arg1¹) = prime_₀^797(_lh_testPrime_nofib_arg1¹)
//│ def the_filter_₀(_lh_the_filter_arg1¹) = case _lh_the_filter_arg1¹ of {
//│ 	LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀^802(isdivs_₀^803(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹)
//│ 	| _  => error⁰}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec atIndex_lz__d0 n_4 ls_2_2 =
//│ 		  (if (n_4 < 0) then
//│ 		    (failwith "error")
//│ 		  else
//│ 		    (match (Lazy.force ls_2_2) with
//│ 		      | `LH_C(h_2_3, t_2_5) -> 
//│ 		        (if (n_4 = 0) then
//│ 		          h_2_3
//│ 		        else
//│ 		          ((atIndex_lz__d0 (n_4 - 1)) t_2_5))
//│ 		      | `LH_N -> 
//│ 		        (failwith "error")))
//│ 		and enumFromTo__d0 a_5 b_2 =
//│ 		  (if (a_5 <= b_2) then
//│ 		    (`LH_C(a_5, ((enumFromTo__d0 (a_5 + 1)) b_2)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and filter__d0 f_1_2 ls_1_9 =
//│ 		  (match ls_1_9 with
//│ 		    | `LH_C(h_2_0, t_2_2) -> 
//│ 		      (if (f_1_2 h_2_0) then
//│ 		        (`LH_C(h_2_0, ((filter__d0 f_1_2) t_2_2)))
//│ 		      else
//│ 		        ((filter__d0 f_1_2) t_2_2))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and head__d0 ls_2_1 =
//│ 		  (match ls_2_1 with
//│ 		    | `LH_C(h_2_2, t_2_4) -> 
//│ 		      h_2_2
//│ 		    | `LH_N -> 
//│ 		      (failwith "error"))
//│ 		and isdivs__d0 _lh_isdivs_arg1_1 _lh_isdivs_arg2_1 =
//│ 		  ((_lh_isdivs_arg2_1 mod _lh_isdivs_arg1_1) <> 0)
//│ 		and iterate__d0 f_1_3 x_2 =
//│ 		  (lazy (`LH_C(x_2, ((iterate__d0 f_1_3) (f_1_3 x_2)))))
//│ 		and map_lz__d0 f_1_4 ls_2_0 =
//│ 		  (lazy (match (Lazy.force ls_2_0) with
//│ 		    | `LH_C(h_2_1, t_2_3) -> 
//│ 		      (`LH_C((f_1_4 h_2_1), ((map_lz__d0 f_1_4) t_2_3)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)))
//│ 		and prime__d0 _lh_prime_arg1_1 =
//│ 		  ((atIndex_lz__d0 _lh_prime_arg1_1) ((map_lz__d0 head__d0) ((iterate__d0 the_filter__d0) ((enumFromTo__d0 2) (_lh_prime_arg1_1 * _lh_prime_arg1_1)))))
//│ 		and testPrime_nofib__d0 _lh_testPrime_nofib_arg1_1 =
//│ 		  (prime__d0 _lh_testPrime_nofib_arg1_1)
//│ 		and the_filter__d0 _lh_the_filter_arg1_1 =
//│ 		  (match _lh_the_filter_arg1_1 with
//│ 		    | `LH_C(_lh_the_filter_LH_C_0_1, _lh_the_filter_LH_C_1_1) -> 
//│ 		      ((filter__d0 (isdivs__d0 _lh_the_filter_LH_C_0_1)) _lh_the_filter_LH_C_1_1)
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		(testPrime_nofib__d0 100)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h²⁰ filter_₀(f¹², t²²)]: 667 --->
//│ 	DeadCodeCons
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => if f¹²(h²⁰) then [LH_C h²⁰ filter_₀(f¹², t²²)] else filter_₀(f¹², t²²) | LH_N  => [LH_N]}: 675
//│ 	case ls²¹ of {LH_C h²² t²⁴ => h²² | LH_N  => error⁰}: 712
//│ 	case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀(isdivs_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 810
//│ [LH_N]: 674 --->
//│ 	DeadCodeCons
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => if f¹²(h²⁰) then [LH_C h²⁰ filter_₀(f¹², t²²)] else filter_₀(f¹², t²²) | LH_N  => [LH_N]}: 675
//│ 	case ls²¹ of {LH_C h²² t²⁴ => h²² | LH_N  => error⁰}: 712
//│ 	case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀(isdivs_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 810
//│ [LH_C x² iterate_₀(f¹³, f¹³(x²))]: 687 --->
//│ 	case force⁰(ls²⁰) of {LH_C h²¹ t²³ => [LH_C f¹⁴(h²¹) map_lz_₀(f¹⁴, t²³)] | LH_N  => [LH_N]}: 705
//│ [LH_C f¹⁴(h²¹) map_lz_₀(f¹⁴, t²³)]: 703 --->
//│ 	case force⁰(ls²²) of {LH_C h²³ t²⁵ => if (n⁴ == 0) then h²³ else atIndex_lz_₀((n⁴ - 1), t²⁵) | LH_N  => error⁰}: 793
//│ [LH_N]: 704 --->
//│ 	case force⁰(ls²²) of {LH_C h²³ t²⁵ => if (n⁴ == 0) then h²³ else atIndex_lz_₀((n⁴ - 1), t²⁵) | LH_N  => error⁰}: 793
//│ [LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 740 --->
//│ 	DeadCodeCons
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => if f¹²(h²⁰) then [LH_C h²⁰ filter_₀(f¹², t²²)] else filter_₀(f¹², t²²) | LH_N  => [LH_N]}: 675
//│ 	case ls²¹ of {LH_C h²² t²⁴ => h²² | LH_N  => error⁰}: 712
//│ 	case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀(isdivs_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 810
//│ [LH_N]: 741 --->
//│ 	DeadCodeCons
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => if f¹²(h²⁰) then [LH_C h²⁰ filter_₀(f¹², t²²)] else filter_₀(f¹², t²²) | LH_N  => [LH_N]}: 675
//│ 	case ls²¹ of {LH_C h²² t²⁴ => h²² | LH_N  => error⁰}: 712
//│ 	case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀(isdivs_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 810
//│ ------------------
//│ case ls¹⁹ of {LH_C h²⁰ t²² => if f¹²(h²⁰) then [LH_C h²⁰ filter_₀(f¹², t²²)] else filter_₀(f¹², t²²) | LH_N  => [LH_N]}: 675 --->
//│ 	[LH_C h²⁰ filter_₀(f¹², t²²)]: 667
//│ 	[LH_N]: 674
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 740
//│ 	[LH_N]: 741
//│ case force⁰(ls²⁰) of {LH_C h²¹ t²³ => [LH_C f¹⁴(h²¹) map_lz_₀(f¹⁴, t²³)] | LH_N  => [LH_N]}: 705 --->
//│ 	[LH_C x² iterate_₀(f¹³, f¹³(x²))]: 687
//│ case ls²¹ of {LH_C h²² t²⁴ => h²² | LH_N  => error⁰}: 712 --->
//│ 	[LH_C h²⁰ filter_₀(f¹², t²²)]: 667
//│ 	[LH_N]: 674
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 740
//│ 	[LH_N]: 741
//│ case force⁰(ls²²) of {LH_C h²³ t²⁵ => if (n⁴ == 0) then h²³ else atIndex_lz_₀((n⁴ - 1), t²⁵) | LH_N  => error⁰}: 793 --->
//│ 	[LH_C f¹⁴(h²¹) map_lz_₀(f¹⁴, t²³)]: 703
//│ 	[LH_N]: 704
//│ case _lh_the_filter_arg1¹ of {LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀(isdivs_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹) | _  => error⁰}: 810 --->
//│ 	[LH_C h²⁰ filter_₀(f¹², t²²)]: 667
//│ 	[LH_N]: 674
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 740
//│ 	[LH_N]: 741
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C x² iterate_₀(f¹³, f¹³(x²))]: 687 --->
//│ 	case force⁰(ls²⁰) of {LH_C h²¹ t²³ => [LH_C f¹⁴(h²¹) map_lz_₀(f¹⁴, t²³)] | LH_N  => [LH_N]}: 705
//│ [LH_C f¹⁴(h²¹) map_lz_₀(f¹⁴, t²³)]: 703 --->
//│ 	case force⁰(ls²²) of {LH_C h²³ t²⁵ => if (n⁴ == 0) then h²³ else atIndex_lz_₀((n⁴ - 1), t²⁵) | LH_N  => error⁰}: 793
//│ [LH_N]: 704 --->
//│ 	case force⁰(ls²²) of {LH_C h²³ t²⁵ => if (n⁴ == 0) then h²³ else atIndex_lz_₀((n⁴ - 1), t²⁵) | LH_N  => error⁰}: 793
//│ ------------------
//│ case force⁰(ls²⁰) of {LH_C h²¹ t²³ => [LH_C f¹⁴(h²¹) map_lz_₀(f¹⁴, t²³)] | LH_N  => [LH_N]}: 705 --->
//│ 	[LH_C x² iterate_₀(f¹³, f¹³(x²))]: 687
//│ case force⁰(ls²²) of {LH_C h²³ t²⁵ => if (n⁴ == 0) then h²³ else atIndex_lz_₀((n⁴ - 1), t²⁵) | LH_N  => error⁰}: 793 --->
//│ 	[LH_C f¹⁴(h²¹) map_lz_₀(f¹⁴, t²³)]: 703
//│ 	[LH_N]: 704
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testPrime_nofib_₀(primId⁰(100))
//│ def atIndex_lz_₀(n⁶, ls²⁶) = if (n⁶ < 0) then error⁰ else force⁰(ls²⁶, n⁶)
//│ def enumFromTo_₀(a⁶, b³) = if (a⁶ <= b³) then [LH_C a⁶ enumFromTo_₀((a⁶ + 1), b³)] else [LH_N]
//│ def filter_₀(f¹⁵, ls²⁴) = case ls²⁴ of {
//│ 	LH_C h²⁰ t²² => if f¹⁵(h²⁰) then [LH_C h²⁰ filter_₀(f¹⁵, t²²)] else filter_₀(f¹⁵, t²²)
//│ 	| LH_N  => [LH_N]}
//│ def head_₀(ls²³) = case ls²³ of {
//│ 	LH_C h²² t²⁴ => h²²
//│ 	| LH_N  => error⁰}
//│ def isdivs_₀(_lh_isdivs_arg1², _lh_isdivs_arg2²) = ((_lh_isdivs_arg2² % _lh_isdivs_arg1²) /= 0)
//│ def iterate_₀(f¹⁶, x³) = lazy⁰(
//│ 	let t²⁶ = iterate_₀(f¹⁶, f¹⁶(x³))
//│ 	in let h²⁴ = x³
//│ 	in (fun f¹⁷ -> 
//│ 		let t²⁷ = map_lz_₀(f¹⁷, t²⁶)
//│ 		in let h²⁵ = f¹⁷(h²⁴)
//│ 		in (fun n⁵ -> if (n⁵ == 0) then h²⁵ else atIndex_lz_₀((n⁵ - 1), t²⁷))))
//│ def map_lz_₀(f¹⁸, ls²⁵) = lazy⁰(force⁰(ls²⁵, f¹⁸))
//│ def prime_₀(_lh_prime_arg1²) = atIndex_lz_₀(_lh_prime_arg1², map_lz_₀(head_₀, iterate_₀(the_filter_₀, enumFromTo_₀(2, (_lh_prime_arg1² * _lh_prime_arg1²)))))
//│ def testPrime_nofib_₀(_lh_testPrime_nofib_arg1²) = prime_₀(_lh_testPrime_nofib_arg1²)
//│ def the_filter_₀(_lh_the_filter_arg1²) = case _lh_the_filter_arg1² of {
//│ 	LH_C _lh_the_filter_LH_C_0¹ _lh_the_filter_LH_C_1¹ => filter_₀(isdivs_₀(_lh_the_filter_LH_C_0¹), _lh_the_filter_LH_C_1¹)
//│ 	| _  => error⁰}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
