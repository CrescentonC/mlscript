:NewParser
:ParseOnly

// NOTE: memory allocation negative numbers??
// -- powers = [[r^n | r<-[2..]] | n<-1..]
// powers :: [[Integer]]
// -- powers = [[(-1)^r * r^n | r<-[2..]] | n<-1..]
// neg_powers :: [[Integer]]
// pascal:: [[Integer]]
:lhInHaskell
:lhGenOCaml
powers = lazy ([2..] : (map_lz (\p -> zipWith_lz_lz (\a b -> a * b) (head_lz powers) p) powers))
neg_powers =
  lazy (map_lz (zipWith_lz_lz (\n x -> if n then x else (0-x)) (iterate not True)) powers)
pascal = lazy ([1,2,1] : map_lz (\line -> zipWith (\a b -> a + b) (mappend line [0]) (0:line)) pascal)
bernoulli 0 = 1
bernoulli 1 = 0 - (1 / 2)
bernoulli n =
  if ((n `mod` 2) == 1) then
    0
  else
    let powers = (atIndex_lz (n - 1) (force neg_powers)) in
      ((0-1)/2) + sum [ ((sum $ zipWith_lz_nl (\a b -> a * b) powers (tail $ tail combs)) - k) / (k+1) | (k,combs) <- zip_nl_lz [2..n] pascal ]
testBernoulli_nofib n = bernoulli n
testBernoulli_nofib $ primId 1500
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testBernoulli_nofib_lh_₁^516(primId⁰(1500))
//│ def atIndex_lz_lh_₁(n⁰, ls⁶) = if (n⁰ < 0) then error⁰ else case force⁰(ls⁶) of {
//│ 	LH_C h⁷ t⁷ => if (n⁰ == 0) then h⁷ else atIndex_lz_lh_₁^246((n⁰ - 1), t⁷)
//│ 	| LH_N  => error⁰}
//│ def bernoulli_lh_₁(_lh_bernoulli_arg1⁰) = case _lh_bernoulli_arg1⁰ of {
//│ 	0  => 1
//│ 	| 1  => (0 - (1 / 2))
//│ 	| _  => if ((_lh_bernoulli_arg1⁰ % 2) == 1) then 0 else 
//│ 		let powers⁰ = atIndex_lz_lh_₁^427((_lh_bernoulli_arg1⁰ - 1), force⁰(neg_powers_lh_₁^435))
//│ 		in (((0 - 1) / 2) + sum_lh_₁^449(
//│ 			let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 				LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {
//│ 					LH_P2 _lh_bernoulli_LH_P2_0⁰ _lh_bernoulli_LH_P2_1⁰ => [LH_C ((sum_lh_₂^454(zipWith_lz_nl_lh_₁^455((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂^466(tail_lh_₁^467(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]
//│ 					| _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}
//│ 				| LH_N  => [LH_N]})
//│ 			in _lh_listcomp_fun⁰(zip_nl_lz_lh_₁^495(enumFromTo_lh_₁^496(2, _lh_bernoulli_arg1⁰), pascal_lh_₁^502))))}
//│ def enumFromTo_lh_₁(a⁴, b¹) = if (a⁴ <= b¹) then [LH_C a⁴ enumFromTo_lh_₁^327((a⁴ + 1), b¹)] else [LH_N]
//│ def enumFrom_lh_₁(a⁰) = lazy⁰([LH_C a⁰ enumFrom_lh_₁^3((a⁰ + 1))])
//│ def head_lz_lh_₁(ls⁰) = case force⁰(ls⁰) of {
//│ 	LH_C h⁰ t⁰ => h⁰
//│ 	| LH_N  => error⁰}
//│ def iterate_lh_₁(f², x⁰) = lazy⁰([LH_C x⁰ iterate_lh_₁^96(f², f²(x⁰))])
//│ def map_lz_lh_₁(f⁶, ls⁵) = lazy⁰(case force⁰(ls⁵) of {
//│ 	LH_C h⁶ t⁶ => [LH_C f⁶(h⁶) map_lz_lh_₁^220(f⁶, t⁶)]
//│ 	| LH_N  => [LH_N]})
//│ def map_lz_lh_₂(f⁴, ls⁴) = lazy⁰(case force⁰(ls⁴) of {
//│ 	LH_C h⁴ t⁴ => [LH_C f⁴(h⁴) map_lz_lh_₂^142(f⁴, t⁴)]
//│ 	| LH_N  => [LH_N]})
//│ def map_lz_lh_₃(f⁰, ls¹) = lazy⁰(case force⁰(ls¹) of {
//│ 	LH_C h¹ t¹ => [LH_C f⁰(h¹) map_lz_lh_₃^27(f⁰, t¹)]
//│ 	| LH_N  => [LH_N]})
//│ def mappend_lh_₁(xs², ys²) = case xs² of {
//│ 	LH_C h⁵ t⁵ => [LH_C h⁵ mappend_lh_₁^181(t⁵, ys²)]
//│ 	| LH_N  => ys²}
//│ def neg_powers_lh_₁ = lazy⁰(map_lz_lh_₂^342(zipWith_lz_lz_lh_₁^343((fun n¹ -> (fun x¹ -> if n¹ then x¹ else (0 - x¹))), iterate_lh_₁^355(not⁰, [True])), powers_lh_₁^362))
//│ def pascal_lh_₁ = lazy⁰([LH_C [LH_C 1 [LH_C 2 [LH_C 1 [LH_N]]]] map_lz_lh_₁^378((fun line⁰ -> zipWith_lh_₁^379((fun a⁵ -> (fun b² -> (a⁵ + b²))), mappend_lh_₁^388(line⁰, [LH_C 0 [LH_N]]), [LH_C 0 line⁰])), pascal_lh_₁^402)])
//│ def powers_lh_₁ = lazy⁰([LH_C enumFrom_lh_₁^154(2) map_lz_lh_₃^157((fun p⁰ -> zipWith_lz_lz_lh_₂^158((fun a³ -> (fun b⁰ -> (a³ * b⁰))), head_lz_lh_₁^167(powers_lh_₁^168), p⁰)), powers_lh_₁^175)])
//│ def sumAux_lh_₁(ls³, a²) = case ls³ of {
//│ 	LH_N  => a²
//│ 	| LH_C h³ t³ => sumAux_lh_₁^82(t³, (a² + h³))}
//│ def sumAux_lh_₂(ls², a¹) = case ls² of {
//│ 	LH_N  => a¹
//│ 	| LH_C h² t² => sumAux_lh_₂^68(t², (a¹ + h²))}
//│ def sum_lh_₁(ls⁸) = sumAux_lh_₁^291(ls⁸, 0)
//│ def sum_lh_₂(ls⁷) = sumAux_lh_₂^261(ls⁷, 0)
//│ def tail_lh_₁(ls¹⁰) = case ls¹⁰ of {
//│ 	LH_C h⁹ t⁹ => t⁹
//│ 	| LH_N  => error⁰}
//│ def tail_lh_₂(ls⁹) = case ls⁹ of {
//│ 	LH_C h⁸ t⁸ => t⁸
//│ 	| LH_N  => error⁰}
//│ def testBernoulli_nofib_lh_₁(_lh_testBernoulli_nofib_arg1⁰) = bernoulli_lh_₁^512(_lh_testBernoulli_nofib_arg1⁰)
//│ def zipWith_lh_₁(f⁵, xs³, ys³) = case xs³ of {
//│ 	LH_C hx² tx² => case ys³ of {
//│ 		LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁^198(f⁵, tx², ty²)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ def zipWith_lz_lz_lh_₁(f³, xs¹, ys¹) = lazy⁰(case force⁰(xs¹) of {
//│ 	LH_C hx¹ tx¹ => case force⁰(ys¹) of {
//│ 		LH_C hy¹ ty¹ => [LH_C f³(hx¹, hy¹) zipWith_lz_lz_lh_₁^119(f³, tx¹, ty¹)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]})
//│ def zipWith_lz_lz_lh_₂(f¹, xs⁰, ys⁰) = lazy⁰(case force⁰(xs⁰) of {
//│ 	LH_C hx⁰ tx⁰ => case force⁰(ys⁰) of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f¹(hx⁰, hy⁰) zipWith_lz_lz_lh_₂^50(f¹, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]})
//│ def zipWith_lz_nl_lh_₁(f⁷, xs⁴, ys⁴) = case ys⁴ of {
//│ 	LH_C hy³ ty³ => case force⁰(xs⁴) of {
//│ 		LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁^276(f⁷, tx³, ty³)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ def zip_nl_lz_lh_₁(xs⁵, ys⁵) = case xs⁵ of {
//│ 	LH_C hx⁴ tx⁴ => case force⁰(ys⁵) of {
//│ 		LH_C hy⁴ ty⁴ => [LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁^304(tx⁴, ty⁴)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec zip_nl_lz_lh__d1 xs_5 ys_5 =
//│ 		  (match xs_5 with
//│ 		    | `LH_C(hx_4, tx_4) -> 
//│ 		      (match (Lazy.force ys_5) with
//│ 		        | `LH_C(hy_4, ty_4) -> 
//│ 		          (`LH_C((`LH_P2(hx_4, hy_4)), ((zip_nl_lz_lh__d1 tx_4) ty_4)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec atIndex_lz_lh__d1 n_0 ls_6 =
//│ 		  (if (n_0 < 0) then
//│ 		    (failwith "error")
//│ 		  else
//│ 		    (match (Lazy.force ls_6) with
//│ 		      | `LH_C(h_7, t_7) -> 
//│ 		        (if (n_0 = 0) then
//│ 		          h_7
//│ 		        else
//│ 		          ((atIndex_lz_lh__d1 (n_0 - 1)) t_7))
//│ 		      | `LH_N -> 
//│ 		        (failwith "error")));;
//│ 		let rec sumAux_lh__d2 ls_2 a_1 =
//│ 		  (match ls_2 with
//│ 		    | `LH_N -> 
//│ 		      a_1
//│ 		    | `LH_C(h_2, t_2) -> 
//│ 		      ((sumAux_lh__d2 t_2) (a_1 + h_2)));;
//│ 		let rec sum_lh__d2 ls_7 =
//│ 		  ((sumAux_lh__d2 ls_7) 0);;
//│ 		let rec tail_lh__d1 ls_1_0 =
//│ 		  (match ls_1_0 with
//│ 		    | `LH_C(h_9, t_9) -> 
//│ 		      t_9
//│ 		    | `LH_N -> 
//│ 		      (failwith "error"));;
//│ 		let rec iterate_lh__d1 f_2 x_0 =
//│ 		  (lazy (`LH_C(x_0, ((iterate_lh__d1 f_2) (f_2 x_0)))));;
//│ 		let rec map_lz_lh__d2 f_4 ls_4 =
//│ 		  (lazy (match (Lazy.force ls_4) with
//│ 		    | `LH_C(h_4, t_4) -> 
//│ 		      (`LH_C((f_4 h_4), ((map_lz_lh__d2 f_4) t_4)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)));;
//│ 		let rec zipWith_lz_lz_lh__d2 f_1 xs_0 ys_0 =
//│ 		  (lazy (match (Lazy.force xs_0) with
//│ 		    | `LH_C(hx_0, tx_0) -> 
//│ 		      (match (Lazy.force ys_0) with
//│ 		        | `LH_C(hy_0, ty_0) -> 
//│ 		          (`LH_C(((f_1 hx_0) hy_0), (((zipWith_lz_lz_lh__d2 f_1) tx_0) ty_0)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)));;
//│ 		let rec map_lz_lh__d3 f_0 ls_1 =
//│ 		  (lazy (match (Lazy.force ls_1) with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      (`LH_C((f_0 h_1), ((map_lz_lh__d3 f_0) t_1)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)));;
//│ 		let rec enumFrom_lh__d1 a_0 =
//│ 		  (lazy (`LH_C(a_0, (enumFrom_lh__d1 (a_0 + 1)))));;
//│ 		let rec head_lz_lh__d1 ls_0 =
//│ 		  (match (Lazy.force ls_0) with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      h_0
//│ 		    | `LH_N -> 
//│ 		      (failwith "error"));;
//│ 		let rec powers_lh__d1 =
//│ 		  (lazy (`LH_C((enumFrom_lh__d1 2), ((map_lz_lh__d3 (fun p_0 -> 
//│ 		    (((zipWith_lz_lz_lh__d2 (fun a_3 b_0 -> 
//│ 		      (a_3 * b_0))) (head_lz_lh__d1 powers_lh__d1)) p_0))) powers_lh__d1))));;
//│ 		let rec zipWith_lz_lz_lh__d1 f_3 xs_1 ys_1 =
//│ 		  (lazy (match (Lazy.force xs_1) with
//│ 		    | `LH_C(hx_1, tx_1) -> 
//│ 		      (match (Lazy.force ys_1) with
//│ 		        | `LH_C(hy_1, ty_1) -> 
//│ 		          (`LH_C(((f_3 hx_1) hy_1), (((zipWith_lz_lz_lh__d1 f_3) tx_1) ty_1)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)));;
//│ 		let rec neg_powers_lh__d1 =
//│ 		  (lazy ((map_lz_lh__d2 ((zipWith_lz_lz_lh__d1 (fun n_1 x_1 -> 
//│ 		    (if n_1 then
//│ 		      x_1
//│ 		    else
//│ 		      (0 - x_1)))) ((iterate_lh__d1 not) true))) powers_lh__d1));;
//│ 		let rec enumFromTo_lh__d1 a_4 b_1 =
//│ 		  (if (a_4 <= b_1) then
//│ 		    (`LH_C(a_4, ((enumFromTo_lh__d1 (a_4 + 1)) b_1)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec zipWith_lz_nl_lh__d1 f_7 xs_4 ys_4 =
//│ 		  (match ys_4 with
//│ 		    | `LH_C(hy_3, ty_3) -> 
//│ 		      (match (Lazy.force xs_4) with
//│ 		        | `LH_C(hx_3, tx_3) -> 
//│ 		          (`LH_C(((f_7 hx_3) hy_3), (((zipWith_lz_nl_lh__d1 f_7) tx_3) ty_3)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec mappend_lh__d1 xs_2 ys_2 =
//│ 		  (match xs_2 with
//│ 		    | `LH_C(h_5, t_5) -> 
//│ 		      (`LH_C(h_5, ((mappend_lh__d1 t_5) ys_2)))
//│ 		    | `LH_N -> 
//│ 		      ys_2);;
//│ 		let rec map_lz_lh__d1 f_6 ls_5 =
//│ 		  (lazy (match (Lazy.force ls_5) with
//│ 		    | `LH_C(h_6, t_6) -> 
//│ 		      (`LH_C((f_6 h_6), ((map_lz_lh__d1 f_6) t_6)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)));;
//│ 		let rec zipWith_lh__d1 f_5 xs_3 ys_3 =
//│ 		  (match xs_3 with
//│ 		    | `LH_C(hx_2, tx_2) -> 
//│ 		      (match ys_3 with
//│ 		        | `LH_C(hy_2, ty_2) -> 
//│ 		          (`LH_C(((f_5 hx_2) hy_2), (((zipWith_lh__d1 f_5) tx_2) ty_2)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec pascal_lh__d1 =
//│ 		  (lazy (`LH_C((`LH_C(1, (`LH_C(2, (`LH_C(1, (`LH_N))))))), ((map_lz_lh__d1 (fun line_0 -> 
//│ 		    (((zipWith_lh__d1 (fun a_5 b_2 -> 
//│ 		      (a_5 + b_2))) ((mappend_lh__d1 line_0) (`LH_C(0, (`LH_N))))) (`LH_C(0, line_0))))) pascal_lh__d1))));;
//│ 		let rec tail_lh__d2 ls_9 =
//│ 		  (match ls_9 with
//│ 		    | `LH_C(h_8, t_8) -> 
//│ 		      t_8
//│ 		    | `LH_N -> 
//│ 		      (failwith "error"));;
//│ 		let rec sumAux_lh__d1 ls_3 a_2 =
//│ 		  (match ls_3 with
//│ 		    | `LH_N -> 
//│ 		      a_2
//│ 		    | `LH_C(h_3, t_3) -> 
//│ 		      ((sumAux_lh__d1 t_3) (a_2 + h_3)));;
//│ 		let rec sum_lh__d1 ls_8 =
//│ 		  ((sumAux_lh__d1 ls_8) 0);;
//│ 		let rec bernoulli_lh__d1 _lh_bernoulli_arg1_0 =
//│ 		  (match _lh_bernoulli_arg1_0 with
//│ 		    | 0 -> 
//│ 		      1
//│ 		    | 1 -> 
//│ 		      (0 - (1 / 2))
//│ 		    | _ -> 
//│ 		      (if ((_lh_bernoulli_arg1_0 mod 2) = 1) then
//│ 		        0
//│ 		      else
//│ 		        (let rec powers_0 = ((atIndex_lz_lh__d1 (_lh_bernoulli_arg1_0 - 1)) (Lazy.force neg_powers_lh__d1)) in
//│ 		          (((0 - 1) / 2) + (sum_lh__d1 (let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│ 		            (match _lh_listcomp_fun_para_0 with
//│ 		              | `LH_C(_lh_listcomp_fun_ls_h_0, _lh_listcomp_fun_ls_t_0) -> 
//│ 		                (match _lh_listcomp_fun_ls_h_0 with
//│ 		                  | `LH_P2(_lh_bernoulli_LH_P2_0_0, _lh_bernoulli_LH_P2_1_0) -> 
//│ 		                    (`LH_C((((sum_lh__d2 (((zipWith_lz_nl_lh__d1 (fun a_6 b_3 -> 
//│ 		                      (a_6 * b_3))) powers_0) (tail_lh__d2 (tail_lh__d1 _lh_bernoulli_LH_P2_1_0)))) - _lh_bernoulli_LH_P2_0_0) / (_lh_bernoulli_LH_P2_0_0 + 1)), (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0)))
//│ 		                  | _ -> 
//│ 		                    (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0))
//│ 		              | `LH_N -> 
//│ 		                (`LH_N))) in
//│ 		            (_lh_listcomp_fun_0 ((zip_nl_lz_lh__d1 ((enumFromTo_lh__d1 2) _lh_bernoulli_arg1_0)) pascal_lh__d1))))))));;
//│ 		let rec testBernoulli_nofib_lh__d1 _lh_testBernoulli_nofib_arg1_0 =
//│ 		  (bernoulli_lh__d1 _lh_testBernoulli_nofib_arg1_0);;
//│ 		(testBernoulli_nofib_lh__d1 1500)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a⁰ enumFrom_lh_₁((a⁰ + 1))]: 10 --->
//│ 	case force⁰(ys⁰) of {LH_C hy⁰ ty⁰ => [LH_C f¹(hx⁰, hy⁰) zipWith_lz_lz_lh_₂(f¹, tx⁰, ty⁰)] | LH_N  => [LH_N]}: 59
//│ 	case force⁰(xs⁰) of {LH_C hx⁰ tx⁰ => case force⁰(ys⁰) of {LH_C hy⁰ ty⁰ => [LH_C f¹(hx⁰, hy⁰) zipWith_lz_lz_lh_₂(f¹, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 61
//│ 	case force⁰(ys¹) of {LH_C hy¹ ty¹ => [LH_C f³(hx¹, hy¹) zipWith_lz_lz_lh_₁(f³, tx¹, ty¹)] | LH_N  => [LH_N]}: 128
//│ [LH_C f⁰(h¹) map_lz_lh_₃(f⁰, t¹)]: 32 --->
//│ 	DeadCodeCons
//│ 	case force⁰(ls¹) of {LH_C h¹ t¹ => [LH_C f⁰(h¹) map_lz_lh_₃(f⁰, t¹)] | LH_N  => [LH_N]}: 34
//│ 	case force⁰(ls⁴) of {LH_C h⁴ t⁴ => [LH_C f⁴(h⁴) map_lz_lh_₂(f⁴, t⁴)] | LH_N  => [LH_N]}: 149
//│ [LH_N]: 33 --->
//│ 	DeadCodeCons
//│ 	case force⁰(ls¹) of {LH_C h¹ t¹ => [LH_C f⁰(h¹) map_lz_lh_₃(f⁰, t¹)] | LH_N  => [LH_N]}: 34
//│ 	case force⁰(ls⁴) of {LH_C h⁴ t⁴ => [LH_C f⁴(h⁴) map_lz_lh_₂(f⁴, t⁴)] | LH_N  => [LH_N]}: 149
//│ [LH_C f¹(hx⁰, hy⁰) zipWith_lz_lz_lh_₂(f¹, tx⁰, ty⁰)]: 57 --->
//│ 	DeadCodeCons
//│ 	case force⁰(ys⁰) of {LH_C hy⁰ ty⁰ => [LH_C f¹(hx⁰, hy⁰) zipWith_lz_lz_lh_₂(f¹, tx⁰, ty⁰)] | LH_N  => [LH_N]}: 59
//│ 	case force⁰(ys¹) of {LH_C hy¹ ty¹ => [LH_C f³(hx¹, hy¹) zipWith_lz_lz_lh_₁(f³, tx¹, ty¹)] | LH_N  => [LH_N]}: 128
//│ [LH_N]: 58 --->
//│ 	DeadCodeCons
//│ 	case force⁰(ys⁰) of {LH_C hy⁰ ty⁰ => [LH_C f¹(hx⁰, hy⁰) zipWith_lz_lz_lh_₂(f¹, tx⁰, ty⁰)] | LH_N  => [LH_N]}: 59
//│ 	case force⁰(ys¹) of {LH_C hy¹ ty¹ => [LH_C f³(hx¹, hy¹) zipWith_lz_lz_lh_₁(f³, tx¹, ty¹)] | LH_N  => [LH_N]}: 128
//│ [LH_N]: 60 --->
//│ 	DeadCodeCons
//│ 	case force⁰(ys⁰) of {LH_C hy⁰ ty⁰ => [LH_C f¹(hx⁰, hy⁰) zipWith_lz_lz_lh_₂(f¹, tx⁰, ty⁰)] | LH_N  => [LH_N]}: 59
//│ 	case force⁰(ys¹) of {LH_C hy¹ ty¹ => [LH_C f³(hx¹, hy¹) zipWith_lz_lz_lh_₁(f³, tx¹, ty¹)] | LH_N  => [LH_N]}: 128
//│ [LH_C x⁰ iterate_lh_₁(f², f²(x⁰))]: 103 --->
//│ 	case force⁰(xs¹) of {LH_C hx¹ tx¹ => case force⁰(ys¹) of {LH_C hy¹ ty¹ => [LH_C f³(hx¹, hy¹) zipWith_lz_lz_lh_₁(f³, tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 130
//│ [LH_C f³(hx¹, hy¹) zipWith_lz_lz_lh_₁(f³, tx¹, ty¹)]: 126 --->
//│ 	case force⁰(xs⁴) of {LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)] | LH_N  => [LH_N]}: 285
//│ [LH_N]: 127 --->
//│ 	case force⁰(xs⁴) of {LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)] | LH_N  => [LH_N]}: 285
//│ [LH_N]: 129 --->
//│ 	case force⁰(xs⁴) of {LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)] | LH_N  => [LH_N]}: 285
//│ [LH_C f⁴(h⁴) map_lz_lh_₂(f⁴, t⁴)]: 147 --->
//│ 	case force⁰(ls⁶) of {LH_C h⁷ t⁷ => if (n⁰ == 0) then h⁷ else atIndex_lz_lh_₁((n⁰ - 1), t⁷) | LH_N  => error⁰}: 257
//│ [LH_N]: 148 --->
//│ 	case force⁰(ls⁶) of {LH_C h⁷ t⁷ => if (n⁰ == 0) then h⁷ else atIndex_lz_lh_₁((n⁰ - 1), t⁷) | LH_N  => error⁰}: 257
//│ [LH_C enumFrom_lh_₁(2) map_lz_lh_₃((fun p⁰ -> zipWith_lz_lz_lh_₂((fun a³ -> (fun b⁰ -> (a³ * b⁰))), head_lz_lh_₁(powers_lh_₁), p⁰)), powers_lh_₁)]: 177 --->
//│ 	case force⁰(ls⁰) of {LH_C h⁰ t⁰ => h⁰ | LH_N  => error⁰}: 18
//│ 	case force⁰(ls¹) of {LH_C h¹ t¹ => [LH_C f⁰(h¹) map_lz_lh_₃(f⁰, t¹)] | LH_N  => [LH_N]}: 34
//│ 	case force⁰(ls⁴) of {LH_C h⁴ t⁴ => [LH_C f⁴(h⁴) map_lz_lh_₂(f⁴, t⁴)] | LH_N  => [LH_N]}: 149
//│ [LH_C h⁵ mappend_lh_₁(t⁵, ys²)]: 186 --->
//│ 	case xs³ of {LH_C hx² tx² => case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 209
//│ [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)]: 205 --->
//│ 	case xs² of {LH_C h⁵ t⁵ => [LH_C h⁵ mappend_lh_₁(t⁵, ys²)] | LH_N  => ys²}: 188
//│ 	case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]}: 207
//│ 	case ys⁴ of {LH_C hy³ ty³ => case force⁰(xs⁴) of {LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 287
//│ 	case ls⁹ of {LH_C h⁸ t⁸ => t⁸ | LH_N  => error⁰}: 319
//│ 	case ls¹⁰ of {LH_C h⁹ t⁹ => t⁹ | LH_N  => error⁰}: 368
//│ [LH_N]: 206 --->
//│ 	case xs² of {LH_C h⁵ t⁵ => [LH_C h⁵ mappend_lh_₁(t⁵, ys²)] | LH_N  => ys²}: 188
//│ 	case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]}: 207
//│ 	case ys⁴ of {LH_C hy³ ty³ => case force⁰(xs⁴) of {LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 287
//│ 	case ls⁹ of {LH_C h⁸ t⁸ => t⁸ | LH_N  => error⁰}: 319
//│ 	case ls¹⁰ of {LH_C h⁹ t⁹ => t⁹ | LH_N  => error⁰}: 368
//│ [LH_N]: 208 --->
//│ 	case xs² of {LH_C h⁵ t⁵ => [LH_C h⁵ mappend_lh_₁(t⁵, ys²)] | LH_N  => ys²}: 188
//│ 	case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]}: 207
//│ 	case ys⁴ of {LH_C hy³ ty³ => case force⁰(xs⁴) of {LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 287
//│ 	case ls⁹ of {LH_C h⁸ t⁸ => t⁸ | LH_N  => error⁰}: 319
//│ 	case ls¹⁰ of {LH_C h⁹ t⁹ => t⁹ | LH_N  => error⁰}: 368
//│ [LH_C f⁶(h⁶) map_lz_lh_₁(f⁶, t⁶)]: 225 --->
//│ 	case force⁰(ls⁵) of {LH_C h⁶ t⁶ => [LH_C f⁶(h⁶) map_lz_lh_₁(f⁶, t⁶)] | LH_N  => [LH_N]}: 227
//│ 	case force⁰(ys⁵) of {LH_C hy⁴ ty⁴ => [LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁(tx⁴, ty⁴)] | LH_N  => [LH_N]}: 311
//│ [LH_N]: 226 --->
//│ 	case force⁰(ls⁵) of {LH_C h⁶ t⁶ => [LH_C f⁶(h⁶) map_lz_lh_₁(f⁶, t⁶)] | LH_N  => [LH_N]}: 227
//│ 	case force⁰(ys⁵) of {LH_C hy⁴ ty⁴ => [LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁(tx⁴, ty⁴)] | LH_N  => [LH_N]}: 311
//│ [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)]: 283 --->
//│ 	case ls² of {LH_N  => a¹ | LH_C h² t² => sumAux_lh_₂(t², (a¹ + h²))}: 77
//│ [LH_N]: 284 --->
//│ 	case ls² of {LH_N  => a¹ | LH_C h² t² => sumAux_lh_₂(t², (a¹ + h²))}: 77
//│ [LH_N]: 286 --->
//│ 	case ls² of {LH_N  => a¹ | LH_C h² t² => sumAux_lh_₂(t², (a¹ + h²))}: 77
//│ [LH_P2 hx⁴ hy⁴]: 303 --->
//│ 	case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_bernoulli_LH_P2_0⁰ _lh_bernoulli_LH_P2_1⁰ => [LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 490
//│ [LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁(tx⁴, ty⁴)]: 309 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_bernoulli_LH_P2_0⁰ _lh_bernoulli_LH_P2_1⁰ => [LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 492
//│ [LH_N]: 310 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_bernoulli_LH_P2_0⁰ _lh_bernoulli_LH_P2_1⁰ => [LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 492
//│ [LH_N]: 312 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_bernoulli_LH_P2_0⁰ _lh_bernoulli_LH_P2_1⁰ => [LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 492
//│ [LH_C a⁴ enumFromTo_lh_₁((a⁴ + 1), b¹)]: 336 --->
//│ 	case xs⁵ of {LH_C hx⁴ tx⁴ => case force⁰(ys⁵) of {LH_C hy⁴ ty⁴ => [LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁(tx⁴, ty⁴)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 313
//│ [LH_N]: 337 --->
//│ 	case xs⁵ of {LH_C hx⁴ tx⁴ => case force⁰(ys⁵) of {LH_C hy⁴ ty⁴ => [LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁(tx⁴, ty⁴)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 313
//│ [LH_N]: 374 --->
//│ 	case xs² of {LH_C h⁵ t⁵ => [LH_C h⁵ mappend_lh_₁(t⁵, ys²)] | LH_N  => ys²}: 188
//│ 	case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]}: 207
//│ 	case ys⁴ of {LH_C hy³ ty³ => case force⁰(xs⁴) of {LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 287
//│ [LH_C 1 [LH_N]]: 375 --->
//│ 	case xs² of {LH_C h⁵ t⁵ => [LH_C h⁵ mappend_lh_₁(t⁵, ys²)] | LH_N  => ys²}: 188
//│ 	case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]}: 207
//│ 	case ys⁴ of {LH_C hy³ ty³ => case force⁰(xs⁴) of {LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 287
//│ [LH_C 2 [LH_C 1 [LH_N]]]: 376 --->
//│ 	case xs² of {LH_C h⁵ t⁵ => [LH_C h⁵ mappend_lh_₁(t⁵, ys²)] | LH_N  => ys²}: 188
//│ 	case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]}: 207
//│ 	case ls⁹ of {LH_C h⁸ t⁸ => t⁸ | LH_N  => error⁰}: 319
//│ [LH_C 1 [LH_C 2 [LH_C 1 [LH_N]]]]: 377 --->
//│ 	case xs² of {LH_C h⁵ t⁵ => [LH_C h⁵ mappend_lh_₁(t⁵, ys²)] | LH_N  => ys²}: 188
//│ 	case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]}: 207
//│ 	case ls¹⁰ of {LH_C h⁹ t⁹ => t⁹ | LH_N  => error⁰}: 368
//│ [LH_N]: 392 --->
//│ 	case xs³ of {LH_C hx² tx² => case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 209
//│ [LH_C 0 [LH_N]]: 393 --->
//│ 	case xs³ of {LH_C hx² tx² => case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 209
//│ [LH_C 0 line⁰]: 398 --->
//│ 	case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]}: 207
//│ [LH_C [LH_C 1 [LH_C 2 [LH_C 1 [LH_N]]]] map_lz_lh_₁((fun line⁰ -> zipWith_lh_₁((fun a⁵ -> (fun b² -> (a⁵ + b²))), mappend_lh_₁(line⁰, [LH_C 0 [LH_N]]), [LH_C 0 line⁰])), pascal_lh_₁)]: 404 --->
//│ 	case force⁰(ls⁵) of {LH_C h⁶ t⁶ => [LH_C f⁶(h⁶) map_lz_lh_₁(f⁶, t⁶)] | LH_N  => [LH_N]}: 227
//│ 	case force⁰(ys⁵) of {LH_C hy⁴ ty⁴ => [LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁(tx⁴, ty⁴)] | LH_N  => [LH_N]}: 311
//│ [LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 486 --->
//│ 	case ls³ of {LH_N  => a² | LH_C h³ t³ => sumAux_lh_₁(t³, (a² + h³))}: 91
//│ [LH_N]: 491 --->
//│ 	case ls³ of {LH_N  => a² | LH_C h³ t³ => sumAux_lh_₁(t³, (a² + h³))}: 91
//│ ------------------
//│ case force⁰(ls⁰) of {LH_C h⁰ t⁰ => h⁰ | LH_N  => error⁰}: 18 --->
//│ 	[LH_C enumFrom_lh_₁(2) map_lz_lh_₃((fun p⁰ -> zipWith_lz_lz_lh_₂((fun a³ -> (fun b⁰ -> (a³ * b⁰))), head_lz_lh_₁(powers_lh_₁), p⁰)), powers_lh_₁)]: 177
//│ case force⁰(ls¹) of {LH_C h¹ t¹ => [LH_C f⁰(h¹) map_lz_lh_₃(f⁰, t¹)] | LH_N  => [LH_N]}: 34 --->
//│ 	[LH_C f⁰(h¹) map_lz_lh_₃(f⁰, t¹)]: 32
//│ 	[LH_N]: 33
//│ 	[LH_C enumFrom_lh_₁(2) map_lz_lh_₃((fun p⁰ -> zipWith_lz_lz_lh_₂((fun a³ -> (fun b⁰ -> (a³ * b⁰))), head_lz_lh_₁(powers_lh_₁), p⁰)), powers_lh_₁)]: 177
//│ case force⁰(ys⁰) of {LH_C hy⁰ ty⁰ => [LH_C f¹(hx⁰, hy⁰) zipWith_lz_lz_lh_₂(f¹, tx⁰, ty⁰)] | LH_N  => [LH_N]}: 59 --->
//│ 	[LH_C a⁰ enumFrom_lh_₁((a⁰ + 1))]: 10
//│ 	[LH_C f¹(hx⁰, hy⁰) zipWith_lz_lz_lh_₂(f¹, tx⁰, ty⁰)]: 57
//│ 	[LH_N]: 58
//│ 	[LH_N]: 60
//│ case force⁰(xs⁰) of {LH_C hx⁰ tx⁰ => case force⁰(ys⁰) of {LH_C hy⁰ ty⁰ => [LH_C f¹(hx⁰, hy⁰) zipWith_lz_lz_lh_₂(f¹, tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 61 --->
//│ 	[LH_C a⁰ enumFrom_lh_₁((a⁰ + 1))]: 10
//│ case ls² of {LH_N  => a¹ | LH_C h² t² => sumAux_lh_₂(t², (a¹ + h²))}: 77 --->
//│ 	[LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)]: 283
//│ 	[LH_N]: 284
//│ 	[LH_N]: 286
//│ case ls³ of {LH_N  => a² | LH_C h³ t³ => sumAux_lh_₁(t³, (a² + h³))}: 91 --->
//│ 	[LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 486
//│ 	[LH_N]: 491
//│ case force⁰(ys¹) of {LH_C hy¹ ty¹ => [LH_C f³(hx¹, hy¹) zipWith_lz_lz_lh_₁(f³, tx¹, ty¹)] | LH_N  => [LH_N]}: 128 --->
//│ 	[LH_C a⁰ enumFrom_lh_₁((a⁰ + 1))]: 10
//│ 	[LH_C f¹(hx⁰, hy⁰) zipWith_lz_lz_lh_₂(f¹, tx⁰, ty⁰)]: 57
//│ 	[LH_N]: 58
//│ 	[LH_N]: 60
//│ case force⁰(xs¹) of {LH_C hx¹ tx¹ => case force⁰(ys¹) of {LH_C hy¹ ty¹ => [LH_C f³(hx¹, hy¹) zipWith_lz_lz_lh_₁(f³, tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 130 --->
//│ 	[LH_C x⁰ iterate_lh_₁(f², f²(x⁰))]: 103
//│ case force⁰(ls⁴) of {LH_C h⁴ t⁴ => [LH_C f⁴(h⁴) map_lz_lh_₂(f⁴, t⁴)] | LH_N  => [LH_N]}: 149 --->
//│ 	[LH_C f⁰(h¹) map_lz_lh_₃(f⁰, t¹)]: 32
//│ 	[LH_N]: 33
//│ 	[LH_C enumFrom_lh_₁(2) map_lz_lh_₃((fun p⁰ -> zipWith_lz_lz_lh_₂((fun a³ -> (fun b⁰ -> (a³ * b⁰))), head_lz_lh_₁(powers_lh_₁), p⁰)), powers_lh_₁)]: 177
//│ case xs² of {LH_C h⁵ t⁵ => [LH_C h⁵ mappend_lh_₁(t⁵, ys²)] | LH_N  => ys²}: 188 --->
//│ 	[LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)]: 205
//│ 	[LH_N]: 206
//│ 	[LH_N]: 208
//│ 	[LH_N]: 374
//│ 	[LH_C 1 [LH_N]]: 375
//│ 	[LH_C 2 [LH_C 1 [LH_N]]]: 376
//│ 	[LH_C 1 [LH_C 2 [LH_C 1 [LH_N]]]]: 377
//│ case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]}: 207 --->
//│ 	[LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)]: 205
//│ 	[LH_N]: 206
//│ 	[LH_N]: 208
//│ 	[LH_N]: 374
//│ 	[LH_C 1 [LH_N]]: 375
//│ 	[LH_C 2 [LH_C 1 [LH_N]]]: 376
//│ 	[LH_C 1 [LH_C 2 [LH_C 1 [LH_N]]]]: 377
//│ 	[LH_C 0 line⁰]: 398
//│ case xs³ of {LH_C hx² tx² => case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 209 --->
//│ 	[LH_C h⁵ mappend_lh_₁(t⁵, ys²)]: 186
//│ 	[LH_N]: 392
//│ 	[LH_C 0 [LH_N]]: 393
//│ case force⁰(ls⁵) of {LH_C h⁶ t⁶ => [LH_C f⁶(h⁶) map_lz_lh_₁(f⁶, t⁶)] | LH_N  => [LH_N]}: 227 --->
//│ 	[LH_C f⁶(h⁶) map_lz_lh_₁(f⁶, t⁶)]: 225
//│ 	[LH_N]: 226
//│ 	[LH_C [LH_C 1 [LH_C 2 [LH_C 1 [LH_N]]]] map_lz_lh_₁((fun line⁰ -> zipWith_lh_₁((fun a⁵ -> (fun b² -> (a⁵ + b²))), mappend_lh_₁(line⁰, [LH_C 0 [LH_N]]), [LH_C 0 line⁰])), pascal_lh_₁)]: 404
//│ case force⁰(ls⁶) of {LH_C h⁷ t⁷ => if (n⁰ == 0) then h⁷ else atIndex_lz_lh_₁((n⁰ - 1), t⁷) | LH_N  => error⁰}: 257 --->
//│ 	[LH_C f⁴(h⁴) map_lz_lh_₂(f⁴, t⁴)]: 147
//│ 	[LH_N]: 148
//│ case force⁰(xs⁴) of {LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)] | LH_N  => [LH_N]}: 285 --->
//│ 	[LH_C f³(hx¹, hy¹) zipWith_lz_lz_lh_₁(f³, tx¹, ty¹)]: 126
//│ 	[LH_N]: 127
//│ 	[LH_N]: 129
//│ case ys⁴ of {LH_C hy³ ty³ => case force⁰(xs⁴) of {LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 287 --->
//│ 	[LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)]: 205
//│ 	[LH_N]: 206
//│ 	[LH_N]: 208
//│ 	[LH_N]: 374
//│ 	[LH_C 1 [LH_N]]: 375
//│ case force⁰(ys⁵) of {LH_C hy⁴ ty⁴ => [LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁(tx⁴, ty⁴)] | LH_N  => [LH_N]}: 311 --->
//│ 	[LH_C f⁶(h⁶) map_lz_lh_₁(f⁶, t⁶)]: 225
//│ 	[LH_N]: 226
//│ 	[LH_C [LH_C 1 [LH_C 2 [LH_C 1 [LH_N]]]] map_lz_lh_₁((fun line⁰ -> zipWith_lh_₁((fun a⁵ -> (fun b² -> (a⁵ + b²))), mappend_lh_₁(line⁰, [LH_C 0 [LH_N]]), [LH_C 0 line⁰])), pascal_lh_₁)]: 404
//│ case xs⁵ of {LH_C hx⁴ tx⁴ => case force⁰(ys⁵) of {LH_C hy⁴ ty⁴ => [LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁(tx⁴, ty⁴)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 313 --->
//│ 	[LH_C a⁴ enumFromTo_lh_₁((a⁴ + 1), b¹)]: 336
//│ 	[LH_N]: 337
//│ case ls⁹ of {LH_C h⁸ t⁸ => t⁸ | LH_N  => error⁰}: 319 --->
//│ 	[LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)]: 205
//│ 	[LH_N]: 206
//│ 	[LH_N]: 208
//│ 	[LH_C 2 [LH_C 1 [LH_N]]]: 376
//│ case ls¹⁰ of {LH_C h⁹ t⁹ => t⁹ | LH_N  => error⁰}: 368 --->
//│ 	[LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)]: 205
//│ 	[LH_N]: 206
//│ 	[LH_N]: 208
//│ 	[LH_C 1 [LH_C 2 [LH_C 1 [LH_N]]]]: 377
//│ case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_bernoulli_LH_P2_0⁰ _lh_bernoulli_LH_P2_1⁰ => [LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 490 --->
//│ 	[LH_P2 hx⁴ hy⁴]: 303
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_bernoulli_LH_P2_0⁰ _lh_bernoulli_LH_P2_1⁰ => [LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 492 --->
//│ 	[LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁(tx⁴, ty⁴)]: 309
//│ 	[LH_N]: 310
//│ 	[LH_N]: 312
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C x⁰ iterate_lh_₁(f², f²(x⁰))]: 103 --->
//│ 	case force⁰(xs¹) of {LH_C hx¹ tx¹ => case force⁰(ys¹) of {LH_C hy¹ ty¹ => [LH_C f³(hx¹, hy¹) zipWith_lz_lz_lh_₁(f³, tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 130
//│ [LH_C f³(hx¹, hy¹) zipWith_lz_lz_lh_₁(f³, tx¹, ty¹)]: 126 --->
//│ 	case force⁰(xs⁴) of {LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)] | LH_N  => [LH_N]}: 285
//│ [LH_N]: 127 --->
//│ 	case force⁰(xs⁴) of {LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)] | LH_N  => [LH_N]}: 285
//│ [LH_N]: 129 --->
//│ 	case force⁰(xs⁴) of {LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)] | LH_N  => [LH_N]}: 285
//│ [LH_C f⁴(h⁴) map_lz_lh_₂(f⁴, t⁴)]: 147 --->
//│ 	case force⁰(ls⁶) of {LH_C h⁷ t⁷ => if (n⁰ == 0) then h⁷ else atIndex_lz_lh_₁((n⁰ - 1), t⁷) | LH_N  => error⁰}: 257
//│ [LH_N]: 148 --->
//│ 	case force⁰(ls⁶) of {LH_C h⁷ t⁷ => if (n⁰ == 0) then h⁷ else atIndex_lz_lh_₁((n⁰ - 1), t⁷) | LH_N  => error⁰}: 257
//│ [LH_C h⁵ mappend_lh_₁(t⁵, ys²)]: 186 --->
//│ 	case xs³ of {LH_C hx² tx² => case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 209
//│ [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)]: 283 --->
//│ 	case ls² of {LH_N  => a¹ | LH_C h² t² => sumAux_lh_₂(t², (a¹ + h²))}: 77
//│ [LH_N]: 284 --->
//│ 	case ls² of {LH_N  => a¹ | LH_C h² t² => sumAux_lh_₂(t², (a¹ + h²))}: 77
//│ [LH_N]: 286 --->
//│ 	case ls² of {LH_N  => a¹ | LH_C h² t² => sumAux_lh_₂(t², (a¹ + h²))}: 77
//│ [LH_P2 hx⁴ hy⁴]: 303 --->
//│ 	case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_bernoulli_LH_P2_0⁰ _lh_bernoulli_LH_P2_1⁰ => [LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 490
//│ [LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁(tx⁴, ty⁴)]: 309 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_bernoulli_LH_P2_0⁰ _lh_bernoulli_LH_P2_1⁰ => [LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 492
//│ [LH_N]: 310 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_bernoulli_LH_P2_0⁰ _lh_bernoulli_LH_P2_1⁰ => [LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 492
//│ [LH_N]: 312 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_bernoulli_LH_P2_0⁰ _lh_bernoulli_LH_P2_1⁰ => [LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 492
//│ [LH_C a⁴ enumFromTo_lh_₁((a⁴ + 1), b¹)]: 336 --->
//│ 	case xs⁵ of {LH_C hx⁴ tx⁴ => case force⁰(ys⁵) of {LH_C hy⁴ ty⁴ => [LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁(tx⁴, ty⁴)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 313
//│ [LH_N]: 337 --->
//│ 	case xs⁵ of {LH_C hx⁴ tx⁴ => case force⁰(ys⁵) of {LH_C hy⁴ ty⁴ => [LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁(tx⁴, ty⁴)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 313
//│ [LH_N]: 392 --->
//│ 	case xs³ of {LH_C hx² tx² => case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 209
//│ [LH_C 0 [LH_N]]: 393 --->
//│ 	case xs³ of {LH_C hx² tx² => case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 209
//│ [LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 486 --->
//│ 	case ls³ of {LH_N  => a² | LH_C h³ t³ => sumAux_lh_₁(t³, (a² + h³))}: 91
//│ [LH_N]: 491 --->
//│ 	case ls³ of {LH_N  => a² | LH_C h³ t³ => sumAux_lh_₁(t³, (a² + h³))}: 91
//│ ------------------
//│ case ls² of {LH_N  => a¹ | LH_C h² t² => sumAux_lh_₂(t², (a¹ + h²))}: 77 --->
//│ 	[LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)]: 283
//│ 	[LH_N]: 284
//│ 	[LH_N]: 286
//│ case ls³ of {LH_N  => a² | LH_C h³ t³ => sumAux_lh_₁(t³, (a² + h³))}: 91 --->
//│ 	[LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 486
//│ 	[LH_N]: 491
//│ case force⁰(xs¹) of {LH_C hx¹ tx¹ => case force⁰(ys¹) of {LH_C hy¹ ty¹ => [LH_C f³(hx¹, hy¹) zipWith_lz_lz_lh_₁(f³, tx¹, ty¹)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 130 --->
//│ 	[LH_C x⁰ iterate_lh_₁(f², f²(x⁰))]: 103
//│ case xs³ of {LH_C hx² tx² => case ys³ of {LH_C hy² ty² => [LH_C f⁵(hx², hy²) zipWith_lh_₁(f⁵, tx², ty²)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 209 --->
//│ 	[LH_C h⁵ mappend_lh_₁(t⁵, ys²)]: 186
//│ 	[LH_N]: 392
//│ 	[LH_C 0 [LH_N]]: 393
//│ case force⁰(ls⁶) of {LH_C h⁷ t⁷ => if (n⁰ == 0) then h⁷ else atIndex_lz_lh_₁((n⁰ - 1), t⁷) | LH_N  => error⁰}: 257 --->
//│ 	[LH_C f⁴(h⁴) map_lz_lh_₂(f⁴, t⁴)]: 147
//│ 	[LH_N]: 148
//│ case force⁰(xs⁴) of {LH_C hx³ tx³ => [LH_C f⁷(hx³, hy³) zipWith_lz_nl_lh_₁(f⁷, tx³, ty³)] | LH_N  => [LH_N]}: 285 --->
//│ 	[LH_C f³(hx¹, hy¹) zipWith_lz_lz_lh_₁(f³, tx¹, ty¹)]: 126
//│ 	[LH_N]: 127
//│ 	[LH_N]: 129
//│ case xs⁵ of {LH_C hx⁴ tx⁴ => case force⁰(ys⁵) of {LH_C hy⁴ ty⁴ => [LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁(tx⁴, ty⁴)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 313 --->
//│ 	[LH_C a⁴ enumFromTo_lh_₁((a⁴ + 1), b¹)]: 336
//│ 	[LH_N]: 337
//│ case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_bernoulli_LH_P2_0⁰ _lh_bernoulli_LH_P2_1⁰ => [LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 490 --->
//│ 	[LH_P2 hx⁴ hy⁴]: 303
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_bernoulli_LH_P2_0⁰ _lh_bernoulli_LH_P2_1⁰ => [LH_C ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a⁶ -> (fun b³ -> (a⁶ * b³))), powers⁰, tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)))) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 492 --->
//│ 	[LH_C [LH_P2 hx⁴ hy⁴] zip_nl_lz_lh_₁(tx⁴, ty⁴)]: 309
//│ 	[LH_N]: 310
//│ 	[LH_N]: 312
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testBernoulli_nofib_lh_₁(primId⁰(1500))
//│ def atIndex_lz_lh_₁(n², ls¹¹) = if (n² < 0) then error⁰ else force⁰(ls¹¹, n²)
//│ def bernoulli_lh_₁(_lh_bernoulli_arg1¹) = case _lh_bernoulli_arg1¹ of {
//│ 	0  => 1
//│ 	| 1  => (0 - (1 / 2))
//│ 	| _  => if ((_lh_bernoulli_arg1¹ % 2) == 1) then 0 else 
//│ 		let powers⁵ = atIndex_lz_lh_₁((_lh_bernoulli_arg1¹ - 1), force⁰(neg_powers_lh_₁))
//│ 		in (((0 - 1) / 2) + sum_lh_₁(
//│ 			let _lh_listcomp_fun⁵ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun⁵, powers⁵))
//│ 			in _lh_listcomp_fun⁵(zip_nl_lz_lh_₁(enumFromTo_lh_₁(2, _lh_bernoulli_arg1¹), pascal_lh_₁))))}
//│ def enumFromTo_lh_₁(a⁸, b⁵) = if (a⁸ <= b⁵) then 
//│ 	let tx⁵ = enumFromTo_lh_₁((a⁸ + 1), b⁵)
//│ 	in let hx⁵ = a⁸
//│ 	in (fun ys⁷ -> case force⁰(ys⁷) of {
//│ 		LH_C hy⁴ ty⁴ => 
//│ 			let _lh_listcomp_fun_ls_t¹ = zip_nl_lz_lh_₁(tx⁵, ty⁴)
//│ 			in let _lh_listcomp_fun_ls_h¹ = 	
//│ 				let _lh_bernoulli_LH_P2_1¹ = hy⁴
//│ 				in let _lh_bernoulli_LH_P2_0¹ = hx⁵
//│ 				in (fun _lh_listcomp_fun_ls_t² -> (fun _lh_listcomp_fun² -> (fun powers² -> 
//│ 					let t¹⁰ = _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)
//│ 					in let h¹⁰ = ((sum_lh_₂(zipWith_lz_nl_lh_₁((fun a¹⁰ -> (fun b⁶ -> (a¹⁰ * b⁶))), powers², tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1¹)))) - _lh_bernoulli_LH_P2_0¹) / (_lh_bernoulli_LH_P2_0¹ + 1))
//│ 					in (fun a⁹ -> sumAux_lh_₁(t¹⁰, (a⁹ + h¹⁰))))))
//│ 			in (fun _lh_listcomp_fun¹ -> (fun powers¹ -> _lh_listcomp_fun_ls_h¹(_lh_listcomp_fun_ls_t¹, _lh_listcomp_fun¹, powers¹)))
//│ 		| LH_N  => (fun _lh_listcomp_fun³ -> (fun powers³ -> (fun a¹¹ -> a¹¹)))}) else (fun ys⁸ -> (fun _lh_listcomp_fun⁴ -> (fun powers⁴ -> (fun a¹² -> a¹²))))
//│ def enumFrom_lh_₁(a¹⁷) = lazy⁰([LH_C a¹⁷ enumFrom_lh_₁((a¹⁷ + 1))])
//│ def head_lz_lh_₁(ls²¹) = case force⁰(ls²¹) of {
//│ 	LH_C h⁰ t⁰ => h⁰
//│ 	| LH_N  => error⁰}
//│ def iterate_lh_₁(f¹⁸, x³) = lazy⁰(
//│ 	let tx⁸ = iterate_lh_₁(f¹⁸, f¹⁸(x³))
//│ 	in let hx⁸ = x³
//│ 	in (fun f¹⁹ -> (fun ys¹⁷ -> case force⁰(ys¹⁷) of {
//│ 		LH_C hy¹ ty¹ => 
//│ 			let tx⁹ = zipWith_lz_lz_lh_₁(f¹⁹, tx⁸, ty¹)
//│ 			in let hx⁹ = f¹⁹(hx⁸, hy¹)
//│ 			in (fun f²⁰ -> (fun hy⁵ -> (fun ty⁵ -> 
//│ 				let t¹² = zipWith_lz_nl_lh_₁(f²⁰, tx⁹, ty⁵)
//│ 				in let h¹² = f²⁰(hx⁹, hy⁵)
//│ 				in (fun a¹⁸ -> sumAux_lh_₂(t¹², (a¹⁸ + h¹²))))))
//│ 		| LH_N  => (fun f²¹ -> (fun hy⁶ -> (fun ty⁶ -> (fun a¹⁹ -> a¹⁹))))})))
//│ def map_lz_lh_₁(f¹², ls¹⁷) = lazy⁰(case force⁰(ls¹⁷) of {
//│ 	LH_C h⁶ t⁶ => [LH_C f¹²(h⁶) map_lz_lh_₁(f¹², t⁶)]
//│ 	| LH_N  => [LH_N]})
//│ def map_lz_lh_₂(f¹¹, ls¹⁵) = lazy⁰(case force⁰(ls¹⁵) of {
//│ 	LH_C h⁴ t⁴ => 
//│ 		let t¹¹ = map_lz_lh_₂(f¹¹, t⁴)
//│ 		in let h¹¹ = f¹¹(h⁴)
//│ 		in (fun n⁴ -> if (n⁴ == 0) then h¹¹ else atIndex_lz_lh_₁((n⁴ - 1), t¹¹))
//│ 	| LH_N  => (fun n⁵ -> error⁰)})
//│ def map_lz_lh_₃(f⁹, ls¹³) = lazy⁰(case force⁰(ls¹³) of {
//│ 	LH_C h¹ t¹ => [LH_C f⁹(h¹) map_lz_lh_₃(f⁹, t¹)]
//│ 	| LH_N  => [LH_N]})
//│ def mappend_lh_₁(xs⁹, ys¹¹) = case xs⁹ of {
//│ 	LH_C h⁵ t⁵ => 
//│ 		let tx⁶ = mappend_lh_₁(t⁵, ys¹¹)
//│ 		in let hx⁶ = h⁵
//│ 		in (fun f¹³ -> (fun ys¹² -> case ys¹² of {
//│ 			LH_C hy² ty² => [LH_C f¹³(hx⁶, hy²) zipWith_lh_₁(f¹³, tx⁶, ty²)]
//│ 			| LH_N  => [LH_N]}))
//│ 	| LH_N  => ys¹¹}
//│ def neg_powers_lh_₁ = lazy⁰(map_lz_lh_₂(zipWith_lz_lz_lh_₁((fun n³ -> (fun x² -> if n³ then x² else (0 - x²))), iterate_lh_₁(not⁰, [True])), powers_lh_₁))
//│ def pascal_lh_₁ = lazy⁰([LH_C [LH_C 1 [LH_C 2 [LH_C 1 [LH_N]]]] map_lz_lh_₁((fun line¹ -> zipWith_lh_₁((fun a¹⁶ -> (fun b⁷ -> (a¹⁶ + b⁷))), mappend_lh_₁(line¹, 
//│ 	let tx⁷ = (fun f¹⁶ -> (fun ys¹⁵ -> [LH_N]))
//│ 	in let hx⁷ = 0
//│ 	in (fun f¹⁵ -> (fun ys¹⁴ -> case ys¹⁴ of {
//│ 		LH_C hy² ty² => [LH_C f¹⁵(hx⁷, hy²) zipWith_lh_₁(f¹⁵, tx⁷, ty²)]
//│ 		| LH_N  => [LH_N]}))), [LH_C 0 line¹])), pascal_lh_₁)])
//│ def powers_lh_₁ = lazy⁰([LH_C enumFrom_lh_₁(2) map_lz_lh_₃((fun p¹ -> zipWith_lz_lz_lh_₂((fun a⁷ -> (fun b⁴ -> (a⁷ * b⁴))), head_lz_lh_₁(powers_lh_₁), p¹)), powers_lh_₁)])
//│ def sumAux_lh_₁(ls¹⁴, a¹³) = ls¹⁴(a¹³)
//│ def sumAux_lh_₂(ls¹⁶, a¹⁴) = ls¹⁶(a¹⁴)
//│ def sum_lh_₁(ls¹⁹) = sumAux_lh_₁(ls¹⁹, 0)
//│ def sum_lh_₂(ls¹²) = sumAux_lh_₂(ls¹², 0)
//│ def tail_lh_₁(ls²⁰) = case ls²⁰ of {
//│ 	LH_C h⁹ t⁹ => t⁹
//│ 	| LH_N  => error⁰}
//│ def tail_lh_₂(ls¹⁸) = case ls¹⁸ of {
//│ 	LH_C h⁸ t⁸ => t⁸
//│ 	| LH_N  => error⁰}
//│ def testBernoulli_nofib_lh_₁(_lh_testBernoulli_nofib_arg1¹) = bernoulli_lh_₁(_lh_testBernoulli_nofib_arg1¹)
//│ def zipWith_lh_₁(f¹⁰, xs⁷, ys⁹) = xs⁷(f¹⁰, ys⁹)
//│ def zipWith_lz_lz_lh_₁(f¹⁷, xs¹¹, ys¹⁶) = lazy⁰(force⁰(xs¹¹, f¹⁷, ys¹⁶))
//│ def zipWith_lz_lz_lh_₂(f⁸, xs⁶, ys⁶) = lazy⁰(case force⁰(xs⁶) of {
//│ 	LH_C hx⁰ tx⁰ => case force⁰(ys⁶) of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f⁸(hx⁰, hy⁰) zipWith_lz_lz_lh_₂(f⁸, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]})
//│ def zipWith_lz_nl_lh_₁(f¹⁴, xs¹⁰, ys¹³) = case ys¹³ of {
//│ 	LH_C hy³ ty³ => force⁰(xs¹⁰, f¹⁴, hy³, ty³)
//│ 	| LH_N  => (fun a¹⁵ -> a¹⁵)}
//│ def zip_nl_lz_lh_₁(xs⁸, ys¹⁰) = xs⁸(ys¹⁰)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ bernoulli_lh_₁, zipWith_lz_lz_lh_₁, atIndex_lz_lh_₁, zip_nl_lz_lh_₁, sumAux_lh_₂, zipWith_lh_₁, sumAux_lh_₁, zipWith_lz_nl_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ mappend_lh_₁ -> 4
//│ pascal_lh_₁ -> 0
//│ enumFromTo_lh_₁ -> 3
//│ iterate_lh_₁ -> 2
//│ map_lz_lh_₂ -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testBernoulli_nofib_lh_₁(primId⁰(1500))
//│ def atIndex_lz_lh_₁(n⁰, ls⁰) = if (n⁰ < 0) then error⁰ else force⁰(ls⁰, n⁰)
//│ def bernoulli_lh_₁(_lh_bernoulli_arg1⁰) = case _lh_bernoulli_arg1⁰ of {
//│ 	0  => 1
//│ 	| 1  => (0 - (1 / 2))
//│ 	| _  => if ((_lh_bernoulli_arg1⁰ % 2) == 1) then 0 else 
//│ 		let powers⁵ = if ((_lh_bernoulli_arg1⁰ - 1) < 0) then error⁰ else force⁰(force⁰(neg_powers_lh_₁), (_lh_bernoulli_arg1⁰ - 1))
//│ 		in (((0 - 1) / 2) + sum_lh_₁(
//│ 			let _lh_listcomp_fun⁵ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun⁵, powers⁵))
//│ 			in _lh_listcomp_fun⁵(enumFromTo_lh_₁(2, _lh_bernoulli_arg1⁰, pascal_lh_₁))))}
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let tx¹ = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let hx¹ = a¹
//│ 	in (fun ys² -> case force⁰(ys²) of {
//│ 		LH_C hy¹ ty¹ => 
//│ 			let _lh_listcomp_fun_ls_t⁰ = tx¹(ty¹)
//│ 			in let _lh_listcomp_fun_ls_h⁰ = 	
//│ 				let _lh_bernoulli_LH_P2_1⁰ = hy¹
//│ 				in let _lh_bernoulli_LH_P2_0⁰ = hx¹
//│ 				in (fun _lh_listcomp_fun_ls_t¹ -> (fun _lh_listcomp_fun⁰ -> (fun powers⁰ -> 
//│ 					let t¹ = _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t¹)
//│ 					in let h¹ = ((sum_lh_₂(case tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)) of {
//│ 						LH_C hy² ty² => force⁰(powers⁰, (fun a² -> (fun b² -> (a² * b²))), hy², ty²)
//│ 						| LH_N  => (fun a³ -> a³)}) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1))
//│ 					in (fun a⁴ -> t¹((a⁴ + h¹))))))
//│ 			in (fun _lh_listcomp_fun¹ -> (fun powers¹ -> _lh_listcomp_fun_ls_h⁰(_lh_listcomp_fun_ls_t⁰, _lh_listcomp_fun¹, powers¹)))
//│ 		| LH_N  => (fun _lh_listcomp_fun² -> (fun powers² -> (fun a⁵ -> a⁵)))}) else (fun ys³ -> (fun _lh_listcomp_fun³ -> (fun powers³ -> (fun a⁶ -> a⁶))))
//│ def enumFrom_lh_₁(a¹¹) = lazy⁰([LH_C a¹¹ enumFrom_lh_₁((a¹¹ + 1))])
//│ def head_lz_lh_₁(ls¹⁰) = case force⁰(ls¹⁰) of {
//│ 	LH_C h⁸ t⁸ => h⁸
//│ 	| LH_N  => error⁰}
//│ def iterate_lh_₁(f¹⁰, x¹) = lazy⁰(
//│ 	let tx⁴ = iterate_lh_₁(f¹⁰, f¹⁰(x¹))
//│ 	in let hx⁴ = x¹
//│ 	in (fun f¹¹ -> (fun ys¹² -> case force⁰(ys¹²) of {
//│ 		LH_C hy⁶ ty⁶ => 
//│ 			let tx⁵ = lazy⁰(force⁰(tx⁴, f¹¹, ty⁶))
//│ 			in let hx⁵ = f¹¹(hx⁴, hy⁶)
//│ 			in (fun f¹² -> (fun hy⁷ -> (fun ty⁷ -> 
//│ 				let t⁹ = case ty⁷ of {
//│ 					LH_C hy⁸ ty⁸ => force⁰(tx⁵, f¹², hy⁸, ty⁸)
//│ 					| LH_N  => (fun a¹² -> a¹²)}
//│ 				in let h⁹ = f¹²(hx⁵, hy⁷)
//│ 				in (fun a¹³ -> t⁹((a¹³ + h⁹))))))
//│ 		| LH_N  => (fun f¹³ -> (fun hy⁹ -> (fun ty⁹ -> (fun a¹⁴ -> a¹⁴))))})))
//│ def map_lz_lh_₁(f⁴, ls⁶) = lazy⁰(case force⁰(ls⁶) of {
//│ 	LH_C h⁴ t⁴ => [LH_C f⁴(h⁴) map_lz_lh_₁(f⁴, t⁴)]
//│ 	| LH_N  => [LH_N]})
//│ def map_lz_lh_₂(f³, ls⁴) = lazy⁰(case force⁰(ls⁴) of {
//│ 	LH_C h² t² => 
//│ 		let t³ = map_lz_lh_₂(f³, t²)
//│ 		in let h³ = f³(h²)
//│ 		in (fun n² -> if (n² == 0) then h³ else if ((n² - 1) < 0) then error⁰ else force⁰(t³, (n² - 1)))
//│ 	| LH_N  => (fun n³ -> error⁰)})
//│ def map_lz_lh_₃(f¹, ls²) = lazy⁰(case force⁰(ls²) of {
//│ 	LH_C h⁰ t⁰ => [LH_C f¹(h⁰) map_lz_lh_₃(f¹, t⁰)]
//│ 	| LH_N  => [LH_N]})
//│ def mappend_lh_₁(xs³, ys⁶) = case xs³ of {
//│ 	LH_C h⁵ t⁵ => 
//│ 		let tx² = mappend_lh_₁(t⁵, ys⁶)
//│ 		in let hx² = h⁵
//│ 		in (fun f⁵ -> (fun ys⁷ -> case ys⁷ of {
//│ 			LH_C hy³ ty³ => [LH_C f⁵(hx², hy³) tx²(f⁵, ty³)]
//│ 			| LH_N  => [LH_N]}))
//│ 	| LH_N  => ys⁶}
//│ def neg_powers_lh_₁ = lazy⁰(map_lz_lh_₂((fun ys¹ -> lazy⁰(force⁰(iterate_lh_₁(not⁰, [True]), (fun n¹ -> (fun x⁰ -> if n¹ then x⁰ else (0 - x⁰))), ys¹))), powers_lh_₁))
//│ def pascal_lh_₁ = lazy⁰([LH_C [LH_C 1 [LH_C 2 [LH_C 1 [LH_N]]]] map_lz_lh_₁((fun line⁰ -> mappend_lh_₁(line⁰, 
//│ 	let tx³ = (fun f⁷ -> (fun ys⁹ -> [LH_N]))
//│ 	in let hx³ = 0
//│ 	in (fun f⁸ -> (fun ys¹⁰ -> case ys¹⁰ of {
//│ 		LH_C hy⁵ ty⁵ => [LH_C f⁸(hx³, hy⁵) tx³(f⁸, ty⁵)]
//│ 		| LH_N  => [LH_N]})), (fun a¹⁰ -> (fun b³ -> (a¹⁰ + b³))), [LH_C 0 line⁰])), pascal_lh_₁)])
//│ def powers_lh_₁ = lazy⁰([LH_C enumFrom_lh_₁(2) map_lz_lh_₃((fun p⁰ -> zipWith_lz_lz_lh_₂((fun a⁰ -> (fun b⁰ -> (a⁰ * b⁰))), head_lz_lh_₁(powers_lh_₁), p⁰)), powers_lh_₁)])
//│ def sumAux_lh_₁(ls³, a⁷) = ls³(a⁷)
//│ def sumAux_lh_₂(ls⁵, a⁸) = ls⁵(a⁸)
//│ def sum_lh_₁(ls⁸) = ls⁸(0)
//│ def sum_lh_₂(ls¹) = ls¹(0)
//│ def tail_lh_₁(ls⁹) = case ls⁹ of {
//│ 	LH_C h⁷ t⁷ => t⁷
//│ 	| LH_N  => error⁰}
//│ def tail_lh_₂(ls⁷) = case ls⁷ of {
//│ 	LH_C h⁶ t⁶ => t⁶
//│ 	| LH_N  => error⁰}
//│ def testBernoulli_nofib_lh_₁(_lh_testBernoulli_nofib_arg1⁰) = case _lh_testBernoulli_nofib_arg1⁰ of {
//│ 	0  => 1
//│ 	| 1  => (0 - (1 / 2))
//│ 	| _  => if ((_lh_testBernoulli_nofib_arg1⁰ % 2) == 1) then 0 else 
//│ 		let powers⁴ = if ((_lh_testBernoulli_nofib_arg1⁰ - 1) < 0) then error⁰ else force⁰(force⁰(neg_powers_lh_₁), (_lh_testBernoulli_nofib_arg1⁰ - 1))
//│ 		in (((0 - 1) / 2) + sum_lh_₁(
//│ 			let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁰ -> _lh_listcomp_fun_para⁰(_lh_listcomp_fun⁴, powers⁴))
//│ 			in _lh_listcomp_fun⁴(enumFromTo_lh_₁(2, _lh_testBernoulli_nofib_arg1⁰, pascal_lh_₁))))}
//│ def zipWith_lh_₁(f², xs¹, ys⁴) = xs¹(f², ys⁴)
//│ def zipWith_lz_lz_lh_₁(f⁹, xs⁵, ys¹¹) = lazy⁰(force⁰(xs⁵, f⁹, ys¹¹))
//│ def zipWith_lz_lz_lh_₂(f⁰, xs⁰, ys⁰) = lazy⁰(case force⁰(xs⁰) of {
//│ 	LH_C hx⁰ tx⁰ => case force⁰(ys⁰) of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lz_lz_lh_₂(f⁰, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]})
//│ def zipWith_lz_nl_lh_₁(f⁶, xs⁴, ys⁸) = case ys⁸ of {
//│ 	LH_C hy⁴ ty⁴ => force⁰(xs⁴, f⁶, hy⁴, ty⁴)
//│ 	| LH_N  => (fun a⁹ -> a⁹)}
//│ def zip_nl_lz_lh_₁(xs², ys⁵) = xs²(ys⁵)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testBernoulli_nofib_lh_₁(primId⁰(1500))
//│ def atIndex_lz_lh_₁(n⁰, ls⁰) = if (n⁰ < 0) then error⁰ else force⁰(ls⁰, n⁰)
//│ def bernoulli_lh_₁(_lh_bernoulli_arg1⁰) = case _lh_bernoulli_arg1⁰ of {
//│ 	0  => 1
//│ 	| 1  => (0 - (1 / 2))
//│ 	| _  => if ((_lh_bernoulli_arg1⁰ % 2) == 1) then 0 else 
//│ 		let powers⁵ = if ((_lh_bernoulli_arg1⁰ - 1) < 0) then error⁰ else force⁰(force⁰(neg_powers_lh_₁), (_lh_bernoulli_arg1⁰ - 1))
//│ 		in (((0 - 1) / 2) + sum_lh_₁(
//│ 			let _lh_listcomp_fun⁵ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun⁵, powers⁵))
//│ 			in _lh_listcomp_fun⁵(enumFromTo_lh_₁(2, _lh_bernoulli_arg1⁰, pascal_lh_₁))))}
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let tx¹ = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let hx¹ = a¹
//│ 	in (fun ys² -> case force⁰(ys²) of {
//│ 		LH_C hy¹ ty¹ => 
//│ 			let _lh_listcomp_fun_ls_t⁰ = tx¹(ty¹)
//│ 			in let _lh_listcomp_fun_ls_h⁰ = 	
//│ 				let _lh_bernoulli_LH_P2_1⁰ = hy¹
//│ 				in let _lh_bernoulli_LH_P2_0⁰ = hx¹
//│ 				in (fun _lh_listcomp_fun_ls_t¹ -> (fun _lh_listcomp_fun⁰ -> (fun powers⁰ -> 
//│ 					let t¹ = _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t¹)
//│ 					in let h¹ = ((sum_lh_₂(case tail_lh_₂(tail_lh_₁(_lh_bernoulli_LH_P2_1⁰)) of {
//│ 						LH_C hy² ty² => force⁰(powers⁰, (fun a² -> (fun b² -> (a² * b²))), hy², ty²)
//│ 						| LH_N  => (fun a³ -> a³)}) - _lh_bernoulli_LH_P2_0⁰) / (_lh_bernoulli_LH_P2_0⁰ + 1))
//│ 					in (fun a⁴ -> t¹((a⁴ + h¹))))))
//│ 			in (fun _lh_listcomp_fun¹ -> (fun powers¹ -> _lh_listcomp_fun_ls_h⁰(_lh_listcomp_fun_ls_t⁰, _lh_listcomp_fun¹, powers¹)))
//│ 		| LH_N  => (fun _lh_listcomp_fun² -> (fun powers² -> (fun a⁵ -> a⁵)))}) else (fun ys³ -> (fun _lh_listcomp_fun³ -> (fun powers³ -> (fun a⁶ -> a⁶))))
//│ def enumFrom_lh_₁(a¹¹) = lazy⁰([LH_C a¹¹ enumFrom_lh_₁((a¹¹ + 1))])
//│ def head_lz_lh_₁(ls¹⁰) = case force⁰(ls¹⁰) of {
//│ 	LH_C h⁸ t⁸ => h⁸
//│ 	| LH_N  => error⁰}
//│ def iterate_lh_₁(f¹⁰, x¹) = lazy⁰(
//│ 	let tx⁴ = iterate_lh_₁(f¹⁰, f¹⁰(x¹))
//│ 	in let hx⁴ = x¹
//│ 	in (fun f¹¹ -> (fun ys¹² -> case force⁰(ys¹²) of {
//│ 		LH_C hy⁶ ty⁶ => 
//│ 			let tx⁵ = lazy⁰(force⁰(tx⁴, f¹¹, ty⁶))
//│ 			in let hx⁵ = f¹¹(hx⁴, hy⁶)
//│ 			in (fun f¹² -> (fun hy⁷ -> (fun ty⁷ -> 
//│ 				let t⁹ = case ty⁷ of {
//│ 					LH_C hy⁸ ty⁸ => force⁰(tx⁵, f¹², hy⁸, ty⁸)
//│ 					| LH_N  => (fun a¹² -> a¹²)}
//│ 				in let h⁹ = f¹²(hx⁵, hy⁷)
//│ 				in (fun a¹³ -> t⁹((a¹³ + h⁹))))))
//│ 		| LH_N  => (fun f¹³ -> (fun hy⁹ -> (fun ty⁹ -> (fun a¹⁴ -> a¹⁴))))})))
//│ def map_lz_lh_₁(f⁴, ls⁶) = lazy⁰(case force⁰(ls⁶) of {
//│ 	LH_C h⁴ t⁴ => [LH_C f⁴(h⁴) map_lz_lh_₁(f⁴, t⁴)]
//│ 	| LH_N  => [LH_N]})
//│ def map_lz_lh_₂(f³, ls⁴) = lazy⁰(case force⁰(ls⁴) of {
//│ 	LH_C h² t² => 
//│ 		let t³ = map_lz_lh_₂(f³, t²)
//│ 		in let h³ = f³(h²)
//│ 		in (fun n² -> if (n² == 0) then h³ else if ((n² - 1) < 0) then error⁰ else force⁰(t³, (n² - 1)))
//│ 	| LH_N  => (fun n³ -> error⁰)})
//│ def map_lz_lh_₃(f¹, ls²) = lazy⁰(case force⁰(ls²) of {
//│ 	LH_C h⁰ t⁰ => [LH_C f¹(h⁰) map_lz_lh_₃(f¹, t⁰)]
//│ 	| LH_N  => [LH_N]})
//│ def mappend_lh_₁(xs³, ys⁶) = case xs³ of {
//│ 	LH_C h⁵ t⁵ => 
//│ 		let tx² = mappend_lh_₁(t⁵, ys⁶)
//│ 		in let hx² = h⁵
//│ 		in (fun f⁵ -> (fun ys⁷ -> case ys⁷ of {
//│ 			LH_C hy³ ty³ => [LH_C f⁵(hx², hy³) tx²(f⁵, ty³)]
//│ 			| LH_N  => [LH_N]}))
//│ 	| LH_N  => ys⁶}
//│ def neg_powers_lh_₁ = lazy⁰(map_lz_lh_₂((fun ys¹ -> lazy⁰(force⁰(iterate_lh_₁(not⁰, [True]), (fun n¹ -> (fun x⁰ -> if n¹ then x⁰ else (0 - x⁰))), ys¹))), powers_lh_₁))
//│ def pascal_lh_₁ = lazy⁰([LH_C [LH_C 1 [LH_C 2 [LH_C 1 [LH_N]]]] map_lz_lh_₁((fun line⁰ -> mappend_lh_₁(line⁰, 
//│ 	let tx³ = (fun f⁷ -> (fun ys⁹ -> [LH_N]))
//│ 	in let hx³ = 0
//│ 	in (fun f⁸ -> (fun ys¹⁰ -> case ys¹⁰ of {
//│ 		LH_C hy⁵ ty⁵ => [LH_C f⁸(hx³, hy⁵) tx³(f⁸, ty⁵)]
//│ 		| LH_N  => [LH_N]})), (fun a¹⁰ -> (fun b³ -> (a¹⁰ + b³))), [LH_C 0 line⁰])), pascal_lh_₁)])
//│ def powers_lh_₁ = lazy⁰([LH_C enumFrom_lh_₁(2) map_lz_lh_₃((fun p⁰ -> zipWith_lz_lz_lh_₂((fun a⁰ -> (fun b⁰ -> (a⁰ * b⁰))), head_lz_lh_₁(powers_lh_₁), p⁰)), powers_lh_₁)])
//│ def sumAux_lh_₁(ls³, a⁷) = ls³(a⁷)
//│ def sumAux_lh_₂(ls⁵, a⁸) = ls⁵(a⁸)
//│ def sum_lh_₁(ls⁸) = ls⁸(0)
//│ def sum_lh_₂(ls¹) = ls¹(0)
//│ def tail_lh_₁(ls⁹) = case ls⁹ of {
//│ 	LH_C h⁷ t⁷ => t⁷
//│ 	| LH_N  => error⁰}
//│ def tail_lh_₂(ls⁷) = case ls⁷ of {
//│ 	LH_C h⁶ t⁶ => t⁶
//│ 	| LH_N  => error⁰}
//│ def testBernoulli_nofib_lh_₁(_lh_testBernoulli_nofib_arg1⁰) = case _lh_testBernoulli_nofib_arg1⁰ of {
//│ 	0  => 1
//│ 	| 1  => (0 - (1 / 2))
//│ 	| _  => if ((_lh_testBernoulli_nofib_arg1⁰ % 2) == 1) then 0 else 
//│ 		let powers⁴ = if ((_lh_testBernoulli_nofib_arg1⁰ - 1) < 0) then error⁰ else force⁰(force⁰(neg_powers_lh_₁), (_lh_testBernoulli_nofib_arg1⁰ - 1))
//│ 		in (((0 - 1) / 2) + sum_lh_₁(
//│ 			let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁰ -> _lh_listcomp_fun_para⁰(_lh_listcomp_fun⁴, powers⁴))
//│ 			in _lh_listcomp_fun⁴(enumFromTo_lh_₁(2, _lh_testBernoulli_nofib_arg1⁰, pascal_lh_₁))))}
//│ def zipWith_lh_₁(f², xs¹, ys⁴) = xs¹(f², ys⁴)
//│ def zipWith_lz_lz_lh_₁(f⁹, xs⁵, ys¹¹) = lazy⁰(force⁰(xs⁵, f⁹, ys¹¹))
//│ def zipWith_lz_lz_lh_₂(f⁰, xs⁰, ys⁰) = lazy⁰(case force⁰(xs⁰) of {
//│ 	LH_C hx⁰ tx⁰ => case force⁰(ys⁰) of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C f⁰(hx⁰, hy⁰) zipWith_lz_lz_lh_₂(f⁰, tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]})
//│ def zipWith_lz_nl_lh_₁(f⁶, xs⁴, ys⁸) = case ys⁸ of {
//│ 	LH_C hy⁴ ty⁴ => force⁰(xs⁴, f⁶, hy⁴, ty⁴)
//│ 	| LH_N  => (fun a⁹ -> a⁹)}
//│ def zip_nl_lz_lh_₁(xs², ys⁵) = xs²(ys⁵)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

