:NewParser
:ParseOnly


fun f(xs, a) = primitive(
  if xs is
    C(h, t) then primitive(h)(t)(a)
)
f(C(1, C(2, N)))
//│ |#fun| |f|(|xs|,| |a|)| |#=| |primitive|(|→|#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |primitive|(|h|)|(|t|)|(|a|)|←|←|↵|)|↵|f|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun f = xs, a, => primitive (if xs is ‹(C (h, t,)) then primitive (h,) (t,) (a,)›,); f (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^14([C 1 [C 2 [N]]])
//│ def f(xs⁰, a⁰) = primitive⁰(case xs⁰ of {
//│ 	C h⁰ t⁰ => primitive⁰(h⁰, t⁰, a⁰)})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^14] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀([C 1 [C 2 [N]]])
//│ def f_₀(xs¹, a¹) = 
//│ 	primitive⁰(case xs¹ of {
//│ 		C h¹ t¹ => primitive⁰(h¹, t¹, a¹)})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case xs¹ of {C h¹ t¹ => primitive⁰(h¹, t¹, a¹)}: 30
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => primitive⁰(h¹, t¹, a¹)}: 30 --->
//│ 	[C 1 [C 2 [N]]]: 39
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case xs¹ of {C h¹ t¹ => primitive⁰(h¹, t¹, a¹)}: 30
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => primitive⁰(h¹, t¹, a¹)}: 30 --->
//│ 	[C 1 [C 2 [N]]]: 39
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀(
//│ 	let t² = [C 2 [N]]
//│ 	in let h² = 1
//│ 	in (fun a² -> primitive⁰(h², t², a²)))
//│ def f_₀(xs², a³) = 
//│ 	primitive⁰(xs²(a³))
//│ <<<<<<< after fusion <<<<<<<

fun f(xs, a) = primitive(
  if xs is
    C(h, t) then primitive(h)(t)(a)
)
let cs = C(1, C(2, cs))
f(cs)
//│ |#fun| |f|(|xs|,| |a|)| |#=| |primitive|(|→|#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |primitive|(|h|)|(|t|)|(|a|)|←|←|↵|)|↵|#let| |cs| |#=| |C|(|1|,| |C|(|2|,| |cs|)|)|↵|f|(|cs|)|
//│ Parsed: {fun f = xs, a, => primitive (if xs is ‹(C (h, t,)) then primitive (h,) (t,) (a,)›,); let cs = C (1, C (2, cs,),); f (cs,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^19(cs^20)
//│ def cs = [C 1 [C 2 cs^16]]
//│ def f(xs⁰, a⁰) = primitive⁰(case xs⁰ of {
//│ 	C h⁰ t⁰ => primitive⁰(h⁰, t⁰, a⁰)})
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [cs^20]
//│ 	[cs^20 · cs^16] ---> [cs^20] (only one)
//│ [f^19] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀(cs_₀)
//│ def cs_₀ = 
//│ 	[C 1 [C 2 cs_₀]]
//│ def f_₀(xs¹, a¹) = 
//│ 	primitive⁰(case xs¹ of {
//│ 		C h¹ t¹ => primitive⁰(h¹, t¹, a¹)})
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 cs_₀]]: 26 --->
//│ 	NoCons
//│ 	case xs¹ of {C h¹ t¹ => primitive⁰(h¹, t¹, a¹)}: 36
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => primitive⁰(h¹, t¹, a¹)}: 36 --->
//│ 	[C 1 [C 2 cs_₀]]: 26
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀(cs_₀)
//│ def cs_₀ = 
//│ 	[C 1 [C 2 cs_₀]]
//│ def f_₀(xs², a²) = 
//│ 	primitive⁰(case xs² of {
//│ 		C h¹ t¹ => primitive⁰(h¹, t¹, a²)})
//│ <<<<<<< after fusion <<<<<<<


_LUMBERHACK_EVAL
fun f(xs, a) = primitive(
  if xs is
    C(h, t) then primitive(h)(f(t, a))(a)
    N then primitive(a)
)
fun g(init) = if init > 0
  then C(1, g(init - 1))
  else N 
f(g(42))(0)
//│ |_LUMBERHACK_EVAL|↵|#fun| |f|(|xs|,| |a|)| |#=| |primitive|(|→|#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |primitive|(|h|)|(|f|(|t|,| |a|)|)|(|a|)|↵|N| |#then| |primitive|(|a|)|←|←|↵|)|↵|#fun| |g|(|init|)| |#=| |#if| |init| |>| |0|→|#then| |C|(|1|,| |g|(|init| |-| |1|)|)|↵|#else| |N| |←|↵|f|(|g|(|42|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun f = xs, a, => primitive (if xs is ‹(C (h, t,)) then primitive (h,) (f (t, a,),) (a,); (N) then primitive (a,)›,); fun g = init, => if (> (init,) (0,)) then C (1, g (- (init,) (1,),),) else N; f (g (42,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^38(g^39(42), 0)
//│ def f(xs⁰, a⁰) = primitive⁰(case xs⁰ of {
//│ 	C h⁰ t⁰ => primitive⁰(h⁰, f^6(t⁰, a⁰), a⁰)
//│ 	| N  => primitive⁰(a⁰)})
//│ def g(init⁰) = if (init⁰ > 0) then [C 1 g^27((init⁰ - 1))] else [N]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0))
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^38]
//│ 	[f^38 · f^6] ---> [f^38] (only one)
//│ [g^39]
//│ 	[g^39 · g^27] ---> [g^39] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀(g_₀(42), 0)
//│ def f_₀(xs¹, a¹) = 
//│ 	primitive⁰(case xs¹ of {
//│ 		C h¹ t¹ => primitive⁰(h¹, f_₀(t¹, a¹), a¹)
//│ 		| N  => primitive⁰(a¹)})
//│ def g_₀(init¹) = 
//│ 	if (init¹ > 0) then [C 1 g_₀((init¹ - 1))] else [N]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 g_₀((init¹ - 1))]: 78 --->
//│ 	case xs¹ of {C h¹ t¹ => primitive⁰(h¹, f_₀(t¹, a¹), a¹) | N  => primitive⁰(a¹)}: 61
//│ [N]: 79 --->
//│ 	case xs¹ of {C h¹ t¹ => primitive⁰(h¹, f_₀(t¹, a¹), a¹) | N  => primitive⁰(a¹)}: 61
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => primitive⁰(h¹, f_₀(t¹, a¹), a¹) | N  => primitive⁰(a¹)}: 61 --->
//│ 	[C 1 g_₀((init¹ - 1))]: 78
//│ 	[N]: 79
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 g_₀((init¹ - 1))]: 78 --->
//│ 	case xs¹ of {C h¹ t¹ => primitive⁰(h¹, f_₀(t¹, a¹), a¹) | N  => primitive⁰(a¹)}: 61
//│ [N]: 79 --->
//│ 	case xs¹ of {C h¹ t¹ => primitive⁰(h¹, f_₀(t¹, a¹), a¹) | N  => primitive⁰(a¹)}: 61
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => primitive⁰(h¹, f_₀(t¹, a¹), a¹) | N  => primitive⁰(a¹)}: 61 --->
//│ 	[C 1 g_₀((init¹ - 1))]: 78
//│ 	[N]: 79
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀(g_₀(42), 0)
//│ def f_₀(xs², a²) = 
//│ 	primitive⁰(xs²(a²))
//│ def g_₀(init²) = 
//│ 	if (init² > 0) then 
//│ 		let t² = g_₀((init² - 1))
//│ 		in let h² = 1
//│ 		in (fun a³ -> primitive⁰(h², f_₀(t², a³), a³)) else (fun a⁴ -> primitive⁰(a⁴))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0)), 0))
//│ <<<<<<< evaluate <<<<<<<

_LUMBERHACK_EVAL
fun f(xs, a) = primitive(
  if xs is
    C(h, t) then primitive(h)(f(t, a + 1))(a)
    N then primitive(a)
)
fun g(init) = if init > 0
  then C(1, g(init - 1))
  else N
f(g(42))(0)
//│ |_LUMBERHACK_EVAL|↵|#fun| |f|(|xs|,| |a|)| |#=| |primitive|(|→|#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |primitive|(|h|)|(|f|(|t|,| |a| |+| |1|)|)|(|a|)|↵|N| |#then| |primitive|(|a|)|←|←|↵|)|↵|#fun| |g|(|init|)| |#=| |#if| |init| |>| |0|→|#then| |C|(|1|,| |g|(|init| |-| |1|)|)|↵|#else| |N|←|↵|f|(|g|(|42|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun f = xs, a, => primitive (if xs is ‹(C (h, t,)) then primitive (h,) (f (t, + (a,) (1,),),) (a,); (N) then primitive (a,)›,); fun g = init, => if (> (init,) (0,)) then C (1, g (- (init,) (1,),),) else N; f (g (42,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^42(g^43(42), 0)
//│ def f(xs⁰, a⁰) = primitive⁰(case xs⁰ of {
//│ 	C h⁰ t⁰ => primitive⁰(h⁰, f^6(t⁰, (a⁰ + 1)), a⁰)
//│ 	| N  => primitive⁰(a⁰)})
//│ def g(init⁰) = if (init⁰ > 0) then [C 1 g^31((init⁰ - 1))] else [N]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(42)), 41)), 40)), 39)), 38)), 37)), 36)), 35)), 34)), 33)), 32)), 31)), 30)), 29)), 28)), 27)), 26)), 25)), 24)), 23)), 22)), 21)), 20)), 19)), 18)), 17)), 16)), 15)), 14)), 13)), 12)), 11)), 10)), 9)), 8)), 7)), 6)), 5)), 4)), 3)), 2)), 1)), 0))
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^42]
//│ 	[f^42 · f^6] ---> [f^42] (only one)
//│ [g^43]
//│ 	[g^43 · g^31] ---> [g^43] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀(g_₀(42), 0)
//│ def f_₀(xs¹, a¹) = 
//│ 	primitive⁰(case xs¹ of {
//│ 		C h¹ t¹ => primitive⁰(h¹, f_₀(t¹, (a¹ + 1)), a¹)
//│ 		| N  => primitive⁰(a¹)})
//│ def g_₀(init¹) = 
//│ 	if (init¹ > 0) then [C 1 g_₀((init¹ - 1))] else [N]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 g_₀((init¹ - 1))]: 86 --->
//│ 	case xs¹ of {C h¹ t¹ => primitive⁰(h¹, f_₀(t¹, (a¹ + 1)), a¹) | N  => primitive⁰(a¹)}: 69
//│ [N]: 87 --->
//│ 	case xs¹ of {C h¹ t¹ => primitive⁰(h¹, f_₀(t¹, (a¹ + 1)), a¹) | N  => primitive⁰(a¹)}: 69
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => primitive⁰(h¹, f_₀(t¹, (a¹ + 1)), a¹) | N  => primitive⁰(a¹)}: 69 --->
//│ 	[C 1 g_₀((init¹ - 1))]: 86
//│ 	[N]: 87
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 g_₀((init¹ - 1))]: 86 --->
//│ 	case xs¹ of {C h¹ t¹ => primitive⁰(h¹, f_₀(t¹, (a¹ + 1)), a¹) | N  => primitive⁰(a¹)}: 69
//│ [N]: 87 --->
//│ 	case xs¹ of {C h¹ t¹ => primitive⁰(h¹, f_₀(t¹, (a¹ + 1)), a¹) | N  => primitive⁰(a¹)}: 69
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => primitive⁰(h¹, f_₀(t¹, (a¹ + 1)), a¹) | N  => primitive⁰(a¹)}: 69 --->
//│ 	[C 1 g_₀((init¹ - 1))]: 86
//│ 	[N]: 87
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀(g_₀(42), 0)
//│ def f_₀(xs², a²) = 
//│ 	primitive⁰(xs²(a²))
//│ def g_₀(init²) = 
//│ 	if (init² > 0) then 
//│ 		let t² = g_₀((init² - 1))
//│ 		in let h² = 1
//│ 		in (fun a³ -> primitive⁰(h², f_₀(t², (a³ + 1)), a³)) else (fun a⁴ -> primitive⁰(a⁴))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(1, primitive⁰(primitive⁰(42)), 41)), 40)), 39)), 38)), 37)), 36)), 35)), 34)), 33)), 32)), 31)), 30)), 29)), 28)), 27)), 26)), 25)), 24)), 23)), 22)), 21)), 20)), 19)), 18)), 17)), 16)), 15)), 14)), 13)), 12)), 11)), 10)), 9)), 8)), 7)), 6)), 5)), 4)), 3)), 2)), 1)), 0))
//│ <<<<<<< evaluate <<<<<<<


// TODO: why '54_callres
_LUMBERHACK_EVAL
fun f(xs, a) = primitive(
  if xs is
    C(h, t) then primitive(h)(t)(a)
    N then primitive(a)
)
fun g(init) = if init > 0
  then C(1, C(2, g(init - 1)))
  else N
f(g(42))(0)
//│ |_LUMBERHACK_EVAL|↵|#fun| |f|(|xs|,| |a|)| |#=| |primitive|(|→|#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |primitive|(|h|)|(|t|)|(|a|)|↵|N| |#then| |primitive|(|a|)|←|←|↵|)|↵|#fun| |g|(|init|)| |#=| |#if| |init| |>| |0|→|#then| |C|(|1|,| |C|(|2|,| |g|(|init| |-| |1|)|)|)|↵|#else| |N|←|↵|f|(|g|(|42|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun f = xs, a, => primitive (if xs is ‹(C (h, t,)) then primitive (h,) (t,) (a,); (N) then primitive (a,)›,); fun g = init, => if (> (init,) (0,)) then C (1, C (2, g (- (init,) (1,),),),) else N; f (g (42,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^36(g^37(42), 0)
//│ def f(xs⁰, a⁰) = primitive⁰(case xs⁰ of {
//│ 	C h⁰ t⁰ => primitive⁰(h⁰, t⁰, a⁰)
//│ 	| N  => primitive⁰(a⁰)})
//│ def g(init⁰) = if (init⁰ > 0) then [C 1 [C 2 g^24((init⁰ - 1))]] else [N]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ primitive⁰(primitive⁰(1, [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]], 0))
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^36] (hopeless to continue)
//│ [g^37]
//│ 	[g^37 · g^24] ---> [g^37] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ f_₀(g_₀(42), 0)
//│ def f_₀(xs¹, a¹) = 
//│ 	primitive⁰(case xs¹ of {
//│ 		C h¹ t¹ => primitive⁰(h¹, t¹, a¹)
//│ 		| N  => primitive⁰(a¹)})
//│ def g_₀(init¹) = 
//│ 	if (init¹ > 0) then [C 1 [C 2 g_₀((init¹ - 1))]] else [N]
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 g_₀((init¹ - 1))]]: 58 --->
//│ 	NoCons
//│ 	case xs¹ of {C h¹ t¹ => primitive⁰(h¹, t¹, a¹) | N  => primitive⁰(a¹)}: 74
//│ [N]: 59 --->
//│ 	NoCons
//│ 	case xs¹ of {C h¹ t¹ => primitive⁰(h¹, t¹, a¹) | N  => primitive⁰(a¹)}: 74
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => primitive⁰(h¹, t¹, a¹) | N  => primitive⁰(a¹)}: 74 --->
//│ 	[C 1 [C 2 g_₀((init¹ - 1))]]: 58
//│ 	[N]: 59
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f_₀(g_₀(42), 0)
//│ def f_₀(xs², a²) = 
//│ 	primitive⁰(case xs² of {
//│ 		C h¹ t¹ => primitive⁰(h¹, t¹, a²)
//│ 		| N  => primitive⁰(a²)})
//│ def g_₀(init²) = 
//│ 	if (init² > 0) then [C 1 [C 2 g_₀((init² - 1))]] else [N]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ primitive⁰(primitive⁰(1, [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]], 0))
//│ <<<<<<< evaluate <<<<<<<



