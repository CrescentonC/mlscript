:NewParser
:ParseOnly


fun f(xs, a) = primitive(
  if xs is
    C(h, t) then primitive(h)(t)(a)
)
f(C(1, C(2, N)))
//│ |#fun| |f|(|xs|,| |a|)| |#=| |primitive|(|→|#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |primitive|(|h|)|(|t|)|(|a|)|←|←|↵|)|↵|f|(|C|(|1|,| |C|(|2|,| |N|)|)|)|
//│ Parsed: {fun f = xs, a, => primitive (if xs is ‹(C (h, t,)) then primitive (h,) (t,) (a,)›,); f (C (1, C (2, N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^14 [C 1 [C 2 [N]]])
//│ def f = (fun xs⁰ -> (fun a⁰ -> (primitive⁰ case xs⁰ of {
//│ 	C h⁰ t⁰ => (((primitive⁰ h⁰) t⁰) a⁰)})))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^14] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ [C 1 [C 2 [N]]])
//│ def f₀ = 
//│ 	(fun xs¹ -> (fun a¹ -> (primitive⁰ case xs¹ of {
//│ 		C h¹ t¹ => (((primitive⁰ h¹) t¹) a¹)})))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) t¹) a¹)}: 30
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) t¹) a¹)}: 30 --->
//│ 	[C 1 [C 2 [N]]]: 39
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 [C 2 [N]]]: 39 --->
//│ 	case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) t¹) a¹)}: 30
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) t¹) a¹)}: 30 --->
//│ 	[C 1 [C 2 [N]]]: 39
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ 
//│ 	let h² = 1
//│ 	in let t² = [C 2 [N]]
//│ 	in (fun a² -> (((primitive⁰ h²) t²) a²)))
//│ def f₀ = 
//│ 	(fun xs² -> (fun a³ -> (primitive⁰ (xs² a³))))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀₀ 
//│ 	let h¹ = 1
//│ 	in let t¹ = [C 2 [N]]
//│ 	in (fun a³ -> (((primitive⁰ h¹) t¹) a³)))
//│ def f₀₀ = 
//│ 	(fun xs¹ -> (fun a² -> (primitive⁰ (xs¹ a²))))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀₀ 
//│ 	let h¹ = 1
//│ 	in let t¹ = [C 2 [N]]
//│ 	in (fun a⁴ -> (((primitive⁰ h¹) t¹) a⁴)))
//│ def f₀₀ = 
//│ 	(fun xs² -> (fun a⁵ -> (primitive⁰ (xs² a⁵))))
//│ <<<<<<< after fusion <<<<<<<

fun f(xs, a) = primitive(
  if xs is
    C(h, t) then primitive(h)(t)(a)
)
let cs = C(1, C(2, cs))
f(cs)
//│ |#fun| |f|(|xs|,| |a|)| |#=| |primitive|(|→|#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |primitive|(|h|)|(|t|)|(|a|)|←|←|↵|)|↵|#let| |cs| |#=| |C|(|1|,| |C|(|2|,| |cs|)|)|↵|f|(|cs|)|
//│ Parsed: {fun f = xs, a, => primitive (if xs is ‹(C (h, t,)) then primitive (h,) (t,) (a,)›,); let cs = C (1, C (2, cs,),); f (cs,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (f^19 cs^20)
//│ def cs = [C 1 [C 2 cs^16]]
//│ def f = (fun xs⁰ -> (fun a⁰ -> (primitive⁰ case xs⁰ of {
//│ 	C h⁰ t⁰ => (((primitive⁰ h⁰) t⁰) a⁰)})))
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [cs^20] (hopeless to continue)
//│ 	[cs^20 · cs^16] ---> [cs^20] (using original def)
//│ [f^19] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀ cs₀)
//│ def cs₀ = 
//│ 	[C 1 [C 2 cs₀]]
//│ def f₀ = 
//│ 	(fun xs¹ -> (fun a¹ -> (primitive⁰ case xs¹ of {
//│ 		C h¹ t¹ => (((primitive⁰ h¹) t¹) a¹)})))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 cs₀]]: 26 --->
//│ 	case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) t¹) a¹)}: 36
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) t¹) a¹)}: 36 --->
//│ 	[C 1 [C 2 cs₀]]: 26
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 [C 2 cs₀]]: 26 --->
//│ 	case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) t¹) a¹)}: 36
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) t¹) a¹)}: 36 --->
//│ 	[C 1 [C 2 cs₀]]: 26
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀ cs₀)
//│ def cs₀ = 
//│ 	let h² = 1
//│ 	in let t² = [C 2 cs₀]
//│ 	in (fun a² -> (((primitive⁰ h²) t²) a²))
//│ def f₀ = 
//│ 	(fun xs² -> (fun a³ -> (primitive⁰ (xs² a³))))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [cs₀^2] (hopeless to continue)
//│ 	[cs₀^2 · cs₀^6] ---> [cs₀^2] (using original def)
//│ [f₀^1] (hopeless to continue)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ (f₀₀ cs₀₀)
//│ def cs₀₀ = 
//│ 	let h¹ = 1
//│ 	in let t¹ = [C 2 cs₀₀]
//│ 	in (fun a³ -> (((primitive⁰ h¹) t¹) a³))
//│ def f₀₀ = 
//│ 	(fun xs¹ -> (fun a² -> (primitive⁰ (xs¹ a²))))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ (f₀₀ cs₀₀)
//│ def cs₀₀ = 
//│ 	let h¹ = 1
//│ 	in let t¹ = [C 2 cs₀₀]
//│ 	in (fun a⁵ -> (((primitive⁰ h¹) t¹) a⁵))
//│ def f₀₀ = 
//│ 	(fun xs² -> (fun a⁴ -> (primitive⁰ (xs² a⁴))))
//│ <<<<<<< after fusion <<<<<<<


_LUMBERHACK_EVAL
fun f(xs, a) = primitive(
  if xs is
    C(h, t) then primitive(h)(f(t, a))(a)
    N then primitive(a)
)
fun g(init) = if init > 0
  then C(1, g(init - 1))
  else N 
f(g(42))(0)
//│ |_LUMBERHACK_EVAL|↵|#fun| |f|(|xs|,| |a|)| |#=| |primitive|(|→|#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |primitive|(|h|)|(|f|(|t|,| |a|)|)|(|a|)|↵|N| |#then| |primitive|(|a|)|←|←|↵|)|↵|#fun| |g|(|init|)| |#=| |#if| |init| |>| |0|→|#then| |C|(|1|,| |g|(|init| |-| |1|)|)|↵|#else| |N| |←|↵|f|(|g|(|42|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun f = xs, a, => primitive (if xs is ‹(C (h, t,)) then primitive (h,) (f (t, a,),) (a,); (N) then primitive (a,)›,); fun g = init, => if (> (init,) (0,)) then C (1, g (- (init,) (1,),),) else N; f (g (42,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((f^38 (g^39 42)) 0)
//│ def f = (fun xs⁰ -> (fun a⁰ -> (primitive⁰ case xs⁰ of {
//│ 	C h⁰ t⁰ => (((primitive⁰ h⁰) ((f^6 t⁰) a⁰)) a⁰)
//│ 	| N => (primitive⁰ a⁰)})))
//│ def g = (fun init⁰ -> if (init⁰ > 0) then [C 1 (g^27 (init⁰ - 1))] else [N])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^38]
//│ 	[f^38 · f^6] ---> [f^38] (only one)
//│ [g^39]
//│ 	[g^39 · g^27] ---> [g^39] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((f₀ (g₀ 42)) 0)
//│ def f₀ = 
//│ 	(fun xs¹ -> (fun a¹ -> (primitive⁰ case xs¹ of {
//│ 		C h¹ t¹ => (((primitive⁰ h¹) ((f₀ t¹) a¹)) a¹)
//│ 		| N => (primitive⁰ a¹)})))
//│ def g₀ = 
//│ 	(fun init¹ -> if (init¹ > 0) then [C 1 (g₀ (init¹ - 1))] else [N])
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 (g₀ (init¹ - 1))]: 78 --->
//│ 	case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) ((f₀ t¹) a¹)) a¹) | N => (primitive⁰ a¹)}: 61
//│ [N]: 79 --->
//│ 	case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) ((f₀ t¹) a¹)) a¹) | N => (primitive⁰ a¹)}: 61
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) ((f₀ t¹) a¹)) a¹) | N => (primitive⁰ a¹)}: 61 --->
//│ 	[C 1 (g₀ (init¹ - 1))]: 78
//│ 	[N]: 79
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 (g₀ (init¹ - 1))]: 78 --->
//│ 	case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) ((f₀ t¹) a¹)) a¹) | N => (primitive⁰ a¹)}: 61
//│ [N]: 79 --->
//│ 	case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) ((f₀ t¹) a¹)) a¹) | N => (primitive⁰ a¹)}: 61
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) ((f₀ t¹) a¹)) a¹) | N => (primitive⁰ a¹)}: 61 --->
//│ 	[C 1 (g₀ (init¹ - 1))]: 78
//│ 	[N]: 79
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((f₀ (g₀ 42)) 0)
//│ def f₀ = 
//│ 	(fun xs² -> (fun a² -> (primitive⁰ (xs² a²))))
//│ def g₀ = 
//│ 	(fun init² -> if (init² > 0) then 
//│ 		let h² = 1
//│ 		in let t² = (g₀ (init² - 1))
//│ 		in (fun a³ -> (((primitive⁰ h²) ((f₀ t²) a³)) a³)) else (fun a⁴ -> (primitive⁰ a⁴)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (primitive⁰ 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f₀^1] (hopeless to continue)
//│ [g₀^2] (hopeless to continue)
//│ 	[g₀^2 · f₀^31] (using original def)
//│ 	[g₀^2 · g₀^21] ---> [g₀^2] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((f₀₀ (g₀₀ 42)) 0)
//│ def f₀₀ = 
//│ 	(fun xs¹ -> (fun a³ -> (primitive⁰ (xs¹ a³))))
//│ def g₀₀ = 
//│ 	(fun init¹ -> if (init¹ > 0) then 
//│ 		let h¹ = 1
//│ 		in let t¹ = (g₀₀ (init¹ - 1))
//│ 		in (fun a⁴ -> (((primitive⁰ h¹) ((f₀₁ t¹) a⁴)) a⁴)) else (fun a⁵ -> (primitive⁰ a⁵)))
//│ 	where
//│ 	def f₀₁ = 
//│ 		(fun xs² -> (fun a⁶ -> (primitive⁰ (xs² a⁶))))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((f₀₀ (g₀₀ 42)) 0)
//│ def f₀₀ = 
//│ 	(fun xs³ -> (fun a⁷ -> (primitive⁰ (xs³ a⁷))))
//│ def g₀₀ = 
//│ 	(fun init² -> if (init² > 0) then 
//│ 		let h¹ = 1
//│ 		in let t¹ = (g₀₀ (init² - 1))
//│ 		in (fun a⁸ -> (((primitive⁰ h¹) ((f₀₁ t¹) a⁸)) a⁸)) else (fun a⁹ -> (primitive⁰ a⁹)))
//│ 	where
//│ 	def f₀₁ = 
//│ 		(fun xs⁴ -> (fun a¹⁰ -> (primitive⁰ (xs⁴ a¹⁰))))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (primitive⁰ 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))) 0))
//│ <<<<<<< evaluate <<<<<<<

_LUMBERHACK_EVAL
fun f(xs, a) = primitive(
  if xs is
    C(h, t) then primitive(h)(f(t, a + 1))(a)
    N then primitive(a)
)
fun g(init) = if init > 0
  then C(1, g(init - 1))
  else N
f(g(42))(0)
//│ |_LUMBERHACK_EVAL|↵|#fun| |f|(|xs|,| |a|)| |#=| |primitive|(|→|#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |primitive|(|h|)|(|f|(|t|,| |a| |+| |1|)|)|(|a|)|↵|N| |#then| |primitive|(|a|)|←|←|↵|)|↵|#fun| |g|(|init|)| |#=| |#if| |init| |>| |0|→|#then| |C|(|1|,| |g|(|init| |-| |1|)|)|↵|#else| |N|←|↵|f|(|g|(|42|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun f = xs, a, => primitive (if xs is ‹(C (h, t,)) then primitive (h,) (f (t, + (a,) (1,),),) (a,); (N) then primitive (a,)›,); fun g = init, => if (> (init,) (0,)) then C (1, g (- (init,) (1,),),) else N; f (g (42,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((f^42 (g^43 42)) 0)
//│ def f = (fun xs⁰ -> (fun a⁰ -> (primitive⁰ case xs⁰ of {
//│ 	C h⁰ t⁰ => (((primitive⁰ h⁰) ((f^6 t⁰) (a⁰ + 1))) a⁰)
//│ 	| N => (primitive⁰ a⁰)})))
//│ def g = (fun init⁰ -> if (init⁰ > 0) then [C 1 (g^31 (init⁰ - 1))] else [N])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^42]
//│ 	[f^42 · f^6] ---> [f^42] (only one)
//│ [g^43]
//│ 	[g^43 · g^31] ---> [g^43] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((f₀ (g₀ 42)) 0)
//│ def f₀ = 
//│ 	(fun xs¹ -> (fun a¹ -> (primitive⁰ case xs¹ of {
//│ 		C h¹ t¹ => (((primitive⁰ h¹) ((f₀ t¹) (a¹ + 1))) a¹)
//│ 		| N => (primitive⁰ a¹)})))
//│ def g₀ = 
//│ 	(fun init¹ -> if (init¹ > 0) then [C 1 (g₀ (init¹ - 1))] else [N])
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 (g₀ (init¹ - 1))]: 86 --->
//│ 	case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) ((f₀ t¹) (a¹ + 1))) a¹) | N => (primitive⁰ a¹)}: 69
//│ [N]: 87 --->
//│ 	case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) ((f₀ t¹) (a¹ + 1))) a¹) | N => (primitive⁰ a¹)}: 69
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) ((f₀ t¹) (a¹ + 1))) a¹) | N => (primitive⁰ a¹)}: 69 --->
//│ 	[C 1 (g₀ (init¹ - 1))]: 86
//│ 	[N]: 87
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 (g₀ (init¹ - 1))]: 86 --->
//│ 	case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) ((f₀ t¹) (a¹ + 1))) a¹) | N => (primitive⁰ a¹)}: 69
//│ [N]: 87 --->
//│ 	case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) ((f₀ t¹) (a¹ + 1))) a¹) | N => (primitive⁰ a¹)}: 69
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) ((f₀ t¹) (a¹ + 1))) a¹) | N => (primitive⁰ a¹)}: 69 --->
//│ 	[C 1 (g₀ (init¹ - 1))]: 86
//│ 	[N]: 87
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((f₀ (g₀ 42)) 0)
//│ def f₀ = 
//│ 	(fun xs² -> (fun a² -> (primitive⁰ (xs² a²))))
//│ def g₀ = 
//│ 	(fun init² -> if (init² > 0) then 
//│ 		let h² = 1
//│ 		in let t² = (g₀ (init² - 1))
//│ 		in (fun a³ -> (((primitive⁰ h²) ((f₀ t²) (a³ + 1))) a³)) else (fun a⁴ -> (primitive⁰ a⁴)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (primitive⁰ 42))) 41))) 40))) 39))) 38))) 37))) 36))) 35))) 34))) 33))) 32))) 31))) 30))) 29))) 28))) 27))) 26))) 25))) 24))) 23))) 22))) 21))) 20))) 19))) 18))) 17))) 16))) 15))) 14))) 13))) 12))) 11))) 10))) 9))) 8))) 7))) 6))) 5))) 4))) 3))) 2))) 1))) 0))
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ ~~~~~~~~~~~~~~~~~~~~~~~ NEXT ITERATION ~~~~~~~~~~~~~~~~~~~~~~~
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f₀^1] (hopeless to continue)
//│ [g₀^2] (hopeless to continue)
//│ 	[g₀^2 · f₀^31] (using original def)
//│ 	[g₀^2 · g₀^21] ---> [g₀^2] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((f₀₀ (g₀₀ 42)) 0)
//│ def f₀₀ = 
//│ 	(fun xs¹ -> (fun a³ -> (primitive⁰ (xs¹ a³))))
//│ def g₀₀ = 
//│ 	(fun init¹ -> if (init¹ > 0) then 
//│ 		let h¹ = 1
//│ 		in let t¹ = (g₀₀ (init¹ - 1))
//│ 		in (fun a⁴ -> (((primitive⁰ h¹) ((f₀₁ t¹) (a⁴ + 1))) a⁴)) else (fun a⁵ -> (primitive⁰ a⁵)))
//│ 	where
//│ 	def f₀₁ = 
//│ 		(fun xs² -> (fun a⁶ -> (primitive⁰ (xs² a⁶))))
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((f₀₀ (g₀₀ 42)) 0)
//│ def f₀₀ = 
//│ 	(fun xs³ -> (fun a⁷ -> (primitive⁰ (xs³ a⁷))))
//│ def g₀₀ = 
//│ 	(fun init² -> if (init² > 0) then 
//│ 		let h¹ = 1
//│ 		in let t¹ = (g₀₀ (init² - 1))
//│ 		in (fun a⁸ -> (((primitive⁰ h¹) ((f₀₁ t¹) (a⁸ + 1))) a⁸)) else (fun a⁹ -> (primitive⁰ a⁹)))
//│ 	where
//│ 	def f₀₁ = 
//│ 		(fun xs⁴ -> (fun a¹⁰ -> (primitive⁰ (xs⁴ a¹⁰))))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (((primitive⁰ 1) (primitive⁰ (primitive⁰ 42))) 41))) 40))) 39))) 38))) 37))) 36))) 35))) 34))) 33))) 32))) 31))) 30))) 29))) 28))) 27))) 26))) 25))) 24))) 23))) 22))) 21))) 20))) 19))) 18))) 17))) 16))) 15))) 14))) 13))) 12))) 11))) 10))) 9))) 8))) 7))) 6))) 5))) 4))) 3))) 2))) 1))) 0))
//│ <<<<<<< evaluate <<<<<<<


// TODO: why '54_callres
_LUMBERHACK_EVAL
fun f(xs, a) = primitive(
  if xs is
    C(h, t) then primitive(h)(t)(a)
    N then primitive(a)
)
fun g(init) = if init > 0
  then C(1, C(2, g(init - 1)))
  else N
f(g(42))(0)
//│ |_LUMBERHACK_EVAL|↵|#fun| |f|(|xs|,| |a|)| |#=| |primitive|(|→|#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |primitive|(|h|)|(|t|)|(|a|)|↵|N| |#then| |primitive|(|a|)|←|←|↵|)|↵|#fun| |g|(|init|)| |#=| |#if| |init| |>| |0|→|#then| |C|(|1|,| |C|(|2|,| |g|(|init| |-| |1|)|)|)|↵|#else| |N|←|↵|f|(|g|(|42|)|)|(|0|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun f = xs, a, => primitive (if xs is ‹(C (h, t,)) then primitive (h,) (t,) (a,); (N) then primitive (a,)›,); fun g = init, => if (> (init,) (0,)) then C (1, C (2, g (- (init,) (1,),),),) else N; f (g (42,),) (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ ((f^36 (g^37 42)) 0)
//│ def f = (fun xs⁰ -> (fun a⁰ -> (primitive⁰ case xs⁰ of {
//│ 	C h⁰ t⁰ => (((primitive⁰ h⁰) t⁰) a⁰)
//│ 	| N => (primitive⁰ a⁰)})))
//│ def g = (fun init⁰ -> if (init⁰ > 0) then [C 1 [C 2 (g^24 (init⁰ - 1))]] else [N])
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [f^36] (hopeless to continue)
//│ [g^37] (hopeless to continue)
//│ 	[g^37 · g^24] ---> [g^37] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ ((f₀ (g₀ 42)) 0)
//│ def f₀ = 
//│ 	(fun xs¹ -> (fun a¹ -> (primitive⁰ case xs¹ of {
//│ 		C h¹ t¹ => (((primitive⁰ h¹) t¹) a¹)
//│ 		| N => (primitive⁰ a¹)})))
//│ def g₀ = 
//│ 	(fun init¹ -> if (init¹ > 0) then [C 1 [C 2 (g₀ (init¹ - 1))]] else [N])
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [C 2 (g₀ (init¹ - 1))]]: 58 --->
//│ 	'56_callres
//│ 	case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) t¹) a¹) | N => (primitive⁰ a¹)}: 74
//│ [N]: 59 --->
//│ 	'56_callres
//│ 	case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) t¹) a¹) | N => (primitive⁰ a¹)}: 74
//│ ------------------
//│ case xs¹ of {C h¹ t¹ => (((primitive⁰ h¹) t¹) a¹) | N => (primitive⁰ a¹)}: 74 --->
//│ 	[C 1 [C 2 (g₀ (init¹ - 1))]]: 58
//│ 	[N]: 59
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ ((f₀ (g₀ 42)) 0)
//│ def f₀ = 
//│ 	(fun xs² -> (fun a² -> (primitive⁰ case xs² of {
//│ 		C h¹ t¹ => (((primitive⁰ h¹) t¹) a²)
//│ 		| N => (primitive⁰ a²)})))
//│ def g₀ = 
//│ 	(fun init² -> if (init² > 0) then [C 1 [C 2 (g₀ (init² - 1))]] else [N])
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ (primitive⁰ (((primitive⁰ 1) [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]) 0))
//│ <<<<<<< evaluate <<<<<<<



