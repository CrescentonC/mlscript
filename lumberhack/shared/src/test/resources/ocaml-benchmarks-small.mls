:NewParser
:ParseOnly


:lhInHaskell
:lhGenOCaml
testMapmapBuiltInType ls = map (\x -> x + 1) $ map (\x -> x * x) ls
testMapmapBuiltInType $ primId [1..100000]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapmapBuiltInType_lh_₁^69(primId⁰(enumFromTo_lh_₁^71(1, 100000)))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^55((a⁰ + 1), b⁰)] else [LH_N]
//│ def map_lh_₁(f¹, ls¹) = case ls¹ of {
//│ 	LH_C h¹ t¹ => [LH_C f¹(h¹) map_lh_₁^19(f¹, t¹)]
//│ 	| LH_N  => [LH_N]}
//│ def map_lh_₂(f⁰, ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₂^5(f⁰, t⁰)]
//│ 	| LH_N  => [LH_N]}
//│ def testMapmapBuiltInType_lh_₁(_lh_testMapmapBuiltInType_arg1⁰) = map_lh_₂^29((fun x⁰ -> (x⁰ + 1)), map_lh_₁^37((fun x¹ -> (x¹ * x¹)), _lh_testMapmapBuiltInType_arg1⁰))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_lh__d1 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d1 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec map_lh__d2 f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (`LH_C((f_0 h_0), ((map_lh__d2 f_0) t_0)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec map_lh__d1 f_1 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      (`LH_C((f_1 h_1), ((map_lh__d1 f_1) t_1)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec testMapmapBuiltInType_lh__d1 _lh_testMapmapBuiltInType_arg1_0 =
//│ 		  ((map_lh__d2 (fun x_0 -> 
//│ 		    (x_0 + 1))) ((map_lh__d1 (fun x_1 -> 
//│ 		    (x_1 * x_1))) _lh_testMapmapBuiltInType_arg1_0));;
//│ 		(testMapmapBuiltInType_lh__d1 ((enumFromTo_lh__d1 1) 100000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f¹(h¹) map_lh_₁(f¹, t¹)]: 24 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₂(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ [LH_N]: 25 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₂(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ ------------------
//│ case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₂(f⁰, t⁰)] | LH_N  => [LH_N]}: 12 --->
//│ 	[LH_C f¹(h¹) map_lh_₁(f¹, t¹)]: 24
//│ 	[LH_N]: 25
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f¹(h¹) map_lh_₁(f¹, t¹)]: 24 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₂(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ [LH_N]: 25 --->
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₂(f⁰, t⁰)] | LH_N  => [LH_N]}: 12
//│ ------------------
//│ case ls⁰ of {LH_C h⁰ t⁰ => [LH_C f⁰(h⁰) map_lh_₂(f⁰, t⁰)] | LH_N  => [LH_N]}: 12 --->
//│ 	[LH_C f¹(h¹) map_lh_₁(f¹, t¹)]: 24
//│ 	[LH_N]: 25
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapmapBuiltInType_lh_₁(primId⁰(enumFromTo_lh_₁(1, 100000)))
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then [LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b¹)] else [LH_N]
//│ def map_lh_₁(f³, ls³) = case ls³ of {
//│ 	LH_C h¹ t¹ => 
//│ 		let t² = map_lh_₁(f³, t¹)
//│ 		in let h² = f³(h¹)
//│ 		in (fun f⁴ -> [LH_C f⁴(h²) map_lh_₂(f⁴, t²)])
//│ 	| LH_N  => (fun f⁵ -> [LH_N])}
//│ def map_lh_₂(f², ls²) = ls²(f²)
//│ def testMapmapBuiltInType_lh_₁(_lh_testMapmapBuiltInType_arg1¹) = map_lh_₂((fun x² -> (x² + 1)), map_lh_₁((fun x³ -> (x³ * x³)), _lh_testMapmapBuiltInType_arg1¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map_lh_₂
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ map_lh_₁ -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testMapmapBuiltInType_lh_₁(primId⁰(enumFromTo_lh_₁(1, 100000)))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)] else [LH_N]
//│ def map_lh_₁(f¹, ls¹) = case ls¹ of {
//│ 	LH_C h⁰ t⁰ => 
//│ 		let t¹ = map_lh_₁(f¹, t⁰)
//│ 		in let h¹ = f¹(h⁰)
//│ 		in (fun f² -> [LH_C f²(h¹) t¹(f²)])
//│ 	| LH_N  => (fun f³ -> [LH_N])}
//│ def map_lh_₂(f⁰, ls⁰) = ls⁰(f⁰)
//│ def testMapmapBuiltInType_lh_₁(_lh_testMapmapBuiltInType_arg1⁰) = map_lh_₁((fun x⁰ -> (x⁰ * x⁰)), _lh_testMapmapBuiltInType_arg1⁰, (fun x¹ -> (x¹ + 1)))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testMapmapBuiltInType_lh_₁(primId⁰(enumFromTo_lh_₁(1, 100000)))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)] else [LH_N]
//│ def map_lh_₁(f¹, ls¹, _lh_popOutId_0⁰) = case ls¹ of {
//│ 	LH_C h⁰ t⁰ => 
//│ 		let t¹ = map_lh_₁(f¹, t⁰)
//│ 		in let h¹ = f¹(h⁰)
//│ 		in [LH_C _lh_popOutId_0⁰(h¹) t¹(_lh_popOutId_0⁰)]
//│ 	| LH_N  => [LH_N]}
//│ def map_lh_₂(f⁰, ls⁰) = ls⁰(f⁰)
//│ def testMapmapBuiltInType_lh_₁(_lh_testMapmapBuiltInType_arg1⁰) = map_lh_₁((fun x⁰ -> (x⁰ * x⁰)), _lh_testMapmapBuiltInType_arg1⁰, (fun x¹ -> (x¹ + 1)))
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

// NOTE: why manually fused version is still not faster?
:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun filter(ls, f) = if ls is
  C(h, t) then if f(h) then C(h, filter(t, f)) else filter(t, f)
  N then N
fun lastDrive(ls) = if ls is
  C(h, t) then Some(last(h, t))
  N then None
fun last(a, ls) = if ls is
  N then a
  C(h, t) then last(h, t)
fun testLastFilter(ls) = lastDrive(filter(ls, x => x < 1000))
fun _lhManualLastFilterDrive(ls, f) = if ls is
  C(h, t) then if f(h) then
    let a = _lhManualLastFilter(t, f, h)
    Some(a)
  else
    _lhManualLastFilterDrive(t, f)
  N then None
fun _lhManualLastFilter(ls, f, a) = if ls is
  C(h, t) then if f(h) then _lhManualLastFilter(t, f, h) else _lhManualLastFilter(t, f, a)
  N then a
fun testManual(ls) = _lhManualLastFilterDrive(ls, x => x < 1000)
testLastFilter(primId(enumFromTo(1, 500000)))
testManual(primId(enumFromTo(1, 500000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |filter|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |C|(|h|,| |filter|(|t|,| |f|)|)| |#else| |filter|(|t|,| |f|)|↵|N| |#then| |N|←|↵|#fun| |lastDrive|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |Some|(|last|(|h|,| |t|)|)|↵|N| |#then| |None|←|↵|#fun| |last|(|a|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a|↵|C|(|h|,| |t|)| |#then| |last|(|h|,| |t|)|←|↵|#fun| |testLastFilter|(|ls|)| |#=| |lastDrive|(|filter|(|ls|,| |x| |=>| |x| |<| |1000|)|)|↵|#fun| |_lhManualLastFilterDrive|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then|→|#let| |a| |#=| |_lhManualLastFilter|(|t|,| |f|,| |h|)|↵|Some|(|a|)|←|↵|#else|→|_lhManualLastFilterDrive|(|t|,| |f|)|←|↵|N| |#then| |None|←|↵|#fun| |_lhManualLastFilter|(|ls|,| |f|,| |a|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |_lhManualLastFilter|(|t|,| |f|,| |h|)| |#else| |_lhManualLastFilter|(|t|,| |f|,| |a|)|↵|N| |#then| |a|←|↵|#fun| |testManual|(|ls|)| |#=| |_lhManualLastFilterDrive|(|ls|,| |x| |=>| |x| |<| |1000|)|↵|testLastFilter|(|primId|(|enumFromTo|(|1|,| |500000|)|)|)|↵|testManual|(|primId|(|enumFromTo|(|1|,| |500000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun filter = ls, f, => if ls is ‹(C (h, t,)) then if (f (h,)) then C (h, filter (t, f,),) else filter (t, f,); (N) then N›; fun lastDrive = ls, => if ls is ‹(C (h, t,)) then Some (last (h, t,),); (N) then None›; fun last = a, ls, => if ls is ‹(N) then a; (C (h, t,)) then last (h, t,)›; fun testLastFilter = ls, => lastDrive (filter (ls, x, => < (x,) (1000,),),); fun _lhManualLastFilterDrive = ls, f, => if ls is ‹(C (h, t,)) then if (f (h,)) then {let a = _lhManualLastFilter (t, f, h,); Some (a,)} else {_lhManualLastFilterDrive (t, f,)}; (N) then None›; fun _lhManualLastFilter = ls, f, a, => if ls is ‹(C (h, t,)) then if (f (h,)) then _lhManualLastFilter (t, f, h,) else _lhManualLastFilter (t, f, a,); (N) then a›; fun testManual = ls, => _lhManualLastFilterDrive (ls, x, => < (x,) (1000,),); testLastFilter (primId (enumFromTo (1, 500000,),),); testManual (primId (enumFromTo (1, 500000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testLastFilter^134(primId⁰(enumFromTo^136(1, 500000)))
//│ testManual^143(primId⁰(enumFromTo^145(1, 500000)))
//│ def _lhManualLastFilter(ls⁵, f², a³) = case ls⁵ of {
//│ 	C h⁴ t⁴ => if f²(h⁴) then _lhManualLastFilter^103(t⁴, f², h⁴) else _lhManualLastFilter^110(t⁴, f², a³)
//│ 	| N  => a³}
//│ def _lhManualLastFilterDrive(ls⁴, f¹) = case ls⁴ of {
//│ 	C h³ t³ => if f¹(h³) then 
//│ 		let a² = _lhManualLastFilter^79(t³, f¹, h³)
//│ 		in [Some a²] else _lhManualLastFilterDrive^89(t³, f¹)
//│ 	| N  => [None]}
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def filter(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter^26(t⁰, f⁰)] else filter^32(t⁰, f⁰)
//│ 	| N  => [N]}
//│ def last(a¹, ls²) = case ls² of {
//│ 	N  => a¹
//│ 	| C h² t² => last^54(h², t²)}
//│ def lastDrive(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => [Some last^43(h¹, t¹)]
//│ 	| N  => [None]}
//│ def testLastFilter(ls³) = lastDrive^62(filter^63(ls³, (fun x⁰ -> (x⁰ < 1000))))
//│ def testManual(ls⁶) = _lhManualLastFilterDrive^123(ls⁶, (fun x¹ -> (x¹ < 1000)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec _lhManualLastFilter ls_5 f_2 a_3 =
//│ 		  (match ls_5 with
//│ 		    | `C(h_4, t_4) -> 
//│ 		      (if (f_2 h_4) then
//│ 		        (((_lhManualLastFilter t_4) f_2) h_4)
//│ 		      else
//│ 		        (((_lhManualLastFilter t_4) f_2) a_3))
//│ 		    | `N -> 
//│ 		      a_3);;
//│ 		let rec _lhManualLastFilterDrive ls_4 f_1 =
//│ 		  (match ls_4 with
//│ 		    | `C(h_3, t_3) -> 
//│ 		      (if (f_1 h_3) then
//│ 		        (let rec a_2 = (((_lhManualLastFilter t_3) f_1) h_3) in
//│ 		          (`Some(a_2)))
//│ 		      else
//│ 		        ((_lhManualLastFilterDrive t_3) f_1))
//│ 		    | `N -> 
//│ 		      (`None));;
//│ 		let rec testManual ls_6 =
//│ 		  ((_lhManualLastFilterDrive ls_6) (fun x_1 -> 
//│ 		    (x_1 < 1000)));;
//│ 		let rec filter ls_0 f_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (f_0 h_0) then
//│ 		        (`C(h_0, ((filter t_0) f_0)))
//│ 		      else
//│ 		        ((filter t_0) f_0))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec last a_1 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      a_1
//│ 		    | `C(h_2, t_2) -> 
//│ 		      ((last h_2) t_2));;
//│ 		let rec lastDrive ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (`Some(((last h_1) t_1)))
//│ 		    | `N -> 
//│ 		      (`None));;
//│ 		let rec testLastFilter ls_3 =
//│ 		  (lastDrive ((filter ls_3) (fun x_0 -> 
//│ 		    (x_0 < 1000))));;
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		(testLastFilter ((enumFromTo 1) 500000))
//│ 		(testManual ((enumFromTo 1) 500000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁰ filter(t⁰, f⁰)]: 31 --->
//│ 	case ls¹ of {C h¹ t¹ => [Some last(h¹, t¹)] | N  => [None]}: 50
//│ 	case ls² of {N  => a¹ | C h² t² => last(h², t²)}: 59
//│ [N]: 38 --->
//│ 	case ls¹ of {C h¹ t¹ => [Some last(h¹, t¹)] | N  => [None]}: 50
//│ 	case ls² of {N  => a¹ | C h² t² => last(h², t²)}: 59
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => [Some last(h¹, t¹)] | N  => [None]}: 50 --->
//│ 	[C h⁰ filter(t⁰, f⁰)]: 31
//│ 	[N]: 38
//│ case ls² of {N  => a¹ | C h² t² => last(h², t²)}: 59 --->
//│ 	[C h⁰ filter(t⁰, f⁰)]: 31
//│ 	[N]: 38
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testLastFilter(primId⁰(enumFromTo(1, 500000)))
//│ testManual(primId⁰(enumFromTo(1, 500000)))
//│ def _lhManualLastFilter(ls⁹, f³, a⁴) = case ls⁹ of {
//│ 	C h⁴ t⁴ => if f³(h⁴) then _lhManualLastFilter(t⁴, f³, h⁴) else _lhManualLastFilter(t⁴, f³, a⁴)
//│ 	| N  => a⁴}
//│ def _lhManualLastFilterDrive(ls¹⁰, f⁴) = case ls¹⁰ of {
//│ 	C h³ t³ => if f⁴(h³) then 
//│ 		let a⁵ = _lhManualLastFilter(t³, f⁴, h³)
//│ 		in [Some a⁵] else _lhManualLastFilterDrive(t³, f⁴)
//│ 	| N  => [None]}
//│ def enumFromTo(a⁷, b¹) = if (a⁷ <= b¹) then [C a⁷ enumFromTo((a⁷ + 1), b¹)] else [N]
//│ def filter(ls¹², f⁵) = case ls¹² of {
//│ 	C h⁰ t⁰ => if f⁵(h⁰) then [C h⁰ filter(t⁰, f⁵)] else filter(t⁰, f⁵)
//│ 	| N  => [N]}
//│ def last(a⁶, ls¹¹) = case ls¹¹ of {
//│ 	N  => a⁶
//│ 	| C h² t² => last(h², t²)}
//│ def lastDrive(ls⁷) = case ls⁷ of {
//│ 	C h¹ t¹ => [Some last(h¹, t¹)]
//│ 	| N  => [None]}
//│ def testLastFilter(ls⁸) = lastDrive(filter(ls⁸, (fun x² -> (x² < 1000))))
//│ def testManual(ls¹³) = _lhManualLastFilterDrive(ls¹³, (fun x³ -> (x³ < 1000)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testLastFilter(primId⁰(enumFromTo(1, 500000)))
//│ testManual(primId⁰(enumFromTo(1, 500000)))
//│ def _lhManualLastFilter(ls², f⁰, a⁰) = case ls² of {
//│ 	C h¹ t¹ => if f⁰(h¹) then _lhManualLastFilter(t¹, f⁰, h¹) else _lhManualLastFilter(t¹, f⁰, a⁰)
//│ 	| N  => a⁰}
//│ def _lhManualLastFilterDrive(ls³, f¹) = case ls³ of {
//│ 	C h² t² => if f¹(h²) then 
//│ 		let a¹ = _lhManualLastFilter(t², f¹, h²)
//│ 		in [Some a¹] else _lhManualLastFilterDrive(t², f¹)
//│ 	| N  => [None]}
//│ def enumFromTo(a³, b⁰) = if (a³ <= b⁰) then [C a³ enumFromTo((a³ + 1), b⁰)] else [N]
//│ def filter(ls⁵, f²) = case ls⁵ of {
//│ 	C h⁴ t⁴ => if f²(h⁴) then [C h⁴ filter(t⁴, f²)] else filter(t⁴, f²)
//│ 	| N  => [N]}
//│ def last(a², ls⁴) = case ls⁴ of {
//│ 	N  => a²
//│ 	| C h³ t³ => last(h³, t³)}
//│ def lastDrive(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [Some last(h⁰, t⁰)]
//│ 	| N  => [None]}
//│ def testLastFilter(ls¹) = lastDrive(filter(ls¹, (fun x⁰ -> (x⁰ < 1000))))
//│ def testManual(ls⁶) = _lhManualLastFilterDrive(ls⁶, (fun x¹ -> (x¹ < 1000)))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testLastFilter(primId⁰(enumFromTo(1, 500000)))
//│ testManual(primId⁰(enumFromTo(1, 500000)))
//│ def _lhManualLastFilter(ls², f⁰, a⁰) = case ls² of {
//│ 	C h¹ t¹ => if f⁰(h¹) then _lhManualLastFilter(t¹, f⁰, h¹) else _lhManualLastFilter(t¹, f⁰, a⁰)
//│ 	| N  => a⁰}
//│ def _lhManualLastFilterDrive(ls³, f¹) = case ls³ of {
//│ 	C h² t² => if f¹(h²) then 
//│ 		let a¹ = _lhManualLastFilter(t², f¹, h²)
//│ 		in [Some a¹] else _lhManualLastFilterDrive(t², f¹)
//│ 	| N  => [None]}
//│ def enumFromTo(a³, b⁰) = if (a³ <= b⁰) then [C a³ enumFromTo((a³ + 1), b⁰)] else [N]
//│ def filter(ls⁵, f²) = case ls⁵ of {
//│ 	C h⁴ t⁴ => if f²(h⁴) then [C h⁴ filter(t⁴, f²)] else filter(t⁴, f²)
//│ 	| N  => [N]}
//│ def last(a², ls⁴) = case ls⁴ of {
//│ 	N  => a²
//│ 	| C h³ t³ => last(h³, t³)}
//│ def lastDrive(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [Some last(h⁰, t⁰)]
//│ 	| N  => [None]}
//│ def testLastFilter(ls¹) = lastDrive(filter(ls¹, (fun x⁰ -> (x⁰ < 1000))))
//│ def testManual(ls⁶) = _lhManualLastFilterDrive(ls⁶, (fun x¹ -> (x¹ < 1000)))
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun filter(ls, f) = if ls is
  C(h, t) then if f(h) then C(h, filter(t, f)) else filter(t, f)
  N then N
fun lastDrive(ls) = if ls is
  C(h, t) then Some(last(h, t))
  N then None
fun last(a, ls) = if ls is
  N then a
  C(h, t) then last(h, t)
fun testLastFilterEnum(n) = lastDrive(filter(enumFromTo(1, n), x => x < 1000))
testLastFilterEnum(primId(500000))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |filter|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |C|(|h|,| |filter|(|t|,| |f|)|)| |#else| |filter|(|t|,| |f|)|↵|N| |#then| |N|←|↵|#fun| |lastDrive|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |Some|(|last|(|h|,| |t|)|)|↵|N| |#then| |None|←|↵|#fun| |last|(|a|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a|↵|C|(|h|,| |t|)| |#then| |last|(|h|,| |t|)|←|↵|#fun| |testLastFilterEnum|(|n|)| |#=| |lastDrive|(|filter|(|enumFromTo|(|1|,| |n|)|,| |x| |=>| |x| |<| |1000|)|)|↵|testLastFilterEnum|(|primId|(|500000|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun filter = ls, f, => if ls is ‹(C (h, t,)) then if (f (h,)) then C (h, filter (t, f,),) else filter (t, f,); (N) then N›; fun lastDrive = ls, => if ls is ‹(C (h, t,)) then Some (last (h, t,),); (N) then None›; fun last = a, ls, => if ls is ‹(N) then a; (C (h, t,)) then last (h, t,)›; fun testLastFilterEnum = n, => lastDrive (filter (enumFromTo (1, n,), x, => < (x,) (1000,),),); testLastFilterEnum (primId (500000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testLastFilterEnum^79(primId⁰(500000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def filter(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter^26(t⁰, f⁰)] else filter^32(t⁰, f⁰)
//│ 	| N  => [N]}
//│ def last(a¹, ls²) = case ls² of {
//│ 	N  => a¹
//│ 	| C h² t² => last^54(h², t²)}
//│ def lastDrive(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => [Some last^43(h¹, t¹)]
//│ 	| N  => [None]}
//│ def testLastFilterEnum(n⁰) = lastDrive^62(filter^63(enumFromTo^64(1, n⁰), (fun x⁰ -> (x⁰ < 1000))))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec filter ls_0 f_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (f_0 h_0) then
//│ 		        (`C(h_0, ((filter t_0) f_0)))
//│ 		      else
//│ 		        ((filter t_0) f_0))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec last a_1 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      a_1
//│ 		    | `C(h_2, t_2) -> 
//│ 		      ((last h_2) t_2));;
//│ 		let rec lastDrive ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (`Some(((last h_1) t_1)))
//│ 		    | `N -> 
//│ 		      (`None));;
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec testLastFilterEnum n_0 =
//│ 		  (lastDrive ((filter ((enumFromTo 1) n_0)) (fun x_0 -> 
//│ 		    (x_0 < 1000))));;
//│ 		(testLastFilterEnum 500000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a⁰ enumFromTo((a⁰ + 1), b⁰)]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter(t⁰, f⁰)] else filter(t⁰, f⁰) | N  => [N]}: 39
//│ [N]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter(t⁰, f⁰)] else filter(t⁰, f⁰) | N  => [N]}: 39
//│ [C h⁰ filter(t⁰, f⁰)]: 31 --->
//│ 	case ls¹ of {C h¹ t¹ => [Some last(h¹, t¹)] | N  => [None]}: 50
//│ 	case ls² of {N  => a¹ | C h² t² => last(h², t²)}: 59
//│ [N]: 38 --->
//│ 	case ls¹ of {C h¹ t¹ => [Some last(h¹, t¹)] | N  => [None]}: 50
//│ 	case ls² of {N  => a¹ | C h² t² => last(h², t²)}: 59
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter(t⁰, f⁰)] else filter(t⁰, f⁰) | N  => [N]}: 39 --->
//│ 	[C a⁰ enumFromTo((a⁰ + 1), b⁰)]: 16
//│ 	[N]: 17
//│ case ls¹ of {C h¹ t¹ => [Some last(h¹, t¹)] | N  => [None]}: 50 --->
//│ 	[C h⁰ filter(t⁰, f⁰)]: 31
//│ 	[N]: 38
//│ case ls² of {N  => a¹ | C h² t² => last(h², t²)}: 59 --->
//│ 	[C h⁰ filter(t⁰, f⁰)]: 31
//│ 	[N]: 38
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C a⁰ enumFromTo((a⁰ + 1), b⁰)]: 16 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter(t⁰, f⁰)] else filter(t⁰, f⁰) | N  => [N]}: 39
//│ [N]: 17 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter(t⁰, f⁰)] else filter(t⁰, f⁰) | N  => [N]}: 39
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter(t⁰, f⁰)] else filter(t⁰, f⁰) | N  => [N]}: 39 --->
//│ 	[C a⁰ enumFromTo((a⁰ + 1), b⁰)]: 16
//│ 	[N]: 17
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testLastFilterEnum(primId⁰(500000))
//│ def enumFromTo(a³, b¹) = if (a³ <= b¹) then 
//│ 	let t³ = enumFromTo((a³ + 1), b¹)
//│ 	in let h³ = a³
//│ 	in (fun f² -> if f²(h³) then [C h³ filter(t³, f²)] else filter(t³, f²)) else (fun f³ -> [N])
//│ def filter(ls⁵, f¹) = ls⁵(f¹)
//│ def last(a², ls⁴) = case ls⁴ of {
//│ 	N  => a²
//│ 	| C h² t² => last(h², t²)}
//│ def lastDrive(ls³) = case ls³ of {
//│ 	C h¹ t¹ => [Some last(h¹, t¹)]
//│ 	| N  => [None]}
//│ def testLastFilterEnum(n¹) = lastDrive(filter(enumFromTo(1, n¹), (fun x¹ -> (x¹ < 1000))))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ filter
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testLastFilterEnum(primId⁰(500000))
//│ def enumFromTo(a¹, b⁰) = if (a¹ <= b⁰) then 
//│ 	let t² = enumFromTo((a¹ + 1), b⁰)
//│ 	in let h² = a¹
//│ 	in (fun f¹ -> if f¹(h²) then [C h² t²(f¹)] else t²(f¹)) else (fun f² -> [N])
//│ def filter(ls², f⁰) = ls²(f⁰)
//│ def last(a⁰, ls¹) = case ls¹ of {
//│ 	N  => a⁰
//│ 	| C h¹ t¹ => last(h¹, t¹)}
//│ def lastDrive(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [Some last(h⁰, t⁰)]
//│ 	| N  => [None]}
//│ def testLastFilterEnum(n⁰) = lastDrive(enumFromTo(1, n⁰, (fun x⁰ -> (x⁰ < 1000))))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testLastFilterEnum(primId⁰(500000))
//│ def enumFromTo(a¹, b⁰, _lh_popOutId_0⁰) = if (a¹ <= b⁰) then 
//│ 	let t² = enumFromTo((a¹ + 1), b⁰)
//│ 	in let h² = a¹
//│ 	in if _lh_popOutId_0⁰(h²) then [C h² t²(_lh_popOutId_0⁰)] else t²(_lh_popOutId_0⁰) else [N]
//│ def filter(ls², f⁰) = ls²(f⁰)
//│ def last(a⁰, ls¹) = case ls¹ of {
//│ 	N  => a⁰
//│ 	| C h¹ t¹ => last(h¹, t¹)}
//│ def lastDrive(ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [Some last(h⁰, t⁰)]
//│ 	| N  => [None]}
//│ def testLastFilterEnum(n⁰) = lastDrive(enumFromTo(1, n⁰, (fun x⁰ -> (x⁰ < 1000))))
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun testMapmap(ls) = map(x => x + 1, map(x => x * x, ls))
fun _lhManual(ls, f1, f2) = if ls is
  C(h, t) then C(f2(f1(h)), _lhManual(t, f1, f2))
  N then N
fun testManual(ls) = _lhManual(ls, x => x * x, x => x + 1)
testMapmap(primId(enumFromTo(1, 100000)))
testManual(primId(enumFromTo(1, 100000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |testMapmap|(|ls|)| |#=| |map|(|x| |=>| |x| |+| |1|,| |map|(|x| |=>| |x| |*| |x|,| |ls|)|)|↵|#fun| |_lhManual|(|ls|,| |f1|,| |f2|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f2|(|f1|(|h|)|)|,| |_lhManual|(|t|,| |f1|,| |f2|)|)|↵|N| |#then| |N|←|↵|#fun| |testManual|(|ls|)| |#=| |_lhManual|(|ls|,| |x| |=>| |x| |*| |x|,| |x| |=>| |x| |+| |1|)|↵|testMapmap|(|primId|(|enumFromTo|(|1|,| |100000|)|)|)|↵|testManual|(|primId|(|enumFromTo|(|1|,| |100000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun testMapmap = ls, => map (x, => + (x,) (1,), map (x, => * (x,) (x,), ls,),); fun _lhManual = ls, f1, f2, => if ls is ‹(C (h, t,)) then C (f2 (f1 (h,),), _lhManual (t, f1, f2,),); (N) then N›; fun testManual = ls, => _lhManual (ls, x, => * (x,) (x,), x, => + (x,) (1,),); testMapmap (primId (enumFromTo (1, 100000,),),); testManual (primId (enumFromTo (1, 100000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapmap^92(primId⁰(enumFromTo^94(1, 100000)))
//│ testManual^101(primId⁰(enumFromTo^103(1, 100000)))
//│ def _lhManual(ls², f1⁰, f2⁰) = case ls² of {
//│ 	C h¹ t¹ => [C f2⁰(f1⁰(h¹)) _lhManual^61(t¹, f1⁰, f2⁰)]
//│ 	| N  => [N]}
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^25(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def testManual(ls³) = _lhManual^74(ls³, (fun x² -> (x² * x²)), (fun x³ -> (x³ + 1)))
//│ def testMapmap(ls¹) = map^35((fun x⁰ -> (x⁰ + 1)), map^43((fun x¹ -> (x¹ * x¹)), ls¹))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec _lhManual ls_2 f1_0 f2_0 =
//│ 		  (match ls_2 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (`C((f2_0 (f1_0 h_1)), (((_lhManual t_1) f1_0) f2_0)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec testManual ls_3 =
//│ 		  (((_lhManual ls_3) (fun x_2 -> 
//│ 		    (x_2 * x_2))) (fun x_3 -> 
//│ 		    (x_3 + 1)));;
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec testMapmap ls_1 =
//│ 		  ((map (fun x_0 -> 
//│ 		    (x_0 + 1))) ((map (fun x_1 -> 
//│ 		    (x_1 * x_1))) ls_1));;
//│ 		(testMapmap ((enumFromTo 1) 100000))
//│ 		(testManual ((enumFromTo 1) 100000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(f⁰, t⁰)]: 30 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 32
//│ [N]: 31 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 32
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 32 --->
//│ 	NoProd
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 30
//│ 	[N]: 31
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapmap(primId⁰(enumFromTo(1, 100000)))
//│ testManual(primId⁰(enumFromTo(1, 100000)))
//│ def _lhManual(ls⁶, f1¹, f2¹) = case ls⁶ of {
//│ 	C h¹ t¹ => [C f2¹(f1¹(h¹)) _lhManual(t¹, f1¹, f2¹)]
//│ 	| N  => [N]}
//│ def enumFromTo(a¹, b¹) = if (a¹ <= b¹) then [C a¹ enumFromTo((a¹ + 1), b¹)] else [N]
//│ def map(f¹, ls⁴) = case ls⁴ of {
//│ 	C h⁰ t⁰ => [C f¹(h⁰) map(f¹, t⁰)]
//│ 	| N  => [N]}
//│ def testManual(ls⁷) = _lhManual(ls⁷, (fun x⁶ -> (x⁶ * x⁶)), (fun x⁷ -> (x⁷ + 1)))
//│ def testMapmap(ls⁵) = map((fun x⁴ -> (x⁴ + 1)), map((fun x⁵ -> (x⁵ * x⁵)), ls⁵))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testMapmap(primId⁰(enumFromTo(1, 100000)))
//│ testManual(primId⁰(enumFromTo(1, 100000)))
//│ def _lhManual(ls², f1⁰, f2⁰) = case ls² of {
//│ 	C h¹ t¹ => [C f2⁰(f1⁰(h¹)) _lhManual(t¹, f1⁰, f2⁰)]
//│ 	| N  => [N]}
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def testManual(ls³) = _lhManual(ls³, (fun x² -> (x² * x²)), (fun x³ -> (x³ + 1)))
//│ def testMapmap(ls¹) = map((fun x⁰ -> (x⁰ + 1)), map((fun x¹ -> (x¹ * x¹)), ls¹))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testMapmap(primId⁰(enumFromTo(1, 100000)))
//│ testManual(primId⁰(enumFromTo(1, 100000)))
//│ def _lhManual(ls², f1⁰, f2⁰) = case ls² of {
//│ 	C h¹ t¹ => [C f2⁰(f1⁰(h¹)) _lhManual(t¹, f1⁰, f2⁰)]
//│ 	| N  => [N]}
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def testManual(ls³) = _lhManual(ls³, (fun x² -> (x² * x²)), (fun x³ -> (x³ + 1)))
//│ def testMapmap(ls¹) = map((fun x⁰ -> (x⁰ + 1)), map((fun x¹ -> (x¹ * x¹)), ls¹))
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


// NOTE: digression: simply use `let r = f(h) in C(r, map(t, f))` will be faster
:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun map(f, ls) = if ls is
  C(h, t) then let r = f(h) in C(r, map(f, t))
  N then N
fun testMapmapLet(ls) = map(x => x + 1, map(x => x * x, ls))
testMapmapLet(primId(enumFromTo(1, 100000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#let| |r| |#=| |f|(|h|)| |#in| |C|(|r|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |testMapmapLet|(|ls|)| |#=| |map|(|x| |=>| |x| |+| |1|,| |map|(|x| |=>| |x| |*| |x|,| |ls|)|)|↵|testMapmapLet|(|primId|(|enumFromTo|(|1|,| |100000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun map = f, ls, => if ls is ‹(C (h, t,)) then let r = f (h,) in C (r, map (f, t,),); (N) then N›; fun testMapmapLet = ls, => map (x, => + (x,) (1,), map (x, => * (x,) (x,), ls,),); testMapmapLet (primId (enumFromTo (1, 100000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapmapLet^57(primId⁰(enumFromTo^59(1, 100000)))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let r⁰ = f⁰(h⁰)
//│ 		in [C r⁰ map^26(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def testMapmapLet(ls¹) = map^37((fun x⁰ -> (x⁰ + 1)), map^45((fun x¹ -> (x¹ * x¹)), ls¹))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (let rec r_0 = (f_0 h_0) in
//│ 		        (`C(r_0, ((map f_0) t_0))))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec testMapmapLet ls_1 =
//│ 		  ((map (fun x_0 -> 
//│ 		    (x_0 + 1))) ((map (fun x_1 -> 
//│ 		    (x_1 * x_1))) ls_1));;
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		(testMapmapLet ((enumFromTo 1) 100000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C r⁰ map(f⁰, t⁰)]: 31 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => let r⁰ = f⁰(h⁰)
//│ in [C r⁰ map(f⁰, t⁰)] | N  => [N]}: 34
//│ [N]: 33 --->
//│ 	NoCons
//│ 	case ls⁰ of {C h⁰ t⁰ => let r⁰ = f⁰(h⁰)
//│ in [C r⁰ map(f⁰, t⁰)] | N  => [N]}: 34
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => let r⁰ = f⁰(h⁰)
//│ in [C r⁰ map(f⁰, t⁰)] | N  => [N]}: 34 --->
//│ 	NoProd
//│ 	[C r⁰ map(f⁰, t⁰)]: 31
//│ 	[N]: 33
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapmapLet(primId⁰(enumFromTo(1, 100000)))
//│ def enumFromTo(a¹, b¹) = if (a¹ <= b¹) then [C a¹ enumFromTo((a¹ + 1), b¹)] else [N]
//│ def map(f¹, ls²) = case ls² of {
//│ 	C h⁰ t⁰ => 
//│ 		let r¹ = f¹(h⁰)
//│ 		in [C r¹ map(f¹, t⁰)]
//│ 	| N  => [N]}
//│ def testMapmapLet(ls³) = map((fun x² -> (x² + 1)), map((fun x³ -> (x³ * x³)), ls³))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testMapmapLet(primId⁰(enumFromTo(1, 100000)))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let r⁰ = f⁰(h⁰)
//│ 		in [C r⁰ map(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def testMapmapLet(ls¹) = map((fun x⁰ -> (x⁰ + 1)), map((fun x¹ -> (x¹ * x¹)), ls¹))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testMapmapLet(primId⁰(enumFromTo(1, 100000)))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let r⁰ = f⁰(h⁰)
//│ 		in [C r⁰ map(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def testMapmapLet(ls¹) = map((fun x⁰ -> (x⁰ + 1)), map((fun x¹ -> (x¹ * x¹)), ls¹))
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
:lhInHaskell
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = flatMap (\b ->
              flatMap (\q -> if (safe q 1 b) then [q:b] else []) [1..nq]
            ) (gen (n-1) nq)
flatMap f [] = []
flatMap f (h:t) = append (f h) (flatMap f t)
append [] ys = ys
append (h:t) ys = h:(append t ys)
nsoln nq = length (gen nq nq)
testQueenUsingFlatMapBuiltInType n = nsoln n
testQueenUsingFlatMapBuiltInType $ primId 11
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testQueenUsingFlatMapBuiltInType_lh_₁^197(primId⁰(11))
//│ def append_lh_₁(_lh_append_arg1¹, _lh_append_arg2¹) = case _lh_append_arg1¹ of {
//│ 	LH_N  => _lh_append_arg2¹
//│ 	| LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_lh_₁^17(_lh_append_LH_C_1¹, _lh_append_arg2¹)]
//│ 	| _  => error⁰}
//│ def append_lh_₂(_lh_append_arg1⁰, _lh_append_arg2⁰) = case _lh_append_arg1⁰ of {
//│ 	LH_N  => _lh_append_arg2⁰
//│ 	| LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₂^4(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]
//│ 	| _  => error⁰}
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^117((a⁰ + 1), b⁰)] else [LH_N]
//│ def flatMap_lh_₁(_lh_flatMap_arg1¹, _lh_flatMap_arg2¹) = case _lh_flatMap_arg2¹ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append_lh_₁^96(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_lh_₁^101(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹))
//│ 	| _  => error⁰}
//│ def flatMap_lh_₂(_lh_flatMap_arg1⁰, _lh_flatMap_arg2⁰) = case _lh_flatMap_arg2⁰ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => append_lh_₂^29(_lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰), flatMap_lh_₂^34(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def gen_lh_₁(_lh_gen_arg1⁰, _lh_gen_arg2⁰) = case _lh_gen_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => flatMap_lh_₂^135((fun b¹ -> flatMap_lh_₁^136((fun q⁰ -> if safe_lh_₁^137(q⁰, 1, b¹) then [LH_C [LH_C q⁰ b¹] [LH_N]] else [LH_N]), enumFromTo_lh_₁^153(1, _lh_gen_arg2⁰))), gen_lh_₁^161((_lh_gen_arg1⁰ - 1), _lh_gen_arg2⁰))}
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁^178(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1⁰) = length_lh_₁^185(gen_lh_₁^186(_lh_nsoln_arg1⁰, _lh_nsoln_arg1⁰))
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁰, _lh_safe_arg3⁰) = case _lh_safe_arg3⁰ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁^77(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def testQueenUsingFlatMapBuiltInType_lh_₁(_lh_testQueenUsingFlatMapBuiltInType_arg1⁰) = nsoln_lh_₁^193(_lh_testQueenUsingFlatMapBuiltInType_arg1⁰)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec length_lh__d1 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (1 + (length_lh__d1 t_0))
//│ 		    | `LH_N -> 
//│ 		      0);;
//│ 		let rec enumFromTo_lh__d1 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d1 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec append_lh__d1 _lh_append_arg1_1 _lh_append_arg2_1 =
//│ 		  (match _lh_append_arg1_1 with
//│ 		    | `LH_N -> 
//│ 		      _lh_append_arg2_1
//│ 		    | `LH_C(_lh_append_LH_C_0_1, _lh_append_LH_C_1_1) -> 
//│ 		      (`LH_C(_lh_append_LH_C_0_1, ((append_lh__d1 _lh_append_LH_C_1_1) _lh_append_arg2_1)))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec flatMap_lh__d1 _lh_flatMap_arg1_1 _lh_flatMap_arg2_1 =
//│ 		  (match _lh_flatMap_arg2_1 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_flatMap_LH_C_0_1, _lh_flatMap_LH_C_1_1) -> 
//│ 		      ((append_lh__d1 (_lh_flatMap_arg1_1 _lh_flatMap_LH_C_0_1)) ((flatMap_lh__d1 _lh_flatMap_arg1_1) _lh_flatMap_LH_C_1_1))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec append_lh__d2 _lh_append_arg1_0 _lh_append_arg2_0 =
//│ 		  (match _lh_append_arg1_0 with
//│ 		    | `LH_N -> 
//│ 		      _lh_append_arg2_0
//│ 		    | `LH_C(_lh_append_LH_C_0_0, _lh_append_LH_C_1_0) -> 
//│ 		      (`LH_C(_lh_append_LH_C_0_0, ((append_lh__d2 _lh_append_LH_C_1_0) _lh_append_arg2_0)))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec flatMap_lh__d2 _lh_flatMap_arg1_0 _lh_flatMap_arg2_0 =
//│ 		  (match _lh_flatMap_arg2_0 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_flatMap_LH_C_0_0, _lh_flatMap_LH_C_1_0) -> 
//│ 		      ((append_lh__d2 (_lh_flatMap_arg1_0 _lh_flatMap_LH_C_0_0)) ((flatMap_lh__d2 _lh_flatMap_arg1_0) _lh_flatMap_LH_C_1_0))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec safe_lh__d1 _lh_safe_arg1_0 _lh_safe_arg2_0 _lh_safe_arg3_0 =
//│ 		  (match _lh_safe_arg3_0 with
//│ 		    | `LH_N -> 
//│ 		      true
//│ 		    | `LH_C(_lh_safe_LH_C_0_0, _lh_safe_LH_C_1_0) -> 
//│ 		      ((((_lh_safe_arg1_0 <> _lh_safe_LH_C_0_0) && (_lh_safe_arg1_0 <> (_lh_safe_LH_C_0_0 + _lh_safe_arg2_0))) && (_lh_safe_arg1_0 <> (_lh_safe_LH_C_0_0 - _lh_safe_arg2_0))) && (((safe_lh__d1 _lh_safe_arg1_0) (_lh_safe_arg2_0 + 1)) _lh_safe_LH_C_1_0))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec gen_lh__d1 _lh_gen_arg1_0 _lh_gen_arg2_0 =
//│ 		  (match _lh_gen_arg1_0 with
//│ 		    | 0 -> 
//│ 		      (`LH_C((`LH_N), (`LH_N)))
//│ 		    | _ -> 
//│ 		      ((flatMap_lh__d2 (fun b_1 -> 
//│ 		        ((flatMap_lh__d1 (fun q_0 -> 
//│ 		          (if (((safe_lh__d1 q_0) 1) b_1) then
//│ 		            (`LH_C((`LH_C(q_0, b_1)), (`LH_N)))
//│ 		          else
//│ 		            (`LH_N)))) ((enumFromTo_lh__d1 1) _lh_gen_arg2_0)))) ((gen_lh__d1 (_lh_gen_arg1_0 - 1)) _lh_gen_arg2_0)));;
//│ 		let rec nsoln_lh__d1 _lh_nsoln_arg1_0 =
//│ 		  (length_lh__d1 ((gen_lh__d1 _lh_nsoln_arg1_0) _lh_nsoln_arg1_0));;
//│ 		let rec testQueenUsingFlatMapBuiltInType_lh__d1 _lh_testQueenUsingFlatMapBuiltInType_arg1_0 =
//│ 		  (nsoln_lh__d1 _lh_testQueenUsingFlatMapBuiltInType_arg1_0);;
//│ 		(testQueenUsingFlatMapBuiltInType_lh__d1 11)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C _lh_append_LH_C_0⁰ append_lh_₂(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]: 9 --->
//│ 	case _lh_flatMap_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => append_lh_₂(_lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰), flatMap_lh_₂(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰)) | _  => error⁰}: 41
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 183
//│ [LH_C _lh_append_LH_C_0¹ append_lh_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 22 --->
//│ 	case _lh_append_arg1⁰ of {LH_N  => _lh_append_arg2⁰ | LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₂(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)] | _  => error⁰}: 11
//│ [LH_N]: 28 --->
//│ 	case _lh_flatMap_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => append_lh_₂(_lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰), flatMap_lh_₂(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰)) | _  => error⁰}: 41
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 183
//│ [LH_N]: 95 --->
//│ 	case _lh_append_arg1⁰ of {LH_N  => _lh_append_arg2⁰ | LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₂(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)] | _  => error⁰}: 11
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 126 --->
//│ 	case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append_lh_₁(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_lh_₁(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 108
//│ [LH_N]: 127 --->
//│ 	case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append_lh_₁(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_lh_₁(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 108
//│ [LH_N]: 132 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 90
//│ [LH_N]: 133 --->
//│ 	case _lh_flatMap_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => append_lh_₂(_lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰), flatMap_lh_₂(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰)) | _  => error⁰}: 41
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 183
//│ [LH_C [LH_N] [LH_N]]: 134 --->
//│ 	case _lh_flatMap_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => append_lh_₂(_lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰), flatMap_lh_₂(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰)) | _  => error⁰}: 41
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 183
//│ [LH_C q⁰ b¹]: 146 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 90
//│ [LH_N]: 147 --->
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_lh_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 24
//│ [LH_C [LH_C q⁰ b¹] [LH_N]]: 148 --->
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_lh_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 24
//│ [LH_N]: 149 --->
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_lh_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 24
//│ ------------------
//│ case _lh_append_arg1⁰ of {LH_N  => _lh_append_arg2⁰ | LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₂(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)] | _  => error⁰}: 11 --->
//│ 	[LH_C _lh_append_LH_C_0¹ append_lh_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 22
//│ 	[LH_N]: 95
//│ case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_lh_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 24 --->
//│ 	[LH_N]: 147
//│ 	[LH_C [LH_C q⁰ b¹] [LH_N]]: 148
//│ 	[LH_N]: 149
//│ case _lh_flatMap_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => append_lh_₂(_lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰), flatMap_lh_₂(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰)) | _  => error⁰}: 41 --->
//│ 	[LH_C _lh_append_LH_C_0⁰ append_lh_₂(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]: 9
//│ 	[LH_N]: 28
//│ 	[LH_N]: 133
//│ 	[LH_C [LH_N] [LH_N]]: 134
//│ case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 90 --->
//│ 	[LH_N]: 132
//│ 	[LH_C q⁰ b¹]: 146
//│ case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append_lh_₁(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_lh_₁(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 108 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 126
//│ 	[LH_N]: 127
//│ case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 183 --->
//│ 	[LH_C _lh_append_LH_C_0⁰ append_lh_₂(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]: 9
//│ 	[LH_N]: 28
//│ 	[LH_N]: 133
//│ 	[LH_C [LH_N] [LH_N]]: 134
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C _lh_append_LH_C_0¹ append_lh_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 22 --->
//│ 	case _lh_append_arg1⁰ of {LH_N  => _lh_append_arg2⁰ | LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₂(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)] | _  => error⁰}: 11
//│ [LH_N]: 95 --->
//│ 	case _lh_append_arg1⁰ of {LH_N  => _lh_append_arg2⁰ | LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₂(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)] | _  => error⁰}: 11
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 126 --->
//│ 	case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append_lh_₁(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_lh_₁(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 108
//│ [LH_N]: 127 --->
//│ 	case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append_lh_₁(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_lh_₁(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 108
//│ [LH_N]: 147 --->
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_lh_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 24
//│ [LH_C [LH_C q⁰ b¹] [LH_N]]: 148 --->
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_lh_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 24
//│ [LH_N]: 149 --->
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_lh_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 24
//│ ------------------
//│ case _lh_append_arg1⁰ of {LH_N  => _lh_append_arg2⁰ | LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₂(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)] | _  => error⁰}: 11 --->
//│ 	[LH_C _lh_append_LH_C_0¹ append_lh_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 22
//│ 	[LH_N]: 95
//│ case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_lh_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 24 --->
//│ 	[LH_N]: 147
//│ 	[LH_C [LH_C q⁰ b¹] [LH_N]]: 148
//│ 	[LH_N]: 149
//│ case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append_lh_₁(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_lh_₁(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 108 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 126
//│ 	[LH_N]: 127
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testQueenUsingFlatMapBuiltInType_lh_₁(primId⁰(11))
//│ def append_lh_₁(_lh_append_arg1³, _lh_append_arg2⁷) = _lh_append_arg1³(_lh_append_arg2⁷)
//│ def append_lh_₂(_lh_append_arg1², _lh_append_arg2²) = _lh_append_arg1²(_lh_append_arg2²)
//│ def enumFromTo_lh_₁(a¹, b³) = if (a¹ <= b³) then 
//│ 	let _lh_flatMap_LH_C_1² = enumFromTo_lh_₁((a¹ + 1), b³)
//│ 	in let _lh_flatMap_LH_C_0² = a¹
//│ 	in (fun _lh_flatMap_arg1² -> append_lh_₁(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap_lh_₁(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²))) else (fun _lh_flatMap_arg1³ -> (fun _lh_append_arg2⁸ -> _lh_append_arg2⁸))
//│ def flatMap_lh_₁(_lh_flatMap_arg1⁴, _lh_flatMap_arg2²) = _lh_flatMap_arg2²(_lh_flatMap_arg1⁴)
//│ def flatMap_lh_₂(_lh_flatMap_arg1⁵, _lh_flatMap_arg2³) = case _lh_flatMap_arg2³ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => append_lh_₂(_lh_flatMap_arg1⁵(_lh_flatMap_LH_C_0⁰), flatMap_lh_₂(_lh_flatMap_arg1⁵, _lh_flatMap_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def gen_lh_₁(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => flatMap_lh_₂((fun b² -> flatMap_lh_₁((fun q¹ -> if safe_lh_₁(q¹, 1, b²) then 
//│ 		let _lh_append_LH_C_1² = (fun _lh_append_arg2⁵ -> _lh_append_arg2⁵)
//│ 		in let _lh_append_LH_C_0² = [LH_C q¹ b²]
//│ 		in (fun _lh_append_arg2³ -> 
//│ 			let _lh_append_LH_C_1³ = append_lh_₁(_lh_append_LH_C_1², _lh_append_arg2³)
//│ 			in let _lh_append_LH_C_0³ = _lh_append_LH_C_0²
//│ 			in (fun _lh_append_arg2⁴ -> [LH_C _lh_append_LH_C_0³ append_lh_₂(_lh_append_LH_C_1³, _lh_append_arg2⁴)])) else (fun _lh_append_arg2⁶ -> _lh_append_arg2⁶)), enumFromTo_lh_₁(1, _lh_gen_arg2¹))), gen_lh_₁((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length_lh_₁(ls¹) = case ls¹ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1¹) = length_lh_₁(gen_lh_₁(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe_lh_₁(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2¹))) && safe_lh_₁(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def testQueenUsingFlatMapBuiltInType_lh_₁(_lh_testQueenUsingFlatMapBuiltInType_arg1¹) = nsoln_lh_₁(_lh_testQueenUsingFlatMapBuiltInType_arg1¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ append_lh_₂, append_lh_₁, flatMap_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ gen_lh_₁ -> 2
//│ enumFromTo_lh_₁ -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testQueenUsingFlatMapBuiltInType_lh_₁(primId⁰(11))
//│ def append_lh_₁(_lh_append_arg1¹, _lh_append_arg2⁵) = _lh_append_arg1¹(_lh_append_arg2⁵)
//│ def append_lh_₂(_lh_append_arg1⁰, _lh_append_arg2⁰) = _lh_append_arg1⁰(_lh_append_arg2⁰)
//│ def enumFromTo_lh_₁(a⁰, b¹) = if (a⁰ <= b¹) then 
//│ 	let _lh_flatMap_LH_C_1⁰ = enumFromTo_lh_₁((a⁰ + 1), b¹)
//│ 	in let _lh_flatMap_LH_C_0⁰ = a⁰
//│ 	in (fun _lh_flatMap_arg1⁰ -> _lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰, _lh_flatMap_LH_C_1⁰(_lh_flatMap_arg1⁰))) else (fun _lh_flatMap_arg1¹ -> (fun _lh_append_arg2⁶ -> _lh_append_arg2⁶))
//│ def flatMap_lh_₁(_lh_flatMap_arg1², _lh_flatMap_arg2⁰) = _lh_flatMap_arg2⁰(_lh_flatMap_arg1²)
//│ def flatMap_lh_₂(_lh_flatMap_arg1³, _lh_flatMap_arg2¹) = case _lh_flatMap_arg2¹ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => _lh_flatMap_arg1³(_lh_flatMap_LH_C_0¹, flatMap_lh_₂(_lh_flatMap_arg1³, _lh_flatMap_LH_C_1¹))
//│ 	| _  => error⁰}
//│ def gen_lh_₁(_lh_gen_arg1⁰, _lh_gen_arg2⁰) = case _lh_gen_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => flatMap_lh_₂((fun b⁰ -> enumFromTo_lh_₁(1, _lh_gen_arg2⁰, (fun q⁰ -> if safe_lh_₁(q⁰, 1, b⁰) then 
//│ 		let _lh_append_LH_C_1⁰ = (fun _lh_append_arg2¹ -> _lh_append_arg2¹)
//│ 		in let _lh_append_LH_C_0⁰ = [LH_C q⁰ b⁰]
//│ 		in (fun _lh_append_arg2² -> 
//│ 			let _lh_append_LH_C_1¹ = _lh_append_LH_C_1⁰(_lh_append_arg2²)
//│ 			in let _lh_append_LH_C_0¹ = _lh_append_LH_C_0⁰
//│ 			in (fun _lh_append_arg2³ -> [LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹(_lh_append_arg2³)])) else (fun _lh_append_arg2⁴ -> _lh_append_arg2⁴)))), gen_lh_₁((_lh_gen_arg1⁰ - 1), _lh_gen_arg2⁰))}
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1⁰) = length_lh_₁(gen_lh_₁(_lh_nsoln_arg1⁰, _lh_nsoln_arg1⁰))
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁰, _lh_safe_arg3⁰) = case _lh_safe_arg3⁰ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def testQueenUsingFlatMapBuiltInType_lh_₁(_lh_testQueenUsingFlatMapBuiltInType_arg1⁰) = nsoln_lh_₁(_lh_testQueenUsingFlatMapBuiltInType_arg1⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testQueenUsingFlatMapBuiltInType_lh_₁(primId⁰(11))
//│ def append_lh_₁(_lh_append_arg1¹, _lh_append_arg2⁵) = _lh_append_arg1¹(_lh_append_arg2⁵)
//│ def append_lh_₂(_lh_append_arg1⁰, _lh_append_arg2⁰) = _lh_append_arg1⁰(_lh_append_arg2⁰)
//│ def enumFromTo_lh_₁(a⁰, b¹, _lh_popOutId_0⁰) = if (a⁰ <= b¹) then 
//│ 	let _lh_flatMap_LH_C_1⁰ = enumFromTo_lh_₁((a⁰ + 1), b¹)
//│ 	in let _lh_flatMap_LH_C_0⁰ = a⁰
//│ 	in _lh_popOutId_0⁰(_lh_flatMap_LH_C_0⁰, _lh_flatMap_LH_C_1⁰(_lh_popOutId_0⁰)) else (fun _lh_append_arg2⁶ -> _lh_append_arg2⁶)
//│ def flatMap_lh_₁(_lh_flatMap_arg1⁰, _lh_flatMap_arg2⁰) = _lh_flatMap_arg2⁰(_lh_flatMap_arg1⁰)
//│ def flatMap_lh_₂(_lh_flatMap_arg1¹, _lh_flatMap_arg2¹) = case _lh_flatMap_arg2¹ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => _lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹, flatMap_lh_₂(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹))
//│ 	| _  => error⁰}
//│ def gen_lh_₁(_lh_gen_arg1⁰, _lh_gen_arg2⁰) = case _lh_gen_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => flatMap_lh_₂((fun b⁰ -> enumFromTo_lh_₁(1, _lh_gen_arg2⁰, (fun q⁰ -> if safe_lh_₁(q⁰, 1, b⁰) then 
//│ 		let _lh_append_LH_C_1⁰ = (fun _lh_append_arg2¹ -> _lh_append_arg2¹)
//│ 		in let _lh_append_LH_C_0⁰ = [LH_C q⁰ b⁰]
//│ 		in (fun _lh_append_arg2² -> 
//│ 			let _lh_append_LH_C_1¹ = _lh_append_LH_C_1⁰(_lh_append_arg2²)
//│ 			in let _lh_append_LH_C_0¹ = _lh_append_LH_C_0⁰
//│ 			in (fun _lh_append_arg2³ -> [LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹(_lh_append_arg2³)])) else (fun _lh_append_arg2⁴ -> _lh_append_arg2⁴)))), gen_lh_₁((_lh_gen_arg1⁰ - 1), _lh_gen_arg2⁰))}
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1⁰) = length_lh_₁(gen_lh_₁(_lh_nsoln_arg1⁰, _lh_nsoln_arg1⁰))
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁰, _lh_safe_arg3⁰) = case _lh_safe_arg3⁰ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def testQueenUsingFlatMapBuiltInType_lh_₁(_lh_testQueenUsingFlatMapBuiltInType_arg1⁰) = nsoln_lh_₁(_lh_testQueenUsingFlatMapBuiltInType_arg1⁰)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<



:lhGenOCaml
:lhInHaskell
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = [ (q:b) | b <- gen (n-1) nq, q <- [1..nq], safe q 1 b ]
nsoln nq = length (gen nq nq)
testQueenBuiltInType n = nsoln n
testQueenBuiltInType $ primId 11
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testQueenBuiltInType_lh_₁^149(primId⁰(11))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^57((a⁰ + 1), b⁰)] else [LH_N]
//│ def gen_lh_₁(_lh_gen_arg1⁰, _lh_gen_arg2⁰) = case _lh_gen_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 				let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 					LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁^77(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)
//│ 					| LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ 				in _lh_listcomp_fun¹(enumFromTo_lh_₁^101(1, _lh_gen_arg2⁰))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁰(gen_lh_₁^112((_lh_gen_arg1⁰ - 1), _lh_gen_arg2⁰))}
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁^130(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1⁰) = length_lh_₁^137(gen_lh_₁^138(_lh_nsoln_arg1⁰, _lh_nsoln_arg1⁰))
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁰, _lh_safe_arg3⁰) = case _lh_safe_arg3⁰ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁^34(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def testQueenBuiltInType_lh_₁(_lh_testQueenBuiltInType_arg1⁰) = nsoln_lh_₁^145(_lh_testQueenBuiltInType_arg1⁰)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_lh__d1 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d1 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec safe_lh__d1 _lh_safe_arg1_0 _lh_safe_arg2_0 _lh_safe_arg3_0 =
//│ 		  (match _lh_safe_arg3_0 with
//│ 		    | `LH_N -> 
//│ 		      true
//│ 		    | `LH_C(_lh_safe_LH_C_0_0, _lh_safe_LH_C_1_0) -> 
//│ 		      ((((_lh_safe_arg1_0 <> _lh_safe_LH_C_0_0) && (_lh_safe_arg1_0 <> (_lh_safe_LH_C_0_0 + _lh_safe_arg2_0))) && (_lh_safe_arg1_0 <> (_lh_safe_LH_C_0_0 - _lh_safe_arg2_0))) && (((safe_lh__d1 _lh_safe_arg1_0) (_lh_safe_arg2_0 + 1)) _lh_safe_LH_C_1_0))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec gen_lh__d1 _lh_gen_arg1_0 _lh_gen_arg2_0 =
//│ 		  (match _lh_gen_arg1_0 with
//│ 		    | 0 -> 
//│ 		      (`LH_C((`LH_N), (`LH_N)))
//│ 		    | _ -> 
//│ 		      (let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│ 		        (match _lh_listcomp_fun_para_0 with
//│ 		          | `LH_C(_lh_listcomp_fun_ls_h_0, _lh_listcomp_fun_ls_t_0) -> 
//│ 		            (let rec _lh_listcomp_fun_1 = (fun _lh_listcomp_fun_para_1 -> 
//│ 		              (match _lh_listcomp_fun_para_1 with
//│ 		                | `LH_C(_lh_listcomp_fun_ls_h_1, _lh_listcomp_fun_ls_t_1) -> 
//│ 		                  (if (((safe_lh__d1 _lh_listcomp_fun_ls_h_1) 1) _lh_listcomp_fun_ls_h_0) then
//│ 		                    (`LH_C((`LH_C(_lh_listcomp_fun_ls_h_1, _lh_listcomp_fun_ls_h_0)), (_lh_listcomp_fun_1 _lh_listcomp_fun_ls_t_1)))
//│ 		                  else
//│ 		                    (_lh_listcomp_fun_1 _lh_listcomp_fun_ls_t_1))
//│ 		                | `LH_N -> 
//│ 		                  (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0))) in
//│ 		              (_lh_listcomp_fun_1 ((enumFromTo_lh__d1 1) _lh_gen_arg2_0)))
//│ 		          | `LH_N -> 
//│ 		            (`LH_N))) in
//│ 		        (_lh_listcomp_fun_0 ((gen_lh__d1 (_lh_gen_arg1_0 - 1)) _lh_gen_arg2_0))));;
//│ 		let rec length_lh__d1 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (1 + (length_lh__d1 t_0))
//│ 		    | `LH_N -> 
//│ 		      0);;
//│ 		let rec nsoln_lh__d1 _lh_nsoln_arg1_0 =
//│ 		  (length_lh__d1 ((gen_lh__d1 _lh_nsoln_arg1_0) _lh_nsoln_arg1_0));;
//│ 		let rec testQueenBuiltInType_lh__d1 _lh_testQueenBuiltInType_arg1_0 =
//│ 		  (nsoln_lh__d1 _lh_testQueenBuiltInType_arg1_0);;
//│ 		(testQueenBuiltInType_lh__d1 11)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 66 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98
//│ [LH_N]: 67 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98
//│ [LH_N]: 72 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 47
//│ [LH_N]: 73 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135
//│ [LH_C [LH_N] [LH_N]]: 74 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135
//│ [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰]: 86 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 47
//│ [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 90 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135
//│ [LH_N]: 108 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135
//│ ------------------
//│ case _lh_safe_arg3⁰ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰)) | _  => error⁰}: 47 --->
//│ 	[LH_N]: 72
//│ 	[LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰]: 86
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 66
//│ 	[LH_N]: 67
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰)) | LH_N  => [LH_N]}: 109 --->
//│ 	[LH_N]: 73
//│ 	[LH_C [LH_N] [LH_N]]: 74
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 90
//│ 	[LH_N]: 108
//│ case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰)) | LH_N  => 0}: 135 --->
//│ 	[LH_N]: 73
//│ 	[LH_C [LH_N] [LH_N]]: 74
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 90
//│ 	[LH_N]: 108
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 66 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98
//│ [LH_N]: 67 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98
//│ ------------------
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h⁰) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h⁰] _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹) | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 98 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 66
//│ 	[LH_N]: 67
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testQueenBuiltInType_lh_₁(primId⁰(11))
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let _lh_listcomp_fun_ls_t² = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let _lh_listcomp_fun_ls_h² = a¹
//│ 	in (fun _lh_listcomp_fun_ls_h³ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_listcomp_fun_ls_t³ -> (fun _lh_listcomp_fun⁵ -> if safe_lh_₁(_lh_listcomp_fun_ls_h², 1, _lh_listcomp_fun_ls_h³) then [LH_C [LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_h³] _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t²))))) else (fun _lh_listcomp_fun_ls_h⁴ -> (fun _lh_listcomp_fun⁶ -> (fun _lh_listcomp_fun_ls_t⁴ -> (fun _lh_listcomp_fun⁷ -> _lh_listcomp_fun⁷(_lh_listcomp_fun_ls_t⁴)))))
//│ def gen_lh_₁(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 				let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> _lh_listcomp_fun_para³(_lh_listcomp_fun_ls_h⁰, _lh_listcomp_fun³, _lh_listcomp_fun_ls_t⁰, _lh_listcomp_fun²))
//│ 				in _lh_listcomp_fun³(enumFromTo_lh_₁(1, _lh_gen_arg2¹))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun²(gen_lh_₁((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length_lh_₁(ls¹) = case ls¹ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1¹) = length_lh_₁(gen_lh_₁(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe_lh_₁(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2¹))) && safe_lh_₁(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def testQueenBuiltInType_lh_₁(_lh_testQueenBuiltInType_arg1¹) = nsoln_lh_₁(_lh_testQueenBuiltInType_arg1¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ recursive consumer: gen_lh_₁
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₁ -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testQueenBuiltInType_lh_₁(primId⁰(11))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_listcomp_fun_ls_t¹ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_listcomp_fun_ls_h¹ = a⁰
//│ 	in (fun _lh_listcomp_fun_ls_h² -> (fun _lh_listcomp_fun² -> (fun _lh_listcomp_fun_ls_t² -> (fun _lh_listcomp_fun³ -> if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun²(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t¹))))) else (fun _lh_listcomp_fun_ls_h³ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_listcomp_fun_ls_t³ -> (fun _lh_listcomp_fun⁵ -> _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t³)))))
//│ def gen_lh_₁(_lh_gen_arg1⁰, _lh_gen_arg2⁰) = case _lh_gen_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 				let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun_ls_h⁰, _lh_listcomp_fun¹, _lh_listcomp_fun_ls_t⁰, _lh_listcomp_fun⁰))
//│ 				in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁰(gen_lh_₁((_lh_gen_arg1⁰ - 1), _lh_gen_arg2⁰))}
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1⁰) = length_lh_₁(gen_lh_₁(_lh_nsoln_arg1⁰, _lh_nsoln_arg1⁰))
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁰, _lh_safe_arg3⁰) = case _lh_safe_arg3⁰ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def testQueenBuiltInType_lh_₁(_lh_testQueenBuiltInType_arg1⁰) = nsoln_lh_₁(_lh_testQueenBuiltInType_arg1⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testQueenBuiltInType_lh_₁(primId⁰(11))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_listcomp_fun_ls_t¹ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_listcomp_fun_ls_h¹ = a⁰
//│ 	in (fun _lh_listcomp_fun_ls_h² -> (fun _lh_listcomp_fun² -> (fun _lh_listcomp_fun_ls_t² -> (fun _lh_listcomp_fun³ -> if safe_lh_₁(_lh_listcomp_fun_ls_h¹, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun²(_lh_listcomp_fun_ls_t¹)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t¹))))) else (fun _lh_listcomp_fun_ls_h³ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_listcomp_fun_ls_t³ -> (fun _lh_listcomp_fun⁵ -> _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t³)))))
//│ def gen_lh_₁(_lh_gen_arg1⁰, _lh_gen_arg2⁰) = case _lh_gen_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 				let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun_ls_h⁰, _lh_listcomp_fun¹, _lh_listcomp_fun_ls_t⁰, _lh_listcomp_fun⁰))
//│ 				in _lh_listcomp_fun¹(enumFromTo_lh_₁(1, _lh_gen_arg2⁰))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁰(gen_lh_₁((_lh_gen_arg1⁰ - 1), _lh_gen_arg2⁰))}
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def nsoln_lh_₁(_lh_nsoln_arg1⁰) = length_lh_₁(gen_lh_₁(_lh_nsoln_arg1⁰, _lh_nsoln_arg1⁰))
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁰, _lh_safe_arg3⁰) = case _lh_safe_arg3⁰ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0⁰ _lh_safe_LH_C_1⁰ => ((((_lh_safe_arg1⁰ /= _lh_safe_LH_C_0⁰) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ + _lh_safe_arg2⁰))) && (_lh_safe_arg1⁰ /= (_lh_safe_LH_C_0⁰ - _lh_safe_arg2⁰))) && safe_lh_₁(_lh_safe_arg1⁰, (_lh_safe_arg2⁰ + 1), _lh_safe_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def testQueenBuiltInType_lh_₁(_lh_testQueenBuiltInType_arg1⁰) = nsoln_lh_₁(_lh_testQueenBuiltInType_arg1⁰)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun sum(ls) = summ(0, ls)
fun summ(acc, ls) = if ls is
  N then acc
  C(h, t) then summ(acc + h, t)
fun testSumMapEnumSumAcc(n) = sum(map(x => x * x, enumFromTo(1, n)))
testSumMapEnumSumAcc(primId(300000))
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |sum|(|ls|)| |#=| |summ|(|0|,| |ls|)|↵|#fun| |summ|(|acc|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc|↵|C|(|h|,| |t|)| |#then| |summ|(|acc| |+| |h|,| |t|)|←|↵|#fun| |testSumMapEnumSumAcc|(|n|)| |#=| |sum|(|map|(|x| |=>| |x| |*| |x|,| |enumFromTo|(|1|,| |n|)|)|)|↵|testSumMapEnumSumAcc|(|primId|(|300000|)|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun sum = ls, => summ (0, ls,); fun summ = acc, ls, => if ls is ‹(N) then acc; (C (h, t,)) then summ (+ (acc,) (h,), t,)›; fun testSumMapEnumSumAcc = n, => sum (map (x, => * (x,) (x,), enumFromTo (1, n,),),); testSumMapEnumSumAcc (primId (300000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumMapEnumSumAcc^72(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^21((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def sum(ls¹) = summ^35(0, ls¹)
//│ def summ(acc⁰, ls²) = case ls² of {
//│ 	N  => acc⁰
//│ 	| C h¹ t¹ => summ^43((acc⁰ + h¹), t¹)}
//│ def testSumMapEnumSumAcc(n⁰) = sum^55(map^56((fun x⁰ -> (x⁰ * x⁰)), enumFromTo^64(1, n⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec summ acc_0 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      acc_0
//│ 		    | `C(h_1, t_1) -> 
//│ 		      ((summ (acc_0 + h_1)) t_1));;
//│ 		let rec sum ls_1 =
//│ 		  ((summ 0) ls_1);;
//│ 		let rec map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec testSumMapEnumSumAcc n_0 =
//│ 		  (sum ((map (fun x_0 -> 
//│ 		    (x_0 * x_0))) ((enumFromTo 1) n_0)));;
//│ 		(testSumMapEnumSumAcc 300000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(f⁰, t⁰)]: 10 --->
//│ 	case ls² of {N  => acc⁰ | C h¹ t¹ => summ((acc⁰ + h¹), t¹)}: 52
//│ [N]: 11 --->
//│ 	case ls² of {N  => acc⁰ | C h¹ t¹ => summ((acc⁰ + h¹), t¹)}: 52
//│ [C a⁰ enumFromTo((a⁰ + 1), b⁰)]: 30 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ [N]: 31 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12 --->
//│ 	[C a⁰ enumFromTo((a⁰ + 1), b⁰)]: 30
//│ 	[N]: 31
//│ case ls² of {N  => acc⁰ | C h¹ t¹ => summ((acc⁰ + h¹), t¹)}: 52 --->
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h⁰) map(f⁰, t⁰)]: 10 --->
//│ 	case ls² of {N  => acc⁰ | C h¹ t¹ => summ((acc⁰ + h¹), t¹)}: 52
//│ [N]: 11 --->
//│ 	case ls² of {N  => acc⁰ | C h¹ t¹ => summ((acc⁰ + h¹), t¹)}: 52
//│ [C a⁰ enumFromTo((a⁰ + 1), b⁰)]: 30 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ [N]: 31 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12 --->
//│ 	[C a⁰ enumFromTo((a⁰ + 1), b⁰)]: 30
//│ 	[N]: 31
//│ case ls² of {N  => acc⁰ | C h¹ t¹ => summ((acc⁰ + h¹), t¹)}: 52 --->
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumMapEnumSumAcc(primId⁰(300000))
//│ def enumFromTo(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let t² = enumFromTo((a¹ + 1), b¹)
//│ 	in let h² = a¹
//│ 	in (fun f² -> 
//│ 		let t³ = map(f², t²)
//│ 		in let h³ = f²(h²)
//│ 		in (fun acc² -> summ((acc² + h³), t³))) else (fun f³ -> (fun acc³ -> acc³))
//│ def map(f¹, ls³) = ls³(f¹)
//│ def sum(ls⁴) = summ(0, ls⁴)
//│ def summ(acc¹, ls⁵) = ls⁵(acc¹)
//│ def testSumMapEnumSumAcc(n¹) = sum(map((fun x¹ -> (x¹ * x¹)), enumFromTo(1, n¹)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ summ, map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testSumMapEnumSumAcc(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let t⁰ = enumFromTo((a⁰ + 1), b⁰)
//│ 	in let h⁰ = a⁰
//│ 	in (fun f¹ -> 
//│ 		let t¹ = t⁰(f¹)
//│ 		in let h¹ = f¹(h⁰)
//│ 		in (fun acc¹ -> t¹((acc¹ + h¹)))) else (fun f² -> (fun acc² -> acc²))
//│ def map(f⁰, ls⁰) = ls⁰(f⁰)
//│ def sum(ls¹) = ls¹(0)
//│ def summ(acc⁰, ls²) = ls²(acc⁰)
//│ def testSumMapEnumSumAcc(n⁰) = sum(enumFromTo(1, n⁰, (fun x⁰ -> (x⁰ * x⁰))))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testSumMapEnumSumAcc(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let t⁰ = enumFromTo((a⁰ + 1), b⁰)
//│ 	in let h⁰ = a⁰
//│ 	in (fun f¹ -> 
//│ 		let t¹ = t⁰(f¹)
//│ 		in let h¹ = f¹(h⁰)
//│ 		in (fun acc¹ -> t¹((acc¹ + h¹)))) else (fun f² -> (fun acc² -> acc²))
//│ def map(f⁰, ls⁰) = ls⁰(f⁰)
//│ def sum(ls¹) = ls¹(0)
//│ def summ(acc⁰, ls²) = ls²(acc⁰)
//│ def testSumMapEnumSumAcc(n⁰) = sum(enumFromTo(1, n⁰, (fun x⁰ -> (x⁰ * x⁰))))
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun sum(ls) = if ls is
  C(h, t) then h + sum(t)
  N then 0
fun testSumMapEnum(n) = sum(map(x => x * x, enumFromTo(1, n)))
testSumMapEnum(primId(300000))
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |h| |+| |sum|(|t|)|↵|N| |#then| |0|←|↵|#fun| |testSumMapEnum|(|n|)| |#=| |sum|(|map|(|x| |=>| |x| |*| |x|,| |enumFromTo|(|1|,| |n|)|)|)|↵|testSumMapEnum|(|primId|(|300000|)|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun sum = ls, => if ls is ‹(C (h, t,)) then + (h,) (sum (t,),); (N) then 0›; fun testSumMapEnum = n, => sum (map (x, => * (x,) (x,), enumFromTo (1, n,),),); testSumMapEnum (primId (300000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumMapEnum^63(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^21((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def sum(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => (h¹ + sum^39(t¹))
//│ 	| N  => 0}
//│ def testSumMapEnum(n⁰) = sum^46(map^47((fun x⁰ -> (x⁰ * x⁰)), enumFromTo^55(1, n⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec sum ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (h_1 + (sum t_1))
//│ 		    | `N -> 
//│ 		      0);;
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec testSumMapEnum n_0 =
//│ 		  (sum ((map (fun x_0 -> 
//│ 		    (x_0 * x_0))) ((enumFromTo 1) n_0)));;
//│ 		(testSumMapEnum 300000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(f⁰, t⁰)]: 10 --->
//│ 	case ls¹ of {C h¹ t¹ => (h¹ + sum(t¹)) | N  => 0}: 44
//│ [N]: 11 --->
//│ 	case ls¹ of {C h¹ t¹ => (h¹ + sum(t¹)) | N  => 0}: 44
//│ [C a⁰ enumFromTo((a⁰ + 1), b⁰)]: 30 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ [N]: 31 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12 --->
//│ 	[C a⁰ enumFromTo((a⁰ + 1), b⁰)]: 30
//│ 	[N]: 31
//│ case ls¹ of {C h¹ t¹ => (h¹ + sum(t¹)) | N  => 0}: 44 --->
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h⁰) map(f⁰, t⁰)]: 10 --->
//│ 	case ls¹ of {C h¹ t¹ => (h¹ + sum(t¹)) | N  => 0}: 44
//│ [N]: 11 --->
//│ 	case ls¹ of {C h¹ t¹ => (h¹ + sum(t¹)) | N  => 0}: 44
//│ [C a⁰ enumFromTo((a⁰ + 1), b⁰)]: 30 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ [N]: 31 --->
//│ 	case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12
//│ ------------------
//│ case ls⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 12 --->
//│ 	[C a⁰ enumFromTo((a⁰ + 1), b⁰)]: 30
//│ 	[N]: 31
//│ case ls¹ of {C h¹ t¹ => (h¹ + sum(t¹)) | N  => 0}: 44 --->
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumMapEnum(primId⁰(300000))
//│ def enumFromTo(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let t² = enumFromTo((a¹ + 1), b¹)
//│ 	in let h² = a¹
//│ 	in (fun f² -> 
//│ 		let t³ = map(f², t²)
//│ 		in let h³ = f²(h²)
//│ 		in (fun _lh_dummy⁰ -> (h³ + sum(t³)))) else (fun f³ -> (fun _lh_dummy¹ -> 0))
//│ def map(f¹, ls²) = ls²(f¹)
//│ def sum(ls³) = ls³(99)
//│ def testSumMapEnum(n¹) = sum(map((fun x¹ -> (x¹ * x¹)), enumFromTo(1, n¹)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ sum, map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo -> 4
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testSumMapEnum(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let t⁰ = enumFromTo((a⁰ + 1), b⁰)
//│ 	in let h⁰ = a⁰
//│ 	in (fun f¹ -> 
//│ 		let t¹ = t⁰(f¹)
//│ 		in let h¹ = f¹(h⁰)
//│ 		in (fun _lh_dummy⁰ -> (h¹ + t¹(99)))) else (fun f² -> (fun _lh_dummy¹ -> 0))
//│ def map(f⁰, ls⁰) = ls⁰(f⁰)
//│ def sum(ls¹) = ls¹(99)
//│ def testSumMapEnum(n⁰) = enumFromTo(1, n⁰, (fun x⁰ -> (x⁰ * x⁰)), 99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testSumMapEnum(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰, _lh_popOutId_0⁰, _lh_popOutId_1⁰) = if (a⁰ <= b⁰) then 
//│ 	let t⁰ = enumFromTo((a⁰ + 1), b⁰)
//│ 	in let h⁰ = a⁰
//│ 	in let t¹ = t⁰(_lh_popOutId_0⁰)
//│ 	in let h¹ = _lh_popOutId_0⁰(h⁰)
//│ 	in (h¹ + t¹(99)) else 0
//│ def map(f⁰, ls⁰) = ls⁰(f⁰)
//│ def sum(ls¹) = ls¹(99)
//│ def testSumMapEnum(n⁰) = enumFromTo(1, n⁰, (fun x⁰ -> (x⁰ * x⁰)), 99)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
:lhInHaskell
and [] = True
and (h:t) = if h then and t else False
append [] ys = ys
append (h:t) ys = h:(append t ys)
queens 0 = [[]]
queens m = [ append p [n] | p <- queens (m - 1), n <- [1 .. 9], safe p n]
safe p n = let m = (length p) + 1 in (and [ (j /= n) && ((i + j) /= (m + n)) && ((i - j) /= (m - n)) | (i, j) <- zip [1..(m - 1)] p ])
testAnotherQueenNineBuiltInType n = length $ queens n
testAnotherQueenNineBuiltInType $ primId 9
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testAnotherQueenNineBuiltInType_lh_₁^242(primId⁰(9))
//│ def and_lh_₁(_lh_and_arg1⁰) = case _lh_and_arg1⁰ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_and_LH_C_0⁰ _lh_and_LH_C_1⁰ => if _lh_and_LH_C_0⁰ then and_lh_₁^4(_lh_and_LH_C_1⁰) else [False]
//│ 	| _  => error⁰}
//│ def append_lh_₁(_lh_append_arg1⁰, _lh_append_arg2⁰) = case _lh_append_arg1⁰ of {
//│ 	LH_N  => _lh_append_arg2⁰
//│ 	| LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₁^161(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]
//│ 	| _  => error⁰}
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then [LH_C a¹ enumFromTo_lh_₁^144((a¹ + 1), b¹)] else [LH_N]
//│ def enumFromTo_lh_₂(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₂^18((a⁰ + 1), b⁰)] else [LH_N]
//│ def length_lh_₁(ls¹) = case ls¹ of {
//│ 	LH_C h¹ t¹ => (1 + length_lh_₁^175(t¹))
//│ 	| LH_N  => 0}
//│ def length_lh_₂(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₂^36(t⁰))
//│ 	| LH_N  => 0}
//│ def queens_lh_₁(_lh_queens_arg1⁰) = case _lh_queens_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 			LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => 
//│ 				let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 					LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => if safe_lh_₁^188(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun_ls_h²) then [LH_C append_lh_₁^193(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)
//│ 					| LH_N  => _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)})
//│ 				in _lh_listcomp_fun²(enumFromTo_lh_₁^214(1, 9))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun¹(queens_lh_₁^225((_lh_queens_arg1⁰ - 1)))}
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁰) = 
//│ 	let m⁰ = (length_lh_₂^61(_lh_safe_arg1⁰) + 1)
//│ 	in and_lh_₁^67(
//│ 		let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {
//│ 				LH_P2 _lh_safe_LH_P2_0⁰ _lh_safe_LH_P2_1⁰ => [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]
//│ 				| _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁰(zip_lh_₁^119(enumFromTo_lh_₂^120(1, (m⁰ - 1)), _lh_safe_arg1⁰)))
//│ def testAnotherQueenNineBuiltInType_lh_₁(_lh_testAnotherQueenNineBuiltInType_arg1⁰) = length_lh_₁^236(queens_lh_₁^237(_lh_testAnotherQueenNineBuiltInType_arg1⁰))
//│ def zip_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁^48(tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec append_lh__d1 _lh_append_arg1_0 _lh_append_arg2_0 =
//│ 		  (match _lh_append_arg1_0 with
//│ 		    | `LH_N -> 
//│ 		      _lh_append_arg2_0
//│ 		    | `LH_C(_lh_append_LH_C_0_0, _lh_append_LH_C_1_0) -> 
//│ 		      (`LH_C(_lh_append_LH_C_0_0, ((append_lh__d1 _lh_append_LH_C_1_0) _lh_append_arg2_0)))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec length_lh__d2 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (1 + (length_lh__d2 t_0))
//│ 		    | `LH_N -> 
//│ 		      0);;
//│ 		let rec enumFromTo_lh__d2 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d2 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec and_lh__d1 _lh_and_arg1_0 =
//│ 		  (match _lh_and_arg1_0 with
//│ 		    | `LH_N -> 
//│ 		      true
//│ 		    | `LH_C(_lh_and_LH_C_0_0, _lh_and_LH_C_1_0) -> 
//│ 		      (if _lh_and_LH_C_0_0 then
//│ 		        (and_lh__d1 _lh_and_LH_C_1_0)
//│ 		      else
//│ 		        false)
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec zip_lh__d1 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(hx_0, tx_0) -> 
//│ 		      (match ys_0 with
//│ 		        | `LH_C(hy_0, ty_0) -> 
//│ 		          (`LH_C((`LH_P2(hx_0, hy_0)), ((zip_lh__d1 tx_0) ty_0)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec safe_lh__d1 _lh_safe_arg1_0 _lh_safe_arg2_0 =
//│ 		  (let rec m_0 = ((length_lh__d2 _lh_safe_arg1_0) + 1) in
//│ 		    (and_lh__d1 (let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│ 		      (match _lh_listcomp_fun_para_0 with
//│ 		        | `LH_C(_lh_listcomp_fun_ls_h_0, _lh_listcomp_fun_ls_t_0) -> 
//│ 		          (match _lh_listcomp_fun_ls_h_0 with
//│ 		            | `LH_P2(_lh_safe_LH_P2_0_0, _lh_safe_LH_P2_1_0) -> 
//│ 		              (`LH_C((((_lh_safe_LH_P2_1_0 <> _lh_safe_arg2_0) && ((_lh_safe_LH_P2_0_0 + _lh_safe_LH_P2_1_0) <> (m_0 + _lh_safe_arg2_0))) && ((_lh_safe_LH_P2_0_0 - _lh_safe_LH_P2_1_0) <> (m_0 - _lh_safe_arg2_0))), (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0)))
//│ 		            | _ -> 
//│ 		              (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))) in
//│ 		      (_lh_listcomp_fun_0 ((zip_lh__d1 ((enumFromTo_lh__d2 1) (m_0 - 1))) _lh_safe_arg1_0)))));;
//│ 		let rec enumFromTo_lh__d1 a_1 b_1 =
//│ 		  (if (a_1 <= b_1) then
//│ 		    (`LH_C(a_1, ((enumFromTo_lh__d1 (a_1 + 1)) b_1)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec queens_lh__d1 _lh_queens_arg1_0 =
//│ 		  (match _lh_queens_arg1_0 with
//│ 		    | 0 -> 
//│ 		      (`LH_C((`LH_N), (`LH_N)))
//│ 		    | _ -> 
//│ 		      (let rec _lh_listcomp_fun_1 = (fun _lh_listcomp_fun_para_1 -> 
//│ 		        (match _lh_listcomp_fun_para_1 with
//│ 		          | `LH_C(_lh_listcomp_fun_ls_h_1, _lh_listcomp_fun_ls_t_1) -> 
//│ 		            (let rec _lh_listcomp_fun_2 = (fun _lh_listcomp_fun_para_2 -> 
//│ 		              (match _lh_listcomp_fun_para_2 with
//│ 		                | `LH_C(_lh_listcomp_fun_ls_h_2, _lh_listcomp_fun_ls_t_2) -> 
//│ 		                  (if ((safe_lh__d1 _lh_listcomp_fun_ls_h_1) _lh_listcomp_fun_ls_h_2) then
//│ 		                    (`LH_C(((append_lh__d1 _lh_listcomp_fun_ls_h_1) (`LH_C(_lh_listcomp_fun_ls_h_2, (`LH_N)))), (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_2)))
//│ 		                  else
//│ 		                    (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_2))
//│ 		                | `LH_N -> 
//│ 		                  (_lh_listcomp_fun_1 _lh_listcomp_fun_ls_t_1))) in
//│ 		              (_lh_listcomp_fun_2 ((enumFromTo_lh__d1 1) 9)))
//│ 		          | `LH_N -> 
//│ 		            (`LH_N))) in
//│ 		        (_lh_listcomp_fun_1 (queens_lh__d1 (_lh_queens_arg1_0 - 1)))));;
//│ 		let rec length_lh__d1 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      (1 + (length_lh__d1 t_1))
//│ 		    | `LH_N -> 
//│ 		      0);;
//│ 		let rec testAnotherQueenNineBuiltInType_lh__d1 _lh_testAnotherQueenNineBuiltInType_arg1_0 =
//│ 		  (length_lh__d1 (queens_lh__d1 _lh_testAnotherQueenNineBuiltInType_arg1_0));;
//│ 		(testAnotherQueenNineBuiltInType_lh__d1 9)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₂((a⁰ + 1), b⁰)]: 27 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 57
//│ [LH_N]: 28 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 57
//│ [LH_P2 hx⁰ hy⁰]: 47 --->
//│ 	case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_safe_LH_P2_0⁰ _lh_safe_LH_P2_1⁰ => [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 114
//│ [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)]: 53 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_safe_LH_P2_0⁰ _lh_safe_LH_P2_1⁰ => [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 116
//│ [LH_N]: 54 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_safe_LH_P2_0⁰ _lh_safe_LH_P2_1⁰ => [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 116
//│ [LH_N]: 56 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_safe_LH_P2_0⁰ _lh_safe_LH_P2_1⁰ => [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 116
//│ [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 110 --->
//│ 	case _lh_and_arg1⁰ of {LH_N  => [True] | LH_C _lh_and_LH_C_0⁰ _lh_and_LH_C_1⁰ => if _lh_and_LH_C_0⁰ then and_lh_₁(_lh_and_LH_C_1⁰) else [False] | _  => error⁰}: 10
//│ [LH_N]: 115 --->
//│ 	case _lh_and_arg1⁰ of {LH_N  => [True] | LH_C _lh_and_LH_C_0⁰ _lh_and_LH_C_1⁰ => if _lh_and_LH_C_0⁰ then and_lh_₁(_lh_and_LH_C_1⁰) else [False] | _  => error⁰}: 10
//│ [LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b¹)]: 153 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun_ls_h²) then [LH_C append_lh_₁(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²) | LH_N  => _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)}: 211
//│ [LH_N]: 154 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun_ls_h²) then [LH_C append_lh_₁(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²) | LH_N  => _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)}: 211
//│ [LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]: 166 --->
//│ 	DeadCodeCons
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₂(t⁰)) | LH_N  => 0}: 41
//│ 	case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]}: 55
//│ 	case _lh_append_arg1⁰ of {LH_N  => _lh_append_arg2⁰ | LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)] | _  => error⁰}: 168
//│ [LH_N]: 183 --->
//│ 	DeadCodeCons
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₂(t⁰)) | LH_N  => 0}: 41
//│ 	case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]}: 55
//│ 	case _lh_append_arg1⁰ of {LH_N  => _lh_append_arg2⁰ | LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)] | _  => error⁰}: 168
//│ [LH_N]: 184 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length_lh_₁(t¹)) | LH_N  => 0}: 180
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun_ls_h²) then [LH_C append_lh_₁(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²) | LH_N  => _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)})
//│ in _lh_listcomp_fun²(enumFromTo_lh_₁(1, 9)) | LH_N  => [LH_N]}: 222
//│ [LH_C [LH_N] [LH_N]]: 185 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length_lh_₁(t¹)) | LH_N  => 0}: 180
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun_ls_h²) then [LH_C append_lh_₁(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²) | LH_N  => _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)})
//│ in _lh_listcomp_fun²(enumFromTo_lh_₁(1, 9)) | LH_N  => [LH_N]}: 222
//│ [LH_N]: 197 --->
//│ 	DeadCodeCons
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₂(t⁰)) | LH_N  => 0}: 41
//│ 	case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]}: 55
//│ 	case _lh_append_arg1⁰ of {LH_N  => _lh_append_arg2⁰ | LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)] | _  => error⁰}: 168
//│ [LH_C _lh_listcomp_fun_ls_h² [LH_N]]: 198 --->
//│ 	DeadCodeCons
//│ 	case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₂(t⁰)) | LH_N  => 0}: 41
//│ 	case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]}: 55
//│ 	case _lh_append_arg1⁰ of {LH_N  => _lh_append_arg2⁰ | LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)] | _  => error⁰}: 168
//│ [LH_C append_lh_₁(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)]: 203 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length_lh_₁(t¹)) | LH_N  => 0}: 180
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun_ls_h²) then [LH_C append_lh_₁(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²) | LH_N  => _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)})
//│ in _lh_listcomp_fun²(enumFromTo_lh_₁(1, 9)) | LH_N  => [LH_N]}: 222
//│ [LH_N]: 221 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => (1 + length_lh_₁(t¹)) | LH_N  => 0}: 180
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun_ls_h²) then [LH_C append_lh_₁(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²) | LH_N  => _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)})
//│ in _lh_listcomp_fun²(enumFromTo_lh_₁(1, 9)) | LH_N  => [LH_N]}: 222
//│ ------------------
//│ case _lh_and_arg1⁰ of {LH_N  => [True] | LH_C _lh_and_LH_C_0⁰ _lh_and_LH_C_1⁰ => if _lh_and_LH_C_0⁰ then and_lh_₁(_lh_and_LH_C_1⁰) else [False] | _  => error⁰}: 10 --->
//│ 	[LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 110
//│ 	[LH_N]: 115
//│ case ls⁰ of {LH_C h⁰ t⁰ => (1 + length_lh_₂(t⁰)) | LH_N  => 0}: 41 --->
//│ 	[LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]: 166
//│ 	[LH_N]: 183
//│ 	[LH_N]: 197
//│ 	[LH_C _lh_listcomp_fun_ls_h² [LH_N]]: 198
//│ case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]}: 55 --->
//│ 	[LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]: 166
//│ 	[LH_N]: 183
//│ 	[LH_N]: 197
//│ 	[LH_C _lh_listcomp_fun_ls_h² [LH_N]]: 198
//│ case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 57 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₂((a⁰ + 1), b⁰)]: 27
//│ 	[LH_N]: 28
//│ case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_safe_LH_P2_0⁰ _lh_safe_LH_P2_1⁰ => [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 114 --->
//│ 	[LH_P2 hx⁰ hy⁰]: 47
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_safe_LH_P2_0⁰ _lh_safe_LH_P2_1⁰ => [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 116 --->
//│ 	[LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)]: 53
//│ 	[LH_N]: 54
//│ 	[LH_N]: 56
//│ case _lh_append_arg1⁰ of {LH_N  => _lh_append_arg2⁰ | LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)] | _  => error⁰}: 168 --->
//│ 	[LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]: 166
//│ 	[LH_N]: 183
//│ 	[LH_N]: 197
//│ 	[LH_C _lh_listcomp_fun_ls_h² [LH_N]]: 198
//│ case ls¹ of {LH_C h¹ t¹ => (1 + length_lh_₁(t¹)) | LH_N  => 0}: 180 --->
//│ 	[LH_N]: 184
//│ 	[LH_C [LH_N] [LH_N]]: 185
//│ 	[LH_C append_lh_₁(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)]: 203
//│ 	[LH_N]: 221
//│ case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun_ls_h²) then [LH_C append_lh_₁(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²) | LH_N  => _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)}: 211 --->
//│ 	[LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b¹)]: 153
//│ 	[LH_N]: 154
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun_ls_h²) then [LH_C append_lh_₁(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²) | LH_N  => _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)})
//│ in _lh_listcomp_fun²(enumFromTo_lh_₁(1, 9)) | LH_N  => [LH_N]}: 222 --->
//│ 	[LH_N]: 184
//│ 	[LH_C [LH_N] [LH_N]]: 185
//│ 	[LH_C append_lh_₁(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)]: 203
//│ 	[LH_N]: 221
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₂((a⁰ + 1), b⁰)]: 27 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 57
//│ [LH_N]: 28 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 57
//│ [LH_P2 hx⁰ hy⁰]: 47 --->
//│ 	case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_safe_LH_P2_0⁰ _lh_safe_LH_P2_1⁰ => [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 114
//│ [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)]: 53 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_safe_LH_P2_0⁰ _lh_safe_LH_P2_1⁰ => [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 116
//│ [LH_N]: 54 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_safe_LH_P2_0⁰ _lh_safe_LH_P2_1⁰ => [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 116
//│ [LH_N]: 56 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_safe_LH_P2_0⁰ _lh_safe_LH_P2_1⁰ => [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 116
//│ [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 110 --->
//│ 	case _lh_and_arg1⁰ of {LH_N  => [True] | LH_C _lh_and_LH_C_0⁰ _lh_and_LH_C_1⁰ => if _lh_and_LH_C_0⁰ then and_lh_₁(_lh_and_LH_C_1⁰) else [False] | _  => error⁰}: 10
//│ [LH_N]: 115 --->
//│ 	case _lh_and_arg1⁰ of {LH_N  => [True] | LH_C _lh_and_LH_C_0⁰ _lh_and_LH_C_1⁰ => if _lh_and_LH_C_0⁰ then and_lh_₁(_lh_and_LH_C_1⁰) else [False] | _  => error⁰}: 10
//│ [LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b¹)]: 153 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun_ls_h²) then [LH_C append_lh_₁(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²) | LH_N  => _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)}: 211
//│ [LH_N]: 154 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun_ls_h²) then [LH_C append_lh_₁(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²) | LH_N  => _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)}: 211
//│ ------------------
//│ case _lh_and_arg1⁰ of {LH_N  => [True] | LH_C _lh_and_LH_C_0⁰ _lh_and_LH_C_1⁰ => if _lh_and_LH_C_0⁰ then and_lh_₁(_lh_and_LH_C_1⁰) else [False] | _  => error⁰}: 10 --->
//│ 	[LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]: 110
//│ 	[LH_N]: 115
//│ case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 57 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₂((a⁰ + 1), b⁰)]: 27
//│ 	[LH_N]: 28
//│ case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_safe_LH_P2_0⁰ _lh_safe_LH_P2_1⁰ => [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 114 --->
//│ 	[LH_P2 hx⁰ hy⁰]: 47
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => case _lh_listcomp_fun_ls_h⁰ of {LH_P2 _lh_safe_LH_P2_0⁰ _lh_safe_LH_P2_1⁰ => [LH_C (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰))) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)] | _  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)} | LH_N  => [LH_N]}: 116 --->
//│ 	[LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)]: 53
//│ 	[LH_N]: 54
//│ 	[LH_N]: 56
//│ case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => if safe_lh_₁(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun_ls_h²) then [LH_C append_lh_₁(_lh_listcomp_fun_ls_h¹, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)] else _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²) | LH_N  => _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)}: 211 --->
//│ 	[LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b¹)]: 153
//│ 	[LH_N]: 154
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testAnotherQueenNineBuiltInType_lh_₁(primId⁰(9))
//│ def and_lh_₁(_lh_and_arg1¹) = _lh_and_arg1¹(99)
//│ def append_lh_₁(_lh_append_arg1¹, _lh_append_arg2¹) = case _lh_append_arg1¹ of {
//│ 	LH_N  => _lh_append_arg2¹
//│ 	| LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2¹)]
//│ 	| _  => error⁰}
//│ def enumFromTo_lh_₁(a³, b³) = if (a³ <= b³) then 
//│ 	let _lh_listcomp_fun_ls_t⁵ = enumFromTo_lh_₁((a³ + 1), b³)
//│ 	in let _lh_listcomp_fun_ls_h⁴ = a³
//│ 	in (fun _lh_listcomp_fun_ls_h⁵ -> (fun _lh_listcomp_fun⁹ -> (fun _lh_listcomp_fun_ls_t⁶ -> (fun _lh_listcomp_fun¹⁰ -> if safe_lh_₁(_lh_listcomp_fun_ls_h⁵, _lh_listcomp_fun_ls_h⁴) then [LH_C append_lh_₁(_lh_listcomp_fun_ls_h⁵, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁹(_lh_listcomp_fun_ls_t⁵)] else _lh_listcomp_fun⁹(_lh_listcomp_fun_ls_t⁵))))) else (fun _lh_listcomp_fun_ls_h⁶ -> (fun _lh_listcomp_fun¹¹ -> (fun _lh_listcomp_fun_ls_t⁷ -> (fun _lh_listcomp_fun¹² -> _lh_listcomp_fun¹²(_lh_listcomp_fun_ls_t⁷)))))
//│ def enumFromTo_lh_₂(a², b²) = if (a² <= b²) then 
//│ 	let tx¹ = enumFromTo_lh_₂((a² + 1), b²)
//│ 	in let hx¹ = a²
//│ 	in (fun ys² -> case ys² of {
//│ 		LH_C hy⁰ ty⁰ => 
//│ 			let _lh_listcomp_fun_ls_t³ = zip_lh_₁(tx¹, ty⁰)
//│ 			in let _lh_listcomp_fun_ls_h³ = 	
//│ 				let _lh_safe_LH_P2_1¹ = hy⁰
//│ 				in let _lh_safe_LH_P2_0¹ = hx¹
//│ 				in (fun _lh_listcomp_fun_ls_t⁴ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_safe_arg2² -> (fun m² -> 
//│ 					let _lh_and_LH_C_1¹ = _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)
//│ 					in let _lh_and_LH_C_0¹ = (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2²) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m² + _lh_safe_arg2²))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m² - _lh_safe_arg2²)))
//│ 					in (fun _lh_dummy⁰ -> if _lh_and_LH_C_0¹ then and_lh_₁(_lh_and_LH_C_1¹) else [False])))))
//│ 			in (fun _lh_listcomp_fun³ -> (fun _lh_safe_arg2¹ -> (fun m¹ -> _lh_listcomp_fun_ls_h³(_lh_listcomp_fun_ls_t³, _lh_listcomp_fun³, _lh_safe_arg2¹, m¹))))
//│ 		| LH_N  => (fun _lh_listcomp_fun⁵ -> (fun _lh_safe_arg2³ -> (fun m³ -> (fun _lh_dummy¹ -> [True]))))}) else (fun ys³ -> (fun _lh_listcomp_fun⁶ -> (fun _lh_safe_arg2⁴ -> (fun m⁴ -> (fun _lh_dummy² -> [True])))))
//│ def length_lh_₁(ls²) = case ls² of {
//│ 	LH_C h¹ t¹ => (1 + length_lh_₁(t¹))
//│ 	| LH_N  => 0}
//│ def length_lh_₂(ls³) = case ls³ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₂(t⁰))
//│ 	| LH_N  => 0}
//│ def queens_lh_₁(_lh_queens_arg1¹) = case _lh_queens_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun⁷ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 			LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => 
//│ 				let _lh_listcomp_fun⁸ = (fun _lh_listcomp_fun_para⁴ -> _lh_listcomp_fun_para⁴(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun⁸, _lh_listcomp_fun_ls_t¹, _lh_listcomp_fun⁷))
//│ 				in _lh_listcomp_fun⁸(enumFromTo_lh_₁(1, 9))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁷(queens_lh_₁((_lh_queens_arg1¹ - 1)))}
//│ def safe_lh_₁(_lh_safe_arg1¹, _lh_safe_arg2⁵) = 
//│ 	let m⁵ = (length_lh_₂(_lh_safe_arg1¹) + 1)
//│ 	in and_lh_₁(
//│ 		let _lh_listcomp_fun¹³ = (fun _lh_listcomp_fun_para⁵ -> _lh_listcomp_fun_para⁵(_lh_listcomp_fun¹³, _lh_safe_arg2⁵, m⁵))
//│ 		in _lh_listcomp_fun¹³(zip_lh_₁(enumFromTo_lh_₂(1, (m⁵ - 1)), _lh_safe_arg1¹)))
//│ def testAnotherQueenNineBuiltInType_lh_₁(_lh_testAnotherQueenNineBuiltInType_arg1¹) = length_lh_₁(queens_lh_₁(_lh_testAnotherQueenNineBuiltInType_arg1¹))
//│ def zip_lh_₁(xs¹, ys¹) = xs¹(ys¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ recursive consumer: queens_lh_₁
//│ safe_lh_₁, and_lh_₁, zip_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₂ -> 3
//│ enumFromTo_lh_₁ -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testAnotherQueenNineBuiltInType_lh_₁(primId⁰(9))
//│ def and_lh_₁(_lh_and_arg1⁰) = _lh_and_arg1⁰(99)
//│ def append_lh_₁(_lh_append_arg1⁰, _lh_append_arg2⁰) = case _lh_append_arg1⁰ of {
//│ 	LH_N  => _lh_append_arg2⁰
//│ 	| LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]
//│ 	| _  => error⁰}
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let _lh_listcomp_fun_ls_t³ = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let _lh_listcomp_fun_ls_h² = a¹
//│ 	in (fun _lh_listcomp_fun_ls_h³ -> (fun _lh_listcomp_fun⁶ -> (fun _lh_listcomp_fun_ls_t⁴ -> (fun _lh_listcomp_fun⁷ -> if 
//│ 		let m⁴ = (length_lh_₂(_lh_listcomp_fun_ls_h³) + 1)
//│ 		in let _lh_listcomp_fun⁸ = (fun _lh_listcomp_fun_para² -> _lh_listcomp_fun_para²(_lh_listcomp_fun⁸, _lh_listcomp_fun_ls_h², m⁴))
//│ 			in _lh_listcomp_fun⁸(enumFromTo_lh_₂(1, (m⁴ - 1), _lh_listcomp_fun_ls_h³))(99) then [LH_C append_lh_₁(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun⁶(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun⁶(_lh_listcomp_fun_ls_t³))))) else (fun _lh_listcomp_fun_ls_h⁴ -> (fun _lh_listcomp_fun⁹ -> (fun _lh_listcomp_fun_ls_t⁵ -> (fun _lh_listcomp_fun¹⁰ -> _lh_listcomp_fun¹⁰(_lh_listcomp_fun_ls_t⁵)))))
//│ def enumFromTo_lh_₂(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let tx⁰ = enumFromTo_lh_₂((a⁰ + 1), b⁰)
//│ 	in let hx⁰ = a⁰
//│ 	in (fun ys¹ -> case ys¹ of {
//│ 		LH_C hy⁰ ty⁰ => 
//│ 			let _lh_listcomp_fun_ls_t⁰ = tx⁰(ty⁰)
//│ 			in let _lh_listcomp_fun_ls_h⁰ = 	
//│ 				let _lh_safe_LH_P2_1⁰ = hy⁰
//│ 				in let _lh_safe_LH_P2_0⁰ = hx⁰
//│ 				in (fun _lh_listcomp_fun_ls_t¹ -> (fun _lh_listcomp_fun⁰ -> (fun _lh_safe_arg2⁰ -> (fun m⁰ -> 
//│ 					let _lh_and_LH_C_1⁰ = _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t¹)
//│ 					in let _lh_and_LH_C_0⁰ = (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰)))
//│ 					in (fun _lh_dummy⁰ -> if _lh_and_LH_C_0⁰ then _lh_and_LH_C_1⁰(99) else [False])))))
//│ 			in (fun _lh_listcomp_fun¹ -> (fun _lh_safe_arg2¹ -> (fun m¹ -> _lh_listcomp_fun_ls_h⁰(_lh_listcomp_fun_ls_t⁰, _lh_listcomp_fun¹, _lh_safe_arg2¹, m¹))))
//│ 		| LH_N  => (fun _lh_listcomp_fun² -> (fun _lh_safe_arg2² -> (fun m² -> (fun _lh_dummy¹ -> [True]))))}) else (fun ys² -> (fun _lh_listcomp_fun³ -> (fun _lh_safe_arg2³ -> (fun m³ -> (fun _lh_dummy² -> [True])))))
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def length_lh_₂(ls¹) = case ls¹ of {
//│ 	LH_C h¹ t¹ => (1 + length_lh_₂(t¹))
//│ 	| LH_N  => 0}
//│ def queens_lh_₁(_lh_queens_arg1⁰) = case _lh_queens_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 			LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t² => 
//│ 				let _lh_listcomp_fun⁵ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun⁵, _lh_listcomp_fun_ls_t², _lh_listcomp_fun⁴))
//│ 				in _lh_listcomp_fun⁵(enumFromTo_lh_₁(1, 9))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁴(queens_lh_₁((_lh_queens_arg1⁰ - 1)))}
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁴) = 
//│ 	let m⁵ = (length_lh_₂(_lh_safe_arg1⁰) + 1)
//│ 	in let _lh_listcomp_fun¹¹ = (fun _lh_listcomp_fun_para³ -> _lh_listcomp_fun_para³(_lh_listcomp_fun¹¹, _lh_safe_arg2⁴, m⁵))
//│ 		in _lh_listcomp_fun¹¹(enumFromTo_lh_₂(1, (m⁵ - 1), _lh_safe_arg1⁰))(99)
//│ def testAnotherQueenNineBuiltInType_lh_₁(_lh_testAnotherQueenNineBuiltInType_arg1⁰) = length_lh_₁(queens_lh_₁(_lh_testAnotherQueenNineBuiltInType_arg1⁰))
//│ def zip_lh_₁(xs⁰, ys⁰) = xs⁰(ys⁰)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testAnotherQueenNineBuiltInType_lh_₁(primId⁰(9))
//│ def and_lh_₁(_lh_and_arg1⁰) = _lh_and_arg1⁰(99)
//│ def append_lh_₁(_lh_append_arg1⁰, _lh_append_arg2⁰) = case _lh_append_arg1⁰ of {
//│ 	LH_N  => _lh_append_arg2⁰
//│ 	| LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]
//│ 	| _  => error⁰}
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let _lh_listcomp_fun_ls_t³ = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let _lh_listcomp_fun_ls_h² = a¹
//│ 	in (fun _lh_listcomp_fun_ls_h³ -> (fun _lh_listcomp_fun⁶ -> (fun _lh_listcomp_fun_ls_t⁴ -> (fun _lh_listcomp_fun⁷ -> if 
//│ 		let m⁴ = (length_lh_₂(_lh_listcomp_fun_ls_h³) + 1)
//│ 		in let _lh_listcomp_fun⁸ = (fun _lh_listcomp_fun_para² -> _lh_listcomp_fun_para²(_lh_listcomp_fun⁸, _lh_listcomp_fun_ls_h², m⁴))
//│ 			in _lh_listcomp_fun⁸(enumFromTo_lh_₂(1, (m⁴ - 1), _lh_listcomp_fun_ls_h³))(99) then [LH_C append_lh_₁(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h² [LH_N]]) _lh_listcomp_fun⁶(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun⁶(_lh_listcomp_fun_ls_t³))))) else (fun _lh_listcomp_fun_ls_h⁴ -> (fun _lh_listcomp_fun⁹ -> (fun _lh_listcomp_fun_ls_t⁵ -> (fun _lh_listcomp_fun¹⁰ -> _lh_listcomp_fun¹⁰(_lh_listcomp_fun_ls_t⁵)))))
//│ def enumFromTo_lh_₂(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let tx⁰ = enumFromTo_lh_₂((a⁰ + 1), b⁰)
//│ 	in let hx⁰ = a⁰
//│ 	in (fun ys¹ -> case ys¹ of {
//│ 		LH_C hy⁰ ty⁰ => 
//│ 			let _lh_listcomp_fun_ls_t⁰ = tx⁰(ty⁰)
//│ 			in let _lh_listcomp_fun_ls_h⁰ = 	
//│ 				let _lh_safe_LH_P2_1⁰ = hy⁰
//│ 				in let _lh_safe_LH_P2_0⁰ = hx⁰
//│ 				in (fun _lh_listcomp_fun_ls_t¹ -> (fun _lh_listcomp_fun⁰ -> (fun _lh_safe_arg2⁰ -> (fun m⁰ -> 
//│ 					let _lh_and_LH_C_1⁰ = _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t¹)
//│ 					in let _lh_and_LH_C_0⁰ = (((_lh_safe_LH_P2_1⁰ /= _lh_safe_arg2⁰) && ((_lh_safe_LH_P2_0⁰ + _lh_safe_LH_P2_1⁰) /= (m⁰ + _lh_safe_arg2⁰))) && ((_lh_safe_LH_P2_0⁰ - _lh_safe_LH_P2_1⁰) /= (m⁰ - _lh_safe_arg2⁰)))
//│ 					in (fun _lh_dummy⁰ -> if _lh_and_LH_C_0⁰ then _lh_and_LH_C_1⁰(99) else [False])))))
//│ 			in (fun _lh_listcomp_fun¹ -> (fun _lh_safe_arg2¹ -> (fun m¹ -> _lh_listcomp_fun_ls_h⁰(_lh_listcomp_fun_ls_t⁰, _lh_listcomp_fun¹, _lh_safe_arg2¹, m¹))))
//│ 		| LH_N  => (fun _lh_listcomp_fun² -> (fun _lh_safe_arg2² -> (fun m² -> (fun _lh_dummy¹ -> [True]))))}) else (fun ys² -> (fun _lh_listcomp_fun³ -> (fun _lh_safe_arg2³ -> (fun m³ -> (fun _lh_dummy² -> [True])))))
//│ def length_lh_₁(ls⁰) = case ls⁰ of {
//│ 	LH_C h⁰ t⁰ => (1 + length_lh_₁(t⁰))
//│ 	| LH_N  => 0}
//│ def length_lh_₂(ls¹) = case ls¹ of {
//│ 	LH_C h¹ t¹ => (1 + length_lh_₂(t¹))
//│ 	| LH_N  => 0}
//│ def queens_lh_₁(_lh_queens_arg1⁰) = case _lh_queens_arg1⁰ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 			LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t² => 
//│ 				let _lh_listcomp_fun⁵ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun_ls_h¹, _lh_listcomp_fun⁵, _lh_listcomp_fun_ls_t², _lh_listcomp_fun⁴))
//│ 				in _lh_listcomp_fun⁵(enumFromTo_lh_₁(1, 9))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁴(queens_lh_₁((_lh_queens_arg1⁰ - 1)))}
//│ def safe_lh_₁(_lh_safe_arg1⁰, _lh_safe_arg2⁴) = 
//│ 	let m⁵ = (length_lh_₂(_lh_safe_arg1⁰) + 1)
//│ 	in let _lh_listcomp_fun¹¹ = (fun _lh_listcomp_fun_para³ -> _lh_listcomp_fun_para³(_lh_listcomp_fun¹¹, _lh_safe_arg2⁴, m⁵))
//│ 		in _lh_listcomp_fun¹¹(enumFromTo_lh_₂(1, (m⁵ - 1), _lh_safe_arg1⁰))(99)
//│ def testAnotherQueenNineBuiltInType_lh_₁(_lh_testAnotherQueenNineBuiltInType_arg1⁰) = length_lh_₁(queens_lh_₁(_lh_testAnotherQueenNineBuiltInType_arg1⁰))
//│ def zip_lh_₁(xs⁰, ys⁰) = xs⁰(ys⁰)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<



:lhInHaskell
:lhGenOCaml
testSumMapEnumBuiltInType n = sum $ map (\x -> x * x) (enumFromTo 1 n)
testSumMapEnumBuiltInType $ primId 300000
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumMapEnumBuiltInType_lh_₁^72(primId⁰(300000))
//│ def enumFromTo_lh_₁(a¹, b⁰) = if (a¹ <= b⁰) then [LH_C a¹ enumFromTo_lh_₁^35((a¹ + 1), b⁰)] else [LH_N]
//│ def map_lh_₁(f⁰, ls¹) = case ls¹ of {
//│ 	LH_C h¹ t¹ => [LH_C f⁰(h¹) map_lh_₁^19(f⁰, t¹)]
//│ 	| LH_N  => [LH_N]}
//│ def sumAux_lh_₁(ls⁰, a⁰) = case ls⁰ of {
//│ 	LH_N  => a⁰
//│ 	| LH_C h⁰ t⁰ => sumAux_lh_₁^3(t⁰, (a⁰ + h⁰))}
//│ def sum_lh_₁(ls²) = sumAux_lh_₁^49(ls², 0)
//│ def testSumMapEnumBuiltInType_lh_₁(_lh_testSumMapEnumBuiltInType_arg1⁰) = sum_lh_₁^55(map_lh_₁^56((fun x⁰ -> (x⁰ * x⁰)), enumFromTo_lh_₁^64(1, _lh_testSumMapEnumBuiltInType_arg1⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec map_lh__d1 f_0 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `LH_C(h_1, t_1) -> 
//│ 		      (`LH_C((f_0 h_1), ((map_lh__d1 f_0) t_1)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec enumFromTo_lh__d1 a_1 b_0 =
//│ 		  (if (a_1 <= b_0) then
//│ 		    (`LH_C(a_1, ((enumFromTo_lh__d1 (a_1 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec sumAux_lh__d1 ls_0 a_0 =
//│ 		  (match ls_0 with
//│ 		    | `LH_N -> 
//│ 		      a_0
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      ((sumAux_lh__d1 t_0) (a_0 + h_0)));;
//│ 		let rec sum_lh__d1 ls_2 =
//│ 		  ((sumAux_lh__d1 ls_2) 0);;
//│ 		let rec testSumMapEnumBuiltInType_lh__d1 _lh_testSumMapEnumBuiltInType_arg1_0 =
//│ 		  (sum_lh__d1 ((map_lh__d1 (fun x_0 -> 
//│ 		    (x_0 * x_0))) ((enumFromTo_lh__d1 1) _lh_testSumMapEnumBuiltInType_arg1_0)));;
//│ 		(testSumMapEnumBuiltInType_lh__d1 300000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f⁰(h¹) map_lh_₁(f⁰, t¹)]: 24 --->
//│ 	case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12
//│ [LH_N]: 25 --->
//│ 	case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12
//│ [LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b⁰)]: 44 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => [LH_C f⁰(h¹) map_lh_₁(f⁰, t¹)] | LH_N  => [LH_N]}: 26
//│ [LH_N]: 45 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => [LH_C f⁰(h¹) map_lh_₁(f⁰, t¹)] | LH_N  => [LH_N]}: 26
//│ ------------------
//│ case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12 --->
//│ 	[LH_C f⁰(h¹) map_lh_₁(f⁰, t¹)]: 24
//│ 	[LH_N]: 25
//│ case ls¹ of {LH_C h¹ t¹ => [LH_C f⁰(h¹) map_lh_₁(f⁰, t¹)] | LH_N  => [LH_N]}: 26 --->
//│ 	[LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b⁰)]: 44
//│ 	[LH_N]: 45
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f⁰(h¹) map_lh_₁(f⁰, t¹)]: 24 --->
//│ 	case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12
//│ [LH_N]: 25 --->
//│ 	case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12
//│ [LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b⁰)]: 44 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => [LH_C f⁰(h¹) map_lh_₁(f⁰, t¹)] | LH_N  => [LH_N]}: 26
//│ [LH_N]: 45 --->
//│ 	case ls¹ of {LH_C h¹ t¹ => [LH_C f⁰(h¹) map_lh_₁(f⁰, t¹)] | LH_N  => [LH_N]}: 26
//│ ------------------
//│ case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12 --->
//│ 	[LH_C f⁰(h¹) map_lh_₁(f⁰, t¹)]: 24
//│ 	[LH_N]: 25
//│ case ls¹ of {LH_C h¹ t¹ => [LH_C f⁰(h¹) map_lh_₁(f⁰, t¹)] | LH_N  => [LH_N]}: 26 --->
//│ 	[LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b⁰)]: 44
//│ 	[LH_N]: 45
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumMapEnumBuiltInType_lh_₁(primId⁰(300000))
//│ def enumFromTo_lh_₁(a², b¹) = if (a² <= b¹) then 
//│ 	let t² = enumFromTo_lh_₁((a² + 1), b¹)
//│ 	in let h² = a²
//│ 	in (fun f² -> 
//│ 		let t³ = map_lh_₁(f², t²)
//│ 		in let h³ = f²(h²)
//│ 		in (fun a³ -> sumAux_lh_₁(t³, (a³ + h³)))) else (fun f³ -> (fun a⁴ -> a⁴))
//│ def map_lh_₁(f¹, ls⁴) = ls⁴(f¹)
//│ def sumAux_lh_₁(ls⁵, a⁵) = ls⁵(a⁵)
//│ def sum_lh_₁(ls³) = sumAux_lh_₁(ls³, 0)
//│ def testSumMapEnumBuiltInType_lh_₁(_lh_testSumMapEnumBuiltInType_arg1¹) = sum_lh_₁(map_lh_₁((fun x¹ -> (x¹ * x¹)), enumFromTo_lh_₁(1, _lh_testSumMapEnumBuiltInType_arg1¹)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ sumAux_lh_₁, map_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₁ -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testSumMapEnumBuiltInType_lh_₁(primId⁰(300000))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let t⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let h⁰ = a⁰
//│ 	in (fun f¹ -> 
//│ 		let t¹ = t⁰(f¹)
//│ 		in let h¹ = f¹(h⁰)
//│ 		in (fun a¹ -> t¹((a¹ + h¹)))) else (fun f² -> (fun a² -> a²))
//│ def map_lh_₁(f⁰, ls¹) = ls¹(f⁰)
//│ def sumAux_lh_₁(ls², a³) = ls²(a³)
//│ def sum_lh_₁(ls⁰) = ls⁰(0)
//│ def testSumMapEnumBuiltInType_lh_₁(_lh_testSumMapEnumBuiltInType_arg1⁰) = sum_lh_₁(enumFromTo_lh_₁(1, _lh_testSumMapEnumBuiltInType_arg1⁰, (fun x⁰ -> (x⁰ * x⁰))))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testSumMapEnumBuiltInType_lh_₁(primId⁰(300000))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let t⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let h⁰ = a⁰
//│ 	in (fun f¹ -> 
//│ 		let t¹ = t⁰(f¹)
//│ 		in let h¹ = f¹(h⁰)
//│ 		in (fun a¹ -> t¹((a¹ + h¹)))) else (fun f² -> (fun a² -> a²))
//│ def map_lh_₁(f⁰, ls¹) = ls¹(f⁰)
//│ def sumAux_lh_₁(ls², a³) = ls²(a³)
//│ def sum_lh_₁(ls⁰) = ls⁰(0)
//│ def testSumMapEnumBuiltInType_lh_₁(_lh_testSumMapEnumBuiltInType_arg1⁰) = sum_lh_₁(enumFromTo_lh_₁(1, _lh_testSumMapEnumBuiltInType_arg1⁰, (fun x⁰ -> (x⁰ * x⁰))))
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun genTree(n, i) = if n <= 0 then N(i) else T(genTree(n - 1, i), genTree(n - 1, i + 1))
fun flip(t) = if t is
  T(l, r) then T(flip(r), flip(l))
  N(v) then N(v)
fun ff(t) = flip(flip(t))
fun testFlipFlip(t) = ff(t)
testFlipFlip(primId(genTree(17, 0)))
//│ |#fun| |genTree|(|n|,| |i|)| |#=| |#if| |n| |<=| |0| |#then| |N|(|i|)| |#else| |T|(|genTree|(|n| |-| |1|,| |i|)|,| |genTree|(|n| |-| |1|,| |i| |+| |1|)|)|↵|#fun| |flip|(|t|)| |#=| |#if| |t| |is|→|T|(|l|,| |r|)| |#then| |T|(|flip|(|r|)|,| |flip|(|l|)|)|↵|N|(|v|)| |#then| |N|(|v|)|←|↵|#fun| |ff|(|t|)| |#=| |flip|(|flip|(|t|)|)|↵|#fun| |testFlipFlip|(|t|)| |#=| |ff|(|t|)|↵|testFlipFlip|(|primId|(|genTree|(|17|,| |0|)|)|)|
//│ Parsed: {fun genTree = n, i, => if (<= (n,) (0,)) then N (i,) else T (genTree (- (n,) (1,), i,), genTree (- (n,) (1,), + (i,) (1,),),); fun flip = t, => if t is ‹(T (l, r,)) then T (flip (r,), flip (l,),); (N (v,)) then N (v,)›; fun ff = t, => flip (flip (t,),); fun testFlipFlip = t, => ff (t,); testFlipFlip (primId (genTree (17, 0,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testFlipFlip^56(primId⁰(genTree^58(17, 0)))
//│ def ff(t¹) = flip^46(flip^47(t¹))
//│ def flip(t⁰) = case t⁰ of {
//│ 	T l⁰ r⁰ => [T flip^35(r⁰) flip^38(l⁰)]
//│ 	| N v⁰ => [N v⁰]}
//│ def genTree(n⁰, i⁰) = if (n⁰ <= 0) then [N i⁰] else [T genTree^8((n⁰ - 1), i⁰) genTree^17((n⁰ - 1), (i⁰ + 1))]
//│ def testFlipFlip(t²) = ff^52(t²)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec flip t_0 =
//│ 		  (match t_0 with
//│ 		    | `T(l_0, r_0) -> 
//│ 		      (`T((flip r_0), (flip l_0)))
//│ 		    | `N(v_0) -> 
//│ 		      (`N(v_0)));;
//│ 		let rec ff t_1 =
//│ 		  (flip (flip t_1));;
//│ 		let rec testFlipFlip t_2 =
//│ 		  (ff t_2);;
//│ 		let rec genTree n_0 i_0 =
//│ 		  (if (n_0 <= 0) then
//│ 		    (`N(i_0))
//│ 		  else
//│ 		    (`T(((genTree (n_0 - 1)) i_0), ((genTree (n_0 - 1)) (i_0 + 1)))));;
//│ 		(testFlipFlip ((genTree 17) 0))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [T flip(r⁰) flip(l⁰)]: 41 --->
//│ 	NoCons
//│ 	case t⁰ of {T l⁰ r⁰ => [T flip(r⁰) flip(l⁰)] | N v⁰ => [N v⁰]}: 44
//│ [N v⁰]: 43 --->
//│ 	NoCons
//│ 	case t⁰ of {T l⁰ r⁰ => [T flip(r⁰) flip(l⁰)] | N v⁰ => [N v⁰]}: 44
//│ ------------------
//│ case t⁰ of {T l⁰ r⁰ => [T flip(r⁰) flip(l⁰)] | N v⁰ => [N v⁰]}: 44 --->
//│ 	NoProd
//│ 	[T flip(r⁰) flip(l⁰)]: 41
//│ 	[N v⁰]: 43
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testFlipFlip(primId⁰(genTree(17, 0)))
//│ def ff(t⁴) = flip(flip(t⁴))
//│ def flip(t³) = case t³ of {
//│ 	T l⁰ r⁰ => [T flip(r⁰) flip(l⁰)]
//│ 	| N v⁰ => [N v⁰]}
//│ def genTree(n¹, i¹) = if (n¹ <= 0) then [N i¹] else [T genTree((n¹ - 1), i¹) genTree((n¹ - 1), (i¹ + 1))]
//│ def testFlipFlip(t⁵) = ff(t⁵)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testFlipFlip(primId⁰(genTree(17, 0)))
//│ def ff(t¹) = flip(flip(t¹))
//│ def flip(t⁰) = case t⁰ of {
//│ 	T l⁰ r⁰ => [T flip(r⁰) flip(l⁰)]
//│ 	| N v⁰ => [N v⁰]}
//│ def genTree(n⁰, i⁰) = if (n⁰ <= 0) then [N i⁰] else [T genTree((n⁰ - 1), i⁰) genTree((n⁰ - 1), (i⁰ + 1))]
//│ def testFlipFlip(t²) = ff(t²)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testFlipFlip(primId⁰(genTree(17, 0)))
//│ def ff(t¹) = flip(flip(t¹))
//│ def flip(t⁰) = case t⁰ of {
//│ 	T l⁰ r⁰ => [T flip(r⁰) flip(l⁰)]
//│ 	| N v⁰ => [N v⁰]}
//│ def genTree(n⁰, i⁰) = if (n⁰ <= 0) then [N i⁰] else [T genTree((n⁰ - 1), i⁰) genTree((n⁰ - 1), (i⁰ + 1))]
//│ def testFlipFlip(t²) = ff(t²)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun foldl(f, s, ls) = if ls is
  C(h, t) then foldl(f, f(s, h), t)
  N then s
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun testFoldMap(n) = foldl(
  i => x => i + x,
  0,
  map(x => x * x, primId(enumFromTo(1, n)))
)
testFoldMap(primId(300000))
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |foldl|(|f|,| |s|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |foldl|(|f|,| |f|(|s|,| |h|)|,| |t|)|↵|N| |#then| |s|←|↵|#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |testFoldMap|(|n|)| |#=| |foldl|(|→|i| |=>| |x| |=>| |i| |+| |x|,|↵|0|,|↵|map|(|x| |=>| |x| |*| |x|,| |primId|(|enumFromTo|(|1|,| |n|)|)|)|←|↵|)|↵|testFoldMap|(|primId|(|300000|)|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun foldl = f, s, ls, => if ls is ‹(C (h, t,)) then foldl (f, f (s, h,), t,); (N) then s›; fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun testFoldMap = n, => foldl (i, => x, => + (i,) (x,), 0, map (x, => * (x,) (x,), primId (enumFromTo (1, n,),),),); testFoldMap (primId (300000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testFoldMap^81(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^38((a⁰ + 1), b⁰)] else [N]
//│ def foldl(f¹, s⁰, ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => foldl^16(f¹, f¹(s⁰, h¹), t¹)
//│ 	| N  => s⁰}
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def testFoldMap(n⁰) = foldl^52((fun i⁰ -> (fun x⁰ -> (i⁰ + x⁰))), 0, map^63((fun x¹ -> (x¹ * x¹)), primId⁰(enumFromTo^72(1, n⁰))))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec foldl f_1 s_0 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (((foldl f_1) ((f_1 s_0) h_1)) t_1)
//│ 		    | `N -> 
//│ 		      s_0);;
//│ 		let rec map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec testFoldMap n_0 =
//│ 		  (((foldl (fun i_0 x_0 -> 
//│ 		    (i_0 + x_0))) 0) ((map (fun x_1 -> 
//│ 		    (x_1 * x_1))) ((enumFromTo 1) n_0)));;
//│ 		(testFoldMap 300000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(f⁰, t⁰)]: 10 --->
//│ 	case ls¹ of {C h¹ t¹ => foldl(f¹, f¹(s⁰, h¹), t¹) | N  => s⁰}: 28
//│ [N]: 11 --->
//│ 	case ls¹ of {C h¹ t¹ => foldl(f¹, f¹(s⁰, h¹), t¹) | N  => s⁰}: 28
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => foldl(f¹, f¹(s⁰, h¹), t¹) | N  => s⁰}: 28 --->
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h⁰) map(f⁰, t⁰)]: 10 --->
//│ 	case ls¹ of {C h¹ t¹ => foldl(f¹, f¹(s⁰, h¹), t¹) | N  => s⁰}: 28
//│ [N]: 11 --->
//│ 	case ls¹ of {C h¹ t¹ => foldl(f¹, f¹(s⁰, h¹), t¹) | N  => s⁰}: 28
//│ ------------------
//│ case ls¹ of {C h¹ t¹ => foldl(f¹, f¹(s⁰, h¹), t¹) | N  => s⁰}: 28 --->
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 10
//│ 	[N]: 11
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testFoldMap(primId⁰(300000))
//│ def enumFromTo(a¹, b¹) = if (a¹ <= b¹) then [C a¹ enumFromTo((a¹ + 1), b¹)] else [N]
//│ def foldl(f⁵, s³, ls³) = ls³(f⁵, s³)
//│ def map(f², ls²) = case ls² of {
//│ 	C h⁰ t⁰ => 
//│ 		let t² = map(f², t⁰)
//│ 		in let h² = f²(h⁰)
//│ 		in (fun f³ -> (fun s¹ -> foldl(f³, f³(s¹, h²), t²)))
//│ 	| N  => (fun f⁴ -> (fun s² -> s²))}
//│ def testFoldMap(n¹) = foldl((fun i¹ -> (fun x² -> (i¹ + x²))), 0, map((fun x³ -> (x³ * x³)), primId⁰(enumFromTo(1, n¹))))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ foldl
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ map -> 4
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testFoldMap(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo((a⁰ + 1), b⁰)] else [N]
//│ def foldl(f³, s², ls¹) = ls¹(f³, s²)
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t¹ = map(f⁰, t⁰)
//│ 		in let h¹ = f⁰(h⁰)
//│ 		in (fun f¹ -> (fun s⁰ -> t¹(f¹, f¹(s⁰, h¹))))
//│ 	| N  => (fun f² -> (fun s¹ -> s¹))}
//│ def testFoldMap(n⁰) = map((fun x⁰ -> (x⁰ * x⁰)), primId⁰(enumFromTo(1, n⁰)), (fun i⁰ -> (fun x¹ -> (i⁰ + x¹))), 0)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testFoldMap(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo((a⁰ + 1), b⁰)] else [N]
//│ def foldl(f¹, s⁰, ls¹) = ls¹(f¹, s⁰)
//│ def map(f⁰, ls⁰, _lh_popOutId_0⁰, _lh_popOutId_1⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t¹ = map(f⁰, t⁰)
//│ 		in let h¹ = f⁰(h⁰)
//│ 		in t¹(_lh_popOutId_0⁰, _lh_popOutId_0⁰(_lh_popOutId_1⁰, h¹))
//│ 	| N  => _lh_popOutId_1⁰}
//│ def testFoldMap(n⁰) = map((fun x⁰ -> (x⁰ * x⁰)), primId⁰(enumFromTo(1, n⁰)), (fun i⁰ -> (fun x¹ -> (i⁰ + x¹))), 0)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun map(f, xs) = if xs is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun qrev(a, ys) = if ys is
  C(h, t) then qrev(C(h, a), t)
  N then a
fun testMapQrev(ls) = map(x => x + 1, qrev(N, ls))
testMapQrev(primId(enumFromTo(1, 10000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |map|(|f|,| |xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |qrev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |qrev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |testMapQrev|(|ls|)| |#=| |map|(|x| |=>| |x| |+| |1|,| |qrev|(|N|,| |ls|)|)|↵|testMapQrev|(|primId|(|enumFromTo|(|1|,| |10000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun map = f, xs, => if xs is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun qrev = a, ys, => if ys is ‹(C (h, t,)) then qrev (C (h, a,), t,); (N) then a›; fun testMapQrev = ls, => map (x, => + (x,) (1,), qrev (N, ls,),); testMapQrev (primId (enumFromTo (1, 10000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapQrev^62(primId⁰(enumFromTo^64(1, 10000)))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^25(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def qrev(a¹, ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => qrev^36([C h¹ a¹], t¹)
//│ 	| N  => a¹}
//│ def testMapQrev(ls⁰) = map^47((fun x⁰ -> (x⁰ + 1)), qrev^55([N], ls⁰))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec map f_0 xs_0 =
//│ 		  (match xs_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec qrev a_1 ys_0 =
//│ 		  (match ys_0 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      ((qrev (`C(h_1, a_1))) t_1)
//│ 		    | `N -> 
//│ 		      a_1);;
//│ 		let rec testMapQrev ls_0 =
//│ 		  ((map (fun x_0 -> 
//│ 		    (x_0 + 1))) ((qrev (`N)) ls_0));;
//│ 		(testMapQrev ((enumFromTo 1) 10000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h¹ a¹]: 39 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 32
//│ [N]: 56 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 32
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 32 --->
//│ 	[C h¹ a¹]: 39
//│ 	[N]: 56
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h¹ a¹]: 39 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 32
//│ [N]: 56 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 32
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => [C f⁰(h⁰) map(f⁰, t⁰)] | N  => [N]}: 32 --->
//│ 	[C h¹ a¹]: 39
//│ 	[N]: 56
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapQrev(primId⁰(enumFromTo(1, 10000)))
//│ def enumFromTo(a², b¹) = if (a² <= b¹) then [C a² enumFromTo((a² + 1), b¹)] else [N]
//│ def map(f¹, xs¹) = xs¹(f¹)
//│ def qrev(a³, ys¹) = case ys¹ of {
//│ 	C h¹ t¹ => qrev(
//│ 		let t² = a³
//│ 		in let h² = h¹
//│ 		in (fun f² -> [C f²(h²) map(f², t²)]), t¹)
//│ 	| N  => a³}
//│ def testMapQrev(ls¹) = map((fun x¹ -> (x¹ + 1)), qrev((fun f³ -> [N]), ls¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ map
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ qrev -> 2
//│ testMapQrev -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testMapQrev(primId⁰(enumFromTo(1, 10000)))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, xs⁰) = xs⁰(f⁰)
//│ def qrev(a¹, ys⁰) = case ys⁰ of {
//│ 	C h⁰ t⁰ => qrev(
//│ 		let t¹ = a¹
//│ 		in let h¹ = h⁰
//│ 		in (fun f¹ -> [C f¹(h¹) t¹(f¹)]), t⁰)
//│ 	| N  => a¹}
//│ def testMapQrev(ls⁰) = qrev((fun f² -> [N]), ls⁰, (fun x⁰ -> (x⁰ + 1)))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testMapQrev(primId⁰(enumFromTo(1, 10000)))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, xs⁰) = xs⁰(f⁰)
//│ def qrev(a¹, ys⁰) = case ys⁰ of {
//│ 	C h⁰ t⁰ => qrev(
//│ 		let t¹ = a¹
//│ 		in let h¹ = h⁰
//│ 		in (fun f¹ -> [C f¹(h¹) t¹(f¹)]), t⁰)
//│ 	| N  => a¹}
//│ def testMapQrev(ls⁰) = qrev((fun f² -> [N]), ls⁰, (fun x⁰ -> (x⁰ + 1)))
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun map(f, xs) = if xs is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun qrev(a, ys) = if ys is
  C(h, t) then qrev(C(h, a), t)
  N then a
fun _lhManualQrevMap(f, xs, a) = if xs is
  C(h, t) then _lhManualQrevMap(f, t, C(f(h), a))
  N then a
fun testQrevMap(ls) = qrev(N, map(x => x + 1, ls))
fun testManual(ls) = _lhManualQrevMap(x => x + 1, ls, N)
testQrevMap(primId(enumFromTo(1, 10000)))
testManual(primId(enumFromTo(1, 10000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |map|(|f|,| |xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |qrev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |qrev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |_lhManualQrevMap|(|f|,| |xs|,| |a|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |_lhManualQrevMap|(|f|,| |t|,| |C|(|f|(|h|)|,| |a|)|)|↵|N| |#then| |a|←|↵|#fun| |testQrevMap|(|ls|)| |#=| |qrev|(|N|,| |map|(|x| |=>| |x| |+| |1|,| |ls|)|)|↵|#fun| |testManual|(|ls|)| |#=| |_lhManualQrevMap|(|x| |=>| |x| |+| |1|,| |ls|,| |N|)|↵|testQrevMap|(|primId|(|enumFromTo|(|1|,| |10000|)|)|)|↵|testManual|(|primId|(|enumFromTo|(|1|,| |10000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun map = f, xs, => if xs is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun qrev = a, ys, => if ys is ‹(C (h, t,)) then qrev (C (h, a,), t,); (N) then a›; fun _lhManualQrevMap = f, xs, a, => if xs is ‹(C (h, t,)) then _lhManualQrevMap (f, t, C (f (h,), a,),); (N) then a›; fun testQrevMap = ls, => qrev (N, map (x, => + (x,) (1,), ls,),); fun testManual = ls, => _lhManualQrevMap (x, => + (x,) (1,), ls, N,); testQrevMap (primId (enumFromTo (1, 10000,),),); testManual (primId (enumFromTo (1, 10000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testQrevMap^92(primId⁰(enumFromTo^94(1, 10000)))
//│ testManual^101(primId⁰(enumFromTo^103(1, 10000)))
//│ def _lhManualQrevMap(f¹, xs¹, a²) = case xs¹ of {
//│ 	C h² t² => _lhManualQrevMap^48(f¹, t², [C f¹(h²) a²])
//│ 	| N  => a²}
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^25(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def qrev(a¹, ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => qrev^36([C h¹ a¹], t¹)
//│ 	| N  => a¹}
//│ def testManual(ls¹) = _lhManualQrevMap^79((fun x¹ -> (x¹ + 1)), ls¹, [N])
//│ def testQrevMap(ls⁰) = qrev^64([N], map^67((fun x⁰ -> (x⁰ + 1)), ls⁰))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec _lhManualQrevMap f_1 xs_1 a_2 =
//│ 		  (match xs_1 with
//│ 		    | `C(h_2, t_2) -> 
//│ 		      (((_lhManualQrevMap f_1) t_2) (`C((f_1 h_2), a_2)))
//│ 		    | `N -> 
//│ 		      a_2);;
//│ 		let rec testManual ls_1 =
//│ 		  (((_lhManualQrevMap (fun x_1 -> 
//│ 		    (x_1 + 1))) ls_1) (`N));;
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N));;
//│ 		let rec qrev a_1 ys_0 =
//│ 		  (match ys_0 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      ((qrev (`C(h_1, a_1))) t_1)
//│ 		    | `N -> 
//│ 		      a_1);;
//│ 		let rec map f_0 xs_0 =
//│ 		  (match xs_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N));;
//│ 		let rec testQrevMap ls_0 =
//│ 		  ((qrev (`N)) ((map (fun x_0 -> 
//│ 		    (x_0 + 1))) ls_0));;
//│ 		(testQrevMap ((enumFromTo 1) 10000))
//│ 		(testManual ((enumFromTo 1) 10000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f⁰(h⁰) map(f⁰, t⁰)]: 30 --->
//│ 	case ys⁰ of {C h¹ t¹ => qrev([C h¹ a¹], t¹) | N  => a¹}: 44
//│ [N]: 31 --->
//│ 	case ys⁰ of {C h¹ t¹ => qrev([C h¹ a¹], t¹) | N  => a¹}: 44
//│ ------------------
//│ case ys⁰ of {C h¹ t¹ => qrev([C h¹ a¹], t¹) | N  => a¹}: 44 --->
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 30
//│ 	[N]: 31
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f⁰(h⁰) map(f⁰, t⁰)]: 30 --->
//│ 	case ys⁰ of {C h¹ t¹ => qrev([C h¹ a¹], t¹) | N  => a¹}: 44
//│ [N]: 31 --->
//│ 	case ys⁰ of {C h¹ t¹ => qrev([C h¹ a¹], t¹) | N  => a¹}: 44
//│ ------------------
//│ case ys⁰ of {C h¹ t¹ => qrev([C h¹ a¹], t¹) | N  => a¹}: 44 --->
//│ 	[C f⁰(h⁰) map(f⁰, t⁰)]: 30
//│ 	[N]: 31
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testQrevMap(primId⁰(enumFromTo(1, 10000)))
//│ testManual(primId⁰(enumFromTo(1, 10000)))
//│ def _lhManualQrevMap(f³, xs³, a⁵) = case xs³ of {
//│ 	C h² t² => _lhManualQrevMap(f³, t², [C f³(h²) a⁵])
//│ 	| N  => a⁵}
//│ def enumFromTo(a⁷, b¹) = if (a⁷ <= b¹) then [C a⁷ enumFromTo((a⁷ + 1), b¹)] else [N]
//│ def map(f², xs²) = case xs² of {
//│ 	C h⁰ t⁰ => 
//│ 		let t³ = map(f², t⁰)
//│ 		in let h³ = f²(h⁰)
//│ 		in (fun a³ -> qrev([C h³ a³], t³))
//│ 	| N  => (fun a⁴ -> a⁴)}
//│ def qrev(a⁶, ys¹) = ys¹(a⁶)
//│ def testManual(ls³) = _lhManualQrevMap((fun x³ -> (x³ + 1)), ls³, [N])
//│ def testQrevMap(ls²) = qrev([N], map((fun x² -> (x² + 1)), ls²))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ qrev
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ map -> 3
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testQrevMap(primId⁰(enumFromTo(1, 10000)))
//│ testManual(primId⁰(enumFromTo(1, 10000)))
//│ def _lhManualQrevMap(f¹, xs¹, a²) = case xs¹ of {
//│ 	C h² t² => _lhManualQrevMap(f¹, t², [C f¹(h²) a²])
//│ 	| N  => a²}
//│ def enumFromTo(a⁴, b⁰) = if (a⁴ <= b⁰) then [C a⁴ enumFromTo((a⁴ + 1), b⁰)] else [N]
//│ def map(f⁰, xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t¹ = map(f⁰, t⁰)
//│ 		in let h¹ = f⁰(h⁰)
//│ 		in (fun a⁰ -> t¹([C h¹ a⁰]))
//│ 	| N  => (fun a¹ -> a¹)}
//│ def qrev(a³, ys⁰) = ys⁰(a³)
//│ def testManual(ls¹) = _lhManualQrevMap((fun x¹ -> (x¹ + 1)), ls¹, [N])
//│ def testQrevMap(ls⁰) = map((fun x⁰ -> (x⁰ + 1)), ls⁰, [N])
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testQrevMap(primId⁰(enumFromTo(1, 10000)))
//│ testManual(primId⁰(enumFromTo(1, 10000)))
//│ def _lhManualQrevMap(f¹, xs¹, a⁰) = case xs¹ of {
//│ 	C h² t² => _lhManualQrevMap(f¹, t², [C f¹(h²) a⁰])
//│ 	| N  => a⁰}
//│ def enumFromTo(a², b⁰) = if (a² <= b⁰) then [C a² enumFromTo((a² + 1), b⁰)] else [N]
//│ def map(f⁰, xs⁰, _lh_popOutId_0⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let t¹ = map(f⁰, t⁰)
//│ 		in let h¹ = f⁰(h⁰)
//│ 		in t¹([C h¹ _lh_popOutId_0⁰])
//│ 	| N  => _lh_popOutId_0⁰}
//│ def qrev(a¹, ys⁰) = ys⁰(a¹)
//│ def testManual(ls¹) = _lhManualQrevMap((fun x¹ -> (x¹ + 1)), ls¹, [N])
//│ def testQrevMap(ls⁰) = map((fun x⁰ -> (x⁰ + 1)), ls⁰, [N])
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
testSumListComprehensionBuiltInType n = sum [ k * m | k <- [1..n], m <- [1..k] ]
testSumListComprehensionBuiltInType $ primId 1000
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumListComprehensionBuiltInType_lh_₁^99(primId⁰(1000))
//│ def enumFromTo_lh_₁(a², b¹) = if (a² <= b¹) then [LH_C a² enumFromTo_lh_₁^41((a² + 1), b¹)] else [LH_N]
//│ def enumFromTo_lh_₂(a¹, b⁰) = if (a¹ <= b⁰) then [LH_C a¹ enumFromTo_lh_₂^21((a¹ + 1), b⁰)] else [LH_N]
//│ def sumAux_lh_₁(ls⁰, a⁰) = case ls⁰ of {
//│ 	LH_N  => a⁰
//│ 	| LH_C h⁰ t⁰ => sumAux_lh_₁^3(t⁰, (a⁰ + h⁰))}
//│ def sum_lh_₁(ls¹) = sumAux_lh_₁^55(ls¹, 0)
//│ def testSumListComprehensionBuiltInType_lh_₁(_lh_testSumListComprehensionBuiltInType_arg1⁰) = sum_lh_₁^61(
//│ 	let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 		LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => 
//│ 			let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 				LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]
//│ 				| LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ 			in _lh_listcomp_fun¹(enumFromTo_lh_₂^79(1, _lh_listcomp_fun_ls_h⁰))
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun⁰(enumFromTo_lh_₁^90(1, _lh_testSumListComprehensionBuiltInType_arg1⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_lh__d1 a_2 b_1 =
//│ 		  (if (a_2 <= b_1) then
//│ 		    (`LH_C(a_2, ((enumFromTo_lh__d1 (a_2 + 1)) b_1)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec enumFromTo_lh__d2 a_1 b_0 =
//│ 		  (if (a_1 <= b_0) then
//│ 		    (`LH_C(a_1, ((enumFromTo_lh__d2 (a_1 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec sumAux_lh__d1 ls_0 a_0 =
//│ 		  (match ls_0 with
//│ 		    | `LH_N -> 
//│ 		      a_0
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      ((sumAux_lh__d1 t_0) (a_0 + h_0)));;
//│ 		let rec sum_lh__d1 ls_1 =
//│ 		  ((sumAux_lh__d1 ls_1) 0);;
//│ 		let rec testSumListComprehensionBuiltInType_lh__d1 _lh_testSumListComprehensionBuiltInType_arg1_0 =
//│ 		  (sum_lh__d1 (let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│ 		    (match _lh_listcomp_fun_para_0 with
//│ 		      | `LH_C(_lh_listcomp_fun_ls_h_0, _lh_listcomp_fun_ls_t_0) -> 
//│ 		        (let rec _lh_listcomp_fun_1 = (fun _lh_listcomp_fun_para_1 -> 
//│ 		          (match _lh_listcomp_fun_para_1 with
//│ 		            | `LH_C(_lh_listcomp_fun_ls_h_1, _lh_listcomp_fun_ls_t_1) -> 
//│ 		              (`LH_C((_lh_listcomp_fun_ls_h_0 * _lh_listcomp_fun_ls_h_1), (_lh_listcomp_fun_1 _lh_listcomp_fun_ls_t_1)))
//│ 		            | `LH_N -> 
//│ 		              (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0))) in
//│ 		          (_lh_listcomp_fun_1 ((enumFromTo_lh__d2 1) _lh_listcomp_fun_ls_h_0)))
//│ 		      | `LH_N -> 
//│ 		        (`LH_N))) in
//│ 		    (_lh_listcomp_fun_0 ((enumFromTo_lh__d1 1) _lh_testSumListComprehensionBuiltInType_arg1_0))));;
//│ 		(testSumListComprehensionBuiltInType_lh__d1 1000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a¹ enumFromTo_lh_₂((a¹ + 1), b⁰)]: 30 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 76
//│ [LH_N]: 31 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 76
//│ [LH_C a² enumFromTo_lh_₁((a² + 1), b¹)]: 50 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₂(1, _lh_listcomp_fun_ls_h⁰)) | LH_N  => [LH_N]}: 87
//│ [LH_N]: 51 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₂(1, _lh_listcomp_fun_ls_h⁰)) | LH_N  => [LH_N]}: 87
//│ [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 72 --->
//│ 	case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12
//│ [LH_N]: 86 --->
//│ 	case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12
//│ ------------------
//│ case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12 --->
//│ 	[LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 72
//│ 	[LH_N]: 86
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 76 --->
//│ 	[LH_C a¹ enumFromTo_lh_₂((a¹ + 1), b⁰)]: 30
//│ 	[LH_N]: 31
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₂(1, _lh_listcomp_fun_ls_h⁰)) | LH_N  => [LH_N]}: 87 --->
//│ 	[LH_C a² enumFromTo_lh_₁((a² + 1), b¹)]: 50
//│ 	[LH_N]: 51
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a¹ enumFromTo_lh_₂((a¹ + 1), b⁰)]: 30 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 76
//│ [LH_N]: 31 --->
//│ 	case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 76
//│ [LH_C a² enumFromTo_lh_₁((a² + 1), b¹)]: 50 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₂(1, _lh_listcomp_fun_ls_h⁰)) | LH_N  => [LH_N]}: 87
//│ [LH_N]: 51 --->
//│ 	case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₂(1, _lh_listcomp_fun_ls_h⁰)) | LH_N  => [LH_N]}: 87
//│ [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 72 --->
//│ 	case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12
//│ [LH_N]: 86 --->
//│ 	case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12
//│ ------------------
//│ case ls⁰ of {LH_N  => a⁰ | LH_C h⁰ t⁰ => sumAux_lh_₁(t⁰, (a⁰ + h⁰))}: 12 --->
//│ 	[LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]: 72
//│ 	[LH_N]: 86
//│ case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)}: 76 --->
//│ 	[LH_C a¹ enumFromTo_lh_₂((a¹ + 1), b⁰)]: 30
//│ 	[LH_N]: 31
//│ case _lh_listcomp_fun_para⁰ of {LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C (_lh_listcomp_fun_ls_h⁰ * _lh_listcomp_fun_ls_h¹) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)] | LH_N  => _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)})
//│ in _lh_listcomp_fun¹(enumFromTo_lh_₂(1, _lh_listcomp_fun_ls_h⁰)) | LH_N  => [LH_N]}: 87 --->
//│ 	[LH_C a² enumFromTo_lh_₁((a² + 1), b¹)]: 50
//│ 	[LH_N]: 51
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumListComprehensionBuiltInType_lh_₁(primId⁰(1000))
//│ def enumFromTo_lh_₁(a⁵, b³) = if (a⁵ <= b³) then 
//│ 	let _lh_listcomp_fun_ls_t⁵ = enumFromTo_lh_₁((a⁵ + 1), b³)
//│ 	in let _lh_listcomp_fun_ls_h⁵ = a⁵
//│ 	in (fun _lh_listcomp_fun⁷ -> 
//│ 		let _lh_listcomp_fun⁸ = (fun _lh_listcomp_fun_para³ -> _lh_listcomp_fun_para³(_lh_listcomp_fun_ls_h⁵, _lh_listcomp_fun⁸, _lh_listcomp_fun_ls_t⁵, _lh_listcomp_fun⁷))
//│ 		in _lh_listcomp_fun⁸(enumFromTo_lh_₂(1, _lh_listcomp_fun_ls_h⁵))) else (fun _lh_listcomp_fun⁹ -> (fun a⁶ -> a⁶))
//│ def enumFromTo_lh_₂(a³, b²) = if (a³ <= b²) then 
//│ 	let _lh_listcomp_fun_ls_t² = enumFromTo_lh_₂((a³ + 1), b²)
//│ 	in let _lh_listcomp_fun_ls_h² = a³
//│ 	in (fun _lh_listcomp_fun_ls_h³ -> (fun _lh_listcomp_fun² -> (fun _lh_listcomp_fun_ls_t³ -> (fun _lh_listcomp_fun³ -> 
//│ 		let t¹ = _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)
//│ 		in let h¹ = (_lh_listcomp_fun_ls_h³ * _lh_listcomp_fun_ls_h²)
//│ 		in (fun a⁴ -> sumAux_lh_₁(t¹, (a⁴ + h¹))))))) else (fun _lh_listcomp_fun_ls_h⁴ -> (fun _lh_listcomp_fun⁴ -> (fun _lh_listcomp_fun_ls_t⁴ -> (fun _lh_listcomp_fun⁵ -> _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁴)))))
//│ def sumAux_lh_₁(ls³, a⁷) = ls³(a⁷)
//│ def sum_lh_₁(ls²) = sumAux_lh_₁(ls², 0)
//│ def testSumListComprehensionBuiltInType_lh_₁(_lh_testSumListComprehensionBuiltInType_arg1¹) = sum_lh_₁(
//│ 	let _lh_listcomp_fun⁶ = (fun _lh_listcomp_fun_para² -> _lh_listcomp_fun_para²(_lh_listcomp_fun⁶))
//│ 	in _lh_listcomp_fun⁶(enumFromTo_lh_₁(1, _lh_testSumListComprehensionBuiltInType_arg1¹)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ sumAux_lh_₁, testSumListComprehensionBuiltInType_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₂ -> 2
//│ enumFromTo_lh_₁ -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ sum_lh_₁(
//│ 	let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> _lh_listcomp_fun_para⁰(_lh_listcomp_fun⁰))
//│ 	in _lh_listcomp_fun⁰(enumFromTo_lh_₁(1, primId⁰(1000))))
//│ def enumFromTo_lh_₁(a², b¹) = if (a² <= b¹) then 
//│ 	let _lh_listcomp_fun_ls_t³ = enumFromTo_lh_₁((a² + 1), b¹)
//│ 	in let _lh_listcomp_fun_ls_h³ = a²
//│ 	in (fun _lh_listcomp_fun⁶ -> 
//│ 		let _lh_listcomp_fun⁷ = (fun _lh_listcomp_fun_para² -> _lh_listcomp_fun_para²(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun⁷, _lh_listcomp_fun_ls_t³, _lh_listcomp_fun⁶))
//│ 		in _lh_listcomp_fun⁷(enumFromTo_lh_₂(1, _lh_listcomp_fun_ls_h³))) else (fun _lh_listcomp_fun⁸ -> (fun a³ -> a³))
//│ def enumFromTo_lh_₂(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_listcomp_fun_ls_t⁰ = enumFromTo_lh_₂((a⁰ + 1), b⁰)
//│ 	in let _lh_listcomp_fun_ls_h⁰ = a⁰
//│ 	in (fun _lh_listcomp_fun_ls_h¹ -> (fun _lh_listcomp_fun¹ -> (fun _lh_listcomp_fun_ls_t¹ -> (fun _lh_listcomp_fun² -> 
//│ 		let t⁰ = _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t⁰)
//│ 		in let h⁰ = (_lh_listcomp_fun_ls_h¹ * _lh_listcomp_fun_ls_h⁰)
//│ 		in (fun a¹ -> t⁰((a¹ + h⁰))))))) else (fun _lh_listcomp_fun_ls_h² -> (fun _lh_listcomp_fun³ -> (fun _lh_listcomp_fun_ls_t² -> (fun _lh_listcomp_fun⁴ -> _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t²)))))
//│ def sumAux_lh_₁(ls¹, a⁴) = ls¹(a⁴)
//│ def sum_lh_₁(ls⁰) = ls⁰(0)
//│ def testSumListComprehensionBuiltInType_lh_₁(_lh_testSumListComprehensionBuiltInType_arg1⁰) = sum_lh_₁(
//│ 	let _lh_listcomp_fun⁵ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun⁵))
//│ 	in _lh_listcomp_fun⁵(enumFromTo_lh_₁(1, _lh_testSumListComprehensionBuiltInType_arg1⁰)))
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ sum_lh_₁(
//│ 	let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> _lh_listcomp_fun_para⁰(_lh_listcomp_fun⁰))
//│ 	in _lh_listcomp_fun⁰(enumFromTo_lh_₁(1, primId⁰(1000))))
//│ def enumFromTo_lh_₁(a², b¹) = if (a² <= b¹) then 
//│ 	let _lh_listcomp_fun_ls_t³ = enumFromTo_lh_₁((a² + 1), b¹)
//│ 	in let _lh_listcomp_fun_ls_h³ = a²
//│ 	in (fun _lh_listcomp_fun⁶ -> 
//│ 		let _lh_listcomp_fun⁷ = (fun _lh_listcomp_fun_para² -> _lh_listcomp_fun_para²(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun⁷, _lh_listcomp_fun_ls_t³, _lh_listcomp_fun⁶))
//│ 		in _lh_listcomp_fun⁷(enumFromTo_lh_₂(1, _lh_listcomp_fun_ls_h³))) else (fun _lh_listcomp_fun⁸ -> (fun a³ -> a³))
//│ def enumFromTo_lh_₂(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_listcomp_fun_ls_t⁰ = enumFromTo_lh_₂((a⁰ + 1), b⁰)
//│ 	in let _lh_listcomp_fun_ls_h⁰ = a⁰
//│ 	in (fun _lh_listcomp_fun_ls_h¹ -> (fun _lh_listcomp_fun¹ -> (fun _lh_listcomp_fun_ls_t¹ -> (fun _lh_listcomp_fun² -> 
//│ 		let t⁰ = _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t⁰)
//│ 		in let h⁰ = (_lh_listcomp_fun_ls_h¹ * _lh_listcomp_fun_ls_h⁰)
//│ 		in (fun a¹ -> t⁰((a¹ + h⁰))))))) else (fun _lh_listcomp_fun_ls_h² -> (fun _lh_listcomp_fun³ -> (fun _lh_listcomp_fun_ls_t² -> (fun _lh_listcomp_fun⁴ -> _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t²)))))
//│ def sumAux_lh_₁(ls¹, a⁴) = ls¹(a⁴)
//│ def sum_lh_₁(ls⁰) = ls⁰(0)
//│ def testSumListComprehensionBuiltInType_lh_₁(_lh_testSumListComprehensionBuiltInType_arg1⁰) = sum_lh_₁(
//│ 	let _lh_listcomp_fun⁵ = (fun _lh_listcomp_fun_para¹ -> _lh_listcomp_fun_para¹(_lh_listcomp_fun⁵))
//│ 	in _lh_listcomp_fun⁵(enumFromTo_lh_₁(1, _lh_testSumListComprehensionBuiltInType_arg1⁰)))
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhInHaskell
:lhGenOCaml
flatMap f [] = []
flatMap f (h:t) = (f h) ++ (flatMap f t)
summ s [] = s
summ s (h:t) = summ (s+h) t
testSumFlatmapEnum n = summ 0 $ flatMap (\a -> [a, a]) [1..n]
testSumFlatmapEnum $ primId 100000
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumFlatmapEnum_lh_₁^84(primId⁰(100000))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^51((a⁰ + 1), b⁰)] else [LH_N]
//│ def flatMap_lh_₁(_lh_flatMap_arg1⁰, _lh_flatMap_arg2⁰) = case _lh_flatMap_arg2⁰ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => mappend_lh_₁^30(_lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰), flatMap_lh_₁^35(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁^3(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def summ_lh_₁(_lh_summ_arg1⁰, _lh_summ_arg2⁰) = case _lh_summ_arg2⁰ of {
//│ 	LH_N  => _lh_summ_arg1⁰
//│ 	| LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => summ_lh_₁^15((_lh_summ_arg1⁰ + _lh_summ_LH_C_0⁰), _lh_summ_LH_C_1⁰)
//│ 	| _  => error⁰}
//│ def testSumFlatmapEnum_lh_₁(_lh_testSumFlatmapEnum_arg1⁰) = summ_lh_₁^65(0, flatMap_lh_₁^68((fun a¹ -> [LH_C a¹ [LH_C a¹ [LH_N]]]), enumFromTo_lh_₁^76(1, _lh_testSumFlatmapEnum_arg1⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec summ_lh__d1 _lh_summ_arg1_0 _lh_summ_arg2_0 =
//│ 		  (match _lh_summ_arg2_0 with
//│ 		    | `LH_N -> 
//│ 		      _lh_summ_arg1_0
//│ 		    | `LH_C(_lh_summ_LH_C_0_0, _lh_summ_LH_C_1_0) -> 
//│ 		      ((summ_lh__d1 (_lh_summ_arg1_0 + _lh_summ_LH_C_0_0)) _lh_summ_LH_C_1_0)
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec mappend_lh__d1 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (`LH_C(h_0, ((mappend_lh__d1 t_0) ys_0)))
//│ 		    | `LH_N -> 
//│ 		      ys_0);;
//│ 		let rec flatMap_lh__d1 _lh_flatMap_arg1_0 _lh_flatMap_arg2_0 =
//│ 		  (match _lh_flatMap_arg2_0 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_flatMap_LH_C_0_0, _lh_flatMap_LH_C_1_0) -> 
//│ 		      ((mappend_lh__d1 (_lh_flatMap_arg1_0 _lh_flatMap_LH_C_0_0)) ((flatMap_lh__d1 _lh_flatMap_arg1_0) _lh_flatMap_LH_C_1_0))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec enumFromTo_lh__d1 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d1 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec testSumFlatmapEnum_lh__d1 _lh_testSumFlatmapEnum_arg1_0 =
//│ 		  ((summ_lh__d1 0) ((flatMap_lh__d1 (fun a_1 -> 
//│ 		    (`LH_C(a_1, (`LH_C(a_1, (`LH_N))))))) ((enumFromTo_lh__d1 1) _lh_testSumFlatmapEnum_arg1_0)));;
//│ 		(testSumFlatmapEnum_lh__d1 100000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8 --->
//│ 	case _lh_summ_arg2⁰ of {LH_N  => _lh_summ_arg1⁰ | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => summ_lh_₁((_lh_summ_arg1⁰ + _lh_summ_LH_C_0⁰), _lh_summ_LH_C_1⁰) | _  => error⁰}: 25
//│ [LH_N]: 29 --->
//│ 	case _lh_summ_arg2⁰ of {LH_N  => _lh_summ_arg1⁰ | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => summ_lh_₁((_lh_summ_arg1⁰ + _lh_summ_LH_C_0⁰), _lh_summ_LH_C_1⁰) | _  => error⁰}: 25
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 60 --->
//│ 	case _lh_flatMap_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => mappend_lh_₁(_lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰), flatMap_lh_₁(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰)) | _  => error⁰}: 42
//│ [LH_N]: 61 --->
//│ 	case _lh_flatMap_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => mappend_lh_₁(_lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰), flatMap_lh_₁(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰)) | _  => error⁰}: 42
//│ [LH_N]: 71 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C a¹ [LH_N]]: 72 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C a¹ [LH_C a¹ [LH_N]]]: 73 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10 --->
//│ 	[LH_N]: 71
//│ 	[LH_C a¹ [LH_N]]: 72
//│ 	[LH_C a¹ [LH_C a¹ [LH_N]]]: 73
//│ case _lh_summ_arg2⁰ of {LH_N  => _lh_summ_arg1⁰ | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => summ_lh_₁((_lh_summ_arg1⁰ + _lh_summ_LH_C_0⁰), _lh_summ_LH_C_1⁰) | _  => error⁰}: 25 --->
//│ 	[LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8
//│ 	[LH_N]: 29
//│ case _lh_flatMap_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => mappend_lh_₁(_lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰), flatMap_lh_₁(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰)) | _  => error⁰}: 42 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 60
//│ 	[LH_N]: 61
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8 --->
//│ 	case _lh_summ_arg2⁰ of {LH_N  => _lh_summ_arg1⁰ | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => summ_lh_₁((_lh_summ_arg1⁰ + _lh_summ_LH_C_0⁰), _lh_summ_LH_C_1⁰) | _  => error⁰}: 25
//│ [LH_N]: 29 --->
//│ 	case _lh_summ_arg2⁰ of {LH_N  => _lh_summ_arg1⁰ | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => summ_lh_₁((_lh_summ_arg1⁰ + _lh_summ_LH_C_0⁰), _lh_summ_LH_C_1⁰) | _  => error⁰}: 25
//│ [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 60 --->
//│ 	case _lh_flatMap_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => mappend_lh_₁(_lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰), flatMap_lh_₁(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰)) | _  => error⁰}: 42
//│ [LH_N]: 61 --->
//│ 	case _lh_flatMap_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => mappend_lh_₁(_lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰), flatMap_lh_₁(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰)) | _  => error⁰}: 42
//│ [LH_N]: 71 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C a¹ [LH_N]]: 72 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C a¹ [LH_C a¹ [LH_N]]]: 73 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10 --->
//│ 	[LH_N]: 71
//│ 	[LH_C a¹ [LH_N]]: 72
//│ 	[LH_C a¹ [LH_C a¹ [LH_N]]]: 73
//│ case _lh_summ_arg2⁰ of {LH_N  => _lh_summ_arg1⁰ | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => summ_lh_₁((_lh_summ_arg1⁰ + _lh_summ_LH_C_0⁰), _lh_summ_LH_C_1⁰) | _  => error⁰}: 25 --->
//│ 	[LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8
//│ 	[LH_N]: 29
//│ case _lh_flatMap_arg2⁰ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => mappend_lh_₁(_lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰), flatMap_lh_₁(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰)) | _  => error⁰}: 42 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)]: 60
//│ 	[LH_N]: 61
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumFlatmapEnum_lh_₁(primId⁰(100000))
//│ def enumFromTo_lh_₁(a², b¹) = if (a² <= b¹) then 
//│ 	let _lh_flatMap_LH_C_1¹ = enumFromTo_lh_₁((a² + 1), b¹)
//│ 	in let _lh_flatMap_LH_C_0¹ = a²
//│ 	in (fun _lh_flatMap_arg1¹ -> mappend_lh_₁(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_lh_₁(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹))) else (fun _lh_flatMap_arg1² -> (fun _lh_summ_arg1¹ -> _lh_summ_arg1¹))
//│ def flatMap_lh_₁(_lh_flatMap_arg1³, _lh_flatMap_arg2¹) = _lh_flatMap_arg2¹(_lh_flatMap_arg1³)
//│ def mappend_lh_₁(xs¹, ys¹) = xs¹(ys¹)
//│ def summ_lh_₁(_lh_summ_arg1², _lh_summ_arg2¹) = _lh_summ_arg2¹(_lh_summ_arg1²)
//│ def testSumFlatmapEnum_lh_₁(_lh_testSumFlatmapEnum_arg1¹) = summ_lh_₁(0, flatMap_lh_₁((fun a³ -> 
//│ 	let t¹ = 	
//│ 		let t² = (fun ys⁴ -> ys⁴)
//│ 		in let h² = a³
//│ 		in (fun ys³ -> 
//│ 			let _lh_summ_LH_C_1² = mappend_lh_₁(t², ys³)
//│ 			in let _lh_summ_LH_C_0² = h²
//│ 			in (fun _lh_summ_arg1⁴ -> summ_lh_₁((_lh_summ_arg1⁴ + _lh_summ_LH_C_0²), _lh_summ_LH_C_1²)))
//│ 	in let h¹ = a³
//│ 	in (fun ys² -> 
//│ 		let _lh_summ_LH_C_1¹ = mappend_lh_₁(t¹, ys²)
//│ 		in let _lh_summ_LH_C_0¹ = h¹
//│ 		in (fun _lh_summ_arg1³ -> summ_lh_₁((_lh_summ_arg1³ + _lh_summ_LH_C_0¹), _lh_summ_LH_C_1¹)))), enumFromTo_lh_₁(1, _lh_testSumFlatmapEnum_arg1¹)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ summ_lh_₁, flatMap_lh_₁, mappend_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₁ -> 3
//│ testSumFlatmapEnum_lh_₁ -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testSumFlatmapEnum_lh_₁(primId⁰(100000))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_flatMap_LH_C_1⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_flatMap_LH_C_0⁰ = a⁰
//│ 	in (fun _lh_flatMap_arg1⁰ -> _lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰, _lh_flatMap_LH_C_1⁰(_lh_flatMap_arg1⁰))) else (fun _lh_flatMap_arg1¹ -> (fun _lh_summ_arg1⁰ -> _lh_summ_arg1⁰))
//│ def flatMap_lh_₁(_lh_flatMap_arg1², _lh_flatMap_arg2⁰) = _lh_flatMap_arg2⁰(_lh_flatMap_arg1²)
//│ def mappend_lh_₁(xs⁰, ys⁰) = xs⁰(ys⁰)
//│ def summ_lh_₁(_lh_summ_arg1¹, _lh_summ_arg2⁰) = _lh_summ_arg2⁰(_lh_summ_arg1¹)
//│ def testSumFlatmapEnum_lh_₁(_lh_testSumFlatmapEnum_arg1⁰) = enumFromTo_lh_₁(1, _lh_testSumFlatmapEnum_arg1⁰, (fun a¹ -> 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun ys¹ -> ys¹)
//│ 		in let h⁰ = a¹
//│ 		in (fun ys² -> 
//│ 			let _lh_summ_LH_C_1⁰ = t¹(ys²)
//│ 			in let _lh_summ_LH_C_0⁰ = h⁰
//│ 			in (fun _lh_summ_arg1² -> _lh_summ_LH_C_1⁰((_lh_summ_arg1² + _lh_summ_LH_C_0⁰))))
//│ 	in let h¹ = a¹
//│ 	in (fun ys³ -> 
//│ 		let _lh_summ_LH_C_1¹ = t⁰(ys³)
//│ 		in let _lh_summ_LH_C_0¹ = h¹
//│ 		in (fun _lh_summ_arg1³ -> _lh_summ_LH_C_1¹((_lh_summ_arg1³ + _lh_summ_LH_C_0¹))))), 0)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testSumFlatmapEnum_lh_₁(primId⁰(100000))
//│ def enumFromTo_lh_₁(a⁰, b⁰, _lh_popOutId_0⁰) = if (a⁰ <= b⁰) then 
//│ 	let _lh_flatMap_LH_C_1⁰ = enumFromTo_lh_₁((a⁰ + 1), b⁰)
//│ 	in let _lh_flatMap_LH_C_0⁰ = a⁰
//│ 	in _lh_popOutId_0⁰(_lh_flatMap_LH_C_0⁰, _lh_flatMap_LH_C_1⁰(_lh_popOutId_0⁰)) else (fun _lh_summ_arg1⁰ -> _lh_summ_arg1⁰)
//│ def flatMap_lh_₁(_lh_flatMap_arg1⁰, _lh_flatMap_arg2⁰) = _lh_flatMap_arg2⁰(_lh_flatMap_arg1⁰)
//│ def mappend_lh_₁(xs⁰, ys⁰) = xs⁰(ys⁰)
//│ def summ_lh_₁(_lh_summ_arg1¹, _lh_summ_arg2⁰) = _lh_summ_arg2⁰(_lh_summ_arg1¹)
//│ def testSumFlatmapEnum_lh_₁(_lh_testSumFlatmapEnum_arg1⁰) = enumFromTo_lh_₁(1, _lh_testSumFlatmapEnum_arg1⁰, (fun a¹ -> 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun ys¹ -> ys¹)
//│ 		in let h⁰ = a¹
//│ 		in (fun ys² -> 
//│ 			let _lh_summ_LH_C_1⁰ = t¹(ys²)
//│ 			in let _lh_summ_LH_C_0⁰ = h⁰
//│ 			in (fun _lh_summ_arg1² -> _lh_summ_LH_C_1⁰((_lh_summ_arg1² + _lh_summ_LH_C_0⁰))))
//│ 	in let h¹ = a¹
//│ 	in (fun ys³ -> 
//│ 		let _lh_summ_LH_C_1¹ = t⁰(ys³)
//│ 		in let _lh_summ_LH_C_0¹ = h¹
//│ 		in (fun _lh_summ_arg1³ -> _lh_summ_LH_C_1¹((_lh_summ_arg1³ + _lh_summ_LH_C_0¹))))), 0)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
flatMap f [] = []
flatMap f (h:t) = (f h) ++ (flatMap f t)
summ s [] = s
summ s (h:t) = summ (s+h) t
testSumFlatmap n = summ 0 $ flatMap (\a -> [a, a]) (primId [1..n])
testSumFlatmap $ primId 100000
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumFlatmap_lh_₁^86(primId⁰(100000))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁^34((a⁰ + 1), b⁰)] else [LH_N]
//│ def flatMap_lh_₁(_lh_flatMap_arg1⁰, _lh_flatMap_arg2⁰) = case _lh_flatMap_arg2⁰ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => mappend_lh_₁^50(_lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰), flatMap_lh_₁^55(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def mappend_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁^3(t⁰, ys⁰)]
//│ 	| LH_N  => ys⁰}
//│ def summ_lh_₁(_lh_summ_arg1⁰, _lh_summ_arg2⁰) = case _lh_summ_arg2⁰ of {
//│ 	LH_N  => _lh_summ_arg1⁰
//│ 	| LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => summ_lh_₁^15((_lh_summ_arg1⁰ + _lh_summ_LH_C_0⁰), _lh_summ_LH_C_1⁰)
//│ 	| _  => error⁰}
//│ def testSumFlatmap_lh_₁(_lh_testSumFlatmap_arg1⁰) = summ_lh_₁^65(0, flatMap_lh_₁^68((fun a¹ -> [LH_C a¹ [LH_C a¹ [LH_N]]]), primId⁰(enumFromTo_lh_₁^77(1, _lh_testSumFlatmap_arg1⁰))))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo_lh__d1 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d1 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec summ_lh__d1 _lh_summ_arg1_0 _lh_summ_arg2_0 =
//│ 		  (match _lh_summ_arg2_0 with
//│ 		    | `LH_N -> 
//│ 		      _lh_summ_arg1_0
//│ 		    | `LH_C(_lh_summ_LH_C_0_0, _lh_summ_LH_C_1_0) -> 
//│ 		      ((summ_lh__d1 (_lh_summ_arg1_0 + _lh_summ_LH_C_0_0)) _lh_summ_LH_C_1_0)
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec mappend_lh__d1 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(h_0, t_0) -> 
//│ 		      (`LH_C(h_0, ((mappend_lh__d1 t_0) ys_0)))
//│ 		    | `LH_N -> 
//│ 		      ys_0);;
//│ 		let rec flatMap_lh__d1 _lh_flatMap_arg1_0 _lh_flatMap_arg2_0 =
//│ 		  (match _lh_flatMap_arg2_0 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_flatMap_LH_C_0_0, _lh_flatMap_LH_C_1_0) -> 
//│ 		      ((mappend_lh__d1 (_lh_flatMap_arg1_0 _lh_flatMap_LH_C_0_0)) ((flatMap_lh__d1 _lh_flatMap_arg1_0) _lh_flatMap_LH_C_1_0))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec testSumFlatmap_lh__d1 _lh_testSumFlatmap_arg1_0 =
//│ 		  ((summ_lh__d1 0) ((flatMap_lh__d1 (fun a_1 -> 
//│ 		    (`LH_C(a_1, (`LH_C(a_1, (`LH_N))))))) ((enumFromTo_lh__d1 1) _lh_testSumFlatmap_arg1_0)));;
//│ 		(testSumFlatmap_lh__d1 100000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8 --->
//│ 	case _lh_summ_arg2⁰ of {LH_N  => _lh_summ_arg1⁰ | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => summ_lh_₁((_lh_summ_arg1⁰ + _lh_summ_LH_C_0⁰), _lh_summ_LH_C_1⁰) | _  => error⁰}: 25
//│ [LH_N]: 49 --->
//│ 	case _lh_summ_arg2⁰ of {LH_N  => _lh_summ_arg1⁰ | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => summ_lh_₁((_lh_summ_arg1⁰ + _lh_summ_LH_C_0⁰), _lh_summ_LH_C_1⁰) | _  => error⁰}: 25
//│ [LH_N]: 71 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C a¹ [LH_N]]: 72 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C a¹ [LH_C a¹ [LH_N]]]: 73 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10 --->
//│ 	[LH_N]: 71
//│ 	[LH_C a¹ [LH_N]]: 72
//│ 	[LH_C a¹ [LH_C a¹ [LH_N]]]: 73
//│ case _lh_summ_arg2⁰ of {LH_N  => _lh_summ_arg1⁰ | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => summ_lh_₁((_lh_summ_arg1⁰ + _lh_summ_LH_C_0⁰), _lh_summ_LH_C_1⁰) | _  => error⁰}: 25 --->
//│ 	[LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8
//│ 	[LH_N]: 49
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8 --->
//│ 	case _lh_summ_arg2⁰ of {LH_N  => _lh_summ_arg1⁰ | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => summ_lh_₁((_lh_summ_arg1⁰ + _lh_summ_LH_C_0⁰), _lh_summ_LH_C_1⁰) | _  => error⁰}: 25
//│ [LH_N]: 49 --->
//│ 	case _lh_summ_arg2⁰ of {LH_N  => _lh_summ_arg1⁰ | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => summ_lh_₁((_lh_summ_arg1⁰ + _lh_summ_LH_C_0⁰), _lh_summ_LH_C_1⁰) | _  => error⁰}: 25
//│ [LH_N]: 71 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C a¹ [LH_N]]: 72 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ [LH_C a¹ [LH_C a¹ [LH_N]]]: 73 --->
//│ 	case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10
//│ ------------------
//│ case xs⁰ of {LH_C h⁰ t⁰ => [LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)] | LH_N  => ys⁰}: 10 --->
//│ 	[LH_N]: 71
//│ 	[LH_C a¹ [LH_N]]: 72
//│ 	[LH_C a¹ [LH_C a¹ [LH_N]]]: 73
//│ case _lh_summ_arg2⁰ of {LH_N  => _lh_summ_arg1⁰ | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => summ_lh_₁((_lh_summ_arg1⁰ + _lh_summ_LH_C_0⁰), _lh_summ_LH_C_1⁰) | _  => error⁰}: 25 --->
//│ 	[LH_C h⁰ mappend_lh_₁(t⁰, ys⁰)]: 8
//│ 	[LH_N]: 49
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumFlatmap_lh_₁(primId⁰(100000))
//│ def enumFromTo_lh_₁(a², b¹) = if (a² <= b¹) then [LH_C a² enumFromTo_lh_₁((a² + 1), b¹)] else [LH_N]
//│ def flatMap_lh_₁(_lh_flatMap_arg1¹, _lh_flatMap_arg2¹) = case _lh_flatMap_arg2¹ of {
//│ 	LH_N  => (fun _lh_summ_arg1² -> _lh_summ_arg1²)
//│ 	| LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => mappend_lh_₁(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0⁰), flatMap_lh_₁(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def mappend_lh_₁(xs¹, ys¹) = xs¹(ys¹)
//│ def summ_lh_₁(_lh_summ_arg1¹, _lh_summ_arg2¹) = _lh_summ_arg2¹(_lh_summ_arg1¹)
//│ def testSumFlatmap_lh_₁(_lh_testSumFlatmap_arg1¹) = summ_lh_₁(0, flatMap_lh_₁((fun a³ -> 
//│ 	let t¹ = 	
//│ 		let t² = (fun ys⁴ -> ys⁴)
//│ 		in let h² = a³
//│ 		in (fun ys³ -> 
//│ 			let _lh_summ_LH_C_1² = mappend_lh_₁(t², ys³)
//│ 			in let _lh_summ_LH_C_0² = h²
//│ 			in (fun _lh_summ_arg1⁴ -> summ_lh_₁((_lh_summ_arg1⁴ + _lh_summ_LH_C_0²), _lh_summ_LH_C_1²)))
//│ 	in let h¹ = a³
//│ 	in (fun ys² -> 
//│ 		let _lh_summ_LH_C_1¹ = mappend_lh_₁(t¹, ys²)
//│ 		in let _lh_summ_LH_C_0¹ = h¹
//│ 		in (fun _lh_summ_arg1³ -> summ_lh_₁((_lh_summ_arg1³ + _lh_summ_LH_C_0¹), _lh_summ_LH_C_1¹)))), primId⁰(enumFromTo_lh_₁(1, _lh_testSumFlatmap_arg1¹))))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ summ_lh_₁, mappend_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ flatMap_lh_₁ -> 2
//│ testSumFlatmap_lh_₁ -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testSumFlatmap_lh_₁(primId⁰(100000))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)] else [LH_N]
//│ def flatMap_lh_₁(_lh_flatMap_arg1⁰, _lh_flatMap_arg2⁰) = case _lh_flatMap_arg2⁰ of {
//│ 	LH_N  => (fun _lh_summ_arg1¹ -> _lh_summ_arg1¹)
//│ 	| LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => _lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰, flatMap_lh_₁(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def mappend_lh_₁(xs⁰, ys⁰) = xs⁰(ys⁰)
//│ def summ_lh_₁(_lh_summ_arg1⁰, _lh_summ_arg2⁰) = _lh_summ_arg2⁰(_lh_summ_arg1⁰)
//│ def testSumFlatmap_lh_₁(_lh_testSumFlatmap_arg1⁰) = flatMap_lh_₁((fun a¹ -> 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun ys¹ -> ys¹)
//│ 		in let h⁰ = a¹
//│ 		in (fun ys² -> 
//│ 			let _lh_summ_LH_C_1⁰ = t¹(ys²)
//│ 			in let _lh_summ_LH_C_0⁰ = h⁰
//│ 			in (fun _lh_summ_arg1² -> _lh_summ_LH_C_1⁰((_lh_summ_arg1² + _lh_summ_LH_C_0⁰))))
//│ 	in let h¹ = a¹
//│ 	in (fun ys³ -> 
//│ 		let _lh_summ_LH_C_1¹ = t⁰(ys³)
//│ 		in let _lh_summ_LH_C_0¹ = h¹
//│ 		in (fun _lh_summ_arg1³ -> _lh_summ_LH_C_1¹((_lh_summ_arg1³ + _lh_summ_LH_C_0¹))))), primId⁰(enumFromTo_lh_₁(1, _lh_testSumFlatmap_arg1⁰)), 0)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testSumFlatmap_lh_₁(primId⁰(100000))
//│ def enumFromTo_lh_₁(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₁((a⁰ + 1), b⁰)] else [LH_N]
//│ def flatMap_lh_₁(_lh_flatMap_arg1⁰, _lh_flatMap_arg2⁰) = case _lh_flatMap_arg2⁰ of {
//│ 	LH_N  => (fun _lh_summ_arg1¹ -> _lh_summ_arg1¹)
//│ 	| LH_C _lh_flatMap_LH_C_0⁰ _lh_flatMap_LH_C_1⁰ => _lh_flatMap_arg1⁰(_lh_flatMap_LH_C_0⁰, flatMap_lh_₁(_lh_flatMap_arg1⁰, _lh_flatMap_LH_C_1⁰))
//│ 	| _  => error⁰}
//│ def mappend_lh_₁(xs⁰, ys⁰) = xs⁰(ys⁰)
//│ def summ_lh_₁(_lh_summ_arg1⁰, _lh_summ_arg2⁰) = _lh_summ_arg2⁰(_lh_summ_arg1⁰)
//│ def testSumFlatmap_lh_₁(_lh_testSumFlatmap_arg1⁰) = flatMap_lh_₁((fun a¹ -> 
//│ 	let t⁰ = 	
//│ 		let t¹ = (fun ys¹ -> ys¹)
//│ 		in let h⁰ = a¹
//│ 		in (fun ys² -> 
//│ 			let _lh_summ_LH_C_1⁰ = t¹(ys²)
//│ 			in let _lh_summ_LH_C_0⁰ = h⁰
//│ 			in (fun _lh_summ_arg1² -> _lh_summ_LH_C_1⁰((_lh_summ_arg1² + _lh_summ_LH_C_0⁰))))
//│ 	in let h¹ = a¹
//│ 	in (fun ys³ -> 
//│ 		let _lh_summ_LH_C_1¹ = t⁰(ys³)
//│ 		in let _lh_summ_LH_C_0¹ = h¹
//│ 		in (fun _lh_summ_arg1³ -> _lh_summ_LH_C_1¹((_lh_summ_arg1³ + _lh_summ_LH_C_0¹))))), primId⁰(enumFromTo_lh_₁(1, _lh_testSumFlatmap_arg1⁰)), 0)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
fun sqTree(t) = if t is
  T(v, l, r) then T(v * v, sqTree(l), sqTree(r))
  L then L
fun sumTree(t) = if t is
  T(v, l, r) then v + sumTree(l) + sumTree(r)
  L then 0
fun genTree(n) = if n > 0 then T(n, genTree(n - 1), genTree(n - 1)) else L
fun testSumSquareTree(n) = sumTree(sqTree(primId(genTree(n))))
testSumSquareTree(primId(18))
//│ |#fun| |sqTree|(|t|)| |#=| |#if| |t| |is|→|T|(|v|,| |l|,| |r|)| |#then| |T|(|v| |*| |v|,| |sqTree|(|l|)|,| |sqTree|(|r|)|)|↵|L| |#then| |L|←|↵|#fun| |sumTree|(|t|)| |#=| |#if| |t| |is|→|T|(|v|,| |l|,| |r|)| |#then| |v| |+| |sumTree|(|l|)| |+| |sumTree|(|r|)|↵|L| |#then| |0|←|↵|#fun| |genTree|(|n|)| |#=| |#if| |n| |>| |0| |#then| |T|(|n|,| |genTree|(|n| |-| |1|)|,| |genTree|(|n| |-| |1|)|)| |#else| |L|↵|#fun| |testSumSquareTree|(|n|)| |#=| |sumTree|(|sqTree|(|primId|(|genTree|(|n|)|)|)|)|↵|testSumSquareTree|(|primId|(|18|)|)|
//│ Parsed: {fun sqTree = t, => if t is ‹(T (v, l, r,)) then T (* (v,) (v,), sqTree (l,), sqTree (r,),); (L) then L›; fun sumTree = t, => if t is ‹(T (v, l, r,)) then + (+ (v,) (sumTree (l,),),) (sumTree (r,),); (L) then 0›; fun genTree = n, => if (> (n,) (0,)) then T (n, genTree (- (n,) (1,),), genTree (- (n,) (1,),),) else L; fun testSumSquareTree = n, => sumTree (sqTree (primId (genTree (n,),),),); testSumSquareTree (primId (18,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumSquareTree^68(primId⁰(18))
//│ def genTree(n⁰) = if (n⁰ > 0) then [T n⁰ genTree^40((n⁰ - 1)) genTree^47((n⁰ - 1))] else [L]
//│ def sqTree(t⁰) = case t⁰ of {
//│ 	T v⁰ l⁰ r⁰ => [T (v⁰ * v⁰) sqTree^7(l⁰) sqTree^10(r⁰)]
//│ 	| L  => [L]}
//│ def sumTree(t¹) = case t¹ of {
//│ 	T v¹ l¹ r¹ => ((v¹ + sumTree^22(l¹)) + sumTree^27(r¹))
//│ 	| L  => 0}
//│ def testSumSquareTree(n¹) = sumTree^58(sqTree^59(primId⁰(genTree^61(n¹))))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec sqTree t_0 =
//│ 		  (match t_0 with
//│ 		    | `T(v_0, l_0, r_0) -> 
//│ 		      (`T((v_0 * v_0), (sqTree l_0), (sqTree r_0)))
//│ 		    | `L -> 
//│ 		      (`L));;
//│ 		let rec sumTree t_1 =
//│ 		  (match t_1 with
//│ 		    | `T(v_1, l_1, r_1) -> 
//│ 		      ((v_1 + (sumTree l_1)) + (sumTree r_1))
//│ 		    | `L -> 
//│ 		      0);;
//│ 		let rec genTree n_0 =
//│ 		  (if (n_0 > 0) then
//│ 		    (`T(n_0, (genTree (n_0 - 1)), (genTree (n_0 - 1))))
//│ 		  else
//│ 		    (`L));;
//│ 		let rec testSumSquareTree n_1 =
//│ 		  (sumTree (sqTree (genTree n_1)));;
//│ 		(testSumSquareTree 18)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [T (v⁰ * v⁰) sqTree(l⁰) sqTree(r⁰)]: 13 --->
//│ 	case t¹ of {T v¹ l¹ r¹ => ((v¹ + sumTree(l¹)) + sumTree(r¹)) | L  => 0}: 32
//│ [L]: 14 --->
//│ 	case t¹ of {T v¹ l¹ r¹ => ((v¹ + sumTree(l¹)) + sumTree(r¹)) | L  => 0}: 32
//│ ------------------
//│ case t¹ of {T v¹ l¹ r¹ => ((v¹ + sumTree(l¹)) + sumTree(r¹)) | L  => 0}: 32 --->
//│ 	[T (v⁰ * v⁰) sqTree(l⁰) sqTree(r⁰)]: 13
//│ 	[L]: 14
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [T (v⁰ * v⁰) sqTree(l⁰) sqTree(r⁰)]: 13 --->
//│ 	case t¹ of {T v¹ l¹ r¹ => ((v¹ + sumTree(l¹)) + sumTree(r¹)) | L  => 0}: 32
//│ [L]: 14 --->
//│ 	case t¹ of {T v¹ l¹ r¹ => ((v¹ + sumTree(l¹)) + sumTree(r¹)) | L  => 0}: 32
//│ ------------------
//│ case t¹ of {T v¹ l¹ r¹ => ((v¹ + sumTree(l¹)) + sumTree(r¹)) | L  => 0}: 32 --->
//│ 	[T (v⁰ * v⁰) sqTree(l⁰) sqTree(r⁰)]: 13
//│ 	[L]: 14
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumSquareTree(primId⁰(18))
//│ def genTree(n²) = if (n² > 0) then [T n² genTree((n² - 1)) genTree((n² - 1))] else [L]
//│ def sqTree(t²) = case t² of {
//│ 	T v⁰ l⁰ r⁰ => 
//│ 		let r² = sqTree(r⁰)
//│ 		in let l² = sqTree(l⁰)
//│ 		in let v² = (v⁰ * v⁰)
//│ 		in (fun _lh_dummy⁰ -> ((v² + sumTree(l²)) + sumTree(r²)))
//│ 	| L  => (fun _lh_dummy¹ -> 0)}
//│ def sumTree(t³) = t³(99)
//│ def testSumSquareTree(n³) = sumTree(sqTree(primId⁰(genTree(n³))))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ sumTree
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ sqTree -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testSumSquareTree(primId⁰(18))
//│ def genTree(n⁰) = if (n⁰ > 0) then [T n⁰ genTree((n⁰ - 1)) genTree((n⁰ - 1))] else [L]
//│ def sqTree(t⁰) = case t⁰ of {
//│ 	T v⁰ l⁰ r⁰ => 
//│ 		let r¹ = sqTree(r⁰)
//│ 		in let l¹ = sqTree(l⁰)
//│ 		in let v¹ = (v⁰ * v⁰)
//│ 		in (fun _lh_dummy⁰ -> ((v¹ + l¹(99)) + r¹(99)))
//│ 	| L  => (fun _lh_dummy¹ -> 0)}
//│ def sumTree(t¹) = t¹(99)
//│ def testSumSquareTree(n¹) = sqTree(primId⁰(genTree(n¹)), 99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testSumSquareTree(primId⁰(18))
//│ def genTree(n⁰) = if (n⁰ > 0) then [T n⁰ genTree((n⁰ - 1)) genTree((n⁰ - 1))] else [L]
//│ def sqTree(t⁰, _lh_popOutId_0⁰) = case t⁰ of {
//│ 	T v⁰ l⁰ r⁰ => 
//│ 		let r¹ = sqTree(r⁰)
//│ 		in let l¹ = sqTree(l⁰)
//│ 		in let v¹ = (v⁰ * v⁰)
//│ 		in ((v¹ + l¹(99)) + r¹(99))
//│ 	| L  => 0}
//│ def sumTree(t¹) = t¹(99)
//│ def testSumSquareTree(n¹) = sqTree(primId⁰(genTree(n¹)), 99)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<



:lhInHaskell
:lhGenOCaml
summ xs = case xs of { [] -> 0; (h:t) -> h + (summ t) }
append xs ys = case xs of { [] -> ys; (h:t) -> h:(append t ys) }
flatten xss = case xss of { [] -> []; (h:t) -> append h (flatten t) }
testSumFlatten n = summ $ flatten n
sum2 ls = let k = ls in k 99
append2 xs ys p = case xs of { [] -> ys p; (h:t) -> let tt = append2 t ys in let hh = h in hh + sum2 tt }
flatten2 ls p = case ls of { [] -> 0; (h:t) -> append2 h (flatten2 t) p }
testManual n = sum2 $ flatten2 n
testSumFlatten $ primId [primId [1..n] | n <- primId [1..1000]]
testManual $ primId [primId [1..n] | n <- primId [1..1000]]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumFlatten_lh_₁^191(primId⁰(
//│ 	let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 		LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C primId⁰(enumFromTo_lh_₄^195(1, _lh_listcomp_fun_ls_h⁰)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun⁰(primId⁰(enumFromTo_lh_₃^210(1, 1000)))))
//│ testManual_lh_₁^220(primId⁰(
//│ 	let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 		LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C primId⁰(enumFromTo_lh_₁^224(1, _lh_listcomp_fun_ls_h¹)) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun¹(primId⁰(enumFromTo_lh_₂^239(1, 1000)))))
//│ def append2_lh_₁(_lh_append2_arg1⁰, _lh_append2_arg2⁰, _lh_append2_arg3⁰) = 
//│ 	let _lh_matchIdent¹ = _lh_append2_arg1⁰
//│ 	in case _lh_matchIdent¹ of {
//│ 		LH_N  => _lh_append2_arg2⁰(_lh_append2_arg3⁰)
//│ 		| LH_C _lh_append2_LH_C_0⁰ _lh_append2_LH_C_1⁰ => 
//│ 			let tt⁰ = append2_lh_₁^27(_lh_append2_LH_C_1⁰, _lh_append2_arg2⁰)
//│ 			in let hh⁰ = _lh_append2_LH_C_0⁰
//│ 			in (hh⁰ + sum2_lh_₂^36(tt⁰))
//│ 		| _  => error⁰}
//│ def append_lh_₁(_lh_append_arg1⁰, _lh_append_arg2⁰) = 
//│ 	let _lh_matchIdent⁰ = _lh_append_arg1⁰
//│ 	in case _lh_matchIdent⁰ of {
//│ 		LH_N  => _lh_append_arg2⁰
//│ 		| LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => [LH_C _lh_append_LH_C_0⁰ append_lh_₁^11(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]
//│ 		| _  => error⁰}
//│ def enumFromTo_lh_₁(a³, b³) = if (a³ <= b³) then [LH_C a³ enumFromTo_lh_₁^177((a³ + 1), b³)] else [LH_N]
//│ def enumFromTo_lh_₂(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo_lh_₂^157((a² + 1), b²)] else [LH_N]
//│ def enumFromTo_lh_₃(a¹, b¹) = if (a¹ <= b¹) then [LH_C a¹ enumFromTo_lh_₃^137((a¹ + 1), b¹)] else [LH_N]
//│ def enumFromTo_lh_₄(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₄^117((a⁰ + 1), b⁰)] else [LH_N]
//│ def flatten2_lh_₁(_lh_flatten2_arg1⁰, _lh_flatten2_arg2⁰) = 
//│ 	let _lh_matchIdent⁴ = _lh_flatten2_arg1⁰
//│ 	in case _lh_matchIdent⁴ of {
//│ 		LH_N  => 0
//│ 		| LH_C _lh_flatten2_LH_C_0⁰ _lh_flatten2_LH_C_1⁰ => append2_lh_₁^85(_lh_flatten2_LH_C_0⁰, flatten2_lh_₁^88(_lh_flatten2_LH_C_1⁰), _lh_flatten2_arg2⁰)
//│ 		| _  => error⁰}
//│ def flatten_lh_₁(_lh_flatten_arg1⁰) = 
//│ 	let _lh_matchIdent³ = _lh_flatten_arg1⁰
//│ 	in case _lh_matchIdent³ of {
//│ 		LH_N  => [LH_N]
//│ 		| LH_C _lh_flatten_LH_C_0⁰ _lh_flatten_LH_C_1⁰ => append_lh_₁^65(_lh_flatten_LH_C_0⁰, flatten_lh_₁^68(_lh_flatten_LH_C_1⁰))
//│ 		| _  => error⁰}
//│ def sum2_lh_₁(_lh_sum2_arg1¹) = 
//│ 	let k¹ = _lh_sum2_arg1¹
//│ 	in k¹(99)
//│ def sum2_lh_₂(_lh_sum2_arg1⁰) = 
//│ 	let k⁰ = _lh_sum2_arg1⁰
//│ 	in k⁰(99)
//│ def summ_lh_₁(_lh_summ_arg1⁰) = 
//│ 	let _lh_matchIdent² = _lh_summ_arg1⁰
//│ 	in case _lh_matchIdent² of {
//│ 		LH_N  => 0
//│ 		| LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => (_lh_summ_LH_C_0⁰ + summ_lh_₁^54(_lh_summ_LH_C_1⁰))
//│ 		| _  => error⁰}
//│ def testManual_lh_₁(_lh_testManual_arg1⁰) = sum2_lh_₁^105(flatten2_lh_₁^106(_lh_testManual_arg1⁰))
//│ def testSumFlatten_lh_₁(_lh_testSumFlatten_arg1⁰) = summ_lh_₁^99(flatten_lh_₁^100(_lh_testSumFlatten_arg1⁰))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec sum2_lh__d2 _lh_sum2_arg1_0 =
//│ 		  (let rec k_0 = _lh_sum2_arg1_0 in
//│ 		    (k_0 99));;
//│ 		let rec append2_lh__d1 _lh_append2_arg1_0 _lh_append2_arg2_0 _lh_append2_arg3_0 =
//│ 		  (let rec _lh_matchIdent_1 = _lh_append2_arg1_0 in
//│ 		    (match _lh_matchIdent_1 with
//│ 		      | `LH_N -> 
//│ 		        (_lh_append2_arg2_0 _lh_append2_arg3_0)
//│ 		      | `LH_C(_lh_append2_LH_C_0_0, _lh_append2_LH_C_1_0) -> 
//│ 		        (let rec tt_0 = ((append2_lh__d1 _lh_append2_LH_C_1_0) _lh_append2_arg2_0) in
//│ 		          (let rec hh_0 = _lh_append2_LH_C_0_0 in
//│ 		            (hh_0 + (sum2_lh__d2 tt_0))))
//│ 		      | _ -> 
//│ 		        (failwith "error")));;
//│ 		let rec flatten2_lh__d1 _lh_flatten2_arg1_0 _lh_flatten2_arg2_0 =
//│ 		  (let rec _lh_matchIdent_4 = _lh_flatten2_arg1_0 in
//│ 		    (match _lh_matchIdent_4 with
//│ 		      | `LH_N -> 
//│ 		        0
//│ 		      | `LH_C(_lh_flatten2_LH_C_0_0, _lh_flatten2_LH_C_1_0) -> 
//│ 		        (((append2_lh__d1 _lh_flatten2_LH_C_0_0) (flatten2_lh__d1 _lh_flatten2_LH_C_1_0)) _lh_flatten2_arg2_0)
//│ 		      | _ -> 
//│ 		        (failwith "error")));;
//│ 		let rec sum2_lh__d1 _lh_sum2_arg1_1 =
//│ 		  (let rec k_1 = _lh_sum2_arg1_1 in
//│ 		    (k_1 99));;
//│ 		let rec testManual_lh__d1 _lh_testManual_arg1_0 =
//│ 		  (sum2_lh__d1 (flatten2_lh__d1 _lh_testManual_arg1_0));;
//│ 		let rec append_lh__d1 _lh_append_arg1_0 _lh_append_arg2_0 =
//│ 		  (let rec _lh_matchIdent_0 = _lh_append_arg1_0 in
//│ 		    (match _lh_matchIdent_0 with
//│ 		      | `LH_N -> 
//│ 		        _lh_append_arg2_0
//│ 		      | `LH_C(_lh_append_LH_C_0_0, _lh_append_LH_C_1_0) -> 
//│ 		        (`LH_C(_lh_append_LH_C_0_0, ((append_lh__d1 _lh_append_LH_C_1_0) _lh_append_arg2_0)))
//│ 		      | _ -> 
//│ 		        (failwith "error")));;
//│ 		let rec flatten_lh__d1 _lh_flatten_arg1_0 =
//│ 		  (let rec _lh_matchIdent_3 = _lh_flatten_arg1_0 in
//│ 		    (match _lh_matchIdent_3 with
//│ 		      | `LH_N -> 
//│ 		        (`LH_N)
//│ 		      | `LH_C(_lh_flatten_LH_C_0_0, _lh_flatten_LH_C_1_0) -> 
//│ 		        ((append_lh__d1 _lh_flatten_LH_C_0_0) (flatten_lh__d1 _lh_flatten_LH_C_1_0))
//│ 		      | _ -> 
//│ 		        (failwith "error")));;
//│ 		let rec summ_lh__d1 _lh_summ_arg1_0 =
//│ 		  (let rec _lh_matchIdent_2 = _lh_summ_arg1_0 in
//│ 		    (match _lh_matchIdent_2 with
//│ 		      | `LH_N -> 
//│ 		        0
//│ 		      | `LH_C(_lh_summ_LH_C_0_0, _lh_summ_LH_C_1_0) -> 
//│ 		        (_lh_summ_LH_C_0_0 + (summ_lh__d1 _lh_summ_LH_C_1_0))
//│ 		      | _ -> 
//│ 		        (failwith "error")));;
//│ 		let rec testSumFlatten_lh__d1 _lh_testSumFlatten_arg1_0 =
//│ 		  (summ_lh__d1 (flatten_lh__d1 _lh_testSumFlatten_arg1_0));;
//│ 		let rec enumFromTo_lh__d2 a_2 b_2 =
//│ 		  (if (a_2 <= b_2) then
//│ 		    (`LH_C(a_2, ((enumFromTo_lh__d2 (a_2 + 1)) b_2)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec enumFromTo_lh__d1 a_3 b_3 =
//│ 		  (if (a_3 <= b_3) then
//│ 		    (`LH_C(a_3, ((enumFromTo_lh__d1 (a_3 + 1)) b_3)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec enumFromTo_lh__d4 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d4 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec enumFromTo_lh__d3 a_1 b_1 =
//│ 		  (if (a_1 <= b_1) then
//│ 		    (`LH_C(a_1, ((enumFromTo_lh__d3 (a_1 + 1)) b_1)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		(testSumFlatten_lh__d1 (let rec _lh_listcomp_fun_0 = (fun _lh_listcomp_fun_para_0 -> 
//│ 		  (match _lh_listcomp_fun_para_0 with
//│ 		    | `LH_C(_lh_listcomp_fun_ls_h_0, _lh_listcomp_fun_ls_t_0) -> 
//│ 		      (`LH_C(((enumFromTo_lh__d4 1) _lh_listcomp_fun_ls_h_0), (_lh_listcomp_fun_0 _lh_listcomp_fun_ls_t_0)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))) in
//│ 		  (_lh_listcomp_fun_0 ((enumFromTo_lh__d3 1) 1000))))
//│ 		(testManual_lh__d1 (let rec _lh_listcomp_fun_1 = (fun _lh_listcomp_fun_para_1 -> 
//│ 		  (match _lh_listcomp_fun_para_1 with
//│ 		    | `LH_C(_lh_listcomp_fun_ls_h_1, _lh_listcomp_fun_ls_t_1) -> 
//│ 		      (`LH_C(((enumFromTo_lh__d1 1) _lh_listcomp_fun_ls_h_1), (_lh_listcomp_fun_1 _lh_listcomp_fun_ls_t_1)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))) in
//│ 		  (_lh_listcomp_fun_1 ((enumFromTo_lh__d2 1) 1000))))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]: 16 --->
//│ 	case _lh_matchIdent² of {LH_N  => 0 | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => (_lh_summ_LH_C_0⁰ + summ_lh_₁(_lh_summ_LH_C_1⁰)) | _  => error⁰}: 59
//│ [LH_N]: 64 --->
//│ 	case _lh_matchIdent² of {LH_N  => 0 | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => (_lh_summ_LH_C_0⁰ + summ_lh_₁(_lh_summ_LH_C_1⁰)) | _  => error⁰}: 59
//│ ------------------
//│ case _lh_matchIdent² of {LH_N  => 0 | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => (_lh_summ_LH_C_0⁰ + summ_lh_₁(_lh_summ_LH_C_1⁰)) | _  => error⁰}: 59 --->
//│ 	[LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]: 16
//│ 	[LH_N]: 64
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]: 16 --->
//│ 	case _lh_matchIdent² of {LH_N  => 0 | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => (_lh_summ_LH_C_0⁰ + summ_lh_₁(_lh_summ_LH_C_1⁰)) | _  => error⁰}: 59
//│ [LH_N]: 64 --->
//│ 	case _lh_matchIdent² of {LH_N  => 0 | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => (_lh_summ_LH_C_0⁰ + summ_lh_₁(_lh_summ_LH_C_1⁰)) | _  => error⁰}: 59
//│ ------------------
//│ case _lh_matchIdent² of {LH_N  => 0 | LH_C _lh_summ_LH_C_0⁰ _lh_summ_LH_C_1⁰ => (_lh_summ_LH_C_0⁰ + summ_lh_₁(_lh_summ_LH_C_1⁰)) | _  => error⁰}: 59 --->
//│ 	[LH_C _lh_append_LH_C_0⁰ append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)]: 16
//│ 	[LH_N]: 64
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumFlatten_lh_₁(primId⁰(
//│ 	let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 		LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C primId⁰(enumFromTo_lh_₄(1, _lh_listcomp_fun_ls_h⁰)) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t⁰)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun²(primId⁰(enumFromTo_lh_₃(1, 1000)))))
//│ testManual_lh_₁(primId⁰(
//│ 	let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 		LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C primId⁰(enumFromTo_lh_₁(1, _lh_listcomp_fun_ls_h¹)) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t¹)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun³(primId⁰(enumFromTo_lh_₂(1, 1000)))))
//│ def append2_lh_₁(_lh_append2_arg1¹, _lh_append2_arg2¹, _lh_append2_arg3¹) = 
//│ 	let _lh_matchIdent⁸ = _lh_append2_arg1¹
//│ 	in case _lh_matchIdent⁸ of {
//│ 		LH_N  => _lh_append2_arg2¹(_lh_append2_arg3¹)
//│ 		| LH_C _lh_append2_LH_C_0⁰ _lh_append2_LH_C_1⁰ => 
//│ 			let tt¹ = append2_lh_₁(_lh_append2_LH_C_1⁰, _lh_append2_arg2¹)
//│ 			in let hh¹ = _lh_append2_LH_C_0⁰
//│ 			in (hh¹ + sum2_lh_₂(tt¹))
//│ 		| _  => error⁰}
//│ def append_lh_₁(_lh_append_arg1¹, _lh_append_arg2¹) = 
//│ 	let _lh_matchIdent⁶ = _lh_append_arg1¹
//│ 	in case _lh_matchIdent⁶ of {
//│ 		LH_N  => _lh_append_arg2¹
//│ 		| LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => 
//│ 			let _lh_summ_LH_C_1¹ = append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2¹)
//│ 			in let _lh_summ_LH_C_0¹ = _lh_append_LH_C_0⁰
//│ 			in (fun _lh_dummy⁰ -> (_lh_summ_LH_C_0¹ + summ_lh_₁(_lh_summ_LH_C_1¹)))
//│ 		| _  => error⁰}
//│ def enumFromTo_lh_₁(a⁷, b⁷) = if (a⁷ <= b⁷) then [LH_C a⁷ enumFromTo_lh_₁((a⁷ + 1), b⁷)] else [LH_N]
//│ def enumFromTo_lh_₂(a⁵, b⁵) = if (a⁵ <= b⁵) then [LH_C a⁵ enumFromTo_lh_₂((a⁵ + 1), b⁵)] else [LH_N]
//│ def enumFromTo_lh_₃(a⁶, b⁶) = if (a⁶ <= b⁶) then [LH_C a⁶ enumFromTo_lh_₃((a⁶ + 1), b⁶)] else [LH_N]
//│ def enumFromTo_lh_₄(a⁴, b⁴) = if (a⁴ <= b⁴) then [LH_C a⁴ enumFromTo_lh_₄((a⁴ + 1), b⁴)] else [LH_N]
//│ def flatten2_lh_₁(_lh_flatten2_arg1¹, _lh_flatten2_arg2¹) = 
//│ 	let _lh_matchIdent⁵ = _lh_flatten2_arg1¹
//│ 	in case _lh_matchIdent⁵ of {
//│ 		LH_N  => 0
//│ 		| LH_C _lh_flatten2_LH_C_0⁰ _lh_flatten2_LH_C_1⁰ => append2_lh_₁(_lh_flatten2_LH_C_0⁰, flatten2_lh_₁(_lh_flatten2_LH_C_1⁰), _lh_flatten2_arg2¹)
//│ 		| _  => error⁰}
//│ def flatten_lh_₁(_lh_flatten_arg1¹) = 
//│ 	let _lh_matchIdent⁹ = _lh_flatten_arg1¹
//│ 	in case _lh_matchIdent⁹ of {
//│ 		LH_N  => (fun _lh_dummy¹ -> 0)
//│ 		| LH_C _lh_flatten_LH_C_0⁰ _lh_flatten_LH_C_1⁰ => append_lh_₁(_lh_flatten_LH_C_0⁰, flatten_lh_₁(_lh_flatten_LH_C_1⁰))
//│ 		| _  => error⁰}
//│ def sum2_lh_₁(_lh_sum2_arg1³) = 
//│ 	let k³ = _lh_sum2_arg1³
//│ 	in k³(99)
//│ def sum2_lh_₂(_lh_sum2_arg1²) = 
//│ 	let k² = _lh_sum2_arg1²
//│ 	in k²(99)
//│ def summ_lh_₁(_lh_summ_arg1¹) = 
//│ 	let _lh_matchIdent⁷ = _lh_summ_arg1¹
//│ 	in _lh_matchIdent⁷(99)
//│ def testManual_lh_₁(_lh_testManual_arg1¹) = sum2_lh_₁(flatten2_lh_₁(_lh_testManual_arg1¹))
//│ def testSumFlatten_lh_₁(_lh_testSumFlatten_arg1¹) = summ_lh_₁(flatten_lh_₁(_lh_testSumFlatten_arg1¹))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ summ_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ append_lh_₁ -> 2
//│ flatten_lh_₁ -> 1
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testSumFlatten_lh_₁(primId⁰(
//│ 	let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 		LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C primId⁰(enumFromTo_lh_₄(1, _lh_listcomp_fun_ls_h⁰)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun⁰(primId⁰(enumFromTo_lh_₃(1, 1000)))))
//│ testManual_lh_₁(primId⁰(
//│ 	let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 		LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C primId⁰(enumFromTo_lh_₁(1, _lh_listcomp_fun_ls_h¹)) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun¹(primId⁰(enumFromTo_lh_₂(1, 1000)))))
//│ def append2_lh_₁(_lh_append2_arg1⁰, _lh_append2_arg2⁰, _lh_append2_arg3⁰) = 
//│ 	let _lh_matchIdent⁴ = _lh_append2_arg1⁰
//│ 	in case _lh_matchIdent⁴ of {
//│ 		LH_N  => _lh_append2_arg2⁰(_lh_append2_arg3⁰)
//│ 		| LH_C _lh_append2_LH_C_0⁰ _lh_append2_LH_C_1⁰ => 
//│ 			let tt⁰ = append2_lh_₁(_lh_append2_LH_C_1⁰, _lh_append2_arg2⁰)
//│ 			in let hh⁰ = _lh_append2_LH_C_0⁰
//│ 			in (hh⁰ + sum2_lh_₂(tt⁰))
//│ 		| _  => error⁰}
//│ def append_lh_₁(_lh_append_arg1⁰, _lh_append_arg2⁰) = 
//│ 	let _lh_matchIdent¹ = _lh_append_arg1⁰
//│ 	in case _lh_matchIdent¹ of {
//│ 		LH_N  => _lh_append_arg2⁰
//│ 		| LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => 
//│ 			let _lh_summ_LH_C_1⁰ = append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)
//│ 			in let _lh_summ_LH_C_0⁰ = _lh_append_LH_C_0⁰
//│ 			in (fun _lh_dummy⁰ -> (_lh_summ_LH_C_0⁰ + 
//│ 				let _lh_matchIdent² = _lh_summ_LH_C_1⁰
//│ 				in _lh_matchIdent²(99)))
//│ 		| _  => error⁰}
//│ def enumFromTo_lh_₁(a³, b³) = if (a³ <= b³) then [LH_C a³ enumFromTo_lh_₁((a³ + 1), b³)] else [LH_N]
//│ def enumFromTo_lh_₂(a¹, b¹) = if (a¹ <= b¹) then [LH_C a¹ enumFromTo_lh_₂((a¹ + 1), b¹)] else [LH_N]
//│ def enumFromTo_lh_₃(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo_lh_₃((a² + 1), b²)] else [LH_N]
//│ def enumFromTo_lh_₄(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₄((a⁰ + 1), b⁰)] else [LH_N]
//│ def flatten2_lh_₁(_lh_flatten2_arg1⁰, _lh_flatten2_arg2⁰) = 
//│ 	let _lh_matchIdent⁰ = _lh_flatten2_arg1⁰
//│ 	in case _lh_matchIdent⁰ of {
//│ 		LH_N  => 0
//│ 		| LH_C _lh_flatten2_LH_C_0⁰ _lh_flatten2_LH_C_1⁰ => append2_lh_₁(_lh_flatten2_LH_C_0⁰, flatten2_lh_₁(_lh_flatten2_LH_C_1⁰), _lh_flatten2_arg2⁰)
//│ 		| _  => error⁰}
//│ def flatten_lh_₁(_lh_flatten_arg1⁰) = 
//│ 	let _lh_matchIdent⁶ = _lh_flatten_arg1⁰
//│ 	in case _lh_matchIdent⁶ of {
//│ 		LH_N  => (fun _lh_dummy¹ -> 0)
//│ 		| LH_C _lh_flatten_LH_C_0⁰ _lh_flatten_LH_C_1⁰ => append_lh_₁(_lh_flatten_LH_C_0⁰, flatten_lh_₁(_lh_flatten_LH_C_1⁰))
//│ 		| _  => error⁰}
//│ def sum2_lh_₁(_lh_sum2_arg1¹) = 
//│ 	let k¹ = _lh_sum2_arg1¹
//│ 	in k¹(99)
//│ def sum2_lh_₂(_lh_sum2_arg1⁰) = 
//│ 	let k⁰ = _lh_sum2_arg1⁰
//│ 	in k⁰(99)
//│ def summ_lh_₁(_lh_summ_arg1⁰) = 
//│ 	let _lh_matchIdent³ = _lh_summ_arg1⁰
//│ 	in _lh_matchIdent³(99)
//│ def testManual_lh_₁(_lh_testManual_arg1⁰) = sum2_lh_₁(flatten2_lh_₁(_lh_testManual_arg1⁰))
//│ def testSumFlatten_lh_₁(_lh_testSumFlatten_arg1⁰) = 
//│ 	let _lh_matchIdent⁵ = flatten_lh_₁(_lh_testSumFlatten_arg1⁰)
//│ 	in _lh_matchIdent⁵(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testSumFlatten_lh_₁(primId⁰(
//│ 	let _lh_listcomp_fun⁰ = (fun _lh_listcomp_fun_para⁰ -> case _lh_listcomp_fun_para⁰ of {
//│ 		LH_C _lh_listcomp_fun_ls_h⁰ _lh_listcomp_fun_ls_t⁰ => [LH_C primId⁰(enumFromTo_lh_₄(1, _lh_listcomp_fun_ls_h⁰)) _lh_listcomp_fun⁰(_lh_listcomp_fun_ls_t⁰)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun⁰(primId⁰(enumFromTo_lh_₃(1, 1000)))))
//│ testManual_lh_₁(primId⁰(
//│ 	let _lh_listcomp_fun¹ = (fun _lh_listcomp_fun_para¹ -> case _lh_listcomp_fun_para¹ of {
//│ 		LH_C _lh_listcomp_fun_ls_h¹ _lh_listcomp_fun_ls_t¹ => [LH_C primId⁰(enumFromTo_lh_₁(1, _lh_listcomp_fun_ls_h¹)) _lh_listcomp_fun¹(_lh_listcomp_fun_ls_t¹)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun¹(primId⁰(enumFromTo_lh_₂(1, 1000)))))
//│ def append2_lh_₁(_lh_append2_arg1⁰, _lh_append2_arg2⁰, _lh_append2_arg3⁰) = 
//│ 	let _lh_matchIdent⁴ = _lh_append2_arg1⁰
//│ 	in case _lh_matchIdent⁴ of {
//│ 		LH_N  => _lh_append2_arg2⁰(_lh_append2_arg3⁰)
//│ 		| LH_C _lh_append2_LH_C_0⁰ _lh_append2_LH_C_1⁰ => 
//│ 			let tt⁰ = append2_lh_₁(_lh_append2_LH_C_1⁰, _lh_append2_arg2⁰)
//│ 			in let hh⁰ = _lh_append2_LH_C_0⁰
//│ 			in (hh⁰ + sum2_lh_₂(tt⁰))
//│ 		| _  => error⁰}
//│ def append_lh_₁(_lh_append_arg1⁰, _lh_append_arg2⁰) = 
//│ 	let _lh_matchIdent¹ = _lh_append_arg1⁰
//│ 	in case _lh_matchIdent¹ of {
//│ 		LH_N  => _lh_append_arg2⁰
//│ 		| LH_C _lh_append_LH_C_0⁰ _lh_append_LH_C_1⁰ => 
//│ 			let _lh_summ_LH_C_1⁰ = append_lh_₁(_lh_append_LH_C_1⁰, _lh_append_arg2⁰)
//│ 			in let _lh_summ_LH_C_0⁰ = _lh_append_LH_C_0⁰
//│ 			in (fun _lh_dummy⁰ -> (_lh_summ_LH_C_0⁰ + 
//│ 				let _lh_matchIdent² = _lh_summ_LH_C_1⁰
//│ 				in _lh_matchIdent²(99)))
//│ 		| _  => error⁰}
//│ def enumFromTo_lh_₁(a³, b³) = if (a³ <= b³) then [LH_C a³ enumFromTo_lh_₁((a³ + 1), b³)] else [LH_N]
//│ def enumFromTo_lh_₂(a¹, b¹) = if (a¹ <= b¹) then [LH_C a¹ enumFromTo_lh_₂((a¹ + 1), b¹)] else [LH_N]
//│ def enumFromTo_lh_₃(a², b²) = if (a² <= b²) then [LH_C a² enumFromTo_lh_₃((a² + 1), b²)] else [LH_N]
//│ def enumFromTo_lh_₄(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₄((a⁰ + 1), b⁰)] else [LH_N]
//│ def flatten2_lh_₁(_lh_flatten2_arg1⁰, _lh_flatten2_arg2⁰) = 
//│ 	let _lh_matchIdent⁰ = _lh_flatten2_arg1⁰
//│ 	in case _lh_matchIdent⁰ of {
//│ 		LH_N  => 0
//│ 		| LH_C _lh_flatten2_LH_C_0⁰ _lh_flatten2_LH_C_1⁰ => append2_lh_₁(_lh_flatten2_LH_C_0⁰, flatten2_lh_₁(_lh_flatten2_LH_C_1⁰), _lh_flatten2_arg2⁰)
//│ 		| _  => error⁰}
//│ def flatten_lh_₁(_lh_flatten_arg1⁰) = 
//│ 	let _lh_matchIdent⁶ = _lh_flatten_arg1⁰
//│ 	in case _lh_matchIdent⁶ of {
//│ 		LH_N  => (fun _lh_dummy¹ -> 0)
//│ 		| LH_C _lh_flatten_LH_C_0⁰ _lh_flatten_LH_C_1⁰ => append_lh_₁(_lh_flatten_LH_C_0⁰, flatten_lh_₁(_lh_flatten_LH_C_1⁰))
//│ 		| _  => error⁰}
//│ def sum2_lh_₁(_lh_sum2_arg1¹) = 
//│ 	let k¹ = _lh_sum2_arg1¹
//│ 	in k¹(99)
//│ def sum2_lh_₂(_lh_sum2_arg1⁰) = 
//│ 	let k⁰ = _lh_sum2_arg1⁰
//│ 	in k⁰(99)
//│ def summ_lh_₁(_lh_summ_arg1⁰) = 
//│ 	let _lh_matchIdent³ = _lh_summ_arg1⁰
//│ 	in _lh_matchIdent³(99)
//│ def testManual_lh_₁(_lh_testManual_arg1⁰) = sum2_lh_₁(flatten2_lh_₁(_lh_testManual_arg1⁰))
//│ def testSumFlatten_lh_₁(_lh_testSumFlatten_arg1⁰) = 
//│ 	let _lh_matchIdent⁵ = flatten_lh_₁(_lh_testSumFlatten_arg1⁰)
//│ 	in _lh_matchIdent⁵(99)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
testZipEnumEnum n = zip [1..n] [1..n]
testZipEnumEnum $ primId 100000
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testZipEnumEnum_lh_₁^72(primId⁰(100000))
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then [LH_C a¹ enumFromTo_lh_₁^27((a¹ + 1), b¹)] else [LH_N]
//│ def enumFromTo_lh_₂(a⁰, b⁰) = if (a⁰ <= b⁰) then [LH_C a⁰ enumFromTo_lh_₂^7((a⁰ + 1), b⁰)] else [LH_N]
//│ def testZipEnumEnum_lh_₁(_lh_testZipEnumEnum_arg1⁰) = zip_lh_₁^58(enumFromTo_lh_₁^59(1, _lh_testZipEnumEnum_arg1⁰), enumFromTo_lh_₂^65(1, _lh_testZipEnumEnum_arg1⁰))
//│ def zip_lh_₁(xs⁰, ys⁰) = case xs⁰ of {
//│ 	LH_C hx⁰ tx⁰ => case ys⁰ of {
//│ 		LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁^46(tx⁰, ty⁰)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec zip_lh__d1 xs_0 ys_0 =
//│ 		  (match xs_0 with
//│ 		    | `LH_C(hx_0, tx_0) -> 
//│ 		      (match ys_0 with
//│ 		        | `LH_C(hy_0, ty_0) -> 
//│ 		          (`LH_C((`LH_P2(hx_0, hy_0)), ((zip_lh__d1 tx_0) ty_0)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		let rec enumFromTo_lh__d1 a_1 b_1 =
//│ 		  (if (a_1 <= b_1) then
//│ 		    (`LH_C(a_1, ((enumFromTo_lh__d1 (a_1 + 1)) b_1)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec enumFromTo_lh__d2 a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`LH_C(a_0, ((enumFromTo_lh__d2 (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`LH_N));;
//│ 		let rec testZipEnumEnum_lh__d1 _lh_testZipEnumEnum_arg1_0 =
//│ 		  ((zip_lh__d1 ((enumFromTo_lh__d1 1) _lh_testZipEnumEnum_arg1_0)) ((enumFromTo_lh__d2 1) _lh_testZipEnumEnum_arg1_0));;
//│ 		(testZipEnumEnum_lh__d1 100000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₂((a⁰ + 1), b⁰)]: 16 --->
//│ 	case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]}: 53
//│ [LH_N]: 17 --->
//│ 	case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]}: 53
//│ [LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b¹)]: 36 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 55
//│ [LH_N]: 37 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 55
//│ ------------------
//│ case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]}: 53 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₂((a⁰ + 1), b⁰)]: 16
//│ 	[LH_N]: 17
//│ case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 55 --->
//│ 	[LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b¹)]: 36
//│ 	[LH_N]: 37
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁰ enumFromTo_lh_₂((a⁰ + 1), b⁰)]: 16 --->
//│ 	case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]}: 53
//│ [LH_N]: 17 --->
//│ 	case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]}: 53
//│ [LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b¹)]: 36 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 55
//│ [LH_N]: 37 --->
//│ 	case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 55
//│ ------------------
//│ case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]}: 53 --->
//│ 	[LH_C a⁰ enumFromTo_lh_₂((a⁰ + 1), b⁰)]: 16
//│ 	[LH_N]: 17
//│ case xs⁰ of {LH_C hx⁰ tx⁰ => case ys⁰ of {LH_C hy⁰ ty⁰ => [LH_C [LH_P2 hx⁰ hy⁰] zip_lh_₁(tx⁰, ty⁰)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 55 --->
//│ 	[LH_C a¹ enumFromTo_lh_₁((a¹ + 1), b¹)]: 36
//│ 	[LH_N]: 37
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testZipEnumEnum_lh_₁(primId⁰(100000))
//│ def enumFromTo_lh_₁(a³, b³) = if (a³ <= b³) then 
//│ 	let tx³ = enumFromTo_lh_₁((a³ + 1), b³)
//│ 	in let hx³ = a³
//│ 	in (fun ys¹ -> ys¹(hx³, tx³)) else (fun ys² -> [LH_N])
//│ def enumFromTo_lh_₂(a², b²) = if (a² <= b²) then 
//│ 	let ty¹ = enumFromTo_lh_₂((a² + 1), b²)
//│ 	in let hy¹ = a²
//│ 	in (fun hx¹ -> (fun tx¹ -> [LH_C [LH_P2 hx¹ hy¹] zip_lh_₁(tx¹, ty¹)])) else (fun hx² -> (fun tx² -> [LH_N]))
//│ def testZipEnumEnum_lh_₁(_lh_testZipEnumEnum_arg1¹) = zip_lh_₁(enumFromTo_lh_₁(1, _lh_testZipEnumEnum_arg1¹), enumFromTo_lh_₂(1, _lh_testZipEnumEnum_arg1¹))
//│ def zip_lh_₁(xs¹, ys³) = xs¹(ys³)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ zip_lh_₁
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ enumFromTo_lh_₂ -> 2
//│ enumFromTo_lh_₁ -> 2
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ testZipEnumEnum_lh_₁(primId⁰(100000))
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let tx² = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let hx² = a¹
//│ 	in (fun ys⁰ -> ys⁰(hx², tx²)) else (fun ys¹ -> [LH_N])
//│ def enumFromTo_lh_₂(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let ty⁰ = enumFromTo_lh_₂((a⁰ + 1), b⁰)
//│ 	in let hy⁰ = a⁰
//│ 	in (fun hx⁰ -> (fun tx⁰ -> [LH_C [LH_P2 hx⁰ hy⁰] tx⁰(ty⁰)])) else (fun hx¹ -> (fun tx¹ -> [LH_N]))
//│ def testZipEnumEnum_lh_₁(_lh_testZipEnumEnum_arg1⁰) = enumFromTo_lh_₁(1, _lh_testZipEnumEnum_arg1⁰, enumFromTo_lh_₂(1, _lh_testZipEnumEnum_arg1⁰))
//│ def zip_lh_₁(xs⁰, ys²) = xs⁰(ys²)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ testZipEnumEnum_lh_₁(primId⁰(100000))
//│ def enumFromTo_lh_₁(a¹, b¹) = if (a¹ <= b¹) then 
//│ 	let tx² = enumFromTo_lh_₁((a¹ + 1), b¹)
//│ 	in let hx² = a¹
//│ 	in (fun ys⁰ -> ys⁰(hx², tx²)) else (fun ys¹ -> [LH_N])
//│ def enumFromTo_lh_₂(a⁰, b⁰) = if (a⁰ <= b⁰) then 
//│ 	let ty⁰ = enumFromTo_lh_₂((a⁰ + 1), b⁰)
//│ 	in let hy⁰ = a⁰
//│ 	in (fun hx⁰ -> (fun tx⁰ -> [LH_C [LH_P2 hx⁰ hy⁰] tx⁰(ty⁰)])) else (fun hx¹ -> (fun tx¹ -> [LH_N]))
//│ def testZipEnumEnum_lh_₁(_lh_testZipEnumEnum_arg1⁰) = enumFromTo_lh_₁(1, _lh_testZipEnumEnum_arg1⁰, enumFromTo_lh_₂(1, _lh_testZipEnumEnum_arg1⁰))
//│ def zip_lh_₁(xs⁰, ys²) = xs⁰(ys²)
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
