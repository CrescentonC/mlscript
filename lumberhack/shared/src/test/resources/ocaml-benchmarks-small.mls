:NewParser
:ParseOnly


:lhInHaskell
:lhGenOCaml
testMapmapBuiltInType ls = map (\x -> x + 1) $ map (\x -> x * x) ls
testMapmapBuiltInType $ primId [1..100000]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapmapBuiltInType_₀^701(primId⁰(enumFromTo_₀^703(1, 100000)))
//│ def enumFromTo_₀(a⁵, b²) = if (a⁵ <= b²) then [LH_C a⁵ enumFromTo_₀^653((a⁵ + 1), b²)] else [LH_N]
//│ def map_₀(f¹², ls¹⁹) = case ls¹⁹ of {
//│ 	LH_C h²⁰ t²² => [LH_C f¹²(h²⁰) map_₀^637(f¹², t²²)]
//│ 	| LH_N  => [LH_N]}
//│ def map_₁(f¹³, ls²⁰) = case ls²⁰ of {
//│ 	LH_C h²¹ t²³ => [LH_C f¹³(h²¹) map_₁^671(f¹³, t²³)]
//│ 	| LH_N  => [LH_N]}
//│ def testMapmapBuiltInType_₀(_lh_testMapmapBuiltInType_arg1¹) = map_₀^681((fun x⁴ -> (x⁴ + 1)), map_₁^689((fun x⁵ -> (x⁵ * x⁵)), _lh_testMapmapBuiltInType_arg1¹))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo__d0 a_5 b_2 =
//│ 		  (if (a_5 <= b_2) then
//│ 		    (`LH_C(a_5, ((enumFromTo__d0 (a_5 + 1)) b_2)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and map__d0 f_1_2 ls_1_9 =
//│ 		  (match ls_1_9 with
//│ 		    | `LH_C(h_2_0, t_2_2) -> 
//│ 		      (`LH_C((f_1_2 h_2_0), ((map__d0 f_1_2) t_2_2)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and map__d1 f_1_3 ls_2_0 =
//│ 		  (match ls_2_0 with
//│ 		    | `LH_C(h_2_1, t_2_3) -> 
//│ 		      (`LH_C((f_1_3 h_2_1), ((map__d1 f_1_3) t_2_3)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and testMapmapBuiltInType__d0 _lh_testMapmapBuiltInType_arg1_1 =
//│ 		  ((map__d0 (fun x_4 -> 
//│ 		    (x_4 + 1))) ((map__d1 (fun x_5 -> 
//│ 		    (x_5 * x_5))) _lh_testMapmapBuiltInType_arg1_1));;
//│ 		(testMapmapBuiltInType__d0 ((enumFromTo__d0 1) 100000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C f¹³(h²¹) map_₁(f¹³, t²³)]: 676 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => [LH_C f¹²(h²⁰) map_₀(f¹², t²²)] | LH_N  => [LH_N]}: 644
//│ [LH_N]: 677 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => [LH_C f¹²(h²⁰) map_₀(f¹², t²²)] | LH_N  => [LH_N]}: 644
//│ ------------------
//│ case ls¹⁹ of {LH_C h²⁰ t²² => [LH_C f¹²(h²⁰) map_₀(f¹², t²²)] | LH_N  => [LH_N]}: 644 --->
//│ 	[LH_C f¹³(h²¹) map_₁(f¹³, t²³)]: 676
//│ 	[LH_N]: 677
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C f¹³(h²¹) map_₁(f¹³, t²³)]: 676 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => [LH_C f¹²(h²⁰) map_₀(f¹², t²²)] | LH_N  => [LH_N]}: 644
//│ [LH_N]: 677 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => [LH_C f¹²(h²⁰) map_₀(f¹², t²²)] | LH_N  => [LH_N]}: 644
//│ ------------------
//│ case ls¹⁹ of {LH_C h²⁰ t²² => [LH_C f¹²(h²⁰) map_₀(f¹², t²²)] | LH_N  => [LH_N]}: 644 --->
//│ 	[LH_C f¹³(h²¹) map_₁(f¹³, t²³)]: 676
//│ 	[LH_N]: 677
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapmapBuiltInType_₀(primId⁰(enumFromTo_₀(1, 100000)))
//│ def enumFromTo_₀(a⁶, b³) = if (a⁶ <= b³) then [LH_C a⁶ enumFromTo_₀((a⁶ + 1), b³)] else [LH_N]
//│ def map_₀(f¹⁴, ls²¹) = ls²¹(f¹⁴)
//│ def map_₁(f¹⁵, ls²²) = case ls²² of {
//│ 	LH_C h²¹ t²³ => 
//│ 		let t²⁴ = map_₁(f¹⁵, t²³)
//│ 		in let h²² = f¹⁵(h²¹)
//│ 		in (fun f¹⁶ -> [LH_C f¹⁶(h²²) map_₀(f¹⁶, t²⁴)])
//│ 	| LH_N  => (fun f¹⁷ -> [LH_N])}
//│ def testMapmapBuiltInType_₀(_lh_testMapmapBuiltInType_arg1²) = map_₀((fun x⁶ -> (x⁶ + 1)), map_₁((fun x⁷ -> (x⁷ * x⁷)), _lh_testMapmapBuiltInType_arg1²))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

// NOTE: why manually fused version is still not faster?
:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun filter(ls, f) = if ls is
  C(h, t) then if f(h) then C(h, filter(t, f)) else filter(t, f)
  N then N
fun lastDrive(ls) = if ls is
  C(h, t) then Some(last(h, t))
  N then None
fun last(a, ls) = if ls is
  N then a
  C(h, t) then last(h, t)
fun testLastFilter(ls) = lastDrive(filter(ls, x => x < 1000))
fun _lhManualLastFilterDrive(ls, f) = if ls is
  C(h, t) then if f(h) then
    let a = _lhManualLastFilter(t, f, h)
    Some(a)
  else
    _lhManualLastFilterDrive(t, f)
  N then None
fun _lhManualLastFilter(ls, f, a) = if ls is
  C(h, t) then if f(h) then _lhManualLastFilter(t, f, h) else _lhManualLastFilter(t, f, a)
  N then a
fun testManual(ls) = _lhManualLastFilterDrive(ls, x => x < 1000)
testLastFilter(primId(enumFromTo(1, 500000)))
testManual(primId(enumFromTo(1, 500000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |filter|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |C|(|h|,| |filter|(|t|,| |f|)|)| |#else| |filter|(|t|,| |f|)|↵|N| |#then| |N|←|↵|#fun| |lastDrive|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |Some|(|last|(|h|,| |t|)|)|↵|N| |#then| |None|←|↵|#fun| |last|(|a|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a|↵|C|(|h|,| |t|)| |#then| |last|(|h|,| |t|)|←|↵|#fun| |testLastFilter|(|ls|)| |#=| |lastDrive|(|filter|(|ls|,| |x| |=>| |x| |<| |1000|)|)|↵|#fun| |_lhManualLastFilterDrive|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then|→|#let| |a| |#=| |_lhManualLastFilter|(|t|,| |f|,| |h|)|↵|Some|(|a|)|←|↵|#else|→|_lhManualLastFilterDrive|(|t|,| |f|)|←|↵|N| |#then| |None|←|↵|#fun| |_lhManualLastFilter|(|ls|,| |f|,| |a|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |_lhManualLastFilter|(|t|,| |f|,| |h|)| |#else| |_lhManualLastFilter|(|t|,| |f|,| |a|)|↵|N| |#then| |a|←|↵|#fun| |testManual|(|ls|)| |#=| |_lhManualLastFilterDrive|(|ls|,| |x| |=>| |x| |<| |1000|)|↵|testLastFilter|(|primId|(|enumFromTo|(|1|,| |500000|)|)|)|↵|testManual|(|primId|(|enumFromTo|(|1|,| |500000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun filter = ls, f, => if ls is ‹(C (h, t,)) then if (f (h,)) then C (h, filter (t, f,),) else filter (t, f,); (N) then N›; fun lastDrive = ls, => if ls is ‹(C (h, t,)) then Some (last (h, t,),); (N) then None›; fun last = a, ls, => if ls is ‹(N) then a; (C (h, t,)) then last (h, t,)›; fun testLastFilter = ls, => lastDrive (filter (ls, x, => < (x,) (1000,),),); fun _lhManualLastFilterDrive = ls, f, => if ls is ‹(C (h, t,)) then if (f (h,)) then {let a = _lhManualLastFilter (t, f, h,); Some (a,)} else {_lhManualLastFilterDrive (t, f,)}; (N) then None›; fun _lhManualLastFilter = ls, f, a, => if ls is ‹(C (h, t,)) then if (f (h,)) then _lhManualLastFilter (t, f, h,) else _lhManualLastFilter (t, f, a,); (N) then a›; fun testManual = ls, => _lhManualLastFilterDrive (ls, x, => < (x,) (1000,),); testLastFilter (primId (enumFromTo (1, 500000,),),); testManual (primId (enumFromTo (1, 500000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testLastFilter^134(primId⁰(enumFromTo^136(1, 500000)))
//│ testManual^143(primId⁰(enumFromTo^145(1, 500000)))
//│ def _lhManualLastFilter(ls⁵, f², a³) = case ls⁵ of {
//│ 	C h⁴ t⁴ => if f²(h⁴) then _lhManualLastFilter^103(t⁴, f², h⁴) else _lhManualLastFilter^110(t⁴, f², a³)
//│ 	| N  => a³}
//│ def _lhManualLastFilterDrive(ls⁴, f¹) = case ls⁴ of {
//│ 	C h³ t³ => if f¹(h³) then 
//│ 		let a² = _lhManualLastFilter^79(t³, f¹, h³)
//│ 		in [Some a²] else _lhManualLastFilterDrive^89(t³, f¹)
//│ 	| N  => [None]}
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def filter(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter^26(t⁰, f⁰)] else filter^32(t⁰, f⁰)
//│ 	| N  => [N]}
//│ def last(a¹, ls²) = case ls² of {
//│ 	N  => a¹
//│ 	| C h² t² => last^54(h², t²)}
//│ def lastDrive(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => [Some last^43(h¹, t¹)]
//│ 	| N  => [None]}
//│ def testLastFilter(ls³) = lastDrive^62(filter^63(ls³, (fun x⁰ -> (x⁰ < 1000))))
//│ def testManual(ls⁶) = _lhManualLastFilterDrive^123(ls⁶, (fun x¹ -> (x¹ < 1000)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec _lhManualLastFilter ls_5 f_2 a_3 =
//│ 		  (match ls_5 with
//│ 		    | `C(h_4, t_4) -> 
//│ 		      (if (f_2 h_4) then
//│ 		        (((_lhManualLastFilter t_4) f_2) h_4)
//│ 		      else
//│ 		        (((_lhManualLastFilter t_4) f_2) a_3))
//│ 		    | `N -> 
//│ 		      a_3)
//│ 		and _lhManualLastFilterDrive ls_4 f_1 =
//│ 		  (match ls_4 with
//│ 		    | `C(h_3, t_3) -> 
//│ 		      (if (f_1 h_3) then
//│ 		        (let rec a_2 = (((_lhManualLastFilter t_3) f_1) h_3) in
//│ 		          (`Some(a_2)))
//│ 		      else
//│ 		        ((_lhManualLastFilterDrive t_3) f_1))
//│ 		    | `N -> 
//│ 		      (`None))
//│ 		and enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N))
//│ 		and filter ls_0 f_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (f_0 h_0) then
//│ 		        (`C(h_0, ((filter t_0) f_0)))
//│ 		      else
//│ 		        ((filter t_0) f_0))
//│ 		    | `N -> 
//│ 		      (`N))
//│ 		and last a_1 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      a_1
//│ 		    | `C(h_2, t_2) -> 
//│ 		      ((last h_2) t_2))
//│ 		and lastDrive ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (`Some(((last h_1) t_1)))
//│ 		    | `N -> 
//│ 		      (`None))
//│ 		and testLastFilter ls_3 =
//│ 		  (lastDrive ((filter ls_3) (fun x_0 -> 
//│ 		    (x_0 < 1000))))
//│ 		and testManual ls_6 =
//│ 		  ((_lhManualLastFilterDrive ls_6) (fun x_1 -> 
//│ 		    (x_1 < 1000)));;
//│ 		(testLastFilter ((enumFromTo 1) 500000))
//│ 		(testManual ((enumFromTo 1) 500000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo^136] (hopeless to continue)
//│ 	[enumFromTo^136 · enumFromTo^7] ---> [enumFromTo^136] (using original def)
//│ [enumFromTo^145]
//│ 	[enumFromTo^145 · enumFromTo^7] ---> [enumFromTo^145] (only one)
//│ [testLastFilter^134]
//│ 	[testLastFilter^134 · filter^63]
//│ 		[testLastFilter^134 · filter^63 · filter^26] (hopeless to continue)
//│ 			[testLastFilter^134 · filter^63 · filter^26 · filter^26] ---> [testLastFilter^134 · filter^63 · filter^26] (using original def)
//│ 			[testLastFilter^134 · filter^63 · filter^26 · filter^32] ---> [testLastFilter^134 · filter^63 · filter^26] (using original def)
//│ 		[testLastFilter^134 · filter^63 · filter^32] ---> [testLastFilter^134 · filter^63] (only one)
//│ 	[testLastFilter^134 · lastDrive^62] (hopeless to continue)
//│ 		[testLastFilter^134 · lastDrive^62 · last^43] (using original def)
//│ 			[testLastFilter^134 · lastDrive^62 · last^43 · last^54] ---> [testLastFilter^134 · lastDrive^62 · last^43] (using original def)
//│ [testManual^143]
//│ 	[testManual^143 · _lhManualLastFilterDrive^123]
//│ 		[testManual^143 · _lhManualLastFilterDrive^123 · _lhManualLastFilterDrive^89] ---> [testManual^143 · _lhManualLastFilterDrive^123] (only one)
//│ 		[testManual^143 · _lhManualLastFilterDrive^123 · _lhManualLastFilter^79]
//│ 			[testManual^143 · _lhManualLastFilterDrive^123 · _lhManualLastFilter^79 · _lhManualLastFilter^103] ---> [testManual^143 · _lhManualLastFilterDrive^123 · _lhManualLastFilter^79] (only one)
//│ 			[testManual^143 · _lhManualLastFilterDrive^123 · _lhManualLastFilter^79 · _lhManualLastFilter^110] ---> [testManual^143 · _lhManualLastFilterDrive^123 · _lhManualLastFilter^79] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testLastFilter_₀(primId⁰(enumFromTo_₀(1, 500000)))
//│ testManual_₀(primId⁰(enumFromTo_₁(1, 500000)))
//│ def enumFromTo_₀(a⁷, b²) = 
//│ 	if (a⁷ <= b²) then [C a⁷ enumFromTo_₀((a⁷ + 1), b²)] else [N]
//│ def enumFromTo_₁(a⁵, b¹) = 
//│ 	if (a⁵ <= b¹) then [C a⁵ enumFromTo_₁((a⁵ + 1), b¹)] else [N]
//│ def testLastFilter_₀(ls⁹) = 
//│ 	lastDrive_₀(filter_₀(ls⁹, (fun x² -> (x² < 1000))))
//│ 	where
//│ 	def filter_₀(ls¹³, f⁵) = 
//│ 		case ls¹³ of {
//│ 			C h⁹ t⁹ => if f⁵(h⁹) then [C h⁹ filter_₁(t⁹, f⁵)] else filter_₀(t⁹, f⁵)
//│ 			| N  => [N]}
//│ 		where
//│ 		def filter_₁(ls¹⁴, f⁶) = 
//│ 			case ls¹⁴ of {
//│ 				C h¹⁰ t¹⁰ => if f⁶(h¹⁰) then [C h¹⁰ filter_₁(t¹⁰, f⁶)] else filter_₁(t¹⁰, f⁶)
//│ 				| N  => [N]}
//│ 	def lastDrive_₀(ls⁸) = 
//│ 		case ls⁸ of {
//│ 			C h⁶ t⁶ => [Some last_₀(h⁶, t⁶)]
//│ 			| N  => [None]}
//│ 		where
//│ 		def last_₀(a⁶, ls¹¹) = 
//│ 			case ls¹¹ of {
//│ 				N  => a⁶
//│ 				| C h⁷ t⁷ => last_₀(h⁷, t⁷)}
//│ def testManual_₀(ls¹⁰) = 
//│ 	_lhManualLastFilterDrive_₀(ls¹⁰, (fun x³ -> (x³ < 1000)))
//│ 	where
//│ 	def _lhManualLastFilterDrive_₀(ls⁷, f³) = 
//│ 		case ls⁷ of {
//│ 			C h⁵ t⁵ => if f³(h⁵) then 
//│ 				let a⁴ = _lhManualLastFilter_₀(t⁵, f³, h⁵)
//│ 				in [Some a⁴] else _lhManualLastFilterDrive_₀(t⁵, f³)
//│ 			| N  => [None]}
//│ 		where
//│ 		def _lhManualLastFilter_₀(ls¹², f⁴, a⁸) = 
//│ 			case ls¹² of {
//│ 				C h⁸ t⁸ => if f⁴(h⁸) then _lhManualLastFilter_₀(t⁸, f⁴, h⁸) else _lhManualLastFilter_₀(t⁸, f⁴, a⁸)
//│ 				| N  => a⁸}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C h⁹ filter_₁(t⁹, f⁵)]: 294 --->
//│ 	case ls⁸ of {C h⁶ t⁶ => [Some last_₀(h⁶, t⁶)] | N  => [None]}: 204
//│ [N]: 301 --->
//│ 	case ls⁸ of {C h⁶ t⁶ => [Some last_₀(h⁶, t⁶)] | N  => [None]}: 204
//│ [C h¹⁰ filter_₁(t¹⁰, f⁶)]: 315 --->
//│ 	case ls¹¹ of {N  => a⁶ | C h⁷ t⁷ => last_₀(h⁷, t⁷)}: 237
//│ [N]: 322 --->
//│ 	case ls¹¹ of {N  => a⁶ | C h⁷ t⁷ => last_₀(h⁷, t⁷)}: 237
//│ ------------------
//│ case ls⁸ of {C h⁶ t⁶ => [Some last_₀(h⁶, t⁶)] | N  => [None]}: 204 --->
//│ 	[C h⁹ filter_₁(t⁹, f⁵)]: 294
//│ 	[N]: 301
//│ case ls¹¹ of {N  => a⁶ | C h⁷ t⁷ => last_₀(h⁷, t⁷)}: 237 --->
//│ 	[C h¹⁰ filter_₁(t¹⁰, f⁶)]: 315
//│ 	[N]: 322
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C h⁹ filter_₁(t⁹, f⁵)]: 294 --->
//│ 	case ls⁸ of {C h⁶ t⁶ => [Some last_₀(h⁶, t⁶)] | N  => [None]}: 204
//│ [N]: 301 --->
//│ 	case ls⁸ of {C h⁶ t⁶ => [Some last_₀(h⁶, t⁶)] | N  => [None]}: 204
//│ [C h¹⁰ filter_₁(t¹⁰, f⁶)]: 315 --->
//│ 	case ls¹¹ of {N  => a⁶ | C h⁷ t⁷ => last_₀(h⁷, t⁷)}: 237
//│ [N]: 322 --->
//│ 	case ls¹¹ of {N  => a⁶ | C h⁷ t⁷ => last_₀(h⁷, t⁷)}: 237
//│ ------------------
//│ case ls⁸ of {C h⁶ t⁶ => [Some last_₀(h⁶, t⁶)] | N  => [None]}: 204 --->
//│ 	[C h⁹ filter_₁(t⁹, f⁵)]: 294
//│ 	[N]: 301
//│ case ls¹¹ of {N  => a⁶ | C h⁷ t⁷ => last_₀(h⁷, t⁷)}: 237 --->
//│ 	[C h¹⁰ filter_₁(t¹⁰, f⁶)]: 315
//│ 	[N]: 322
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testLastFilter_₀(primId⁰(enumFromTo_₀(1, 500000)))
//│ testManual_₀(primId⁰(enumFromTo_₁(1, 500000)))
//│ def enumFromTo_₀(a¹³, b⁴) = 
//│ 	if (a¹³ <= b⁴) then [C a¹³ enumFromTo_₀((a¹³ + 1), b⁴)] else [N]
//│ def enumFromTo_₁(a¹¹, b³) = 
//│ 	if (a¹¹ <= b³) then [C a¹¹ enumFromTo_₁((a¹¹ + 1), b³)] else [N]
//│ def testLastFilter_₀(ls²⁰) = 
//│ 	lastDrive_₀(filter_₀(ls²⁰, (fun x⁵ -> (x⁵ < 1000))))
//│ 	where
//│ 	def filter_₀(ls¹⁷, f⁸) = 
//│ 		case ls¹⁷ of {
//│ 			C h⁹ t⁹ => if f⁸(h⁹) then 
//│ 				let t¹² = filter_₁(t⁹, f⁸)
//│ 				in let h¹² = h⁹
//│ 				in (fun _lh_dummy⁰ -> [Some last_₀(h¹², t¹²)]) else filter_₀(t⁹, f⁸)
//│ 			| N  => (fun _lh_dummy¹ -> [None])}
//│ 		where
//│ 		def filter_₁(ls¹⁶, f⁷) = 
//│ 			case ls¹⁶ of {
//│ 				C h¹⁰ t¹⁰ => if f⁷(h¹⁰) then 
//│ 					let t¹¹ = filter_₁(t¹⁰, f⁷)
//│ 					in let h¹¹ = h¹⁰
//│ 					in (fun a⁹ -> last_₀(h¹¹, t¹¹)) else filter_₁(t¹⁰, f⁷)
//│ 				| N  => (fun a¹⁰ -> a¹⁰)}
//│ 	def lastDrive_₀(ls¹⁵) = 
//│ 		ls¹⁵(99)
//│ 		where
//│ 		def last_₀(a¹⁴, ls²¹) = 
//│ 			ls²¹(a¹⁴)
//│ def testManual_₀(ls¹⁸) = 
//│ 	_lhManualLastFilterDrive_₀(ls¹⁸, (fun x⁴ -> (x⁴ < 1000)))
//│ 	where
//│ 	def _lhManualLastFilterDrive_₀(ls¹⁹, f⁹) = 
//│ 		case ls¹⁹ of {
//│ 			C h⁵ t⁵ => if f⁹(h⁵) then 
//│ 				let a¹² = _lhManualLastFilter_₀(t⁵, f⁹, h⁵)
//│ 				in [Some a¹²] else _lhManualLastFilterDrive_₀(t⁵, f⁹)
//│ 			| N  => [None]}
//│ 		where
//│ 		def _lhManualLastFilter_₀(ls²², f¹⁰, a¹⁵) = 
//│ 			case ls²² of {
//│ 				C h⁸ t⁸ => if f¹⁰(h⁸) then _lhManualLastFilter_₀(t⁸, f¹⁰, h⁸) else _lhManualLastFilter_₀(t⁸, f¹⁰, a¹⁵)
//│ 				| N  => a¹⁵}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun filter(ls, f) = if ls is
  C(h, t) then if f(h) then C(h, filter(t, f)) else filter(t, f)
  N then N
fun lastDrive(ls) = if ls is
  C(h, t) then Some(last(h, t))
  N then None
fun last(a, ls) = if ls is
  N then a
  C(h, t) then last(h, t)
fun testLastFilterEnum(n) = lastDrive(filter(enumFromTo(1, n), x => x < 1000))
testLastFilterEnum(primId(500000))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |filter|(|ls|,| |f|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |C|(|h|,| |filter|(|t|,| |f|)|)| |#else| |filter|(|t|,| |f|)|↵|N| |#then| |N|←|↵|#fun| |lastDrive|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |Some|(|last|(|h|,| |t|)|)|↵|N| |#then| |None|←|↵|#fun| |last|(|a|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |a|↵|C|(|h|,| |t|)| |#then| |last|(|h|,| |t|)|←|↵|#fun| |testLastFilterEnum|(|n|)| |#=| |lastDrive|(|filter|(|enumFromTo|(|1|,| |n|)|,| |x| |=>| |x| |<| |1000|)|)|↵|testLastFilterEnum|(|primId|(|500000|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun filter = ls, f, => if ls is ‹(C (h, t,)) then if (f (h,)) then C (h, filter (t, f,),) else filter (t, f,); (N) then N›; fun lastDrive = ls, => if ls is ‹(C (h, t,)) then Some (last (h, t,),); (N) then None›; fun last = a, ls, => if ls is ‹(N) then a; (C (h, t,)) then last (h, t,)›; fun testLastFilterEnum = n, => lastDrive (filter (enumFromTo (1, n,), x, => < (x,) (1000,),),); testLastFilterEnum (primId (500000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testLastFilterEnum^79(primId⁰(500000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def filter(ls⁰, f⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => if f⁰(h⁰) then [C h⁰ filter^26(t⁰, f⁰)] else filter^32(t⁰, f⁰)
//│ 	| N  => [N]}
//│ def last(a¹, ls²) = case ls² of {
//│ 	N  => a¹
//│ 	| C h² t² => last^54(h², t²)}
//│ def lastDrive(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => [Some last^43(h¹, t¹)]
//│ 	| N  => [None]}
//│ def testLastFilterEnum(n⁰) = lastDrive^62(filter^63(enumFromTo^64(1, n⁰), (fun x⁰ -> (x⁰ < 1000))))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N))
//│ 		and filter ls_0 f_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (f_0 h_0) then
//│ 		        (`C(h_0, ((filter t_0) f_0)))
//│ 		      else
//│ 		        ((filter t_0) f_0))
//│ 		    | `N -> 
//│ 		      (`N))
//│ 		and last a_1 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      a_1
//│ 		    | `C(h_2, t_2) -> 
//│ 		      ((last h_2) t_2))
//│ 		and lastDrive ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (`Some(((last h_1) t_1)))
//│ 		    | `N -> 
//│ 		      (`None))
//│ 		and testLastFilterEnum n_0 =
//│ 		  (lastDrive ((filter ((enumFromTo 1) n_0)) (fun x_0 -> 
//│ 		    (x_0 < 1000))));;
//│ 		(testLastFilterEnum 500000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testLastFilterEnum^79] (hopeless to continue)
//│ 	[testLastFilterEnum^79 · enumFromTo^64] (using original def)
//│ 		[testLastFilterEnum^79 · enumFromTo^64 · enumFromTo^7] ---> [testLastFilterEnum^79 · enumFromTo^64] (using original def)
//│ 	[testLastFilterEnum^79 · filter^63] (using original def)
//│ 		[testLastFilterEnum^79 · filter^63 · filter^26] ---> [testLastFilterEnum^79 · filter^63] (using original def)
//│ 		[testLastFilterEnum^79 · filter^63 · filter^32] ---> [testLastFilterEnum^79 · filter^63] (using original def)
//│ 	[testLastFilterEnum^79 · lastDrive^62] (using original def)
//│ 		[testLastFilterEnum^79 · lastDrive^62 · last^43] (using original def)
//│ 			[testLastFilterEnum^79 · lastDrive^62 · last^43 · last^54] ---> [testLastFilterEnum^79 · lastDrive^62 · last^43] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testLastFilterEnum_₀(primId⁰(500000))
//│ def testLastFilterEnum_₀(n¹) = 
//│ 	lastDrive_₀(filter_₀(enumFromTo_₀(1, n¹), (fun x¹ -> (x¹ < 1000))))
//│ 	where
//│ 	def enumFromTo_₀(a², b¹) = 
//│ 		if (a² <= b¹) then [C a² enumFromTo_₀((a² + 1), b¹)] else [N]
//│ 	def filter_₀(ls⁴, f¹) = 
//│ 		case ls⁴ of {
//│ 			C h⁴ t⁴ => if f¹(h⁴) then [C h⁴ filter_₀(t⁴, f¹)] else filter_₀(t⁴, f¹)
//│ 			| N  => [N]}
//│ 	def lastDrive_₀(ls³) = 
//│ 		case ls³ of {
//│ 			C h³ t³ => [Some last_₀(h³, t³)]
//│ 			| N  => [None]}
//│ 		where
//│ 		def last_₀(a³, ls⁵) = 
//│ 			case ls⁵ of {
//│ 				N  => a³
//│ 				| C h⁵ t⁵ => last_₀(h⁵, t⁵)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a² enumFromTo_₀((a² + 1), b¹)]: 99 --->
//│ 	case ls⁴ of {C h⁴ t⁴ => if f¹(h⁴) then [C h⁴ filter_₀(t⁴, f¹)] else filter_₀(t⁴, f¹) | N  => [N]}: 132
//│ [N]: 100 --->
//│ 	case ls⁴ of {C h⁴ t⁴ => if f¹(h⁴) then [C h⁴ filter_₀(t⁴, f¹)] else filter_₀(t⁴, f¹) | N  => [N]}: 132
//│ [C h⁴ filter_₀(t⁴, f¹)]: 124 --->
//│ 	case ls³ of {C h³ t³ => [Some last_₀(h³, t³)] | N  => [None]}: 112
//│ 	case ls⁵ of {N  => a³ | C h⁵ t⁵ => last_₀(h⁵, t⁵)}: 159
//│ [N]: 131 --->
//│ 	case ls³ of {C h³ t³ => [Some last_₀(h³, t³)] | N  => [None]}: 112
//│ 	case ls⁵ of {N  => a³ | C h⁵ t⁵ => last_₀(h⁵, t⁵)}: 159
//│ ------------------
//│ case ls³ of {C h³ t³ => [Some last_₀(h³, t³)] | N  => [None]}: 112 --->
//│ 	[C h⁴ filter_₀(t⁴, f¹)]: 124
//│ 	[N]: 131
//│ case ls⁴ of {C h⁴ t⁴ => if f¹(h⁴) then [C h⁴ filter_₀(t⁴, f¹)] else filter_₀(t⁴, f¹) | N  => [N]}: 132 --->
//│ 	[C a² enumFromTo_₀((a² + 1), b¹)]: 99
//│ 	[N]: 100
//│ case ls⁵ of {N  => a³ | C h⁵ t⁵ => last_₀(h⁵, t⁵)}: 159 --->
//│ 	[C h⁴ filter_₀(t⁴, f¹)]: 124
//│ 	[N]: 131
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C a² enumFromTo_₀((a² + 1), b¹)]: 99 --->
//│ 	case ls⁴ of {C h⁴ t⁴ => if f¹(h⁴) then [C h⁴ filter_₀(t⁴, f¹)] else filter_₀(t⁴, f¹) | N  => [N]}: 132
//│ [N]: 100 --->
//│ 	case ls⁴ of {C h⁴ t⁴ => if f¹(h⁴) then [C h⁴ filter_₀(t⁴, f¹)] else filter_₀(t⁴, f¹) | N  => [N]}: 132
//│ ------------------
//│ case ls⁴ of {C h⁴ t⁴ => if f¹(h⁴) then [C h⁴ filter_₀(t⁴, f¹)] else filter_₀(t⁴, f¹) | N  => [N]}: 132 --->
//│ 	[C a² enumFromTo_₀((a² + 1), b¹)]: 99
//│ 	[N]: 100
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testLastFilterEnum_₀(primId⁰(500000))
//│ def testLastFilterEnum_₀(n²) = 
//│ 	lastDrive_₀(filter_₀(enumFromTo_₀(1, n²), (fun x² -> (x² < 1000))))
//│ 	where
//│ 	def enumFromTo_₀(a⁵, b²) = 
//│ 		if (a⁵ <= b²) then 
//│ 			let t⁶ = enumFromTo_₀((a⁵ + 1), b²)
//│ 			in let h⁶ = a⁵
//│ 			in (fun f³ -> if f³(h⁶) then [C h⁶ filter_₀(t⁶, f³)] else filter_₀(t⁶, f³)) else (fun f⁴ -> [N])
//│ 	def filter_₀(ls⁷, f²) = 
//│ 		ls⁷(f²)
//│ 	def lastDrive_₀(ls⁶) = 
//│ 		case ls⁶ of {
//│ 			C h³ t³ => [Some last_₀(h³, t³)]
//│ 			| N  => [None]}
//│ 		where
//│ 		def last_₀(a⁴, ls⁸) = 
//│ 			case ls⁸ of {
//│ 				N  => a⁴
//│ 				| C h⁵ t⁵ => last_₀(h⁵, t⁵)}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun testMapmap(ls) = map(x => x + 1, map(x => x * x, ls))
fun _lhManual(ls, f1, f2) = if ls is
  C(h, t) then C(f2(f1(h)), _lhManual(t, f1, f2))
  N then N
fun testManual(ls) = _lhManual(ls, x => x * x, x => x + 1)
testMapmap(primId(enumFromTo(1, 100000)))
testManual(primId(enumFromTo(1, 100000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |testMapmap|(|ls|)| |#=| |map|(|x| |=>| |x| |+| |1|,| |map|(|x| |=>| |x| |*| |x|,| |ls|)|)|↵|#fun| |_lhManual|(|ls|,| |f1|,| |f2|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f2|(|f1|(|h|)|)|,| |_lhManual|(|t|,| |f1|,| |f2|)|)|↵|N| |#then| |N|←|↵|#fun| |testManual|(|ls|)| |#=| |_lhManual|(|ls|,| |x| |=>| |x| |*| |x|,| |x| |=>| |x| |+| |1|)|↵|testMapmap|(|primId|(|enumFromTo|(|1|,| |100000|)|)|)|↵|testManual|(|primId|(|enumFromTo|(|1|,| |100000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun testMapmap = ls, => map (x, => + (x,) (1,), map (x, => * (x,) (x,), ls,),); fun _lhManual = ls, f1, f2, => if ls is ‹(C (h, t,)) then C (f2 (f1 (h,),), _lhManual (t, f1, f2,),); (N) then N›; fun testManual = ls, => _lhManual (ls, x, => * (x,) (x,), x, => + (x,) (1,),); testMapmap (primId (enumFromTo (1, 100000,),),); testManual (primId (enumFromTo (1, 100000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapmap^92(primId⁰(enumFromTo^94(1, 100000)))
//│ testManual^101(primId⁰(enumFromTo^103(1, 100000)))
//│ def _lhManual(ls², f1⁰, f2⁰) = case ls² of {
//│ 	C h¹ t¹ => [C f2⁰(f1⁰(h¹)) _lhManual^61(t¹, f1⁰, f2⁰)]
//│ 	| N  => [N]}
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^25(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def testManual(ls³) = _lhManual^74(ls³, (fun x² -> (x² * x²)), (fun x³ -> (x³ + 1)))
//│ def testMapmap(ls¹) = map^35((fun x⁰ -> (x⁰ + 1)), map^43((fun x¹ -> (x¹ * x¹)), ls¹))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec _lhManual ls_2 f1_0 f2_0 =
//│ 		  (match ls_2 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (`C((f2_0 (f1_0 h_1)), (((_lhManual t_1) f1_0) f2_0)))
//│ 		    | `N -> 
//│ 		      (`N))
//│ 		and enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N))
//│ 		and map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N))
//│ 		and testManual ls_3 =
//│ 		  (((_lhManual ls_3) (fun x_2 -> 
//│ 		    (x_2 * x_2))) (fun x_3 -> 
//│ 		    (x_3 + 1)))
//│ 		and testMapmap ls_1 =
//│ 		  ((map (fun x_0 -> 
//│ 		    (x_0 + 1))) ((map (fun x_1 -> 
//│ 		    (x_1 * x_1))) ls_1));;
//│ 		(testMapmap ((enumFromTo 1) 100000))
//│ 		(testManual ((enumFromTo 1) 100000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo^103]
//│ 	[enumFromTo^103 · enumFromTo^7] ---> [enumFromTo^103] (only one)
//│ [enumFromTo^94] (hopeless to continue)
//│ 	[enumFromTo^94 · enumFromTo^7] ---> [enumFromTo^94] (using original def)
//│ [testManual^101]
//│ 	[testManual^101 · _lhManual^74]
//│ 		[testManual^101 · _lhManual^74 · _lhManual^61] ---> [testManual^101 · _lhManual^74] (only one)
//│ [testMapmap^92]
//│ 	[testMapmap^92 · map^35]
//│ 		[testMapmap^92 · map^35 · map^25] ---> [testMapmap^92 · map^35] (only one)
//│ 	[testMapmap^92 · map^43]
//│ 		[testMapmap^92 · map^43 · map^25] ---> [testMapmap^92 · map^43] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testMapmap_₀(primId⁰(enumFromTo_₁(1, 100000)))
//│ testManual_₀(primId⁰(enumFromTo_₀(1, 100000)))
//│ def enumFromTo_₀(a¹, b¹) = 
//│ 	if (a¹ <= b¹) then [C a¹ enumFromTo_₀((a¹ + 1), b¹)] else [N]
//│ def enumFromTo_₁(a², b²) = 
//│ 	if (a² <= b²) then [C a² enumFromTo_₁((a² + 1), b²)] else [N]
//│ def testManual_₀(ls⁴) = 
//│ 	_lhManual_₀(ls⁴, (fun x⁴ -> (x⁴ * x⁴)), (fun x⁵ -> (x⁵ + 1)))
//│ 	where
//│ 	def _lhManual_₀(ls⁶, f1¹, f2¹) = 
//│ 		case ls⁶ of {
//│ 			C h³ t³ => [C f2¹(f1¹(h³)) _lhManual_₀(t³, f1¹, f2¹)]
//│ 			| N  => [N]}
//│ def testMapmap_₀(ls⁸) = 
//│ 	map_₀((fun x⁶ -> (x⁶ + 1)), map_₁((fun x⁷ -> (x⁷ * x⁷)), ls⁸))
//│ 	where
//│ 	def map_₀(f², ls⁷) = 
//│ 		case ls⁷ of {
//│ 			C h⁴ t⁴ => [C f²(h⁴) map_₀(f², t⁴)]
//│ 			| N  => [N]}
//│ 	def map_₁(f¹, ls⁵) = 
//│ 		case ls⁵ of {
//│ 			C h² t² => [C f¹(h²) map_₁(f¹, t²)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f¹(h²) map_₁(f¹, t²)]: 137 --->
//│ 	case ls⁷ of {C h⁴ t⁴ => [C f²(h⁴) map_₀(f², t⁴)] | N  => [N]}: 192
//│ [N]: 138 --->
//│ 	case ls⁷ of {C h⁴ t⁴ => [C f²(h⁴) map_₀(f², t⁴)] | N  => [N]}: 192
//│ ------------------
//│ case ls⁷ of {C h⁴ t⁴ => [C f²(h⁴) map_₀(f², t⁴)] | N  => [N]}: 192 --->
//│ 	[C f¹(h²) map_₁(f¹, t²)]: 137
//│ 	[N]: 138
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f¹(h²) map_₁(f¹, t²)]: 137 --->
//│ 	case ls⁷ of {C h⁴ t⁴ => [C f²(h⁴) map_₀(f², t⁴)] | N  => [N]}: 192
//│ [N]: 138 --->
//│ 	case ls⁷ of {C h⁴ t⁴ => [C f²(h⁴) map_₀(f², t⁴)] | N  => [N]}: 192
//│ ------------------
//│ case ls⁷ of {C h⁴ t⁴ => [C f²(h⁴) map_₀(f², t⁴)] | N  => [N]}: 192 --->
//│ 	[C f¹(h²) map_₁(f¹, t²)]: 137
//│ 	[N]: 138
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapmap_₀(primId⁰(enumFromTo_₁(1, 100000)))
//│ testManual_₀(primId⁰(enumFromTo_₀(1, 100000)))
//│ def enumFromTo_₀(a⁴, b⁴) = 
//│ 	if (a⁴ <= b⁴) then [C a⁴ enumFromTo_₀((a⁴ + 1), b⁴)] else [N]
//│ def enumFromTo_₁(a³, b³) = 
//│ 	if (a³ <= b³) then [C a³ enumFromTo_₁((a³ + 1), b³)] else [N]
//│ def testManual_₀(ls¹²) = 
//│ 	_lhManual_₀(ls¹², (fun x¹⁰ -> (x¹⁰ * x¹⁰)), (fun x¹¹ -> (x¹¹ + 1)))
//│ 	where
//│ 	def _lhManual_₀(ls¹³, f1², f2²) = 
//│ 		case ls¹³ of {
//│ 			C h³ t³ => [C f2²(f1²(h³)) _lhManual_₀(t³, f1², f2²)]
//│ 			| N  => [N]}
//│ def testMapmap_₀(ls¹⁰) = 
//│ 	map_₀((fun x⁸ -> (x⁸ + 1)), map_₁((fun x⁹ -> (x⁹ * x⁹)), ls¹⁰))
//│ 	where
//│ 	def map_₀(f³, ls⁹) = 
//│ 		ls⁹(f³)
//│ 	def map_₁(f⁴, ls¹¹) = 
//│ 		case ls¹¹ of {
//│ 			C h² t² => 
//│ 				let t⁵ = map_₁(f⁴, t²)
//│ 				in let h⁵ = f⁴(h²)
//│ 				in (fun f⁵ -> [C f⁵(h⁵) map_₀(f⁵, t⁵)])
//│ 			| N  => (fun f⁶ -> [N])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


// NOTE: digression: simply use `let r = f(h) in C(r, map(t, f))` will be faster
:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun map(f, ls) = if ls is
  C(h, t) then let r = f(h) in C(r, map(f, t))
  N then N
fun testMapmapLet(ls) = map(x => x + 1, map(x => x * x, ls))
testMapmapLet(primId(enumFromTo(1, 100000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |#let| |r| |#=| |f|(|h|)| |#in| |C|(|r|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |testMapmapLet|(|ls|)| |#=| |map|(|x| |=>| |x| |+| |1|,| |map|(|x| |=>| |x| |*| |x|,| |ls|)|)|↵|testMapmapLet|(|primId|(|enumFromTo|(|1|,| |100000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun map = f, ls, => if ls is ‹(C (h, t,)) then let r = f (h,) in C (r, map (f, t,),); (N) then N›; fun testMapmapLet = ls, => map (x, => + (x,) (1,), map (x, => * (x,) (x,), ls,),); testMapmapLet (primId (enumFromTo (1, 100000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapmapLet^57(primId⁰(enumFromTo^59(1, 100000)))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => 
//│ 		let r⁰ = f⁰(h⁰)
//│ 		in [C r⁰ map^26(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def testMapmapLet(ls¹) = map^37((fun x⁰ -> (x⁰ + 1)), map^45((fun x¹ -> (x¹ * x¹)), ls¹))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N))
//│ 		and map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (let rec r_0 = (f_0 h_0) in
//│ 		        (`C(r_0, ((map f_0) t_0))))
//│ 		    | `N -> 
//│ 		      (`N))
//│ 		and testMapmapLet ls_1 =
//│ 		  ((map (fun x_0 -> 
//│ 		    (x_0 + 1))) ((map (fun x_1 -> 
//│ 		    (x_1 * x_1))) ls_1));;
//│ 		(testMapmapLet ((enumFromTo 1) 100000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo^59]
//│ 	[enumFromTo^59 · enumFromTo^7] ---> [enumFromTo^59] (only one)
//│ [testMapmapLet^57]
//│ 	[testMapmapLet^57 · map^37]
//│ 		[testMapmapLet^57 · map^37 · map^26] ---> [testMapmapLet^57 · map^37] (only one)
//│ 	[testMapmapLet^57 · map^45]
//│ 		[testMapmapLet^57 · map^45 · map^26] ---> [testMapmapLet^57 · map^45] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testMapmapLet_₀(primId⁰(enumFromTo_₀(1, 100000)))
//│ def enumFromTo_₀(a¹, b¹) = 
//│ 	if (a¹ <= b¹) then [C a¹ enumFromTo_₀((a¹ + 1), b¹)] else [N]
//│ def testMapmapLet_₀(ls³) = 
//│ 	map_₀((fun x² -> (x² + 1)), map_₁((fun x³ -> (x³ * x³)), ls³))
//│ 	where
//│ 	def map_₀(f², ls⁴) = 
//│ 		case ls⁴ of {
//│ 			C h² t² => 
//│ 				let r² = f²(h²)
//│ 				in [C r² map_₀(f², t²)]
//│ 			| N  => [N]}
//│ 	def map_₁(f¹, ls²) = 
//│ 		case ls² of {
//│ 			C h¹ t¹ => 
//│ 				let r¹ = f¹(h¹)
//│ 				in [C r¹ map_₁(f¹, t¹)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C r¹ map_₁(f¹, t¹)]: 76 --->
//│ 	case ls⁴ of {C h² t² => let r² = f²(h²)
//│ in [C r² map_₀(f², t²)] | N  => [N]}: 135
//│ [N]: 78 --->
//│ 	case ls⁴ of {C h² t² => let r² = f²(h²)
//│ in [C r² map_₀(f², t²)] | N  => [N]}: 135
//│ ------------------
//│ case ls⁴ of {C h² t² => let r² = f²(h²)
//│ in [C r² map_₀(f², t²)] | N  => [N]}: 135 --->
//│ 	[C r¹ map_₁(f¹, t¹)]: 76
//│ 	[N]: 78
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C r¹ map_₁(f¹, t¹)]: 76 --->
//│ 	case ls⁴ of {C h² t² => let r² = f²(h²)
//│ in [C r² map_₀(f², t²)] | N  => [N]}: 135
//│ [N]: 78 --->
//│ 	case ls⁴ of {C h² t² => let r² = f²(h²)
//│ in [C r² map_₀(f², t²)] | N  => [N]}: 135
//│ ------------------
//│ case ls⁴ of {C h² t² => let r² = f²(h²)
//│ in [C r² map_₀(f², t²)] | N  => [N]}: 135 --->
//│ 	[C r¹ map_₁(f¹, t¹)]: 76
//│ 	[N]: 78
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapmapLet_₀(primId⁰(enumFromTo_₀(1, 100000)))
//│ def enumFromTo_₀(a², b²) = 
//│ 	if (a² <= b²) then [C a² enumFromTo_₀((a² + 1), b²)] else [N]
//│ def testMapmapLet_₀(ls⁶) = 
//│ 	map_₀((fun x⁴ -> (x⁴ + 1)), map_₁((fun x⁵ -> (x⁵ * x⁵)), ls⁶))
//│ 	where
//│ 	def map_₀(f⁶, ls⁷) = 
//│ 		ls⁷(f⁶)
//│ 	def map_₁(f³, ls⁵) = 
//│ 		case ls⁵ of {
//│ 			C h¹ t¹ => 
//│ 				let r³ = f³(h¹)
//│ 				in let t³ = map_₁(f³, t¹)
//│ 				in let h³ = r³
//│ 				in (fun f⁴ -> 
//│ 					let r⁴ = f⁴(h³)
//│ 					in [C r⁴ map_₀(f⁴, t³)])
//│ 			| N  => (fun f⁵ -> [N])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
:lhInHaskell
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = flatMap (\b ->
              flatMap (\q -> if (safe q 1 b) then [q:b] else []) [1..nq]
            ) (gen (n-1) nq)
flatMap f [] = []
flatMap f (h:t) = append (f h) (flatMap f t)
append [] ys = ys
append (h:t) ys = h:(append t ys)
nsoln nq = length (gen nq nq)
testQueenUsingFlatMapBuiltInType n = nsoln n
testQueenUsingFlatMapBuiltInType $ primId 11
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testQueenUsingFlatMapBuiltInType_₀^940(primId⁰(11))
//│ def append_₀(_lh_append_arg1², _lh_append_arg2²) = case _lh_append_arg1² of {
//│ 	LH_N  => _lh_append_arg2²
//│ 	| LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append_₀^930(_lh_append_LH_C_1², _lh_append_arg2²)]
//│ 	| _  => error⁰}
//│ def append_₁(_lh_append_arg1¹, _lh_append_arg2¹) = case _lh_append_arg1¹ of {
//│ 	LH_N  => _lh_append_arg2¹
//│ 	| LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₁^758(_lh_append_LH_C_1¹, _lh_append_arg2¹)]
//│ 	| _  => error⁰}
//│ def enumFromTo_₀(a⁵, b⁴) = if (a⁵ <= b⁴) then [LH_C a⁵ enumFromTo_₀^838((a⁵ + 1), b⁴)] else [LH_N]
//│ def flatMap_₀(_lh_flatMap_arg1¹, _lh_flatMap_arg2¹) = case _lh_flatMap_arg2¹ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append_₀^817(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_₀^822(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹))
//│ 	| _  => error⁰}
//│ def flatMap_₁(_lh_flatMap_arg1², _lh_flatMap_arg2²) = case _lh_flatMap_arg2² of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append_₁^854(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap_₁^859(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²))
//│ 	| _  => error⁰}
//│ def gen_₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => flatMap_₀^772((fun b³ -> flatMap_₁^773((fun q¹ -> if safe_₀^774(q¹, 1, b³) then [LH_C [LH_C q¹ b³] [LH_N]] else [LH_N]), enumFromTo_₀^790(1, _lh_gen_arg2¹))), gen_₀^798((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length_₀(ls¹⁹) = case ls¹⁹ of {
//│ 	LH_C h²⁰ t²² => (1 + length_₀^748(t²²))
//│ 	| LH_N  => 0}
//│ def nsoln_₀(_lh_nsoln_arg1¹) = length_₀^919(gen_₀^920(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe_₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe_₀^902(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))
//│ 	| _  => error⁰}
//│ def testQueenUsingFlatMapBuiltInType_₀(_lh_testQueenUsingFlatMapBuiltInType_arg1¹) = nsoln_₀^811(_lh_testQueenUsingFlatMapBuiltInType_arg1¹)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec append__d0 _lh_append_arg1_2 _lh_append_arg2_2 =
//│ 		  (match _lh_append_arg1_2 with
//│ 		    | `LH_N -> 
//│ 		      _lh_append_arg2_2
//│ 		    | `LH_C(_lh_append_LH_C_0_2, _lh_append_LH_C_1_2) -> 
//│ 		      (`LH_C(_lh_append_LH_C_0_2, ((append__d0 _lh_append_LH_C_1_2) _lh_append_arg2_2)))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and append__d1 _lh_append_arg1_1 _lh_append_arg2_1 =
//│ 		  (match _lh_append_arg1_1 with
//│ 		    | `LH_N -> 
//│ 		      _lh_append_arg2_1
//│ 		    | `LH_C(_lh_append_LH_C_0_1, _lh_append_LH_C_1_1) -> 
//│ 		      (`LH_C(_lh_append_LH_C_0_1, ((append__d1 _lh_append_LH_C_1_1) _lh_append_arg2_1)))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and enumFromTo__d0 a_5 b_4 =
//│ 		  (if (a_5 <= b_4) then
//│ 		    (`LH_C(a_5, ((enumFromTo__d0 (a_5 + 1)) b_4)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and flatMap__d0 _lh_flatMap_arg1_1 _lh_flatMap_arg2_1 =
//│ 		  (match _lh_flatMap_arg2_1 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_flatMap_LH_C_0_1, _lh_flatMap_LH_C_1_1) -> 
//│ 		      ((append__d0 (_lh_flatMap_arg1_1 _lh_flatMap_LH_C_0_1)) ((flatMap__d0 _lh_flatMap_arg1_1) _lh_flatMap_LH_C_1_1))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and flatMap__d1 _lh_flatMap_arg1_2 _lh_flatMap_arg2_2 =
//│ 		  (match _lh_flatMap_arg2_2 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_flatMap_LH_C_0_2, _lh_flatMap_LH_C_1_2) -> 
//│ 		      ((append__d1 (_lh_flatMap_arg1_2 _lh_flatMap_LH_C_0_2)) ((flatMap__d1 _lh_flatMap_arg1_2) _lh_flatMap_LH_C_1_2))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and gen__d0 _lh_gen_arg1_1 _lh_gen_arg2_1 =
//│ 		  (match _lh_gen_arg1_1 with
//│ 		    | 0 -> 
//│ 		      (`LH_C((`LH_N), (`LH_N)))
//│ 		    | _ -> 
//│ 		      ((flatMap__d0 (fun b_3 -> 
//│ 		        ((flatMap__d1 (fun q_1 -> 
//│ 		          (if (((safe__d0 q_1) 1) b_3) then
//│ 		            (`LH_C((`LH_C(q_1, b_3)), (`LH_N)))
//│ 		          else
//│ 		            (`LH_N)))) ((enumFromTo__d0 1) _lh_gen_arg2_1)))) ((gen__d0 (_lh_gen_arg1_1 - 1)) _lh_gen_arg2_1)))
//│ 		and length__d0 ls_1_9 =
//│ 		  (match ls_1_9 with
//│ 		    | `LH_C(h_2_0, t_2_2) -> 
//│ 		      (1 + (length__d0 t_2_2))
//│ 		    | `LH_N -> 
//│ 		      0)
//│ 		and nsoln__d0 _lh_nsoln_arg1_1 =
//│ 		  (length__d0 ((gen__d0 _lh_nsoln_arg1_1) _lh_nsoln_arg1_1))
//│ 		and safe__d0 _lh_safe_arg1_1 _lh_safe_arg2_1 _lh_safe_arg3_1 =
//│ 		  (match _lh_safe_arg3_1 with
//│ 		    | `LH_N -> 
//│ 		      true
//│ 		    | `LH_C(_lh_safe_LH_C_0_1, _lh_safe_LH_C_1_1) -> 
//│ 		      ((((_lh_safe_arg1_1 <> _lh_safe_LH_C_0_1) && (_lh_safe_arg1_1 <> (_lh_safe_LH_C_0_1 + _lh_safe_arg2_1))) && (_lh_safe_arg1_1 <> (_lh_safe_LH_C_0_1 - _lh_safe_arg2_1))) && (((safe__d0 _lh_safe_arg1_1) (_lh_safe_arg2_1 + 1)) _lh_safe_LH_C_1_1))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and testQueenUsingFlatMapBuiltInType__d0 _lh_testQueenUsingFlatMapBuiltInType_arg1_1 =
//│ 		  (nsoln__d0 _lh_testQueenUsingFlatMapBuiltInType_arg1_1);;
//│ 		(testQueenUsingFlatMapBuiltInType__d0 11)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C _lh_append_LH_C_0¹ append_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 763 --->
//│ 	case _lh_append_arg1² of {LH_N  => _lh_append_arg2² | LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append_₀(_lh_append_LH_C_1², _lh_append_arg2²)] | _  => error⁰}: 937
//│ [LH_N]: 769 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe_₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰}: 915
//│ [LH_N]: 770 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₀(t²²)) | LH_N  => 0}: 753
//│ 	case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append_₀(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_₀(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 829
//│ [LH_C [LH_N] [LH_N]]: 771 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₀(t²²)) | LH_N  => 0}: 753
//│ 	case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append_₀(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_₀(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 829
//│ [LH_C q¹ b³]: 783 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe_₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰}: 915
//│ [LH_N]: 784 --->
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 765
//│ [LH_C [LH_C q¹ b³] [LH_N]]: 785 --->
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 765
//│ [LH_N]: 786 --->
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 765
//│ [LH_N]: 816 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₀(t²²)) | LH_N  => 0}: 753
//│ 	case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append_₀(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_₀(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 829
//│ [LH_C a⁵ enumFromTo_₀((a⁵ + 1), b⁴)]: 847 --->
//│ 	case _lh_flatMap_arg2² of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append_₁(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap_₁(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²)) | _  => error⁰}: 866
//│ [LH_N]: 848 --->
//│ 	case _lh_flatMap_arg2² of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append_₁(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap_₁(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²)) | _  => error⁰}: 866
//│ [LH_N]: 853 --->
//│ 	case _lh_append_arg1² of {LH_N  => _lh_append_arg2² | LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append_₀(_lh_append_LH_C_1², _lh_append_arg2²)] | _  => error⁰}: 937
//│ [LH_C _lh_append_LH_C_0² append_₀(_lh_append_LH_C_1², _lh_append_arg2²)]: 935 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₀(t²²)) | LH_N  => 0}: 753
//│ 	case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append_₀(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_₀(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 829
//│ ------------------
//│ case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₀(t²²)) | LH_N  => 0}: 753 --->
//│ 	[LH_N]: 770
//│ 	[LH_C [LH_N] [LH_N]]: 771
//│ 	[LH_N]: 816
//│ 	[LH_C _lh_append_LH_C_0² append_₀(_lh_append_LH_C_1², _lh_append_arg2²)]: 935
//│ case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 765 --->
//│ 	[LH_N]: 784
//│ 	[LH_C [LH_C q¹ b³] [LH_N]]: 785
//│ 	[LH_N]: 786
//│ case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append_₀(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_₀(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 829 --->
//│ 	[LH_N]: 770
//│ 	[LH_C [LH_N] [LH_N]]: 771
//│ 	[LH_N]: 816
//│ 	[LH_C _lh_append_LH_C_0² append_₀(_lh_append_LH_C_1², _lh_append_arg2²)]: 935
//│ case _lh_flatMap_arg2² of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append_₁(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap_₁(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²)) | _  => error⁰}: 866 --->
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b⁴)]: 847
//│ 	[LH_N]: 848
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe_₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰}: 915 --->
//│ 	[LH_N]: 769
//│ 	[LH_C q¹ b³]: 783
//│ case _lh_append_arg1² of {LH_N  => _lh_append_arg2² | LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append_₀(_lh_append_LH_C_1², _lh_append_arg2²)] | _  => error⁰}: 937 --->
//│ 	[LH_C _lh_append_LH_C_0¹ append_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 763
//│ 	[LH_N]: 853
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C _lh_append_LH_C_0¹ append_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 763 --->
//│ 	case _lh_append_arg1² of {LH_N  => _lh_append_arg2² | LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append_₀(_lh_append_LH_C_1², _lh_append_arg2²)] | _  => error⁰}: 937
//│ [LH_N]: 784 --->
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 765
//│ [LH_C [LH_C q¹ b³] [LH_N]]: 785 --->
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 765
//│ [LH_N]: 786 --->
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 765
//│ [LH_C a⁵ enumFromTo_₀((a⁵ + 1), b⁴)]: 847 --->
//│ 	case _lh_flatMap_arg2² of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append_₁(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap_₁(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²)) | _  => error⁰}: 866
//│ [LH_N]: 848 --->
//│ 	case _lh_flatMap_arg2² of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append_₁(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap_₁(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²)) | _  => error⁰}: 866
//│ [LH_N]: 853 --->
//│ 	case _lh_append_arg1² of {LH_N  => _lh_append_arg2² | LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append_₀(_lh_append_LH_C_1², _lh_append_arg2²)] | _  => error⁰}: 937
//│ ------------------
//│ case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 765 --->
//│ 	[LH_N]: 784
//│ 	[LH_C [LH_C q¹ b³] [LH_N]]: 785
//│ 	[LH_N]: 786
//│ case _lh_flatMap_arg2² of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0² _lh_flatMap_LH_C_1² => append_₁(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0²), flatMap_₁(_lh_flatMap_arg1², _lh_flatMap_LH_C_1²)) | _  => error⁰}: 866 --->
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b⁴)]: 847
//│ 	[LH_N]: 848
//│ case _lh_append_arg1² of {LH_N  => _lh_append_arg2² | LH_C _lh_append_LH_C_0² _lh_append_LH_C_1² => [LH_C _lh_append_LH_C_0² append_₀(_lh_append_LH_C_1², _lh_append_arg2²)] | _  => error⁰}: 937 --->
//│ 	[LH_C _lh_append_LH_C_0¹ append_₁(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 763
//│ 	[LH_N]: 853
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testQueenUsingFlatMapBuiltInType_₀(primId⁰(11))
//│ def append_₀(_lh_append_arg1³, _lh_append_arg2⁴) = _lh_append_arg1³(_lh_append_arg2⁴)
//│ def append_₁(_lh_append_arg1⁴, _lh_append_arg2⁹) = _lh_append_arg1⁴(_lh_append_arg2⁹)
//│ def enumFromTo_₀(a⁶, b⁵) = if (a⁶ <= b⁵) then 
//│ 	let _lh_flatMap_LH_C_1³ = enumFromTo_₀((a⁶ + 1), b⁵)
//│ 	in let _lh_flatMap_LH_C_0³ = a⁶
//│ 	in (fun _lh_flatMap_arg1⁴ -> append_₁(_lh_flatMap_arg1⁴(_lh_flatMap_LH_C_0³), flatMap_₁(_lh_flatMap_arg1⁴, _lh_flatMap_LH_C_1³))) else (fun _lh_flatMap_arg1⁵ -> (fun _lh_append_arg2³ -> _lh_append_arg2³))
//│ def flatMap_₀(_lh_flatMap_arg1³, _lh_flatMap_arg2³) = case _lh_flatMap_arg2³ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => append_₀(_lh_flatMap_arg1³(_lh_flatMap_LH_C_0¹), flatMap_₀(_lh_flatMap_arg1³, _lh_flatMap_LH_C_1¹))
//│ 	| _  => error⁰}
//│ def flatMap_₁(_lh_flatMap_arg1⁶, _lh_flatMap_arg2⁴) = _lh_flatMap_arg2⁴(_lh_flatMap_arg1⁶)
//│ def gen_₀(_lh_gen_arg1², _lh_gen_arg2²) = case _lh_gen_arg1² of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => flatMap_₀((fun b⁶ -> flatMap_₁((fun q² -> if safe_₀(q², 1, b⁶) then 
//│ 		let _lh_append_LH_C_1³ = (fun _lh_append_arg2⁷ -> _lh_append_arg2⁷)
//│ 		in let _lh_append_LH_C_0³ = [LH_C q² b⁶]
//│ 		in (fun _lh_append_arg2⁵ -> 
//│ 			let _lh_append_LH_C_1⁴ = append_₁(_lh_append_LH_C_1³, _lh_append_arg2⁵)
//│ 			in let _lh_append_LH_C_0⁴ = _lh_append_LH_C_0³
//│ 			in (fun _lh_append_arg2⁶ -> [LH_C _lh_append_LH_C_0⁴ append_₀(_lh_append_LH_C_1⁴, _lh_append_arg2⁶)])) else (fun _lh_append_arg2⁸ -> _lh_append_arg2⁸)), enumFromTo_₀(1, _lh_gen_arg2²))), gen_₀((_lh_gen_arg1² - 1), _lh_gen_arg2²))}
//│ def length_₀(ls²⁰) = case ls²⁰ of {
//│ 	LH_C h²⁰ t²² => (1 + length_₀(t²²))
//│ 	| LH_N  => 0}
//│ def nsoln_₀(_lh_nsoln_arg1²) = length_₀(gen_₀(_lh_nsoln_arg1², _lh_nsoln_arg1²))
//│ def safe_₀(_lh_safe_arg1², _lh_safe_arg2², _lh_safe_arg3²) = case _lh_safe_arg3² of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1² /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2²))) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2²))) && safe_₀(_lh_safe_arg1², (_lh_safe_arg2² + 1), _lh_safe_LH_C_1¹))
//│ 	| _  => error⁰}
//│ def testQueenUsingFlatMapBuiltInType_₀(_lh_testQueenUsingFlatMapBuiltInType_arg1²) = nsoln_₀(_lh_testQueenUsingFlatMapBuiltInType_arg1²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<



:lhGenOCaml
:lhInHaskell
safe x d []    = True
safe x d (q:l) = (x /= q) && (x /= (q+d)) && (x /= (q-d)) && (safe x (d+1) l)
gen 0 nq = [[]]
gen n nq = [ (q:b) | b <- gen (n-1) nq, q <- [1..nq], safe q 1 b ]
nsoln nq = length (gen nq nq)
testQueenBuiltInType n = nsoln n
testQueenBuiltInType $ primId 11
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testQueenBuiltInType_₀^874(primId⁰(11))
//│ def enumFromTo_₀(a⁵, b²) = if (a⁵ <= b²) then [LH_C a⁵ enumFromTo_₀^740((a⁵ + 1), b²)] else [LH_N]
//│ def gen_₀(_lh_gen_arg1¹, _lh_gen_arg2¹) = case _lh_gen_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 			LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 				let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 					LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe_₀^771(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)
//│ 					| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 				in _lh_listcomp_fun³(enumFromTo_₀^795(1, _lh_gen_arg2¹))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun²(gen_₀^806((_lh_gen_arg1¹ - 1), _lh_gen_arg2¹))}
//│ def length_₀(ls¹⁹) = case ls¹⁹ of {
//│ 	LH_C h²⁰ t²² => (1 + length_₀^758(t²²))
//│ 	| LH_N  => 0}
//│ def nsoln_₀(_lh_nsoln_arg1¹) = length_₀^726(gen_₀^727(_lh_nsoln_arg1¹, _lh_nsoln_arg1¹))
//│ def safe_₀(_lh_safe_arg1¹, _lh_safe_arg2¹, _lh_safe_arg3¹) = case _lh_safe_arg3¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe_₀^857(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹))
//│ 	| _  => error⁰}
//│ def testQueenBuiltInType_₀(_lh_testQueenBuiltInType_arg1¹) = nsoln_₀^820(_lh_testQueenBuiltInType_arg1¹)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo__d0 a_5 b_2 =
//│ 		  (if (a_5 <= b_2) then
//│ 		    (`LH_C(a_5, ((enumFromTo__d0 (a_5 + 1)) b_2)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and gen__d0 _lh_gen_arg1_1 _lh_gen_arg2_1 =
//│ 		  (match _lh_gen_arg1_1 with
//│ 		    | 0 -> 
//│ 		      (`LH_C((`LH_N), (`LH_N)))
//│ 		    | _ -> 
//│ 		      (let rec _lh_listcomp_fun_2 = (fun _lh_listcomp_fun_para_2 -> 
//│ 		        (match _lh_listcomp_fun_para_2 with
//│ 		          | `LH_C(_lh_listcomp_fun_ls_h_2, _lh_listcomp_fun_ls_t_2) -> 
//│ 		            (let rec _lh_listcomp_fun_3 = (fun _lh_listcomp_fun_para_3 -> 
//│ 		              (match _lh_listcomp_fun_para_3 with
//│ 		                | `LH_C(_lh_listcomp_fun_ls_h_3, _lh_listcomp_fun_ls_t_3) -> 
//│ 		                  (if (((safe__d0 _lh_listcomp_fun_ls_h_3) 1) _lh_listcomp_fun_ls_h_2) then
//│ 		                    (`LH_C((`LH_C(_lh_listcomp_fun_ls_h_3, _lh_listcomp_fun_ls_h_2)), (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3)))
//│ 		                  else
//│ 		                    (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3))
//│ 		                | `LH_N -> 
//│ 		                  (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_2))) in
//│ 		              (_lh_listcomp_fun_3 ((enumFromTo__d0 1) _lh_gen_arg2_1)))
//│ 		          | `LH_N -> 
//│ 		            (`LH_N))) in
//│ 		        (_lh_listcomp_fun_2 ((gen__d0 (_lh_gen_arg1_1 - 1)) _lh_gen_arg2_1))))
//│ 		and length__d0 ls_1_9 =
//│ 		  (match ls_1_9 with
//│ 		    | `LH_C(h_2_0, t_2_2) -> 
//│ 		      (1 + (length__d0 t_2_2))
//│ 		    | `LH_N -> 
//│ 		      0)
//│ 		and nsoln__d0 _lh_nsoln_arg1_1 =
//│ 		  (length__d0 ((gen__d0 _lh_nsoln_arg1_1) _lh_nsoln_arg1_1))
//│ 		and safe__d0 _lh_safe_arg1_1 _lh_safe_arg2_1 _lh_safe_arg3_1 =
//│ 		  (match _lh_safe_arg3_1 with
//│ 		    | `LH_N -> 
//│ 		      true
//│ 		    | `LH_C(_lh_safe_LH_C_0_1, _lh_safe_LH_C_1_1) -> 
//│ 		      ((((_lh_safe_arg1_1 <> _lh_safe_LH_C_0_1) && (_lh_safe_arg1_1 <> (_lh_safe_LH_C_0_1 + _lh_safe_arg2_1))) && (_lh_safe_arg1_1 <> (_lh_safe_LH_C_0_1 - _lh_safe_arg2_1))) && (((safe__d0 _lh_safe_arg1_1) (_lh_safe_arg2_1 + 1)) _lh_safe_LH_C_1_1))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and testQueenBuiltInType__d0 _lh_testQueenBuiltInType_arg1_1 =
//│ 		  (nsoln__d0 _lh_testQueenBuiltInType_arg1_1);;
//│ 		(testQueenBuiltInType__d0 11)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 749 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe_₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 792
//│ [LH_N]: 750 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe_₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 792
//│ [LH_N]: 766 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe_₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰}: 870
//│ [LH_N]: 767 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₀(t²²)) | LH_N  => 0}: 763
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe_₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo_₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 803
//│ [LH_C [LH_N] [LH_N]]: 768 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₀(t²²)) | LH_N  => 0}: 763
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe_₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo_₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 803
//│ [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 780 --->
//│ 	DeadCodeCons
//│ 	case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe_₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰}: 870
//│ [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 784 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₀(t²²)) | LH_N  => 0}: 763
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe_₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo_₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 803
//│ [LH_N]: 802 --->
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₀(t²²)) | LH_N  => 0}: 763
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe_₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo_₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 803
//│ ------------------
//│ case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₀(t²²)) | LH_N  => 0}: 763 --->
//│ 	[LH_N]: 767
//│ 	[LH_C [LH_N] [LH_N]]: 768
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 784
//│ 	[LH_N]: 802
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe_₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 792 --->
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 749
//│ 	[LH_N]: 750
//│ case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe_₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo_₀(1, _lh_gen_arg2¹)) | LH_N  => [LH_N]}: 803 --->
//│ 	[LH_N]: 767
//│ 	[LH_C [LH_N] [LH_N]]: 768
//│ 	[LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 784
//│ 	[LH_N]: 802
//│ case _lh_safe_arg3¹ of {LH_N  => [True] | LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1¹ /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2¹))) && (_lh_safe_arg1¹ /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2¹))) && safe_₀(_lh_safe_arg1¹, (_lh_safe_arg2¹ + 1), _lh_safe_LH_C_1¹)) | _  => error⁰}: 870 --->
//│ 	[LH_N]: 766
//│ 	[LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²]: 780
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 749 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe_₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 792
//│ [LH_N]: 750 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe_₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 792
//│ ------------------
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => if safe_₀(_lh_listcomp_fun_ls_h³, 1, _lh_listcomp_fun_ls_h²) then [LH_C [LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_h²] _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] else _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³) | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 792 --->
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 749
//│ 	[LH_N]: 750
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testQueenBuiltInType_₀(primId⁰(11))
//│ def enumFromTo_₀(a⁶, b³) = if (a⁶ <= b³) then 
//│ 	let _lh_listcomp_fun_ls_t⁴ = enumFromTo_₀((a⁶ + 1), b³)
//│ 	in let _lh_listcomp_fun_ls_h⁴ = a⁶
//│ 	in (fun _lh_listcomp_fun_ls_h⁵ -> (fun _lh_listcomp_fun⁶ -> (fun _lh_listcomp_fun_ls_t⁵ -> (fun _lh_listcomp_fun⁷ -> if safe_₀(_lh_listcomp_fun_ls_h⁴, 1, _lh_listcomp_fun_ls_h⁵) then [LH_C [LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_h⁵] _lh_listcomp_fun⁶(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁶(_lh_listcomp_fun_ls_t⁴))))) else (fun _lh_listcomp_fun_ls_h⁶ -> (fun _lh_listcomp_fun⁸ -> (fun _lh_listcomp_fun_ls_t⁶ -> (fun _lh_listcomp_fun⁹ -> _lh_listcomp_fun⁹(_lh_listcomp_fun_ls_t⁶)))))
//│ def gen_₀(_lh_gen_arg1², _lh_gen_arg2²) = case _lh_gen_arg1² of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {
//│ 			LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 				let _lh_listcomp_fun⁵ = (fun _lh_listcomp_fun_para⁵ -> _lh_listcomp_fun_para⁵(_lh_listcomp_fun_ls_h², _lh_listcomp_fun⁵, _lh_listcomp_fun_ls_t², _lh_listcomp_fun⁴))
//│ 				in _lh_listcomp_fun⁵(enumFromTo_₀(1, _lh_gen_arg2²))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁴(gen_₀((_lh_gen_arg1² - 1), _lh_gen_arg2²))}
//│ def length_₀(ls²⁰) = case ls²⁰ of {
//│ 	LH_C h²⁰ t²² => (1 + length_₀(t²²))
//│ 	| LH_N  => 0}
//│ def nsoln_₀(_lh_nsoln_arg1²) = length_₀(gen_₀(_lh_nsoln_arg1², _lh_nsoln_arg1²))
//│ def safe_₀(_lh_safe_arg1², _lh_safe_arg2², _lh_safe_arg3²) = case _lh_safe_arg3² of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_safe_LH_C_0¹ _lh_safe_LH_C_1¹ => ((((_lh_safe_arg1² /= _lh_safe_LH_C_0¹) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0¹ + _lh_safe_arg2²))) && (_lh_safe_arg1² /= (_lh_safe_LH_C_0¹ - _lh_safe_arg2²))) && safe_₀(_lh_safe_arg1², (_lh_safe_arg2² + 1), _lh_safe_LH_C_1¹))
//│ 	| _  => error⁰}
//│ def testQueenBuiltInType_₀(_lh_testQueenBuiltInType_arg1²) = nsoln_₀(_lh_testQueenBuiltInType_arg1²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun sum(ls) = summ(0, ls)
fun summ(acc, ls) = if ls is
  N then acc
  C(h, t) then summ(acc + h, t)
fun testSumMapEnumSumAcc(n) = sum(map(x => x * x, enumFromTo(1, n)))
testSumMapEnumSumAcc(primId(300000))
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |sum|(|ls|)| |#=| |summ|(|0|,| |ls|)|↵|#fun| |summ|(|acc|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |acc|↵|C|(|h|,| |t|)| |#then| |summ|(|acc| |+| |h|,| |t|)|←|↵|#fun| |testSumMapEnumSumAcc|(|n|)| |#=| |sum|(|map|(|x| |=>| |x| |*| |x|,| |enumFromTo|(|1|,| |n|)|)|)|↵|testSumMapEnumSumAcc|(|primId|(|300000|)|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun sum = ls, => summ (0, ls,); fun summ = acc, ls, => if ls is ‹(N) then acc; (C (h, t,)) then summ (+ (acc,) (h,), t,)›; fun testSumMapEnumSumAcc = n, => sum (map (x, => * (x,) (x,), enumFromTo (1, n,),),); testSumMapEnumSumAcc (primId (300000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumMapEnumSumAcc^72(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^21((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def sum(ls¹) = summ^35(0, ls¹)
//│ def summ(acc⁰, ls²) = case ls² of {
//│ 	N  => acc⁰
//│ 	| C h¹ t¹ => summ^43((acc⁰ + h¹), t¹)}
//│ def testSumMapEnumSumAcc(n⁰) = sum^55(map^56((fun x⁰ -> (x⁰ * x⁰)), enumFromTo^64(1, n⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N))
//│ 		and map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N))
//│ 		and sum ls_1 =
//│ 		  ((summ 0) ls_1)
//│ 		and summ acc_0 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      acc_0
//│ 		    | `C(h_1, t_1) -> 
//│ 		      ((summ (acc_0 + h_1)) t_1))
//│ 		and testSumMapEnumSumAcc n_0 =
//│ 		  (sum ((map (fun x_0 -> 
//│ 		    (x_0 * x_0))) ((enumFromTo 1) n_0)));;
//│ 		(testSumMapEnumSumAcc 300000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testSumMapEnumSumAcc^72] (hopeless to continue)
//│ 	[testSumMapEnumSumAcc^72 · enumFromTo^64] (using original def)
//│ 		[testSumMapEnumSumAcc^72 · enumFromTo^64 · enumFromTo^21] ---> [testSumMapEnumSumAcc^72 · enumFromTo^64] (using original def)
//│ 	[testSumMapEnumSumAcc^72 · map^56] (using original def)
//│ 		[testSumMapEnumSumAcc^72 · map^56 · map^5] ---> [testSumMapEnumSumAcc^72 · map^56] (using original def)
//│ 	[testSumMapEnumSumAcc^72 · sum^55] (using original def)
//│ 		[testSumMapEnumSumAcc^72 · sum^55 · summ^35] (using original def)
//│ 			[testSumMapEnumSumAcc^72 · sum^55 · summ^35 · summ^43] ---> [testSumMapEnumSumAcc^72 · sum^55 · summ^35] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testSumMapEnumSumAcc_₀(primId⁰(300000))
//│ def testSumMapEnumSumAcc_₀(n¹) = 
//│ 	sum_₀(map_₀((fun x¹ -> (x¹ * x¹)), enumFromTo_₀(1, n¹)))
//│ 	where
//│ 	def enumFromTo_₀(a¹, b¹) = 
//│ 		if (a¹ <= b¹) then [C a¹ enumFromTo_₀((a¹ + 1), b¹)] else [N]
//│ 	def map_₀(f¹, ls³) = 
//│ 		case ls³ of {
//│ 			C h² t² => [C f¹(h²) map_₀(f¹, t²)]
//│ 			| N  => [N]}
//│ 	def sum_₀(ls⁵) = 
//│ 		summ_₀(0, ls⁵)
//│ 		where
//│ 		def summ_₀(acc¹, ls⁴) = 
//│ 			case ls⁴ of {
//│ 				N  => acc¹
//│ 				| C h³ t³ => summ_₀((acc¹ + h³), t³)}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C a¹ enumFromTo_₀((a¹ + 1), b¹)]: 92 --->
//│ 	case ls³ of {C h² t² => [C f¹(h²) map_₀(f¹, t²)] | N  => [N]}: 108
//│ [N]: 93 --->
//│ 	case ls³ of {C h² t² => [C f¹(h²) map_₀(f¹, t²)] | N  => [N]}: 108
//│ [C f¹(h²) map_₀(f¹, t²)]: 106 --->
//│ 	case ls⁴ of {N  => acc¹ | C h³ t³ => summ_₀((acc¹ + h³), t³)}: 122
//│ [N]: 107 --->
//│ 	case ls⁴ of {N  => acc¹ | C h³ t³ => summ_₀((acc¹ + h³), t³)}: 122
//│ ------------------
//│ case ls³ of {C h² t² => [C f¹(h²) map_₀(f¹, t²)] | N  => [N]}: 108 --->
//│ 	[C a¹ enumFromTo_₀((a¹ + 1), b¹)]: 92
//│ 	[N]: 93
//│ case ls⁴ of {N  => acc¹ | C h³ t³ => summ_₀((acc¹ + h³), t³)}: 122 --->
//│ 	[C f¹(h²) map_₀(f¹, t²)]: 106
//│ 	[N]: 107
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C a¹ enumFromTo_₀((a¹ + 1), b¹)]: 92 --->
//│ 	case ls³ of {C h² t² => [C f¹(h²) map_₀(f¹, t²)] | N  => [N]}: 108
//│ [N]: 93 --->
//│ 	case ls³ of {C h² t² => [C f¹(h²) map_₀(f¹, t²)] | N  => [N]}: 108
//│ [C f¹(h²) map_₀(f¹, t²)]: 106 --->
//│ 	case ls⁴ of {N  => acc¹ | C h³ t³ => summ_₀((acc¹ + h³), t³)}: 122
//│ [N]: 107 --->
//│ 	case ls⁴ of {N  => acc¹ | C h³ t³ => summ_₀((acc¹ + h³), t³)}: 122
//│ ------------------
//│ case ls³ of {C h² t² => [C f¹(h²) map_₀(f¹, t²)] | N  => [N]}: 108 --->
//│ 	[C a¹ enumFromTo_₀((a¹ + 1), b¹)]: 92
//│ 	[N]: 93
//│ case ls⁴ of {N  => acc¹ | C h³ t³ => summ_₀((acc¹ + h³), t³)}: 122 --->
//│ 	[C f¹(h²) map_₀(f¹, t²)]: 106
//│ 	[N]: 107
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumMapEnumSumAcc_₀(primId⁰(300000))
//│ def testSumMapEnumSumAcc_₀(n²) = 
//│ 	sum_₀(map_₀((fun x² -> (x² * x²)), enumFromTo_₀(1, n²)))
//│ 	where
//│ 	def enumFromTo_₀(a², b²) = 
//│ 		if (a² <= b²) then 
//│ 			let t⁴ = enumFromTo_₀((a² + 1), b²)
//│ 			in let h⁴ = a²
//│ 			in (fun f³ -> 
//│ 				let t⁵ = map_₀(f³, t⁴)
//│ 				in let h⁵ = f³(h⁴)
//│ 				in (fun acc² -> summ_₀((acc² + h⁵), t⁵))) else (fun f⁴ -> (fun acc³ -> acc³))
//│ 	def map_₀(f², ls⁶) = 
//│ 		ls⁶(f²)
//│ 	def sum_₀(ls⁷) = 
//│ 		summ_₀(0, ls⁷)
//│ 		where
//│ 		def summ_₀(acc⁴, ls⁸) = 
//│ 			ls⁸(acc⁴)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun sum(ls) = if ls is
  C(h, t) then h + sum(t)
  N then 0
fun testSumMapEnum(n) = sum(map(x => x * x, enumFromTo(1, n)))
testSumMapEnum(primId(300000))
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |sum|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |h| |+| |sum|(|t|)|↵|N| |#then| |0|←|↵|#fun| |testSumMapEnum|(|n|)| |#=| |sum|(|map|(|x| |=>| |x| |*| |x|,| |enumFromTo|(|1|,| |n|)|)|)|↵|testSumMapEnum|(|primId|(|300000|)|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun sum = ls, => if ls is ‹(C (h, t,)) then + (h,) (sum (t,),); (N) then 0›; fun testSumMapEnum = n, => sum (map (x, => * (x,) (x,), enumFromTo (1, n,),),); testSumMapEnum (primId (300000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumMapEnum^63(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^21((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def sum(ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => (h¹ + sum^39(t¹))
//│ 	| N  => 0}
//│ def testSumMapEnum(n⁰) = sum^46(map^47((fun x⁰ -> (x⁰ * x⁰)), enumFromTo^55(1, n⁰)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N))
//│ 		and map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N))
//│ 		and sum ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (h_1 + (sum t_1))
//│ 		    | `N -> 
//│ 		      0)
//│ 		and testSumMapEnum n_0 =
//│ 		  (sum ((map (fun x_0 -> 
//│ 		    (x_0 * x_0))) ((enumFromTo 1) n_0)));;
//│ 		(testSumMapEnum 300000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testSumMapEnum^63] (hopeless to continue)
//│ 	[testSumMapEnum^63 · enumFromTo^55] (using original def)
//│ 		[testSumMapEnum^63 · enumFromTo^55 · enumFromTo^21] ---> [testSumMapEnum^63 · enumFromTo^55] (using original def)
//│ 	[testSumMapEnum^63 · map^47] (using original def)
//│ 		[testSumMapEnum^63 · map^47 · map^5] ---> [testSumMapEnum^63 · map^47] (using original def)
//│ 	[testSumMapEnum^63 · sum^46] (using original def)
//│ 		[testSumMapEnum^63 · sum^46 · sum^39] ---> [testSumMapEnum^63 · sum^46] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testSumMapEnum_₀(primId⁰(300000))
//│ def testSumMapEnum_₀(n¹) = 
//│ 	sum_₀(map_₀((fun x¹ -> (x¹ * x¹)), enumFromTo_₀(1, n¹)))
//│ 	where
//│ 	def enumFromTo_₀(a¹, b¹) = 
//│ 		if (a¹ <= b¹) then [C a¹ enumFromTo_₀((a¹ + 1), b¹)] else [N]
//│ 	def map_₀(f¹, ls²) = 
//│ 		case ls² of {
//│ 			C h² t² => [C f¹(h²) map_₀(f¹, t²)]
//│ 			| N  => [N]}
//│ 	def sum_₀(ls³) = 
//│ 		case ls³ of {
//│ 			C h³ t³ => (h³ + sum_₀(t³))
//│ 			| N  => 0}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f¹(h²) map_₀(f¹, t²)]: 94 --->
//│ 	case ls³ of {C h³ t³ => (h³ + sum_₀(t³)) | N  => 0}: 128
//│ [N]: 95 --->
//│ 	case ls³ of {C h³ t³ => (h³ + sum_₀(t³)) | N  => 0}: 128
//│ [C a¹ enumFromTo_₀((a¹ + 1), b¹)]: 114 --->
//│ 	case ls² of {C h² t² => [C f¹(h²) map_₀(f¹, t²)] | N  => [N]}: 96
//│ [N]: 115 --->
//│ 	case ls² of {C h² t² => [C f¹(h²) map_₀(f¹, t²)] | N  => [N]}: 96
//│ ------------------
//│ case ls² of {C h² t² => [C f¹(h²) map_₀(f¹, t²)] | N  => [N]}: 96 --->
//│ 	[C a¹ enumFromTo_₀((a¹ + 1), b¹)]: 114
//│ 	[N]: 115
//│ case ls³ of {C h³ t³ => (h³ + sum_₀(t³)) | N  => 0}: 128 --->
//│ 	[C f¹(h²) map_₀(f¹, t²)]: 94
//│ 	[N]: 95
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f¹(h²) map_₀(f¹, t²)]: 94 --->
//│ 	case ls³ of {C h³ t³ => (h³ + sum_₀(t³)) | N  => 0}: 128
//│ [N]: 95 --->
//│ 	case ls³ of {C h³ t³ => (h³ + sum_₀(t³)) | N  => 0}: 128
//│ [C a¹ enumFromTo_₀((a¹ + 1), b¹)]: 114 --->
//│ 	case ls² of {C h² t² => [C f¹(h²) map_₀(f¹, t²)] | N  => [N]}: 96
//│ [N]: 115 --->
//│ 	case ls² of {C h² t² => [C f¹(h²) map_₀(f¹, t²)] | N  => [N]}: 96
//│ ------------------
//│ case ls² of {C h² t² => [C f¹(h²) map_₀(f¹, t²)] | N  => [N]}: 96 --->
//│ 	[C a¹ enumFromTo_₀((a¹ + 1), b¹)]: 114
//│ 	[N]: 115
//│ case ls³ of {C h³ t³ => (h³ + sum_₀(t³)) | N  => 0}: 128 --->
//│ 	[C f¹(h²) map_₀(f¹, t²)]: 94
//│ 	[N]: 95
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumMapEnum_₀(primId⁰(300000))
//│ def testSumMapEnum_₀(n²) = 
//│ 	sum_₀(map_₀((fun x² -> (x² * x²)), enumFromTo_₀(1, n²)))
//│ 	where
//│ 	def enumFromTo_₀(a², b²) = 
//│ 		if (a² <= b²) then 
//│ 			let t⁴ = enumFromTo_₀((a² + 1), b²)
//│ 			in let h⁴ = a²
//│ 			in (fun f³ -> 
//│ 				let t⁵ = map_₀(f³, t⁴)
//│ 				in let h⁵ = f³(h⁴)
//│ 				in (fun _lh_dummy⁰ -> (h⁵ + sum_₀(t⁵)))) else (fun f⁴ -> (fun _lh_dummy¹ -> 0))
//│ 	def map_₀(f², ls⁴) = 
//│ 		ls⁴(f²)
//│ 	def sum_₀(ls⁵) = 
//│ 		ls⁵(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
:lhInHaskell
and [] = True
and (h:t) = if h then and t else False
append [] ys = ys
append (h:t) ys = h:(append t ys)
queens 0 = [[]]
queens m = [ append p [n] | p <- queens (m - 1), n <- [1 .. 9], safe p n]
safe p n = let m = (length p) + 1 in (and [ (j /= n) && ((i + j) /= (m + n)) && ((i - j) /= (m - n)) | (i, j) <- zip [1..(m - 1)] p ])
testAnotherQueenNineBuiltInType n = length $ queens n
testAnotherQueenNineBuiltInType $ primId 9
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testAnotherQueenNineBuiltInType_₀^1012(primId⁰(9))
//│ def and_₀(_lh_and_arg1¹) = case _lh_and_arg1¹ of {
//│ 	LH_N  => [True]
//│ 	| LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and_₀^780(_lh_and_LH_C_1¹) else [False]
//│ 	| _  => error⁰}
//│ def append_₀(_lh_append_arg1¹, _lh_append_arg2¹) = case _lh_append_arg1¹ of {
//│ 	LH_N  => _lh_append_arg2¹
//│ 	| LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₀^791(_lh_append_LH_C_1¹, _lh_append_arg2¹)]
//│ 	| _  => error⁰}
//│ def enumFromTo_₀(a⁵, b²) = if (a⁵ <= b²) then [LH_C a⁵ enumFromTo_₀^967((a⁵ + 1), b²)] else [LH_N]
//│ def enumFromTo_₁(a⁶, b³) = if (a⁶ <= b³) then [LH_C a⁶ enumFromTo_₁^998((a⁶ + 1), b³)] else [LH_N]
//│ def length_₀(ls²⁰) = case ls²⁰ of {
//│ 	LH_C h²¹ t²³ => (1 + length_₀^985(t²³))
//│ 	| LH_N  => 0}
//│ def length_₁(ls¹⁹) = case ls¹⁹ of {
//│ 	LH_C h²⁰ t²² => (1 + length_₁^954(t²²))
//│ 	| LH_N  => 0}
//│ def queens_₀(_lh_queens_arg1¹) = case _lh_queens_arg1¹ of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 			LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => 
//│ 				let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {
//│ 					LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe_₀^807(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append_₀^812(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)
//│ 					| LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)})
//│ 				in _lh_listcomp_fun⁴(enumFromTo_₀^833(1, 9))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun³(queens_₀^844((_lh_queens_arg1¹ - 1)))}
//│ def safe_₀(_lh_safe_arg1¹, _lh_safe_arg2¹) = 
//│ 	let m¹ = (length_₁^873(_lh_safe_arg1¹) + 1)
//│ 	in and_₀^879(
//│ 		let _lh_listcomp_fun⁵ = (fun _lh_listcomp_fun_para⁵ -> case _lh_listcomp_fun_para⁵ of {
//│ 			LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {
//│ 				LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)]
//│ 				| _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)}
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun⁵(zip_₀^931(enumFromTo_₁^932(1, (m¹ - 1)), _lh_safe_arg1¹)))
//│ def testAnotherQueenNineBuiltInType_₀(_lh_testAnotherQueenNineBuiltInType_arg1¹) = length_₀^771(queens_₀^772(_lh_testAnotherQueenNineBuiltInType_arg1¹))
//│ def zip_₀(xs⁹, ys⁹) = case xs⁹ of {
//│ 	LH_C hx⁸ tx⁸ => case ys⁹ of {
//│ 		LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀^860(tx⁸, ty⁸)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec and__d0 _lh_and_arg1_1 =
//│ 		  (match _lh_and_arg1_1 with
//│ 		    | `LH_N -> 
//│ 		      true
//│ 		    | `LH_C(_lh_and_LH_C_0_1, _lh_and_LH_C_1_1) -> 
//│ 		      (if _lh_and_LH_C_0_1 then
//│ 		        (and__d0 _lh_and_LH_C_1_1)
//│ 		      else
//│ 		        false)
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and append__d0 _lh_append_arg1_1 _lh_append_arg2_1 =
//│ 		  (match _lh_append_arg1_1 with
//│ 		    | `LH_N -> 
//│ 		      _lh_append_arg2_1
//│ 		    | `LH_C(_lh_append_LH_C_0_1, _lh_append_LH_C_1_1) -> 
//│ 		      (`LH_C(_lh_append_LH_C_0_1, ((append__d0 _lh_append_LH_C_1_1) _lh_append_arg2_1)))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and enumFromTo__d0 a_5 b_2 =
//│ 		  (if (a_5 <= b_2) then
//│ 		    (`LH_C(a_5, ((enumFromTo__d0 (a_5 + 1)) b_2)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and enumFromTo__d1 a_6 b_3 =
//│ 		  (if (a_6 <= b_3) then
//│ 		    (`LH_C(a_6, ((enumFromTo__d1 (a_6 + 1)) b_3)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and length__d0 ls_2_0 =
//│ 		  (match ls_2_0 with
//│ 		    | `LH_C(h_2_1, t_2_3) -> 
//│ 		      (1 + (length__d0 t_2_3))
//│ 		    | `LH_N -> 
//│ 		      0)
//│ 		and length__d1 ls_1_9 =
//│ 		  (match ls_1_9 with
//│ 		    | `LH_C(h_2_0, t_2_2) -> 
//│ 		      (1 + (length__d1 t_2_2))
//│ 		    | `LH_N -> 
//│ 		      0)
//│ 		and queens__d0 _lh_queens_arg1_1 =
//│ 		  (match _lh_queens_arg1_1 with
//│ 		    | 0 -> 
//│ 		      (`LH_C((`LH_N), (`LH_N)))
//│ 		    | _ -> 
//│ 		      (let rec _lh_listcomp_fun_3 = (fun _lh_listcomp_fun_para_3 -> 
//│ 		        (match _lh_listcomp_fun_para_3 with
//│ 		          | `LH_C(_lh_listcomp_fun_ls_h_3, _lh_listcomp_fun_ls_t_3) -> 
//│ 		            (let rec _lh_listcomp_fun_4 = (fun _lh_listcomp_fun_para_4 -> 
//│ 		              (match _lh_listcomp_fun_para_4 with
//│ 		                | `LH_C(_lh_listcomp_fun_ls_h_4, _lh_listcomp_fun_ls_t_4) -> 
//│ 		                  (if ((safe__d0 _lh_listcomp_fun_ls_h_3) _lh_listcomp_fun_ls_h_4) then
//│ 		                    (`LH_C(((append__d0 _lh_listcomp_fun_ls_h_3) (`LH_C(_lh_listcomp_fun_ls_h_4, (`LH_N)))), (_lh_listcomp_fun_4 _lh_listcomp_fun_ls_t_4)))
//│ 		                  else
//│ 		                    (_lh_listcomp_fun_4 _lh_listcomp_fun_ls_t_4))
//│ 		                | `LH_N -> 
//│ 		                  (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3))) in
//│ 		              (_lh_listcomp_fun_4 ((enumFromTo__d0 1) 9)))
//│ 		          | `LH_N -> 
//│ 		            (`LH_N))) in
//│ 		        (_lh_listcomp_fun_3 (queens__d0 (_lh_queens_arg1_1 - 1)))))
//│ 		and safe__d0 _lh_safe_arg1_1 _lh_safe_arg2_1 =
//│ 		  (let rec m_1 = ((length__d1 _lh_safe_arg1_1) + 1) in
//│ 		    (and__d0 (let rec _lh_listcomp_fun_5 = (fun _lh_listcomp_fun_para_5 -> 
//│ 		      (match _lh_listcomp_fun_para_5 with
//│ 		        | `LH_C(_lh_listcomp_fun_ls_h_5, _lh_listcomp_fun_ls_t_5) -> 
//│ 		          (match _lh_listcomp_fun_ls_h_5 with
//│ 		            | `LH_P2(_lh_safe_LH_P2_0_1, _lh_safe_LH_P2_1_1) -> 
//│ 		              (`LH_C((((_lh_safe_LH_P2_1_1 <> _lh_safe_arg2_1) && ((_lh_safe_LH_P2_0_1 + _lh_safe_LH_P2_1_1) <> (m_1 + _lh_safe_arg2_1))) && ((_lh_safe_LH_P2_0_1 - _lh_safe_LH_P2_1_1) <> (m_1 - _lh_safe_arg2_1))), (_lh_listcomp_fun_5 _lh_listcomp_fun_ls_t_5)))
//│ 		            | _ -> 
//│ 		              (_lh_listcomp_fun_5 _lh_listcomp_fun_ls_t_5))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))) in
//│ 		      (_lh_listcomp_fun_5 ((zip__d0 ((enumFromTo__d1 1) (m_1 - 1))) _lh_safe_arg1_1)))))
//│ 		and testAnotherQueenNineBuiltInType__d0 _lh_testAnotherQueenNineBuiltInType_arg1_1 =
//│ 		  (length__d0 (queens__d0 _lh_testAnotherQueenNineBuiltInType_arg1_1))
//│ 		and zip__d0 xs_9 ys_9 =
//│ 		  (match xs_9 with
//│ 		    | `LH_C(hx_8, tx_8) -> 
//│ 		      (match ys_9 with
//│ 		        | `LH_C(hy_8, ty_8) -> 
//│ 		          (`LH_C((`LH_P2(hx_8, hy_8)), ((zip__d0 tx_8) ty_8)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		(testAnotherQueenNineBuiltInType__d0 9)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C _lh_append_LH_C_0¹ append_₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 796 --->
//│ 	DeadCodeCons
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 798
//│ 	case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]}: 867
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₁(t²²)) | LH_N  => 0}: 959
//│ [LH_N]: 802 --->
//│ 	DeadCodeCons
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 798
//│ 	case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]}: 867
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₁(t²²)) | LH_N  => 0}: 959
//│ [LH_N]: 803 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe_₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append_₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)})
//│ in _lh_listcomp_fun⁴(enumFromTo_₀(1, 9)) | LH_N  => [LH_N]}: 841
//│ 	case ls²⁰ of {LH_C h²¹ t²³ => (1 + length_₀(t²³)) | LH_N  => 0}: 990
//│ [LH_C [LH_N] [LH_N]]: 804 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe_₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append_₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)})
//│ in _lh_listcomp_fun⁴(enumFromTo_₀(1, 9)) | LH_N  => [LH_N]}: 841
//│ 	case ls²⁰ of {LH_C h²¹ t²³ => (1 + length_₀(t²³)) | LH_N  => 0}: 990
//│ [LH_N]: 816 --->
//│ 	DeadCodeCons
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 798
//│ 	case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]}: 867
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₁(t²²)) | LH_N  => 0}: 959
//│ [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]: 817 --->
//│ 	DeadCodeCons
//│ 	case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 798
//│ 	case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]}: 867
//│ 	case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₁(t²²)) | LH_N  => 0}: 959
//│ [LH_C append_₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)]: 822 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe_₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append_₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)})
//│ in _lh_listcomp_fun⁴(enumFromTo_₀(1, 9)) | LH_N  => [LH_N]}: 841
//│ 	case ls²⁰ of {LH_C h²¹ t²³ => (1 + length_₀(t²³)) | LH_N  => 0}: 990
//│ [LH_N]: 840 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe_₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append_₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)})
//│ in _lh_listcomp_fun⁴(enumFromTo_₀(1, 9)) | LH_N  => [LH_N]}: 841
//│ 	case ls²⁰ of {LH_C h²¹ t²³ => (1 + length_₀(t²³)) | LH_N  => 0}: 990
//│ [LH_P2 hx⁸ hy⁸]: 859 --->
//│ 	case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)}: 926
//│ [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)]: 865 --->
//│ 	case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 928
//│ [LH_N]: 866 --->
//│ 	case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 928
//│ [LH_N]: 868 --->
//│ 	case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 928
//│ [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)]: 922 --->
//│ 	case _lh_and_arg1¹ of {LH_N  => [True] | LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and_₀(_lh_and_LH_C_1¹) else [False] | _  => error⁰}: 786
//│ [LH_N]: 927 --->
//│ 	case _lh_and_arg1¹ of {LH_N  => [True] | LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and_₀(_lh_and_LH_C_1¹) else [False] | _  => error⁰}: 786
//│ [LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 976 --->
//│ 	case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe_₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append_₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)}: 830
//│ [LH_N]: 977 --->
//│ 	case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe_₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append_₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)}: 830
//│ [LH_C a⁶ enumFromTo_₁((a⁶ + 1), b³)]: 1007 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 869
//│ [LH_N]: 1008 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 869
//│ ------------------
//│ case _lh_and_arg1¹ of {LH_N  => [True] | LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and_₀(_lh_and_LH_C_1¹) else [False] | _  => error⁰}: 786 --->
//│ 	[LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)]: 922
//│ 	[LH_N]: 927
//│ case _lh_append_arg1¹ of {LH_N  => _lh_append_arg2¹ | LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)] | _  => error⁰}: 798 --->
//│ 	[LH_C _lh_append_LH_C_0¹ append_₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 796
//│ 	[LH_N]: 802
//│ 	[LH_N]: 816
//│ 	[LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]: 817
//│ case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe_₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append_₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)}: 830 --->
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 976
//│ 	[LH_N]: 977
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe_₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append_₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)})
//│ in _lh_listcomp_fun⁴(enumFromTo_₀(1, 9)) | LH_N  => [LH_N]}: 841 --->
//│ 	[LH_N]: 803
//│ 	[LH_C [LH_N] [LH_N]]: 804
//│ 	[LH_C append_₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)]: 822
//│ 	[LH_N]: 840
//│ case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]}: 867 --->
//│ 	[LH_C _lh_append_LH_C_0¹ append_₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 796
//│ 	[LH_N]: 802
//│ 	[LH_N]: 816
//│ 	[LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]: 817
//│ case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 869 --->
//│ 	[LH_C a⁶ enumFromTo_₁((a⁶ + 1), b³)]: 1007
//│ 	[LH_N]: 1008
//│ case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)}: 926 --->
//│ 	[LH_P2 hx⁸ hy⁸]: 859
//│ case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 928 --->
//│ 	[LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)]: 865
//│ 	[LH_N]: 866
//│ 	[LH_N]: 868
//│ case ls¹⁹ of {LH_C h²⁰ t²² => (1 + length_₁(t²²)) | LH_N  => 0}: 959 --->
//│ 	[LH_C _lh_append_LH_C_0¹ append_₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 796
//│ 	[LH_N]: 802
//│ 	[LH_N]: 816
//│ 	[LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]: 817
//│ case ls²⁰ of {LH_C h²¹ t²³ => (1 + length_₀(t²³)) | LH_N  => 0}: 990 --->
//│ 	[LH_N]: 803
//│ 	[LH_C [LH_N] [LH_N]]: 804
//│ 	[LH_C append_₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)]: 822
//│ 	[LH_N]: 840
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_P2 hx⁸ hy⁸]: 859 --->
//│ 	case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)}: 926
//│ [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)]: 865 --->
//│ 	case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 928
//│ [LH_N]: 866 --->
//│ 	case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 928
//│ [LH_N]: 868 --->
//│ 	case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 928
//│ [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)]: 922 --->
//│ 	case _lh_and_arg1¹ of {LH_N  => [True] | LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and_₀(_lh_and_LH_C_1¹) else [False] | _  => error⁰}: 786
//│ [LH_N]: 927 --->
//│ 	case _lh_and_arg1¹ of {LH_N  => [True] | LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and_₀(_lh_and_LH_C_1¹) else [False] | _  => error⁰}: 786
//│ [LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 976 --->
//│ 	case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe_₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append_₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)}: 830
//│ [LH_N]: 977 --->
//│ 	case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe_₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append_₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)}: 830
//│ [LH_C a⁶ enumFromTo_₁((a⁶ + 1), b³)]: 1007 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 869
//│ [LH_N]: 1008 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 869
//│ ------------------
//│ case _lh_and_arg1¹ of {LH_N  => [True] | LH_C _lh_and_LH_C_0¹ _lh_and_LH_C_1¹ => if _lh_and_LH_C_0¹ then and_₀(_lh_and_LH_C_1¹) else [False] | _  => error⁰}: 786 --->
//│ 	[LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)]: 922
//│ 	[LH_N]: 927
//│ case _lh_listcomp_fun_para⁴ of {LH_C _lh_listcomp_fun_ls_h⁴ _lh_listcomp_fun_ls_t⁴ => if safe_₀(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun_ls_h⁴) then [LH_C append_₀(_lh_listcomp_fun_ls_h³, [LH_C _lh_listcomp_fun_ls_h⁴ [LH_N]]) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴)] else _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t⁴) | LH_N  => _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)}: 830 --->
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 976
//│ 	[LH_N]: 977
//│ case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 869 --->
//│ 	[LH_C a⁶ enumFromTo_₁((a⁶ + 1), b³)]: 1007
//│ 	[LH_N]: 1008
//│ case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)}: 926 --->
//│ 	[LH_P2 hx⁸ hy⁸]: 859
//│ case _lh_listcomp_fun_para⁵ of {LH_C _lh_listcomp_fun_ls_h⁵ _lh_listcomp_fun_ls_t⁵ => case _lh_listcomp_fun_ls_h⁵ of {LH_P2 _lh_safe_LH_P2_0¹ _lh_safe_LH_P2_1¹ => [LH_C (((_lh_safe_LH_P2_1¹ /= _lh_safe_arg2¹) && ((_lh_safe_LH_P2_0¹ + _lh_safe_LH_P2_1¹) /= (m¹ + _lh_safe_arg2¹))) && ((_lh_safe_LH_P2_0¹ - _lh_safe_LH_P2_1¹) /= (m¹ - _lh_safe_arg2¹))) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)] | _  => _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t⁵)} | LH_N  => [LH_N]}: 928 --->
//│ 	[LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)]: 865
//│ 	[LH_N]: 866
//│ 	[LH_N]: 868
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testAnotherQueenNineBuiltInType_₀(primId⁰(9))
//│ def and_₀(_lh_and_arg1²) = _lh_and_arg1²(99)
//│ def append_₀(_lh_append_arg1², _lh_append_arg2²) = case _lh_append_arg1² of {
//│ 	LH_N  => _lh_append_arg2²
//│ 	| LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₀(_lh_append_LH_C_1¹, _lh_append_arg2²)]
//│ 	| _  => error⁰}
//│ def enumFromTo_₀(a⁸, b⁵) = if (a⁸ <= b⁵) then 
//│ 	let _lh_listcomp_fun_ls_t⁸ = enumFromTo_₀((a⁸ + 1), b⁵)
//│ 	in let _lh_listcomp_fun_ls_h⁷ = a⁸
//│ 	in (fun _lh_listcomp_fun_ls_h⁸ -> (fun _lh_listcomp_fun¹⁰ -> (fun _lh_listcomp_fun_ls_t⁹ -> (fun _lh_listcomp_fun¹¹ -> if safe_₀(_lh_listcomp_fun_ls_h⁸, _lh_listcomp_fun_ls_h⁷) then [LH_C append_₀(_lh_listcomp_fun_ls_h⁸, [LH_C _lh_listcomp_fun_ls_h⁷ [LH_N]]) _lh_listcomp_fun¹⁰(_lh_listcomp_fun_ls_t⁸)] else _lh_listcomp_fun¹⁰(_lh_listcomp_fun_ls_t⁸))))) else (fun _lh_listcomp_fun_ls_h⁹ -> (fun _lh_listcomp_fun¹² -> (fun _lh_listcomp_fun_ls_t¹⁰ -> (fun _lh_listcomp_fun¹³ -> _lh_listcomp_fun¹³(_lh_listcomp_fun_ls_t¹⁰)))))
//│ def enumFromTo_₁(a⁷, b⁴) = if (a⁷ <= b⁴) then 
//│ 	let tx⁹ = enumFromTo_₁((a⁷ + 1), b⁴)
//│ 	in let hx⁹ = a⁷
//│ 	in (fun ys¹¹ -> case ys¹¹ of {
//│ 		LH_C hy⁸ ty⁸ => 
//│ 			let _lh_listcomp_fun_ls_t⁶ = zip_₀(tx⁹, ty⁸)
//│ 			in let _lh_listcomp_fun_ls_h⁶ = 	
//│ 				let _lh_safe_LH_P2_1² = hy⁸
//│ 				in let _lh_safe_LH_P2_0² = hx⁹
//│ 				in (fun _lh_listcomp_fun_ls_t⁷ -> (fun _lh_listcomp_fun⁷ -> (fun _lh_safe_arg2³ -> (fun m³ -> 
//│ 					let _lh_and_LH_C_1² = _lh_listcomp_fun⁷(_lh_listcomp_fun_ls_t⁷)
//│ 					in let _lh_and_LH_C_0² = (((_lh_safe_LH_P2_1² /= _lh_safe_arg2³) && ((_lh_safe_LH_P2_0² + _lh_safe_LH_P2_1²) /= (m³ + _lh_safe_arg2³))) && ((_lh_safe_LH_P2_0² - _lh_safe_LH_P2_1²) /= (m³ - _lh_safe_arg2³)))
//│ 					in (fun _lh_dummy⁰ -> if _lh_and_LH_C_0² then and_₀(_lh_and_LH_C_1²) else [False])))))
//│ 			in (fun _lh_listcomp_fun⁶ -> (fun _lh_safe_arg2² -> (fun m² -> _lh_listcomp_fun_ls_h⁶(_lh_listcomp_fun_ls_t⁶, _lh_listcomp_fun⁶, _lh_safe_arg2², m²))))
//│ 		| LH_N  => (fun _lh_listcomp_fun⁸ -> (fun _lh_safe_arg2⁴ -> (fun m⁴ -> (fun _lh_dummy¹ -> [True]))))}) else (fun ys¹² -> (fun _lh_listcomp_fun⁹ -> (fun _lh_safe_arg2⁵ -> (fun m⁵ -> (fun _lh_dummy² -> [True])))))
//│ def length_₀(ls²²) = case ls²² of {
//│ 	LH_C h²¹ t²³ => (1 + length_₀(t²³))
//│ 	| LH_N  => 0}
//│ def length_₁(ls²¹) = case ls²¹ of {
//│ 	LH_C h²⁰ t²² => (1 + length_₁(t²²))
//│ 	| LH_N  => 0}
//│ def queens_₀(_lh_queens_arg1²) = case _lh_queens_arg1² of {
//│ 	0  => [LH_C [LH_N] [LH_N]]
//│ 	| _  => 
//│ 		let _lh_listcomp_fun¹⁴ = (fun _lh_listcomp_fun_para⁶ -> case _lh_listcomp_fun_para⁶ of {
//│ 			LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => 
//│ 				let _lh_listcomp_fun¹⁵ = (fun _lh_listcomp_fun_para⁷ -> _lh_listcomp_fun_para⁷(_lh_listcomp_fun_ls_h³, _lh_listcomp_fun¹⁵, _lh_listcomp_fun_ls_t³, _lh_listcomp_fun¹⁴))
//│ 				in _lh_listcomp_fun¹⁵(enumFromTo_₀(1, 9))
//│ 			| LH_N  => [LH_N]})
//│ 		in _lh_listcomp_fun¹⁴(queens_₀((_lh_queens_arg1² - 1)))}
//│ def safe_₀(_lh_safe_arg1², _lh_safe_arg2⁶) = 
//│ 	let m⁶ = (length_₁(_lh_safe_arg1²) + 1)
//│ 	in and_₀(
//│ 		let _lh_listcomp_fun¹⁶ = (fun _lh_listcomp_fun_para⁸ -> _lh_listcomp_fun_para⁸(_lh_listcomp_fun¹⁶, _lh_safe_arg2⁶, m⁶))
//│ 		in _lh_listcomp_fun¹⁶(zip_₀(enumFromTo_₁(1, (m⁶ - 1)), _lh_safe_arg1²)))
//│ def testAnotherQueenNineBuiltInType_₀(_lh_testAnotherQueenNineBuiltInType_arg1²) = length_₀(queens_₀(_lh_testAnotherQueenNineBuiltInType_arg1²))
//│ def zip_₀(xs¹⁰, ys¹⁰) = xs¹⁰(ys¹⁰)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<



:lhInHaskell
:lhGenOCaml
sum [] = 0
sum (h:t) = h + (sum t)
testSumMapEnumBuiltInType n = sum $ map (\x -> x * x) (enumFromTo 1 n)
testSumMapEnumBuiltInType $ primId 300000
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumMapEnumBuiltInType_₀^690(primId⁰(300000))
//│ def enumFromTo_₀(a⁵, b²) = if (a⁵ <= b²) then [LH_C a⁵ enumFromTo_₀^662((a⁵ + 1), b²)] else [LH_N]
//│ def map_₀(f¹², ls¹⁸) = case ls¹⁸ of {
//│ 	LH_C h¹⁹ t²¹ => [LH_C f¹²(h¹⁹) map_₀^680(f¹², t²¹)]
//│ 	| LH_N  => [LH_N]}
//│ def sum_₀(_lh_sum_arg1¹) = case _lh_sum_arg1¹ of {
//│ 	LH_N  => 0
//│ 	| LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum_₀^632(_lh_sum_LH_C_1¹))
//│ 	| _  => error⁰}
//│ def testSumMapEnumBuiltInType_₀(_lh_testSumMapEnumBuiltInType_arg1¹) = sum_₀^639(map_₀^640((fun x³ -> (x³ * x³)), enumFromTo_₀^648(1, _lh_testSumMapEnumBuiltInType_arg1¹)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo__d0 a_5 b_2 =
//│ 		  (if (a_5 <= b_2) then
//│ 		    (`LH_C(a_5, ((enumFromTo__d0 (a_5 + 1)) b_2)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and map__d0 f_1_2 ls_1_8 =
//│ 		  (match ls_1_8 with
//│ 		    | `LH_C(h_1_9, t_2_1) -> 
//│ 		      (`LH_C((f_1_2 h_1_9), ((map__d0 f_1_2) t_2_1)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))
//│ 		and sum__d0 _lh_sum_arg1_1 =
//│ 		  (match _lh_sum_arg1_1 with
//│ 		    | `LH_N -> 
//│ 		      0
//│ 		    | `LH_C(_lh_sum_LH_C_0_1, _lh_sum_LH_C_1_1) -> 
//│ 		      (_lh_sum_LH_C_0_1 + (sum__d0 _lh_sum_LH_C_1_1))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and testSumMapEnumBuiltInType__d0 _lh_testSumMapEnumBuiltInType_arg1_1 =
//│ 		  (sum__d0 ((map__d0 (fun x_3 -> 
//│ 		    (x_3 * x_3))) ((enumFromTo__d0 1) _lh_testSumMapEnumBuiltInType_arg1_1)));;
//│ 		(testSumMapEnumBuiltInType__d0 300000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 671 --->
//│ 	case ls¹⁸ of {LH_C h¹⁹ t²¹ => [LH_C f¹²(h¹⁹) map_₀(f¹², t²¹)] | LH_N  => [LH_N]}: 687
//│ [LH_N]: 672 --->
//│ 	case ls¹⁸ of {LH_C h¹⁹ t²¹ => [LH_C f¹²(h¹⁹) map_₀(f¹², t²¹)] | LH_N  => [LH_N]}: 687
//│ [LH_C f¹²(h¹⁹) map_₀(f¹², t²¹)]: 685 --->
//│ 	case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum_₀(_lh_sum_LH_C_1¹)) | _  => error⁰}: 637
//│ [LH_N]: 686 --->
//│ 	case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum_₀(_lh_sum_LH_C_1¹)) | _  => error⁰}: 637
//│ ------------------
//│ case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum_₀(_lh_sum_LH_C_1¹)) | _  => error⁰}: 637 --->
//│ 	[LH_C f¹²(h¹⁹) map_₀(f¹², t²¹)]: 685
//│ 	[LH_N]: 686
//│ case ls¹⁸ of {LH_C h¹⁹ t²¹ => [LH_C f¹²(h¹⁹) map_₀(f¹², t²¹)] | LH_N  => [LH_N]}: 687 --->
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 671
//│ 	[LH_N]: 672
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 671 --->
//│ 	case ls¹⁸ of {LH_C h¹⁹ t²¹ => [LH_C f¹²(h¹⁹) map_₀(f¹², t²¹)] | LH_N  => [LH_N]}: 687
//│ [LH_N]: 672 --->
//│ 	case ls¹⁸ of {LH_C h¹⁹ t²¹ => [LH_C f¹²(h¹⁹) map_₀(f¹², t²¹)] | LH_N  => [LH_N]}: 687
//│ [LH_C f¹²(h¹⁹) map_₀(f¹², t²¹)]: 685 --->
//│ 	case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum_₀(_lh_sum_LH_C_1¹)) | _  => error⁰}: 637
//│ [LH_N]: 686 --->
//│ 	case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum_₀(_lh_sum_LH_C_1¹)) | _  => error⁰}: 637
//│ ------------------
//│ case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum_₀(_lh_sum_LH_C_1¹)) | _  => error⁰}: 637 --->
//│ 	[LH_C f¹²(h¹⁹) map_₀(f¹², t²¹)]: 685
//│ 	[LH_N]: 686
//│ case ls¹⁸ of {LH_C h¹⁹ t²¹ => [LH_C f¹²(h¹⁹) map_₀(f¹², t²¹)] | LH_N  => [LH_N]}: 687 --->
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 671
//│ 	[LH_N]: 672
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumMapEnumBuiltInType_₀(primId⁰(300000))
//│ def enumFromTo_₀(a⁶, b³) = if (a⁶ <= b³) then 
//│ 	let t²² = enumFromTo_₀((a⁶ + 1), b³)
//│ 	in let h²⁰ = a⁶
//│ 	in (fun f¹³ -> 
//│ 		let _lh_sum_LH_C_1² = map_₀(f¹³, t²²)
//│ 		in let _lh_sum_LH_C_0² = f¹³(h²⁰)
//│ 		in (fun _lh_dummy⁰ -> (_lh_sum_LH_C_0² + sum_₀(_lh_sum_LH_C_1²)))) else (fun f¹⁴ -> (fun _lh_dummy¹ -> 0))
//│ def map_₀(f¹⁵, ls¹⁹) = ls¹⁹(f¹⁵)
//│ def sum_₀(_lh_sum_arg1²) = _lh_sum_arg1²(99)
//│ def testSumMapEnumBuiltInType_₀(_lh_testSumMapEnumBuiltInType_arg1²) = sum_₀(map_₀((fun x⁴ -> (x⁴ * x⁴)), enumFromTo_₀(1, _lh_testSumMapEnumBuiltInType_arg1²)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun genTree(n, i) = if n <= 0 then N(i) else T(genTree(n - 1, i), genTree(n - 1, i + 1))
fun flip(t) = if t is
  T(l, r) then T(flip(r), flip(l))
  N(v) then N(v)
fun ff(t) = flip(flip(t))
fun testFlipFlip(t) = ff(t)
testFlipFlip(primId(genTree(17, 0)))
//│ |#fun| |genTree|(|n|,| |i|)| |#=| |#if| |n| |<=| |0| |#then| |N|(|i|)| |#else| |T|(|genTree|(|n| |-| |1|,| |i|)|,| |genTree|(|n| |-| |1|,| |i| |+| |1|)|)|↵|#fun| |flip|(|t|)| |#=| |#if| |t| |is|→|T|(|l|,| |r|)| |#then| |T|(|flip|(|r|)|,| |flip|(|l|)|)|↵|N|(|v|)| |#then| |N|(|v|)|←|↵|#fun| |ff|(|t|)| |#=| |flip|(|flip|(|t|)|)|↵|#fun| |testFlipFlip|(|t|)| |#=| |ff|(|t|)|↵|testFlipFlip|(|primId|(|genTree|(|17|,| |0|)|)|)|
//│ Parsed: {fun genTree = n, i, => if (<= (n,) (0,)) then N (i,) else T (genTree (- (n,) (1,), i,), genTree (- (n,) (1,), + (i,) (1,),),); fun flip = t, => if t is ‹(T (l, r,)) then T (flip (r,), flip (l,),); (N (v,)) then N (v,)›; fun ff = t, => flip (flip (t,),); fun testFlipFlip = t, => ff (t,); testFlipFlip (primId (genTree (17, 0,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testFlipFlip^56(primId⁰(genTree^58(17, 0)))
//│ def ff(t¹) = flip^46(flip^47(t¹))
//│ def flip(t⁰) = case t⁰ of {
//│ 	T l⁰ r⁰ => [T flip^35(r⁰) flip^38(l⁰)]
//│ 	| N v⁰ => [N v⁰]}
//│ def genTree(n⁰, i⁰) = if (n⁰ <= 0) then [N i⁰] else [T genTree^8((n⁰ - 1), i⁰) genTree^17((n⁰ - 1), (i⁰ + 1))]
//│ def testFlipFlip(t²) = ff^52(t²)
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec ff t_1 =
//│ 		  (flip (flip t_1))
//│ 		and flip t_0 =
//│ 		  (match t_0 with
//│ 		    | `T(l_0, r_0) -> 
//│ 		      (`T((flip r_0), (flip l_0)))
//│ 		    | `N(v_0) -> 
//│ 		      (`N(v_0)))
//│ 		and genTree n_0 i_0 =
//│ 		  (if (n_0 <= 0) then
//│ 		    (`N(i_0))
//│ 		  else
//│ 		    (`T(((genTree (n_0 - 1)) i_0), ((genTree (n_0 - 1)) (i_0 + 1)))))
//│ 		and testFlipFlip t_2 =
//│ 		  (ff t_2);;
//│ 		(testFlipFlip ((genTree 17) 0))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [genTree^58]
//│ 	[genTree^58 · genTree^17] ---> [genTree^58] (only one)
//│ 	[genTree^58 · genTree^8] ---> [genTree^58] (only one)
//│ [testFlipFlip^56]
//│ 	[testFlipFlip^56 · ff^52]
//│ 		[testFlipFlip^56 · ff^52 · flip^46]
//│ 			[testFlipFlip^56 · ff^52 · flip^46 · flip^35] ---> [testFlipFlip^56 · ff^52 · flip^46] (only one)
//│ 			[testFlipFlip^56 · ff^52 · flip^46 · flip^38] ---> [testFlipFlip^56 · ff^52 · flip^46] (only one)
//│ 		[testFlipFlip^56 · ff^52 · flip^47]
//│ 			[testFlipFlip^56 · ff^52 · flip^47 · flip^35] ---> [testFlipFlip^56 · ff^52 · flip^47] (only one)
//│ 			[testFlipFlip^56 · ff^52 · flip^47 · flip^38] ---> [testFlipFlip^56 · ff^52 · flip^47] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testFlipFlip_₀(primId⁰(genTree_₀(17, 0)))
//│ def genTree_₀(n¹, i¹) = 
//│ 	if (n¹ <= 0) then [N i¹] else [T genTree_₀((n¹ - 1), i¹) genTree_₀((n¹ - 1), (i¹ + 1))]
//│ def testFlipFlip_₀(t⁶) = 
//│ 	ff_₀(t⁶)
//│ 	where
//│ 	def ff_₀(t⁴) = 
//│ 		flip_₀(flip_₁(t⁴))
//│ 		where
//│ 		def flip_₀(t³) = 
//│ 			case t³ of {
//│ 				T l¹ r¹ => [T flip_₀(r¹) flip_₀(l¹)]
//│ 				| N v¹ => [N v¹]}
//│ 		def flip_₁(t⁵) = 
//│ 			case t⁵ of {
//│ 				T l² r² => [T flip_₁(r²) flip_₁(l²)]
//│ 				| N v² => [N v²]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [T flip_₁(r²) flip_₁(l²)]: 123 --->
//│ 	case t³ of {T l¹ r¹ => [T flip_₀(r¹) flip_₀(l¹)] | N v¹ => [N v¹]}: 75
//│ [N v²]: 125 --->
//│ 	case t³ of {T l¹ r¹ => [T flip_₀(r¹) flip_₀(l¹)] | N v¹ => [N v¹]}: 75
//│ ------------------
//│ case t³ of {T l¹ r¹ => [T flip_₀(r¹) flip_₀(l¹)] | N v¹ => [N v¹]}: 75 --->
//│ 	[T flip_₁(r²) flip_₁(l²)]: 123
//│ 	[N v²]: 125
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [T flip_₁(r²) flip_₁(l²)]: 123 --->
//│ 	case t³ of {T l¹ r¹ => [T flip_₀(r¹) flip_₀(l¹)] | N v¹ => [N v¹]}: 75
//│ [N v²]: 125 --->
//│ 	case t³ of {T l¹ r¹ => [T flip_₀(r¹) flip_₀(l¹)] | N v¹ => [N v¹]}: 75
//│ ------------------
//│ case t³ of {T l¹ r¹ => [T flip_₀(r¹) flip_₀(l¹)] | N v¹ => [N v¹]}: 75 --->
//│ 	[T flip_₁(r²) flip_₁(l²)]: 123
//│ 	[N v²]: 125
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testFlipFlip_₀(primId⁰(genTree_₀(17, 0)))
//│ def genTree_₀(n², i²) = 
//│ 	if (n² <= 0) then [N i²] else [T genTree_₀((n² - 1), i²) genTree_₀((n² - 1), (i² + 1))]
//│ def testFlipFlip_₀(t¹⁰) = 
//│ 	ff_₀(t¹⁰)
//│ 	where
//│ 	def ff_₀(t⁹) = 
//│ 		flip_₀(flip_₁(t⁹))
//│ 		where
//│ 		def flip_₀(t⁷) = 
//│ 			t⁷(99)
//│ 		def flip_₁(t⁸) = 
//│ 			case t⁸ of {
//│ 				T l² r² => 
//│ 					let r³ = flip_₁(l²)
//│ 					in let l³ = flip_₁(r²)
//│ 					in (fun _lh_dummy⁰ -> [T flip_₀(r³) flip_₀(l³)])
//│ 				| N v² => 
//│ 					let v³ = v²
//│ 					in (fun _lh_dummy¹ -> [N v³])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
fun map(f, ls) = if ls is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun foldl(f, s, ls) = if ls is
  C(h, t) then foldl(f, f(s, h), t)
  N then s
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun testFoldMap(n) = foldl(
  i => x => i + x,
  0,
  map(x => x * x, primId(enumFromTo(1, n)))
)
testFoldMap(primId(300000))
//│ |#fun| |map|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |foldl|(|f|,| |s|,| |ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |foldl|(|f|,| |f|(|s|,| |h|)|,| |t|)|↵|N| |#then| |s|←|↵|#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |testFoldMap|(|n|)| |#=| |foldl|(|→|i| |=>| |x| |=>| |i| |+| |x|,|↵|0|,|↵|map|(|x| |=>| |x| |*| |x|,| |primId|(|enumFromTo|(|1|,| |n|)|)|)|←|↵|)|↵|testFoldMap|(|primId|(|300000|)|)|
//│ Parsed: {fun map = f, ls, => if ls is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun foldl = f, s, ls, => if ls is ‹(C (h, t,)) then foldl (f, f (s, h,), t,); (N) then s›; fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun testFoldMap = n, => foldl (i, => x, => + (i,) (x,), 0, map (x, => * (x,) (x,), primId (enumFromTo (1, n,),),),); testFoldMap (primId (300000,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testFoldMap^81(primId⁰(300000))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^38((a⁰ + 1), b⁰)] else [N]
//│ def foldl(f¹, s⁰, ls¹) = case ls¹ of {
//│ 	C h¹ t¹ => foldl^16(f¹, f¹(s⁰, h¹), t¹)
//│ 	| N  => s⁰}
//│ def map(f⁰, ls⁰) = case ls⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^5(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def testFoldMap(n⁰) = foldl^52((fun i⁰ -> (fun x⁰ -> (i⁰ + x⁰))), 0, map^63((fun x¹ -> (x¹ * x¹)), primId⁰(enumFromTo^72(1, n⁰))))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N))
//│ 		and foldl f_1 s_0 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (((foldl f_1) ((f_1 s_0) h_1)) t_1)
//│ 		    | `N -> 
//│ 		      s_0)
//│ 		and map f_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N))
//│ 		and testFoldMap n_0 =
//│ 		  (((foldl (fun i_0 x_0 -> 
//│ 		    (i_0 + x_0))) 0) ((map (fun x_1 -> 
//│ 		    (x_1 * x_1))) ((enumFromTo 1) n_0)));;
//│ 		(testFoldMap 300000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testFoldMap^81] (hopeless to continue)
//│ 	[testFoldMap^81 · enumFromTo^72] (using original def)
//│ 		[testFoldMap^81 · enumFromTo^72 · enumFromTo^38] ---> [testFoldMap^81 · enumFromTo^72] (using original def)
//│ 	[testFoldMap^81 · foldl^52] (using original def)
//│ 		[testFoldMap^81 · foldl^52 · foldl^16] ---> [testFoldMap^81 · foldl^52] (using original def)
//│ 	[testFoldMap^81 · map^63] (using original def)
//│ 		[testFoldMap^81 · map^63 · map^5] ---> [testFoldMap^81 · map^63] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testFoldMap_₀(primId⁰(300000))
//│ def testFoldMap_₀(n¹) = 
//│ 	foldl_₀((fun i¹ -> (fun x² -> (i¹ + x²))), 0, map_₀((fun x³ -> (x³ * x³)), primId⁰(enumFromTo_₀(1, n¹))))
//│ 	where
//│ 	def enumFromTo_₀(a¹, b¹) = 
//│ 		if (a¹ <= b¹) then [C a¹ enumFromTo_₀((a¹ + 1), b¹)] else [N]
//│ 	def foldl_₀(f², s¹, ls²) = 
//│ 		case ls² of {
//│ 			C h² t² => foldl_₀(f², f²(s¹, h²), t²)
//│ 			| N  => s¹}
//│ 	def map_₀(f³, ls³) = 
//│ 		case ls³ of {
//│ 			C h³ t³ => [C f³(h³) map_₀(f³, t³)]
//│ 			| N  => [N]}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f³(h³) map_₀(f³, t³)]: 112 --->
//│ 	case ls² of {C h² t² => foldl_₀(f², f²(s¹, h²), t²) | N  => s¹}: 99
//│ [N]: 113 --->
//│ 	case ls² of {C h² t² => foldl_₀(f², f²(s¹, h²), t²) | N  => s¹}: 99
//│ ------------------
//│ case ls² of {C h² t² => foldl_₀(f², f²(s¹, h²), t²) | N  => s¹}: 99 --->
//│ 	[C f³(h³) map_₀(f³, t³)]: 112
//│ 	[N]: 113
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f³(h³) map_₀(f³, t³)]: 112 --->
//│ 	case ls² of {C h² t² => foldl_₀(f², f²(s¹, h²), t²) | N  => s¹}: 99
//│ [N]: 113 --->
//│ 	case ls² of {C h² t² => foldl_₀(f², f²(s¹, h²), t²) | N  => s¹}: 99
//│ ------------------
//│ case ls² of {C h² t² => foldl_₀(f², f²(s¹, h²), t²) | N  => s¹}: 99 --->
//│ 	[C f³(h³) map_₀(f³, t³)]: 112
//│ 	[N]: 113
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testFoldMap_₀(primId⁰(300000))
//│ def testFoldMap_₀(n²) = 
//│ 	foldl_₀((fun i² -> (fun x⁴ -> (i² + x⁴))), 0, map_₀((fun x⁵ -> (x⁵ * x⁵)), primId⁰(enumFromTo_₀(1, n²))))
//│ 	where
//│ 	def enumFromTo_₀(a², b²) = 
//│ 		if (a² <= b²) then [C a² enumFromTo_₀((a² + 1), b²)] else [N]
//│ 	def foldl_₀(f⁴, s², ls⁴) = 
//│ 		ls⁴(f⁴, s²)
//│ 	def map_₀(f⁵, ls⁵) = 
//│ 		case ls⁵ of {
//│ 			C h³ t³ => 
//│ 				let t⁴ = map_₀(f⁵, t³)
//│ 				in let h⁴ = f⁵(h³)
//│ 				in (fun f⁶ -> (fun s³ -> foldl_₀(f⁶, f⁶(s³, h⁴), t⁴)))
//│ 			| N  => (fun f⁷ -> (fun s⁴ -> s⁴))}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun map(f, xs) = if xs is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun qrev(a, ys) = if ys is
  C(h, t) then qrev(C(h, a), t)
  N then a
fun testMapQrev(ls) = map(x => x + 1, qrev(N, ls))
testMapQrev(primId(enumFromTo(1, 10000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |map|(|f|,| |xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |qrev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |qrev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |testMapQrev|(|ls|)| |#=| |map|(|x| |=>| |x| |+| |1|,| |qrev|(|N|,| |ls|)|)|↵|testMapQrev|(|primId|(|enumFromTo|(|1|,| |10000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun map = f, xs, => if xs is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun qrev = a, ys, => if ys is ‹(C (h, t,)) then qrev (C (h, a,), t,); (N) then a›; fun testMapQrev = ls, => map (x, => + (x,) (1,), qrev (N, ls,),); testMapQrev (primId (enumFromTo (1, 10000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testMapQrev^62(primId⁰(enumFromTo^64(1, 10000)))
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^25(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def qrev(a¹, ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => qrev^36([C h¹ a¹], t¹)
//│ 	| N  => a¹}
//│ def testMapQrev(ls⁰) = map^47((fun x⁰ -> (x⁰ + 1)), qrev^55([N], ls⁰))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N))
//│ 		and map f_0 xs_0 =
//│ 		  (match xs_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N))
//│ 		and qrev a_1 ys_0 =
//│ 		  (match ys_0 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      ((qrev (`C(h_1, a_1))) t_1)
//│ 		    | `N -> 
//│ 		      a_1)
//│ 		and testMapQrev ls_0 =
//│ 		  ((map (fun x_0 -> 
//│ 		    (x_0 + 1))) ((qrev (`N)) ls_0));;
//│ 		(testMapQrev ((enumFromTo 1) 10000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo^64]
//│ 	[enumFromTo^64 · enumFromTo^7] ---> [enumFromTo^64] (only one)
//│ [testMapQrev^62]
//│ 	[testMapQrev^62 · map^47]
//│ 		[testMapQrev^62 · map^47 · map^25] ---> [testMapQrev^62 · map^47] (only one)
//│ 	[testMapQrev^62 · qrev^55]
//│ 		[testMapQrev^62 · qrev^55 · qrev^36] ---> [testMapQrev^62 · qrev^55] (only one)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testMapQrev_₀(primId⁰(enumFromTo_₀(1, 10000)))
//│ def enumFromTo_₀(a², b¹) = 
//│ 	if (a² <= b¹) then [C a² enumFromTo_₀((a² + 1), b¹)] else [N]
//│ def testMapQrev_₀(ls¹) = 
//│ 	map_₀((fun x¹ -> (x¹ + 1)), qrev_₀([N], ls¹))
//│ 	where
//│ 	def map_₀(f¹, xs¹) = 
//│ 		case xs¹ of {
//│ 			C h³ t³ => [C f¹(h³) map_₀(f¹, t³)]
//│ 			| N  => [N]}
//│ 	def qrev_₀(a³, ys¹) = 
//│ 		case ys¹ of {
//│ 			C h² t² => qrev_₀([C h² a³], t²)
//│ 			| N  => a³}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 80 --->
//│ 	case xs¹ of {C h³ t³ => [C f¹(h³) map_₀(f¹, t³)] | N  => [N]}: 129
//│ [C h² a³]: 110 --->
//│ 	case xs¹ of {C h³ t³ => [C f¹(h³) map_₀(f¹, t³)] | N  => [N]}: 129
//│ ------------------
//│ case xs¹ of {C h³ t³ => [C f¹(h³) map_₀(f¹, t³)] | N  => [N]}: 129 --->
//│ 	[N]: 80
//│ 	[C h² a³]: 110
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [N]: 80 --->
//│ 	case xs¹ of {C h³ t³ => [C f¹(h³) map_₀(f¹, t³)] | N  => [N]}: 129
//│ [C h² a³]: 110 --->
//│ 	case xs¹ of {C h³ t³ => [C f¹(h³) map_₀(f¹, t³)] | N  => [N]}: 129
//│ ------------------
//│ case xs¹ of {C h³ t³ => [C f¹(h³) map_₀(f¹, t³)] | N  => [N]}: 129 --->
//│ 	[N]: 80
//│ 	[C h² a³]: 110
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testMapQrev_₀(primId⁰(enumFromTo_₀(1, 10000)))
//│ def enumFromTo_₀(a⁴, b²) = 
//│ 	if (a⁴ <= b²) then [C a⁴ enumFromTo_₀((a⁴ + 1), b²)] else [N]
//│ def testMapQrev_₀(ls²) = 
//│ 	map_₀((fun x² -> (x² + 1)), qrev_₀((fun f² -> [N]), ls²))
//│ 	where
//│ 	def map_₀(f⁴, xs²) = 
//│ 		xs²(f⁴)
//│ 	def qrev_₀(a⁵, ys²) = 
//│ 		case ys² of {
//│ 			C h² t² => qrev_₀(
//│ 				let t⁴ = a⁵
//│ 				in let h⁴ = h²
//│ 				in (fun f³ -> [C f³(h⁴) map_₀(f³, t⁴)]), t²)
//│ 			| N  => a⁵}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
fun enumFromTo(a, b) = if a <= b then C(a, enumFromTo(a + 1, b)) else N
fun map(f, xs) = if xs is
  C(h, t) then C(f(h), map(f, t))
  N then N
fun qrev(a, ys) = if ys is
  C(h, t) then qrev(C(h, a), t)
  N then a
fun _lhManualQrevMap(f, xs, a) = if xs is
  C(h, t) then _lhManualQrevMap(f, t, C(f(h), a))
  N then a
fun testQrevMap(ls) = qrev(N, map(x => x + 1, ls))
fun testManual(ls) = _lhManualQrevMap(x => x + 1, ls, N)
testQrevMap(primId(enumFromTo(1, 10000)))
testManual(primId(enumFromTo(1, 10000)))
//│ |#fun| |enumFromTo|(|a|,| |b|)| |#=| |#if| |a| |<=| |b| |#then| |C|(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)| |#else| |N|↵|#fun| |map|(|f|,| |xs|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |C|(|f|(|h|)|,| |map|(|f|,| |t|)|)|↵|N| |#then| |N|←|↵|#fun| |qrev|(|a|,| |ys|)| |#=| |#if| |ys| |is|→|C|(|h|,| |t|)| |#then| |qrev|(|C|(|h|,| |a|)|,| |t|)|↵|N| |#then| |a|←|↵|#fun| |_lhManualQrevMap|(|f|,| |xs|,| |a|)| |#=| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |_lhManualQrevMap|(|f|,| |t|,| |C|(|f|(|h|)|,| |a|)|)|↵|N| |#then| |a|←|↵|#fun| |testQrevMap|(|ls|)| |#=| |qrev|(|N|,| |map|(|x| |=>| |x| |+| |1|,| |ls|)|)|↵|#fun| |testManual|(|ls|)| |#=| |_lhManualQrevMap|(|x| |=>| |x| |+| |1|,| |ls|,| |N|)|↵|testQrevMap|(|primId|(|enumFromTo|(|1|,| |10000|)|)|)|↵|testManual|(|primId|(|enumFromTo|(|1|,| |10000|)|)|)|
//│ Parsed: {fun enumFromTo = a, b, => if (<= (a,) (b,)) then C (a, enumFromTo (+ (a,) (1,), b,),) else N; fun map = f, xs, => if xs is ‹(C (h, t,)) then C (f (h,), map (f, t,),); (N) then N›; fun qrev = a, ys, => if ys is ‹(C (h, t,)) then qrev (C (h, a,), t,); (N) then a›; fun _lhManualQrevMap = f, xs, a, => if xs is ‹(C (h, t,)) then _lhManualQrevMap (f, t, C (f (h,), a,),); (N) then a›; fun testQrevMap = ls, => qrev (N, map (x, => + (x,) (1,), ls,),); fun testManual = ls, => _lhManualQrevMap (x, => + (x,) (1,), ls, N,); testQrevMap (primId (enumFromTo (1, 10000,),),); testManual (primId (enumFromTo (1, 10000,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testQrevMap^92(primId⁰(enumFromTo^94(1, 10000)))
//│ testManual^101(primId⁰(enumFromTo^103(1, 10000)))
//│ def _lhManualQrevMap(f¹, xs¹, a²) = case xs¹ of {
//│ 	C h² t² => _lhManualQrevMap^48(f¹, t², [C f¹(h²) a²])
//│ 	| N  => a²}
//│ def enumFromTo(a⁰, b⁰) = if (a⁰ <= b⁰) then [C a⁰ enumFromTo^7((a⁰ + 1), b⁰)] else [N]
//│ def map(f⁰, xs⁰) = case xs⁰ of {
//│ 	C h⁰ t⁰ => [C f⁰(h⁰) map^25(f⁰, t⁰)]
//│ 	| N  => [N]}
//│ def qrev(a¹, ys⁰) = case ys⁰ of {
//│ 	C h¹ t¹ => qrev^36([C h¹ a¹], t¹)
//│ 	| N  => a¹}
//│ def testManual(ls¹) = _lhManualQrevMap^79((fun x¹ -> (x¹ + 1)), ls¹, [N])
//│ def testQrevMap(ls⁰) = qrev^64([N], map^67((fun x⁰ -> (x⁰ + 1)), ls⁰))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec _lhManualQrevMap f_1 xs_1 a_2 =
//│ 		  (match xs_1 with
//│ 		    | `C(h_2, t_2) -> 
//│ 		      (((_lhManualQrevMap f_1) t_2) (`C((f_1 h_2), a_2)))
//│ 		    | `N -> 
//│ 		      a_2)
//│ 		and enumFromTo a_0 b_0 =
//│ 		  (if (a_0 <= b_0) then
//│ 		    (`C(a_0, ((enumFromTo (a_0 + 1)) b_0)))
//│ 		  else
//│ 		    (`N))
//│ 		and map f_0 xs_0 =
//│ 		  (match xs_0 with
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (`C((f_0 h_0), ((map f_0) t_0)))
//│ 		    | `N -> 
//│ 		      (`N))
//│ 		and qrev a_1 ys_0 =
//│ 		  (match ys_0 with
//│ 		    | `C(h_1, t_1) -> 
//│ 		      ((qrev (`C(h_1, a_1))) t_1)
//│ 		    | `N -> 
//│ 		      a_1)
//│ 		and testManual ls_1 =
//│ 		  (((_lhManualQrevMap (fun x_1 -> 
//│ 		    (x_1 + 1))) ls_1) (`N))
//│ 		and testQrevMap ls_0 =
//│ 		  ((qrev (`N)) ((map (fun x_0 -> 
//│ 		    (x_0 + 1))) ls_0));;
//│ 		(testQrevMap ((enumFromTo 1) 10000))
//│ 		(testManual ((enumFromTo 1) 10000))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [enumFromTo^103]
//│ 	[enumFromTo^103 · enumFromTo^7] ---> [enumFromTo^103] (only one)
//│ [enumFromTo^94] (hopeless to continue)
//│ 	[enumFromTo^94 · enumFromTo^7] ---> [enumFromTo^94] (using original def)
//│ [testManual^101]
//│ 	[testManual^101 · _lhManualQrevMap^79]
//│ 		[testManual^101 · _lhManualQrevMap^79 · _lhManualQrevMap^48] ---> [testManual^101 · _lhManualQrevMap^79] (only one)
//│ [testQrevMap^92]
//│ 	[testQrevMap^92 · map^67]
//│ 		[testQrevMap^92 · map^67 · map^25] ---> [testQrevMap^92 · map^67] (only one)
//│ 	[testQrevMap^92 · qrev^64] (hopeless to continue)
//│ 		[testQrevMap^92 · qrev^64 · qrev^36] ---> [testQrevMap^92 · qrev^64] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testQrevMap_₀(primId⁰(enumFromTo_₁(1, 10000)))
//│ testManual_₀(primId⁰(enumFromTo_₀(1, 10000)))
//│ def enumFromTo_₀(a⁴, b¹) = 
//│ 	if (a⁴ <= b¹) then [C a⁴ enumFromTo_₀((a⁴ + 1), b¹)] else [N]
//│ def enumFromTo_₁(a⁵, b²) = 
//│ 	if (a⁵ <= b²) then [C a⁵ enumFromTo_₁((a⁵ + 1), b²)] else [N]
//│ def testManual_₀(ls²) = 
//│ 	_lhManualQrevMap_₀((fun x² -> (x² + 1)), ls², [N])
//│ 	where
//│ 	def _lhManualQrevMap_₀(f³, xs³, a⁶) = 
//│ 		case xs³ of {
//│ 			C h⁵ t⁵ => _lhManualQrevMap_₀(f³, t⁵, [C f³(h⁵) a⁶])
//│ 			| N  => a⁶}
//│ def testQrevMap_₀(ls³) = 
//│ 	qrev_₀([N], map_₀((fun x³ -> (x³ + 1)), ls³))
//│ 	where
//│ 	def map_₀(f², xs²) = 
//│ 		case xs² of {
//│ 			C h⁴ t⁴ => [C f²(h⁴) map_₀(f², t⁴)]
//│ 			| N  => [N]}
//│ 	def qrev_₀(a³, ys¹) = 
//│ 		case ys¹ of {
//│ 			C h³ t³ => qrev_₀([C h³ a³], t³)
//│ 			| N  => a³}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C f²(h⁴) map_₀(f², t⁴)]: 164 --->
//│ 	case ys¹ of {C h³ t³ => qrev_₀([C h³ a³], t³) | N  => a³}: 119
//│ [N]: 165 --->
//│ 	case ys¹ of {C h³ t³ => qrev_₀([C h³ a³], t³) | N  => a³}: 119
//│ ------------------
//│ case ys¹ of {C h³ t³ => qrev_₀([C h³ a³], t³) | N  => a³}: 119 --->
//│ 	[C f²(h⁴) map_₀(f², t⁴)]: 164
//│ 	[N]: 165
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C f²(h⁴) map_₀(f², t⁴)]: 164 --->
//│ 	case ys¹ of {C h³ t³ => qrev_₀([C h³ a³], t³) | N  => a³}: 119
//│ [N]: 165 --->
//│ 	case ys¹ of {C h³ t³ => qrev_₀([C h³ a³], t³) | N  => a³}: 119
//│ ------------------
//│ case ys¹ of {C h³ t³ => qrev_₀([C h³ a³], t³) | N  => a³}: 119 --->
//│ 	[C f²(h⁴) map_₀(f², t⁴)]: 164
//│ 	[N]: 165
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testQrevMap_₀(primId⁰(enumFromTo_₁(1, 10000)))
//│ testManual_₀(primId⁰(enumFromTo_₀(1, 10000)))
//│ def enumFromTo_₀(a¹⁰, b⁴) = 
//│ 	if (a¹⁰ <= b⁴) then [C a¹⁰ enumFromTo_₀((a¹⁰ + 1), b⁴)] else [N]
//│ def enumFromTo_₁(a⁹, b³) = 
//│ 	if (a⁹ <= b³) then [C a⁹ enumFromTo_₁((a⁹ + 1), b³)] else [N]
//│ def testManual_₀(ls⁵) = 
//│ 	_lhManualQrevMap_₀((fun x⁵ -> (x⁵ + 1)), ls⁵, [N])
//│ 	where
//│ 	def _lhManualQrevMap_₀(f⁵, xs⁵, a¹¹) = 
//│ 		case xs⁵ of {
//│ 			C h⁵ t⁵ => _lhManualQrevMap_₀(f⁵, t⁵, [C f⁵(h⁵) a¹¹])
//│ 			| N  => a¹¹}
//│ def testQrevMap_₀(ls⁴) = 
//│ 	qrev_₀([N], map_₀((fun x⁴ -> (x⁴ + 1)), ls⁴))
//│ 	where
//│ 	def map_₀(f⁴, xs⁴) = 
//│ 		case xs⁴ of {
//│ 			C h⁴ t⁴ => 
//│ 				let t⁶ = map_₀(f⁴, t⁴)
//│ 				in let h⁶ = f⁴(h⁴)
//│ 				in (fun a⁷ -> qrev_₀([C h⁶ a⁷], t⁶))
//│ 			| N  => (fun a⁸ -> a⁸)}
//│ 	def qrev_₀(a¹², ys²) = 
//│ 		ys²(a¹²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
sum [] = 0
sum (h:t) = h + sum(t)
testSumListComprehensionBuiltInType n = sum [ k * m | k <- [1..n], m <- [1..k] ]
testSumListComprehensionBuiltInType $ primId 1000
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumListComprehensionBuiltInType_₀^738(primId⁰(1000))
//│ def enumFromTo_₀(a⁵, b²) = if (a⁵ <= b²) then [LH_C a⁵ enumFromTo_₀^654((a⁵ + 1), b²)] else [LH_N]
//│ def enumFromTo_₁(a⁶, b³) = if (a⁶ <= b³) then [LH_C a⁶ enumFromTo_₁^724((a⁶ + 1), b³)] else [LH_N]
//│ def sum_₀(_lh_sum_arg1¹) = case _lh_sum_arg1¹ of {
//│ 	LH_N  => 0
//│ 	| LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum_₀^711(_lh_sum_LH_C_1¹))
//│ 	| _  => error⁰}
//│ def testSumListComprehensionBuiltInType_₀(_lh_testSumListComprehensionBuiltInType_arg1¹) = sum_₀^668(
//│ 	let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 		LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => 
//│ 			let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 				LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]
//│ 				| LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ 			in _lh_listcomp_fun³(enumFromTo_₁^686(1, _lh_listcomp_fun_ls_h²))
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun²(enumFromTo_₀^697(1, _lh_testSumListComprehensionBuiltInType_arg1¹)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo__d0 a_5 b_2 =
//│ 		  (if (a_5 <= b_2) then
//│ 		    (`LH_C(a_5, ((enumFromTo__d0 (a_5 + 1)) b_2)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and enumFromTo__d1 a_6 b_3 =
//│ 		  (if (a_6 <= b_3) then
//│ 		    (`LH_C(a_6, ((enumFromTo__d1 (a_6 + 1)) b_3)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and sum__d0 _lh_sum_arg1_1 =
//│ 		  (match _lh_sum_arg1_1 with
//│ 		    | `LH_N -> 
//│ 		      0
//│ 		    | `LH_C(_lh_sum_LH_C_0_1, _lh_sum_LH_C_1_1) -> 
//│ 		      (_lh_sum_LH_C_0_1 + (sum__d0 _lh_sum_LH_C_1_1))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and testSumListComprehensionBuiltInType__d0 _lh_testSumListComprehensionBuiltInType_arg1_1 =
//│ 		  (sum__d0 (let rec _lh_listcomp_fun_2 = (fun _lh_listcomp_fun_para_2 -> 
//│ 		    (match _lh_listcomp_fun_para_2 with
//│ 		      | `LH_C(_lh_listcomp_fun_ls_h_2, _lh_listcomp_fun_ls_t_2) -> 
//│ 		        (let rec _lh_listcomp_fun_3 = (fun _lh_listcomp_fun_para_3 -> 
//│ 		          (match _lh_listcomp_fun_para_3 with
//│ 		            | `LH_C(_lh_listcomp_fun_ls_h_3, _lh_listcomp_fun_ls_t_3) -> 
//│ 		              (`LH_C((_lh_listcomp_fun_ls_h_2 * _lh_listcomp_fun_ls_h_3), (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3)))
//│ 		            | `LH_N -> 
//│ 		              (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_2))) in
//│ 		          (_lh_listcomp_fun_3 ((enumFromTo__d1 1) _lh_listcomp_fun_ls_h_2)))
//│ 		      | `LH_N -> 
//│ 		        (`LH_N))) in
//│ 		    (_lh_listcomp_fun_2 ((enumFromTo__d0 1) _lh_testSumListComprehensionBuiltInType_arg1_1))));;
//│ 		(testSumListComprehensionBuiltInType__d0 1000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 663 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo_₁(1, _lh_listcomp_fun_ls_h²)) | LH_N  => [LH_N]}: 694
//│ [LH_N]: 664 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo_₁(1, _lh_listcomp_fun_ls_h²)) | LH_N  => [LH_N]}: 694
//│ [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 679 --->
//│ 	case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum_₀(_lh_sum_LH_C_1¹)) | _  => error⁰}: 716
//│ [LH_N]: 693 --->
//│ 	case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum_₀(_lh_sum_LH_C_1¹)) | _  => error⁰}: 716
//│ [LH_C a⁶ enumFromTo_₁((a⁶ + 1), b³)]: 733 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 683
//│ [LH_N]: 734 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 683
//│ ------------------
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 683 --->
//│ 	[LH_C a⁶ enumFromTo_₁((a⁶ + 1), b³)]: 733
//│ 	[LH_N]: 734
//│ case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo_₁(1, _lh_listcomp_fun_ls_h²)) | LH_N  => [LH_N]}: 694 --->
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 663
//│ 	[LH_N]: 664
//│ case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum_₀(_lh_sum_LH_C_1¹)) | _  => error⁰}: 716 --->
//│ 	[LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 679
//│ 	[LH_N]: 693
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 663 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo_₁(1, _lh_listcomp_fun_ls_h²)) | LH_N  => [LH_N]}: 694
//│ [LH_N]: 664 --->
//│ 	case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo_₁(1, _lh_listcomp_fun_ls_h²)) | LH_N  => [LH_N]}: 694
//│ [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 679 --->
//│ 	case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum_₀(_lh_sum_LH_C_1¹)) | _  => error⁰}: 716
//│ [LH_N]: 693 --->
//│ 	case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum_₀(_lh_sum_LH_C_1¹)) | _  => error⁰}: 716
//│ [LH_C a⁶ enumFromTo_₁((a⁶ + 1), b³)]: 733 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 683
//│ [LH_N]: 734 --->
//│ 	case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 683
//│ ------------------
//│ case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)}: 683 --->
//│ 	[LH_C a⁶ enumFromTo_₁((a⁶ + 1), b³)]: 733
//│ 	[LH_N]: 734
//│ case _lh_listcomp_fun_para² of {LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)] | LH_N  => _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)})
//│ in _lh_listcomp_fun³(enumFromTo_₁(1, _lh_listcomp_fun_ls_h²)) | LH_N  => [LH_N]}: 694 --->
//│ 	[LH_C a⁵ enumFromTo_₀((a⁵ + 1), b²)]: 663
//│ 	[LH_N]: 664
//│ case _lh_sum_arg1¹ of {LH_N  => 0 | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => (_lh_sum_LH_C_0¹ + sum_₀(_lh_sum_LH_C_1¹)) | _  => error⁰}: 716 --->
//│ 	[LH_C (_lh_listcomp_fun_ls_h² * _lh_listcomp_fun_ls_h³) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]: 679
//│ 	[LH_N]: 693
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumListComprehensionBuiltInType_₀(primId⁰(1000))
//│ def enumFromTo_₀(a⁷, b⁴) = if (a⁷ <= b⁴) then 
//│ 	let _lh_listcomp_fun_ls_t⁴ = enumFromTo_₀((a⁷ + 1), b⁴)
//│ 	in let _lh_listcomp_fun_ls_h⁴ = a⁷
//│ 	in (fun _lh_listcomp_fun⁴ -> 
//│ 		let _lh_listcomp_fun⁵ = (fun _lh_listcomp_fun_para⁴ -> _lh_listcomp_fun_para⁴(_lh_listcomp_fun_ls_h⁴, _lh_listcomp_fun⁵, _lh_listcomp_fun_ls_t⁴, _lh_listcomp_fun⁴))
//│ 		in _lh_listcomp_fun⁵(enumFromTo_₁(1, _lh_listcomp_fun_ls_h⁴))) else (fun _lh_listcomp_fun⁶ -> (fun _lh_dummy⁰ -> 0))
//│ def enumFromTo_₁(a⁸, b⁵) = if (a⁸ <= b⁵) then 
//│ 	let _lh_listcomp_fun_ls_t⁵ = enumFromTo_₁((a⁸ + 1), b⁵)
//│ 	in let _lh_listcomp_fun_ls_h⁵ = a⁸
//│ 	in (fun _lh_listcomp_fun_ls_h⁶ -> (fun _lh_listcomp_fun⁸ -> (fun _lh_listcomp_fun_ls_t⁶ -> (fun _lh_listcomp_fun⁹ -> 
//│ 		let _lh_sum_LH_C_1² = _lh_listcomp_fun⁸(_lh_listcomp_fun_ls_t⁵)
//│ 		in let _lh_sum_LH_C_0² = (_lh_listcomp_fun_ls_h⁶ * _lh_listcomp_fun_ls_h⁵)
//│ 		in (fun _lh_dummy¹ -> (_lh_sum_LH_C_0² + sum_₀(_lh_sum_LH_C_1²))))))) else (fun _lh_listcomp_fun_ls_h⁷ -> (fun _lh_listcomp_fun¹⁰ -> (fun _lh_listcomp_fun_ls_t⁷ -> (fun _lh_listcomp_fun¹¹ -> _lh_listcomp_fun¹¹(_lh_listcomp_fun_ls_t⁷)))))
//│ def sum_₀(_lh_sum_arg1²) = _lh_sum_arg1²(99)
//│ def testSumListComprehensionBuiltInType_₀(_lh_testSumListComprehensionBuiltInType_arg1²) = sum_₀(
//│ 	let _lh_listcomp_fun⁷ = (fun _lh_listcomp_fun_para⁵ -> _lh_listcomp_fun_para⁵(_lh_listcomp_fun⁷))
//│ 	in _lh_listcomp_fun⁷(enumFromTo_₀(1, _lh_testSumListComprehensionBuiltInType_arg1²)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhInHaskell
:lhGenOCaml
flatMap f [] = []
flatMap f (h:t) = (f h) ++ (flatMap f t)
sum s [] = s
sum s (h:t) = sum (s+h) t
testSumFlatmapEnum n = sum 0 $ flatMap (\a -> [a, a]) [1..n]
testSumFlatmapEnum $ primId 100000
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumFlatmapEnum_₀^732(primId⁰(100000))
//│ def enumFromTo_₀(a⁶, b²) = if (a⁶ <= b²) then [LH_C a⁶ enumFromTo_₀^670((a⁶ + 1), b²)] else [LH_N]
//│ def flatMap_₀(_lh_flatMap_arg1¹, _lh_flatMap_arg2¹) = case _lh_flatMap_arg2¹ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => mappend_₀^686(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_₀^691(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹))
//│ 	| _  => error⁰}
//│ def mappend_₀(xs⁹, ys⁹) = case xs⁹ of {
//│ 	LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀^703(t²¹, ys⁹)]
//│ 	| LH_N  => ys⁹}
//│ def sum_₀(_lh_sum_arg1¹, _lh_sum_arg2¹) = case _lh_sum_arg2¹ of {
//│ 	LH_N  => _lh_sum_arg1¹
//│ 	| LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => sum_₀^651((_lh_sum_arg1¹ + _lh_sum_LH_C_0¹), _lh_sum_LH_C_1¹)
//│ 	| _  => error⁰}
//│ def testSumFlatmapEnum_₀(_lh_testSumFlatmapEnum_arg1¹) = sum_₀^713(0, flatMap_₀^716((fun a⁷ -> [LH_C a⁷ [LH_C a⁷ [LH_N]]]), enumFromTo_₀^724(1, _lh_testSumFlatmapEnum_arg1¹)))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo__d0 a_6 b_2 =
//│ 		  (if (a_6 <= b_2) then
//│ 		    (`LH_C(a_6, ((enumFromTo__d0 (a_6 + 1)) b_2)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and flatMap__d0 _lh_flatMap_arg1_1 _lh_flatMap_arg2_1 =
//│ 		  (match _lh_flatMap_arg2_1 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_flatMap_LH_C_0_1, _lh_flatMap_LH_C_1_1) -> 
//│ 		      ((mappend__d0 (_lh_flatMap_arg1_1 _lh_flatMap_LH_C_0_1)) ((flatMap__d0 _lh_flatMap_arg1_1) _lh_flatMap_LH_C_1_1))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and mappend__d0 xs_9 ys_9 =
//│ 		  (match xs_9 with
//│ 		    | `LH_C(h_1_9, t_2_1) -> 
//│ 		      (`LH_C(h_1_9, ((mappend__d0 t_2_1) ys_9)))
//│ 		    | `LH_N -> 
//│ 		      ys_9)
//│ 		and sum__d0 _lh_sum_arg1_1 _lh_sum_arg2_1 =
//│ 		  (match _lh_sum_arg2_1 with
//│ 		    | `LH_N -> 
//│ 		      _lh_sum_arg1_1
//│ 		    | `LH_C(_lh_sum_LH_C_0_1, _lh_sum_LH_C_1_1) -> 
//│ 		      ((sum__d0 (_lh_sum_arg1_1 + _lh_sum_LH_C_0_1)) _lh_sum_LH_C_1_1)
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and testSumFlatmapEnum__d0 _lh_testSumFlatmapEnum_arg1_1 =
//│ 		  ((sum__d0 0) ((flatMap__d0 (fun a_7 -> 
//│ 		    (`LH_C(a_7, (`LH_C(a_7, (`LH_N))))))) ((enumFromTo__d0 1) _lh_testSumFlatmapEnum_arg1_1)));;
//│ 		(testSumFlatmapEnum__d0 100000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a⁶ enumFromTo_₀((a⁶ + 1), b²)]: 679 --->
//│ 	case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => mappend_₀(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_₀(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 698
//│ [LH_N]: 680 --->
//│ 	case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => mappend_₀(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_₀(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 698
//│ [LH_N]: 685 --->
//│ 	case _lh_sum_arg2¹ of {LH_N  => _lh_sum_arg1¹ | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => sum_₀((_lh_sum_arg1¹ + _lh_sum_LH_C_0¹), _lh_sum_LH_C_1¹) | _  => error⁰}: 661
//│ [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)]: 708 --->
//│ 	case _lh_sum_arg2¹ of {LH_N  => _lh_sum_arg1¹ | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => sum_₀((_lh_sum_arg1¹ + _lh_sum_LH_C_0¹), _lh_sum_LH_C_1¹) | _  => error⁰}: 661
//│ [LH_N]: 719 --->
//│ 	case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 710
//│ [LH_C a⁷ [LH_N]]: 720 --->
//│ 	case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 710
//│ [LH_C a⁷ [LH_C a⁷ [LH_N]]]: 721 --->
//│ 	case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 710
//│ ------------------
//│ case _lh_sum_arg2¹ of {LH_N  => _lh_sum_arg1¹ | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => sum_₀((_lh_sum_arg1¹ + _lh_sum_LH_C_0¹), _lh_sum_LH_C_1¹) | _  => error⁰}: 661 --->
//│ 	[LH_N]: 685
//│ 	[LH_C h¹⁹ mappend_₀(t²¹, ys⁹)]: 708
//│ case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => mappend_₀(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_₀(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 698 --->
//│ 	[LH_C a⁶ enumFromTo_₀((a⁶ + 1), b²)]: 679
//│ 	[LH_N]: 680
//│ case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 710 --->
//│ 	[LH_N]: 719
//│ 	[LH_C a⁷ [LH_N]]: 720
//│ 	[LH_C a⁷ [LH_C a⁷ [LH_N]]]: 721
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁶ enumFromTo_₀((a⁶ + 1), b²)]: 679 --->
//│ 	case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => mappend_₀(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_₀(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 698
//│ [LH_N]: 680 --->
//│ 	case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => mappend_₀(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_₀(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 698
//│ [LH_N]: 685 --->
//│ 	case _lh_sum_arg2¹ of {LH_N  => _lh_sum_arg1¹ | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => sum_₀((_lh_sum_arg1¹ + _lh_sum_LH_C_0¹), _lh_sum_LH_C_1¹) | _  => error⁰}: 661
//│ [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)]: 708 --->
//│ 	case _lh_sum_arg2¹ of {LH_N  => _lh_sum_arg1¹ | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => sum_₀((_lh_sum_arg1¹ + _lh_sum_LH_C_0¹), _lh_sum_LH_C_1¹) | _  => error⁰}: 661
//│ [LH_N]: 719 --->
//│ 	case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 710
//│ [LH_C a⁷ [LH_N]]: 720 --->
//│ 	case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 710
//│ [LH_C a⁷ [LH_C a⁷ [LH_N]]]: 721 --->
//│ 	case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 710
//│ ------------------
//│ case _lh_sum_arg2¹ of {LH_N  => _lh_sum_arg1¹ | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => sum_₀((_lh_sum_arg1¹ + _lh_sum_LH_C_0¹), _lh_sum_LH_C_1¹) | _  => error⁰}: 661 --->
//│ 	[LH_N]: 685
//│ 	[LH_C h¹⁹ mappend_₀(t²¹, ys⁹)]: 708
//│ case _lh_flatMap_arg2¹ of {LH_N  => [LH_N] | LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => mappend_₀(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_₀(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹)) | _  => error⁰}: 698 --->
//│ 	[LH_C a⁶ enumFromTo_₀((a⁶ + 1), b²)]: 679
//│ 	[LH_N]: 680
//│ case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 710 --->
//│ 	[LH_N]: 719
//│ 	[LH_C a⁷ [LH_N]]: 720
//│ 	[LH_C a⁷ [LH_C a⁷ [LH_N]]]: 721
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumFlatmapEnum_₀(primId⁰(100000))
//│ def enumFromTo_₀(a⁹, b³) = if (a⁹ <= b³) then 
//│ 	let _lh_flatMap_LH_C_1² = enumFromTo_₀((a⁹ + 1), b³)
//│ 	in let _lh_flatMap_LH_C_0² = a⁹
//│ 	in (fun _lh_flatMap_arg1³ -> mappend_₀(_lh_flatMap_arg1³(_lh_flatMap_LH_C_0²), flatMap_₀(_lh_flatMap_arg1³, _lh_flatMap_LH_C_1²))) else (fun _lh_flatMap_arg1⁴ -> (fun _lh_sum_arg1⁴ -> _lh_sum_arg1⁴))
//│ def flatMap_₀(_lh_flatMap_arg1², _lh_flatMap_arg2²) = _lh_flatMap_arg2²(_lh_flatMap_arg1²)
//│ def mappend_₀(xs¹⁰, ys¹³) = xs¹⁰(ys¹³)
//│ def sum_₀(_lh_sum_arg1⁵, _lh_sum_arg2²) = _lh_sum_arg2²(_lh_sum_arg1⁵)
//│ def testSumFlatmapEnum_₀(_lh_testSumFlatmapEnum_arg1²) = sum_₀(0, flatMap_₀((fun a⁸ -> 
//│ 	let t²² = 	
//│ 		let t²³ = (fun ys¹² -> ys¹²)
//│ 		in let h²¹ = a⁸
//│ 		in (fun ys¹¹ -> 
//│ 			let _lh_sum_LH_C_1³ = mappend_₀(t²³, ys¹¹)
//│ 			in let _lh_sum_LH_C_0³ = h²¹
//│ 			in (fun _lh_sum_arg1³ -> sum_₀((_lh_sum_arg1³ + _lh_sum_LH_C_0³), _lh_sum_LH_C_1³)))
//│ 	in let h²⁰ = a⁸
//│ 	in (fun ys¹⁰ -> 
//│ 		let _lh_sum_LH_C_1² = mappend_₀(t²², ys¹⁰)
//│ 		in let _lh_sum_LH_C_0² = h²⁰
//│ 		in (fun _lh_sum_arg1² -> sum_₀((_lh_sum_arg1² + _lh_sum_LH_C_0²), _lh_sum_LH_C_1²)))), enumFromTo_₀(1, _lh_testSumFlatmapEnum_arg1²)))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
flatMap f [] = []
flatMap f (h:t) = (f h) ++ (flatMap f t)
sum s [] = s
sum s (h:t) = sum (s+h) t
testSumFlatmap n = sum 0 $ flatMap (\a -> [a, a]) (primId [1..n])
testSumFlatmap $ primId 100000
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumFlatmap_₀^736(primId⁰(100000))
//│ def enumFromTo_₀(a⁷, b²) = if (a⁷ <= b²) then [LH_C a⁷ enumFromTo_₀^722((a⁷ + 1), b²)] else [LH_N]
//│ def flatMap_₀(_lh_flatMap_arg1¹, _lh_flatMap_arg2¹) = case _lh_flatMap_arg2¹ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => mappend_₀^653(_lh_flatMap_arg1¹(_lh_flatMap_LH_C_0¹), flatMap_₀^658(_lh_flatMap_arg1¹, _lh_flatMap_LH_C_1¹))
//│ 	| _  => error⁰}
//│ def mappend_₀(xs⁹, ys⁹) = case xs⁹ of {
//│ 	LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀^670(t²¹, ys⁹)]
//│ 	| LH_N  => ys⁹}
//│ def sum_₀(_lh_sum_arg1¹, _lh_sum_arg2¹) = case _lh_sum_arg2¹ of {
//│ 	LH_N  => _lh_sum_arg1¹
//│ 	| LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => sum_₀^703((_lh_sum_arg1¹ + _lh_sum_LH_C_0¹), _lh_sum_LH_C_1¹)
//│ 	| _  => error⁰}
//│ def testSumFlatmap_₀(_lh_testSumFlatmap_arg1¹) = sum_₀^680(0, flatMap_₀^683((fun a⁶ -> [LH_C a⁶ [LH_C a⁶ [LH_N]]]), primId⁰(enumFromTo_₀^692(1, _lh_testSumFlatmap_arg1¹))))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo__d0 a_7 b_2 =
//│ 		  (if (a_7 <= b_2) then
//│ 		    (`LH_C(a_7, ((enumFromTo__d0 (a_7 + 1)) b_2)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and flatMap__d0 _lh_flatMap_arg1_1 _lh_flatMap_arg2_1 =
//│ 		  (match _lh_flatMap_arg2_1 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_flatMap_LH_C_0_1, _lh_flatMap_LH_C_1_1) -> 
//│ 		      ((mappend__d0 (_lh_flatMap_arg1_1 _lh_flatMap_LH_C_0_1)) ((flatMap__d0 _lh_flatMap_arg1_1) _lh_flatMap_LH_C_1_1))
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and mappend__d0 xs_9 ys_9 =
//│ 		  (match xs_9 with
//│ 		    | `LH_C(h_1_9, t_2_1) -> 
//│ 		      (`LH_C(h_1_9, ((mappend__d0 t_2_1) ys_9)))
//│ 		    | `LH_N -> 
//│ 		      ys_9)
//│ 		and sum__d0 _lh_sum_arg1_1 _lh_sum_arg2_1 =
//│ 		  (match _lh_sum_arg2_1 with
//│ 		    | `LH_N -> 
//│ 		      _lh_sum_arg1_1
//│ 		    | `LH_C(_lh_sum_LH_C_0_1, _lh_sum_LH_C_1_1) -> 
//│ 		      ((sum__d0 (_lh_sum_arg1_1 + _lh_sum_LH_C_0_1)) _lh_sum_LH_C_1_1)
//│ 		    | _ -> 
//│ 		      (failwith "error"))
//│ 		and testSumFlatmap__d0 _lh_testSumFlatmap_arg1_1 =
//│ 		  ((sum__d0 0) ((flatMap__d0 (fun a_6 -> 
//│ 		    (`LH_C(a_6, (`LH_C(a_6, (`LH_N))))))) ((enumFromTo__d0 1) _lh_testSumFlatmap_arg1_1)));;
//│ 		(testSumFlatmap__d0 100000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_N]: 652 --->
//│ 	case _lh_sum_arg2¹ of {LH_N  => _lh_sum_arg1¹ | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => sum_₀((_lh_sum_arg1¹ + _lh_sum_LH_C_0¹), _lh_sum_LH_C_1¹) | _  => error⁰}: 713
//│ [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)]: 675 --->
//│ 	case _lh_sum_arg2¹ of {LH_N  => _lh_sum_arg1¹ | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => sum_₀((_lh_sum_arg1¹ + _lh_sum_LH_C_0¹), _lh_sum_LH_C_1¹) | _  => error⁰}: 713
//│ [LH_N]: 686 --->
//│ 	case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 677
//│ [LH_C a⁶ [LH_N]]: 687 --->
//│ 	case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 677
//│ [LH_C a⁶ [LH_C a⁶ [LH_N]]]: 688 --->
//│ 	case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 677
//│ ------------------
//│ case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 677 --->
//│ 	[LH_N]: 686
//│ 	[LH_C a⁶ [LH_N]]: 687
//│ 	[LH_C a⁶ [LH_C a⁶ [LH_N]]]: 688
//│ case _lh_sum_arg2¹ of {LH_N  => _lh_sum_arg1¹ | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => sum_₀((_lh_sum_arg1¹ + _lh_sum_LH_C_0¹), _lh_sum_LH_C_1¹) | _  => error⁰}: 713 --->
//│ 	[LH_N]: 652
//│ 	[LH_C h¹⁹ mappend_₀(t²¹, ys⁹)]: 675
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_N]: 652 --->
//│ 	case _lh_sum_arg2¹ of {LH_N  => _lh_sum_arg1¹ | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => sum_₀((_lh_sum_arg1¹ + _lh_sum_LH_C_0¹), _lh_sum_LH_C_1¹) | _  => error⁰}: 713
//│ [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)]: 675 --->
//│ 	case _lh_sum_arg2¹ of {LH_N  => _lh_sum_arg1¹ | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => sum_₀((_lh_sum_arg1¹ + _lh_sum_LH_C_0¹), _lh_sum_LH_C_1¹) | _  => error⁰}: 713
//│ [LH_N]: 686 --->
//│ 	case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 677
//│ [LH_C a⁶ [LH_N]]: 687 --->
//│ 	case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 677
//│ [LH_C a⁶ [LH_C a⁶ [LH_N]]]: 688 --->
//│ 	case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 677
//│ ------------------
//│ case xs⁹ of {LH_C h¹⁹ t²¹ => [LH_C h¹⁹ mappend_₀(t²¹, ys⁹)] | LH_N  => ys⁹}: 677 --->
//│ 	[LH_N]: 686
//│ 	[LH_C a⁶ [LH_N]]: 687
//│ 	[LH_C a⁶ [LH_C a⁶ [LH_N]]]: 688
//│ case _lh_sum_arg2¹ of {LH_N  => _lh_sum_arg1¹ | LH_C _lh_sum_LH_C_0¹ _lh_sum_LH_C_1¹ => sum_₀((_lh_sum_arg1¹ + _lh_sum_LH_C_0¹), _lh_sum_LH_C_1¹) | _  => error⁰}: 713 --->
//│ 	[LH_N]: 652
//│ 	[LH_C h¹⁹ mappend_₀(t²¹, ys⁹)]: 675
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumFlatmap_₀(primId⁰(100000))
//│ def enumFromTo_₀(a⁸, b³) = if (a⁸ <= b³) then [LH_C a⁸ enumFromTo_₀((a⁸ + 1), b³)] else [LH_N]
//│ def flatMap_₀(_lh_flatMap_arg1², _lh_flatMap_arg2²) = case _lh_flatMap_arg2² of {
//│ 	LH_N  => (fun _lh_sum_arg1² -> _lh_sum_arg1²)
//│ 	| LH_C _lh_flatMap_LH_C_0¹ _lh_flatMap_LH_C_1¹ => mappend_₀(_lh_flatMap_arg1²(_lh_flatMap_LH_C_0¹), flatMap_₀(_lh_flatMap_arg1², _lh_flatMap_LH_C_1¹))
//│ 	| _  => error⁰}
//│ def mappend_₀(xs¹⁰, ys¹⁰) = xs¹⁰(ys¹⁰)
//│ def sum_₀(_lh_sum_arg1³, _lh_sum_arg2²) = _lh_sum_arg2²(_lh_sum_arg1³)
//│ def testSumFlatmap_₀(_lh_testSumFlatmap_arg1²) = sum_₀(0, flatMap_₀((fun a⁹ -> 
//│ 	let t²² = 	
//│ 		let t²³ = (fun ys¹³ -> ys¹³)
//│ 		in let h²¹ = a⁹
//│ 		in (fun ys¹² -> 
//│ 			let _lh_sum_LH_C_1³ = mappend_₀(t²³, ys¹²)
//│ 			in let _lh_sum_LH_C_0³ = h²¹
//│ 			in (fun _lh_sum_arg1⁵ -> sum_₀((_lh_sum_arg1⁵ + _lh_sum_LH_C_0³), _lh_sum_LH_C_1³)))
//│ 	in let h²⁰ = a⁹
//│ 	in (fun ys¹¹ -> 
//│ 		let _lh_sum_LH_C_1² = mappend_₀(t²², ys¹¹)
//│ 		in let _lh_sum_LH_C_0² = h²⁰
//│ 		in (fun _lh_sum_arg1⁴ -> sum_₀((_lh_sum_arg1⁴ + _lh_sum_LH_C_0²), _lh_sum_LH_C_1²)))), primId⁰(enumFromTo_₀(1, _lh_testSumFlatmap_arg1²))))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<


:lhGenOCaml
fun sqTree(t) = if t is
  T(v, l, r) then T(v * v, sqTree(l), sqTree(r))
  L then L
fun sumTree(t) = if t is
  T(v, l, r) then v + sumTree(l) + sumTree(r)
  L then 0
fun genTree(n) = if n > 0 then T(n, genTree(n - 1), genTree(n - 1)) else L
fun testSumSquareTree(n) = sumTree(sqTree(primId(genTree(n))))
testSumSquareTree(primId(18))
//│ |#fun| |sqTree|(|t|)| |#=| |#if| |t| |is|→|T|(|v|,| |l|,| |r|)| |#then| |T|(|v| |*| |v|,| |sqTree|(|l|)|,| |sqTree|(|r|)|)|↵|L| |#then| |L|←|↵|#fun| |sumTree|(|t|)| |#=| |#if| |t| |is|→|T|(|v|,| |l|,| |r|)| |#then| |v| |+| |sumTree|(|l|)| |+| |sumTree|(|r|)|↵|L| |#then| |0|←|↵|#fun| |genTree|(|n|)| |#=| |#if| |n| |>| |0| |#then| |T|(|n|,| |genTree|(|n| |-| |1|)|,| |genTree|(|n| |-| |1|)|)| |#else| |L|↵|#fun| |testSumSquareTree|(|n|)| |#=| |sumTree|(|sqTree|(|primId|(|genTree|(|n|)|)|)|)|↵|testSumSquareTree|(|primId|(|18|)|)|
//│ Parsed: {fun sqTree = t, => if t is ‹(T (v, l, r,)) then T (* (v,) (v,), sqTree (l,), sqTree (r,),); (L) then L›; fun sumTree = t, => if t is ‹(T (v, l, r,)) then + (+ (v,) (sumTree (l,),),) (sumTree (r,),); (L) then 0›; fun genTree = n, => if (> (n,) (0,)) then T (n, genTree (- (n,) (1,),), genTree (- (n,) (1,),),) else L; fun testSumSquareTree = n, => sumTree (sqTree (primId (genTree (n,),),),); testSumSquareTree (primId (18,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumSquareTree^68(primId⁰(18))
//│ def genTree(n⁰) = if (n⁰ > 0) then [T n⁰ genTree^40((n⁰ - 1)) genTree^47((n⁰ - 1))] else [L]
//│ def sqTree(t⁰) = case t⁰ of {
//│ 	T v⁰ l⁰ r⁰ => [T (v⁰ * v⁰) sqTree^7(l⁰) sqTree^10(r⁰)]
//│ 	| L  => [L]}
//│ def sumTree(t¹) = case t¹ of {
//│ 	T v¹ l¹ r¹ => ((v¹ + sumTree^22(l¹)) + sumTree^27(r¹))
//│ 	| L  => 0}
//│ def testSumSquareTree(n¹) = sumTree^58(sqTree^59(primId⁰(genTree^61(n¹))))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec genTree n_0 =
//│ 		  (if (n_0 > 0) then
//│ 		    (`T(n_0, (genTree (n_0 - 1)), (genTree (n_0 - 1))))
//│ 		  else
//│ 		    (`L))
//│ 		and sqTree t_0 =
//│ 		  (match t_0 with
//│ 		    | `T(v_0, l_0, r_0) -> 
//│ 		      (`T((v_0 * v_0), (sqTree l_0), (sqTree r_0)))
//│ 		    | `L -> 
//│ 		      (`L))
//│ 		and sumTree t_1 =
//│ 		  (match t_1 with
//│ 		    | `T(v_1, l_1, r_1) -> 
//│ 		      ((v_1 + (sumTree l_1)) + (sumTree r_1))
//│ 		    | `L -> 
//│ 		      0)
//│ 		and testSumSquareTree n_1 =
//│ 		  (sumTree (sqTree (genTree n_1)));;
//│ 		(testSumSquareTree 18)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> expansion >>>>>>>
//│ [testSumSquareTree^68] (hopeless to continue)
//│ 	[testSumSquareTree^68 · genTree^61] (using original def)
//│ 		[testSumSquareTree^68 · genTree^61 · genTree^40] ---> [testSumSquareTree^68 · genTree^61] (using original def)
//│ 		[testSumSquareTree^68 · genTree^61 · genTree^47] ---> [testSumSquareTree^68 · genTree^61] (using original def)
//│ 	[testSumSquareTree^68 · sqTree^59] (using original def)
//│ 		[testSumSquareTree^68 · sqTree^59 · sqTree^10] ---> [testSumSquareTree^68 · sqTree^59] (using original def)
//│ 		[testSumSquareTree^68 · sqTree^59 · sqTree^7] ---> [testSumSquareTree^68 · sqTree^59] (using original def)
//│ 	[testSumSquareTree^68 · sumTree^58] (using original def)
//│ 		[testSumSquareTree^68 · sumTree^58 · sumTree^22] ---> [testSumSquareTree^68 · sumTree^58] (using original def)
//│ 		[testSumSquareTree^68 · sumTree^58 · sumTree^27] ---> [testSumSquareTree^68 · sumTree^58] (using original def)
//│ <<<<<<< expansion <<<<<<<
//│ 
//│ >>>>>>> expanded program >>>>>>>
//│ testSumSquareTree_₀(primId⁰(18))
//│ def testSumSquareTree_₀(n²) = 
//│ 	sumTree_₀(sqTree_₀(primId⁰(genTree_₀(n²))))
//│ 	where
//│ 	def genTree_₀(n³) = 
//│ 		if (n³ > 0) then [T n³ genTree_₀((n³ - 1)) genTree_₀((n³ - 1))] else [L]
//│ 	def sqTree_₀(t³) = 
//│ 		case t³ of {
//│ 			T v³ l³ r³ => [T (v³ * v³) sqTree_₀(l³) sqTree_₀(r³)]
//│ 			| L  => [L]}
//│ 	def sumTree_₀(t²) = 
//│ 		case t² of {
//│ 			T v² l² r² => ((v² + sumTree_₀(l²)) + sumTree_₀(r²))
//│ 			| L  => 0}
//│ <<<<<<< expanded program <<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [T (v³ * v³) sqTree_₀(l³) sqTree_₀(r³)]: 102 --->
//│ 	case t² of {T v² l² r² => ((v² + sumTree_₀(l²)) + sumTree_₀(r²)) | L  => 0}: 88
//│ [L]: 103 --->
//│ 	case t² of {T v² l² r² => ((v² + sumTree_₀(l²)) + sumTree_₀(r²)) | L  => 0}: 88
//│ ------------------
//│ case t² of {T v² l² r² => ((v² + sumTree_₀(l²)) + sumTree_₀(r²)) | L  => 0}: 88 --->
//│ 	[T (v³ * v³) sqTree_₀(l³) sqTree_₀(r³)]: 102
//│ 	[L]: 103
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [T (v³ * v³) sqTree_₀(l³) sqTree_₀(r³)]: 102 --->
//│ 	case t² of {T v² l² r² => ((v² + sumTree_₀(l²)) + sumTree_₀(r²)) | L  => 0}: 88
//│ [L]: 103 --->
//│ 	case t² of {T v² l² r² => ((v² + sumTree_₀(l²)) + sumTree_₀(r²)) | L  => 0}: 88
//│ ------------------
//│ case t² of {T v² l² r² => ((v² + sumTree_₀(l²)) + sumTree_₀(r²)) | L  => 0}: 88 --->
//│ 	[T (v³ * v³) sqTree_₀(l³) sqTree_₀(r³)]: 102
//│ 	[L]: 103
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumSquareTree_₀(primId⁰(18))
//│ def testSumSquareTree_₀(n⁴) = 
//│ 	sumTree_₀(sqTree_₀(primId⁰(genTree_₀(n⁴))))
//│ 	where
//│ 	def genTree_₀(n⁵) = 
//│ 		if (n⁵ > 0) then [T n⁵ genTree_₀((n⁵ - 1)) genTree_₀((n⁵ - 1))] else [L]
//│ 	def sqTree_₀(t⁵) = 
//│ 		case t⁵ of {
//│ 			T v³ l³ r³ => 
//│ 				let r⁴ = sqTree_₀(r³)
//│ 				in let l⁴ = sqTree_₀(l³)
//│ 				in let v⁴ = (v³ * v³)
//│ 				in (fun _lh_dummy⁰ -> ((v⁴ + sumTree_₀(l⁴)) + sumTree_₀(r⁴)))
//│ 			| L  => (fun _lh_dummy¹ -> 0)}
//│ 	def sumTree_₀(t⁴) = 
//│ 		t⁴(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<



:lhInHaskell
:lhGenOCaml
summ xs = case xs of { [] -> 0; (h:t) -> h + (summ t) }
append xs ys = case xs of { [] -> ys; (h:t) -> h:(append t ys) }
flatten xss = case xss of { [] -> []; (h:t) -> append h (flatten t) }
testSumFlatten n = summ $ flatten n
sum2 ls = let k = ls in k 99
append2 xs ys p = case xs of { [] -> ys p; (h:t) -> let tt = append2 t ys in let hh = h in hh + sum2 tt }
flatten2 ls p = case ls of { [] -> 0; (h:t) -> append2 h (flatten2 t) p }
testManual n = sum2 $ flatten2 n
testSumFlatten $ primId [primId [1..n] | n <- primId [1..1000]]
testManual $ primId [primId [1..n] | n <- primId [1..1000]]
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testSumFlatten_₀^956(primId⁰(
//│ 	let _lh_listcomp_fun² = (fun _lh_listcomp_fun_para² -> case _lh_listcomp_fun_para² of {
//│ 		LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => [LH_C primId⁰(enumFromTo_₁^960(1, _lh_listcomp_fun_ls_h²)) _lh_listcomp_fun²(_lh_listcomp_fun_ls_t²)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun²(primId⁰(enumFromTo_₀^975(1, 1000)))))
//│ testManual_₀^985(primId⁰(
//│ 	let _lh_listcomp_fun³ = (fun _lh_listcomp_fun_para³ -> case _lh_listcomp_fun_para³ of {
//│ 		LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C primId⁰(enumFromTo_₃^989(1, _lh_listcomp_fun_ls_h³)) _lh_listcomp_fun³(_lh_listcomp_fun_ls_t³)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun³(primId⁰(enumFromTo_₂^1004(1, 1000)))))
//│ def append2_₀(_lh_append2_arg1¹, _lh_append2_arg2¹, _lh_append2_arg3¹) = 
//│ 	let _lh_matchIdent⁶ = _lh_append2_arg1¹
//│ 	in case _lh_matchIdent⁶ of {
//│ 		LH_N  => _lh_append2_arg2¹(_lh_append2_arg3¹)
//│ 		| LH_C _lh_append2_LH_C_0¹ _lh_append2_LH_C_1¹ => 
//│ 			let tt¹ = append2_₀^812(_lh_append2_LH_C_1¹, _lh_append2_arg2¹)
//│ 			in let hh¹ = _lh_append2_LH_C_0¹
//│ 			in (hh¹ + sum2_₀^821(tt¹))
//│ 		| _  => error⁰}
//│ def append_₀(_lh_append_arg1¹, _lh_append_arg2¹) = 
//│ 	let _lh_matchIdent⁵ = _lh_append_arg1¹
//│ 	in case _lh_matchIdent⁵ of {
//│ 		LH_N  => _lh_append_arg2¹
//│ 		| LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => [LH_C _lh_append_LH_C_0¹ append_₀^790(_lh_append_LH_C_1¹, _lh_append_arg2¹)]
//│ 		| _  => error⁰}
//│ def enumFromTo_₀(a⁸, b⁵) = if (a⁸ <= b⁵) then [LH_C a⁸ enumFromTo_₀^928((a⁸ + 1), b⁵)] else [LH_N]
//│ def enumFromTo_₁(a⁵, b²) = if (a⁵ <= b²) then [LH_C a⁵ enumFromTo_₁^772((a⁵ + 1), b²)] else [LH_N]
//│ def enumFromTo_₂(a⁷, b⁴) = if (a⁷ <= b⁴) then [LH_C a⁷ enumFromTo_₂^888((a⁷ + 1), b⁴)] else [LH_N]
//│ def enumFromTo_₃(a⁶, b³) = if (a⁶ <= b³) then [LH_C a⁶ enumFromTo_₃^862((a⁶ + 1), b³)] else [LH_N]
//│ def flatten2_₀(_lh_flatten2_arg1¹, _lh_flatten2_arg2¹) = 
//│ 	let _lh_matchIdent⁷ = _lh_flatten2_arg1¹
//│ 	in case _lh_matchIdent⁷ of {
//│ 		LH_N  => 0
//│ 		| LH_C _lh_flatten2_LH_C_0¹ _lh_flatten2_LH_C_1¹ => append2_₀^836(_lh_flatten2_LH_C_0¹, flatten2_₀^839(_lh_flatten2_LH_C_1¹), _lh_flatten2_arg2¹)
//│ 		| _  => error⁰}
//│ def flatten_₀(_lh_flatten_arg1¹) = 
//│ 	let _lh_matchIdent⁹ = _lh_flatten_arg1¹
//│ 	in case _lh_matchIdent⁹ of {
//│ 		LH_N  => [LH_N]
//│ 		| LH_C _lh_flatten_LH_C_0¹ _lh_flatten_LH_C_1¹ => append_₀^945(_lh_flatten_LH_C_0¹, flatten_₀^948(_lh_flatten_LH_C_1¹))
//│ 		| _  => error⁰}
//│ def sum2_₀(_lh_sum2_arg1²) = 
//│ 	let k² = _lh_sum2_arg1²
//│ 	in k²(99)
//│ def sum2_₁(_lh_sum2_arg1¹) = 
//│ 	let k¹ = _lh_sum2_arg1¹
//│ 	in k¹(99)
//│ def summ_₀(_lh_summ_arg1¹) = 
//│ 	let _lh_matchIdent⁸ = _lh_summ_arg1¹
//│ 	in case _lh_matchIdent⁸ of {
//│ 		LH_N  => 0
//│ 		| LH_C _lh_summ_LH_C_0¹ _lh_summ_LH_C_1¹ => (_lh_summ_LH_C_0¹ + summ_₀^908(_lh_summ_LH_C_1¹))
//│ 		| _  => error⁰}
//│ def testManual_₀(_lh_testManual_arg1¹) = sum2_₁^850(flatten2_₀^851(_lh_testManual_arg1¹))
//│ def testSumFlatten_₀(_lh_testSumFlatten_arg1¹) = summ_₀^801(flatten_₀^802(_lh_testSumFlatten_arg1¹))
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec append2__d0 _lh_append2_arg1_1 _lh_append2_arg2_1 _lh_append2_arg3_1 =
//│ 		  (let rec _lh_matchIdent_6 = _lh_append2_arg1_1 in
//│ 		    (match _lh_matchIdent_6 with
//│ 		      | `LH_N -> 
//│ 		        (_lh_append2_arg2_1 _lh_append2_arg3_1)
//│ 		      | `LH_C(_lh_append2_LH_C_0_1, _lh_append2_LH_C_1_1) -> 
//│ 		        (let rec tt_1 = ((append2__d0 _lh_append2_LH_C_1_1) _lh_append2_arg2_1) in
//│ 		          (let rec hh_1 = _lh_append2_LH_C_0_1 in
//│ 		            (hh_1 + (sum2__d0 tt_1))))
//│ 		      | _ -> 
//│ 		        (failwith "error")))
//│ 		and append__d0 _lh_append_arg1_1 _lh_append_arg2_1 =
//│ 		  (let rec _lh_matchIdent_5 = _lh_append_arg1_1 in
//│ 		    (match _lh_matchIdent_5 with
//│ 		      | `LH_N -> 
//│ 		        _lh_append_arg2_1
//│ 		      | `LH_C(_lh_append_LH_C_0_1, _lh_append_LH_C_1_1) -> 
//│ 		        (`LH_C(_lh_append_LH_C_0_1, ((append__d0 _lh_append_LH_C_1_1) _lh_append_arg2_1)))
//│ 		      | _ -> 
//│ 		        (failwith "error")))
//│ 		and enumFromTo__d0 a_8 b_5 =
//│ 		  (if (a_8 <= b_5) then
//│ 		    (`LH_C(a_8, ((enumFromTo__d0 (a_8 + 1)) b_5)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and enumFromTo__d1 a_5 b_2 =
//│ 		  (if (a_5 <= b_2) then
//│ 		    (`LH_C(a_5, ((enumFromTo__d1 (a_5 + 1)) b_2)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and enumFromTo__d2 a_7 b_4 =
//│ 		  (if (a_7 <= b_4) then
//│ 		    (`LH_C(a_7, ((enumFromTo__d2 (a_7 + 1)) b_4)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and enumFromTo__d3 a_6 b_3 =
//│ 		  (if (a_6 <= b_3) then
//│ 		    (`LH_C(a_6, ((enumFromTo__d3 (a_6 + 1)) b_3)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and flatten2__d0 _lh_flatten2_arg1_1 _lh_flatten2_arg2_1 =
//│ 		  (let rec _lh_matchIdent_7 = _lh_flatten2_arg1_1 in
//│ 		    (match _lh_matchIdent_7 with
//│ 		      | `LH_N -> 
//│ 		        0
//│ 		      | `LH_C(_lh_flatten2_LH_C_0_1, _lh_flatten2_LH_C_1_1) -> 
//│ 		        (((append2__d0 _lh_flatten2_LH_C_0_1) (flatten2__d0 _lh_flatten2_LH_C_1_1)) _lh_flatten2_arg2_1)
//│ 		      | _ -> 
//│ 		        (failwith "error")))
//│ 		and flatten__d0 _lh_flatten_arg1_1 =
//│ 		  (let rec _lh_matchIdent_9 = _lh_flatten_arg1_1 in
//│ 		    (match _lh_matchIdent_9 with
//│ 		      | `LH_N -> 
//│ 		        (`LH_N)
//│ 		      | `LH_C(_lh_flatten_LH_C_0_1, _lh_flatten_LH_C_1_1) -> 
//│ 		        ((append__d0 _lh_flatten_LH_C_0_1) (flatten__d0 _lh_flatten_LH_C_1_1))
//│ 		      | _ -> 
//│ 		        (failwith "error")))
//│ 		and sum2__d0 _lh_sum2_arg1_2 =
//│ 		  (let rec k_2 = _lh_sum2_arg1_2 in
//│ 		    (k_2 99))
//│ 		and sum2__d1 _lh_sum2_arg1_1 =
//│ 		  (let rec k_1 = _lh_sum2_arg1_1 in
//│ 		    (k_1 99))
//│ 		and summ__d0 _lh_summ_arg1_1 =
//│ 		  (let rec _lh_matchIdent_8 = _lh_summ_arg1_1 in
//│ 		    (match _lh_matchIdent_8 with
//│ 		      | `LH_N -> 
//│ 		        0
//│ 		      | `LH_C(_lh_summ_LH_C_0_1, _lh_summ_LH_C_1_1) -> 
//│ 		        (_lh_summ_LH_C_0_1 + (summ__d0 _lh_summ_LH_C_1_1))
//│ 		      | _ -> 
//│ 		        (failwith "error")))
//│ 		and testManual__d0 _lh_testManual_arg1_1 =
//│ 		  (sum2__d1 (flatten2__d0 _lh_testManual_arg1_1))
//│ 		and testSumFlatten__d0 _lh_testSumFlatten_arg1_1 =
//│ 		  (summ__d0 (flatten__d0 _lh_testSumFlatten_arg1_1));;
//│ 		(testSumFlatten__d0 (let rec _lh_listcomp_fun_2 = (fun _lh_listcomp_fun_para_2 -> 
//│ 		  (match _lh_listcomp_fun_para_2 with
//│ 		    | `LH_C(_lh_listcomp_fun_ls_h_2, _lh_listcomp_fun_ls_t_2) -> 
//│ 		      (`LH_C(((enumFromTo__d1 1) _lh_listcomp_fun_ls_h_2), (_lh_listcomp_fun_2 _lh_listcomp_fun_ls_t_2)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))) in
//│ 		  (_lh_listcomp_fun_2 ((enumFromTo__d0 1) 1000))))
//│ 		(testManual__d0 (let rec _lh_listcomp_fun_3 = (fun _lh_listcomp_fun_para_3 -> 
//│ 		  (match _lh_listcomp_fun_para_3 with
//│ 		    | `LH_C(_lh_listcomp_fun_ls_h_3, _lh_listcomp_fun_ls_t_3) -> 
//│ 		      (`LH_C(((enumFromTo__d3 1) _lh_listcomp_fun_ls_h_3), (_lh_listcomp_fun_3 _lh_listcomp_fun_ls_t_3)))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N))) in
//│ 		  (_lh_listcomp_fun_3 ((enumFromTo__d2 1) 1000))))
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C _lh_append_LH_C_0¹ append_₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 795 --->
//│ 	case _lh_matchIdent⁸ of {LH_N  => 0 | LH_C _lh_summ_LH_C_0¹ _lh_summ_LH_C_1¹ => (_lh_summ_LH_C_0¹ + summ_₀(_lh_summ_LH_C_1¹)) | _  => error⁰}: 913
//│ [LH_N]: 944 --->
//│ 	case _lh_matchIdent⁸ of {LH_N  => 0 | LH_C _lh_summ_LH_C_0¹ _lh_summ_LH_C_1¹ => (_lh_summ_LH_C_0¹ + summ_₀(_lh_summ_LH_C_1¹)) | _  => error⁰}: 913
//│ ------------------
//│ case _lh_matchIdent⁸ of {LH_N  => 0 | LH_C _lh_summ_LH_C_0¹ _lh_summ_LH_C_1¹ => (_lh_summ_LH_C_0¹ + summ_₀(_lh_summ_LH_C_1¹)) | _  => error⁰}: 913 --->
//│ 	[LH_C _lh_append_LH_C_0¹ append_₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 795
//│ 	[LH_N]: 944
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C _lh_append_LH_C_0¹ append_₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 795 --->
//│ 	case _lh_matchIdent⁸ of {LH_N  => 0 | LH_C _lh_summ_LH_C_0¹ _lh_summ_LH_C_1¹ => (_lh_summ_LH_C_0¹ + summ_₀(_lh_summ_LH_C_1¹)) | _  => error⁰}: 913
//│ [LH_N]: 944 --->
//│ 	case _lh_matchIdent⁸ of {LH_N  => 0 | LH_C _lh_summ_LH_C_0¹ _lh_summ_LH_C_1¹ => (_lh_summ_LH_C_0¹ + summ_₀(_lh_summ_LH_C_1¹)) | _  => error⁰}: 913
//│ ------------------
//│ case _lh_matchIdent⁸ of {LH_N  => 0 | LH_C _lh_summ_LH_C_0¹ _lh_summ_LH_C_1¹ => (_lh_summ_LH_C_0¹ + summ_₀(_lh_summ_LH_C_1¹)) | _  => error⁰}: 913 --->
//│ 	[LH_C _lh_append_LH_C_0¹ append_₀(_lh_append_LH_C_1¹, _lh_append_arg2¹)]: 795
//│ 	[LH_N]: 944
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testSumFlatten_₀(primId⁰(
//│ 	let _lh_listcomp_fun⁴ = (fun _lh_listcomp_fun_para⁴ -> case _lh_listcomp_fun_para⁴ of {
//│ 		LH_C _lh_listcomp_fun_ls_h² _lh_listcomp_fun_ls_t² => [LH_C primId⁰(enumFromTo_₁(1, _lh_listcomp_fun_ls_h²)) _lh_listcomp_fun⁴(_lh_listcomp_fun_ls_t²)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun⁴(primId⁰(enumFromTo_₀(1, 1000)))))
//│ testManual_₀(primId⁰(
//│ 	let _lh_listcomp_fun⁵ = (fun _lh_listcomp_fun_para⁵ -> case _lh_listcomp_fun_para⁵ of {
//│ 		LH_C _lh_listcomp_fun_ls_h³ _lh_listcomp_fun_ls_t³ => [LH_C primId⁰(enumFromTo_₃(1, _lh_listcomp_fun_ls_h³)) _lh_listcomp_fun⁵(_lh_listcomp_fun_ls_t³)]
//│ 		| LH_N  => [LH_N]})
//│ 	in _lh_listcomp_fun⁵(primId⁰(enumFromTo_₂(1, 1000)))))
//│ def append2_₀(_lh_append2_arg1², _lh_append2_arg2², _lh_append2_arg3²) = 
//│ 	let _lh_matchIdent¹⁴ = _lh_append2_arg1²
//│ 	in case _lh_matchIdent¹⁴ of {
//│ 		LH_N  => _lh_append2_arg2²(_lh_append2_arg3²)
//│ 		| LH_C _lh_append2_LH_C_0¹ _lh_append2_LH_C_1¹ => 
//│ 			let tt² = append2_₀(_lh_append2_LH_C_1¹, _lh_append2_arg2²)
//│ 			in let hh² = _lh_append2_LH_C_0¹
//│ 			in (hh² + sum2_₀(tt²))
//│ 		| _  => error⁰}
//│ def append_₀(_lh_append_arg1², _lh_append_arg2²) = 
//│ 	let _lh_matchIdent¹¹ = _lh_append_arg1²
//│ 	in case _lh_matchIdent¹¹ of {
//│ 		LH_N  => _lh_append_arg2²
//│ 		| LH_C _lh_append_LH_C_0¹ _lh_append_LH_C_1¹ => 
//│ 			let _lh_summ_LH_C_1² = append_₀(_lh_append_LH_C_1¹, _lh_append_arg2²)
//│ 			in let _lh_summ_LH_C_0² = _lh_append_LH_C_0¹
//│ 			in (fun _lh_dummy⁰ -> (_lh_summ_LH_C_0² + summ_₀(_lh_summ_LH_C_1²)))
//│ 		| _  => error⁰}
//│ def enumFromTo_₀(a¹⁰, b⁷) = if (a¹⁰ <= b⁷) then [LH_C a¹⁰ enumFromTo_₀((a¹⁰ + 1), b⁷)] else [LH_N]
//│ def enumFromTo_₁(a⁹, b⁶) = if (a⁹ <= b⁶) then [LH_C a⁹ enumFromTo_₁((a⁹ + 1), b⁶)] else [LH_N]
//│ def enumFromTo_₂(a¹², b⁹) = if (a¹² <= b⁹) then [LH_C a¹² enumFromTo_₂((a¹² + 1), b⁹)] else [LH_N]
//│ def enumFromTo_₃(a¹¹, b⁸) = if (a¹¹ <= b⁸) then [LH_C a¹¹ enumFromTo_₃((a¹¹ + 1), b⁸)] else [LH_N]
//│ def flatten2_₀(_lh_flatten2_arg1², _lh_flatten2_arg2²) = 
//│ 	let _lh_matchIdent¹⁰ = _lh_flatten2_arg1²
//│ 	in case _lh_matchIdent¹⁰ of {
//│ 		LH_N  => 0
//│ 		| LH_C _lh_flatten2_LH_C_0¹ _lh_flatten2_LH_C_1¹ => append2_₀(_lh_flatten2_LH_C_0¹, flatten2_₀(_lh_flatten2_LH_C_1¹), _lh_flatten2_arg2²)
//│ 		| _  => error⁰}
//│ def flatten_₀(_lh_flatten_arg1²) = 
//│ 	let _lh_matchIdent¹² = _lh_flatten_arg1²
//│ 	in case _lh_matchIdent¹² of {
//│ 		LH_N  => (fun _lh_dummy¹ -> 0)
//│ 		| LH_C _lh_flatten_LH_C_0¹ _lh_flatten_LH_C_1¹ => append_₀(_lh_flatten_LH_C_0¹, flatten_₀(_lh_flatten_LH_C_1¹))
//│ 		| _  => error⁰}
//│ def sum2_₀(_lh_sum2_arg1⁴) = 
//│ 	let k⁴ = _lh_sum2_arg1⁴
//│ 	in k⁴(99)
//│ def sum2_₁(_lh_sum2_arg1³) = 
//│ 	let k³ = _lh_sum2_arg1³
//│ 	in k³(99)
//│ def summ_₀(_lh_summ_arg1²) = 
//│ 	let _lh_matchIdent¹³ = _lh_summ_arg1²
//│ 	in _lh_matchIdent¹³(99)
//│ def testManual_₀(_lh_testManual_arg1²) = sum2_₁(flatten2_₀(_lh_testManual_arg1²))
//│ def testSumFlatten_₀(_lh_testSumFlatten_arg1²) = summ_₀(flatten_₀(_lh_testSumFlatten_arg1²))
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<

:lhInHaskell
:lhGenOCaml
testZipEnumEnum n = zip [1..n] [1..n]
testZipEnumEnum $ primId 100000
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ testZipEnumEnum_₀^694(primId⁰(100000))
//│ def enumFromTo_₀(a⁶, b³) = if (a⁶ <= b³) then [LH_C a⁶ enumFromTo_₀^680((a⁶ + 1), b³)] else [LH_N]
//│ def enumFromTo_₁(a⁵, b²) = if (a⁵ <= b²) then [LH_C a⁵ enumFromTo_₁^660((a⁵ + 1), b²)] else [LH_N]
//│ def testZipEnumEnum_₀(_lh_testZipEnumEnum_arg1¹) = zip_₀^640(enumFromTo_₀^641(1, _lh_testZipEnumEnum_arg1¹), enumFromTo_₁^647(1, _lh_testZipEnumEnum_arg1¹))
//│ def zip_₀(xs⁹, ys⁹) = case xs⁹ of {
//│ 	LH_C hx⁸ tx⁸ => case ys⁹ of {
//│ 		LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀^628(tx⁸, ty⁸)]
//│ 		| LH_N  => [LH_N]}
//│ 	| LH_N  => [LH_N]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec enumFromTo__d0 a_6 b_3 =
//│ 		  (if (a_6 <= b_3) then
//│ 		    (`LH_C(a_6, ((enumFromTo__d0 (a_6 + 1)) b_3)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and enumFromTo__d1 a_5 b_2 =
//│ 		  (if (a_5 <= b_2) then
//│ 		    (`LH_C(a_5, ((enumFromTo__d1 (a_5 + 1)) b_2)))
//│ 		  else
//│ 		    (`LH_N))
//│ 		and testZipEnumEnum__d0 _lh_testZipEnumEnum_arg1_1 =
//│ 		  ((zip__d0 ((enumFromTo__d0 1) _lh_testZipEnumEnum_arg1_1)) ((enumFromTo__d1 1) _lh_testZipEnumEnum_arg1_1))
//│ 		and zip__d0 xs_9 ys_9 =
//│ 		  (match xs_9 with
//│ 		    | `LH_C(hx_8, tx_8) -> 
//│ 		      (match ys_9 with
//│ 		        | `LH_C(hy_8, ty_8) -> 
//│ 		          (`LH_C((`LH_P2(hx_8, hy_8)), ((zip__d0 tx_8) ty_8)))
//│ 		        | `LH_N -> 
//│ 		          (`LH_N))
//│ 		    | `LH_N -> 
//│ 		      (`LH_N));;
//│ 		(testZipEnumEnum__d0 100000)
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [LH_C a⁵ enumFromTo_₁((a⁵ + 1), b²)]: 669 --->
//│ 	case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]}: 635
//│ [LH_N]: 670 --->
//│ 	case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]}: 635
//│ [LH_C a⁶ enumFromTo_₀((a⁶ + 1), b³)]: 689 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 637
//│ [LH_N]: 690 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 637
//│ ------------------
//│ case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]}: 635 --->
//│ 	[LH_C a⁵ enumFromTo_₁((a⁵ + 1), b²)]: 669
//│ 	[LH_N]: 670
//│ case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 637 --->
//│ 	[LH_C a⁶ enumFromTo_₀((a⁶ + 1), b³)]: 689
//│ 	[LH_N]: 690
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [LH_C a⁵ enumFromTo_₁((a⁵ + 1), b²)]: 669 --->
//│ 	case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]}: 635
//│ [LH_N]: 670 --->
//│ 	case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]}: 635
//│ [LH_C a⁶ enumFromTo_₀((a⁶ + 1), b³)]: 689 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 637
//│ [LH_N]: 690 --->
//│ 	case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 637
//│ ------------------
//│ case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]}: 635 --->
//│ 	[LH_C a⁵ enumFromTo_₁((a⁵ + 1), b²)]: 669
//│ 	[LH_N]: 670
//│ case xs⁹ of {LH_C hx⁸ tx⁸ => case ys⁹ of {LH_C hy⁸ ty⁸ => [LH_C [LH_P2 hx⁸ hy⁸] zip_₀(tx⁸, ty⁸)] | LH_N  => [LH_N]} | LH_N  => [LH_N]}: 637 --->
//│ 	[LH_C a⁶ enumFromTo_₀((a⁶ + 1), b³)]: 689
//│ 	[LH_N]: 690
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ testZipEnumEnum_₀(primId⁰(100000))
//│ def enumFromTo_₀(a⁸, b⁵) = if (a⁸ <= b⁵) then 
//│ 	let tx¹¹ = enumFromTo_₀((a⁸ + 1), b⁵)
//│ 	in let hx¹¹ = a⁸
//│ 	in (fun ys¹¹ -> ys¹¹(hx¹¹, tx¹¹)) else (fun ys¹² -> [LH_N])
//│ def enumFromTo_₁(a⁷, b⁴) = if (a⁷ <= b⁴) then 
//│ 	let ty⁹ = enumFromTo_₁((a⁷ + 1), b⁴)
//│ 	in let hy⁹ = a⁷
//│ 	in (fun hx⁹ -> (fun tx⁹ -> [LH_C [LH_P2 hx⁹ hy⁹] zip_₀(tx⁹, ty⁹)])) else (fun hx¹⁰ -> (fun tx¹⁰ -> [LH_N]))
//│ def testZipEnumEnum_₀(_lh_testZipEnumEnum_arg1²) = zip_₀(enumFromTo_₀(1, _lh_testZipEnumEnum_arg1²), enumFromTo_₁(1, _lh_testZipEnumEnum_arg1²))
//│ def zip_₀(xs¹⁰, ys¹⁰) = xs¹⁰(ys¹⁰)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ benchmark file generated
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
