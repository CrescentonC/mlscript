:NewParser
:ParseOnly

_LUMBERHACK_EVAL
if C(A, B(D)) is
  C(a, bd) then if bd is
    B(d) then if a is
      A then OK
//│ |_LUMBERHACK_EVAL|↵|#if| |C|(|A|,| |B|(|D|)|)| |is|→|C|(|a|,| |bd|)| |#then| |#if| |bd| |is|→|B|(|d|)| |#then| |#if| |a| |is|→|A| |#then| |OK|←|←|←|
//│ Parsed: {_LUMBERHACK_EVAL; if C (A, B (D,),) is ‹(C (a, bd,)) then if bd is ‹(B (d,)) then if a is ‹(A) then OK›››}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ case [C [A] [B [D]]] of {
//│ 	C a⁰ bd⁰ => case bd⁰ of {
//│ 		B d⁰ => case a⁰ of {
//│ 			A  => [OK]}}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [OK]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 1 --->
//│ 	case a⁰ of {A  => [OK]}: 8
//│ [B [D]]: 3 --->
//│ 	case bd⁰ of {B d⁰ => case a⁰ of {A  => [OK]}}: 9
//│ [C [A] [B [D]]]: 4 --->
//│ 	case [C [A] [B [D]]] of {C a⁰ bd⁰ => case bd⁰ of {B d⁰ => case a⁰ of {A  => [OK]}}}: 10
//│ ------------------
//│ case a⁰ of {A  => [OK]}: 8 --->
//│ 	[A]: 1
//│ case bd⁰ of {B d⁰ => case a⁰ of {A  => [OK]}}: 9 --->
//│ 	[B [D]]: 3
//│ case [C [A] [B [D]]] of {C a⁰ bd⁰ => case bd⁰ of {B d⁰ => case a⁰ of {A  => [OK]}}}: 10 --->
//│ 	[C [A] [B [D]]]: 4
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 1 --->
//│ 	case a⁰ of {A  => [OK]}: 8
//│ [B [D]]: 3 --->
//│ 	case bd⁰ of {B d⁰ => case a⁰ of {A  => [OK]}}: 9
//│ [C [A] [B [D]]]: 4 --->
//│ 	case [C [A] [B [D]]] of {C a⁰ bd⁰ => case bd⁰ of {B d⁰ => case a⁰ of {A  => [OK]}}}: 10
//│ ------------------
//│ case a⁰ of {A  => [OK]}: 8 --->
//│ 	[A]: 1
//│ case bd⁰ of {B d⁰ => case a⁰ of {A  => [OK]}}: 9 --->
//│ 	[B [D]]: 3
//│ case [C [A] [B [D]]] of {C a⁰ bd⁰ => case bd⁰ of {B d⁰ => case a⁰ of {A  => [OK]}}}: 10 --->
//│ 	[C [A] [B [D]]]: 4
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ let bd¹ = (fun a² -> a²)
//│ in let a¹ = [OK]
//│ in bd¹(a¹)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [OK]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ let bd⁰ = (fun a⁰ -> a⁰)
//│ in let a¹ = [OK]
//│ in bd⁰(a¹)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ let bd⁰ = (fun a⁰ -> a⁰)
//│ in let a¹ = [OK]
//│ in bd⁰(a¹)
//│ <<<<<<< after floating out <<<<<<<


if C(A, B(D)) is
  C(a, bd) then if bd is
    B(d) then (a => if a is
      A then OK
    )(a)
//│ |#if| |C|(|A|,| |B|(|D|)|)| |is|→|C|(|a|,| |bd|)| |#then| |#if| |bd| |is|→|B|(|d|)| |#then| |(|a| |=>| |#if| |a| |is|→|A| |#then| |OK|←|↵|)|(|a|)|←|←|
//│ Parsed: {if C (A, B (D,),) is ‹(C (a, bd,)) then if bd is ‹(B (d,)) then '(' a, => if a is ‹(A) then OK›, ')' (a,)››}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ case [C [A] [B [D]]] of {
//│ 	C a⁰ bd⁰ => case bd⁰ of {
//│ 		B d⁰ => (fun a¹ -> case a¹ of {
//│ 			A  => [OK]})(a⁰)}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 1 --->
//│ 	case a¹ of {A  => [OK]}: 8
//│ [B [D]]: 3 --->
//│ 	case bd⁰ of {B d⁰ => (fun a¹ -> case a¹ of {A  => [OK]})(a⁰)}: 12
//│ [C [A] [B [D]]]: 4 --->
//│ 	case [C [A] [B [D]]] of {C a⁰ bd⁰ => case bd⁰ of {B d⁰ => (fun a¹ -> case a¹ of {A  => [OK]})(a⁰)}}: 13
//│ ------------------
//│ case a¹ of {A  => [OK]}: 8 --->
//│ 	[A]: 1
//│ case bd⁰ of {B d⁰ => (fun a¹ -> case a¹ of {A  => [OK]})(a⁰)}: 12 --->
//│ 	[B [D]]: 3
//│ case [C [A] [B [D]]] of {C a⁰ bd⁰ => case bd⁰ of {B d⁰ => (fun a¹ -> case a¹ of {A  => [OK]})(a⁰)}}: 13 --->
//│ 	[C [A] [B [D]]]: 4
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 1 --->
//│ 	case a¹ of {A  => [OK]}: 8
//│ [B [D]]: 3 --->
//│ 	case bd⁰ of {B d⁰ => (fun a¹ -> case a¹ of {A  => [OK]})(a⁰)}: 12
//│ [C [A] [B [D]]]: 4 --->
//│ 	case [C [A] [B [D]]] of {C a⁰ bd⁰ => case bd⁰ of {B d⁰ => (fun a¹ -> case a¹ of {A  => [OK]})(a⁰)}}: 13
//│ ------------------
//│ case a¹ of {A  => [OK]}: 8 --->
//│ 	[A]: 1
//│ case bd⁰ of {B d⁰ => (fun a¹ -> case a¹ of {A  => [OK]})(a⁰)}: 12 --->
//│ 	[B [D]]: 3
//│ case [C [A] [B [D]]] of {C a⁰ bd⁰ => case bd⁰ of {B d⁰ => (fun a¹ -> case a¹ of {A  => [OK]})(a⁰)}}: 13 --->
//│ 	[C [A] [B [D]]]: 4
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ 	let bd¹ = (fun a³ -> (fun a⁴ -> a⁴)(a³))
//│ 	in let a² = [OK]
//│ 	in (fun _lh_dummy⁰ -> bd¹(a²))(99)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ 	let bd⁰ = (fun a⁰ -> (fun a¹ -> a¹)(a⁰))
//│ 	in let a² = [OK]
//│ 	in (fun _lh_dummy⁰ -> bd⁰(a²))(99)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ 	let bd⁰ = (fun a⁰ -> (fun a¹ -> a¹)(a⁰))
//│ 	in let a² = [OK]
//│ 	in (fun _lh_dummy⁰ -> bd⁰(a²))(99)
//│ <<<<<<< after floating out <<<<<<<
