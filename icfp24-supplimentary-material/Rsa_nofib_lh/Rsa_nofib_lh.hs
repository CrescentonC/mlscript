const0 = z_of_int 0
const31 = z_of_int 31
const1 = z_of_int 1
const2 = z_of_int 2
const128 = z_of_int 128
hash str = foldl (\acc -> \c -> z_add (z_of_int (int_of_char c)) (z_mul acc (const31))) (const0) str
and [] = True
and (h:t) = if h then (and t) else False
unlines ls = concat (map (\l -> l ++ ['n']) ls)
even a = z_equal (z_mod a (const2)) (const0)
drop n [] = []
drop n (h:t) = if n > 0 then (drop (n - 1) t) else (h:t)
encrypt n e = unlines . map (string_of_z . power e n . code) . collect (size n)
code ls = foldl (\x y -> z_add (z_mul (const128) x) (z_of_int (int_of_char y))) (const0) ls
collect 0 xs = []
collect n [] = []
collect n xs = (take n xs) : collect n (drop n xs)
size n = ((length (string_of_z n)) * 47) `div` 100
--- power 0 m x = 1
--- power n m x = if (even n) then ((sqr (power (n `div` 2) m x)) `mod` m) else ((x * (power (n-1) m x)) `mod` m)
power n m x = if (z_equal n (const0)) then
                (const1)
              else
                if (even n) then (z_mod (sqr (power (z_div n (const2)) m x)) m) else (z_mod (z_mul x (power (z_sub n (const1)) m x)) m)
sqr x = z_mul x x
input = from_large_str "module Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h------- Fast exponentiation, mod m -----------------power :: Integer -> Integer -> Integer -> Integerpower 0 m x          = 1power n m x | even n = sqr (power (n `div` 2) m x) `mod` m	    | True   = (x * power (n-1) m x) `mod` msqr :: Integer -> Integersqr x = x * x\\section{AbsDensematrix}This module imports the contents of Densematrix and exports some of thefunctions renaming many of them for use by Matrix. The original %includestatement(from Matrix) is left as a comment at the foot of this file.\\begin{code}module AbsDensematrix(Block,Vec,bmult,bvecmult,vecbmult,vecdot,vecnorm,                      vecouter,badd,bsub,vecadd,vecsub,bsize,vecsize,bneg,                      bxpose,bident,vecneg,svecmult,mkblock,bswaprow,bswapcol,                      bdroprow,bgetrow,bgetcol,bsubscript,vecsubscript,bupdate,                      vecupdate,vechd,vectl,mergevecs,binverse,showblock,                     showvec, mkvec,mkrvec,vecpart,update2,veclist,matlist)       whereimport Densematrixtype Block = Matrixtype Vec = Vectorbmult = mmultbvecmult = matvecmultvecbmult = vmmultvecdot   = vdotvecnorm = normvecouter = vouterbadd = maddbsub = msubvecadd = vaddvecsub = vsubbsize = msizevecsize = vsizebneg = mnegbxpose = mxposebident = midentvecneg = vnegsvecmult = svmultmkblock = mkmatbswaprow = swaprowbswapcol = swapcolbdroprow = droprowbgetrow = getrowbgetcol = getcolbsubscript = subscriptvecsubscript = vsubscriptbupdate = updatevecupdate = vupdatevechd = vhdvectl = vtlmergevecs = mergevectorsbinverse = minverseshowblock = showmatrixshowvec = displayvector\\end{code}The original include statement from Matrix :- %include \"densematrix\"                         block/matrix  vec/vector                         bmult/mmult   bvecmult/mvmult vecbmult/vmmult                         vecdot/vdot   vecnorm/norm    vecouter/vouterr                         badd/madd     bsub/msub  vecadd/vadd vecsub/vsub                         bsize/msize   vecsize/vsize                         bneg/mneg     bxpose/mxpose   bident/mident                         vecneg/vneg   svecmult/svmult                         mkblock/mkmat                         -mkrmat -mkcmat -mkcvec                         bswaprow/swaprow       bswapcol/swapcol                         bdroprow/droprow       bgetrow/getrow bgetcol/getcol                         bsubscript/subscript   vecsubscript/vsubscript                         bupdate/update         vecupdate/vupdate                         vechd/vhd              vectl/vtl                         mergevecs/mergevectors                         binverse/minverse                         showblock/showmatrix showvec/showvectormodule Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h------- Fast exponentiation, mod m -----------------power :: Integer -> Integer -> Integer -> Integerpower 0 m x          = 1power n m x | even n = sqr (power (n `div` 2) m x) `mod` m	    | True   = (x * power (n-1) m x) `mod` msqr :: Integer -> Integersqr x = x * x\\section{AbsDensematrix}This module imports the contents of Densematrix and exports some of thefunctions renaming many of them for use by Matrix. The original %includestatement(from Matrix) is left as a comment at the foot of this file.\\begin{code}module AbsDensematrix(Block,Vec,bmult,bvecmult,vecbmult,vecdot,vecnorm,                      vecouter,badd,bsub,vecadd,vecsub,bsize,vecsize,bneg,                      bxpose,bident,vecneg,svecmult,mkblock,bswaprow,bswapcol,                      bdroprow,bgetrow,bgetcol,bsubscript,vecsubscript,bupdate,                      vecupdate,vechd,vectl,mergevecs,binverse,showblock,                     showvec, mkvec,mkrvec,vecpart,update2,veclist,matlist)       whereimport Densematrixtype Block = Matrixtype Vec = Vectorbmult = mmultbvecmult = matvecmultvecbmult = vmmultvecdot   = vdotvecnorm = normvecouter = vouterbadd = maddbsub = msubvecadd = vaddvecsub = vsubbsize = msizevecsize = vsizebneg = mnegbxpose = mxposebident = midentvecneg = vnegsvecmult = svmultmkblock = mkmatbswaprow = swaprowbswapcol = swapcolbdroprow = droprowbgetrow = getrowbgetcol = getcolbsubscript = subscriptvecsubscript = vsubscriptbupdate = updatevecupdate = vupdatevechd = vhdvectl = vtlmergevecs = mergevectorsbinverse = minverseshowblock = showmatrixshowvec = displayvector\\end{code}The original include statement from Matrix :- %include \"densematrix\"                         block/matrix  vec/vector                         bmult/mmult   bvecmult/mvmult vecbmult/vmmult                         vecdot/vdot   vecnorm/norm    vecouter/vouterr                         badd/madd     bsub/msub  vecadd/vadd vecsub/vsub                         bsize/msize   vecsize/vsize                         bneg/mneg     bxpose/mxpose   bident/mident                         vecneg/vneg   svecmult/svmult                         mkblock/mkmat                         -mkrmat -mkcmat -mkcvec                         bswaprow/swaprow       bswapcol/swapcol                         bdroprow/droprow       bgetrow/getrow bgetcol/getcol                         bsubscript/subscript   vecsubscript/vsubscript                         bupdate/update         vecupdate/vupdate                         vechd/vhd              vectl/vtl                         mergevecs/mergevectors                         binverse/minverse                         showblock/showmatrix showvec/showvectormodule Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h"
testRsa_nofib _ = hash (encrypt
                          (z_of_string "2036450659413645137870851576872812267542175329986469156678671505255564383842535488743101632280716717779536712424613501441720195827856504007305662157107")
                          (z_of_string "387784473137902876992546516170169092918207676456888779623592396031349415024943784869634893342729620092877891356118467738167515879252473323905128540213")
                          input
                        )
testRsa_nofib $ primId 0
