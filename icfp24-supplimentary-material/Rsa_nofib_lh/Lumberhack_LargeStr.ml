open Lumherhack_Common.Lumherhack_Common;;
module Lumberhack_LargeStr = struct
let lh_large_str_0 = listToTaggedList (explode_string "module Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h------- Fast exponentiation, mod m -----------------power :: Integer -> Integer -> Integer -> Integerpower 0 m x          = 1power n m x | even n = sqr (power (n `div` 2) m x) `mod` m	    | True   = (x * power (n-1) m x) `mod` msqr :: Integer -> Integersqr x = x * x\\section{AbsDensematrix}This module imports the contents of Densematrix and exports some of thefunctions renaming many of them for use by Matrix. The original %includestatement(from Matrix) is left as a comment at the foot of this file.\\begin{code}module AbsDensematrix(Block,Vec,bmult,bvecmult,vecbmult,vecdot,vecnorm,                      vecouter,badd,bsub,vecadd,vecsub,bsize,vecsize,bneg,                      bxpose,bident,vecneg,svecmult,mkblock,bswaprow,bswapcol,                      bdroprow,bgetrow,bgetcol,bsubscript,vecsubscript,bupdate,                      vecupdate,vechd,vectl,mergevecs,binverse,showblock,                     showvec, mkvec,mkrvec,vecpart,update2,veclist,matlist)       whereimport Densematrixtype Block = Matrixtype Vec = Vectorbmult = mmultbvecmult = matvecmultvecbmult = vmmultvecdot   = vdotvecnorm = normvecouter = vouterbadd = maddbsub = msubvecadd = vaddvecsub = vsubbsize = msizevecsize = vsizebneg = mnegbxpose = mxposebident = midentvecneg = vnegsvecmult = svmultmkblock = mkmatbswaprow = swaprowbswapcol = swapcolbdroprow = droprowbgetrow = getrowbgetcol = getcolbsubscript = subscriptvecsubscript = vsubscriptbupdate = updatevecupdate = vupdatevechd = vhdvectl = vtlmergevecs = mergevectorsbinverse = minverseshowblock = showmatrixshowvec = displayvector\\end{code}The original include statement from Matrix :- %include \"densematrix\"                         block/matrix  vec/vector                         bmult/mmult   bvecmult/mvmult vecbmult/vmmult                         vecdot/vdot   vecnorm/norm    vecouter/vouterr                         badd/madd     bsub/msub  vecadd/vadd vecsub/vsub                         bsize/msize   vecsize/vsize                         bneg/mneg     bxpose/mxpose   bident/mident                         vecneg/vneg   svecmult/svmult                         mkblock/mkmat                         -mkrmat -mkcmat -mkcvec                         bswaprow/swaprow       bswapcol/swapcol                         bdroprow/droprow       bgetrow/getrow bgetcol/getcol                         bsubscript/subscript   vecsubscript/vsubscript                         bupdate/update         vecupdate/vupdate                         vechd/vhd              vectl/vtl                         mergevecs/mergevectors                         binverse/minverse                         showblock/showmatrix showvec/showvectormodule Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h------- Fast exponentiation, mod m -----------------power :: Integer -> Integer -> Integer -> Integerpower 0 m x          = 1power n m x | even n = sqr (power (n `div` 2) m x) `mod` m	    | True   = (x * power (n-1) m x) `mod` msqr :: Integer -> Integersqr x = x * x\\section{AbsDensematrix}This module imports the contents of Densematrix and exports some of thefunctions renaming many of them for use by Matrix. The original %includestatement(from Matrix) is left as a comment at the foot of this file.\\begin{code}module AbsDensematrix(Block,Vec,bmult,bvecmult,vecbmult,vecdot,vecnorm,                      vecouter,badd,bsub,vecadd,vecsub,bsize,vecsize,bneg,                      bxpose,bident,vecneg,svecmult,mkblock,bswaprow,bswapcol,                      bdroprow,bgetrow,bgetcol,bsubscript,vecsubscript,bupdate,                      vecupdate,vechd,vectl,mergevecs,binverse,showblock,                     showvec, mkvec,mkrvec,vecpart,update2,veclist,matlist)       whereimport Densematrixtype Block = Matrixtype Vec = Vectorbmult = mmultbvecmult = matvecmultvecbmult = vmmultvecdot   = vdotvecnorm = normvecouter = vouterbadd = maddbsub = msubvecadd = vaddvecsub = vsubbsize = msizevecsize = vsizebneg = mnegbxpose = mxposebident = midentvecneg = vnegsvecmult = svmultmkblock = mkmatbswaprow = swaprowbswapcol = swapcolbdroprow = droprowbgetrow = getrowbgetcol = getcolbsubscript = subscriptvecsubscript = vsubscriptbupdate = updatevecupdate = vupdatevechd = vhdvectl = vtlmergevecs = mergevectorsbinverse = minverseshowblock = showmatrixshowvec = displayvector\\end{code}The original include statement from Matrix :- %include \"densematrix\"                         block/matrix  vec/vector                         bmult/mmult   bvecmult/mvmult vecbmult/vmmult                         vecdot/vdot   vecnorm/norm    vecouter/vouterr                         badd/madd     bsub/msub  vecadd/vadd vecsub/vsub                         bsize/msize   vecsize/vsize                         bneg/mneg     bxpose/mxpose   bident/mident                         vecneg/vneg   svecmult/svmult                         mkblock/mkmat                         -mkrmat -mkcmat -mkcvec                         bswaprow/swaprow       bswapcol/swapcol                         bdroprow/droprow       bgetrow/getrow bgetcol/getcol                         bsubscript/subscript   vecsubscript/vsubscript                         bupdate/update         vecupdate/vupdate                         vechd/vhd              vectl/vtl                         mergevecs/mergevectors                         binverse/minverse                         showblock/showmatrix showvec/showvectormodule Rsa (encrypt, decrypt, makeKeys)whereencrypt, decrypt :: Integer -> Integer -> String -> Stringencrypt n e = unlines . map (show . power e n . code) . collect (size n)decrypt n d = concat . map (decode . power d n . read) . lines-------- Converting between Strings and Integers -----------code :: String -> Integercode = foldl accum 0  where accum x y = (128 * x) + fromIntegral (fromEnum y)decode :: Integer -> Stringdecode n = reverse (expand n)   where expand 0 = []         expand x = toEnum (fromIntegral (x `mod` 128)) : expand (x `div` 128)collect :: Int -> [a] -> [[a]]collect 0 xs = []collect n [] = []collect n xs = take n xs : collect n (drop n xs)size :: Integer -> Intsize n = (length (show n) * 47) `div` 100	-- log_128 10 = 0.4745------- Constructing keys -------------------------makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)makeKeys p' q' = (n, invert phi d, d)   where   p = nextPrime p'           q = nextPrime q'	   n = p*q	   phi = (p-1)*(q-1)	   d = nextPrime (p+q+1)nextPrime :: Integer -> IntegernextPrime a = head (filter prime [odd,odd+2..])  where  odd | even a = a+1             | True   = a         prime p = and [power (p-1) p x == 1 | x <- [3,5,7]]invert :: Integer -> Integer -> Integerinvert n a = if e<0 then e+n else e  where  e=iter n 0 a 1iter :: Integer -> Integer -> Integer -> Integer -> Integeriter g v 0  w = viter g v h w = iter h w (g - fact * h) (v - fact * w)    where  fact = g `div` h");;
let lh_large_int_0 = Z.of_string "2036450659413645137870851576872812267542175329986469156678671505255564383842535488743101632280716717779536712424613501441720195827856504007305662157107";;
let lh_large_int_1 = Z.of_string "387784473137902876992546516170169092918207676456888779623592396031349415024943784869634893342729620092877891356118467738167515879252473323905128540213";;
end;;

